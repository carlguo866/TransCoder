<DOCUMENT_ID="pentaho/pentaho-kettle/tree/master/core/src/main/java/org/pentaho/di/core/Props.java"> package org . pentaho . di . core ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; import java . util . Properties ; import org . pentaho . di . core . exception . KettleValueException ; import org . pentaho . di . core . logging . LogChannel ; import org . pentaho . di . core . logging . LogChannelInterface ; import org . pentaho . di . core . row . ValueMetaInterface ; import org . pentaho . di . core . util . SortedFileOutputStream ; import org . pentaho . di . i18n . BaseMessages ; public class Props implements Cloneable { private static Class < ? > PKG = Const . class ; private static final String STRING_USER_PREFERENCES = " User ▁ preferences " ; protected static Props props ; public static final String STRING_FONT_FIXED_NAME = " FontFixedName " ; public static final String STRING_FONT_FIXED_SIZE = " FontFixedSize " ; public static final String STRING_FONT_FIXED_STYLE = " FontFixedStyle " ; public static final String STRING_FONT_DEFAULT_NAME = " FontDefaultName " ; public static final String STRING_FONT_DEFAULT_SIZE = " FontDefaultSize " ; public static final String STRING_FONT_DEFAULT_STYLE = " FontDefaultStyle " ; public static final String STRING_FONT_GRAPH_NAME = " FontGraphName " ; public static final String STRING_FONT_GRAPH_SIZE = " FontGraphSize " ; public static final String STRING_FONT_GRAPH_STYLE = " FontGraphStyle " ; public static final String STRING_FONT_GRID_NAME = " FontGridName " ; public static final String STRING_FONT_GRID_SIZE = " FontGridSize " ; public static final String STRING_FONT_GRID_STYLE = " FontGridStyle " ; public static final String STRING_FONT_NOTE_NAME = " FontNoteName " ; public static final String STRING_FONT_NOTE_SIZE = " FontNoteSize " ; public static final String STRING_FONT_NOTE_STYLE = " FontNoteStyle " ; public static final String STRING_BACKGROUND_COLOR_R = " BackgroundColorR " ; public static final String STRING_BACKGROUND_COLOR_G = " BackgroundColorG " ; public static final String STRING_BACKGROUND_COLOR_B = " BackgroundColorB " ; public static final String STRING_GRAPH_COLOR_R = " GraphColorR " ; public static final String STRING_GRAPH_COLOR_G = " GraphColorG " ; public static final String STRING_GRAPH_COLOR_B = " GraphColorB " ; public static final String STRING_TAB_COLOR_R = " TabColorR54" ; public static final String STRING_TAB_COLOR_G = " TabColorG54" ; public static final String STRING_TAB_COLOR_B = " TabColorB54" ; public static final String STRING_SVG_ENABLED = " EnableSVG " ; public static final String STRING_ICON_SIZE = " IconSize " ; public static final String STRING_LINE_WIDTH = " LineWidth " ; public static final String STRING_SHADOW_SIZE = " ShadowSize54" ; public static final String STRING_LOG_LEVEL = " LogLevel " ; public static final String STRING_LOG_FILTER = " LogFilter " ; public static final String STRING_MIDDLE_PCT = " MiddlePct " ; public static final String STRING_INDICATE_SLOW_TRANS_STEPS = " IndicateSlowTransSteps " ; public static final String STRING_LAST_PREVIEW_TRANS = " LastPreviewTrans " ; public static final String STRING_LAST_PREVIEW_STEP = " LastPreviewStep " ; public static final String STRING_LAST_PREVIEW_SIZE = " LastPreviewSize " ; public static final String STRING_MAX_UNDO = " MaxUndo " ; public static final String STRING_SIZE_MAX = " SizeMax " ; public static final String STRING_SIZE_X = " SizeX " ; public static final String STRING_SIZE_Y = " SizeY " ; public static final String STRING_SIZE_W = " SizeW " ; public static final String STRING_SIZE_H = " SizeH " ; public static final String STRING_SASH_W1 = " SashWeight1" ; public static final String STRING_SASH_W2 = " SashWeight2" ; public static final String STRING_AUTO_SAVE = " AutoSave " ; public static final String STRING_SAVE_CONF = " SaveConfirmation " ; public static final String STRING_AUTO_SPLIT = " AutoSplit " ; public static final String STRING_AUTO_COLLAPSE_CORE_TREE = " AutoCollapseCoreObjectsTree " ; public static final String STRING_USE_DB_CACHE = " UseDBCache " ; public static final String STRING_OPEN_LAST_FILE = " OpenLastFile " ; public static final String STRING_LAST_REPOSITORY_LOGIN = " RepositoryLastLogin " ; public static final String STRING_LAST_REPOSITORY = " RepositoryLast " ; public static final String STRING_ONLY_ACTIVE_STEPS = " OnlyActiveSteps " ; public static final String STRING_START_SHOW_REPOSITORIES = " ShowRepositoriesAtStartup " ; public static final String STRING_ANTI_ALIASING = " EnableAntiAliasing54" ; public static final String STRING_SHOW_CANVAS_GRID = " ShowCanvasGrid " ; public static final String STRING_SHOW_EXIT_WARNING = " ShowExitWarning " ; public static final String STRING_SHOW_OS_LOOK = " ShowOSLook54" ; public static final String STRING_LAST_ARGUMENT = " LastArgument " ; public static final String STRING_ARGUMENT_NAME_PREFIX = " Argument ▁ " ; public static final String STRING_CUSTOM_PARAMETER = " CustomParameter " ; public static final String STRING_PLUGIN_HISTORY = " PluginHistory " ; public static final String STRING_DEFAULT_PREVIEW_SIZE = " DefaultPreviewSize " ; public static final String STRING_ONLY_USED_DB_TO_XML = " SaveOnlyUsedConnectionsToXML " ; public static final String STRING_ASK_ABOUT_REPLACING_DATABASES = " AskAboutReplacingDatabases " ; public static final String STRING_REPLACE_DATABASES = " ReplaceDatabases " ; private static final String STRING_MAX_NR_LINES_IN_LOG = " MaxNrOfLinesInLog " ; private static final String STRING_MAX_NR_LINES_IN_HISTORY = " MaxNrOfLinesInHistory " ; private static final String STRING_LINES_IN_HISTORY_FETCH_SIZE = " LinesInHistoryFetchSize " ; public static final String STRING_DISABLE_INITIAL_EXECUTION_HISTORY = " DisableInitialExecutionHistory " ; private static final String STRING_MAX_LOG_LINE_TIMEOUT_MINUTES = " MaxLogLineTimeOutMinutes " ; public static final String STRING_RECENT_SEARCHES = " RecentSearches " ; public static final String STRING_SHOW_NEW_SUBTRANS_POPUP = " ShowNewSubtransPopup " ; protected LogChannelInterface log ; protected Properties properties ; protected ArrayList < ObjectUsageCount > pluginHistory ; protected int type ; protected String filename ; public static final int TYPE_PROPERTIES_EMPTY = 0 ; public static final int TYPE_PROPERTIES_SPOON = 1 ; public static final int TYPE_PROPERTIES_PAN = 2 ; public static final int TYPE_PROPERTIES_CHEF = 3 ; public static final int TYPE_PROPERTIES_KITCHEN = 4 ; public static final int TYPE_PROPERTIES_MENU = 5 ; public static final int TYPE_PROPERTIES_PLATE = 6 ; public static final int WIDGET_STYLE_DEFAULT = 0 ; public static final int WIDGET_STYLE_FIXED = 1 ; public static final int WIDGET_STYLE_TABLE = 2 ; public static final int WIDGET_STYLE_NOTEPAD = 3 ; public static final int WIDGET_STYLE_GRAPH = 4 ; public static final int WIDGET_STYLE_TAB = 5 ; public static final int WIDGET_STYLE_TOOLBAR = 6 ; public static final void init ( int t ) { if ( props == null ) { props = new Props ( t ) ; } else { throw new RuntimeException ( " The ▁ Properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } public static final void init ( String filename ) { if ( props == null ) { props = new Props ( filename ) ; } else { throw new RuntimeException ( " The ▁ properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } public static boolean isInitialized ( ) { return props != null ; } public static Props getInstance ( ) { if ( props != null ) { return props ; } throw new RuntimeException ( " Properties , ▁ Kettle ▁ systems ▁ settings , ▁ not ▁ initialised ! " ) ; } protected Props ( ) { init ( ) ; } protected Props ( int t ) { type = t ; filename = getFilename ( ) ; init ( ) ; } protected void init ( ) { createLogChannel ( ) ; properties = new Properties ( ) ; pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; loadProps ( ) ; addDefaultEntries ( ) ; loadPluginHistory ( ) ; } protected Props ( String filename ) { properties = new Properties ( ) ; this . type = TYPE_PROPERTIES_EMPTY ; this . filename = filename ; init ( ) ; } @ Override public String toString ( ) { return STRING_USER_PREFERENCES ; } protected void createLogChannel ( ) { log = new LogChannel ( STRING_USER_PREFERENCES ) ; } public String getFilename ( ) { String filename = " " ; String directory = Const . getKettleDirectory ( ) ; switch ( type ) { case TYPE_PROPERTIES_SPOON : case TYPE_PROPERTIES_PAN : filename = directory + Const . FILE_SEPARATOR + " . spoonrc " ; break ; case TYPE_PROPERTIES_CHEF : case TYPE_PROPERTIES_KITCHEN : filename = directory + Const . FILE_SEPARATOR + " . chefrc " ; break ; case TYPE_PROPERTIES_MENU : filename = directory + Const . FILE_SEPARATOR + " . menurc " ; break ; case TYPE_PROPERTIES_PLATE : filename = directory + Const . FILE_SEPARATOR + " . platerc " ; break ; default : break ; } return filename ; } public String getLicenseFilename ( ) { String directory = Const . getKettleDirectory ( ) ; String filename = directory + Const . FILE_SEPARATOR + " . licence " ; File dir = new File ( directory ) ; if ( ! dir . exists ( ) ) { try { dir . mkdirs ( ) ; } catch ( Exception e ) { } } return filename ; } public boolean fileExists ( ) { File f = new File ( filename ) ; return f . exists ( ) ; } public void setType ( int t ) { type = t ; } public int getType ( ) { return type ; } public boolean loadProps ( ) { try { FileInputStream fis = new FileInputStream ( filename ) ; try { properties . load ( fis ) ; } finally { try { fis . close ( ) ; } catch ( IOException ignored ) { } } } catch ( Exception e ) { return false ; } return true ; } protected void addDefaultEntries ( ) { if ( ! properties . containsKey ( " JobDialogStyle " ) ) { properties . setProperty ( " JobDialogStyle " , " RESIZE , MAX , MIN " ) ; } } public void saveProps ( ) { File spoonRc = new File ( filename ) ; try { SortedFileOutputStream fos = new SortedFileOutputStream ( spoonRc ) ; fos . setLogger ( log ) ; properties . store ( fos , " Kettle ▁ Properties ▁ file " ) ; fos . close ( ) ; log . logDetailed ( BaseMessages . getString ( PKG , " Spoon . Log . SaveProperties " ) ) ; } catch ( IOException e ) { if ( spoonRc . isHidden ( ) && filename . indexOf ( ' \\ ' ) != - 1 ) { log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailedWindowsBugAttr " , filename ) ) ; } else { log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailed " ) + e . getMessage ( ) ) ; } } } public void setLogLevel ( String level ) { properties . setProperty ( STRING_LOG_LEVEL , level ) ; } public String getLogLevel ( ) { String level = properties . getProperty ( STRING_LOG_LEVEL , " Basic " ) ; return level ; } public void setLogFilter ( String filter ) { properties . setProperty ( STRING_LOG_FILTER , Const . NVL ( filter , " " ) ) ; } public String getLogFilter ( ) { String level = properties . getProperty ( STRING_LOG_FILTER , " " ) ; return level ; } public void setUseDBCache ( boolean use ) { properties . setProperty ( STRING_USE_DB_CACHE , use ? " Y " : " N " ) ; } public boolean useDBCache ( ) { String use = properties . getProperty ( STRING_USE_DB_CACHE ) ; return ! " N " . equalsIgnoreCase ( use ) ; } public void setLastRepository ( String repname ) { properties . setProperty ( STRING_LAST_REPOSITORY , repname ) ; } public String getLastRepository ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY ) ; } public void setLastRepositoryLogin ( String login ) { properties . setProperty ( STRING_LAST_REPOSITORY_LOGIN , login ) ; } public String getLastRepositoryLogin ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY_LOGIN ) ; } public void setOnlyActiveSteps ( boolean only ) { properties . setProperty ( STRING_ONLY_ACTIVE_STEPS , only ? " Y " : " N " ) ; } public boolean getOnlyActiveSteps ( ) { String only = properties . getProperty ( STRING_ONLY_ACTIVE_STEPS , " N " ) ; return " Y " . equalsIgnoreCase ( only ) ; } public boolean askAboutReplacingDatabaseConnections ( ) { String ask = properties . getProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , " N " ) ; return " Y " . equalsIgnoreCase ( ask ) ; } public void setProperty ( String propertyName , String value ) { properties . setProperty ( propertyName , value ) ; } public String getProperty ( String propertyName ) { return properties . getProperty ( propertyName ) ; } public void setAskAboutReplacingDatabaseConnections ( boolean ask ) { properties . setProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , ask ? " Y " : " N " ) ; } public String getCustomParameter ( String parameterName , String defaultValue ) { return properties . getProperty ( STRING_CUSTOM_PARAMETER + parameterName , defaultValue ) ; } public void setCustomParameter ( String parameterName , String value ) { properties . setProperty ( STRING_CUSTOM_PARAMETER + parameterName , value ) ; } public void clearCustomParameters ( ) { Enumeration < Object > keys = properties . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; if ( key . startsWith ( STRING_CUSTOM_PARAMETER ) ) { properties . remove ( key ) ; } } } public static final int getArgumentNumber ( ValueMetaInterface value ) { if ( value != null && value . getName ( ) . startsWith ( Props . STRING_ARGUMENT_NAME_PREFIX ) ) { return Const . toInt ( value . getName ( ) . substring ( Props . STRING_ARGUMENT_NAME_PREFIX . length ( ) ) , - 1 ) ; } return - 1 ; } public static final String [ ] convertArguments ( RowMetaAndData row ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < row . size ( ) ; i ++ ) { ValueMetaInterface valueMeta = row . getValueMeta ( i ) ; int argNr = getArgumentNumber ( valueMeta ) ; if ( argNr >= 0 && argNr < 10 ) { try { args [ argNr ] = row . getString ( i , " " ) ; } catch ( KettleValueException e ) { args [ argNr ] = " " ; } } } return args ; } public void setLastArguments ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] != null ) { properties . setProperty ( STRING_LAST_ARGUMENT + " _ " + i , args [ i ] ) ; } } } public String [ ] getLastArguments ( ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = properties . getProperty ( STRING_LAST_ARGUMENT + " _ " + i ) ; } return args ; } public List < ObjectUsageCount > getPluginHistory ( ) { return pluginHistory ; } public int increasePluginHistory ( String pluginID ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; if ( usage . getObjectName ( ) . equalsIgnoreCase ( pluginID ) ) { int uses = usage . increment ( ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return uses ; } } addPluginHistory ( pluginID , 1 ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return 1 ; } public void addPluginHistory ( String pluginID , int uses ) { pluginHistory . add ( new ObjectUsageCount ( pluginID , uses ) ) ; } protected void loadPluginHistory ( ) { pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; int i = 0 ; String string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; while ( string != null ) { pluginHistory . add ( ObjectUsageCount . fromString ( string ) ) ; i ++ ; string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; } Collections . sort ( pluginHistory ) ; } private void savePluginHistory ( ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; properties . setProperty ( STRING_PLUGIN_HISTORY + " _ " + i , usage . toString ( ) ) ; } } public boolean areOnlyUsedConnectionsSavedToXML ( ) { String show = properties . getProperty ( STRING_ONLY_USED_DB_TO_XML , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; } public void setOnlyUsedConnectionsSavedToXML ( boolean onlyUsedConnections ) { properties . setProperty ( STRING_ONLY_USED_DB_TO_XML , onlyUsedConnections ? " Y " : " N " ) ; } public boolean replaceExistingDatabaseConnections ( ) { String replace = properties . getProperty ( STRING_REPLACE_DATABASES , " Y " ) ; return " Y " . equalsIgnoreCase ( replace ) ; } public void setReplaceDatabaseConnections ( boolean replace ) { properties . setProperty ( STRING_REPLACE_DATABASES , replace ? " Y " : " N " ) ; } public boolean showNewSubtransPopup ( ) { String show = properties . getProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; } public void setShowNewSubtransPopup ( boolean show ) { properties . setProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , show ? " Y " : " N " ) ; } public int getMaxNrLinesInLog ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_LOG ) ; return Const . toInt ( lines , Const . MAX_NR_LOG_LINES ) ; } public void setMaxNrLinesInLog ( int maxNrLinesInLog ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_LOG , Integer . toString ( maxNrLinesInLog ) ) ; } public int getMaxNrLinesInHistory ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_HISTORY ) ; return Const . toInt ( lines , Const . MAX_NR_HISTORY_LINES ) ; } public int getLinesInHistoryFetchSize ( ) { String fetchSize = properties . getProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE ) ; return Const . toInt ( fetchSize , Const . HISTORY_LINES_FETCH_SIZE ) ; } public boolean disableInitialExecutionHistory ( ) { String disable = properties . getProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , " N " ) ; return " Y " . equalsIgnoreCase ( disable ) ; } public void setMaxNrLinesInHistory ( int maxNrLinesInHistory ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_HISTORY , Integer . toString ( maxNrLinesInHistory ) ) ; } public void setLinesInHistoryFetchSize ( int linesInHistoryFetchSize ) { properties . setProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE , Integer . toString ( linesInHistoryFetchSize ) ) ; } public void setDisableInitialExecutionHistory ( boolean disable ) { properties . setProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , disable ? " Y " : " N " ) ; } public int getMaxLogLineTimeoutMinutes ( ) { String minutes = properties . getProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES ) ; return Const . toInt ( minutes , Const . MAX_LOG_LINE_TIMEOUT_MINUTES ) ; } public void setMaxLogLineTimeoutMinutes ( int maxLogLineTimeoutMinutes ) { properties . setProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES , Integer . toString ( maxLogLineTimeoutMinutes ) ) ; } public void reset ( ) { props = null ; properties . clear ( ) ; pluginHistory . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="clintjhill/saguaro/tree/master/src/com/stoneworks/BrickCanvasConverter.java"> package com . stoneworks ; import com . thoughtworks . xstream . converters . Converter ; import com . thoughtworks . xstream . converters . MarshallingContext ; import com . thoughtworks . xstream . converters . UnmarshallingContext ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; public class BrickCanvasConverter implements Converter { public BrickCanvasConverter ( ) { } public boolean canConvert ( Class type ) { return ( type == BrickCanvas . class ) ; } public void marshal ( Object source , HierarchicalStreamWriter writer , MarshallingContext context ) { BrickCanvas canvas = ( BrickCanvas ) source ; writer . startNode ( " canvasBackgroundImage " ) ; context . convertAnother ( canvas . getBackgroundImage ( ) ) ; writer . endNode ( ) ; writer . startNode ( " bricksOnCanvas " ) ; for ( Object obj : canvas . getBricks ( ) ) { if ( obj instanceof Brick ) { writer . startNode ( obj . getClass ( ) . getName ( ) ) ; context . convertAnother ( obj ) ; writer . endNode ( ) ; } } writer . endNode ( ) ; } public Object unmarshal ( HierarchicalStreamReader reader , UnmarshallingContext context ) { BrickCanvas canvas = BrickCanvas . getInstance ( ) ; while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( " canvasBackgroundImage " ) ) { canvas . setBackgroundImage ( ( BackgroundImage ) context . convertAnother ( reader , BackgroundImage . class ) ) ; } if ( reader . getNodeName ( ) . equals ( " bricksOnCanvas " ) ) { while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( Brick . class . getName ( ) ) ) { canvas . getLayer ( ) . addChild ( ( Brick ) context . convertAnother ( reader , Brick . class ) ) ; } reader . moveUp ( ) ; } } reader . moveUp ( ) ; } return canvas ; } } </DOCUMENT>
<DOCUMENT_ID="da1z/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="avasilevskiy/presto/tree/master/presto-raptor/src/main/java/com/facebook/presto/raptor/metadata/ShardNodes.java"> package com . facebook . presto . raptor . metadata ; import com . google . common . collect . ImmutableSet ; import java . util . Objects ; import java . util . Set ; import java . util . UUID ; import static com . google . common . base . MoreObjects . toStringHelper ; import static com . google . common . base . Preconditions . checkNotNull ; public class ShardNodes { private final UUID shardUuid ; private final Set < String > nodeIdentifiers ; public ShardNodes ( UUID shardUuid , Set < String > nodeIdentifiers ) { this . shardUuid = checkNotNull ( shardUuid , " shardUuid ▁ is ▁ null " ) ; this . nodeIdentifiers = ImmutableSet . copyOf ( checkNotNull ( nodeIdentifiers , " nodeIdentifiers ▁ is ▁ null " ) ) ; } public UUID getShardUuid ( ) { return shardUuid ; } public Set < String > getNodeIdentifiers ( ) { return nodeIdentifiers ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } ShardNodes other = ( ShardNodes ) obj ; return Objects . equals ( this . shardUuid , other . shardUuid ) && Objects . equals ( this . nodeIdentifiers , other . nodeIdentifiers ) ; } @ Override public int hashCode ( ) { return Objects . hash ( shardUuid , nodeIdentifiers ) ; } @ Override public String toString ( ) { return toStringHelper ( this ) . add ( " shardUuid " , shardUuid ) . add ( " nodeIdentifiers " , nodeIdentifiers ) . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="1and1/aesh/tree/master/src/main/java/org/jboss/aesh/cl/builder/OptionBuilder.java"> package org . jboss . aesh . cl . builder ; import org . jboss . aesh . cl . completer . OptionCompleter ; import org . jboss . aesh . cl . converter . CLConverter ; import org . jboss . aesh . cl . exception . OptionParserException ; import org . jboss . aesh . cl . internal . OptionInt ; import org . jboss . aesh . cl . internal . OptionType ; import java . util . ArrayList ; import java . util . List ; public class OptionBuilder { private char shortName ; private String name ; private String description ; private String argument ; private Class < ? > type ; private boolean hasValue = true ; private boolean required = false ; private boolean isProperty = false ; private boolean hasMultipleValues = false ; private char valueSeparator = ' , ' ; private OptionType optionType ; private Class < ? extends CLConverter > converter ; private String fieldName ; private OptionCompleter completer ; private List < String > defaultValues ; public OptionBuilder ( ) { defaultValues = new ArrayList < String > ( ) ; } public OptionBuilder shortName ( char n ) { shortName = n ; return this ; } public OptionBuilder name ( String name ) { this . name = name ; return this ; } public OptionBuilder description ( String description ) { this . description = description ; return this ; } public OptionBuilder argument ( String argument ) { this . argument = argument ; return this ; } public OptionBuilder type ( Class < ? > type ) { this . type = type ; return this ; } public OptionBuilder required ( boolean required ) { this . required = required ; return this ; } public OptionBuilder fieldName ( String fieldName ) { this . fieldName = fieldName ; return this ; } public OptionBuilder hasValue ( boolean hasValue ) { this . hasValue = hasValue ; return this ; } public OptionBuilder isProperty ( boolean isProperty ) { this . isProperty = isProperty ; return this ; } public OptionBuilder hasMultipleValues ( boolean hasMultipleValues ) { this . hasMultipleValues = hasMultipleValues ; return this ; } public OptionBuilder addDefaultValue ( String defaultValue ) { this . defaultValues . add ( defaultValue ) ; return this ; } public OptionBuilder valueSeparator ( char valueSeparator ) { this . valueSeparator = valueSeparator ; return this ; } public OptionBuilder optionType ( OptionType optionType ) { this . optionType = optionType ; return this ; } public OptionBuilder converter ( Class < ? extends CLConverter > converter ) { this . converter = converter ; return this ; } public OptionBuilder completer ( OptionCompleter completer ) { this . completer = completer ; return this ; } public OptionInt create ( ) throws OptionParserException { if ( optionType == null ) { if ( ! hasValue ) optionType = OptionType . BOOLEAN ; else if ( isProperty ) optionType = OptionType . GROUP ; else if ( hasMultipleValues ) optionType = OptionType . LIST ; else optionType = OptionType . NORMAL ; } if ( name == null || ( name . length ( ) < 1 && optionType != OptionType . ARGUMENT ) ) { if ( fieldName == null || fieldName . length ( ) < 1 ) throw new OptionParserException ( " Name ▁ must ▁ be ▁ defined ▁ to ▁ create ▁ an ▁ Option " ) ; else name = fieldName ; } return new OptionInt ( shortName , name , description , argument , required , valueSeparator , defaultValues , type , fieldName , optionType , converter , completer ) ; } } </DOCUMENT>
<DOCUMENT_ID="ptupitsyn/ignite/tree/master/modules/core/src/test/java/org/apache/ignite/internal/IgniteClientRejoinTest.java"> package org . apache . ignite . internal ; import java . io . IOException ; import java . io . OutputStream ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketException ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . ignite . Ignite ; import org . apache . ignite . IgniteCache ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . IgniteClientDisconnectedException ; import org . apache . ignite . IgniteException ; import org . apache . ignite . Ignition ; import org . apache . ignite . cluster . ClusterNode ; import org . apache . ignite . configuration . IgniteConfiguration ; import org . apache . ignite . failure . AbstractFailureHandler ; import org . apache . ignite . failure . FailureContext ; import org . apache . ignite . failure . TestFailureHandler ; import org . apache . ignite . internal . util . typedef . internal . U ; import org . apache . ignite . lang . IgniteInClosure ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . spi . IgniteSpiException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutHelper ; import org . apache . ignite . spi . discovery . tcp . TcpDiscoverySpi ; import org . apache . ignite . spi . discovery . tcp . messages . TcpDiscoveryAbstractMessage ; import org . apache . ignite . testframework . GridTestUtils ; import org . apache . ignite . testframework . junits . common . GridCommonAbstractTest ; import org . junit . Test ; public class IgniteClientRejoinTest extends GridCommonAbstractTest { private volatile boolean block ; private volatile boolean blockAll ; private volatile ClusterNode crd ; private boolean clientReconnectDisabled ; @ Override protected void beforeTestsStarted ( ) throws Exception { System . setProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " , " true " ) ; } @ Override protected void afterTestsStopped ( ) throws Exception { System . clearProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " ) ; } @ Override protected void afterTest ( ) throws Exception { stopAllGrids ( ) ; } @ Override protected void beforeTest ( ) throws Exception { clientReconnectDisabled = false ; } @ Override protected IgniteConfiguration getConfiguration ( String gridName ) throws Exception { IgniteConfiguration cfg = super . getConfiguration ( gridName ) ; if ( gridName . contains ( " client " ) ) { cfg . setCommunicationSpi ( new TcpCommunicationSpi ( ) ) ; TcpDiscoverySpi spi = ( TcpDiscoverySpi ) cfg . getDiscoverySpi ( ) ; DiscoverySpi dspi = new DiscoverySpi ( ) ; dspi . setIpFinder ( spi . getIpFinder ( ) ) ; cfg . setDiscoverySpi ( dspi ) ; dspi . setJoinTimeout ( 60_000 ) ; dspi . setClientReconnectDisabled ( clientReconnectDisabled ) ; cfg . setClientMode ( true ) ; } cfg . setPeerClassLoadingEnabled ( false ) ; return cfg ; } @ Test public void testClientsReconnectAfterStart ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; List < Ignite > clientNodes = new ArrayList < > ( ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) clientNodes . add ( startGrid ( " client " + i ) ) ; blockAll = true ; GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { U . sleep ( 5_000 ) ; block = true ; blockAll = false ; System . out . println ( " > > > ▁ Allow ▁ with ▁ blocked ▁ coordinator . " ) ; latch . countDown ( ) ; return null ; } } ) ; IgniteInternalFuture < Object > fut = GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { latch . await ( ) ; U . sleep ( ( new Random ( ) . nextInt ( 15 ) + 30 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ Allow ▁ coordinator . " ) ; return null ; } } ) ; fut . get ( ) ; for ( Ignite client : clientNodes ) { while ( true ) { try { IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( " some " ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assertEquals ( ( Integer ) i , cache . get ( i ) ) ; cache . clear ( ) ; break ; } catch ( IgniteClientDisconnectedException e ) { e . reconnectFuture ( ) . get ( ) ; } } } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Test public void testClientsReconnect ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String nodeName = " client " + idx ; IgniteConfiguration cfg = getConfiguration ( nodeName ) . setFailureHandler ( new AbstractFailureHandler ( ) { @ Override protected boolean handle ( Ignite ignite , FailureContext failureCtx ) { Runtime . getRuntime ( ) . halt ( Ignition . KILL_EXIT_CODE ) ; return false ; } } ) ; return startGrid ( nodeName , optimize ( cfg ) , null ) ; } } ) ; futs . add ( fut ) ; } GridTestUtils . runAsync ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { latch . countDown ( ) ; Random rnd = new Random ( ) ; U . sleep ( ( rnd . nextInt ( 15 ) + 15 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ ALLOW ▁ connection ▁ to ▁ coordinator . " ) ; return true ; } } ) ; for ( IgniteInternalFuture < Ignite > clientFut : futs ) { Ignite client = clientFut . get ( ) ; IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( client . name ( ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assert i == cache . get ( i ) ; } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Test public void testClientsReconnectDisabled ( ) throws Exception { clientReconnectDisabled = true ; Ignite srv1 = startGrid ( " server1" ) ; if ( ! tcpDiscovery ( ) ) return ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; final CountDownLatch failureHndLatch = new CountDownLatch ( CLIENTS_NUM ) ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String igniteInstanceName = " client " + idx ; return startGrid ( igniteInstanceName , getConfiguration ( igniteInstanceName ) . setFailureHandler ( new TestFailureHandler ( true , failureHndLatch ) ) ) ; } } ) ; futs . add ( fut ) ; } latch . countDown ( ) ; for ( final IgniteInternalFuture < Ignite > clientFut : futs ) { GridTestUtils . assertThrows ( log , new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { clientFut . get ( ) ; return null ; } } , IgniteCheckedException . class , null ) ; } assertTrue ( failureHndLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 0 , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( 0 , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Override protected long getTestTimeout ( ) { return 3 * 60_000 ; } private class TcpCommunicationSpi extends org . apache . ignite . spi . communication . tcp . TcpCommunicationSpi { @ Override public void sendMessage ( ClusterNode node , Message msg ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg ) ; } @ Override public void sendMessage ( ClusterNode node , Message msg , IgniteInClosure < IgniteException > ackC ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg , ackC ) ; } } private class DiscoverySpi extends TcpDiscoverySpi { @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , byte [ ] data , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , data , timeout ) ; } @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , timeout ) ; } @ Override protected void writeToSocket ( Socket sock , OutputStream out , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , out , msg , timeout ) ; } @ Override protected void writeToSocket ( TcpDiscoveryAbstractMessage msg , Socket sock , int res , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( msg , sock , res , timeout ) ; } @ Override protected Socket openSocket ( Socket sock , InetSocketAddress remAddr , IgniteSpiOperationTimeoutHelper timeoutHelper ) throws IOException , IgniteSpiOperationTimeoutException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; return super . openSocket ( sock , remAddr , timeoutHelper ) ; } } } </DOCUMENT>
<DOCUMENT_ID="medsob/Tanaguru/tree/master/web-app/tgol-web-app/src/main/java/org/tanaguru/webapp/command/helper/UploadAuditSetUpCommandHelper.java"> package org . tanaguru . webapp . command . helper ; import java . io . IOException ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import org . tanaguru . crawler . util . CrawlUtils ; import org . springframework . web . multipart . commons . CommonsMultipartFile ; public final class UploadAuditSetUpCommandHelper { private static Map < String , Integer > fileNameCounterMap = new HashMap < String , Integer > ( ) ; public synchronized static Map < String , String > convertFilesToMap ( CommonsMultipartFile [ ] fileInputList ) { Map < String , String > fileMap = new LinkedHashMap < String , String > ( ) ; CommonsMultipartFile tmpMultiFile ; String tmpCharset ; fileNameCounterMap . clear ( ) ; for ( int i = 0 ; i < fileInputList . length ; i ++ ) { tmpMultiFile = fileInputList [ i ] ; try { if ( tmpMultiFile != null && ! tmpMultiFile . isEmpty ( ) && tmpMultiFile . getInputStream ( ) != null ) { tmpCharset = CrawlUtils . extractCharset ( tmpMultiFile . getInputStream ( ) ) ; fileMap . put ( getFileName ( tmpMultiFile . getOriginalFilename ( ) ) , tmpMultiFile . getFileItem ( ) . getString ( tmpCharset ) ) ; } } catch ( IOException e ) { } } return fileMap ; } private static String getFileName ( String originalFileName ) { StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( ' / ' ) ; if ( fileNameCounterMap . containsKey ( originalFileName ) ) { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( fileNameCounterMap . get ( originalFileName ) + 1 ) ) ; fileName . append ( originalFileName ) ; fileName . append ( ' _ ' ) ; fileName . append ( fileNameCounterMap . get ( originalFileName ) ) ; return fileName . toString ( ) ; } else { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( 1 ) ) ; fileName . append ( originalFileName ) ; return fileName . toString ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="charlesvinette/react-native/tree/master/ReactAndroid/src/main/java/com/facebook/react/views/modal/ReactModalHostView.java"> package com . facebook . react . views . modal ; import javax . annotation . Nullable ; import java . util . ArrayList ; import android . app . Activity ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . KeyEvent ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . view . accessibility . AccessibilityEvent ; import android . widget . FrameLayout ; import com . facebook . infer . annotation . Assertions ; import com . facebook . react . R ; import com . facebook . react . bridge . LifecycleEventListener ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . common . annotations . VisibleForTesting ; import com . facebook . react . uimanager . JSTouchDispatcher ; import com . facebook . react . uimanager . RootView ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; public class ReactModalHostView extends ViewGroup implements LifecycleEventListener { public interface OnRequestCloseListener { void onRequestClose ( DialogInterface dialog ) ; } private DialogRootViewGroup mHostView ; private @ Nullable Dialog mDialog ; private boolean mTransparent ; private String mAnimationType ; private boolean mPropertyRequiresNewDialog ; private @ Nullable DialogInterface . OnShowListener mOnShowListener ; private @ Nullable OnRequestCloseListener mOnRequestCloseListener ; public ReactModalHostView ( Context context ) { super ( context ) ; ( ( ReactContext ) context ) . addLifecycleEventListener ( this ) ; mHostView = new DialogRootViewGroup ( context ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { } @ Override public void addView ( View child , int index ) { mHostView . addView ( child , index ) ; } @ Override public int getChildCount ( ) { return mHostView . getChildCount ( ) ; } @ Override public View getChildAt ( int index ) { return mHostView . getChildAt ( index ) ; } @ Override public void removeView ( View child ) { mHostView . removeView ( child ) ; } @ Override public void removeViewAt ( int index ) { View child = getChildAt ( index ) ; mHostView . removeView ( child ) ; } @ Override public void addChildrenForAccessibility ( ArrayList < View > outChildren ) { } @ Override public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { return false ; } public void onDropInstance ( ) { ( ( ReactContext ) getContext ( ) ) . removeLifecycleEventListener ( this ) ; dismiss ( ) ; } private void dismiss ( ) { if ( mDialog != null ) { mDialog . dismiss ( ) ; mDialog = null ; ViewGroup parent = ( ViewGroup ) mHostView . getParent ( ) ; parent . removeViewAt ( 0 ) ; } } protected void setOnRequestCloseListener ( OnRequestCloseListener listener ) { mOnRequestCloseListener = listener ; } protected void setOnShowListener ( DialogInterface . OnShowListener listener ) { mOnShowListener = listener ; } protected void setTransparent ( boolean transparent ) { mTransparent = transparent ; } protected void setAnimationType ( String animationType ) { mAnimationType = animationType ; mPropertyRequiresNewDialog = true ; } @ Override public void onHostResume ( ) { showOrUpdate ( ) ; } @ Override public void onHostPause ( ) { dismiss ( ) ; } @ Override public void onHostDestroy ( ) { onDropInstance ( ) ; } @ VisibleForTesting public @ Nullable Dialog getDialog ( ) { return mDialog ; } protected void showOrUpdate ( ) { if ( mDialog != null ) { if ( mPropertyRequiresNewDialog ) { dismiss ( ) ; } else { updateProperties ( ) ; return ; } } mPropertyRequiresNewDialog = false ; int theme = R . style . Theme_FullScreenDialog ; if ( mAnimationType . equals ( " fade " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedFade ; } else if ( mAnimationType . equals ( " slide " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedSlide ; } mDialog = new Dialog ( getContext ( ) , theme ) ; mDialog . setContentView ( getContentView ( ) ) ; updateProperties ( ) ; mDialog . setOnShowListener ( mOnShowListener ) ; mDialog . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { @ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent event ) { if ( event . getAction ( ) == KeyEvent . ACTION_UP ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { Assertions . assertNotNull ( mOnRequestCloseListener , " setOnRequestCloseListener ▁ must ▁ be ▁ called ▁ by ▁ the ▁ manager " ) ; mOnRequestCloseListener . onRequestClose ( dialog ) ; return true ; } else { Activity currentActivity = ( ( ReactContext ) getContext ( ) ) . getCurrentActivity ( ) ; if ( currentActivity != null ) { return currentActivity . onKeyUp ( keyCode , event ) ; } } } return false ; } } ) ; mDialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; mDialog . show ( ) ; } private View getContentView ( ) { FrameLayout frameLayout = new FrameLayout ( getContext ( ) ) ; frameLayout . addView ( mHostView ) ; frameLayout . setFitsSystemWindows ( true ) ; return frameLayout ; } private void updateProperties ( ) { Assertions . assertNotNull ( mDialog , " mDialog ▁ must ▁ exist ▁ when ▁ we ▁ call ▁ updateProperties " ) ; if ( mTransparent ) { mDialog . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } else { mDialog . getWindow ( ) . setDimAmount ( 0.5f ) ; mDialog . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND , WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } } static class DialogRootViewGroup extends ReactViewGroup implements RootView { private final JSTouchDispatcher mJSTouchDispatcher = new JSTouchDispatcher ( this ) ; public DialogRootViewGroup ( Context context ) { super ( context ) ; } @ Override protected void onSizeChanged ( final int w , final int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; if ( getChildCount ( ) > 0 ) { ( ( ReactContext ) getContext ( ) ) . runOnNativeModulesQueueThread ( new Runnable ( ) { @ Override public void run ( ) { ( ( ReactContext ) getContext ( ) ) . getNativeModule ( UIManagerModule . class ) . updateNodeSize ( getChildAt ( 0 ) . getId ( ) , w , h ) ; } } ) ; } } @ Override public boolean onInterceptTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; return super . onInterceptTouchEvent ( event ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; super . onTouchEvent ( event ) ; return true ; } @ Override public void onChildStartedNativeGesture ( MotionEvent androidEvent ) { mJSTouchDispatcher . onChildStartedNativeGesture ( androidEvent , getEventDispatcher ( ) ) ; } @ Override public void requestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private EventDispatcher getEventDispatcher ( ) { ReactContext reactContext = ( ReactContext ) getContext ( ) ; return reactContext . getNativeModule ( UIManagerModule . class ) . getEventDispatcher ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="maxammann/SimpleClans2/tree/master/SimpleClans2/src/main/java/com/p000ison/dev/simpleclans2/converter/Converter.java"> package com . p000ison . dev . simpleclans2 . converter ; import com . p000ison . dev . simpleclans2 . api . KillType ; import com . p000ison . dev . simpleclans2 . api . logging . Logging ; import com . p000ison . dev . sqlapi . jbdc . JBDCDatabase ; import org . json . simple . JSONArray ; import org . json . simple . JSONObject ; import org . json . simple . parser . JSONParser ; import org . json . simple . parser . ParseException ; import java . sql . * ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; @ SuppressWarnings ( " unchecked " ) public class Converter implements Runnable { private JBDCDatabase from ; private JBDCDatabase to ; private PreparedStatement insertClan , insertBB , updateClan , insertKill ; private PreparedStatement insertClanPlayer ; private Set < ConvertedClan > clans = new HashSet < ConvertedClan > ( ) ; private Set < ConvertedClanPlayer > players = new HashSet < ConvertedClanPlayer > ( ) ; public Converter ( JBDCDatabase from , JBDCDatabase to ) { this . from = from ; this . to = to ; insertBB = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ bb ` ▁ ( ` clan ` , ▁ ` text ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? ▁ ) ; " ) ; updateClan = to . prepare ( " UPDATE ▁ ` sc2 _ clans ` ▁ SET ▁ allies ▁ = ▁ ? , ▁ rivals ▁ = ▁ ? , ▁ warring ▁ = ▁ ? ▁ WHERE ▁ id ▁ = ▁ ? ; " ) ; insertKill = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ kills ` ▁ ( ▁ ` attacker ` , ▁ ` attacker _ clan ` , ▁ ` victim ` , ▁ ` victim _ clan ` , ▁ ` war ` , ▁ ` type ` , ▁ ` date ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; prepareClan ( ) ; prepareClanPlayer ( ) ; } private void prepareClan ( ) { if ( insertClan != null ) { try { insertClan . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClan = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ clans ` ▁ ( ` name ` , ▁ ` tag ` , ▁ ` verified ` , ▁ ` founded ` , ▁ ` last _ action ` , ▁ ` flags ` , ▁ ` balance ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; } private void prepareClanPlayer ( ) { if ( insertClanPlayer != null ) { try { insertClanPlayer . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClanPlayer = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ players ` ▁ ( ▁ ` name ` , ▁ ` leader ` , ▁ ` trusted ` , ▁ ` join _ date ` , ▁ ` last _ seen ` , ▁ ` clan ` , ▁ ` neutral _ kills ` , ▁ ` rival _ Kills ` , ▁ ` civilian _ Kills ` , ▁ ` deaths ` , ▁ ` flags ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) " ) ; } public void convertAll ( ) { try { convertClans ( ) ; convertPlayers ( ) ; convertKills ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } clans = null ; players = null ; } @ Override public void run ( ) { convertAll ( ) ; } public void convertPlayers ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ players ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; try { JSONParser parser = new JSONParser ( ) ; String flagsString = result . getString ( " flags " ) ; JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; boolean friendlyFire = result . getBoolean ( " friendly _ fire " ) ; boolean bb = ( Boolean ) object . get ( " bb - enabled " ) ; boolean cape = ( Boolean ) object . get ( " cape - enabled " ) ; if ( friendlyFire ) { flags . put ( " ff " , friendlyFire ) ; } if ( bb ) { flags . put ( " bb " , bb ) ; } if ( cape ) { flags . put ( " cape " , cape ) ; } } catch ( ParseException e ) { e . printStackTrace ( ) ; continue ; } String name = result . getString ( " name " ) ; insertPlayer ( name , result . getBoolean ( " leader " ) , result . getBoolean ( " trusted " ) , result . getLong ( " join _ date " ) , result . getLong ( " last _ seen " ) , getIDByTag ( result . getString ( " tag " ) ) , result . getInt ( " neutral _ kills " ) , result . getInt ( " rival _ kills " ) , result . getInt ( " civilian _ kills " ) , result . getInt ( " deaths " ) , flags . toJSONString ( ) ) ; ResultSet idResult = to . query ( " SELECT ▁ id ▁ FROM ▁ ` sc2 _ players ` ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ) ; idResult . next ( ) ; players . add ( new ConvertedClanPlayer ( idResult . getLong ( " id " ) , name ) ) ; } } public void insertPlayer ( String name , boolean leader , boolean trusted , long joinDate , long lastSeen , long clan , int neutralKills , int rivalKills , int civilianKills , int deaths , String flags ) throws SQLException { insertClanPlayer . setString ( 1 , name ) ; insertClanPlayer . setBoolean ( 2 , leader ) ; insertClanPlayer . setBoolean ( 3 , trusted ) ; insertClanPlayer . setTimestamp ( 4 , new Timestamp ( joinDate ) ) ; insertClanPlayer . setTimestamp ( 5 , new Timestamp ( lastSeen ) ) ; insertClanPlayer . setLong ( 6 , clan ) ; insertClanPlayer . setInt ( 7 , neutralKills ) ; insertClanPlayer . setInt ( 8 , rivalKills ) ; insertClanPlayer . setInt ( 9 , civilianKills ) ; insertClanPlayer . setInt ( 10 , deaths ) ; if ( flags != null ) { insertClanPlayer . setString ( 11 , flags ) ; } else { insertClanPlayer . setNull ( 11 , Types . VARCHAR ) ; } try { insertClanPlayer . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clanPlayer ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClanPlayer ( ) ; } } public long getClanPlayerIDbyName ( String tag ) { for ( ConvertedClanPlayer cp : players ) { if ( cp . getName ( ) . equals ( tag ) ) { return cp . getId ( ) ; } } return - 1 ; } public void convertClans ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ clans ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; String name = result . getString ( " name " ) ; String tag = result . getString ( " tag " ) ; boolean verified = result . getBoolean ( " verified " ) ; boolean friendly_fire = result . getBoolean ( " friendly _ fire " ) ; long founded = result . getLong ( " founded " ) ; long last_used = result . getLong ( " last _ used " ) ; String flagsString = result . getString ( " flags " ) ; String cape = result . getString ( " cape _ url " ) ; ConvertedClan clan = new ConvertedClan ( tag ) ; clan . setPackedAllies ( result . getString ( " packed _ allies " ) ) ; clan . serPackedRivals ( result . getString ( " packed _ rivals " ) ) ; if ( friendly_fire ) { flags . put ( " ff " , friendly_fire ) ; } if ( cape != null && ! cape . isEmpty ( ) ) { flags . put ( " cape - url " , cape ) ; } JSONParser parser = new JSONParser ( ) ; try { JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; String world = object . get ( " homeWorld " ) . toString ( ) ; if ( ! world . isEmpty ( ) ) { int x = ( ( Long ) object . get ( " homeX " ) ) . intValue ( ) ; int y = ( ( Long ) object . get ( " homeY " ) ) . intValue ( ) ; int z = ( ( Long ) object . get ( " homeZ " ) ) . intValue ( ) ; flags . put ( " home " , x + " : " + y + " : " + z + " : " + world + " : 0:0" ) ; } clan . setRawWarring ( ( JSONArray ) object . get ( " warring " ) ) ; } catch ( ParseException e ) { Logging . debug ( e , true ) ; continue ; } insertClan ( name , tag , verified , founded , last_used , flags . isEmpty ( ) ? null : flags . toJSONString ( ) , result . getDouble ( " balance " ) ) ; String selectLastQuery = " SELECT ▁ ` id ` ▁ FROM ▁ ` sc2 _ clans ` ▁ ORDER ▁ BY ▁ ID ▁ DESC ▁ LIMIT ▁ 1 ; " ; ResultSet selectLast = to . query ( selectLastQuery ) ; selectLast . next ( ) ; clan . setId ( selectLast . getLong ( " id " ) ) ; selectLast . close ( ) ; insertBB ( Arrays . asList ( result . getString ( " packed _ bb " ) . split ( " \\s * ( \\ | | $ ) " ) ) , clan . getId ( ) ) ; clans . add ( clan ) ; } for ( ConvertedClan clan : clans ) { JSONArray allies = new JSONArray ( ) ; JSONArray rivals = new JSONArray ( ) ; JSONArray warring = new JSONArray ( ) ; for ( String allyTag : clan . getRawAllies ( ) ) { long allyID = getIDByTag ( allyTag ) ; if ( allyID != - 1 ) { allies . add ( allyID ) ; } } for ( String rivalTag : clan . getRawAllies ( ) ) { long rivalID = getIDByTag ( rivalTag ) ; if ( rivalID != - 1 ) { rivals . add ( rivalID ) ; } } for ( String warringTag : clan . getRawWarring ( ) ) { long warringID = getIDByTag ( warringTag ) ; if ( warringID != - 1 ) { warring . add ( warringID ) ; } } if ( ! allies . isEmpty ( ) ) { updateClan . setString ( 1 , allies . toJSONString ( ) ) ; } else { updateClan . setNull ( 1 , Types . VARCHAR ) ; } if ( ! rivals . isEmpty ( ) ) { updateClan . setString ( 2 , rivals . toJSONString ( ) ) ; } else { updateClan . setNull ( 2 , Types . VARCHAR ) ; } if ( ! warring . isEmpty ( ) ) { updateClan . setString ( 3 , warring . toJSONString ( ) ) ; } else { updateClan . setNull ( 3 , Types . VARCHAR ) ; } updateClan . setLong ( 4 , clan . getId ( ) ) ; updateClan . executeUpdate ( ) ; } } public long getIDByTag ( String tag ) { for ( ConvertedClan clan : clans ) { if ( clan . getTag ( ) . equals ( tag ) ) { return clan . getId ( ) ; } } return - 1 ; } public void insertBB ( List < String > bb , long clan ) throws SQLException { for ( String text : bb ) { insertBB . setLong ( 1 , clan ) ; insertBB . setString ( 2 , text ) ; insertBB . executeUpdate ( ) ; } } public void insertClan ( String name , String tag , boolean verified , long founded , long last_action , String flags , double balance ) throws SQLException { insertClan . setString ( 1 , name ) ; insertClan . setString ( 2 , tag ) ; insertClan . setBoolean ( 3 , verified ) ; insertClan . setTimestamp ( 4 , new Timestamp ( founded ) ) ; insertClan . setTimestamp ( 5 , new Timestamp ( last_action ) ) ; if ( flags != null ) { insertClan . setString ( 6 , flags ) ; } else { insertClan . setNull ( 6 , Types . VARCHAR ) ; } insertClan . setDouble ( 7 , balance ) ; try { insertClan . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clan ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClan ( ) ; } } public void convertKills ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ kills ` ; " ) ; while ( result . next ( ) ) { Timestamp date ; try { date = result . getTimestamp ( " date " ) ; } catch ( Exception e ) { date = new Timestamp ( System . currentTimeMillis ( ) ) ; } insertKill ( result . getString ( " attacker " ) , result . getString ( " attacker _ tag " ) , result . getString ( " victim " ) , result . getString ( " victim _ tag " ) , result . getString ( " kill _ type " ) , result . getBoolean ( " war " ) , date ) ; } } public void insertKill ( String attacker , String attacker_clan , String victim , String victim_clan , String type , boolean war , Timestamp date ) throws SQLException { long attackerID = getClanPlayerIDbyName ( attacker ) ; if ( attackerID == - 1 ) { return ; } long victimID = getClanPlayerIDbyName ( victim ) ; if ( victimID == - 1 ) { return ; } insertKill . setLong ( 1 , attackerID ) ; insertKill . setLong ( 2 , getIDByTag ( attacker_clan ) ) ; insertKill . setLong ( 3 , victimID ) ; insertKill . setLong ( 4 , getIDByTag ( victim_clan ) ) ; KillType realType ; switch ( type . charAt ( 0 ) ) { case ' c ' : realType = KillType . CIVILIAN ; break ; case ' n ' : realType = KillType . NEUTRAL ; break ; case ' r ' : realType = KillType . RIVAL ; break ; default : throw new UnsupportedOperationException ( " Failed ▁ at ▁ inserting ▁ kill ! ▁ Type ▁ not ▁ found : ▁ " + type ) ; } insertKill . setByte ( 5 , realType . getType ( ) ) ; insertKill . setBoolean ( 6 , war ) ; insertKill . setTimestamp ( 7 , date ) ; insertKill . executeUpdate ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="irwinai/zxing/tree/master/android/src/com/google/zxing/client/android/result/AddressBookResultHandler.java"> package com . google . zxing . client . android . result ; import com . google . zxing . client . android . R ; import com . google . zxing . client . result . AddressBookParsedResult ; import com . google . zxing . client . result . ParsedResult ; import android . app . Activity ; import android . telephony . PhoneNumberUtils ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . style . StyleSpan ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; public final class AddressBookResultHandler extends ResultHandler { private static final DateFormat [ ] DATE_FORMATS = { new SimpleDateFormat ( " yyyyMMdd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyyMMdd ' T ' HHmmss " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd ' T ' HH : mm : ss " , Locale . ENGLISH ) , } ; static { for ( DateFormat format : DATE_FORMATS ) { format . setLenient ( false ) ; } } private static final int [ ] BUTTON_TEXTS = { R . string . button_add_contact , R . string . button_show_map , R . string . button_dial , R . string . button_email , } ; private final boolean [ ] fields ; private int buttonCount ; private int mapIndexToAction ( int index ) { if ( index < buttonCount ) { int count = - 1 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { count ++ ; } if ( count == index ) { return x ; } } } return - 1 ; } public AddressBookResultHandler ( Activity activity , ParsedResult result ) { super ( activity , result ) ; AddressBookParsedResult addressResult = ( AddressBookParsedResult ) result ; String [ ] addresses = addressResult . getAddresses ( ) ; boolean hasAddress = addresses != null && addresses . length > 0 && addresses [ 0 ] != null && ! addresses [ 0 ] . isEmpty ( ) ; String [ ] phoneNumbers = addressResult . getPhoneNumbers ( ) ; boolean hasPhoneNumber = phoneNumbers != null && phoneNumbers . length > 0 ; String [ ] emails = addressResult . getEmails ( ) ; boolean hasEmailAddress = emails != null && emails . length > 0 ; fields = new boolean [ MAX_BUTTON_COUNT ] ; fields [ 0 ] = true ; fields [ 1 ] = hasAddress ; fields [ 2 ] = hasPhoneNumber ; fields [ 3 ] = hasEmailAddress ; buttonCount = 0 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { buttonCount ++ ; } } } @ Override public int getButtonCount ( ) { return buttonCount ; } @ Override public int getButtonText ( int index ) { return BUTTON_TEXTS [ mapIndexToAction ( index ) ] ; } @ Override public void handleButtonPress ( int index ) { AddressBookParsedResult addressResult = ( AddressBookParsedResult ) getResult ( ) ; String [ ] addresses = addressResult . getAddresses ( ) ; String address1 = addresses == null || addresses . length < 1 ? null : addresses [ 0 ] ; String [ ] addressTypes = addressResult . getAddressTypes ( ) ; String address1Type = addressTypes == null || addressTypes . length < 1 ? null : addressTypes [ 0 ] ; int action = mapIndexToAction ( index ) ; switch ( action ) { case 0 : addContact ( addressResult . getNames ( ) , addressResult . getNicknames ( ) , addressResult . getPronunciation ( ) , addressResult . getPhoneNumbers ( ) , addressResult . getPhoneTypes ( ) , addressResult . getEmails ( ) , addressResult . getEmailTypes ( ) , addressResult . getNote ( ) , addressResult . getInstantMessenger ( ) , address1 , address1Type , addressResult . getOrg ( ) , addressResult . getTitle ( ) , addressResult . getURLs ( ) , addressResult . getBirthday ( ) , addressResult . getGeo ( ) ) ; break ; case 1 : searchMap ( address1 ) ; break ; case 2 : dialPhone ( addressResult . getPhoneNumbers ( ) [ 0 ] ) ; break ; case 3 : sendEmail ( addressResult . getEmails ( ) , null , null , null , null ) ; break ; default : break ; } } private static Date parseDate ( String s ) { for ( DateFormat currentFormat : DATE_FORMATS ) { try { return currentFormat . parse ( s ) ; } catch ( ParseException e ) { } } return null ; } @ Override public CharSequence getDisplayContents ( ) { AddressBookParsedResult result = ( AddressBookParsedResult ) getResult ( ) ; StringBuilder contents = new StringBuilder ( 100 ) ; ParsedResult . maybeAppend ( result . getNames ( ) , contents ) ; int namesLength = contents . length ( ) ; String pronunciation = result . getPronunciation ( ) ; if ( pronunciation != null && ! pronunciation . isEmpty ( ) ) { contents . append ( " \n ( " ) ; contents . append ( pronunciation ) ; contents . append ( ' ) ' ) ; } ParsedResult . maybeAppend ( result . getTitle ( ) , contents ) ; ParsedResult . maybeAppend ( result . getOrg ( ) , contents ) ; ParsedResult . maybeAppend ( result . getAddresses ( ) , contents ) ; String [ ] numbers = result . getPhoneNumbers ( ) ; if ( numbers != null ) { for ( String number : numbers ) { if ( number != null ) { ParsedResult . maybeAppend ( PhoneNumberUtils . formatNumber ( number ) , contents ) ; } } } ParsedResult . maybeAppend ( result . getEmails ( ) , contents ) ; ParsedResult . maybeAppend ( result . getURLs ( ) , contents ) ; String birthday = result . getBirthday ( ) ; if ( birthday != null && ! birthday . isEmpty ( ) ) { Date date = parseDate ( birthday ) ; if ( date != null ) { ParsedResult . maybeAppend ( DateFormat . getDateInstance ( DateFormat . MEDIUM ) . format ( date . getTime ( ) ) , contents ) ; } } ParsedResult . maybeAppend ( result . getNote ( ) , contents ) ; if ( namesLength > 0 ) { Spannable styled = new SpannableString ( contents . toString ( ) ) ; styled . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , 0 , namesLength , 0 ) ; return styled ; } else { return contents . toString ( ) ; } } @ Override public int getDisplayTitle ( ) { return R . string . result_address_book ; } } </DOCUMENT>
<DOCUMENT_ID="arunmk/CoreNLP/tree/master/test/src/edu/stanford/nlp/util/IterablesTest.java"> package edu . stanford . nlp . util ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . function . Function ; import junit . framework . Assert ; import junit . framework . TestCase ; public class IterablesTest extends TestCase { public void testZip ( ) { String [ ] s1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int count = 0 ; for ( Pair < String , Integer > pair : Iterables . zip ( s1 , s2 ) ) { assertEquals ( pair . first , s1 [ count ] ) ; assertEquals ( pair . second , s2 [ count ] ) ; count ++ ; } assertEquals ( s1 . length < s2 . length ? s1 . length : s2 . length , count ) ; } @ SuppressWarnings ( " unchecked " ) public void testChain ( ) { List < String > s1 = Arrays . asList ( new String [ ] { " hi " , " there " } ) ; List < String > s2 = Arrays . asList ( new String [ ] { } ) ; List < String > s3 = Arrays . asList ( new String [ ] { " yoo " } ) ; List < String > s4 = Arrays . asList ( new String [ ] { } ) ; List < String > answer = Arrays . asList ( new String [ ] { " yoo " , " hi " , " there " , " yoo " } ) ; List < String > chained = new ArrayList < String > ( ) ; for ( String s : Iterables . chain ( s3 , s1 , s2 , s3 , s4 ) ) { chained . add ( s ) ; } assertEquals ( answer , chained ) ; } public void testFilter ( ) { List < String > values = Arrays . asList ( " a " , " HI " , " tHere " , " YO " ) ; Iterator < String > iterator = Iterables . filter ( values , new Function < String , Boolean > ( ) { public Boolean apply ( String in ) { return in . equals ( in . toUpperCase ( ) ) ; } } ) . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( iterator . next ( ) , " HI " ) ; assertEquals ( iterator . next ( ) , " YO " ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testTransform ( ) { List < Integer > values = Arrays . asList ( 1 , 2 , 3 , 4 ) ; List < Integer > squares = Arrays . asList ( 1 , 4 , 9 , 16 ) ; Function < Integer , Integer > squarer = new Function < Integer , Integer > ( ) { public Integer apply ( Integer in ) { return in * in ; } } ; for ( Pair < Integer , Integer > pair : Iterables . zip ( Iterables . transform ( values , squarer ) , squares ) ) { assertEquals ( pair . first , pair . second ) ; } } public void testMerge ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Pair < String , String > > iter = Iterables . merge ( a , b , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " d " , " d " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testMerge3 ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; List < String > c = Arrays . asList ( " a " , " b " , " c " , " e " , " f " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Triple < String , String , String > > iter = Iterables . merge ( a , b , c , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testGroup ( ) { String [ ] input = new String [ ] { "0 ▁ ab " , "0 ▁ bb " , "0 ▁ cc " , "1 ▁ dd " , "2 ▁ dd " , "2 ▁ kj " , "3 ▁ kj " , "3 ▁ kk " } ; int [ ] counts = new int [ ] { 3 , 1 , 2 , 2 } ; Comparator < String > fieldOne = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . split ( " ▁ " ) [ 0 ] . compareTo ( o2 . split ( " ▁ " ) [ 0 ] ) ; } } ; int index = 0 ; int group = 0 ; for ( Iterable < String > set : Iterables . group ( Arrays . asList ( input ) , fieldOne ) ) { String sharedKey = null ; int thisCount = 0 ; for ( String line : set ) { String thisKey = line . split ( " ▁ " ) [ 0 ] ; if ( sharedKey == null ) { sharedKey = thisKey ; } else { assertEquals ( " Wrong ▁ key " , sharedKey , thisKey ) ; } assertEquals ( " Wrong ▁ input ▁ line " , line , input [ index ++ ] ) ; thisCount ++ ; } assertEquals ( " Wrong ▁ number ▁ of ▁ items ▁ in ▁ this ▁ iterator " , counts [ group ++ ] , thisCount ) ; } assertEquals ( " Didn ' t ▁ get ▁ all ▁ inputs " , input . length , index ) ; assertEquals ( " Wrong ▁ number ▁ of ▁ groups " , counts . length , group ) ; } public void testSample ( ) { Iterable < Integer > items = Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ; int count = 0 ; for ( Integer item : Iterables . sample ( items , 5 , 2 , new Random ( ) ) ) { ++ count ; Assert . assertTrue ( item <= 5 ) ; Assert . assertTrue ( item >= 1 ) ; } Assert . assertEquals ( 2 , count ) ; } } </DOCUMENT>
<DOCUMENT_ID="akshayabd/jenkins/tree/master/core/src/main/java/hudson/model/ListView.java"> package hudson . model ; import hudson . Extension ; import hudson . Util ; import hudson . diagnosis . OldDataMonitor ; import hudson . model . Descriptor . FormException ; import hudson . model . listeners . ItemListener ; import hudson . security . ACL ; import hudson . util . CaseInsensitiveComparator ; import hudson . util . DescribableList ; import hudson . util . FormValidation ; import hudson . util . HttpResponses ; import hudson . views . ListViewColumn ; import hudson . views . ViewJobFilter ; import java . io . IOException ; import java . util . * ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import javax . annotation . concurrent . GuardedBy ; import javax . servlet . ServletException ; import jenkins . model . Jenkins ; import net . sf . json . JSONObject ; import org . kohsuke . accmod . Restricted ; import org . kohsuke . accmod . restrictions . NoExternalUse ; import org . kohsuke . stapler . DataBoundConstructor ; import org . kohsuke . stapler . HttpResponse ; import org . kohsuke . stapler . QueryParameter ; import org . kohsuke . stapler . StaplerRequest ; import org . kohsuke . stapler . StaplerResponse ; import org . kohsuke . stapler . interceptor . RequirePOST ; public class ListView extends View implements DirectlyModifiableView { @ GuardedBy ( " this " ) SortedSet < String > jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; private DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > jobFilters ; private DescribableList < ListViewColumn , Descriptor < ListViewColumn > > columns ; private String includeRegex ; private boolean recurse ; private transient Pattern includePattern ; private Boolean statusFilter ; @ DataBoundConstructor public ListView ( String name ) { super ( name ) ; initColumns ( ) ; initJobFilters ( ) ; } public ListView ( String name , ViewGroup owner ) { this ( name ) ; this . owner = owner ; } private Object readResolve ( ) { if ( includeRegex != null ) { try { includePattern = Pattern . compile ( includeRegex ) ; } catch ( PatternSyntaxException x ) { includeRegex = null ; OldDataMonitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( jobNames == null ) { jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; } initColumns ( ) ; initJobFilters ( ) ; return this ; } protected void initColumns ( ) { if ( columns == null ) columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this , ListViewColumn . createDefaultInitialColumnList ( ) ) ; } protected void initJobFilters ( ) { if ( jobFilters == null ) jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } public boolean hasJobFilterExtensions ( ) { return ! ViewJobFilter . all ( ) . isEmpty ( ) ; } public DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > getJobFilters ( ) { return jobFilters ; } @ Override public DescribableList < ListViewColumn , Descriptor < ListViewColumn > > getColumns ( ) { return columns ; } @ Override public List < TopLevelItem > getItems ( ) { SortedSet < String > names ; List < TopLevelItem > items = new ArrayList < TopLevelItem > ( ) ; synchronized ( this ) { names = new TreeSet < String > ( jobNames ) ; } ItemGroup < ? extends TopLevelItem > parent = getOwnerItemGroup ( ) ; List < TopLevelItem > parentItems = new ArrayList < TopLevelItem > ( parent . getItems ( ) ) ; includeItems ( parent , parentItems , names ) ; Boolean statusFilter = this . statusFilter ; Iterable < ? extends TopLevelItem > candidates ; if ( recurse ) { candidates = Items . getAllItems ( parent , TopLevelItem . class ) ; } else { candidates = parent . getItems ( ) ; } for ( TopLevelItem item : candidates ) { if ( ! names . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ) continue ; if ( statusFilter == null || ! ( item instanceof AbstractProject ) || ( ( AbstractProject ) item ) . isDisabled ( ) ^ statusFilter ) items . add ( item ) ; } Iterable < ViewJobFilter > jobFilters = getJobFilters ( ) ; List < TopLevelItem > allItems = new ArrayList < TopLevelItem > ( parentItems ) ; if ( recurse ) allItems = expand ( allItems , new ArrayList < TopLevelItem > ( ) ) ; for ( ViewJobFilter jobFilter : jobFilters ) { items = jobFilter . filter ( items , allItems , this ) ; } items = new ArrayList < TopLevelItem > ( new LinkedHashSet < TopLevelItem > ( items ) ) ; return items ; } private List < TopLevelItem > expand ( Collection < TopLevelItem > items , List < TopLevelItem > allItems ) { for ( TopLevelItem item : items ) { if ( item instanceof ItemGroup ) { ItemGroup < ? extends Item > ig = ( ItemGroup < ? extends Item > ) item ; expand ( Util . filter ( ig . getItems ( ) , TopLevelItem . class ) , allItems ) ; } allItems . add ( item ) ; } return allItems ; } @ Override public boolean contains ( TopLevelItem item ) { return getItems ( ) . contains ( item ) ; } private void includeItems ( ItemGroup < ? extends TopLevelItem > root , Collection < ? extends Item > parentItems , SortedSet < String > names ) { if ( includePattern != null ) { for ( Item item : parentItems ) { if ( recurse && item instanceof ItemGroup ) { ItemGroup < ? > ig = ( ItemGroup < ? > ) item ; includeItems ( root , ig . getItems ( ) , names ) ; } if ( item instanceof TopLevelItem ) { String itemName = item . getRelativeNameFrom ( root ) ; if ( includePattern . matcher ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } } public synchronized boolean jobNamesContains ( TopLevelItem item ) { if ( item == null ) return false ; return jobNames . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } @ Override public void add ( TopLevelItem item ) throws IOException { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } save ( ) ; } @ Override public boolean remove ( TopLevelItem item ) throws IOException { synchronized ( this ) { String name = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( ! jobNames . remove ( name ) ) return false ; } save ( ) ; return true ; } public String getIncludeRegex ( ) { return includeRegex ; } public boolean isRecurse ( ) { return recurse ; } public void setRecurse ( boolean recurse ) { this . recurse = recurse ; } public Boolean getStatusFilter ( ) { return statusFilter ; } @ Override @ RequirePOST public Item doCreateItem ( StaplerRequest req , StaplerResponse rsp ) throws IOException , ServletException { ItemGroup < ? extends TopLevelItem > ig = getOwnerItemGroup ( ) ; if ( ig instanceof ModifiableItemGroup ) { TopLevelItem item = ( ( ModifiableItemGroup < ? extends TopLevelItem > ) ig ) . doCreateItem ( req , rsp ) ; if ( item != null ) { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } owner . save ( ) ; } return item ; } return null ; } @ Override @ RequirePOST public HttpResponse doAddJobToView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( item == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ does ▁ not ▁ correspond ▁ to ▁ a ▁ known ▁ item " ) ; if ( contains ( item ) ) return HttpResponses . ok ( ) ; add ( item ) ; owner . save ( ) ; return HttpResponses . ok ( ) ; } @ Override @ RequirePOST public HttpResponse doRemoveJobFromView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( remove ( item ) ) owner . save ( ) ; return HttpResponses . ok ( ) ; } private TopLevelItem resolveName ( String name ) { TopLevelItem item = getOwnerItemGroup ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( getOwnerItemGroup ( ) , name ) ; item = Jenkins . getInstance ( ) . getItemByFullName ( name , TopLevelItem . class ) ; } return item ; } @ Override protected void submit ( StaplerRequest req ) throws ServletException , FormException , IOException { JSONObject json = req . getSubmittedForm ( ) ; synchronized ( this ) { recurse = json . optBoolean ( " recurse " , true ) ; jobNames . clear ( ) ; Iterable < ? extends TopLevelItem > items ; if ( recurse ) { items = Items . getAllItems ( getOwnerItemGroup ( ) , TopLevelItem . class ) ; } else { items = getOwnerItemGroup ( ) . getItems ( ) ; } for ( TopLevelItem item : items ) { String relativeNameFrom = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( req . getParameter ( relativeNameFrom ) != null ) { jobNames . add ( relativeNameFrom ) ; } } } setIncludeRegex ( req . getParameter ( " useincluderegex " ) != null ? req . getParameter ( " includeRegex " ) : null ) ; if ( columns == null ) { columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this ) ; } columns . rebuildHetero ( req , json , ListViewColumn . all ( ) , " columns " ) ; if ( jobFilters == null ) { jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } jobFilters . rebuildHetero ( req , json , ViewJobFilter . all ( ) , " jobFilters " ) ; String filter = Util . fixEmpty ( req . getParameter ( " statusFilter " ) ) ; statusFilter = filter != null ? "1" . equals ( filter ) : null ; } public void setIncludeRegex ( String includeRegex ) { this . includeRegex = Util . nullify ( includeRegex ) ; if ( this . includeRegex == null ) this . includePattern = null ; else this . includePattern = Pattern . compile ( includeRegex ) ; } @ Extension public static class DescriptorImpl extends ViewDescriptor { @ Override public String getDisplayName ( ) { return Messages . ListView_DisplayName ( ) ; } public FormValidation doCheckIncludeRegex ( @ QueryParameter String value ) throws IOException , ServletException , InterruptedException { String v = Util . fixEmpty ( value ) ; if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( PatternSyntaxException pse ) { return FormValidation . error ( pse . getMessage ( ) ) ; } } return FormValidation . ok ( ) ; } } @ Deprecated public static List < ListViewColumn > getDefaultColumns ( ) { return ListViewColumn . createDefaultInitialColumnList ( ) ; } @ Restricted ( NoExternalUse . class ) @ Extension public static final class Listener extends ItemListener { @ Override public void onLocationChanged ( final Item item , final String oldFullName , final String newFullName ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { locationChanged ( item , oldFullName , newFullName ) ; } } ) ; } private void locationChanged ( Item item , String oldFullName , String newFullName ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { renameViewItem ( oldFullName , newFullName , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { renameViewItem ( oldFullName , newFullName , vg , ( ListView ) v ) ; } } } } } private void renameViewItem ( String oldFullName , String newFullName , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { Set < String > oldJobNames = new HashSet < String > ( lv . jobNames ) ; lv . jobNames . clear ( ) ; for ( String oldName : oldJobNames ) { lv . jobNames . add ( Items . computeRelativeNamesAfterRenaming ( oldFullName , newFullName , oldName , vg . getItemGroup ( ) ) ) ; } needsSave = ! oldJobNames . equals ( lv . jobNames ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } @ Override public void onDeleted ( final Item item ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { deleted ( item ) ; } } ) ; } private void deleted ( Item item ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { deleteViewItem ( item , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { deleteViewItem ( item , vg , ( ListView ) v ) ; } } } } } private void deleteViewItem ( Item item , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { needsSave = lv . jobNames . remove ( item . getRelativeNameFrom ( vg . getItemGroup ( ) ) ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="JetBrains/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/lambda2methodReference/afterAmbiguityWithoutSuperMethodNonStatic.java"> interface I { String foo ( Foo i ) ; } class Foo { public String foo ( ) { return null ; } String foo ( int i ) { return null ; } String foo ( Foo foo ) { return null ; } public static void main ( String [ ] args ) { I i = Foo :: foo ; } } </DOCUMENT>
<DOCUMENT_ID="christer155/IntegratingFacebookTutorial/tree/master/IntegratingFacebookTutorial-Unity/Assets/Plugins/Android/facebook/src/com/facebook/internal/ImageResponseCache.java"> package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="slburson/fast-serialization/tree/master/src/main/java/org/nustaq/serialization/serializers/FSTCPEnumSetSerializer.java"> package org . nustaq . serialization . serializers ; import org . nustaq . serialization . FSTBasicObjectSerializer ; import org . nustaq . serialization . FSTClazzInfo ; import org . nustaq . serialization . FSTObjectInput ; import org . nustaq . serialization . FSTObjectOutput ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . EnumSet ; public class FSTCPEnumSetSerializer extends FSTBasicObjectSerializer { Field elemType ; @ Override public void writeObject ( FSTObjectOutput out , Object toWrite , FSTClazzInfo clzInfo , FSTClazzInfo . FSTFieldInfo referencedBy , int streamPosition ) throws IOException { EnumSet enset = ( EnumSet ) toWrite ; int count = 0 ; out . writeInt ( enset . size ( ) ) ; if ( enset . isEmpty ( ) ) { EnumSet compl = EnumSet . complementOf ( enset ) ; out . writeClassTag ( compl . iterator ( ) . next ( ) . getClass ( ) ) ; } else { for ( Object element : enset ) { if ( count == 0 ) { out . writeStringUTF ( element . getClass ( ) . getName ( ) ) ; } out . writeStringUTF ( element . toString ( ) ) ; count ++ ; } } } @ Override public boolean alwaysCopy ( ) { return false ; } @ Override public Object instantiate ( Class objectClass , FSTObjectInput in , FSTClazzInfo serializationInfo , FSTClazzInfo . FSTFieldInfo referencee , int streamPosition ) throws Exception { int len = in . readInt ( ) ; Class elemCl = in . getClassForName ( in . readStringUTF ( ) ) ; EnumSet enSet = EnumSet . noneOf ( elemCl ) ; in . registerObject ( enSet , streamPosition , serializationInfo , referencee ) ; for ( int i = 0 ; i < len ; i ++ ) { String val = in . readStringUTF ( ) ; enSet . add ( Enum . valueOf ( elemCl , val ) ) ; } return enSet ; } } </DOCUMENT>
<DOCUMENT_ID="sklintyg/infra/tree/master/sjukfall/engine/src/test/java/se/inera/intyg/infra/sjukfall/engine/SjukfallIntygEnhetCreatorTest.java"> package se . inera . intyg . infra . sjukfall . engine ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import java . io . IOException ; import java . time . LocalDate ; import java . util . List ; import java . util . Map ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . junit . MockitoJUnitRunner ; import se . inera . intyg . infra . sjukfall . dto . IntygData ; import se . inera . intyg . infra . sjukfall . dto . IntygParametrar ; import se . inera . intyg . infra . sjukfall . dto . SjukfallIntyg ; import se . inera . intyg . infra . sjukfall . testdata . SjukfallIntygGenerator ; @ RunWith ( MockitoJUnitRunner . class ) public class SjukfallIntygEnhetCreatorTest { private static final String LOCATION_INTYGSDATA = " classpath : Sjukfall / Enhet / intygsdata - creator . csv " ; private static List < IntygData > intygDataList ; private SjukfallIntygEnhetCreator creator ; private IntygParametrar parameters ; @ BeforeClass public static void initTestData ( ) throws IOException { SjukfallIntygGenerator generator = new SjukfallIntygGenerator ( LOCATION_INTYGSDATA ) ; intygDataList = generator . generate ( ) . get ( ) ; assertTrue ( " Expected ▁ 16 ▁ but ▁ was ▁ " + intygDataList . size ( ) , intygDataList . size ( ) == 16 ) ; } @ Before public void setup ( ) { creator = new SjukfallIntygEnhetCreator ( ) ; parameters = new IntygParametrar ( 5 , LocalDate . parse ( "2016-02-16" ) ) ; } @ Test public void testCreatingMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ but ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; } @ Test public void testReducedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > reducedMap = creator . reduceMap ( map ) ; assertTrue ( " Expected ▁ 6 ▁ but ▁ was ▁ " + reducedMap . size ( ) , reducedMap . size ( ) == 6 ) ; } @ Test public void testSortedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > sortedMap = creator . sortValues ( map ) ; for ( Map . Entry < String , List < SjukfallIntyg > > entry : sortedMap . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { SjukfallIntyg [ ] arr = entry . getValue ( ) . toArray ( new SjukfallIntyg [ entry . getValue ( ) . size ( ) ] ) ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { assertTrue ( arr [ i ] . getSlutDatum ( ) . isBefore ( arr [ i + 1 ] . getSlutDatum ( ) ) ) ; } } } } @ Test public void testSetActiveCertificate ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > activeMap = creator . setActive ( map ) ; assertTrue ( activeMap . entrySet ( ) . stream ( ) . allMatch ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . isAktivtIntyg ( ) ) . count ( ) < 2 ) ) ; } @ Test public void testFall1 ( ) { String key = "19791110-9291" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall2 ( ) { String key = "19791123-9262" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall3 ( ) { String key = "19791212-9280" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall4 ( ) { String key = "19800113-9297" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall5 ( ) { String key = "19800124-9286" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertTrue ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertFalse ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall6 ( ) { String key = "19800207-9294" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertFalse ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall7 ( ) { String key = "19800228-9224" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; assertNull ( map . get ( key ) ) ; } private static void assertStartDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getStartDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } private static void assertEndDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getSlutDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="murador/ignite/tree/master/modules/core/src/main/java/org/apache/ignite/internal/GridJobSiblingsResponse.java"> package org . apache . ignite . internal ; import java . io . Externalizable ; import java . nio . ByteBuffer ; import java . util . Collection ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . compute . ComputeJobSibling ; import org . apache . ignite . internal . util . typedef . internal . S ; import org . apache . ignite . marshaller . Marshaller ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . plugin . extensions . communication . MessageReader ; import org . apache . ignite . plugin . extensions . communication . MessageWriter ; import org . jetbrains . annotations . Nullable ; public class GridJobSiblingsResponse implements Message { private static final long serialVersionUID = 0L ; @ GridDirectTransient private Collection < ComputeJobSibling > siblings ; private byte [ ] siblingsBytes ; public GridJobSiblingsResponse ( ) { } public GridJobSiblingsResponse ( @ Nullable Collection < ComputeJobSibling > siblings , @ Nullable byte [ ] siblingsBytes ) { this . siblings = siblings ; this . siblingsBytes = siblingsBytes ; } public Collection < ComputeJobSibling > jobSiblings ( ) { return siblings ; } public void unmarshalSiblings ( Marshaller marsh ) throws IgniteCheckedException { assert marsh != null ; if ( siblingsBytes != null ) siblings = marsh . unmarshal ( siblingsBytes , null ) ; } @ Override public void onAckReceived ( ) { } @ Override public boolean writeTo ( ByteBuffer buf , MessageWriter writer ) { writer . setBuffer ( buf ) ; if ( ! writer . isHeaderWritten ( ) ) { if ( ! writer . writeHeader ( directType ( ) , fieldsCount ( ) ) ) return false ; writer . onHeaderWritten ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . writeByteArray ( " siblingsBytes " , siblingsBytes ) ) return false ; writer . incrementState ( ) ; } return true ; } @ Override public boolean readFrom ( ByteBuffer buf , MessageReader reader ) { reader . setBuffer ( buf ) ; if ( ! reader . beforeMessageRead ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : siblingsBytes = reader . readByteArray ( " siblingsBytes " ) ; if ( ! reader . isLastRead ( ) ) return false ; reader . incrementState ( ) ; } return reader . afterMessageRead ( GridJobSiblingsResponse . class ) ; } @ Override public byte directType ( ) { return 4 ; } @ Override public byte fieldsCount ( ) { return 1 ; } @ Override public String toString ( ) { return S . toString ( GridJobSiblingsResponse . class , this ) ; } } </DOCUMENT>
<DOCUMENT_ID="shlee89/athena/tree/master/web/gui/src/main/java/org/onosproject/ui/impl/TunnelViewMessageHandler.java"> package org . onosproject . ui . impl ; import com . fasterxml . jackson . databind . node . ObjectNode ; import com . google . common . collect . ImmutableSet ; import org . onosproject . incubator . net . tunnel . Tunnel ; import org . onosproject . incubator . net . tunnel . TunnelEndPointFormatter ; import org . onosproject . incubator . net . tunnel . TunnelService ; import org . onosproject . ui . RequestHandler ; import org . onosproject . ui . UiMessageHandler ; import org . onosproject . ui . table . TableModel ; import org . onosproject . ui . table . TableRequestHandler ; import org . onosproject . ui . table . cell . EnumFormatter ; import java . util . Collection ; public class TunnelViewMessageHandler extends UiMessageHandler { private static final String TUNNEL_DATA_REQ = " tunnelDataRequest " ; private static final String TUNNEL_DATA_RESP = " tunnelDataResponse " ; private static final String TUNNELS = " tunnels " ; private static final String ID = " id " ; private static final String NAME = " name " ; private static final String ONE = " one " ; private static final String TWO = " two " ; private static final String TYPE = " type " ; private static final String GROUP_ID = " group _ id " ; private static final String BANDWIDTH = " bandwidth " ; private static final String PATH = " path " ; private static final String [ ] COL_IDS = { ID , NAME , ONE , TWO , TYPE , GROUP_ID , BANDWIDTH , PATH } ; @ Override protected Collection < RequestHandler > createRequestHandlers ( ) { return ImmutableSet . of ( new TunnelDataRequestHandler ( ) ) ; } private final class TunnelDataRequestHandler extends TableRequestHandler { private static final String NO_ROWS_MESSAGE = " No ▁ tunnels ▁ found " ; public TunnelDataRequestHandler ( ) { super ( TUNNEL_DATA_REQ , TUNNEL_DATA_RESP , TUNNELS ) ; } @ Override protected String [ ] getColumnIds ( ) { return COL_IDS ; } @ Override protected String noRowsMessage ( ObjectNode payload ) { return NO_ROWS_MESSAGE ; } @ Override protected TableModel createTableModel ( ) { TableModel tm = super . createTableModel ( ) ; tm . setFormatter ( ONE , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TWO , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TYPE , EnumFormatter . INSTANCE ) ; return tm ; } @ Override protected void populateTable ( TableModel tm , ObjectNode payload ) { TunnelService ts = get ( TunnelService . class ) ; ts . queryAllTunnels ( ) . forEach ( tunnel -> populateRow ( tm . addRow ( ) , tunnel ) ) ; } } private void populateRow ( TableModel . Row row , Tunnel tunnel ) { row . cell ( ID , tunnel . tunnelId ( ) . id ( ) ) . cell ( NAME , tunnel . tunnelName ( ) . value ( ) ) . cell ( ONE , tunnel . src ( ) ) . cell ( TWO , tunnel . dst ( ) ) . cell ( TYPE , tunnel . type ( ) ) . cell ( GROUP_ID , tunnel . groupId ( ) . id ( ) ) . cell ( BANDWIDTH , tunnel . annotations ( ) . value ( BANDWIDTH ) ) . cell ( PATH , tunnel . path ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="Lotusun/OfficeHelper/tree/master/src/main/java/com/charlesdream/office/word/objects/Style.java"> package com . charlesdream . office . word . objects ; import com . charlesdream . office . BaseObject ; import com . jacob . com . Dispatch ; public class Style extends BaseObject { public Style ( Dispatch dispatch ) { super ( dispatch ) ; } } </DOCUMENT>
<DOCUMENT_ID="borcsokj/camel/tree/master/components/camel-apns/src/test/java/org/apache/camel/component/apns/ApnsProducerTest.java"> package org . apache . camel . component . apns ; import com . notnoop . apns . APNS ; import com . notnoop . apns . ApnsService ; import com . notnoop . apns . EnhancedApnsNotification ; import com . notnoop . apns . utils . ApnsServerStub ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . component . apns . factory . ApnsServiceFactory ; import org . apache . camel . component . apns . model . ApnsConstants ; import org . apache . camel . component . apns . model . MessageType ; import org . apache . camel . component . apns . util . ApnsUtils ; import org . apache . camel . component . apns . util . TestConstants ; import org . apache . camel . test . junit4 . CamelTestSupport ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; public class ApnsProducerTest extends CamelTestSupport { private static final String FAKE_TOKEN = "19308314834701ACD8313AEBD92AEFDE192120371FE13982392831701318B943" ; private ApnsServerStub server ; @ Before public void startup ( ) { server = ApnsUtils . prepareAndStartServer ( TestConstants . TEST_GATEWAY_PORT , TestConstants . TEST_FEEDBACK_PORT ) ; } @ After public void stop ( ) { server . stop ( ) ; } @ Test ( timeout = 5000 ) public void testProducer ( ) throws Exception { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 1 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : test " , message ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } @ Test ( timeout = 5000 ) public void testProducerWithApnsNotification ( ) throws InterruptedException { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; final EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 14 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : testWithApnsNotification " , apnsNotification ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } protected CamelContext createCamelContext ( ) throws Exception { CamelContext camelContext = super . createCamelContext ( ) ; ApnsServiceFactory apnsServiceFactory = ApnsUtils . createDefaultTestConfiguration ( camelContext ) ; ApnsService apnsService = apnsServiceFactory . getApnsService ( ) ; ApnsComponent apnsComponent = new ApnsComponent ( apnsService ) ; camelContext . addComponent ( " apns " , apnsComponent ) ; return camelContext ; } protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : test " ) . setHeader ( ApnsConstants . HEADER_TOKENS , constant ( FAKE_TOKEN ) ) . to ( " apns : notify " ) ; from ( " direct : testWithApnsNotification " ) . setHeader ( ApnsConstants . HEADER_MESSAGE_TYPE , constant ( MessageType . APNS_NOTIFICATION . name ( ) ) ) . to ( " apns : notify " ) ; } } ; } } </DOCUMENT>
<DOCUMENT_ID="crockpotveggies/deeplearning4j/tree/master/deeplearning4j-ui-parent/deeplearning4j-ui/src/test/java/org/deeplearning4j/ui/weights/HistogramBinTest.java"> package org . deeplearning4j . ui . weights ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import java . math . BigDecimal ; import static org . junit . Assert . assertEquals ; public class HistogramBinTest { @ Before public void setUp ( ) throws Exception { } @ Test public void testGetBins ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getBins ( ) ) ; assertEquals ( 2 , histogram . getBins ( ) . getDouble ( 9 ) , 0.001 ) ; } @ Test public void testGetData1 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; } @ Test public void testGetData2 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } @ Test public void testGetData4 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 50 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 50 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="farkas-arpad/KROKI-mockup-tool/tree/master/GraphEdit/src/graphedit/state/SelectionState.java"> package graphedit . state ; import graphedit . actions . popup . LinkPopupMenu ; import graphedit . app . MainFrame ; import graphedit . command . ChangeAssociationPropertiesCommand ; import graphedit . command . ChangeElementPropertiesCommand ; import graphedit . command . ChangeLinkTypeCommand ; import graphedit . command . Command ; import graphedit . gui . dialog . AssociationLinkDialog ; import graphedit . gui . dialog . ClassElementDialog ; import graphedit . model . components . AggregationLink ; import graphedit . model . components . AssociationLink ; import graphedit . model . components . Class ; import graphedit . model . components . CompositionLink ; import graphedit . model . components . GraphElement ; import graphedit . model . components . Link ; import graphedit . model . components . LinkNode ; import graphedit . model . components . Package ; import graphedit . model . properties . PropertyEnums . GraphElementProperties ; import graphedit . view . AggregationLinkPainter ; import graphedit . view . AssociationLinkPainter ; import graphedit . view . CompositionLinkPainter ; import graphedit . view . ElementPainter ; import graphedit . view . LinkPainter ; import java . awt . Cursor ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . geom . Dimension2D ; import java . awt . geom . Point2D ; import java . util . ArrayList ; import java . util . List ; import javax . swing . SwingUtilities ; public class SelectionState extends State { private Point2D popupPoint ; public SelectionState ( ) { super ( ) ; } @ Override public void mouseReleased ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isRightMouseButton ( e ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; if ( hitElement != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; showGraphElementPopup ( e ) ; } else if ( hitLink != null || hitNode != null ) { showLinkElementPopup ( e ) ; } else showGraphElementPopup ( e ) ; view . repaint ( ) ; } } @ Override public void mousePressed ( MouseEvent e ) { Link hitLink = controller . getCurrentLink ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; GraphElement hitElement = controller . getCurrentElement ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null ) view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; else { view . getSelectionModel ( ) . setSelectedLink ( null ) ; if ( hitElement != null ) { if ( e . isControlDown ( ) ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeSelectedElement ( hitElement ) ; } else { view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } else { if ( ! view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { if ( ! e . isControlDown ( ) ) view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; } } } else if ( SwingUtilities . isRightMouseButton ( e ) ) { if ( hitElement != null ) { view . getSelectionModel ( ) . setSelectedLink ( null ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } else if ( hitNode != null ) { view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; } } view . repaint ( ) ; } @ Override public void mouseDragged ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = view . getSelectionModel ( ) . getSelectedNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null || ( hitLink != null && hitElement == null ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; state . mousePressed ( e ) ; } else if ( hitElement != null ) { if ( MainFrame . getInstance ( ) . getCurrentView ( ) . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { if ( e . isControlDown ( ) ) { } if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; ( ( MoveElementState ) state ) . setElements ( view . getSelectionModel ( ) . getSelectedElements ( ) ) ; ( ( MoveElementState ) state ) . setRightMove ( false ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getResizeState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . mousePressed ( e ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getLassoSelectionState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else if ( SwingUtilities . isRightMouseButton ( e ) && hitElement != null ) { if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; List < GraphElement > shadowElements = new ArrayList < GraphElement > ( ) ; List < ElementPainter > shadowPainters = new ArrayList < ElementPainter > ( ) ; for ( GraphElement element : view . getSelectionModel ( ) . getSelectedElements ( ) ) { try { GraphElement clone = ( GraphElement ) element . clone ( ) ; clone . setShadowElement ( true ) ; ElementPainter clonePainter = ( ElementPainter ) view . getElementPainter ( element ) . clone ( ) ; clonePainter . setElement ( clone ) ; shadowElements . add ( clone ) ; shadowPainters . add ( clonePainter ) ; } catch ( CloneNotSupportedException e1 ) { e1 . printStackTrace ( ) ; } } view . setShadowPainters ( shadowPainters ) ; ( ( MoveElementState ) state ) . setElements ( shadowElements ) ; ( ( MoveElementState ) state ) . setRightMove ( true ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else { if ( hitElement != null ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { } } } } @ Override public void mouseMoved ( MouseEvent e ) { int xPos = e . getX ( ) ; int yPos = e . getY ( ) ; MainFrame . getInstance ( ) . setPositionTrack ( xPos , yPos ) ; if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) == 1 ) { GraphElement selectedElement = view . getSelectionModel ( ) . getSelectedElements ( ) . get ( 0 ) ; Dimension2D size = ( Dimension2D ) selectedElement . getProperty ( GraphElementProperties . SIZE ) ; Point2D position = new Point2D . Double ( ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getX ( ) - size . getWidth ( ) / 2 , ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getY ( ) - size . getHeight ( ) / 2 ) ; if ( position . getX ( ) <= xPos && xPos <= position . getX ( ) + 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NW_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . W_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SW_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + 4 < xPos && xPos < position . getX ( ) + size . getWidth ( ) - 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . N_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . S_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + size . getWidth ( ) - 4 <= xPos && xPos <= position . getX ( ) + size . getWidth ( ) ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NE_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . E_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SE_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } @ Override public void keyPressed ( KeyEvent e ) { if ( e . isControlDown ( ) && e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) > 0 ) { } } } @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) if ( e . getClickCount ( ) == 2 ) { Link hitLink = controller . getCurrentLink ( ) ; if ( hitLink != null ) { if ( hitLink instanceof AssociationLink ) { AssociationLinkDialog d = new AssociationLinkDialog ( ( AssociationLink ) hitLink ) ; d . setVisible ( true ) ; if ( d . isSomethingChanged ( ) ) { if ( d . isCreateNewLink ( ) ) { AssociationLink newLink ; LinkPainter painter = null ; if ( d . isAssociation ( ) ) { newLink = new AssociationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AssociationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AssociationLinkPainter ( newLink ) ; } else if ( d . isAggregation ( ) ) { newLink = new AggregationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AggregationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AggregationLinkPainter ( newLink ) ; } else { newLink = new CompositionLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " CompositionLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new CompositionLinkPainter ( newLink ) ; } Command command = new ChangeLinkTypeCommand ( view , hitLink , newLink , painter ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; newLink . getSourceConnector ( ) . setLink ( newLink ) ; newLink . getDestinationConnector ( ) . setLink ( newLink ) ; } else { Command command = new ChangeAssociationPropertiesCommand ( view , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , ( AssociationLink ) hitLink ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; } view . repaint ( ) ; } } } else { GraphElement element = controller . getCurrentElement ( ) ; if ( element instanceof Package ) MainFrame . getInstance ( ) . showDiagram ( ( ( Package ) element ) . getHierarchyPackage ( ) . getDiagram ( ) ) ; else if ( element instanceof graphedit . model . components . Class ) { ClassElementDialog dialog = new ClassElementDialog ( ( Class ) element ) ; dialog . setVisible ( true ) ; if ( dialog . isOk ( ) ) { Command command = new ChangeElementPropertiesCommand ( view , dialog . getName ( ) , dialog . getStereotype ( ) , element ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; view . repaint ( ) ; } } } } } public void showGraphElementPopup ( MouseEvent e ) { MainFrame . getInstance ( ) . getViewPopupMenu ( ) . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } public void showLinkElementPopup ( MouseEvent e ) { LinkPopupMenu popup = MainFrame . getInstance ( ) . getLinkPopupMenu ( ) ; popup . preparePopup ( ) ; popup . setActionPoint ( e . getPoint ( ) ) ; popup . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } @ Override public boolean isAutoScrollOnDragEnabled ( ) { return false ; } @ Override public boolean isAutoScrollOnMoveEnabled ( ) { return false ; } public Point2D getPopupPoint ( ) { return popupPoint ; } public void setPopupPoint ( Point2D popupPoint ) { this . popupPoint = popupPoint ; } } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/compiler/impl/src/com/intellij/compiler/impl/javaCompiler/javac/JavacCompiler.java"> package com . intellij . compiler . impl . javaCompiler . javac ; import com . intellij . compiler . impl . javaCompiler . BackendCompiler ; import com . intellij . openapi . compiler . CompilerBundle ; import com . intellij . openapi . fileTypes . FileType ; import com . intellij . openapi . fileTypes . StdFileTypes ; import com . intellij . openapi . options . Configurable ; import com . intellij . openapi . project . Project ; import org . jetbrains . annotations . NonNls ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . jps . model . java . compiler . JavaCompilers ; import java . util . Collections ; import java . util . Set ; public class JavacCompiler implements BackendCompiler { private final Project myProject ; public JavacCompiler ( Project project ) { myProject = project ; } @ NotNull @ NonNls public String getId ( ) { return JavaCompilers . JAVAC_ID ; } @ NotNull public String getPresentableName ( ) { return CompilerBundle . message ( " compiler . javac . name " ) ; } @ NotNull public Configurable createConfigurable ( ) { return new JavacConfigurable ( JavacConfiguration . getOptions ( myProject , JavacConfiguration . class ) ) ; } @ NotNull public Set < FileType > getCompilableFileTypes ( ) { return Collections . < FileType > singleton ( StdFileTypes . JAVA ) ; } } </DOCUMENT>
<DOCUMENT_ID="jondong/crosswalk/tree/master/third_party/lzma_sdk/src/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
<DOCUMENT_ID="ajhalani/elasticsearch/tree/master/src/main/java/org/elasticsearch/common/logging/log4j/LogConfigurator.java"> package org . elasticsearch . common . logging . log4j ; import com . google . common . collect . ImmutableMap ; import org . apache . log4j . PropertyConfigurator ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . settings . ImmutableSettings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . FailedToResolveConfigException ; import java . io . IOException ; import java . net . MalformedURLException ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . EnumSet ; import java . util . Map ; import java . util . Properties ; import static org . elasticsearch . common . settings . ImmutableSettings . settingsBuilder ; public class LogConfigurator { private static boolean loaded ; private static ImmutableMap < String , String > replacements = new MapBuilder < String , String > ( ) . put ( " console " , " org . elasticsearch . common . logging . log4j . ConsoleAppender " ) . put ( " async " , " org . apache . log4j . AsyncAppender " ) . put ( " dailyRollingFile " , " org . apache . log4j . DailyRollingFileAppender " ) . put ( " externallyRolledFile " , " org . apache . log4j . ExternallyRolledFileAppender " ) . put ( " file " , " org . apache . log4j . FileAppender " ) . put ( " jdbc " , " org . apache . log4j . jdbc . JDBCAppender " ) . put ( " jms " , " org . apache . log4j . net . JMSAppender " ) . put ( " lf5" , " org . apache . log4j . lf5 . LF5Appender " ) . put ( " ntevent " , " org . apache . log4j . nt . NTEventLogAppender " ) . put ( " null " , " org . apache . log4j . NullAppender " ) . put ( " rollingFile " , " org . apache . log4j . RollingFileAppender " ) . put ( " smtp " , " org . apache . log4j . net . SMTPAppender " ) . put ( " socket " , " org . apache . log4j . net . SocketAppender " ) . put ( " socketHub " , " org . apache . log4j . net . SocketHubAppender " ) . put ( " syslog " , " org . apache . log4j . net . SyslogAppender " ) . put ( " telnet " , " org . apache . log4j . net . TelnetAppender " ) . put ( " simple " , " org . apache . log4j . SimpleLayout " ) . put ( " html " , " org . apache . log4j . HTMLLayout " ) . put ( " pattern " , " org . apache . log4j . PatternLayout " ) . put ( " consolePattern " , " org . apache . log4j . PatternLayout " ) . put ( " ttcc " , " org . apache . log4j . TTCCLayout " ) . put ( " xml " , " org . apache . log4j . XMLLayout " ) . immutableMap ( ) ; public static void configure ( Settings settings ) { if ( loaded ) { return ; } loaded = true ; Environment environment = new Environment ( settings ) ; ImmutableSettings . Builder settingsBuilder = settingsBuilder ( ) . put ( settings ) ; resolveConfig ( environment , settingsBuilder ) ; settingsBuilder . putProperties ( " elasticsearch . " , System . getProperties ( ) ) . putProperties ( " es . " , System . getProperties ( ) ) . replacePropertyPlaceholders ( ) ; Properties props = new Properties ( ) ; for ( Map . Entry < String , String > entry : settingsBuilder . build ( ) . getAsMap ( ) . entrySet ( ) ) { String key = " log4j . " + entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( replacements . containsKey ( value ) ) { value = replacements . get ( value ) ; } if ( key . endsWith ( " . value " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . endsWith ( " . type " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { props . setProperty ( key , value ) ; } } PropertyConfigurator . configure ( props ) ; } public static void resolveConfig ( Environment env , final ImmutableSettings . Builder settingsBuilder ) { try { Files . walkFileTree ( env . configFile ( ) . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . startsWith ( " logging . " ) ) { loadConfig ( file , settingsBuilder ) ; } return FileVisitResult . CONTINUE ; } } ) ; } catch ( IOException ioe ) { throw new ElasticsearchException ( " Failed ▁ to ▁ load ▁ logging ▁ configuration " , ioe ) ; } } public static void loadConfig ( Path file , ImmutableSettings . Builder settingsBuilder ) { try { settingsBuilder . loadFromUrl ( file . toUri ( ) . toURL ( ) ) ; } catch ( FailedToResolveConfigException | NoClassDefFoundError | MalformedURLException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="rsf/RSFUtil/tree/master/src/uk/org/ponder/rsf/flow/jsfnav/support/NavigationRule.java"> package uk . org . ponder . rsf . flow . jsfnav . support ; import java . util . List ; import uk . org . ponder . rsf . viewstate . ViewParameters ; public class NavigationRule { public ViewParameters fromViewId ; public List navigationCases ; } </DOCUMENT>
<DOCUMENT_ID="IllusionRom-deprecated/android_platform_tools_idea/tree/master/java/java-analysis-impl/src/com/intellij/codeInspection/NumericOverflowInspection.java"> package com . intellij . codeInspection ; import com . intellij . codeInsight . daemon . GroupNames ; import com . intellij . codeInsight . daemon . JavaErrorMessages ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . util . Key ; import com . intellij . psi . * ; import com . intellij . psi . util . ConstantEvaluationOverflowException ; import com . intellij . psi . util . TypeConversionUtil ; import org . jetbrains . annotations . Nls ; import org . jetbrains . annotations . NotNull ; public class NumericOverflowInspection extends BaseJavaBatchLocalInspectionTool { private static final Key < String > HAS_OVERFLOW_IN_CHILD = Key . create ( " HAS _ OVERFLOW _ IN _ CHILD " ) ; @ Nls @ NotNull @ Override public String getGroupDisplayName ( ) { return GroupNames . NUMERIC_GROUP_NAME ; } @ Nls @ NotNull @ Override public String getDisplayName ( ) { return " Numeric ▁ overflow " ; } @ NotNull @ Override public String getShortName ( ) { return " NumericOverflow " ; } @ NotNull @ Override public PsiElementVisitor buildVisitor ( @ NotNull final ProblemsHolder holder , boolean isOnTheFly ) { return new JavaElementVisitor ( ) { @ Override public void visitReferenceExpression ( PsiReferenceExpression expression ) { visitExpression ( expression ) ; } @ Override public void visitExpression ( PsiExpression expression ) { boolean info = hasOverflow ( expression , holder . getProject ( ) ) ; if ( info ) { holder . registerProblem ( expression , JavaErrorMessages . message ( " numeric . overflow . in . expression " ) , ProblemHighlightType . GENERIC_ERROR_OR_WARNING ) ; } } } ; } private static boolean hasOverflow ( PsiExpression expr , @ NotNull Project project ) { if ( ! TypeConversionUtil . isNumericType ( expr . getType ( ) ) ) return false ; boolean overflow = false ; try { if ( expr . getUserData ( HAS_OVERFLOW_IN_CHILD ) == null ) { JavaPsiFacade . getInstance ( project ) . getConstantEvaluationHelper ( ) . computeConstantExpression ( expr , true ) ; } else { overflow = true ; } } catch ( ConstantEvaluationOverflowException e ) { overflow = true ; } finally { PsiElement parent = expr . getParent ( ) ; if ( overflow && parent instanceof PsiExpression ) { parent . putUserData ( HAS_OVERFLOW_IN_CHILD , " " ) ; } } return overflow ; } } </DOCUMENT>
<DOCUMENT_ID="yuanke/hadoop-hbase/tree/master/src/test/org/apache/hadoop/mapred/TestKillCompletedJob.java"> package org . apache . hadoop . mapred ; import java . io . * ; import java . net . * ; import junit . framework . TestCase ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hdfs . MiniDFSCluster ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IntWritable ; import org . apache . hadoop . io . Text ; public class TestKillCompletedJob extends TestCase { static Boolean launchWordCount ( String fileSys , String jobTracker , JobConf conf , String input , int numMaps , int numReduces ) throws IOException { final Path inDir = new Path ( " / testing / wc / input " ) ; final Path outDir = new Path ( " / testing / wc / output " ) ; FileSystem fs = FileSystem . get ( URI . create ( fileSys ) , conf ) ; fs . delete ( outDir , true ) ; if ( ! fs . mkdirs ( inDir ) ) { throw new IOException ( " Mkdirs ▁ failed ▁ to ▁ create ▁ " + inDir . toString ( ) ) ; } { DataOutputStream file = fs . create ( new Path ( inDir , " part - 0" ) ) ; file . writeBytes ( input ) ; file . close ( ) ; } FileSystem . setDefaultUri ( conf , fileSys ) ; conf . set ( " mapred . job . tracker " , jobTracker ) ; conf . setJobName ( " wordcount " ) ; conf . setInputFormat ( TextInputFormat . class ) ; conf . setOutputKeyClass ( Text . class ) ; conf . setOutputValueClass ( IntWritable . class ) ; conf . setMapperClass ( WordCount . MapClass . class ) ; conf . setCombinerClass ( WordCount . Reduce . class ) ; conf . setReducerClass ( WordCount . Reduce . class ) ; FileInputFormat . setInputPaths ( conf , inDir ) ; FileOutputFormat . setOutputPath ( conf , outDir ) ; conf . setNumMapTasks ( numMaps ) ; conf . setNumReduceTasks ( numReduces ) ; RunningJob rj = JobClient . runJob ( conf ) ; JobID jobId = rj . getID ( ) ; if ( rj . isSuccessful ( ) ) { System . out . println ( " Job ▁ Id : " + jobId + " ▁ completed ▁ successfully . ▁ Killing ▁ it ▁ now " ) ; rj . killJob ( ) ; } return rj . isSuccessful ( ) ; } public void testKillCompJob ( ) throws IOException { String namenode = null ; MiniDFSCluster dfs = null ; MiniMRCluster mr = null ; FileSystem fileSys = null ; try { final int taskTrackers = 1 ; Configuration conf = new Configuration ( ) ; dfs = new MiniDFSCluster ( conf , 1 , true , null ) ; fileSys = dfs . getFileSystem ( ) ; namenode = fileSys . getUri ( ) . toString ( ) ; mr = new MiniMRCluster ( taskTrackers , namenode , 3 ) ; JobConf jobConf = new JobConf ( ) ; Boolean result ; final String jobTrackerName = " localhost : " + mr . getJobTrackerPort ( ) ; result = launchWordCount ( namenode , jobTrackerName , jobConf , " Small ▁ text \n " , 1 , 0 ) ; assertTrue ( result ) ; } finally { if ( dfs != null ) { dfs . shutdown ( ) ; } if ( mr != null ) { mr . shutdown ( ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="Communote/communote-server/tree/master/communote/persistence/src/main/java/com/communote/server/core/tag/TagStoreNotFoundException.java"> package com . communote . server . core . tag ; import com . communote . server . api . core . common . NotFoundException ; public class TagStoreNotFoundException extends NotFoundException { private static final long serialVersionUID = - 5089679368783279854L ; public TagStoreNotFoundException ( String message ) { super ( message ) ; } } </DOCUMENT>
<DOCUMENT_ID="mayonghui2112/helloWorld/tree/master/sourceCode/OnJava8-Examples-master/patterns/trash/Paper.java"> package patterns . trash ; public class Paper extends Trash { private static double val = 0.10f ; public Paper ( double wt ) { super ( wt ) ; } @ Override public double value ( ) { return val ; } public static void value ( double newVal ) { val = newVal ; } } </DOCUMENT>
<DOCUMENT_ID="signed/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="poiru/uni-spiffer/tree/master/spiffer/src/test/java/com/mohanathas/spiffer/algorithm/NodeTest.java"> package com . mohanathas . spiffer . algorithm ; import com . mohanathas . spiffer . util . Point ; import org . junit . Test ; import static org . junit . Assert . * ; public class NodeTest { public NodeTest ( ) { } @ Test public void testConstructor ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( 1 , node . getX ( ) ) ; assertEquals ( 2 , node . getY ( ) ) ; assertEquals ( new Point ( 1 , 2 ) , node . getPoint ( ) ) ; assertEquals ( Float . MAX_VALUE , node . getStartDistance ( ) , 0.001f ) ; assertEquals ( 0.0f , node . getGoalDistance ( ) , 0.001f ) ; } @ Test public void testCompareTo ( ) { final Node node1 = new Node ( 0 , 0 ) ; final Node node2 = new Node ( 0 , 0 ) ; node1 . setStartDistance ( 1.0f ) ; node1 . setGoalDistance ( 2.0f ) ; node2 . setStartDistance ( 2.0f ) ; node2 . setGoalDistance ( 1.0f ) ; assertEquals ( 0 , node1 . compareTo ( node2 ) ) ; node2 . setGoalDistance ( 3.0f ) ; assertEquals ( - 1 , node1 . compareTo ( node2 ) ) ; } @ Test public void testToString ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( " ( 1 , ▁ 2 ) " , node . toString ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="fengyouchao/sockslib/tree/master/src/main/java/sockslib/client/CommandReplyMessage.java"> package sockslib . client ; import sockslib . common . AddressType ; import sockslib . utils . SocksUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . UnknownHostException ; public class CommandReplyMessage implements SocksMessage { protected Logger logger = LoggerFactory . getLogger ( CommandReplyMessage . class ) ; private byte [ ] replyBytes ; public CommandReplyMessage ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } public boolean isSuccess ( ) { if ( replyBytes . length < 10 ) { return false ; } return replyBytes [ 1 ] == 0 ; } public InetAddress getIp ( ) throws UnknownHostException { byte [ ] addressBytes = null ; if ( replyBytes [ 3 ] == AddressType . IPV4 ) { addressBytes = new byte [ 4 ] ; } else if ( replyBytes [ 3 ] == AddressType . IPV6 ) { addressBytes = new byte [ 16 ] ; } System . arraycopy ( replyBytes , 4 , addressBytes , 0 , addressBytes . length ) ; return InetAddress . getByAddress ( addressBytes ) ; } public int getPort ( ) { return SocksUtil . bytesToInt ( replyBytes [ replyBytes . length - 2 ] , replyBytes [ replyBytes . length - 1 ] ) ; } public byte [ ] getReplyBytes ( ) { return replyBytes ; } public void setReplyBytes ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } public SocketAddress getSocketAddress ( ) { try { return new InetSocketAddress ( getIp ( ) , getPort ( ) ) ; } catch ( UnknownHostException e ) { logger . error ( e . getMessage ( ) , e ) ; } return null ; } } </DOCUMENT>
<DOCUMENT_ID="dotunolafunmiloye/hadoop-common/tree/master/src/test/core/org/apache/hadoop/io/file/tfile/Timer.java"> package org . apache . hadoop . io . file . tfile ; import java . io . IOException ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; public class Timer { long startTimeEpoch ; long finishTimeEpoch ; private DateFormat formatter = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; public void startTime ( ) throws IOException { startTimeEpoch = System . currentTimeMillis ( ) ; } public void stopTime ( ) throws IOException { finishTimeEpoch = System . currentTimeMillis ( ) ; } public long getIntervalMillis ( ) throws IOException { return finishTimeEpoch - startTimeEpoch ; } public void printlnWithTimestamp ( String message ) throws IOException { System . out . println ( formatCurrentTime ( ) + " ▁ ▁ " + message ) ; } public String formatTime ( long millis ) { return formatter . format ( millis ) ; } public String getIntervalString ( ) throws IOException { long time = getIntervalMillis ( ) ; return formatTime ( time ) ; } public String formatCurrentTime ( ) { return formatTime ( System . currentTimeMillis ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="iweiss/activemq-artemis/tree/master/tests/activemq5-unit-tests/src/test/java/org/apache/activemq/spring/SpringConsumer.java"> package org . apache . activemq . spring ; import javax . jms . Connection ; import javax . jms . ConnectionFactory ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageConsumer ; import javax . jms . MessageListener ; import javax . jms . Session ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . jms . core . JmsTemplate ; public class SpringConsumer extends ConsumerBean implements MessageListener { private static final Logger LOG = LoggerFactory . getLogger ( SpringConsumer . class ) ; private JmsTemplate template ; private String myId = " foo " ; private Destination destination ; private Connection connection ; private Session session ; private MessageConsumer consumer ; public void start ( ) throws JMSException { String selector = " next ▁ = ▁ ' " + myId + " ' " ; try { ConnectionFactory factory = template . getConnectionFactory ( ) ; final Connection c = connection = factory . createConnection ( ) ; synchronized ( c ) { if ( c . getClientID ( ) == null ) { c . setClientID ( myId ) ; } } connection . start ( ) ; session = connection . createSession ( true , Session . CLIENT_ACKNOWLEDGE ) ; consumer = session . createConsumer ( destination , selector , false ) ; consumer . setMessageListener ( this ) ; } catch ( JMSException ex ) { LOG . error ( " " , ex ) ; throw ex ; } } public void stop ( ) throws JMSException { if ( consumer != null ) { consumer . close ( ) ; } if ( session != null ) { session . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } @ Override public void onMessage ( Message message ) { super . onMessage ( message ) ; try { message . acknowledge ( ) ; } catch ( JMSException e ) { LOG . error ( " Failed ▁ to ▁ acknowledge : ▁ " + e , e ) ; } } public Destination getDestination ( ) { return destination ; } public void setDestination ( Destination destination ) { this . destination = destination ; } public String getMyId ( ) { return myId ; } public void setMyId ( String myId ) { this . myId = myId ; } public JmsTemplate getTemplate ( ) { return template ; } public void setTemplate ( JmsTemplate template ) { this . template = template ; } } </DOCUMENT>
<DOCUMENT_ID="apixandru/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="davidzchen/bazel/tree/master/third_party/java/proguard/proguard5.3.3/src/proguard/optimize/info/InstanceofClassMarker.java"> package proguard . optimize . info ; import proguard . classfile . * ; import proguard . classfile . attribute . CodeAttribute ; import proguard . classfile . constant . ClassConstant ; import proguard . classfile . constant . visitor . ConstantVisitor ; import proguard . classfile . instruction . * ; import proguard . classfile . instruction . visitor . InstructionVisitor ; import proguard . classfile . util . SimplifiedVisitor ; import proguard . classfile . visitor . ClassVisitor ; public class InstanceofClassMarker extends SimplifiedVisitor implements InstructionVisitor , ConstantVisitor , ClassVisitor { public void visitAnyInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , Instruction instruction ) { } public void visitConstantInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , ConstantInstruction constantInstruction ) { if ( constantInstruction . opcode == InstructionConstants . OP_INSTANCEOF ) { clazz . constantPoolEntryAccept ( constantInstruction . constantIndex , this ) ; } } public void visitClassConstant ( Clazz clazz , ClassConstant classConstant ) { classConstant . referencedClassAccept ( this ) ; } public void visitLibraryClass ( LibraryClass libraryClass ) { } public void visitProgramClass ( ProgramClass programClass ) { setInstanceofed ( programClass ) ; } private static void setInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; if ( info != null ) { info . setInstanceofed ( ) ; } } public static boolean isInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; return info == null || info . isInstanceofed ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="elastic-grid/Elastic-Grid/tree/master/modules/replicated-storage/src/main/java/com/elasticgrid/storage/replicated/ReplicatedContainer.java"> package com . elasticgrid . storage . replicated ; import com . elasticgrid . storage . Container ; import com . elasticgrid . storage . Storable ; import com . elasticgrid . storage . StorageException ; import com . elasticgrid . storage . StorableNotFoundException ; import java . util . Arrays ; import java . util . List ; import java . util . logging . Logger ; import java . io . File ; import java . io . InputStream ; public class ReplicatedContainer implements Container { private final Container preferred ; private final List < Container > otherContainers ; private static final Logger logger = Logger . getLogger ( ReplicatedContainer . class . getName ( ) ) ; public ReplicatedContainer ( Container preferred , List < Container > otherContainers ) { this . preferred = preferred ; this . otherContainers = otherContainers ; } public String getName ( ) { return null ; } public List < Storable > listStorables ( ) throws StorageException { return null ; } public Storable findStorableByName ( String name ) throws StorableNotFoundException , StorageException { return null ; } public Storable uploadStorable ( File file ) throws StorageException { return null ; } public Storable uploadStorable ( String name , File file ) throws StorageException { return null ; } public Storable uploadStorable ( String name , InputStream stream , String mimeType ) throws StorageException { return null ; } public void deleteStorable ( String name ) throws StorageException { } } </DOCUMENT>
<DOCUMENT_ID="scnakandala/derby/tree/master/java/engine/org/apache/derby/iapi/services/crypto/CipherProvider.java"> package org . apache . derby . iapi . services . crypto ; import java . security . Key ; import org . apache . derby . iapi . error . StandardException ; public interface CipherProvider { int encrypt ( byte [ ] cleartext , int offset , int length , byte [ ] ciphertext , int outputOffset ) throws StandardException ; int decrypt ( byte [ ] ciphertext , int offset , int length , byte [ ] cleartext , int outputOffset ) throws StandardException ; public int getEncryptionBlockSize ( ) ; } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="elijah513/ice/tree/master/java/test/src/main/java/test/Ice/location/ServerLocatorRegistry.java"> package test . Ice . location ; import test . Ice . location . Test . _TestLocatorRegistryDisp ; public class ServerLocatorRegistry extends _TestLocatorRegistryDisp { @ Override public void setAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setAdapterDirectProxy cb , String adapter , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; } else { _adapters . remove ( adapter ) ; } cb . ice_response ( ) ; } @ Override public void setReplicatedAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setReplicatedAdapterDirectProxy cb , String adapter , String replica , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; _adapters . put ( replica , object ) ; } else { _adapters . remove ( adapter ) ; _adapters . remove ( replica ) ; } cb . ice_response ( ) ; } @ Override public void setServerProcessProxy_async ( Ice . AMD_LocatorRegistry_setServerProcessProxy cb , String id , Ice . ProcessPrx proxy , Ice . Current current ) { } @ Override public void addObject ( Ice . ObjectPrx object , Ice . Current current ) { _objects . put ( object . ice_getIdentity ( ) , object ) ; } public Ice . ObjectPrx getAdapter ( String adapter ) throws Ice . AdapterNotFoundException { Ice . ObjectPrx obj = _adapters . get ( adapter ) ; if ( obj == null ) { throw new Ice . AdapterNotFoundException ( ) ; } return obj ; } public Ice . ObjectPrx getObject ( Ice . Identity id ) throws Ice . ObjectNotFoundException { Ice . ObjectPrx obj = _objects . get ( id ) ; if ( obj == null ) { throw new Ice . ObjectNotFoundException ( ) ; } return obj ; } private java . util . HashMap < String , Ice . ObjectPrx > _adapters = new java . util . HashMap < String , Ice . ObjectPrx > ( ) ; private java . util . HashMap < Ice . Identity , Ice . ObjectPrx > _objects = new java . util . HashMap < Ice . Identity , Ice . ObjectPrx > ( ) ; } </DOCUMENT>
<DOCUMENT_ID="iamjakob/elasticsearch/tree/master/core/src/test/java/org/elasticsearch/benchmark/search/aggregations/GlobalOrdinalsBenchmark.java"> package org . elasticsearch . benchmark . search . aggregations ; import com . carrotsearch . hppc . IntIntHashMap ; import com . carrotsearch . hppc . ObjectHashSet ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . stats . ClusterStatsResponse ; import org . elasticsearch . action . bulk . BulkRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . benchmark . search . aggregations . TermsAggregationSearchBenchmark . StatsResult ; import org . elasticsearch . bootstrap . BootstrapForTesting ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . indices . IndexAlreadyExistsException ; import org . elasticsearch . node . Node ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . transport . TransportModule ; import java . util . * ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . node . NodeBuilder . nodeBuilder ; public class GlobalOrdinalsBenchmark { private static final String INDEX_NAME = " index " ; private static final String TYPE_NAME = " type " ; private static final int QUERY_WARMUP = 25 ; private static final int QUERY_COUNT = 100 ; private static final int FIELD_START = 1 ; private static final int FIELD_LIMIT = 1 << 22 ; private static final boolean USE_DOC_VALUES = false ; static long COUNT = SizeValue . parseSizeValue ( "5m " ) . singles ( ) ; static Node node ; static Client client ; public static void main ( String [ ] args ) throws Exception { System . setProperty ( " es . logger . prefix " , " " ) ; BootstrapForTesting . ensureInitialized ( ) ; Random random = new Random ( ) ; Settings settings = settingsBuilder ( ) . put ( " index . refresh _ interval " , " - 1" ) . put ( SETTING_NUMBER_OF_SHARDS , 1 ) . put ( SETTING_NUMBER_OF_REPLICAS , 0 ) . put ( TransportModule . TRANSPORT_TYPE_KEY , " local " ) . build ( ) ; String clusterName = GlobalOrdinalsBenchmark . class . getSimpleName ( ) ; node = nodeBuilder ( ) . clusterName ( clusterName ) . settings ( settingsBuilder ( ) . put ( settings ) ) . node ( ) ; client = node . client ( ) ; try { client . admin ( ) . indices ( ) . prepareCreate ( INDEX_NAME ) . addMapping ( TYPE_NAME , jsonBuilder ( ) . startObject ( ) . startObject ( TYPE_NAME ) . startArray ( " dynamic _ templates " ) . startObject ( ) . startObject ( " default " ) . field ( " match " , " * " ) . field ( " match _ mapping _ type " , " string " ) . startObject ( " mapping " ) . field ( " type " , " string " ) . field ( " index " , " not _ analyzed " ) . startObject ( " fields " ) . startObject ( " doc _ values " ) . field ( " type " , " string " ) . field ( " index " , " no " ) . startObject ( " fielddata " ) . field ( " format " , " doc _ values " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; ObjectHashSet < String > uniqueTerms = new ObjectHashSet < > ( ) ; for ( int i = 0 ; i < FIELD_LIMIT ; i ++ ) { boolean added ; do { added = uniqueTerms . add ( RandomStrings . randomAsciiOfLength ( random , 16 ) ) ; } while ( ! added ) ; } String [ ] sValues = uniqueTerms . toArray ( String . class ) ; uniqueTerms = null ; BulkRequestBuilder builder = client . prepareBulk ( ) ; IntIntHashMap tracker = new IntIntHashMap ( ) ; for ( int i = 0 ; i < COUNT ; i ++ ) { Map < String , Object > fieldValues = new HashMap < > ( ) ; for ( int fieldSuffix = 1 ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { int index = tracker . putOrAdd ( fieldSuffix , 0 , 0 ) ; if ( index >= fieldSuffix ) { index = random . nextInt ( fieldSuffix ) ; fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; } else { fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; tracker . put ( fieldSuffix , ++ index ) ; } } builder . add ( client . prepareIndex ( INDEX_NAME , TYPE_NAME , String . valueOf ( i ) ) . setSource ( fieldValues ) ) ; if ( builder . numberOfActions ( ) >= 1000 ) { builder . get ( ) ; builder = client . prepareBulk ( ) ; } } if ( builder . numberOfActions ( ) > 0 ) { builder . get ( ) ; } } catch ( IndexAlreadyExistsException e ) { System . out . println ( " - - > ▁ Index ▁ already ▁ exists , ▁ ignoring ▁ indexing ▁ phase , ▁ waiting ▁ for ▁ green " ) ; ClusterHealthResponse clusterHealthResponse = client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . setTimeout ( "10m " ) . execute ( ) . actionGet ( ) ; if ( clusterHealthResponse . isTimedOut ( ) ) { System . err . println ( " - - > ▁ Timed ▁ out ▁ waiting ▁ for ▁ cluster ▁ health " ) ; } } client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( " logger . index . fielddata . ordinals " , " DEBUG " ) ) . get ( ) ; client . admin ( ) . indices ( ) . prepareRefresh ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; COUNT = client . prepareCount ( INDEX_NAME ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) . getCount ( ) ; System . out . println ( " - - > ▁ Number ▁ of ▁ docs ▁ in ▁ index : ▁ " + COUNT ) ; List < StatsResult > stats = new ArrayList < > ( ) ; for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " global _ ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; } stats . add ( terms ( name , fieldName , " global _ ordinals _ low _ cardinality " ) ) ; } for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; } stats . add ( terms ( name , fieldName , " ordinals " ) ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10s % 15s \n " , " name " , " took " , " millis " , " fieldata ▁ size " ) ; for ( StatsResult stat : stats ) { System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10d % 15s \n " , stat . name , TimeValue . timeValueMillis ( stat . took ) , ( stat . took / QUERY_COUNT ) , stat . fieldDataMemoryUsed ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; client . close ( ) ; node . close ( ) ; } private static StatsResult terms ( String name , String field , String executionHint ) { long totalQueryTime ; client . admin ( ) . indices ( ) . prepareClearCache ( ) . setFieldDataCache ( true ) . execute ( ) . actionGet ( ) ; System . gc ( ) ; System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) . . . " ) ; for ( int j = 0 ; j < QUERY_WARMUP ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( j == 0 ) { System . out . println ( " - - > ▁ Loading ▁ ( " + field + " ) : ▁ took : ▁ " + searchResponse . getTook ( ) ) ; } if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } } System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) ▁ DONE " ) ; System . out . println ( " - - > ▁ Running ▁ ( " + name + " ) . . . " ) ; totalQueryTime = 0 ; for ( int j = 0 ; j < QUERY_COUNT ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } totalQueryTime += searchResponse . getTookInMillis ( ) ; } System . out . println ( " - - > ▁ Terms ▁ Agg ▁ ( " + name + " ) : ▁ " + ( totalQueryTime / QUERY_COUNT ) + " ms " ) ; String nodeId = node . injector ( ) . getInstance ( Discovery . class ) . localNode ( ) . getId ( ) ; ClusterStatsResponse clusterStateResponse = client . admin ( ) . cluster ( ) . prepareClusterStats ( ) . setNodesIds ( nodeId ) . get ( ) ; System . out . println ( " - - > ▁ Heap ▁ used : ▁ " + clusterStateResponse . getNodesStats ( ) . getJvm ( ) . getHeapUsed ( ) ) ; ByteSizeValue fieldDataMemoryUsed = clusterStateResponse . getIndicesStats ( ) . getFieldData ( ) . getMemorySize ( ) ; System . out . println ( " - - > ▁ Fielddata ▁ memory ▁ size : ▁ " + fieldDataMemoryUsed ) ; return new StatsResult ( name , totalQueryTime , fieldDataMemoryUsed ) ; } } </DOCUMENT>
<DOCUMENT_ID="beano/gocd/tree/master/plugin-infra/go-plugin-infra/test/com/thoughtworks/go/plugin/infra/MultipleExtensionPluginWithPluginManagerIntegrationTest.java"> package com . thoughtworks . go . plugin . infra ; import java . io . File ; import java . io . IOException ; import com . thoughtworks . go . util . SystemEnvironment ; import com . thoughtworks . go . plugin . activation . DefaultGoPluginActivator ; import com . thoughtworks . go . plugin . infra . listeners . DefaultPluginJarChangeListener ; import com . thoughtworks . go . plugin . infra . monitor . PluginFileDetails ; import com . thoughtworks . go . plugin . infra . plugininfo . GoPluginDescriptor ; import org . apache . commons . io . FileUtils ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_ACTIVATOR_JAR_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_BUNDLE_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_FRAMEWORK_ENABLED ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . MatcherAssert . assertThat ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { " classpath : / applicationContext - plugin - infra . xml " } ) public class MultipleExtensionPluginWithPluginManagerIntegrationTest { public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 = " testplugin . multiple . extension . DescriptorPlugin1 . setPluginDescriptor . invoked " ; public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 = " testplugin . multiple . extension . DescriptorPlugin2 . setPluginDescriptor . invoked " ; private static final String PLUGIN_DIR_NAME = " . / tmp - DefPlgnMgrIntTest " ; private static final String BUNDLE_DIR_NAME = " . / tmp - bundles - DefPlgnMgrIntTest " ; private static final File PLUGIN_DIR = new File ( PLUGIN_DIR_NAME ) ; private static final File BUNDLE_DIR = new File ( BUNDLE_DIR_NAME ) ; private static final String PLUGIN_ID = " testplugin . multiple . extension " ; @ Autowired DefaultPluginManager pluginManager ; @ Autowired DefaultPluginJarChangeListener jarChangeListener ; @ Autowired SystemEnvironment systemEnvironment ; static { System . setProperty ( PLUGIN_ACTIVATOR_JAR_PATH . propertyName ( ) , " defaultFiles / go - plugin - activator . jar " ) ; System . setProperty ( PLUGIN_BUNDLE_PATH . propertyName ( ) , BUNDLE_DIR_NAME ) ; System . setProperty ( PLUGIN_FRAMEWORK_ENABLED . propertyName ( ) , " Y " ) ; } private static File pathOfFileInDefaultFiles ( String filePath ) { return new File ( MultipleExtensionPluginWithPluginManagerIntegrationTest . class . getClassLoader ( ) . getResource ( " defaultFiles / " + filePath ) . getFile ( ) ) ; } @ Test public void shouldProvideDescriptorToMultipleExtensionsImplementingThePluginDescriptorAwareInterface ( ) throws Exception { GoPluginDescriptor plugin = pluginManager . getPluginDescriptorFor ( PLUGIN_ID ) ; assertThat ( plugin . id ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleSymbolicName ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleClassPath ( ) , is ( " lib / go - plugin - activator . jar , . " ) ) ; assertThat ( plugin . bundleActivator ( ) , is ( DefaultGoPluginActivator . class . getCanonicalName ( ) ) ) ; assertThat ( plugin . isInvalid ( ) , is ( false ) ) ; assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) , is ( plugin . toString ( ) ) ) ; assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) , is ( plugin . toString ( ) ) ) ; } @ Before public void setUpPluginInfrastructure ( ) throws IOException { PLUGIN_DIR . mkdirs ( ) ; BUNDLE_DIR . mkdirs ( ) ; try { pluginManager . startInfrastructure ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } jarChangeListener . pluginJarAdded ( new PluginFileDetails ( pathOfFileInDefaultFiles ( " plugin - with - multiple - extensions . jar " ) , false ) ) ; } @ After public void tearDown ( ) throws Exception { System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) ; System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; pluginManager . stopInfrastructure ( ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; } } </DOCUMENT>
<DOCUMENT_ID="likaiwalkman/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="seanzwx/tmp/tree/master/shop/android/imageloader/src/com/nostra13/universalimageloader/cache/memory/impl/LimitedAgeMemoryCache.java"> package com . nostra13 . universalimageloader . cache . memory . impl ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import com . nostra13 . universalimageloader . cache . memory . MemoryCacheAware ; public class LimitedAgeMemoryCache < K , V > implements MemoryCacheAware < K , V > { private final MemoryCacheAware < K , V > cache ; private final long maxAge ; private final Map < K , Long > loadingDates = Collections . synchronizedMap ( new HashMap < K , Long > ( ) ) ; public LimitedAgeMemoryCache ( MemoryCacheAware < K , V > cache , long maxAge ) { this . cache = cache ; this . maxAge = maxAge * 1000 ; } @ Override public boolean put ( K key , V value ) { boolean putSuccesfully = cache . put ( key , value ) ; if ( putSuccesfully ) { loadingDates . put ( key , System . currentTimeMillis ( ) ) ; } return putSuccesfully ; } @ Override public V get ( K key ) { Long loadingDate = loadingDates . get ( key ) ; if ( loadingDate != null && System . currentTimeMillis ( ) - loadingDate > maxAge ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } return cache . get ( key ) ; } @ Override public void remove ( K key ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } @ Override public Collection < K > keys ( ) { return cache . keys ( ) ; } @ Override public void clear ( ) { cache . clear ( ) ; loadingDates . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="didoupimpon/CC152/tree/master/src/main/java/net/minecraft/server/ItemReed.java"> package net . minecraft . server ; import org . bukkit . block . BlockState ; import org . bukkit . craftbukkit . block . CraftBlockState ; import org . bukkit . craftbukkit . event . CraftEventFactory ; import org . bukkit . event . block . BlockPlaceEvent ; public class ItemReed extends Item { private int id ; public ItemReed ( int i , Block block ) { super ( i ) ; this . id = block . id ; } public boolean a ( ItemStack itemstack , EntityHuman entityhuman , World world , int i , int j , int k , int l ) { int clickedX = i , clickedY = j , clickedZ = k ; if ( world . getTypeId ( i , j , k ) == Block . SNOW . id ) { l = 0 ; } else { if ( l == 0 ) { -- j ; } if ( l == 1 ) { ++ j ; } if ( l == 2 ) { -- k ; } if ( l == 3 ) { ++ k ; } if ( l == 4 ) { -- i ; } if ( l == 5 ) { ++ i ; } } if ( itemstack . count == 0 ) { return false ; } else { if ( world . a ( this . id , i , j , k , false ) ) { Block block = Block . byId [ this . id ] ; BlockState replacedBlockState = CraftBlockState . getBlockState ( world , i , j , k ) ; if ( world . setRawTypeId ( i , j , k , this . id ) ) { BlockPlaceEvent event = CraftEventFactory . callBlockPlaceEvent ( world , entityhuman , replacedBlockState , clickedX , clickedY , clickedZ , block ) ; if ( event . isCancelled ( ) || ! event . canBuild ( ) ) { world . setTypeIdAndData ( i , j , k , replacedBlockState . getTypeId ( ) , replacedBlockState . getRawData ( ) ) ; } else { world . update ( i , j , k , this . id ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , l ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , entityhuman ) ; world . makeSound ( ( double ) ( ( float ) i + 0.5F ) , ( double ) ( ( float ) j + 0.5F ) , ( double ) ( ( float ) k + 0.5F ) , block . stepSound . getName ( ) , ( block . stepSound . getVolume1 ( ) + 1.0F ) / 2.0F , block . stepSound . getVolume2 ( ) * 0.8F ) ; -- itemstack . count ; } } } return true ; } } } </DOCUMENT>
<DOCUMENT_ID="volyrique/FrameworkBenchmarks/tree/master/frameworks/Java/dropwizard/src/main/java/com/example/helloworld/HelloJDBIService.java"> package com . example . helloworld ; import com . example . helloworld . db . jdbi . FortuneRepository ; import io . dropwizard . Application ; import io . dropwizard . jdbi3 . JdbiFactory ; import io . dropwizard . jdbi3 . bundles . JdbiExceptionsBundle ; import io . dropwizard . setup . Bootstrap ; import io . dropwizard . setup . Environment ; import io . dropwizard . views . ViewBundle ; import org . jdbi . v3 . core . Jdbi ; import com . example . helloworld . config . HelloWorldConfiguration ; import com . example . helloworld . db . jdbi . WorldRepository ; import com . example . helloworld . resources . FortuneResource ; import com . example . helloworld . resources . WorldResource ; public class HelloJDBIService extends Application < HelloWorldConfiguration > { public static void main ( String [ ] args ) throws Exception { new HelloJDBIService ( ) . run ( args ) ; } @ Override public void initialize ( Bootstrap < HelloWorldConfiguration > bootstrap ) { bootstrap . addBundle ( new ViewBundle < > ( ) ) ; bootstrap . addBundle ( new JdbiExceptionsBundle ( ) ) ; } @ Override public void run ( HelloWorldConfiguration config , Environment environment ) { final JdbiFactory factory = new JdbiFactory ( ) ; final Jdbi jdbi = factory . build ( environment , config . getDatabaseConfiguration ( ) , " RDBMS " ) ; environment . jersey ( ) . register ( new WorldResource ( new WorldRepository ( jdbi ) ) ) ; environment . jersey ( ) . register ( new FortuneResource ( new FortuneRepository ( jdbi ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="nezuvian/Library-webapp/tree/master/src/test/java/top2lz/libapp/web/rest/TestUtil.java"> package top2lz . libapp . web . rest ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . datatype . joda . JodaModule ; import com . fasterxml . jackson . datatype . joda . ser . DateTimeSerializer ; import com . fasterxml . jackson . datatype . joda . ser . JacksonJodaFormat ; import org . joda . time . DateTime ; import org . springframework . format . annotation . DateTimeFormat ; import org . springframework . format . datetime . joda . DateTimeFormatterFactory ; import org . springframework . http . MediaType ; import java . io . IOException ; import java . nio . charset . Charset ; public class TestUtil { public static final MediaType APPLICATION_JSON_UTF8 = new MediaType ( MediaType . APPLICATION_JSON . getType ( ) , MediaType . APPLICATION_JSON . getSubtype ( ) , Charset . forName ( " utf8" ) ) ; public static byte [ ] convertObjectToJsonBytes ( Object object ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; mapper . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ; JodaModule module = new JodaModule ( ) ; DateTimeFormatterFactory formatterFactory = new DateTimeFormatterFactory ( ) ; formatterFactory . setIso ( DateTimeFormat . ISO . DATE ) ; module . addSerializer ( DateTime . class , new DateTimeSerializer ( new JacksonJodaFormat ( formatterFactory . createDateTimeFormatter ( ) . withZoneUTC ( ) ) ) ) ; mapper . registerModule ( module ) ; return mapper . writeValueAsBytes ( object ) ; } } </DOCUMENT>
<DOCUMENT_ID="skofra0/pentaho-kettle/tree/master/engine/src/org/pentaho/di/job/JobEntryListener.java"> package org . pentaho . di . job ; import org . pentaho . di . core . Result ; import org . pentaho . di . job . entry . JobEntryCopy ; import org . pentaho . di . job . entry . JobEntryInterface ; public interface JobEntryListener { public void beforeExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface ) ; public void afterExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface , Result result ) ; } </DOCUMENT>
<DOCUMENT_ID="idea4bsd/idea4bsd/tree/master/java/java-psi-api/src/com/intellij/psi/PsiVariable.java"> package com . intellij . psi ; import com . intellij . pom . PomRenameableTarget ; import com . intellij . util . IncorrectOperationException ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import org . jetbrains . annotations . NonNls ; public interface PsiVariable extends PsiModifierListOwner , PsiNameIdentifierOwner , PsiTarget , PomRenameableTarget < PsiElement > { @ NotNull PsiType getType ( ) ; @ Nullable PsiTypeElement getTypeElement ( ) ; @ Nullable PsiExpression getInitializer ( ) ; boolean hasInitializer ( ) ; void normalizeDeclaration ( ) throws IncorrectOperationException ; @ Nullable Object computeConstantValue ( ) ; @ Override @ Nullable PsiIdentifier getNameIdentifier ( ) ; @ Override PsiElement setName ( @ NonNls @ NotNull String name ) throws IncorrectOperationException ; } </DOCUMENT>
<DOCUMENT_ID="huangbop/takeout/tree/master/app/src/main/java/com/huangbop/takeout/IndexActivity.java"> package com . huangbop . takeout ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . DialogInterface ; import android . content . Intent ; import android . os . Bundle ; import android . view . KeyEvent ; import android . view . View ; import android . widget . Button ; import android . widget . Toast ; public class IndexActivity extends Activity { private Button btnIndex0 ; private Button btnIndex1 ; private Button btnIndex2 ; private ButtonListener listener ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_index ) ; listener = new ButtonListener ( ) ; findButtons ( ) ; setClickListener ( ) ; } private long exitTime = 0 ; @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK && event . getAction ( ) == KeyEvent . ACTION_DOWN ) { if ( ( System . currentTimeMillis ( ) - exitTime ) > 2000 ) { Toast . makeText ( this , " Press ▁ again ▁ to ▁ exit . " , Toast . LENGTH_SHORT ) . show ( ) ; exitTime = System . currentTimeMillis ( ) ; } else { finish ( ) ; System . exit ( 0 ) ; } return true ; } return super . onKeyDown ( keyCode , event ) ; } private void setClickListener ( ) { btnIndex0 . setOnClickListener ( listener ) ; btnIndex1 . setOnClickListener ( listener ) ; btnIndex2 . setOnClickListener ( listener ) ; } private void findButtons ( ) { btnIndex0 = ( Button ) findViewById ( R . id . btnIndex0 ) ; btnIndex1 = ( Button ) findViewById ( R . id . btnIndex1 ) ; btnIndex2 = ( Button ) findViewById ( R . id . btnIndex2 ) ; } private class ButtonListener implements View . OnClickListener { @ Override public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . btnIndex0 : Intent intent0 = new Intent ( IndexActivity . this , MainActivity . class ) ; startActivity ( intent0 ) ; break ; case R . id . btnIndex1 : Intent intent1 = new Intent ( IndexActivity . this , SecondActivity . class ) ; startActivity ( intent1 ) ; break ; case R . id . btnIndex2 : Intent intent2 = new Intent ( IndexActivity . this , LifeCycle . class ) ; startActivity ( intent2 ) ; break ; } } } } </DOCUMENT>
<DOCUMENT_ID="HasanAliKaraca/Telegram/tree/master/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java"> package org . telegram . ui . Adapters ; import android . content . Context ; import android . view . View ; import android . view . ViewGroup ; import org . telegram . android . MessageObject ; import org . telegram . android . MessagesController ; import org . telegram . android . UserObject ; import org . telegram . messenger . TLRPC ; import org . telegram . ui . Cells . MentionCell ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; public class MentionsAdapter extends BaseSearchAdapter { public interface MentionsAdapterDelegate { void needChangePanelVisibility ( boolean show ) ; } private Context mContext ; private TLRPC . ChatParticipants info ; private ArrayList < TLRPC . User > searchResultUsernames ; private ArrayList < String > searchResultHashtags ; private ArrayList < String > searchResultCommands ; private ArrayList < String > searchResultCommandsHelp ; private ArrayList < TLRPC . User > searchResultCommandsUsers ; private MentionsAdapterDelegate delegate ; private HashMap < Integer , TLRPC . BotInfo > botInfo ; private int resultStartPosition ; private int resultLength ; private String lastText ; private int lastPosition ; private ArrayList < MessageObject > messages ; private boolean needUsernames = true ; private boolean isDarkTheme ; private int botsCount ; public MentionsAdapter ( Context context , boolean isDarkTheme , MentionsAdapterDelegate delegate ) { mContext = context ; this . delegate = delegate ; this . isDarkTheme = isDarkTheme ; } public void setChatInfo ( TLRPC . ChatParticipants chatParticipants ) { info = chatParticipants ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void setNeedUsernames ( boolean value ) { needUsernames = value ; } public void setBotInfo ( HashMap < Integer , TLRPC . BotInfo > info ) { botInfo = info ; } public void setBotsCount ( int count ) { botsCount = count ; } @ Override public void clearRecentHashtags ( ) { super . clearRecentHashtags ( ) ; searchResultHashtags . clear ( ) ; notifyDataSetChanged ( ) ; if ( delegate != null ) { delegate . needChangePanelVisibility ( false ) ; } } @ Override protected void setHashtags ( ArrayList < HashtagObject > arrayList , HashMap < String , HashtagObject > hashMap ) { super . setHashtags ( arrayList , hashMap ) ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void searchUsernameOrHashtag ( String text , int position , ArrayList < MessageObject > messageObjects ) { if ( text == null || text . length ( ) == 0 ) { delegate . needChangePanelVisibility ( false ) ; lastText = null ; return ; } int searchPostion = position ; if ( text . length ( ) > 0 ) { searchPostion -- ; } lastText = null ; StringBuilder result = new StringBuilder ( ) ; int foundType = - 1 ; boolean hasIllegalUsernameCharacters = false ; for ( int a = searchPostion ; a >= 0 ; a -- ) { if ( a >= text . length ( ) ) { continue ; } char ch = text . charAt ( a ) ; if ( a == 0 || text . charAt ( a - 1 ) == ' ▁ ' || text . charAt ( a - 1 ) == ' \n ' ) { if ( needUsernames && ch == ' @ ' ) { if ( hasIllegalUsernameCharacters ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( info == null ) { lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 0 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } else if ( ch == ' # ' ) { if ( ! hashtagsLoadedFromDb ) { loadRecentHashtags ( ) ; lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 1 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; result . insert ( 0 , ch ) ; break ; } else if ( a == 0 && botInfo != null && ch == ' / ' ) { foundType = 2 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } } if ( ! ( ch >= '0' && ch <= '9' || ch >= ' a ' && ch <= ' z ' || ch >= ' A ' && ch <= ' Z ' || ch == ' _ ' ) ) { hasIllegalUsernameCharacters = true ; } result . insert ( 0 , ch ) ; } if ( foundType == - 1 ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( foundType == 0 ) { final ArrayList < Integer > users = new ArrayList < > ( ) ; for ( int a = 0 ; a < Math . min ( 100 , messageObjects . size ( ) ) ; a ++ ) { int from_id = messageObjects . get ( a ) . messageOwner . from_id ; if ( ! users . contains ( from_id ) ) { users . add ( from_id ) ; } } String usernameString = result . toString ( ) . toLowerCase ( ) ; ArrayList < TLRPC . User > newResult = new ArrayList < > ( ) ; for ( TLRPC . TL_chatParticipant chatParticipant : info . participants ) { TLRPC . User user = MessagesController . getInstance ( ) . getUser ( chatParticipant . user_id ) ; if ( user == null || UserObject . isUserSelf ( user ) ) { continue ; } if ( user . username != null && user . username . length ( ) > 0 && ( usernameString . length ( ) > 0 && user . username . toLowerCase ( ) . startsWith ( usernameString ) || usernameString . length ( ) == 0 ) ) { newResult . add ( user ) ; } } searchResultHashtags = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; searchResultUsernames = newResult ; Collections . sort ( searchResultUsernames , new Comparator < TLRPC . User > ( ) { @ Override public int compare ( TLRPC . User lhs , TLRPC . User rhs ) { int lhsNum = users . indexOf ( lhs . id ) ; int rhsNum = users . indexOf ( rhs . id ) ; if ( lhsNum != - 1 && rhsNum != - 1 ) { return lhsNum < rhsNum ? - 1 : ( lhsNum == rhsNum ? 0 : 1 ) ; } else if ( lhsNum != - 1 && rhsNum == - 1 ) { return - 1 ; } else if ( lhsNum == - 1 && rhsNum != - 1 ) { return 1 ; } return 0 ; } } ) ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 1 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; String hashtagString = result . toString ( ) . toLowerCase ( ) ; for ( HashtagObject hashtagObject : hashtags ) { if ( hashtagObject != null && hashtagObject . hashtag != null && hashtagObject . hashtag . startsWith ( hashtagString ) ) { newResult . add ( hashtagObject . hashtag ) ; } } searchResultHashtags = newResult ; searchResultUsernames = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 2 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; ArrayList < String > newResultHelp = new ArrayList < > ( ) ; ArrayList < TLRPC . User > newResultUsers = new ArrayList < > ( ) ; String command = result . toString ( ) . toLowerCase ( ) ; for ( HashMap . Entry < Integer , TLRPC . BotInfo > entry : botInfo . entrySet ( ) ) { for ( TLRPC . TL_botCommand botCommand : entry . getValue ( ) . commands ) { if ( botCommand != null && botCommand . command != null && botCommand . command . startsWith ( command ) ) { newResult . add ( " / " + botCommand . command ) ; newResultHelp . add ( botCommand . description ) ; newResultUsers . add ( MessagesController . getInstance ( ) . getUser ( entry . getValue ( ) . user_id ) ) ; } } } searchResultHashtags = null ; searchResultUsernames = null ; searchResultCommands = newResult ; searchResultCommandsHelp = newResultHelp ; searchResultCommandsUsers = newResultUsers ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } } public int getResultStartPosition ( ) { return resultStartPosition ; } public int getResultLength ( ) { return resultLength ; } @ Override public int getViewTypeCount ( ) { return 1 ; } @ Override public int getCount ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . size ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . size ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . size ( ) ; } return 0 ; } @ Override public boolean isEmpty ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . isEmpty ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . isEmpty ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . isEmpty ( ) ; } return true ; } @ Override public int getItemViewType ( int position ) { return 0 ; } @ Override public boolean hasStableIds ( ) { return true ; } @ Override public boolean areAllItemsEnabled ( ) { return true ; } @ Override public boolean isEnabled ( int position ) { return true ; } @ Override public Object getItem ( int i ) { if ( searchResultUsernames != null ) { if ( i < 0 || i >= searchResultUsernames . size ( ) ) { return null ; } return searchResultUsernames . get ( i ) ; } else if ( searchResultHashtags != null ) { if ( i < 0 || i >= searchResultHashtags . size ( ) ) { return null ; } return searchResultHashtags . get ( i ) ; } else if ( searchResultCommands != null ) { if ( i < 0 || i >= searchResultCommands . size ( ) ) { return null ; } if ( searchResultCommandsUsers != null && botsCount != 1 ) { return String . format ( " % s @ % s " , searchResultCommands . get ( i ) , searchResultCommandsUsers . get ( i ) . username ) ; } return searchResultCommands . get ( i ) ; } return null ; } public boolean isLongClickEnabled ( ) { return searchResultHashtags != null ; } public boolean isBotCommands ( ) { return searchResultCommands != null ; } @ Override public View getView ( int i , View view , ViewGroup viewGroup ) { if ( view == null ) { view = new MentionCell ( mContext ) ; ( ( MentionCell ) view ) . setIsDarkTheme ( isDarkTheme ) ; } if ( searchResultUsernames != null ) { ( ( MentionCell ) view ) . setUser ( searchResultUsernames . get ( i ) ) ; } else if ( searchResultHashtags != null ) { ( ( MentionCell ) view ) . setText ( searchResultHashtags . get ( i ) ) ; } else if ( searchResultCommands != null ) { ( ( MentionCell ) view ) . setBotCommand ( searchResultCommands . get ( i ) , searchResultCommandsHelp . get ( i ) , searchResultCommandsUsers . get ( i ) ) ; } return view ; } } </DOCUMENT>
<DOCUMENT_ID="weebl2000/modeshape/tree/master/modeshape-jcr/src/main/java/org/modeshape/jcr/ModeShape.java"> package org . modeshape . jcr ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import org . modeshape . common . collection . UnmodifiableProperties ; import org . modeshape . common . logging . Logger ; public final class ModeShape { private static final Properties bundleProperties = loadBundleProperties ( ) ; private static Properties loadBundleProperties ( ) { InputStream stream = null ; try { stream = JcrRepository . class . getClassLoader ( ) . getResourceAsStream ( " org / modeshape / jcr / repository . properties " ) ; assert stream != null ; Properties props = new Properties ( ) ; props . load ( stream ) ; return new UnmodifiableProperties ( props ) ; } catch ( IOException e ) { throw new IllegalStateException ( JcrI18n . failedToReadPropertiesFromManifest . text ( e . getLocalizedMessage ( ) ) , e ) ; } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } finally { stream = null ; } } } } static { Logger . getLogger ( JcrRepository . class ) . info ( JcrI18n . initializing , getName ( ) , getVersion ( ) ) ; } public static final String getName ( ) { return bundleProperties . getProperty ( " name " ) ; } public static final String getVendor ( ) { return bundleProperties . getProperty ( " vendor " ) ; } public static final String getUrl ( ) { return bundleProperties . getProperty ( " url " ) ; } public static final String getVersion ( ) { return bundleProperties . getProperty ( " version " ) ; } } </DOCUMENT>
<DOCUMENT_ID="Maccimo/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/explicit2var/beforeAnonymous.java"> class MyTest { private void m ( ) { Ru < caret > nnable r = new Runnable ( ) { @ Override public void run ( ) { } } ; } } </DOCUMENT>
<DOCUMENT_ID="telerik/platform-friends-android/tree/master/Friends/facebook/src/main/java/com/facebook/internal/ImageResponseCache.java"> package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="13366348079/Dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="lumenrobot/relex-id/tree/master/core/src/main/java/id/ac/itb/ee/lskk/relexid/core/PartOfSpeech.java"> package id . ac . itb . ee . lskk . relexid . core ; import java . util . Locale ; import java . util . Map ; import javax . xml . namespace . QName ; import org . eclipse . emf . ecore . EObject ; public interface PartOfSpeech extends EObject { String getLiteral ( ) ; void setLiteral ( String value ) ; QName getResource ( ) ; void setResource ( QName value ) ; QName getWord ( ) ; void setWord ( QName value ) ; String getName ( ) ; void setName ( String value ) ; GeneratedLiteral generate ( Locale locale , Map < String , String > dict , Translator translator ) ; } </DOCUMENT>
<DOCUMENT_ID="bobocop/gsn35/tree/master/src/endymion/alarm/senders/GSNAlarmSender.java"> package endymion . alarm . senders ; import endymion . exception . EndymionException ; public abstract class GSNAlarmSender { public abstract void setSendParameters ( String ... parameters ) throws EndymionException ; public abstract void sendAlarm ( String subjectLine , String alarmMessage ) throws EndymionException ; } </DOCUMENT>
<DOCUMENT_ID="iLoop2/openmrs-core/tree/master/api/src/test/java/org/openmrs/PersonAttributeTest.java"> package org . openmrs ; import java . util . Date ; import org . junit . Assert ; import org . junit . Test ; import org . openmrs . api . context . Context ; import org . openmrs . test . BaseContextSensitiveTest ; import org . openmrs . test . Verifies ; public class PersonAttributeTest extends BaseContextSensitiveTest { @ Test @ Verifies ( value = " should ▁ return ▁ toString ▁ of ▁ hydrated ▁ value " , method = " toString ( ) " ) public void toString_shouldReturnToStringOfHydratedValue ( ) throws Exception { PersonAttributeType type = Context . getPersonService ( ) . getPersonAttributeType ( 8 ) ; PersonAttribute attr = new PersonAttribute ( type , "6" ) ; Assert . assertEquals ( " MARRIED " , attr . toString ( ) ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ is ▁ voided " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeIsVoided ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setVoided ( true ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ earlier ▁ date ▁ created " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasEarlierDateCreated ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setDateCreated ( new Date ( ) ) ; PersonAttribute other = new PersonAttribute ( ) ; pa . setDateCreated ( new Date ( pa . getDateCreated ( ) . getTime ( ) - 1000 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ type ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeTypeThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 2 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ not ▁ throw ▁ exception ▁ if ▁ attribute ▁ type ▁ is ▁ null " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldNotThrowExceptionIfAttributeTypeIdIsNull ( ) throws Exception { Assert . assertTrue ( new PersonAttribute ( 1 ) . compareTo ( new PersonAttribute ( 1 ) ) == 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ lower ▁ value " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasLowerValue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "2" ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; other . setValue ( "1" ) ; Assert . assertTrue ( pa . compareTo ( other ) > 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ id ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeIdThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 1 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( 2 ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ true ▁ if ▁ attributeType ▁ value ▁ and ▁ void ▁ status ▁ are ▁ the ▁ same " , method = " equalsContent ( PersonAttribute ) " ) public void equalsContent_shouldReturnTrueIfAttributeTypeValueAndVoidStatusAreTheSame ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; PersonAttribute other = new PersonAttribute ( 1 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; Assert . assertTrue ( pa . equalsContent ( other ) ) ; } @ Test @ Verifies ( value = " should ▁ load ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . Concept " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "5089" ) ; Concept concept = ( Concept ) pa . getHydratedObject ( ) ; Assert . assertEquals ( 5089 , concept . getConceptId ( ) . intValue ( ) ) ; } @ Test @ Verifies ( value = " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadUserClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . User " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "1" ) ; Object value = pa . getHydratedObject ( ) ; Assert . assertTrue ( " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , ( value instanceof User ) ) ; } @ Test @ Verifies ( value = " should ▁ still ▁ load ▁ class ▁ in ▁ format ▁ property ▁ if ▁ not ▁ Attributable " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldStillLoadClassInFormatPropertyIfNotAttributable ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " java . lang . String " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( " lalapalooza " ) ; String value = ( String ) pa . getHydratedObject ( ) ; Assert . assertEquals ( " lalapalooza " , value ) ; } @ Test @ Verifies ( value = " should ▁ set ▁ voided ▁ bit ▁ to ▁ true " , method = " voidAttribute ( String ) " ) public void voidAttribute_shouldSetVoidedBitToTrue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setVoided ( false ) ; pa . voidAttribute ( " Because " ) ; Assert . assertTrue ( pa . isVoided ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="kingargyle/adt-leanback-support/tree/master/leanback-v17/src/main/java/android/support/v17/leanback/app/HeadersFragment.java"> package android . support . v17 . leanback . app ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Bundle ; import android . support . v17 . leanback . R ; import android . support . v17 . leanback . widget . FocusHighlightHelper ; import android . support . v17 . leanback . widget . ItemBridgeAdapter ; import android . support . v17 . leanback . widget . PresenterSelector ; import android . support . v17 . leanback . widget . OnItemSelectedListener ; import android . support . v17 . leanback . widget . Row ; import android . support . v17 . leanback . widget . RowHeaderPresenter ; import android . support . v17 . leanback . widget . SinglePresenterSelector ; import android . support . v17 . leanback . widget . VerticalGridView ; import android . util . TypedValue ; import android . view . View ; import android . view . ViewGroup ; import android . view . View . OnLayoutChangeListener ; import android . widget . FrameLayout ; public class HeadersFragment extends BaseRowFragment { interface OnHeaderClickedListener { void onHeaderClicked ( ) ; } private OnItemSelectedListener mOnItemSelectedListener ; private OnHeaderClickedListener mOnHeaderClickedListener ; private boolean mHeadersEnabled = true ; private boolean mHeadersGone = false ; private int mBackgroundColor ; private boolean mBackgroundColorSet ; private static final PresenterSelector sHeaderPresenter = new SinglePresenterSelector ( new RowHeaderPresenter ( R . layout . lb_header ) ) ; public HeadersFragment ( ) { setPresenterSelector ( sHeaderPresenter ) ; } public void setOnHeaderClickedListener ( OnHeaderClickedListener listener ) { mOnHeaderClickedListener = listener ; } public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelectedListener = listener ; } @ Override protected VerticalGridView findGridViewFromRoot ( View view ) { return ( VerticalGridView ) view . findViewById ( R . id . browse_headers ) ; } @ Override protected void onRowSelected ( ViewGroup parent , View view , int position , long id ) { if ( mOnItemSelectedListener != null ) { if ( position >= 0 ) { Row row = ( Row ) getAdapter ( ) . get ( position ) ; mOnItemSelectedListener . onItemSelected ( null , row ) ; } else { mOnItemSelectedListener . onItemSelected ( null , null ) ; } } } private final ItemBridgeAdapter . AdapterListener mAdapterListener = new ItemBridgeAdapter . AdapterListener ( ) { @ Override public void onCreate ( ItemBridgeAdapter . ViewHolder viewHolder ) { View headerView = viewHolder . getViewHolder ( ) . view ; headerView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mOnHeaderClickedListener != null ) { mOnHeaderClickedListener . onHeaderClicked ( ) ; } } } ) ; headerView . setFocusable ( true ) ; headerView . setFocusableInTouchMode ( true ) ; if ( mWrapper != null ) { viewHolder . itemView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } else { headerView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } } } ; private static OnLayoutChangeListener sLayoutChangeListener = new OnLayoutChangeListener ( ) { @ Override public void onLayoutChange ( View v , int left , int top , int right , int bottom , int oldLeft , int oldTop , int oldRight , int oldBottom ) { v . setPivotX ( 0 ) ; v . setPivotY ( v . getMeasuredHeight ( ) / 2 ) ; } } ; @ Override protected int getLayoutResourceId ( ) { return R . layout . lb_headers_fragment ; } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView == null ) { return ; } if ( getBridgeAdapter ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( listView ) ; } view . setBackgroundColor ( getBackgroundColor ( ) ) ; updateFadingEdgeToBrandColor ( getBackgroundColor ( ) ) ; updateListViewVisibility ( ) ; } private void updateListViewVisibility ( ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { getView ( ) . setVisibility ( mHeadersGone ? View . GONE : View . VISIBLE ) ; if ( ! mHeadersGone ) { if ( mHeadersEnabled ) { listView . setChildrenVisibility ( View . VISIBLE ) ; } else { listView . setChildrenVisibility ( View . INVISIBLE ) ; } } } } void setHeadersEnabled ( boolean enabled ) { mHeadersEnabled = enabled ; updateListViewVisibility ( ) ; } void setHeadersGone ( boolean gone ) { mHeadersGone = gone ; updateListViewVisibility ( ) ; } static class NoOverlappingFrameLayout extends FrameLayout { public NoOverlappingFrameLayout ( Context context ) { super ( context ) ; } @ Override public boolean hasOverlappingRendering ( ) { return false ; } } private final ItemBridgeAdapter . Wrapper mWrapper = new ItemBridgeAdapter . Wrapper ( ) { @ Override public void wrap ( View wrapper , View wrapped ) { ( ( FrameLayout ) wrapper ) . addView ( wrapped ) ; } @ Override public View createWrapper ( View root ) { return new NoOverlappingFrameLayout ( root . getContext ( ) ) ; } } ; @ Override protected void updateAdapter ( ) { super . updateAdapter ( ) ; ItemBridgeAdapter adapter = getBridgeAdapter ( ) ; if ( adapter != null ) { adapter . setAdapterListener ( mAdapterListener ) ; adapter . setWrapper ( mWrapper ) ; } if ( adapter != null && getVerticalGridView ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( getVerticalGridView ( ) ) ; } } void setBackgroundColor ( int color ) { mBackgroundColor = color ; mBackgroundColorSet = true ; if ( getView ( ) != null ) { getView ( ) . setBackgroundColor ( mBackgroundColor ) ; updateFadingEdgeToBrandColor ( mBackgroundColor ) ; } } private void updateFadingEdgeToBrandColor ( int backgroundColor ) { View fadingView = getView ( ) . findViewById ( R . id . fade_out_edge ) ; Drawable background = fadingView . getBackground ( ) ; if ( background instanceof GradientDrawable ) { background . mutate ( ) ; ( ( GradientDrawable ) background ) . setColors ( new int [ ] { Color . TRANSPARENT , backgroundColor } ) ; } } int getBackgroundColor ( ) { if ( getActivity ( ) == null ) { throw new IllegalStateException ( " Activity ▁ must ▁ be ▁ attached " ) ; } if ( mBackgroundColorSet ) { return mBackgroundColor ; } TypedValue outValue = new TypedValue ( ) ; getActivity ( ) . getTheme ( ) . resolveAttribute ( R . attr . defaultBrandColor , outValue , true ) ; return getResources ( ) . getColor ( outValue . resourceId ) ; } @ Override void onTransitionStart ( ) { super . onTransitionStart ( ) ; if ( ! mHeadersEnabled ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_BEFORE_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } } @ Override void onTransitionEnd ( ) { if ( mHeadersEnabled ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_AFTER_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } super . onTransitionEnd ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="bogeo/simsamples/tree/master/src/de/hsbo/geo/simsamples/applications/PubExample.java"> package de . hsbo . geo . simsamples . applications ; import de . hsbo . geo . simsamples . common . RandomValueGenerator ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Customer ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . CustomerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Server ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . ServerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . SimpleServerCustomerSimulator ; public class PubExample { public static void main ( String [ ] args ) throws Exception { new PubExample ( ) . run ( ) ; } private void run ( ) throws Exception { Drinker peter = new Drinker ( " Peter " , 15. ) , paul = new Drinker ( " Paul " , 20. ) , harry = new Drinker ( " Harry " , 30. ) ; Barmaid elke = new Barmaid ( " Elke " , 2. ) ; CustomerQueue drinking = new CustomerQueue ( " . " ) ; CustomerQueue thursty = new CustomerQueue ( " ? " ) ; thursty . enqueue ( peter , paul , harry ) ; ServerQueue tapping = new ServerQueue ( " X " ) ; ServerQueue free = new ServerQueue ( " . " ) ; free . enqueue ( elke ) ; SimpleServerCustomerSimulator sim = new SimpleServerCustomerSimulator ( free , tapping , thursty , drinking ) ; sim . setConsoleDump ( false ) ; double M = 120. ; sim . execute ( M ) ; } protected class Drinker extends Customer { private double dt ; protected Drinker ( String name , double drinkingTime ) { super ( name ) ; this . dt = drinkingTime ; } @ Override public double getDuration ( ) { double var = RandomValueGenerator . number ( - 2. , + 2. , 0. , 1. ) ; return dt + var ; } } protected class Barmaid extends Server { private double dt ; protected Barmaid ( String name , double serviceTime ) { super ( name ) ; this . dt = serviceTime ; } public double getDuration ( ) { return dt + RandomValueGenerator . number ( - 1. , + 1. , 0. , 1. ) ; } } } </DOCUMENT>
<DOCUMENT_ID="nafae/developer/tree/master/modules/dfp_axis/src/main/java/com/google/api/ads/dfp/axis/v201308/ActivityGroupPage.java"> package com . google . api . ads . dfp . axis . v201308 ; public class ActivityGroupPage implements java . io . Serializable { private java . lang . Integer totalResultSetSize ; private java . lang . Integer startIndex ; private com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ; public ActivityGroupPage ( ) { } public ActivityGroupPage ( java . lang . Integer totalResultSetSize , java . lang . Integer startIndex , com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . totalResultSetSize = totalResultSetSize ; this . startIndex = startIndex ; this . results = results ; } public java . lang . Integer getTotalResultSetSize ( ) { return totalResultSetSize ; } public void setTotalResultSetSize ( java . lang . Integer totalResultSetSize ) { this . totalResultSetSize = totalResultSetSize ; } public java . lang . Integer getStartIndex ( ) { return startIndex ; } public void setStartIndex ( java . lang . Integer startIndex ) { this . startIndex = startIndex ; } public com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] getResults ( ) { return results ; } public void setResults ( com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . results = results ; } public com . google . api . ads . dfp . axis . v201308 . ActivityGroup getResults ( int i ) { return this . results [ i ] ; } public void setResults ( int i , com . google . api . ads . dfp . axis . v201308 . ActivityGroup _value ) { this . results [ i ] = _value ; } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof ActivityGroupPage ) ) return false ; ActivityGroupPage other = ( ActivityGroupPage ) obj ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true && ( ( this . totalResultSetSize == null && other . getTotalResultSetSize ( ) == null ) || ( this . totalResultSetSize != null && this . totalResultSetSize . equals ( other . getTotalResultSetSize ( ) ) ) ) && ( ( this . startIndex == null && other . getStartIndex ( ) == null ) || ( this . startIndex != null && this . startIndex . equals ( other . getStartIndex ( ) ) ) ) && ( ( this . results == null && other . getResults ( ) == null ) || ( this . results != null && java . util . Arrays . equals ( this . results , other . getResults ( ) ) ) ) ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; if ( getTotalResultSetSize ( ) != null ) { _hashCode += getTotalResultSetSize ( ) . hashCode ( ) ; } if ( getStartIndex ( ) != null ) { _hashCode += getStartIndex ( ) . hashCode ( ) ; } if ( getResults ( ) != null ) { for ( int i = 0 ; i < java . lang . reflect . Array . getLength ( getResults ( ) ) ; i ++ ) { java . lang . Object obj = java . lang . reflect . Array . get ( getResults ( ) , i ) ; if ( obj != null && ! obj . getClass ( ) . isArray ( ) ) { _hashCode += obj . hashCode ( ) ; } } } __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( ActivityGroupPage . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroupPage " ) ) ; org . apache . axis . description . ElementDesc elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " totalResultSetSize " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " totalResultSetSize " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " startIndex " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " startIndex " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " results " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " results " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroup " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; elemField . setMaxOccursUnbounded ( true ) ; typeDesc . addFieldDesc ( elemField ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; } public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanDeserializer ( _javaType , _xmlType , typeDesc ) ; } } </DOCUMENT>
<DOCUMENT_ID="victos/opencms-core/tree/master/src-gwt/org/opencms/gwt/client/ui/history/CmsResourceHistoryTable.java"> package org . opencms . gwt . client . ui . history ; import org . opencms . gwt . client . CmsCoreProvider ; import org . opencms . gwt . client . ui . css . I_CmsCellTableResources ; import org . opencms . gwt . client . ui . css . I_CmsImageBundle ; import org . opencms . gwt . shared . CmsHistoryResourceBean ; import org . opencms . gwt . shared . CmsHistoryResourceCollection ; import com . google . common . base . Predicate ; import com . google . gwt . cell . client . AbstractCell ; import com . google . gwt . cell . client . ActionCell ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Style . Unit ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . user . cellview . client . CellTable ; import com . google . gwt . user . cellview . client . Column ; import com . google . gwt . user . cellview . client . IdentityColumn ; import com . google . gwt . user . cellview . client . TextColumn ; import com . google . gwt . view . client . ListDataProvider ; import com . google . gwt . view . client . ProvidesKey ; public class CmsResourceHistoryTable extends CellTable < CmsHistoryResourceBean > { static interface Templates extends SafeHtmlTemplates { @ Template ( " < span ▁ class = \ " {1 } \ " ▁ title = \ " {0 } \ " > < / span > " ) SafeHtml button ( String title , String cssClass ) ; @ Template ( " < span ▁ title = \ " {1 } \ " > { 0 } < / span > " ) SafeHtml textSpanWithTitle ( String text , String title ) ; } static Templates templates = GWT . create ( Templates . class ) ; private I_CmsHistoryActionHandler m_handler ; public CmsResourceHistoryTable ( CmsHistoryResourceCollection data , I_CmsHistoryActionHandler handler ) { super ( Integer . MAX_VALUE , ( CellTable . Resources ) GWT . create ( I_CmsCellTableResources . class ) , new ProvidesKey < CmsHistoryResourceBean > ( ) { public Object getKey ( CmsHistoryResourceBean item ) { return item . getStructureId ( ) + " _ " + item . getVersion ( ) ; } } ) ; m_handler = handler ; setWidth ( "100 % " , true ) ; setTableLayoutFixed ( true ) ; addVersionColumn ( ) ; addPreviewColumn ( ) ; addRevertColumn ( ) ; addPathColumn ( ) ; addSizeColumn ( ) ; addModificationDateColumn ( ) ; addUserLastModifiedColumn ( ) ; addPublishDateColumn ( ) ; ListDataProvider < CmsHistoryResourceBean > dataProvider = new ListDataProvider < CmsHistoryResourceBean > ( ) ; dataProvider . addDataDisplay ( this ) ; dataProvider . setList ( data . getResources ( ) ) ; } private void addColumn ( String label , int width , Column < CmsHistoryResourceBean , ? > col ) { addColumn ( col , label ) ; setColumnWidth ( col , width , Unit . PX ) ; } private void addModificationDateColumn ( ) { addColumn ( CmsHistoryMessages . columnModificationDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getModificationDate ( ) . getDateText ( ) ; } } ) ; } private void addPathColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { String path = historyRes . getRootPath ( ) ; String siteRoot = CmsCoreProvider . get ( ) . getSiteRoot ( ) ; if ( path . startsWith ( siteRoot ) ) { path = path . substring ( siteRoot . length ( ) ) ; if ( ! path . startsWith ( " / " ) ) { path = " / " + path ; } } return path ; } } ; addColumn ( col , CmsHistoryMessages . columnPath ( ) ) ; setColumnWidth ( col , 100 , Unit . PCT ) ; } private void addPreviewColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > previewCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titlePreview ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tablePreviewIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . showPreview ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return true ; } } ) ; addColumn ( CmsHistoryMessages . columnPreview ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( previewCell ) ) ; } private void addPublishDateColumn ( ) { addColumn ( CmsHistoryMessages . columnPublishDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { if ( historyRes . getPublishDate ( ) != null ) { return historyRes . getPublishDate ( ) . getDateText ( ) ; } return " - " ; } } ) ; } private void addRevertColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > replaceCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titleRevert ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tableReplaceIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . revert ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return bean . getVersion ( ) . getVersionNumber ( ) != null ; } } ) ; addColumn ( CmsHistoryMessages . columnReplace ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( replaceCell ) ) ; } private void addSizeColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return " " + historyRes . getSize ( ) ; } } ; addColumn ( col , CmsHistoryMessages . columnSize ( ) ) ; setColumnWidth ( col , 100 , Unit . PX ) ; } private void addUserLastModifiedColumn ( ) { addColumn ( CmsHistoryMessages . columnUserLastModified ( ) , 120 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getUserLastModified ( ) ; } } ) ; } private void addVersionColumn ( ) { AbstractCell < CmsHistoryResourceBean > cell = new CmsVersionCell ( ) ; addColumn ( CmsHistoryMessages . columnVersion ( ) , 40 , new IdentityColumn < CmsHistoryResourceBean > ( cell ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="bhaveshdt/camel/tree/master/components/camel-freemarker/src/test/java/org/apache/camel/component/freemarker/FruitFilter.java"> package org . apache . camel . component . freemarker ; public class FruitFilter { public boolean isApple ( String body ) { return " apple " . equalsIgnoreCase ( body ) ; } public boolean isOrange ( String body ) { return " orange " . equalsIgnoreCase ( body ) ; } } </DOCUMENT>
<DOCUMENT_ID="davidfestal/che/tree/master/plugins/plugin-java/che-plugin-java-ext-lang-server/src/test/resources/RenamePackage/testFail10/in/r/A.java"> package r ; class C { } </DOCUMENT>
<DOCUMENT_ID="lucafavatella/intellij-community/tree/master/platform/platform-api/src/com/intellij/openapi/ide/KillRingTransferable.java"> package com . intellij . openapi . ide ; import com . intellij . openapi . editor . Document ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import java . awt . datatransfer . DataFlavor ; import java . awt . datatransfer . StringSelection ; import java . awt . datatransfer . Transferable ; import java . awt . datatransfer . UnsupportedFlavorException ; import java . io . IOException ; import java . lang . ref . WeakReference ; public class KillRingTransferable implements Transferable { private static final DataFlavor [ ] DATA_FLAVORS = { DataFlavor . stringFlavor } ; private final String myData ; private final WeakReference < Document > myDocument ; private final int myStartOffset ; private final int myEndOffset ; private final boolean myCut ; private volatile boolean myReadyToCombine = true ; public KillRingTransferable ( @ NotNull String data , @ NotNull Document document , int startOffset , int endOffset , boolean cut ) { myData = data ; myDocument = new WeakReference < Document > ( document ) ; myStartOffset = startOffset ; myEndOffset = endOffset ; myCut = cut ; } @ Override public DataFlavor [ ] getTransferDataFlavors ( ) { return DATA_FLAVORS ; } @ Override public boolean isDataFlavorSupported ( DataFlavor flavor ) { return flavor == DataFlavor . stringFlavor ; } @ Nullable @ Override public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException , IOException { return isDataFlavorSupported ( flavor ) ? myData : null ; } @ Nullable public Document getDocument ( ) { return myDocument . get ( ) ; } public int getStartOffset ( ) { return myStartOffset ; } public int getEndOffset ( ) { return myEndOffset ; } public boolean isCut ( ) { return myCut ; } public boolean isReadyToCombine ( ) { return myReadyToCombine ; } public void setReadyToCombine ( boolean readyToCombine ) { myReadyToCombine = readyToCombine ; } @ Override public String toString ( ) { return " data = ' " + myData + " ' , ▁ startOffset = " + myStartOffset + " , ▁ endOffset = " + myEndOffset + " , ▁ cut = " + myCut ; } } </DOCUMENT>
<DOCUMENT_ID="fitermay/intellij-community/tree/master/plugins/InspectionGadgets/test/com/siyeh/igtest/bugs/MisspelledToStringInsspection.java"> package com . siyeh . igtest . bugs ; public class MisspelledToStringInsspection { private int m_bar ; public MisspelledToStringInsspection ( ) { m_bar = 0 ; } public String tostring ( ) { return String . valueOf ( m_bar == 3 ) ; } } </DOCUMENT>
<DOCUMENT_ID="nuwanw/product-apim-2015-09-04/tree/master/modules/integration/tests-common/backend-service/src/main/java/org/wso2/am/integration.services/jaxrs/peoplesample/AppConfig.java"> package org . wso2 . am . integration . services . jaxrs . peoplesample ; import org . apache . cxf . bus . spring . SpringBus ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . jaxrs . JAXRSServerFactoryBean ; import org . codehaus . jackson . jaxrs . JacksonJsonProvider ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import javax . ws . rs . ext . RuntimeDelegate ; import java . util . Arrays ; @ Configuration public class AppConfig { @ Bean ( destroyMethod = " shutdown " ) public SpringBus cxf ( ) { return new SpringBus ( ) ; } @ Bean public Server jaxRsServer ( ) { JAXRSServerFactoryBean factory = RuntimeDelegate . getInstance ( ) . createEndpoint ( jaxRsApiApplication ( ) , JAXRSServerFactoryBean . class ) ; factory . setServiceBeans ( Arrays . < Object > asList ( peopleRestService ( ) ) ) ; factory . setAddress ( " / " + factory . getAddress ( ) ) ; factory . setProviders ( Arrays . < Object > asList ( jsonProvider ( ) ) ) ; return factory . create ( ) ; } @ Bean public JaxRsApiApplication jaxRsApiApplication ( ) { return new JaxRsApiApplication ( ) ; } @ Bean public PeopleRestService peopleRestService ( ) { return new PeopleRestService ( ) ; } @ Bean public PeopleService peopleService ( ) { return new PeopleService ( ) ; } @ Bean public JacksonJsonProvider jsonProvider ( ) { return new JacksonJsonProvider ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="jrversteegh/softsailor/tree/master/deps/swig-2.0.4/Examples/ruby/java/Example.java"> public class Example { public int mPublicInt ; public Example ( ) { mPublicInt = 0 ; } public Example ( int IntVal ) { mPublicInt = IntVal ; } public int Add ( int a , int b ) { return ( a + b ) ; } public float Add ( float a , float b ) { return ( a + b ) ; } public String Add ( String a , String b ) { return ( a + b ) ; } public Example Add ( Example a , Example b ) { return new Example ( a . mPublicInt + b . mPublicInt ) ; } } </DOCUMENT>
<DOCUMENT_ID="Rachels-Courses/Course-Common-Files/tree/master/STUDENT_REFERENCE/EXAMPLE_CODE/File IO/Java/OutputCSV/FileOutputter.java"> import java . io . * ; public class FileOutputter { private BufferedWriter m_writer ; private String m_filename ; public static void print ( String filename , String text ) { try { File file = new File ( filename ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; bw . write ( text ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void println ( String filename , String text ) { print ( filename , text + " \n " ) ; } public FileOutputter ( ) { m_filename = " default . txt " ; } public FileOutputter ( String filename ) { m_filename = filename ; } public void print ( String text ) { openFile ( m_filename ) ; try { m_writer . write ( text ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } closeFile ( ) ; } public void println ( String text ) { print ( text + " \n " ) ; } private void openFile ( String filename ) { try { File file = new File ( filename ) ; m_writer = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void closeFile ( ) { try { m_writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="qqming113/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="popstr/undertow/tree/master/core/src/main/java/io/undertow/util/CanonicalPathUtils.java"> package io . undertow . util ; import java . util . ArrayList ; import java . util . List ; public class CanonicalPathUtils { public static String canonicalize ( final String path ) { int state = START ; for ( int i = path . length ( ) - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( c ) { case ' / ' : if ( state == FIRST_SLASH ) { return realCanonicalize ( path , i + 1 , FIRST_SLASH ) ; } else if ( state == ONE_DOT ) { return realCanonicalize ( path , i + 2 , FIRST_SLASH ) ; } else if ( state == TWO_DOT ) { return realCanonicalize ( path , i + 3 , FIRST_SLASH ) ; } state = FIRST_SLASH ; break ; case ' . ' : if ( state == FIRST_SLASH || state == START ) { state = ONE_DOT ; } else if ( state == ONE_DOT ) { state = TWO_DOT ; } else { state = NORMAL ; } break ; default : state = NORMAL ; break ; } } return path ; } static final int START = - 1 ; static final int NORMAL = 0 ; static final int FIRST_SLASH = 1 ; static final int ONE_DOT = 2 ; static final int TWO_DOT = 3 ; private static String realCanonicalize ( final String path , final int lastDot , final int initialState ) { int state = initialState ; int eatCount = 0 ; int tokenEnd = path . length ( ) ; final List < String > parts = new ArrayList < > ( ) ; for ( int i = lastDot - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( state ) { case NORMAL : { if ( c == ' / ' ) { state = FIRST_SLASH ; if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } } break ; } case FIRST_SLASH : { if ( c == ' . ' ) { state = ONE_DOT ; } else if ( c == ' / ' ) { if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } else { parts . add ( path . substring ( i + 1 , tokenEnd ) ) ; tokenEnd = i ; } } else { state = NORMAL ; } break ; } case ONE_DOT : { if ( c == ' . ' ) { state = TWO_DOT ; } else if ( c == ' / ' ) { if ( i + 2 != tokenEnd ) { parts . add ( path . substring ( i + 2 , tokenEnd ) ) ; } tokenEnd = i ; state = FIRST_SLASH ; } else { state = NORMAL ; } break ; } case TWO_DOT : { if ( c == ' / ' ) { if ( i + 3 != tokenEnd ) { parts . add ( path . substring ( i + 3 , tokenEnd ) ) ; } tokenEnd = i ; eatCount ++ ; state = FIRST_SLASH ; } else { state = NORMAL ; } } } } final StringBuilder result = new StringBuilder ( ) ; if ( tokenEnd != 0 ) { result . append ( path . substring ( 0 , tokenEnd ) ) ; } for ( int i = parts . size ( ) - 1 ; i >= 0 ; -- i ) { result . append ( parts . get ( i ) ) ; } if ( result . length ( ) == 0 ) { return " / " ; } return result . toString ( ) ; } private CanonicalPathUtils ( ) { } } </DOCUMENT>
<DOCUMENT_ID="forever342/dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="noonehide/CoolW/tree/master/app/src/main/java/bauhinia/coolw/beans/City.java"> package bauhinia . coolw . beans ; import com . lidroid . xutils . db . annotation . Column ; import com . lidroid . xutils . db . annotation . Id ; import com . lidroid . xutils . db . annotation . Table ; @ Table ( name = " city " ) public class City { @ Id ( column = " _ id " ) int id ; @ Column ( column = " province _ name " ) String city_name ; @ Column ( column = " province _ code " ) String city_code ; @ Column ( column = " province _ id " ) int province_id ; public City ( ) { } public City ( String city_name , String city_code , int province_id ) { this . city_name = city_name ; this . city_code = city_code ; this . province_id = province_id ; } public int getProvince_id ( ) { return province_id ; } public void setProvince_id ( int province_id ) { this . province_id = province_id ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public String getCity_name ( ) { return city_name ; } public void setCity_name ( String city_name ) { this . city_name = city_name ; } public String getCity_code ( ) { return city_code ; } public void setCity_code ( String city_code ) { this . city_code = city_code ; } } </DOCUMENT>
<DOCUMENT_ID="Metaswitch/jitsi/tree/master/src/net/java/sip/communicator/impl/protocol/rss/ContactGroupRssImpl.java"> package net . java . sip . communicator . impl . protocol . rss ; import java . util . * ; import net . java . sip . communicator . service . protocol . * ; public class ContactGroupRssImpl implements ContactGroup { private String groupName = null ; private Vector < Contact > contacts = new Vector < Contact > ( ) ; private Vector < ContactGroup > subGroups = new Vector < ContactGroup > ( ) ; private ContactGroupRssImpl parentGroup = null ; private boolean isPersistent = true ; private ProtocolProviderServiceRssImpl parentProvider = null ; private boolean isResolved = true ; private String uid = null ; private static final String UID_SUFFIX = " . uid " ; public ContactGroupRssImpl ( String groupName , ProtocolProviderServiceRssImpl parentProvider ) { this . groupName = groupName ; this . uid = groupName + UID_SUFFIX ; this . parentProvider = parentProvider ; } public boolean canContainSubgroups ( ) { return true ; } public ProtocolProviderService getProtocolProvider ( ) { return parentProvider ; } public Iterator < Contact > contacts ( ) { return contacts . iterator ( ) ; } public void addContact ( ContactRssImpl contactToAdd ) { this . contacts . add ( contactToAdd ) ; contactToAdd . setParentGroup ( this ) ; } public int countContacts ( ) { return contacts . size ( ) ; } public int countSubgroups ( ) { return subGroups . size ( ) ; } public void addSubgroup ( ContactGroupRssImpl subgroup ) { this . subGroups . add ( subgroup ) ; subgroup . setParentGroup ( this ) ; } void setParentGroup ( ContactGroupRssImpl parent ) { this . parentGroup = parent ; } public ContactGroup getParentContactGroup ( ) { return this . parentGroup ; } public void removeSubGroup ( ContactGroupRssImpl subgroup ) { this . subGroups . remove ( subgroup ) ; subgroup . setParentGroup ( null ) ; } public ContactGroupRssImpl findGroupParent ( ContactGroupRssImpl rssGroup ) { if ( subGroups . contains ( rssGroup ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findGroupParent ( rssGroup ) ; if ( parent != null ) return parent ; } return null ; } public ContactGroupRssImpl findContactParent ( ContactRssImpl rssContact ) { if ( contacts . contains ( rssContact ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findContactParent ( rssContact ) ; if ( parent != null ) return parent ; } return null ; } public Contact getContact ( String id ) { Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( contact . getAddress ( ) . equals ( id ) ) return contact ; } return null ; } public ContactGroup getGroup ( int index ) { return subGroups . get ( index ) ; } public ContactGroup getGroup ( String groupName ) { Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl contactGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; if ( contactGroup . getGroupName ( ) . equals ( groupName ) ) return contactGroup ; } return null ; } public String getGroupName ( ) { return this . groupName ; } public void setGroupName ( String newGrpName ) { this . groupName = newGrpName ; } public Iterator < ContactGroup > subgroups ( ) { return subGroups . iterator ( ) ; } public void removeContact ( ContactRssImpl contact ) { this . contacts . remove ( contact ) ; } public ContactRssImpl findContactByID ( String id ) { Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl mContact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( mContact . getAddress ( ) . equals ( id ) ) return mContact ; } Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl mGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; ContactRssImpl mContact = mGroup . findContactByID ( id ) ; if ( mContact != null ) return mContact ; } return null ; } @ Override public String toString ( ) { StringBuffer buff = new StringBuffer ( getGroupName ( ) ) ; buff . append ( " . subGroups = " + countSubgroups ( ) + " : \n " ) ; Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; buff . append ( group . toString ( ) ) ; if ( subGroups . hasNext ( ) ) buff . append ( " \n " ) ; } buff . append ( " \n ChildContacts = " + countContacts ( ) + " : [ " ) ; Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; buff . append ( contact . toString ( ) ) ; if ( contacts . hasNext ( ) ) buff . append ( " , ▁ " ) ; } return buff . append ( " ] " ) . toString ( ) ; } public void getRssURLList ( List < ContactRssImpl > rssURLList ) { Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; group . getRssURLList ( rssURLList ) ; } Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; rssURLList . add ( contact ) ; } } public void setPersistent ( boolean isPersistent ) { this . isPersistent = isPersistent ; } public boolean isPersistent ( ) { return isPersistent ; } public String getPersistentData ( ) { return null ; } public boolean isResolved ( ) { return isResolved ; } public void setResolved ( boolean resolved ) { this . isResolved = resolved ; } public String getUID ( ) { return uid ; } static String createNameFromUID ( String uid ) { return uid . substring ( 0 , uid . length ( ) - ( UID_SUFFIX . length ( ) ) ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof ContactGroupRssImpl ) ) return false ; ContactGroupRssImpl rssGroup = ( ContactGroupRssImpl ) obj ; if ( ! rssGroup . getGroupName ( ) . equals ( getGroupName ( ) ) || ! rssGroup . getUID ( ) . equals ( getUID ( ) ) || rssGroup . countContacts ( ) != countContacts ( ) || rssGroup . countSubgroups ( ) != countSubgroups ( ) ) return false ; Iterator < Contact > theirContacts = rssGroup . contacts ( ) ; while ( theirContacts . hasNext ( ) ) { ContactRssImpl theirContact = ( ContactRssImpl ) theirContacts . next ( ) ; ContactRssImpl ourContact = ( ContactRssImpl ) getContact ( theirContact . getAddress ( ) ) ; if ( ourContact == null || ! ourContact . equals ( theirContact ) ) return false ; } Iterator < ContactGroup > theirSubgroups = rssGroup . subgroups ( ) ; while ( theirSubgroups . hasNext ( ) ) { ContactGroupRssImpl theirSubgroup = ( ContactGroupRssImpl ) theirSubgroups . next ( ) ; ContactGroupRssImpl ourSubgroup = ( ContactGroupRssImpl ) getGroup ( theirSubgroup . getGroupName ( ) ) ; if ( ourSubgroup == null || ! ourSubgroup . equals ( theirSubgroup ) ) return false ; } return true ; } } </DOCUMENT>
<DOCUMENT_ID="pkdevbox/Kundera/tree/master/src/kundera-cassandra/cassandra-ds-driver/src/main/java/com/impetus/kundera/client/cassandra/dsdriver/DSIdGenerator.java"> package com . impetus . kundera . client . cassandra . dsdriver ; import java . util . UUID ; import com . datastax . driver . core . ResultSet ; import com . impetus . kundera . client . Client ; import com . impetus . kundera . generator . AutoGenerator ; public class DSIdGenerator implements AutoGenerator { @ Override public Object generate ( Client < ? > client , String dataType ) { final String generatedId = " Select ▁ now ( ) ▁ from ▁ system . schema _ columns " ; ResultSet rSet = ( ( DSClient ) client ) . execute ( generatedId , null ) ; UUID uuid = rSet . iterator ( ) . next ( ) . getUUID ( 0 ) ; return uuid ; } } </DOCUMENT>
<DOCUMENT_ID="lowiki-org/localwiki-backend-server/tree/master/sapling-daisydiff/src/java/org/eclipse/compare/rangedifferencer/DifferencesIterator.java"> package org . eclipse . compare . rangedifferencer ; import java . util . ArrayList ; import java . util . List ; class DifferencesIterator { List fRange ; int fIndex ; RangeDifference [ ] fArray ; RangeDifference fDifference ; DifferencesIterator ( RangeDifference [ ] differenceRanges ) { fArray = differenceRanges ; fIndex = 0 ; fRange = new ArrayList ( ) ; if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } int getCount ( ) { return fRange . size ( ) ; } void next ( ) { fRange . add ( fDifference ) ; if ( fDifference != null ) { if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } } DifferencesIterator other ( DifferencesIterator right , DifferencesIterator left ) { if ( this == right ) return left ; return right ; } void removeAll ( ) { fRange . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="pressgang-ccms/PressGangCCMSCommonUtilities/tree/master/src/main/java/org/jboss/pressgang/ccms/utils/common/ExceptionUtilities.java"> package org . jboss . pressgang . ccms . utils . common ; import java . io . PrintWriter ; import java . io . StringWriter ; public class ExceptionUtilities { public static String getStackTrace ( final Throwable ex ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw , true ) ; ex . printStackTrace ( pw ) ; pw . flush ( ) ; sw . flush ( ) ; return sw . toString ( ) ; } public static Throwable getRootCause ( Throwable throwable ) { if ( throwable . getCause ( ) != null ) return getRootCause ( throwable . getCause ( ) ) ; return throwable ; } } </DOCUMENT>
<DOCUMENT_ID="34benma/openjdk/tree/master/nashorn/test/src/jdk/nashorn/internal/runtime/test/LexicalBindingTest.java"> package jdk . nashorn . internal . runtime . test ; import jdk . nashorn . api . scripting . NashornScriptEngineFactory ; import org . testng . annotations . Test ; import javax . script . Bindings ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptException ; import javax . script . SimpleScriptContext ; import static org . testng . Assert . assertEquals ; @ SuppressWarnings ( " javadoc " ) public class LexicalBindingTest { final static String LANGUAGE_ES6 = " - - language = es6" ; final static int NUMBER_OF_CONTEXTS = 20 ; final static int MEGAMORPHIC_LOOP_COUNT = 20 ; @ Test public static void megamorphicVarTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " var ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } @ Test public static void megamorphicMultiGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } @ Test public static void megamorphicSingleGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } @ Test public static void megamorphicInheritedGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ Object . prototype . foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } @ Test public static void multiThreadedLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final Bindings b = e . createBindings ( ) ; final ScriptContext origContext = e . getContext ( ) ; final ScriptContext newCtxt = new SimpleScriptContext ( ) ; newCtxt . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; final String sharedScript = " foo " ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' original ▁ context ' ; " , origContext ) , null ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' new ▁ context ' ; " , newCtxt ) , null ) ; final Thread t1 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t2 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " new ▁ context " , 1000 ) ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( e . eval ( " foo ▁ = ▁ ' newer ▁ context ' ; " , newCtxt ) , " newer ▁ context " ) ; final Thread t3 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t4 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " newer ▁ context " , 1000 ) ) ; t3 . start ( ) ; t4 . start ( ) ; t3 . join ( ) ; t4 . join ( ) ; assertEquals ( e . eval ( sharedScript ) , " original ▁ context " ) ; assertEquals ( e . eval ( sharedScript , newCtxt ) , " newer ▁ context " ) ; } private static class ScriptRunner implements Runnable { final ScriptEngine engine ; final ScriptContext context ; final String source ; final Object expected ; final int iterations ; ScriptRunner ( final ScriptEngine engine , final ScriptContext context , final String source , final Object expected , final int iterations ) { this . engine = engine ; this . context = context ; this . source = source ; this . expected = expected ; this . iterations = iterations ; } @ Override public void run ( ) { try { for ( int i = 0 ; i < iterations ; i ++ ) { assertEquals ( engine . eval ( source , context ) , expected ) ; } } catch ( final ScriptException se ) { throw new RuntimeException ( se ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="tuchida/rhino/tree/master/testsrc/org/mozilla/javascript/tests/Bug688021Test.java"> package org . mozilla . javascript . tests ; import static org . junit . Assert . assertEquals ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mozilla . javascript . CompilerEnvirons ; import org . mozilla . javascript . Context ; import org . mozilla . javascript . ErrorReporter ; import org . mozilla . javascript . Parser ; import org . mozilla . javascript . ast . AstRoot ; public class Bug688021Test { private Context cx ; @ Before public void setUp ( ) { cx = Context . enter ( ) ; cx . setLanguageVersion ( Context . VERSION_1_8 ) ; } @ After public void tearDown ( ) { Context . exit ( ) ; } private AstRoot parse ( CharSequence cs ) { CompilerEnvirons compilerEnv = new CompilerEnvirons ( ) ; compilerEnv . initFromContext ( cx ) ; ErrorReporter compilationErrorReporter = compilerEnv . getErrorReporter ( ) ; Parser p = new Parser ( compilerEnv , compilationErrorReporter ) ; return p . parse ( cs . toString ( ) , " < eval > " , 1 ) ; } private String toSource ( CharSequence cs ) { return parse ( cs ) . toSource ( ) ; } @ Test public void testToSource ( ) { assertEquals ( " debugger ; \n " , toSource ( " debugger " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; \n " ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="aporter/coursera-android/tree/master/Examples/BluetoothSetupAndTransferData/src/course/examples/bluetooth/setupandtransferdata/ConnectionThread.java"> package course . examples . bluetooth . setupandtransferdata ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import android . bluetooth . BluetoothSocket ; import android . os . Handler ; public class ConnectionThread extends Thread { BluetoothSocket mBluetoothSocket ; private final Handler mHandler ; private InputStream mInStream ; private OutputStream mOutStream ; ConnectionThread ( BluetoothSocket socket , Handler handler ) { super ( ) ; mBluetoothSocket = socket ; mHandler = handler ; try { mInStream = mBluetoothSocket . getInputStream ( ) ; mOutStream = mBluetoothSocket . getOutputStream ( ) ; } catch ( IOException e ) { } } @ Override public void run ( ) { byte [ ] buffer = new byte [ 1024 ] ; int bytes ; while ( true ) { try { bytes = mInStream . read ( buffer ) ; String data = new String ( buffer , 0 , bytes ) ; mHandler . obtainMessage ( DataTransferActivity . DATA_RECEIVED , data ) . sendToTarget ( ) ; } catch ( IOException e ) { break ; } } } public void write ( byte [ ] bytes ) { try { mOutStream . write ( bytes ) ; } catch ( IOException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="karianna/jdk8_tl/tree/master/hotspot/test/compiler/5091921/Test6850611.java"> public class Test6850611 { public static void main ( String [ ] args ) { test ( ) ; } private static void test ( ) { for ( int j = 0 ; j < 5 ; ++ j ) { long x = 0 ; for ( int i = Integer . MIN_VALUE ; i < Integer . MAX_VALUE ; ++ i ) { x += i ; } System . out . println ( " sum : ▁ " + x ) ; if ( x != - 4294967295l ) { System . out . println ( " FAILED " ) ; System . exit ( 97 ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="agibsonccc/cloud-bigtable-client/tree/master/bigtable-hbase/src/main/java/com/google/cloud/bigtable/hbase/adapters/BigtableResultScannerAdapter.java"> package com . google . cloud . bigtable . hbase . adapters ; import com . google . api . client . util . Throwables ; import com . google . bigtable . v1 . Row ; import org . apache . hadoop . hbase . client . AbstractClientScanner ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . ResultScanner ; import java . io . IOException ; public class BigtableResultScannerAdapter { final ResponseAdapter < Row , Result > rowAdapter ; public BigtableResultScannerAdapter ( ResponseAdapter < Row , Result > rowAdapter ) { this . rowAdapter = rowAdapter ; } public ResultScanner adapt ( final com . google . cloud . bigtable . grpc . scanner . ResultScanner < Row > bigtableResultScanner ) { return new AbstractClientScanner ( ) { @ Override public Result next ( ) throws IOException { Row row = bigtableResultScanner . next ( ) ; if ( row == null ) { return null ; } return rowAdapter . adaptResponse ( row ) ; } @ Override public void close ( ) { try { bigtableResultScanner . close ( ) ; } catch ( IOException ioe ) { throw Throwables . propagate ( ioe ) ; } } } ; } } </DOCUMENT>
<DOCUMENT_ID="AtwooTM/cassandra/tree/master/src/java/org/apache/cassandra/cql3/UTName.java"> package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; public class UTName { private String ksName ; private final ColumnIdentifier utName ; public UTName ( ColumnIdentifier ksName , ColumnIdentifier utName ) { this . ksName = ksName == null ? null : ksName . toString ( ) ; this . utName = utName ; } public boolean hasKeyspace ( ) { return ksName != null ; } public void setKeyspace ( String keyspace ) { this . ksName = keyspace ; } public String getKeyspace ( ) { return ksName ; } public ByteBuffer getUserTypeName ( ) { return utName . bytes ; } public String getStringTypeName ( ) { return utName . toString ( ) ; } @ Override public String toString ( ) { return ( hasKeyspace ( ) ? ( ksName + " . " ) : " " ) + utName ; } } </DOCUMENT>
<DOCUMENT_ID="WelcomeHUME/svn-caucho-com-resin/tree/master/modules/jca/src/javax/resource/cci/ResourceAdapterMetaData.java"> package javax . resource . cci ; public interface ResourceAdapterMetaData { public String getAdapterVersion ( ) ; public String getAdapterVendorName ( ) ; public String getAdapterName ( ) ; public String getAdapterShortDescription ( ) ; public String getSpecVersion ( ) ; public String [ ] getInteractionSpecsSupported ( ) ; public boolean supportsExecuteWithInputAndOutputRecord ( ) ; public boolean supportsExecuteWithInputRecordOnly ( ) ; public boolean supportsLocalTransactionDemarcation ( ) ; } </DOCUMENT>
<DOCUMENT_ID="tharindum/opennms_dashboard/tree/master/opennms-webapp/src/main/java/org/opennms/web/report/database/ReportParametersValidator.java"> package org . opennms . web . report . database ; import java . util . Iterator ; import java . util . List ; import org . opennms . api . reporting . parameter . ReportDoubleParm ; import org . opennms . api . reporting . parameter . ReportFloatParm ; import org . opennms . api . reporting . parameter . ReportParameters ; import org . opennms . api . reporting . parameter . ReportDateParm ; import org . opennms . api . reporting . parameter . ReportIntParm ; import org . opennms . api . reporting . parameter . ReportStringParm ; import org . springframework . binding . message . MessageBuilder ; import org . springframework . binding . message . MessageContext ; import org . springframework . binding . validation . ValidationContext ; public class ReportParametersValidator { public void validateReportParameters ( ReportParameters reportCriteria , ValidationContext context ) { MessageContext messages = context . getMessageContext ( ) ; List < ReportDateParm > dateParms = reportCriteria . getDateParms ( ) ; for ( Iterator < ReportDateParm > dateParmIter = dateParms . iterator ( ) ; dateParmIter . hasNext ( ) ; ) { ReportDateParm dateParm = dateParmIter . next ( ) ; if ( dateParm . getDate ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " date ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ date ▁ field " + dateParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportStringParm > stringParms = reportCriteria . getStringParms ( ) ; for ( Iterator < ReportStringParm > stringParmIter = stringParms . iterator ( ) ; stringParmIter . hasNext ( ) ; ) { ReportStringParm stringParm = stringParmIter . next ( ) ; if ( stringParm . getValue ( ) == " " ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " string ▁ parms " ) . defaultText ( " cannot ▁ have ▁ empty ▁ string ▁ field " + stringParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportIntParm > intParms = reportCriteria . getIntParms ( ) ; for ( Iterator < ReportIntParm > intParmIter = intParms . iterator ( ) ; intParmIter . hasNext ( ) ; ) { ReportIntParm intParm = intParmIter . next ( ) ; if ( intParm . getValue ( ) == 0 ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " int ▁ parms " ) . defaultText ( " cannot ▁ have ▁ zero ▁ integer ▁ field " + intParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportFloatParm > floatParms = reportCriteria . getFloatParms ( ) ; for ( Iterator < ReportFloatParm > floatParmIter = floatParms . iterator ( ) ; floatParmIter . hasNext ( ) ; ) { ReportFloatParm floatParm = floatParmIter . next ( ) ; if ( floatParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " float ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ float ▁ field " + floatParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportDoubleParm > doubleParms = reportCriteria . getDoubleParms ( ) ; for ( Iterator < ReportDoubleParm > doubleParmIter = doubleParms . iterator ( ) ; doubleParmIter . hasNext ( ) ; ) { ReportDoubleParm doubleParm = doubleParmIter . next ( ) ; if ( doubleParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " double ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ double ▁ field " + doubleParm . getDisplayName ( ) ) . build ( ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="tuxillo/aarch64-dragonfly-gcc/tree/master/libjava/classpath/gnu/java/net/protocol/jar/Handler.java"> package gnu . java . net . protocol . jar ; import gnu . java . lang . CPStringBuilder ; import gnu . java . net . URLParseError ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLStreamHandler ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; public class Handler extends URLStreamHandler { public Handler ( ) { } protected URLConnection openConnection ( URL url ) throws IOException { return new Connection ( url ) ; } protected void parseURL ( URL url , String url_string , int start , int end ) { String file = url . getFile ( ) ; if ( ! file . equals ( " " ) ) { url_string = url_string . substring ( start , end ) ; if ( url_string . startsWith ( " / " ) ) { int idx = file . lastIndexOf ( " ! / " ) ; if ( idx < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; file = file . substring ( 0 , idx + 1 ) + url_string ; } else if ( url_string . length ( ) > 0 ) { int idx = file . lastIndexOf ( " / " ) ; if ( idx == - 1 ) file = " / " + url_string ; else if ( idx == ( file . length ( ) - 1 ) ) file = file + url_string ; else file = file . substring ( 0 , idx + 1 ) + url_string ; } setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , flat ( file ) , null ) ; return ; } if ( end < start ) return ; if ( end - start < 2 ) return ; if ( start > url_string . length ( ) ) return ; url_string = url_string . substring ( start , end ) ; int jar_stop ; if ( ( jar_stop = url_string . indexOf ( " ! / " ) ) < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; try { new URL ( url_string . substring ( 0 , jar_stop ) ) ; } catch ( MalformedURLException e ) { throw new URLParseError ( " invalid ▁ inner ▁ URL : ▁ " + e . getMessage ( ) ) ; } if ( ! url . getProtocol ( ) . equals ( " jar " ) ) throw new URLParseError ( " unexpected ▁ protocol ▁ " + url . getProtocol ( ) ) ; setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , url_string , null ) ; } private static String flat ( String url_string ) { int jar_stop = url_string . indexOf ( " ! / " ) ; String jar_path = url_string . substring ( jar_stop + 1 , url_string . length ( ) ) ; if ( jar_path . indexOf ( " / . " ) < 0 ) return url_string ; ArrayList < String > tokens = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( jar_path , " / " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equals ( " . " ) ) continue ; else if ( token . equals ( " . . " ) ) { if ( ! tokens . isEmpty ( ) ) tokens . remove ( tokens . size ( ) - 1 ) ; } else tokens . add ( token ) ; } CPStringBuilder path = new CPStringBuilder ( url_string . length ( ) ) ; path . append ( url_string . substring ( 0 , jar_stop + 1 ) ) ; Iterator < String > it = tokens . iterator ( ) ; while ( it . hasNext ( ) ) path . append ( ' / ' ) . append ( it . next ( ) ) ; return path . toString ( ) ; } protected String toExternalForm ( URL url ) { String file = url . getFile ( ) ; String ref = url . getRef ( ) ; CPStringBuilder sb = new CPStringBuilder ( file . length ( ) + 5 ) ; sb . append ( " jar : " ) ; sb . append ( file ) ; if ( ref != null ) sb . append ( ' # ' ) . append ( ref ) ; return sb . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="iliat/gatk-tools-java/tree/master/src/main/java/com/google/cloud/genomics/gatk/common/GenomicsConverterBase.java"> package com . google . cloud . genomics . gatk . common ; import htsjdk . samtools . SAMFileHeader ; import htsjdk . samtools . SAMRecord ; import java . util . List ; public abstract class GenomicsConverterBase < Read , ReadGroupSet , Reference > implements GenomicsConverter < Read , ReadGroupSet , Reference > { @ Override public SAMRecord makeSAMRecord ( Read read , ReadGroupSet readGroupSet , List < Reference > references , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , makeSAMFileHeader ( readGroupSet , references ) ) ; } @ Override public SAMRecord makeSAMRecord ( Read read , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , new SAMFileHeader ( ) ) ; } @ Override public abstract SAMFileHeader makeSAMFileHeader ( ReadGroupSet readGroupSet , List < Reference > references ) ; @ Override public abstract SAMRecord makeSAMRecord ( Read read , SAMFileHeader header ) ; } </DOCUMENT>
<DOCUMENT_ID="skyHALud/codenameone/tree/master/Ports/iOSPort/xmlvm/apache-harmony-6.0-src-r991881/classlib/modules/luni/src/test/api/common/org/apache/harmony/luni/tests/java/lang/ThreadTest.java"> package org . apache . harmony . luni . tests . java . lang ; import java . lang . Thread . UncaughtExceptionHandler ; import java . security . Permission ; import java . util . Map ; public class ThreadTest extends junit . framework . TestCase { static class SimpleThread implements Runnable { int delay ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; this . wait ( delay ) ; } } catch ( InterruptedException e ) { return ; } } public SimpleThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class YieldThread implements Runnable { volatile int delay ; public void run ( ) { int x = 0 ; while ( true ) { ++ x ; } } public YieldThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class ResSupThread implements Runnable { Thread parent ; volatile int checkVal = - 1 ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; } while ( true ) { checkVal ++ ; zz ( ) ; Thread . sleep ( 100 ) ; } } catch ( InterruptedException e ) { return ; } catch ( BogusException e ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException x ) { } parent . interrupt ( ) ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException x ) { break ; } } } } public void zz ( ) throws BogusException { } public ResSupThread ( Thread t ) { parent = t ; } public synchronized int getCheckVal ( ) { return checkVal ; } } static class BogusException extends Throwable { private static final long serialVersionUID = 1L ; public BogusException ( String s ) { super ( s ) ; } } Thread st , ct , spinner ; static boolean calledMySecurityManager = false ; public void test_Constructor ( ) { Thread t ; SecurityManager m = new SecurityManager ( ) { @ Override public ThreadGroup getThreadGroup ( ) { calledMySecurityManager = true ; return Thread . currentThread ( ) . getThreadGroup ( ) ; } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } ; try { System . setSecurityManager ( m ) ; t = new Thread ( ) ; } finally { System . setSecurityManager ( null ) ; } assertTrue ( " Did ▁ not ▁ call ▁ SecurityManager . getThreadGroup ▁ ( ) " , calledMySecurityManager ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_Runnable ( ) { ct = new Thread ( new SimpleThread ( 10 ) ) ; ct . start ( ) ; } public void test_ConstructorLjava_lang_RunnableLjava_lang_String ( ) { Thread st1 = new Thread ( new SimpleThread ( 1 ) , " SimpleThread1" ) ; assertEquals ( " Constructed ▁ thread ▁ with ▁ incorrect ▁ thread ▁ name " , " SimpleThread1" , st1 . getName ( ) ) ; st1 . start ( ) ; } public void test_ConstructorLjava_lang_String ( ) { Thread t = new Thread ( " Testing " ) ; assertEquals ( " Created ▁ tread ▁ with ▁ incorrect ▁ name " , " Testing " , t . getName ( ) ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_Runnable ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group1" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread2" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_RunnableLjava_lang_String ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group2" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread3" ) ; assertTrue ( " Constructed ▁ incorrect ▁ thread " , ( st . getThreadGroup ( ) == tg ) && st . getName ( ) . equals ( " SimpleThread3" ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; Runnable r = new Runnable ( ) { public void run ( ) { } } ; ThreadGroup foo = null ; try { new Thread ( foo = new ThreadGroup ( " foo " ) , r , null ) ; fail ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " ) ; } catch ( NullPointerException npe ) { assertTrue ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " , true ) ; foo . destroy ( ) ; } } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread4" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread4" , st . getName ( ) ) ; st . start ( ) ; } public void test_activeCount ( ) { Thread t = new Thread ( new SimpleThread ( 10 ) ) ; int active = 0 ; synchronized ( t ) { t . start ( ) ; active = Thread . activeCount ( ) ; } assertTrue ( " Incorrect ▁ activeCount ▁ for ▁ current ▁ group : ▁ " + active , active > 1 ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { } } public void test_checkAccess ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group3" ) ; try { st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread5" ) ; st . checkAccess ( ) ; assertTrue ( " CheckAccess ▁ passed " , true ) ; } catch ( SecurityException e ) { fail ( " CheckAccess ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; } st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_countStackFrames ( ) { Thread . currentThread ( ) . countStackFrames ( ) ; } public void test_currentThread ( ) { assertNotNull ( Thread . currentThread ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_destroy ( ) { try { new Thread ( ) . destroy ( ) ; } catch ( NoSuchMethodError e ) { } } public void test_enumerate$Ljava_lang_Thread ( ) { class MyThread extends Thread { MyThread ( ThreadGroup tg , String name ) { super ( tg , name ) ; } boolean failed = false ; String failMessage = null ; public void run ( ) { SimpleThread st1 = null ; SimpleThread st2 = null ; ThreadGroup mytg = null ; Thread firstOne = null ; Thread secondOne = null ; try { int arrayLength = 10 ; Thread [ ] tarray = new Thread [ arrayLength ] ; st1 = new SimpleThread ( - 1 ) ; st2 = new SimpleThread ( - 1 ) ; mytg = new ThreadGroup ( " jp " ) ; firstOne = new Thread ( mytg , st1 , " firstOne2" ) ; secondOne = new Thread ( mytg , st2 , " secondOne1" ) ; int count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned1" , 1 , count ) ; synchronized ( st1 ) { firstOne . start ( ) ; try { st1 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned2" , 2 , count ) ; synchronized ( st2 ) { secondOne . start ( ) ; try { st2 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned3" , 3 , count ) ; } catch ( junit . framework . AssertionFailedError e ) { failed = true ; failMessage = e . getMessage ( ) ; } finally { synchronized ( st1 ) { firstOne . interrupt ( ) ; } synchronized ( st2 ) { secondOne . interrupt ( ) ; } try { firstOne . join ( ) ; secondOne . join ( ) ; } catch ( InterruptedException e ) { } mytg . destroy ( ) ; } } } ; ThreadGroup tg = new ThreadGroup ( " tg " ) ; MyThread t = new MyThread ( tg , " top " ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt " ) ; } finally { tg . destroy ( ) ; } assertFalse ( t . failMessage , t . failed ) ; } public void test_getContextClassLoader ( ) { Thread t = new Thread ( ) ; assertTrue ( " Incorrect ▁ class ▁ loader ▁ returned " , t . getContextClassLoader ( ) == Thread . currentThread ( ) . getContextClassLoader ( ) ) ; t . start ( ) ; } public void test_getName ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread6" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread6" , st . getName ( ) ) ; st . start ( ) ; } public void test_getPriority ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_getThreadGroup ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group4" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread8" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } assertNull ( " group ▁ should ▁ be ▁ null " , st . getThreadGroup ( ) ) ; assertNotNull ( " toString ( ) ▁ should ▁ not ▁ be ▁ null " , st . toString ( ) ) ; tg . destroy ( ) ; final Object lock = new Object ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } } ; synchronized ( lock ) { t . start ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } int running = 0 ; while ( t . isAlive ( ) ) running ++ ; ThreadGroup group = t . getThreadGroup ( ) ; assertNull ( " ThreadGroup ▁ is ▁ not ▁ null " , group ) ; } public void test_interrupt ( ) { final Object lock = new Object ( ) ; class ChildThread1 extends Thread { Thread parent ; boolean sync ; @ Override public void run ( ) { if ( sync ) { synchronized ( lock ) { lock . notify ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } } parent . interrupt ( ) ; } public ChildThread1 ( Thread p , String name , boolean sync ) { super ( name ) ; parent = p ; this . sync = sync ; } } boolean interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test1" , false ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; } } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread1" , interrupted ) ; interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test2" , true ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; lock . notify ( ) ; } Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread2" , interrupted ) ; } public void test_interrupted ( ) { assertFalse ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; assertTrue ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; assertFalse ( " Failed ▁ to ▁ clear ▁ interrupted ▁ flag " , Thread . interrupted ( ) ) ; } public void test_isAlive ( ) { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 500 ) ) ; assertFalse ( " A ▁ thread ▁ that ▁ wasn ' t ▁ started ▁ is ▁ alive . " , st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; try { simple . wait ( ) ; } catch ( InterruptedException e ) { } } assertTrue ( " Started ▁ thread ▁ returned ▁ false " , st . isAlive ( ) ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Thread ▁ did ▁ not ▁ die " ) ; } assertTrue ( " Stopped ▁ thread ▁ returned ▁ true " , ! st . isAlive ( ) ) ; } public void test_isDaemon ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread10" ) ; assertTrue ( " Non - Daemon ▁ thread ▁ returned ▁ true " , ! st . isDaemon ( ) ) ; st . setDaemon ( true ) ; assertTrue ( " Daemon ▁ thread ▁ returned ▁ false " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_isInterrupted ( ) { class SpinThread implements Runnable { public volatile boolean done = false ; public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) ; while ( ! done ) ; } } SpinThread spin = new SpinThread ( ) ; spinner = new Thread ( spin ) ; spinner . start ( ) ; Thread . yield ( ) ; try { assertTrue ( " Non - Interrupted ▁ thread ▁ returned ▁ true " , ! spinner . isInterrupted ( ) ) ; spinner . interrupt ( ) ; assertTrue ( " Interrupted ▁ thread ▁ returned ▁ false " , spinner . isInterrupted ( ) ) ; spin . done = true ; } finally { spinner . interrupt ( ) ; spin . done = true ; } } public void test_join ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 100 ) ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { th . join ( ) ; } catch ( InterruptedException e ) { result = false ; } assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJ ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 1000 ) , " SimpleThread12" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 10 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Join ▁ failed ▁ to ▁ timeout " , st . isAlive ( ) ) ; st . interrupt ( ) ; try { st = new Thread ( simple = new SimpleThread ( 100 ) , " SimpleThread13" ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 1000 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; return ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJI ( ) throws Exception { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 1000 ) , " Squawk1" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } long firstRead = System . currentTimeMillis ( ) ; st . join ( 100 , 999999 ) ; long secondRead = System . currentTimeMillis ( ) ; assertTrue ( " Did ▁ not ▁ join ▁ by ▁ appropriate ▁ time : ▁ " + secondRead + " - " + firstRead + " = " + ( secondRead - firstRead ) , secondRead - firstRead <= 300 ) ; assertTrue ( " Joined ▁ thread ▁ is ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 , 20 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_resume ( ) { int orgval ; ResSupThread t ; try { t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test2" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred ▁ : ▁ " + e . getMessage ( ) ) ; } } public void test_run ( ) { class RunThread implements Runnable { boolean didThreadRun = false ; public void run ( ) { didThreadRun = true ; } } RunThread rt = new RunThread ( ) ; Thread t = new Thread ( rt ) ; try { t . start ( ) ; int count = 0 ; while ( ! rt . didThreadRun && count < 20 ) { Thread . sleep ( 100 ) ; count ++ ; } assertTrue ( " Thread ▁ did ▁ not ▁ run " , rt . didThreadRun ) ; t . join ( ) ; } catch ( InterruptedException e ) { assertTrue ( " Joined ▁ thread ▁ was ▁ interrupted " , true ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! t . isAlive ( ) ) ; } public void test_setDaemonZ ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread14" ) ; st . setDaemon ( true ) ; assertTrue ( " Failed ▁ to ▁ set ▁ thread ▁ as ▁ daemon ▁ thread " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_setNameLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread15" ) ; st . setName ( " Bogus ▁ Name " ) ; assertEquals ( " Failed ▁ to ▁ set ▁ thread ▁ name " , " Bogus ▁ Name " , st . getName ( ) ) ; try { st . setName ( null ) ; fail ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " ) ; } catch ( NullPointerException e ) { assertTrue ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " , true ) ; } st . start ( ) ; } public void test_setPriorityI ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Failed ▁ to ▁ set ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_sleepJ ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough " , ( ftime - stime ) >= 800 ) ; } public void test_sleepJI ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 , 999999 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } long result = ftime - stime ; assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough : ▁ " + result , result >= 900 && result <= 1100 ) ; } public void test_start ( ) { try { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test4" ) ; ct . start ( ) ; t . wait ( ) ; } assertTrue ( " Thread ▁ is ▁ not ▁ running1" , ct . isAlive ( ) ) ; int orgval = t . getCheckVal ( ) ; Thread . sleep ( 150 ) ; assertTrue ( " Thread ▁ is ▁ not ▁ running2" , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stop ( ) { try { Runnable r = new ResSupThread ( null ) ; synchronized ( r ) { st = new Thread ( r , " Interupt ▁ Test5" ) ; st . start ( ) ; r . wait ( ) ; } } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } st . stop ( ) ; try { st . join ( 10000 ) ; } catch ( InterruptedException e1 ) { st . interrupt ( ) ; fail ( " Failed ▁ to ▁ stopThread ▁ before ▁ 10000 ▁ timeout " ) ; } assertTrue ( " Failed ▁ to ▁ stopThread " , ! st . isAlive ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_stop_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { fail ( " checkAccess ▁ called " ) ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; public boolean checkAccess = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { checkAccess = true ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } sm . intest = false ; assertTrue ( " no ▁ checkAccess ▁ 1" , sm . checkAccess ) ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; sm . checkAccess = false ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } assertTrue ( " no ▁ checkAccess ▁ 2" , sm . checkAccess ) ; sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable ( ) { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { st = new Thread ( t , " StopThread " ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; st . start ( ) ; try { t . wait ( ) ; } catch ( InterruptedException e ) { } } try { st . stop ( new BogusException ( " Bogus " ) ) ; Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { assertTrue ( " Stopped ▁ child ▁ with ▁ exception ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; return ; } st . interrupt ( ) ; fail ( " Stopped ▁ child ▁ did ▁ not ▁ throw ▁ exception " ) ; } @ SuppressWarnings ( " deprecation " ) public void test_suspend ( ) { int orgval ; ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; try { synchronized ( t ) { ct = new Thread ( t , " Interupt ▁ Test6" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } final Object notify = new Object ( ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { synchronized ( notify ) { notify . notify ( ) ; } Thread . currentThread ( ) . suspend ( ) ; } } ) ; try { synchronized ( notify ) { t1 . start ( ) ; notify . wait ( ) ; } Thread . sleep ( 500 ) ; assertTrue ( " Thread ▁ should ▁ be ▁ alive " , t1 . isAlive ( ) ) ; t1 . resume ( ) ; t1 . join ( ) ; } catch ( InterruptedException e ) { } } public void test_toString ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group5" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread17" ) ; final String stString = st . toString ( ) ; final String expected = " Thread [ SimpleThread17,5 , Test ▁ Group5 ] " ; assertTrue ( " Returned ▁ incorrect ▁ string : ▁ " + stString + " \t ( expecting ▁ : " + expected + " ) " , stString . equals ( expected ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_getAllStackTraces ( ) { Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; assertNotNull ( stMap ) ; } public void test_get_setDefaultUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . getDefaultUncaughtExceptionHandler ( ) ) ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; assertNull ( Thread . getDefaultUncaughtExceptionHandler ( ) ) ; } public void test_getStackTrace ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; assertNotNull ( stackTrace ) ; stack_trace_loop : { for ( int i = 0 ; i < stackTrace . length ; i ++ ) { StackTraceElement e = stackTrace [ i ] ; if ( getClass ( ) . getName ( ) . equals ( e . getClassName ( ) ) ) { if ( " test _ getStackTrace " . equals ( e . getMethodName ( ) ) ) { break stack_trace_loop ; } } } fail ( " class ▁ and ▁ method ▁ not ▁ found ▁ in ▁ stack ▁ trace " ) ; } } public void test_getState ( ) { Thread . State state = Thread . currentThread ( ) . getState ( ) ; assertNotNull ( state ) ; assertEquals ( Thread . State . RUNNABLE , state ) ; } public void test_get_setUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; } public void test_getId ( ) { assertTrue ( " current ▁ thread ' s ▁ ID ▁ is ▁ not ▁ positive " , Thread . currentThread ( ) . getId ( ) > 0 ) ; Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; for ( Thread thread : stMap . keySet ( ) ) { assertTrue ( " thread ' s ▁ ID ▁ is ▁ not ▁ positive : ▁ " + thread . getName ( ) , thread . getId ( ) > 0 ) ; } } @ Override protected void tearDown ( ) { try { if ( st != null ) st . interrupt ( ) ; } catch ( Exception e ) { } try { if ( spinner != null ) spinner . interrupt ( ) ; } catch ( Exception e ) { } try { if ( ct != null ) ct . interrupt ( ) ; } catch ( Exception e ) { } try { spinner = null ; st = null ; ct = null ; System . runFinalization ( ) ; } catch ( Exception e ) { } } } </DOCUMENT>
<DOCUMENT_ID="mstine/polyglot-osgi/tree/master/lib/osgi/felix/org.apache.felix.framework-1.8.1/src/main/java/org/apache/felix/framework/util/JarFileX.java"> package org . apache . felix . framework . util ; import java . io . File ; import java . io . IOException ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . zip . ZipEntry ; public class JarFileX extends JarFile { public JarFileX ( File file ) throws IOException { super ( file ) ; } public JarFileX ( File file , boolean verify ) throws IOException { super ( file , verify ) ; } public JarFileX ( File file , boolean verify , int mode ) throws IOException { super ( file , verify , mode ) ; } public JarFileX ( String name ) throws IOException { super ( name ) ; } public JarFileX ( String name , boolean verify ) throws IOException { super ( name , verify ) ; } public ZipEntry getEntry ( String name ) { ZipEntry entry = super . getEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { ZipEntry dirEntry = super . getEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } public JarEntry getJarEntry ( String name ) { JarEntry entry = super . getJarEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { JarEntry dirEntry = super . getJarEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } } </DOCUMENT>
<DOCUMENT_ID="moosbusch/xbLIDO/tree/master/src/net/opengis/gml/GridCoverageDocument.java"> package net . opengis . gml ; public interface GridCoverageDocument extends net . opengis . gml . DiscreteCoverageDocument { public static final org . apache . xmlbeans . SchemaType type = ( org . apache . xmlbeans . SchemaType ) org . apache . xmlbeans . XmlBeans . typeSystemForClassLoader ( GridCoverageDocument . class . getClassLoader ( ) , " schemaorg _ apache _ xmlbeans . system . s6E28D279B6C224D74769DB8B98AF1665" ) . resolveHandle ( " gridcoveragea6fddoctype " ) ; net . opengis . gml . GridCoverageType getGridCoverage ( ) ; void setGridCoverage ( net . opengis . gml . GridCoverageType gridCoverage ) ; net . opengis . gml . GridCoverageType addNewGridCoverage ( ) ; public static final class Factory { public static net . opengis . gml . GridCoverageDocument newInstance ( ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } public static net . opengis . gml . GridCoverageDocument newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , options ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } private Factory ( ) { } } } </DOCUMENT>
<DOCUMENT_ID="innerverse/libjitsi/tree/master/src/org/jitsi/util/xml/DOMElementWriter.java"> package org . jitsi . util . xml ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static final String lSep = System . getProperty ( " line . separator " ) ; public static String decodeName ( String name ) { int length = name . length ( ) ; StringBuilder value = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; ) { int start = name . indexOf ( ' _ ' , i ) ; if ( start == - 1 ) { value . append ( name , i , length ) ; break ; } if ( i != start ) value . append ( name , i , start ) ; int end = start + 6 ; if ( ( end < length ) && ( name . charAt ( start + 1 ) == ' x ' ) && ( name . charAt ( end ) == ' _ ' ) && isHexDigit ( name . charAt ( start + 2 ) ) && isHexDigit ( name . charAt ( start + 3 ) ) && isHexDigit ( name . charAt ( start + 4 ) ) && isHexDigit ( name . charAt ( start + 5 ) ) ) { char c = ( char ) Integer . parseInt ( name . substring ( start + 2 , end ) , 16 ) ; if ( ( start == 0 ) ? ! isNameStartChar ( c ) : ! isNameChar ( c ) ) { value . append ( c ) ; i = end + 1 ; continue ; } } value . append ( name . charAt ( start ) ) ; i = start + 1 ; } return value . toString ( ) ; } public static String encodeName ( String value ) { int length = value . length ( ) ; StringBuilder name = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = value . charAt ( i ) ; if ( i == 0 ) { if ( isNameStartChar ( c ) ) { name . append ( c ) ; continue ; } } else if ( isNameChar ( c ) ) { name . append ( c ) ; continue ; } name . append ( " _ x " ) ; if ( c <= 0x000F ) name . append ( "000" ) ; else if ( c <= 0x00FF ) name . append ( "00" ) ; else if ( c <= 0x0FFF ) name . append ( '0' ) ; name . append ( Integer . toHexString ( c ) . toUpperCase ( ) ) ; name . append ( ' _ ' ) ; } return name . toString ( ) ; } private static boolean isHexDigit ( char c ) { return ( ( '0' <= c ) && ( c <= '9' ) ) || ( ( ' A ' <= c ) && ( c <= ' F ' ) ) || ( ( ' a ' <= c ) && ( c <= ' f ' ) ) ; } private static boolean isNameChar ( char c ) { if ( isNameStartChar ( c ) ) return true ; else if ( ( c == ' - ' ) || ( c == ' . ' ) ) return true ; else if ( ( '0' <= c ) && ( c <= '9' ) ) return true ; else if ( c == 0xB7 ) return true ; else if ( c < 0x0300 ) return false ; else if ( c <= 0x036F ) return true ; else if ( c < 0x203F ) return false ; else if ( c <= 0x2040 ) return true ; else return false ; } private static boolean isNameStartChar ( char c ) { if ( ( c == ' : ' ) || ( c == ' _ ' ) ) return true ; else if ( ( ' A ' <= c ) && ( c <= ' Z ' ) ) return true ; else if ( ( ' a ' <= c ) && ( c <= ' z ' ) ) return true ; else if ( c < 0xC0 ) return false ; else if ( c <= 0xD6 ) return true ; else if ( c < 0xD8 ) return false ; else if ( c <= 0xF6 ) return true ; else if ( c < 0xF8 ) return false ; else if ( c <= 0x2FF ) return true ; else if ( c < 0x370 ) return false ; else if ( c <= 0x37D ) return true ; else if ( c < 0x37F ) return false ; else if ( c <= 0x1FFF ) return true ; else if ( c < 0x200C ) return false ; else if ( c <= 0x200D ) return true ; else if ( c < 0x2070 ) return false ; else if ( c <= 0x218F ) return true ; else if ( c < 0x2C00 ) return false ; else if ( c <= 0x2FEF ) return true ; else if ( c < 0x3001 ) return false ; else if ( c <= 0xD7FF ) return true ; else if ( c < 0xF900 ) return false ; else if ( c <= 0xFDCF ) return true ; else if ( c < 0xFDF0 ) return false ; else if ( c <= 0xFFFD ) return true ; else return false ; } protected String [ ] knownEntities = { " gt " , " amp " , " lt " , " apos " , " quot " } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , " UTF - 8" ) ; wri . write ( " < ? xml ▁ version = \ " 1.0\ " ▁ encoding = \ " UTF - 8\ " ? > " + lSep ) ; write ( root , wri , 0 , " ▁ ▁ " ) ; wri . flush ( ) ; } public void write ( Node element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } if ( element . getNodeType ( ) == Node . COMMENT_NODE ) { out . write ( " < ! - - " ) ; out . write ( encode ( element . getNodeValue ( ) ) ) ; out . write ( " - - > " ) ; } else { out . write ( " < " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " ▁ " ) ; out . write ( attr . getName ( ) ) ; out . write ( " = \ " " ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( " \ " " ) ; } out . write ( " > " ) ; } boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; element . hasChildNodes ( ) && i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : case Node . COMMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : if ( child . getNodeValue ( ) != null && ( child . getNodeValue ( ) . indexOf ( " \n " ) == - 1 || child . getNodeValue ( ) . trim ( ) . length ( ) != 0 ) ) out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( " < ! [ CDATA [ " ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( " ] ] > " ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( ' & ' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ' ; ' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( " < ? " ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ▁ ' ) ; out . write ( data ) ; } out . write ( " ? > " ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } if ( element . getNodeType ( ) == Node . ELEMENT_NODE ) { out . write ( " < / " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; out . write ( " > " ) ; } out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case ' < ' : sb . append ( " & lt ; " ) ; break ; case ' > ' : sb . append ( " & gt ; " ) ; break ; case ' \ ' ' : sb . append ( " & apos ; " ) ; break ; case ' \ " ' : sb . append ( " & quot ; " ) ; break ; case ' & ' : int nextSemi = value . indexOf ( " ; " , i ) ; if ( ( nextSemi < 0 ) || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) sb . append ( " & amp ; " ) ; else sb . append ( ' & ' ) ; break ; default : if ( isLegalCharacter ( c ) ) sb . append ( c ) ; break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( " ] ] > " ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( " & # x5d ; & # x5d ; & gt ; " ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( " ] ] > " ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == ' & ' ) || ! ent . endsWith ( " ; " ) ) return false ; if ( ent . charAt ( 1 ) == ' # ' ) { if ( ent . charAt ( 2 ) == ' x ' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="deeplearning4j/deeplearning4j/tree/master/nd4j/nd4j-backends/nd4j-api-parent/nd4j-api/src/main/java/org/nd4j/linalg/api/ops/impl/transforms/custom/segment/SegmentMin.java"> package org . nd4j . linalg . api . ops . impl . transforms . custom . segment ; import org . nd4j . autodiff . samediff . SDVariable ; import org . nd4j . autodiff . samediff . SameDiff ; import org . nd4j . base . Preconditions ; import org . nd4j . linalg . api . buffer . DataType ; import org . nd4j . linalg . api . ops . DynamicCustomOp ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class SegmentMin extends DynamicCustomOp { public SegmentMin ( SameDiff sameDiff , SDVariable data , SDVariable segmentIds ) { super ( null , sameDiff , new SDVariable [ ] { data , segmentIds } , false ) ; } public SegmentMin ( ) { } @ Override public String opName ( ) { return " segment _ min " ; } @ Override public String tensorflowName ( ) { return " SegmentMin " ; } @ Override public List < SDVariable > doDiff ( List < SDVariable > gradients ) { return Arrays . asList ( f ( ) . segmentMinBp ( arg ( 0 ) , arg ( 1 ) , gradients . get ( 0 ) ) ) ; } @ Override public List < DataType > calculateOutputDataTypes ( List < DataType > inputDataTypes ) { Preconditions . checkState ( inputDataTypes != null && inputDataTypes . size ( ) == 2 , " Expected ▁ exactly ▁ 2 ▁ input ▁ datatypes ▁ for ▁ % s , ▁ got ▁ % s " , getClass ( ) , inputDataTypes ) ; Preconditions . checkState ( inputDataTypes . get ( 1 ) . isIntType ( ) , " Datatype ▁ for ▁ input ▁ 1 ▁ ( Segment ▁ IDs ) ▁ must ▁ be ▁ an ▁ integer ▁ type , ▁ got ▁ % s " , inputDataTypes . get ( 1 ) ) ; return Collections . singletonList ( inputDataTypes . get ( 0 ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="Authorlove/hadoop/tree/master/hadoop-tools/hadoop-rumen/src/main/java/org/apache/hadoop/tools/rumen/DefaultInputDemuxer.java"> package org . apache . hadoop . tools . rumen ; import java . io . IOException ; import java . io . InputStream ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; public class DefaultInputDemuxer implements InputDemuxer { String name ; InputStream input ; @ Override public void bindTo ( Path path , Configuration conf ) throws IOException { if ( name != null ) { close ( ) ; } name = path . getName ( ) ; input = new PossiblyDecompressedInputStream ( path , conf ) ; return ; } @ Override public Pair < String , InputStream > getNext ( ) throws IOException { if ( name != null ) { Pair < String , InputStream > ret = new Pair < String , InputStream > ( name , input ) ; name = null ; input = null ; return ret ; } return null ; } @ Override public void close ( ) throws IOException { try { if ( input != null ) { input . close ( ) ; } } finally { name = null ; input = null ; } } } </DOCUMENT>
<DOCUMENT_ID="sourcepit/osgifier/tree/master/org.sourcepit.osgifier.core/gen/main/emf/org/sourcepit/osgifier/core/model/java/Named.java"> package org . sourcepit . osgifier . core . model . java ; import org . eclipse . emf . ecore . EObject ; public interface Named extends EObject { String getName ( ) ; void setName ( String value ) ; } </DOCUMENT>
<DOCUMENT_ID="MeetMe/selenium/tree/master/java/server/src/org/openqa/grid/internal/listeners/Prioritizer.java"> package org . openqa . grid . internal . listeners ; import java . util . Map ; public interface Prioritizer { public int compareTo ( Map < String , Object > a , Map < String , Object > b ) ; } </DOCUMENT>
<DOCUMENT_ID="esi-mineset/spark/tree/master/sql/core/src/test/java/test/org/apache/spark/sql/JavaStringLength.java"> package test . org . apache . spark . sql ; import org . apache . spark . sql . api . java . UDF1 ; public class JavaStringLength implements UDF1 < String , Integer > { @ Override public Integer call ( String str ) throws Exception { return new Integer ( str . length ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="sg26565/hott-transmitter-config/tree/master/lzma-sdk/src/main/java/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
