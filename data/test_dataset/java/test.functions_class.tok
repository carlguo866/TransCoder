public String foo ( ) { return null ; }
String foo ( int i ) { return null ; }
String foo ( Foo foo ) { return null ; }
public void writeObject ( FSTObjectOutput out , Object toWrite , FSTClazzInfo clzInfo , FSTClazzInfo . FSTFieldInfo referencedBy , int streamPosition ) throws IOException { EnumSet enset = ( EnumSet ) toWrite ; int count = 0 ; out . writeInt ( enset . size ( ) ) ; if ( enset . isEmpty ( ) ) { EnumSet compl = EnumSet . complementOf ( enset ) ; out . writeClassTag ( compl . iterator ( ) . next ( ) . getClass ( ) ) ; } else { for ( Object element : enset ) { if ( count == 0 ) { out . writeStringUTF ( element . getClass ( ) . getName ( ) ) ; } out . writeStringUTF ( element . toString ( ) ) ; count ++ ; } } }
public boolean alwaysCopy ( ) { return false ; }
public Object instantiate ( Class objectClass , FSTObjectInput in , FSTClazzInfo serializationInfo , FSTClazzInfo . FSTFieldInfo referencee , int streamPosition ) throws Exception { int len = in . readInt ( ) ; Class elemCl = in . getClassForName ( in . readStringUTF ( ) ) ; EnumSet enSet = EnumSet . noneOf ( elemCl ) ; in . registerObject ( enSet , streamPosition , serializationInfo , referencee ) ; for ( int i = 0 ; i < len ; i ++ ) { String val = in . readStringUTF ( ) ; enSet . add ( Enum . valueOf ( elemCl , val ) ) ; } return enSet ; }
BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; }
public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; }
public void testZip ( ) { String [ ] s1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int count = 0 ; for ( Pair < String , Integer > pair : Iterables . zip ( s1 , s2 ) ) { assertEquals ( pair . first , s1 [ count ] ) ; assertEquals ( pair . second , s2 [ count ] ) ; count ++ ; } assertEquals ( s1 . length < s2 . length ? s1 . length : s2 . length , count ) ; }
; }
public void testFilter ( ) { List < String > values = Arrays . asList ( " a " , " HI " , " tHere " , " YO " ) ; Iterator < String > iterator = Iterables . filter ( values , new Function < String , Boolean > ( ) { public Boolean apply ( String in ) { return in . equals ( in . toUpperCase ( ) ) ; } } ) . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( iterator . next ( ) , " HI " ) ; assertEquals ( iterator . next ( ) , " YO " ) ; assertFalse ( iterator . hasNext ( ) ) ; }
public void testTransform ( ) { List < Integer > values = Arrays . asList ( 1 , 2 , 3 , 4 ) ; List < Integer > squares = Arrays . asList ( 1 , 4 , 9 , 16 ) ; Function < Integer , Integer > squarer = new Function < Integer , Integer > ( ) { public Integer apply ( Integer in ) { return in * in ; } } ; for ( Pair < Integer , Integer > pair : Iterables . zip ( Iterables . transform ( values , squarer ) , squares ) ) { assertEquals ( pair . first , pair . second ) ; } }
public void testMerge ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Pair < String , String > > iter = Iterables . merge ( a , b , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " d " , " d " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; }
public void testMerge3 ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; List < String > c = Arrays . asList ( " a " , " b " , " c " , " e " , " f " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Triple < String , String , String > > iter = Iterables . merge ( a , b , c , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; }
public void testGroup ( ) { String [ ] input = new String [ ] { "0 ▁ ab " , "0 ▁ bb " , "0 ▁ cc " , "1 ▁ dd " , "2 ▁ dd " , "2 ▁ kj " , "3 ▁ kj " , "3 ▁ kk " } ; int [ ] counts = new int [ ] { 3 , 1 , 2 , 2 } ; Comparator < String > fieldOne = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . split ( " ▁ " ) [ 0 ] . compareTo ( o2 . split ( " ▁ " ) [ 0 ] ) ; } } ; int index = 0 ; int group = 0 ; for ( Iterable < String > set : Iterables . group ( Arrays . asList ( input ) , fieldOne ) ) { String sharedKey = null ; int thisCount = 0 ; for ( String line : set ) { String thisKey = line . split ( " ▁ " ) [ 0 ] ; if ( sharedKey == null ) { sharedKey = thisKey ; } else { assertEquals ( " Wrong ▁ key " , sharedKey , thisKey ) ; } assertEquals ( " Wrong ▁ input ▁ line " , line , input [ index ++ ] ) ; thisCount ++ ; } assertEquals ( " Wrong ▁ number ▁ of ▁ items ▁ in ▁ this ▁ iterator " , counts [ group ++ ] , thisCount ) ; } assertEquals ( " Didn ' t ▁ get ▁ all ▁ inputs " , input . length , index ) ; assertEquals ( " Wrong ▁ number ▁ of ▁ groups " , counts . length , group ) ; }
public void testSample ( ) { Iterable < Integer > items = Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ; int count = 0 ; for ( Integer item : Iterables . sample ( items , 5 , 2 , new Random ( ) ) ) { ++ count ; Assert . assertTrue ( item <= 5 ) ; Assert . assertTrue ( item >= 1 ) ; } Assert . assertEquals ( 2 , count ) ; }
public GridJobSiblingsResponse ( ) { }
public GridJobSiblingsResponse ( @ Nullable Collection < ComputeJobSibling > siblings , @ Nullable byte [ ] siblingsBytes ) { this . siblings = siblings ; this . siblingsBytes = siblingsBytes ; }
public Collection < ComputeJobSibling > jobSiblings ( ) { return siblings ; }
public void unmarshalSiblings ( Marshaller marsh ) throws IgniteCheckedException { assert marsh != null ; if ( siblingsBytes != null ) siblings = marsh . unmarshal ( siblingsBytes , null ) ; }
public void onAckReceived ( ) { }
public boolean writeTo ( ByteBuffer buf , MessageWriter writer ) { writer . setBuffer ( buf ) ; if ( ! writer . isHeaderWritten ( ) ) { if ( ! writer . writeHeader ( directType ( ) , fieldsCount ( ) ) ) return false ; writer . onHeaderWritten ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . writeByteArray ( " siblingsBytes " , siblingsBytes ) ) return false ; writer . incrementState ( ) ; } return true ; }
public boolean readFrom ( ByteBuffer buf , MessageReader reader ) { reader . setBuffer ( buf ) ; if ( ! reader . beforeMessageRead ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : siblingsBytes = reader . readByteArray ( " siblingsBytes " ) ; if ( ! reader . isLastRead ( ) ) return false ; reader . incrementState ( ) ; } return reader . afterMessageRead ( GridJobSiblingsResponse . class ) ; }
public byte directType ( ) { return 4 ; }
public byte fieldsCount ( ) { return 1 ; }
public String toString ( ) { return S . toString ( GridJobSiblingsResponse . class , this ) ; }
public Style ( Dispatch dispatch ) { super ( dispatch ) ; }
@ Before public void setup ( ) { creator = new SjukfallIntygEnhetCreator ( ) ; parameters = new IntygParametrar ( 5 , LocalDate . parse ( "2016-02-16" ) ) ; }
@ Test public void testCreatingMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ but ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; }
@ Test public void testReducedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > reducedMap = creator . reduceMap ( map ) ; assertTrue ( " Expected ▁ 6 ▁ but ▁ was ▁ " + reducedMap . size ( ) , reducedMap . size ( ) == 6 ) ; }
@ Test public void testSortedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > sortedMap = creator . sortValues ( map ) ; for ( Map . Entry < String , List < SjukfallIntyg > > entry : sortedMap . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { SjukfallIntyg [ ] arr = entry . getValue ( ) . toArray ( new SjukfallIntyg [ entry . getValue ( ) . size ( ) ] ) ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { assertTrue ( arr [ i ] . getSlutDatum ( ) . isBefore ( arr [ i + 1 ] . getSlutDatum ( ) ) ) ; } } } }
@ Test public void testSetActiveCertificate ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > activeMap = creator . setActive ( map ) ; assertTrue ( activeMap . entrySet ( ) . stream ( ) . allMatch ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . isAktivtIntyg ( ) ) . count ( ) < 2 ) ) ; }
@ Test public void testFall1 ( ) { String key = "19791110-9291" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall2 ( ) { String key = "19791123-9262" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall3 ( ) { String key = "19791212-9280" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall4 ( ) { String key = "19800113-9297" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall5 ( ) { String key = "19800124-9286" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertTrue ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertFalse ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall6 ( ) { String key = "19800207-9294" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertFalse ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; }
@ Test public void testFall7 ( ) { String key = "19800228-9224" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; assertNull ( map . get ( key ) ) ; }
protected Collection < RequestHandler > createRequestHandlers ( ) { return ImmutableSet . of ( new TunnelDataRequestHandler ( ) ) ; }
public TunnelDataRequestHandler ( ) { super ( TUNNEL_DATA_REQ , TUNNEL_DATA_RESP , TUNNELS ) ; }
protected String [ ] getColumnIds ( ) { return COL_IDS ; }
protected String noRowsMessage ( ObjectNode payload ) { return NO_ROWS_MESSAGE ; }
protected TableModel createTableModel ( ) { TableModel tm = super . createTableModel ( ) ; tm . setFormatter ( ONE , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TWO , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TYPE , EnumFormatter . INSTANCE ) ; return tm ; }
protected void populateTable ( TableModel tm , ObjectNode payload ) { TunnelService ts = get ( TunnelService . class ) ; ts . queryAllTunnels ( ) . forEach ( tunnel -> populateRow ( tm . addRow ( ) , tunnel ) ) ; }
private void populateRow ( TableModel . Row row , Tunnel tunnel ) { row . cell ( ID , tunnel . tunnelId ( ) . id ( ) ) . cell ( NAME , tunnel . tunnelName ( ) . value ( ) ) . cell ( ONE , tunnel . src ( ) ) . cell ( TWO , tunnel . dst ( ) ) . cell ( TYPE , tunnel . type ( ) ) . cell ( GROUP_ID , tunnel . groupId ( ) . id ( ) ) . cell ( BANDWIDTH , tunnel . annotations ( ) . value ( BANDWIDTH ) ) . cell ( PATH , tunnel . path ( ) ) ; }
@ Before public void startup ( ) { server = ApnsUtils . prepareAndStartServer ( TestConstants . TEST_GATEWAY_PORT , TestConstants . TEST_FEEDBACK_PORT ) ; }
@ After public void stop ( ) { server . stop ( ) ; }
@ Test ( timeout = 5000 ) public void testProducer ( ) throws Exception { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 1 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : test " , message ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; }
@ Test ( timeout = 5000 ) public void testProducerWithApnsNotification ( ) throws InterruptedException { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; final EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 14 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : testWithApnsNotification " , apnsNotification ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; }
protected CamelContext createCamelContext ( ) throws Exception { CamelContext camelContext = super . createCamelContext ( ) ; ApnsServiceFactory apnsServiceFactory = ApnsUtils . createDefaultTestConfiguration ( camelContext ) ; ApnsService apnsService = apnsServiceFactory . getApnsService ( ) ; ApnsComponent apnsComponent = new ApnsComponent ( apnsService ) ; camelContext . addComponent ( " apns " , apnsComponent ) ; return camelContext ; }
protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : test " ) . setHeader ( ApnsConstants . HEADER_TOKENS , constant ( FAKE_TOKEN ) ) . to ( " apns : notify " ) ; from ( " direct : testWithApnsNotification " ) . setHeader ( ApnsConstants . HEADER_MESSAGE_TYPE , constant ( MessageType . APNS_NOTIFICATION . name ( ) ) ) . to ( " apns : notify " ) ; } } ; }
@ DataBoundConstructor public ListView ( String name ) { super ( name ) ; initColumns ( ) ; initJobFilters ( ) ; }
public ListView ( String name , ViewGroup owner ) { this ( name ) ; this . owner = owner ; }
private Object readResolve ( ) { if ( includeRegex != null ) { try { includePattern = Pattern . compile ( includeRegex ) ; } catch ( PatternSyntaxException x ) { includeRegex = null ; OldDataMonitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( jobNames == null ) { jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; } initColumns ( ) ; initJobFilters ( ) ; return this ; }
protected void initColumns ( ) { if ( columns == null ) columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this , ListViewColumn . createDefaultInitialColumnList ( ) ) ; }
protected void initJobFilters ( ) { if ( jobFilters == null ) jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; }
public boolean hasJobFilterExtensions ( ) { return ! ViewJobFilter . all ( ) . isEmpty ( ) ; }
public DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > getJobFilters ( ) { return jobFilters ; }
public DescribableList < ListViewColumn , Descriptor < ListViewColumn > > getColumns ( ) { return columns ; }
public List < TopLevelItem > getItems ( ) { SortedSet < String > names ; List < TopLevelItem > items = new ArrayList < TopLevelItem > ( ) ; synchronized ( this ) { names = new TreeSet < String > ( jobNames ) ; } ItemGroup < ? extends TopLevelItem > parent = getOwnerItemGroup ( ) ; List < TopLevelItem > parentItems = new ArrayList < TopLevelItem > ( parent . getItems ( ) ) ; includeItems ( parent , parentItems , names ) ; Boolean statusFilter = this . statusFilter ; Iterable < ? extends TopLevelItem > candidates ; if ( recurse ) { candidates = Items . getAllItems ( parent , TopLevelItem . class ) ; } else { candidates = parent . getItems ( ) ; } for ( TopLevelItem item : candidates ) { if ( ! names . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ) continue ; if ( statusFilter == null || ! ( item instanceof AbstractProject ) || ( ( AbstractProject ) item ) . isDisabled ( ) ^ statusFilter ) items . add ( item ) ; } Iterable < ViewJobFilter > jobFilters = getJobFilters ( ) ; List < TopLevelItem > allItems = new ArrayList < TopLevelItem > ( parentItems ) ; if ( recurse ) allItems = expand ( allItems , new ArrayList < TopLevelItem > ( ) ) ; for ( ViewJobFilter jobFilter : jobFilters ) { items = jobFilter . filter ( items , allItems , this ) ; } items = new ArrayList < TopLevelItem > ( new LinkedHashSet < TopLevelItem > ( items ) ) ; return items ; }
private List < TopLevelItem > expand ( Collection < TopLevelItem > items , List < TopLevelItem > allItems ) { for ( TopLevelItem item : items ) { if ( item instanceof ItemGroup ) { ItemGroup < ? extends Item > ig = ( ItemGroup < ? extends Item > ) item ; expand ( Util . filter ( ig . getItems ( ) , TopLevelItem . class ) , allItems ) ; } allItems . add ( item ) ; } return allItems ; }
public boolean contains ( TopLevelItem item ) { return getItems ( ) . contains ( item ) ; }
private void includeItems ( ItemGroup < ? extends TopLevelItem > root , Collection < ? extends Item > parentItems , SortedSet < String > names ) { if ( includePattern != null ) { for ( Item item : parentItems ) { if ( recurse && item instanceof ItemGroup ) { ItemGroup < ? > ig = ( ItemGroup < ? > ) item ; includeItems ( root , ig . getItems ( ) , names ) ; } if ( item instanceof TopLevelItem ) { String itemName = item . getRelativeNameFrom ( root ) ; if ( includePattern . matcher ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } }
public synchronized boolean jobNamesContains ( TopLevelItem item ) { if ( item == null ) return false ; return jobNames . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; }
public void add ( TopLevelItem item ) throws IOException { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } save ( ) ; }
public boolean remove ( TopLevelItem item ) throws IOException { synchronized ( this ) { String name = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( ! jobNames . remove ( name ) ) return false ; } save ( ) ; return true ; }
public String getIncludeRegex ( ) { return includeRegex ; }
public boolean isRecurse ( ) { return recurse ; }
public void setRecurse ( boolean recurse ) { this . recurse = recurse ; }
public Boolean getStatusFilter ( ) { return statusFilter ; }
if ( ig instanceof ModifiableItemGroup ) { TopLevelItem item = ( ( ModifiableItemGroup < ? extends TopLevelItem > ) ig ) . doCreateItem ( req , rsp ) ; if ( item != null ) { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } owner . save ( ) ; } return item ; }
private TopLevelItem resolveName ( String name ) { TopLevelItem item = getOwnerItemGroup ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( getOwnerItemGroup ( ) , name ) ; item = Jenkins . getInstance ( ) . getItemByFullName ( name , TopLevelItem . class ) ; } return item ; }
synchronized ( this ) { recurse = json . optBoolean ( " recurse " , true ) ; jobNames . clear ( ) ; Iterable < ? extends TopLevelItem > items ; if ( recurse ) { items = Items . getAllItems ( getOwnerItemGroup ( ) , TopLevelItem . class ) ; } else { items = getOwnerItemGroup ( ) . getItems ( ) ; } for ( TopLevelItem item : items ) { String relativeNameFrom = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( req . getParameter ( relativeNameFrom ) != null ) { jobNames . add ( relativeNameFrom ) ; } } }
if ( columns == null ) { columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this ) ; }
if ( jobFilters == null ) { jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; }
public void setIncludeRegex ( String includeRegex ) { this . includeRegex = Util . nullify ( includeRegex ) ; if ( this . includeRegex == null ) this . includePattern = null ; else this . includePattern = Pattern . compile ( includeRegex ) ; }
public String getDisplayName ( ) { return Messages . ListView_DisplayName ( ) ; }
if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( PatternSyntaxException pse ) { return FormValidation . error ( pse . getMessage ( ) ) ; } }
public void onLocationChanged ( final Item item , final String oldFullName , final String newFullName ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { locationChanged ( item , oldFullName , newFullName ) ; } } ) ; }
private void locationChanged ( Item item , String oldFullName , String newFullName ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { renameViewItem ( oldFullName , newFullName , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { renameViewItem ( oldFullName , newFullName , vg , ( ListView ) v ) ; } } } } }
private void renameViewItem ( String oldFullName , String newFullName , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { Set < String > oldJobNames = new HashSet < String > ( lv . jobNames ) ; lv . jobNames . clear ( ) ; for ( String oldName : oldJobNames ) { lv . jobNames . add ( Items . computeRelativeNamesAfterRenaming ( oldFullName , newFullName , oldName , vg . getItemGroup ( ) ) ) ; } needsSave = ! oldJobNames . equals ( lv . jobNames ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } }
public void onDeleted ( final Item item ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { deleted ( item ) ; } } ) ; }
private void deleted ( Item item ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { deleteViewItem ( item , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { deleteViewItem ( item , vg , ( ListView ) v ) ; } } } } }
private void deleteViewItem ( Item item , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { needsSave = lv . jobNames . remove ( item . getRelativeNameFrom ( vg . getItemGroup ( ) ) ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } }
