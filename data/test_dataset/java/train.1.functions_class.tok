public Paper ( double wt ) { super ( wt ) ; }
public double value ( ) { return val ; }
public NodeTest ( ) { }
@ Test public void testConstructor ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( 1 , node . getX ( ) ) ; assertEquals ( 2 , node . getY ( ) ) ; assertEquals ( new Point ( 1 , 2 ) , node . getPoint ( ) ) ; assertEquals ( Float . MAX_VALUE , node . getStartDistance ( ) , 0.001f ) ; assertEquals ( 0.0f , node . getGoalDistance ( ) , 0.001f ) ; }
@ Test public void testCompareTo ( ) { final Node node1 = new Node ( 0 , 0 ) ; final Node node2 = new Node ( 0 , 0 ) ; node1 . setStartDistance ( 1.0f ) ; node1 . setGoalDistance ( 2.0f ) ; node2 . setStartDistance ( 2.0f ) ; node2 . setGoalDistance ( 1.0f ) ; assertEquals ( 0 , node1 . compareTo ( node2 ) ) ; node2 . setGoalDistance ( 3.0f ) ; assertEquals ( - 1 , node1 . compareTo ( node2 ) ) ; }
@ Test public void testToString ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( " ( 1 , ▁ 2 ) " , node . toString ( ) ) ; }
public CommandReplyMessage ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; }
public boolean isSuccess ( ) { if ( replyBytes . length < 10 ) { return false ; } return replyBytes [ 1 ] == 0 ; }
public InetAddress getIp ( ) throws UnknownHostException { byte [ ] addressBytes = null ; if ( replyBytes [ 3 ] == AddressType . IPV4 ) { addressBytes = new byte [ 4 ] ; } else if ( replyBytes [ 3 ] == AddressType . IPV6 ) { addressBytes = new byte [ 16 ] ; } System . arraycopy ( replyBytes , 4 , addressBytes , 0 , addressBytes . length ) ; return InetAddress . getByAddress ( addressBytes ) ; }
public int getPort ( ) { return SocksUtil . bytesToInt ( replyBytes [ replyBytes . length - 2 ] , replyBytes [ replyBytes . length - 1 ] ) ; }
public byte [ ] getReplyBytes ( ) { return replyBytes ; }
public void setReplyBytes ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; }
public SocketAddress getSocketAddress ( ) { try { return new InetSocketAddress ( getIp ( ) , getPort ( ) ) ; } catch ( UnknownHostException e ) { logger . error ( e . getMessage ( ) , e ) ; } return null ; }
public void startTime ( ) throws IOException { startTimeEpoch = System . currentTimeMillis ( ) ; }
public void stopTime ( ) throws IOException { finishTimeEpoch = System . currentTimeMillis ( ) ; }
public long getIntervalMillis ( ) throws IOException { return finishTimeEpoch - startTimeEpoch ; }
public void printlnWithTimestamp ( String message ) throws IOException { System . out . println ( formatCurrentTime ( ) + " ▁ ▁ " + message ) ; }
public String formatTime ( long millis ) { return formatter . format ( millis ) ; }
public String getIntervalString ( ) throws IOException { long time = getIntervalMillis ( ) ; return formatTime ( time ) ; }
public String formatCurrentTime ( ) { return formatTime ( System . currentTimeMillis ( ) ) ; }
public void visitAnyInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , Instruction instruction ) { }
public void visitConstantInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , ConstantInstruction constantInstruction ) { if ( constantInstruction . opcode == InstructionConstants . OP_INSTANCEOF ) { clazz . constantPoolEntryAccept ( constantInstruction . constantIndex , this ) ; } }
public void visitClassConstant ( Clazz clazz , ClassConstant classConstant ) { classConstant . referencedClassAccept ( this ) ; }
public void visitLibraryClass ( LibraryClass libraryClass ) { }
public void visitProgramClass ( ProgramClass programClass ) { setInstanceofed ( programClass ) ; }
public void start ( ) throws JMSException { String selector = " next ▁ = ▁ ' " + myId + " ' " ; try { ConnectionFactory factory = template . getConnectionFactory ( ) ; final Connection c = connection = factory . createConnection ( ) ; synchronized ( c ) { if ( c . getClientID ( ) == null ) { c . setClientID ( myId ) ; } } connection . start ( ) ; session = connection . createSession ( true , Session . CLIENT_ACKNOWLEDGE ) ; consumer = session . createConsumer ( destination , selector , false ) ; consumer . setMessageListener ( this ) ; } catch ( JMSException ex ) { LOG . error ( " " , ex ) ; throw ex ; } }
public void stop ( ) throws JMSException { if ( consumer != null ) { consumer . close ( ) ; } if ( session != null ) { session . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } }
public void onMessage ( Message message ) { super . onMessage ( message ) ; try { message . acknowledge ( ) ; } catch ( JMSException e ) { LOG . error ( " Failed ▁ to ▁ acknowledge : ▁ " + e , e ) ; } }
public Destination getDestination ( ) { return destination ; }
public void setDestination ( Destination destination ) { this . destination = destination ; }
public String getMyId ( ) { return myId ; }
public void setMyId ( String myId ) { this . myId = myId ; }
public JmsTemplate getTemplate ( ) { return template ; }
public void setTemplate ( JmsTemplate template ) { this . template = template ; }
public ReplicatedContainer ( Container preferred , List < Container > otherContainers ) { this . preferred = preferred ; this . otherContainers = otherContainers ; }
public String getName ( ) { return null ; }
public List < Storable > listStorables ( ) throws StorageException { return null ; }
public Storable uploadStorable ( File file ) throws StorageException { return null ; }
public Storable uploadStorable ( String name , File file ) throws StorageException { return null ; }
public Storable uploadStorable ( String name , InputStream stream , String mimeType ) throws StorageException { return null ; }
public void deleteStorable ( String name ) throws StorageException { }
