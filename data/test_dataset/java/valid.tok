<DOCUMENT_ID="pentaho/pentaho-kettle/tree/master/core/src/main/java/org/pentaho/di/core/Props.java"> package org . pentaho . di . core ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; import java . util . Properties ; import org . pentaho . di . core . exception . KettleValueException ; import org . pentaho . di . core . logging . LogChannel ; import org . pentaho . di . core . logging . LogChannelInterface ; import org . pentaho . di . core . row . ValueMetaInterface ; import org . pentaho . di . core . util . SortedFileOutputStream ; import org . pentaho . di . i18n . BaseMessages ; public class Props implements Cloneable { private static Class < ? > PKG = Const . class ; private static final String STRING_USER_PREFERENCES = " User ▁ preferences " ; protected static Props props ; public static final String STRING_FONT_FIXED_NAME = " FontFixedName " ; public static final String STRING_FONT_FIXED_SIZE = " FontFixedSize " ; public static final String STRING_FONT_FIXED_STYLE = " FontFixedStyle " ; public static final String STRING_FONT_DEFAULT_NAME = " FontDefaultName " ; public static final String STRING_FONT_DEFAULT_SIZE = " FontDefaultSize " ; public static final String STRING_FONT_DEFAULT_STYLE = " FontDefaultStyle " ; public static final String STRING_FONT_GRAPH_NAME = " FontGraphName " ; public static final String STRING_FONT_GRAPH_SIZE = " FontGraphSize " ; public static final String STRING_FONT_GRAPH_STYLE = " FontGraphStyle " ; public static final String STRING_FONT_GRID_NAME = " FontGridName " ; public static final String STRING_FONT_GRID_SIZE = " FontGridSize " ; public static final String STRING_FONT_GRID_STYLE = " FontGridStyle " ; public static final String STRING_FONT_NOTE_NAME = " FontNoteName " ; public static final String STRING_FONT_NOTE_SIZE = " FontNoteSize " ; public static final String STRING_FONT_NOTE_STYLE = " FontNoteStyle " ; public static final String STRING_BACKGROUND_COLOR_R = " BackgroundColorR " ; public static final String STRING_BACKGROUND_COLOR_G = " BackgroundColorG " ; public static final String STRING_BACKGROUND_COLOR_B = " BackgroundColorB " ; public static final String STRING_GRAPH_COLOR_R = " GraphColorR " ; public static final String STRING_GRAPH_COLOR_G = " GraphColorG " ; public static final String STRING_GRAPH_COLOR_B = " GraphColorB " ; public static final String STRING_TAB_COLOR_R = " TabColorR54" ; public static final String STRING_TAB_COLOR_G = " TabColorG54" ; public static final String STRING_TAB_COLOR_B = " TabColorB54" ; public static final String STRING_SVG_ENABLED = " EnableSVG " ; public static final String STRING_ICON_SIZE = " IconSize " ; public static final String STRING_LINE_WIDTH = " LineWidth " ; public static final String STRING_SHADOW_SIZE = " ShadowSize54" ; public static final String STRING_LOG_LEVEL = " LogLevel " ; public static final String STRING_LOG_FILTER = " LogFilter " ; public static final String STRING_MIDDLE_PCT = " MiddlePct " ; public static final String STRING_INDICATE_SLOW_TRANS_STEPS = " IndicateSlowTransSteps " ; public static final String STRING_LAST_PREVIEW_TRANS = " LastPreviewTrans " ; public static final String STRING_LAST_PREVIEW_STEP = " LastPreviewStep " ; public static final String STRING_LAST_PREVIEW_SIZE = " LastPreviewSize " ; public static final String STRING_MAX_UNDO = " MaxUndo " ; public static final String STRING_SIZE_MAX = " SizeMax " ; public static final String STRING_SIZE_X = " SizeX " ; public static final String STRING_SIZE_Y = " SizeY " ; public static final String STRING_SIZE_W = " SizeW " ; public static final String STRING_SIZE_H = " SizeH " ; public static final String STRING_SASH_W1 = " SashWeight1" ; public static final String STRING_SASH_W2 = " SashWeight2" ; public static final String STRING_AUTO_SAVE = " AutoSave " ; public static final String STRING_SAVE_CONF = " SaveConfirmation " ; public static final String STRING_AUTO_SPLIT = " AutoSplit " ; public static final String STRING_AUTO_COLLAPSE_CORE_TREE = " AutoCollapseCoreObjectsTree " ; public static final String STRING_USE_DB_CACHE = " UseDBCache " ; public static final String STRING_OPEN_LAST_FILE = " OpenLastFile " ; public static final String STRING_LAST_REPOSITORY_LOGIN = " RepositoryLastLogin " ; public static final String STRING_LAST_REPOSITORY = " RepositoryLast " ; public static final String STRING_ONLY_ACTIVE_STEPS = " OnlyActiveSteps " ; public static final String STRING_START_SHOW_REPOSITORIES = " ShowRepositoriesAtStartup " ; public static final String STRING_ANTI_ALIASING = " EnableAntiAliasing54" ; public static final String STRING_SHOW_CANVAS_GRID = " ShowCanvasGrid " ; public static final String STRING_SHOW_EXIT_WARNING = " ShowExitWarning " ; public static final String STRING_SHOW_OS_LOOK = " ShowOSLook54" ; public static final String STRING_LAST_ARGUMENT = " LastArgument " ; public static final String STRING_ARGUMENT_NAME_PREFIX = " Argument ▁ " ; public static final String STRING_CUSTOM_PARAMETER = " CustomParameter " ; public static final String STRING_PLUGIN_HISTORY = " PluginHistory " ; public static final String STRING_DEFAULT_PREVIEW_SIZE = " DefaultPreviewSize " ; public static final String STRING_ONLY_USED_DB_TO_XML = " SaveOnlyUsedConnectionsToXML " ; public static final String STRING_ASK_ABOUT_REPLACING_DATABASES = " AskAboutReplacingDatabases " ; public static final String STRING_REPLACE_DATABASES = " ReplaceDatabases " ; private static final String STRING_MAX_NR_LINES_IN_LOG = " MaxNrOfLinesInLog " ; private static final String STRING_MAX_NR_LINES_IN_HISTORY = " MaxNrOfLinesInHistory " ; private static final String STRING_LINES_IN_HISTORY_FETCH_SIZE = " LinesInHistoryFetchSize " ; public static final String STRING_DISABLE_INITIAL_EXECUTION_HISTORY = " DisableInitialExecutionHistory " ; private static final String STRING_MAX_LOG_LINE_TIMEOUT_MINUTES = " MaxLogLineTimeOutMinutes " ; public static final String STRING_RECENT_SEARCHES = " RecentSearches " ; public static final String STRING_SHOW_NEW_SUBTRANS_POPUP = " ShowNewSubtransPopup " ; protected LogChannelInterface log ; protected Properties properties ; protected ArrayList < ObjectUsageCount > pluginHistory ; protected int type ; protected String filename ; public static final int TYPE_PROPERTIES_EMPTY = 0 ; public static final int TYPE_PROPERTIES_SPOON = 1 ; public static final int TYPE_PROPERTIES_PAN = 2 ; public static final int TYPE_PROPERTIES_CHEF = 3 ; public static final int TYPE_PROPERTIES_KITCHEN = 4 ; public static final int TYPE_PROPERTIES_MENU = 5 ; public static final int TYPE_PROPERTIES_PLATE = 6 ; public static final int WIDGET_STYLE_DEFAULT = 0 ; public static final int WIDGET_STYLE_FIXED = 1 ; public static final int WIDGET_STYLE_TABLE = 2 ; public static final int WIDGET_STYLE_NOTEPAD = 3 ; public static final int WIDGET_STYLE_GRAPH = 4 ; public static final int WIDGET_STYLE_TAB = 5 ; public static final int WIDGET_STYLE_TOOLBAR = 6 ; public static final void init ( int t ) { if ( props == null ) { props = new Props ( t ) ; } else { throw new RuntimeException ( " The ▁ Properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } public static final void init ( String filename ) { if ( props == null ) { props = new Props ( filename ) ; } else { throw new RuntimeException ( " The ▁ properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } public static boolean isInitialized ( ) { return props != null ; } public static Props getInstance ( ) { if ( props != null ) { return props ; } throw new RuntimeException ( " Properties , ▁ Kettle ▁ systems ▁ settings , ▁ not ▁ initialised ! " ) ; } protected Props ( ) { init ( ) ; } protected Props ( int t ) { type = t ; filename = getFilename ( ) ; init ( ) ; } protected void init ( ) { createLogChannel ( ) ; properties = new Properties ( ) ; pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; loadProps ( ) ; addDefaultEntries ( ) ; loadPluginHistory ( ) ; } protected Props ( String filename ) { properties = new Properties ( ) ; this . type = TYPE_PROPERTIES_EMPTY ; this . filename = filename ; init ( ) ; } @ Override public String toString ( ) { return STRING_USER_PREFERENCES ; } protected void createLogChannel ( ) { log = new LogChannel ( STRING_USER_PREFERENCES ) ; } public String getFilename ( ) { String filename = " " ; String directory = Const . getKettleDirectory ( ) ; switch ( type ) { case TYPE_PROPERTIES_SPOON : case TYPE_PROPERTIES_PAN : filename = directory + Const . FILE_SEPARATOR + " . spoonrc " ; break ; case TYPE_PROPERTIES_CHEF : case TYPE_PROPERTIES_KITCHEN : filename = directory + Const . FILE_SEPARATOR + " . chefrc " ; break ; case TYPE_PROPERTIES_MENU : filename = directory + Const . FILE_SEPARATOR + " . menurc " ; break ; case TYPE_PROPERTIES_PLATE : filename = directory + Const . FILE_SEPARATOR + " . platerc " ; break ; default : break ; } return filename ; } public String getLicenseFilename ( ) { String directory = Const . getKettleDirectory ( ) ; String filename = directory + Const . FILE_SEPARATOR + " . licence " ; File dir = new File ( directory ) ; if ( ! dir . exists ( ) ) { try { dir . mkdirs ( ) ; } catch ( Exception e ) { } } return filename ; } public boolean fileExists ( ) { File f = new File ( filename ) ; return f . exists ( ) ; } public void setType ( int t ) { type = t ; } public int getType ( ) { return type ; } public boolean loadProps ( ) { try { FileInputStream fis = new FileInputStream ( filename ) ; try { properties . load ( fis ) ; } finally { try { fis . close ( ) ; } catch ( IOException ignored ) { } } } catch ( Exception e ) { return false ; } return true ; } protected void addDefaultEntries ( ) { if ( ! properties . containsKey ( " JobDialogStyle " ) ) { properties . setProperty ( " JobDialogStyle " , " RESIZE , MAX , MIN " ) ; } } public void saveProps ( ) { File spoonRc = new File ( filename ) ; try { SortedFileOutputStream fos = new SortedFileOutputStream ( spoonRc ) ; fos . setLogger ( log ) ; properties . store ( fos , " Kettle ▁ Properties ▁ file " ) ; fos . close ( ) ; log . logDetailed ( BaseMessages . getString ( PKG , " Spoon . Log . SaveProperties " ) ) ; } catch ( IOException e ) { if ( spoonRc . isHidden ( ) && filename . indexOf ( ' \\ ' ) != - 1 ) { log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailedWindowsBugAttr " , filename ) ) ; } else { log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailed " ) + e . getMessage ( ) ) ; } } } public void setLogLevel ( String level ) { properties . setProperty ( STRING_LOG_LEVEL , level ) ; } public String getLogLevel ( ) { String level = properties . getProperty ( STRING_LOG_LEVEL , " Basic " ) ; return level ; } public void setLogFilter ( String filter ) { properties . setProperty ( STRING_LOG_FILTER , Const . NVL ( filter , " " ) ) ; } public String getLogFilter ( ) { String level = properties . getProperty ( STRING_LOG_FILTER , " " ) ; return level ; } public void setUseDBCache ( boolean use ) { properties . setProperty ( STRING_USE_DB_CACHE , use ? " Y " : " N " ) ; } public boolean useDBCache ( ) { String use = properties . getProperty ( STRING_USE_DB_CACHE ) ; return ! " N " . equalsIgnoreCase ( use ) ; } public void setLastRepository ( String repname ) { properties . setProperty ( STRING_LAST_REPOSITORY , repname ) ; } public String getLastRepository ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY ) ; } public void setLastRepositoryLogin ( String login ) { properties . setProperty ( STRING_LAST_REPOSITORY_LOGIN , login ) ; } public String getLastRepositoryLogin ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY_LOGIN ) ; } public void setOnlyActiveSteps ( boolean only ) { properties . setProperty ( STRING_ONLY_ACTIVE_STEPS , only ? " Y " : " N " ) ; } public boolean getOnlyActiveSteps ( ) { String only = properties . getProperty ( STRING_ONLY_ACTIVE_STEPS , " N " ) ; return " Y " . equalsIgnoreCase ( only ) ; } public boolean askAboutReplacingDatabaseConnections ( ) { String ask = properties . getProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , " N " ) ; return " Y " . equalsIgnoreCase ( ask ) ; } public void setProperty ( String propertyName , String value ) { properties . setProperty ( propertyName , value ) ; } public String getProperty ( String propertyName ) { return properties . getProperty ( propertyName ) ; } public void setAskAboutReplacingDatabaseConnections ( boolean ask ) { properties . setProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , ask ? " Y " : " N " ) ; } public String getCustomParameter ( String parameterName , String defaultValue ) { return properties . getProperty ( STRING_CUSTOM_PARAMETER + parameterName , defaultValue ) ; } public void setCustomParameter ( String parameterName , String value ) { properties . setProperty ( STRING_CUSTOM_PARAMETER + parameterName , value ) ; } public void clearCustomParameters ( ) { Enumeration < Object > keys = properties . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; if ( key . startsWith ( STRING_CUSTOM_PARAMETER ) ) { properties . remove ( key ) ; } } } public static final int getArgumentNumber ( ValueMetaInterface value ) { if ( value != null && value . getName ( ) . startsWith ( Props . STRING_ARGUMENT_NAME_PREFIX ) ) { return Const . toInt ( value . getName ( ) . substring ( Props . STRING_ARGUMENT_NAME_PREFIX . length ( ) ) , - 1 ) ; } return - 1 ; } public static final String [ ] convertArguments ( RowMetaAndData row ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < row . size ( ) ; i ++ ) { ValueMetaInterface valueMeta = row . getValueMeta ( i ) ; int argNr = getArgumentNumber ( valueMeta ) ; if ( argNr >= 0 && argNr < 10 ) { try { args [ argNr ] = row . getString ( i , " " ) ; } catch ( KettleValueException e ) { args [ argNr ] = " " ; } } } return args ; } public void setLastArguments ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] != null ) { properties . setProperty ( STRING_LAST_ARGUMENT + " _ " + i , args [ i ] ) ; } } } public String [ ] getLastArguments ( ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = properties . getProperty ( STRING_LAST_ARGUMENT + " _ " + i ) ; } return args ; } public List < ObjectUsageCount > getPluginHistory ( ) { return pluginHistory ; } public int increasePluginHistory ( String pluginID ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; if ( usage . getObjectName ( ) . equalsIgnoreCase ( pluginID ) ) { int uses = usage . increment ( ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return uses ; } } addPluginHistory ( pluginID , 1 ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return 1 ; } public void addPluginHistory ( String pluginID , int uses ) { pluginHistory . add ( new ObjectUsageCount ( pluginID , uses ) ) ; } protected void loadPluginHistory ( ) { pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; int i = 0 ; String string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; while ( string != null ) { pluginHistory . add ( ObjectUsageCount . fromString ( string ) ) ; i ++ ; string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; } Collections . sort ( pluginHistory ) ; } private void savePluginHistory ( ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; properties . setProperty ( STRING_PLUGIN_HISTORY + " _ " + i , usage . toString ( ) ) ; } } public boolean areOnlyUsedConnectionsSavedToXML ( ) { String show = properties . getProperty ( STRING_ONLY_USED_DB_TO_XML , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; } public void setOnlyUsedConnectionsSavedToXML ( boolean onlyUsedConnections ) { properties . setProperty ( STRING_ONLY_USED_DB_TO_XML , onlyUsedConnections ? " Y " : " N " ) ; } public boolean replaceExistingDatabaseConnections ( ) { String replace = properties . getProperty ( STRING_REPLACE_DATABASES , " Y " ) ; return " Y " . equalsIgnoreCase ( replace ) ; } public void setReplaceDatabaseConnections ( boolean replace ) { properties . setProperty ( STRING_REPLACE_DATABASES , replace ? " Y " : " N " ) ; } public boolean showNewSubtransPopup ( ) { String show = properties . getProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; } public void setShowNewSubtransPopup ( boolean show ) { properties . setProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , show ? " Y " : " N " ) ; } public int getMaxNrLinesInLog ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_LOG ) ; return Const . toInt ( lines , Const . MAX_NR_LOG_LINES ) ; } public void setMaxNrLinesInLog ( int maxNrLinesInLog ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_LOG , Integer . toString ( maxNrLinesInLog ) ) ; } public int getMaxNrLinesInHistory ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_HISTORY ) ; return Const . toInt ( lines , Const . MAX_NR_HISTORY_LINES ) ; } public int getLinesInHistoryFetchSize ( ) { String fetchSize = properties . getProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE ) ; return Const . toInt ( fetchSize , Const . HISTORY_LINES_FETCH_SIZE ) ; } public boolean disableInitialExecutionHistory ( ) { String disable = properties . getProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , " N " ) ; return " Y " . equalsIgnoreCase ( disable ) ; } public void setMaxNrLinesInHistory ( int maxNrLinesInHistory ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_HISTORY , Integer . toString ( maxNrLinesInHistory ) ) ; } public void setLinesInHistoryFetchSize ( int linesInHistoryFetchSize ) { properties . setProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE , Integer . toString ( linesInHistoryFetchSize ) ) ; } public void setDisableInitialExecutionHistory ( boolean disable ) { properties . setProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , disable ? " Y " : " N " ) ; } public int getMaxLogLineTimeoutMinutes ( ) { String minutes = properties . getProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES ) ; return Const . toInt ( minutes , Const . MAX_LOG_LINE_TIMEOUT_MINUTES ) ; } public void setMaxLogLineTimeoutMinutes ( int maxLogLineTimeoutMinutes ) { properties . setProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES , Integer . toString ( maxLogLineTimeoutMinutes ) ) ; } public void reset ( ) { props = null ; properties . clear ( ) ; pluginHistory . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="clintjhill/saguaro/tree/master/src/com/stoneworks/BrickCanvasConverter.java"> package com . stoneworks ; import com . thoughtworks . xstream . converters . Converter ; import com . thoughtworks . xstream . converters . MarshallingContext ; import com . thoughtworks . xstream . converters . UnmarshallingContext ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; public class BrickCanvasConverter implements Converter { public BrickCanvasConverter ( ) { } public boolean canConvert ( Class type ) { return ( type == BrickCanvas . class ) ; } public void marshal ( Object source , HierarchicalStreamWriter writer , MarshallingContext context ) { BrickCanvas canvas = ( BrickCanvas ) source ; writer . startNode ( " canvasBackgroundImage " ) ; context . convertAnother ( canvas . getBackgroundImage ( ) ) ; writer . endNode ( ) ; writer . startNode ( " bricksOnCanvas " ) ; for ( Object obj : canvas . getBricks ( ) ) { if ( obj instanceof Brick ) { writer . startNode ( obj . getClass ( ) . getName ( ) ) ; context . convertAnother ( obj ) ; writer . endNode ( ) ; } } writer . endNode ( ) ; } public Object unmarshal ( HierarchicalStreamReader reader , UnmarshallingContext context ) { BrickCanvas canvas = BrickCanvas . getInstance ( ) ; while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( " canvasBackgroundImage " ) ) { canvas . setBackgroundImage ( ( BackgroundImage ) context . convertAnother ( reader , BackgroundImage . class ) ) ; } if ( reader . getNodeName ( ) . equals ( " bricksOnCanvas " ) ) { while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( Brick . class . getName ( ) ) ) { canvas . getLayer ( ) . addChild ( ( Brick ) context . convertAnother ( reader , Brick . class ) ) ; } reader . moveUp ( ) ; } } reader . moveUp ( ) ; } return canvas ; } } </DOCUMENT>
<DOCUMENT_ID="da1z/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="avasilevskiy/presto/tree/master/presto-raptor/src/main/java/com/facebook/presto/raptor/metadata/ShardNodes.java"> package com . facebook . presto . raptor . metadata ; import com . google . common . collect . ImmutableSet ; import java . util . Objects ; import java . util . Set ; import java . util . UUID ; import static com . google . common . base . MoreObjects . toStringHelper ; import static com . google . common . base . Preconditions . checkNotNull ; public class ShardNodes { private final UUID shardUuid ; private final Set < String > nodeIdentifiers ; public ShardNodes ( UUID shardUuid , Set < String > nodeIdentifiers ) { this . shardUuid = checkNotNull ( shardUuid , " shardUuid ▁ is ▁ null " ) ; this . nodeIdentifiers = ImmutableSet . copyOf ( checkNotNull ( nodeIdentifiers , " nodeIdentifiers ▁ is ▁ null " ) ) ; } public UUID getShardUuid ( ) { return shardUuid ; } public Set < String > getNodeIdentifiers ( ) { return nodeIdentifiers ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } ShardNodes other = ( ShardNodes ) obj ; return Objects . equals ( this . shardUuid , other . shardUuid ) && Objects . equals ( this . nodeIdentifiers , other . nodeIdentifiers ) ; } @ Override public int hashCode ( ) { return Objects . hash ( shardUuid , nodeIdentifiers ) ; } @ Override public String toString ( ) { return toStringHelper ( this ) . add ( " shardUuid " , shardUuid ) . add ( " nodeIdentifiers " , nodeIdentifiers ) . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="1and1/aesh/tree/master/src/main/java/org/jboss/aesh/cl/builder/OptionBuilder.java"> package org . jboss . aesh . cl . builder ; import org . jboss . aesh . cl . completer . OptionCompleter ; import org . jboss . aesh . cl . converter . CLConverter ; import org . jboss . aesh . cl . exception . OptionParserException ; import org . jboss . aesh . cl . internal . OptionInt ; import org . jboss . aesh . cl . internal . OptionType ; import java . util . ArrayList ; import java . util . List ; public class OptionBuilder { private char shortName ; private String name ; private String description ; private String argument ; private Class < ? > type ; private boolean hasValue = true ; private boolean required = false ; private boolean isProperty = false ; private boolean hasMultipleValues = false ; private char valueSeparator = ' , ' ; private OptionType optionType ; private Class < ? extends CLConverter > converter ; private String fieldName ; private OptionCompleter completer ; private List < String > defaultValues ; public OptionBuilder ( ) { defaultValues = new ArrayList < String > ( ) ; } public OptionBuilder shortName ( char n ) { shortName = n ; return this ; } public OptionBuilder name ( String name ) { this . name = name ; return this ; } public OptionBuilder description ( String description ) { this . description = description ; return this ; } public OptionBuilder argument ( String argument ) { this . argument = argument ; return this ; } public OptionBuilder type ( Class < ? > type ) { this . type = type ; return this ; } public OptionBuilder required ( boolean required ) { this . required = required ; return this ; } public OptionBuilder fieldName ( String fieldName ) { this . fieldName = fieldName ; return this ; } public OptionBuilder hasValue ( boolean hasValue ) { this . hasValue = hasValue ; return this ; } public OptionBuilder isProperty ( boolean isProperty ) { this . isProperty = isProperty ; return this ; } public OptionBuilder hasMultipleValues ( boolean hasMultipleValues ) { this . hasMultipleValues = hasMultipleValues ; return this ; } public OptionBuilder addDefaultValue ( String defaultValue ) { this . defaultValues . add ( defaultValue ) ; return this ; } public OptionBuilder valueSeparator ( char valueSeparator ) { this . valueSeparator = valueSeparator ; return this ; } public OptionBuilder optionType ( OptionType optionType ) { this . optionType = optionType ; return this ; } public OptionBuilder converter ( Class < ? extends CLConverter > converter ) { this . converter = converter ; return this ; } public OptionBuilder completer ( OptionCompleter completer ) { this . completer = completer ; return this ; } public OptionInt create ( ) throws OptionParserException { if ( optionType == null ) { if ( ! hasValue ) optionType = OptionType . BOOLEAN ; else if ( isProperty ) optionType = OptionType . GROUP ; else if ( hasMultipleValues ) optionType = OptionType . LIST ; else optionType = OptionType . NORMAL ; } if ( name == null || ( name . length ( ) < 1 && optionType != OptionType . ARGUMENT ) ) { if ( fieldName == null || fieldName . length ( ) < 1 ) throw new OptionParserException ( " Name ▁ must ▁ be ▁ defined ▁ to ▁ create ▁ an ▁ Option " ) ; else name = fieldName ; } return new OptionInt ( shortName , name , description , argument , required , valueSeparator , defaultValues , type , fieldName , optionType , converter , completer ) ; } } </DOCUMENT>
<DOCUMENT_ID="ptupitsyn/ignite/tree/master/modules/core/src/test/java/org/apache/ignite/internal/IgniteClientRejoinTest.java"> package org . apache . ignite . internal ; import java . io . IOException ; import java . io . OutputStream ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketException ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . ignite . Ignite ; import org . apache . ignite . IgniteCache ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . IgniteClientDisconnectedException ; import org . apache . ignite . IgniteException ; import org . apache . ignite . Ignition ; import org . apache . ignite . cluster . ClusterNode ; import org . apache . ignite . configuration . IgniteConfiguration ; import org . apache . ignite . failure . AbstractFailureHandler ; import org . apache . ignite . failure . FailureContext ; import org . apache . ignite . failure . TestFailureHandler ; import org . apache . ignite . internal . util . typedef . internal . U ; import org . apache . ignite . lang . IgniteInClosure ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . spi . IgniteSpiException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutHelper ; import org . apache . ignite . spi . discovery . tcp . TcpDiscoverySpi ; import org . apache . ignite . spi . discovery . tcp . messages . TcpDiscoveryAbstractMessage ; import org . apache . ignite . testframework . GridTestUtils ; import org . apache . ignite . testframework . junits . common . GridCommonAbstractTest ; import org . junit . Test ; public class IgniteClientRejoinTest extends GridCommonAbstractTest { private volatile boolean block ; private volatile boolean blockAll ; private volatile ClusterNode crd ; private boolean clientReconnectDisabled ; @ Override protected void beforeTestsStarted ( ) throws Exception { System . setProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " , " true " ) ; } @ Override protected void afterTestsStopped ( ) throws Exception { System . clearProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " ) ; } @ Override protected void afterTest ( ) throws Exception { stopAllGrids ( ) ; } @ Override protected void beforeTest ( ) throws Exception { clientReconnectDisabled = false ; } @ Override protected IgniteConfiguration getConfiguration ( String gridName ) throws Exception { IgniteConfiguration cfg = super . getConfiguration ( gridName ) ; if ( gridName . contains ( " client " ) ) { cfg . setCommunicationSpi ( new TcpCommunicationSpi ( ) ) ; TcpDiscoverySpi spi = ( TcpDiscoverySpi ) cfg . getDiscoverySpi ( ) ; DiscoverySpi dspi = new DiscoverySpi ( ) ; dspi . setIpFinder ( spi . getIpFinder ( ) ) ; cfg . setDiscoverySpi ( dspi ) ; dspi . setJoinTimeout ( 60_000 ) ; dspi . setClientReconnectDisabled ( clientReconnectDisabled ) ; cfg . setClientMode ( true ) ; } cfg . setPeerClassLoadingEnabled ( false ) ; return cfg ; } @ Test public void testClientsReconnectAfterStart ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; List < Ignite > clientNodes = new ArrayList < > ( ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) clientNodes . add ( startGrid ( " client " + i ) ) ; blockAll = true ; GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { U . sleep ( 5_000 ) ; block = true ; blockAll = false ; System . out . println ( " > > > ▁ Allow ▁ with ▁ blocked ▁ coordinator . " ) ; latch . countDown ( ) ; return null ; } } ) ; IgniteInternalFuture < Object > fut = GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { latch . await ( ) ; U . sleep ( ( new Random ( ) . nextInt ( 15 ) + 30 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ Allow ▁ coordinator . " ) ; return null ; } } ) ; fut . get ( ) ; for ( Ignite client : clientNodes ) { while ( true ) { try { IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( " some " ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assertEquals ( ( Integer ) i , cache . get ( i ) ) ; cache . clear ( ) ; break ; } catch ( IgniteClientDisconnectedException e ) { e . reconnectFuture ( ) . get ( ) ; } } } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Test public void testClientsReconnect ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String nodeName = " client " + idx ; IgniteConfiguration cfg = getConfiguration ( nodeName ) . setFailureHandler ( new AbstractFailureHandler ( ) { @ Override protected boolean handle ( Ignite ignite , FailureContext failureCtx ) { Runtime . getRuntime ( ) . halt ( Ignition . KILL_EXIT_CODE ) ; return false ; } } ) ; return startGrid ( nodeName , optimize ( cfg ) , null ) ; } } ) ; futs . add ( fut ) ; } GridTestUtils . runAsync ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { latch . countDown ( ) ; Random rnd = new Random ( ) ; U . sleep ( ( rnd . nextInt ( 15 ) + 15 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ ALLOW ▁ connection ▁ to ▁ coordinator . " ) ; return true ; } } ) ; for ( IgniteInternalFuture < Ignite > clientFut : futs ) { Ignite client = clientFut . get ( ) ; IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( client . name ( ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assert i == cache . get ( i ) ; } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Test public void testClientsReconnectDisabled ( ) throws Exception { clientReconnectDisabled = true ; Ignite srv1 = startGrid ( " server1" ) ; if ( ! tcpDiscovery ( ) ) return ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; final CountDownLatch failureHndLatch = new CountDownLatch ( CLIENTS_NUM ) ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String igniteInstanceName = " client " + idx ; return startGrid ( igniteInstanceName , getConfiguration ( igniteInstanceName ) . setFailureHandler ( new TestFailureHandler ( true , failureHndLatch ) ) ) ; } } ) ; futs . add ( fut ) ; } latch . countDown ( ) ; for ( final IgniteInternalFuture < Ignite > clientFut : futs ) { GridTestUtils . assertThrows ( log , new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { clientFut . get ( ) ; return null ; } } , IgniteCheckedException . class , null ) ; } assertTrue ( failureHndLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 0 , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( 0 , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Override protected long getTestTimeout ( ) { return 3 * 60_000 ; } private class TcpCommunicationSpi extends org . apache . ignite . spi . communication . tcp . TcpCommunicationSpi { @ Override public void sendMessage ( ClusterNode node , Message msg ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg ) ; } @ Override public void sendMessage ( ClusterNode node , Message msg , IgniteInClosure < IgniteException > ackC ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg , ackC ) ; } } private class DiscoverySpi extends TcpDiscoverySpi { @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , byte [ ] data , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , data , timeout ) ; } @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , timeout ) ; } @ Override protected void writeToSocket ( Socket sock , OutputStream out , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , out , msg , timeout ) ; } @ Override protected void writeToSocket ( TcpDiscoveryAbstractMessage msg , Socket sock , int res , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( msg , sock , res , timeout ) ; } @ Override protected Socket openSocket ( Socket sock , InetSocketAddress remAddr , IgniteSpiOperationTimeoutHelper timeoutHelper ) throws IOException , IgniteSpiOperationTimeoutException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; return super . openSocket ( sock , remAddr , timeoutHelper ) ; } } } </DOCUMENT>
<DOCUMENT_ID="medsob/Tanaguru/tree/master/web-app/tgol-web-app/src/main/java/org/tanaguru/webapp/command/helper/UploadAuditSetUpCommandHelper.java"> package org . tanaguru . webapp . command . helper ; import java . io . IOException ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import org . tanaguru . crawler . util . CrawlUtils ; import org . springframework . web . multipart . commons . CommonsMultipartFile ; public final class UploadAuditSetUpCommandHelper { private static Map < String , Integer > fileNameCounterMap = new HashMap < String , Integer > ( ) ; public synchronized static Map < String , String > convertFilesToMap ( CommonsMultipartFile [ ] fileInputList ) { Map < String , String > fileMap = new LinkedHashMap < String , String > ( ) ; CommonsMultipartFile tmpMultiFile ; String tmpCharset ; fileNameCounterMap . clear ( ) ; for ( int i = 0 ; i < fileInputList . length ; i ++ ) { tmpMultiFile = fileInputList [ i ] ; try { if ( tmpMultiFile != null && ! tmpMultiFile . isEmpty ( ) && tmpMultiFile . getInputStream ( ) != null ) { tmpCharset = CrawlUtils . extractCharset ( tmpMultiFile . getInputStream ( ) ) ; fileMap . put ( getFileName ( tmpMultiFile . getOriginalFilename ( ) ) , tmpMultiFile . getFileItem ( ) . getString ( tmpCharset ) ) ; } } catch ( IOException e ) { } } return fileMap ; } private static String getFileName ( String originalFileName ) { StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( ' / ' ) ; if ( fileNameCounterMap . containsKey ( originalFileName ) ) { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( fileNameCounterMap . get ( originalFileName ) + 1 ) ) ; fileName . append ( originalFileName ) ; fileName . append ( ' _ ' ) ; fileName . append ( fileNameCounterMap . get ( originalFileName ) ) ; return fileName . toString ( ) ; } else { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( 1 ) ) ; fileName . append ( originalFileName ) ; return fileName . toString ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="charlesvinette/react-native/tree/master/ReactAndroid/src/main/java/com/facebook/react/views/modal/ReactModalHostView.java"> package com . facebook . react . views . modal ; import javax . annotation . Nullable ; import java . util . ArrayList ; import android . app . Activity ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . KeyEvent ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . view . accessibility . AccessibilityEvent ; import android . widget . FrameLayout ; import com . facebook . infer . annotation . Assertions ; import com . facebook . react . R ; import com . facebook . react . bridge . LifecycleEventListener ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . common . annotations . VisibleForTesting ; import com . facebook . react . uimanager . JSTouchDispatcher ; import com . facebook . react . uimanager . RootView ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; public class ReactModalHostView extends ViewGroup implements LifecycleEventListener { public interface OnRequestCloseListener { void onRequestClose ( DialogInterface dialog ) ; } private DialogRootViewGroup mHostView ; private @ Nullable Dialog mDialog ; private boolean mTransparent ; private String mAnimationType ; private boolean mPropertyRequiresNewDialog ; private @ Nullable DialogInterface . OnShowListener mOnShowListener ; private @ Nullable OnRequestCloseListener mOnRequestCloseListener ; public ReactModalHostView ( Context context ) { super ( context ) ; ( ( ReactContext ) context ) . addLifecycleEventListener ( this ) ; mHostView = new DialogRootViewGroup ( context ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { } @ Override public void addView ( View child , int index ) { mHostView . addView ( child , index ) ; } @ Override public int getChildCount ( ) { return mHostView . getChildCount ( ) ; } @ Override public View getChildAt ( int index ) { return mHostView . getChildAt ( index ) ; } @ Override public void removeView ( View child ) { mHostView . removeView ( child ) ; } @ Override public void removeViewAt ( int index ) { View child = getChildAt ( index ) ; mHostView . removeView ( child ) ; } @ Override public void addChildrenForAccessibility ( ArrayList < View > outChildren ) { } @ Override public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { return false ; } public void onDropInstance ( ) { ( ( ReactContext ) getContext ( ) ) . removeLifecycleEventListener ( this ) ; dismiss ( ) ; } private void dismiss ( ) { if ( mDialog != null ) { mDialog . dismiss ( ) ; mDialog = null ; ViewGroup parent = ( ViewGroup ) mHostView . getParent ( ) ; parent . removeViewAt ( 0 ) ; } } protected void setOnRequestCloseListener ( OnRequestCloseListener listener ) { mOnRequestCloseListener = listener ; } protected void setOnShowListener ( DialogInterface . OnShowListener listener ) { mOnShowListener = listener ; } protected void setTransparent ( boolean transparent ) { mTransparent = transparent ; } protected void setAnimationType ( String animationType ) { mAnimationType = animationType ; mPropertyRequiresNewDialog = true ; } @ Override public void onHostResume ( ) { showOrUpdate ( ) ; } @ Override public void onHostPause ( ) { dismiss ( ) ; } @ Override public void onHostDestroy ( ) { onDropInstance ( ) ; } @ VisibleForTesting public @ Nullable Dialog getDialog ( ) { return mDialog ; } protected void showOrUpdate ( ) { if ( mDialog != null ) { if ( mPropertyRequiresNewDialog ) { dismiss ( ) ; } else { updateProperties ( ) ; return ; } } mPropertyRequiresNewDialog = false ; int theme = R . style . Theme_FullScreenDialog ; if ( mAnimationType . equals ( " fade " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedFade ; } else if ( mAnimationType . equals ( " slide " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedSlide ; } mDialog = new Dialog ( getContext ( ) , theme ) ; mDialog . setContentView ( getContentView ( ) ) ; updateProperties ( ) ; mDialog . setOnShowListener ( mOnShowListener ) ; mDialog . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { @ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent event ) { if ( event . getAction ( ) == KeyEvent . ACTION_UP ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { Assertions . assertNotNull ( mOnRequestCloseListener , " setOnRequestCloseListener ▁ must ▁ be ▁ called ▁ by ▁ the ▁ manager " ) ; mOnRequestCloseListener . onRequestClose ( dialog ) ; return true ; } else { Activity currentActivity = ( ( ReactContext ) getContext ( ) ) . getCurrentActivity ( ) ; if ( currentActivity != null ) { return currentActivity . onKeyUp ( keyCode , event ) ; } } } return false ; } } ) ; mDialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; mDialog . show ( ) ; } private View getContentView ( ) { FrameLayout frameLayout = new FrameLayout ( getContext ( ) ) ; frameLayout . addView ( mHostView ) ; frameLayout . setFitsSystemWindows ( true ) ; return frameLayout ; } private void updateProperties ( ) { Assertions . assertNotNull ( mDialog , " mDialog ▁ must ▁ exist ▁ when ▁ we ▁ call ▁ updateProperties " ) ; if ( mTransparent ) { mDialog . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } else { mDialog . getWindow ( ) . setDimAmount ( 0.5f ) ; mDialog . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND , WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } } static class DialogRootViewGroup extends ReactViewGroup implements RootView { private final JSTouchDispatcher mJSTouchDispatcher = new JSTouchDispatcher ( this ) ; public DialogRootViewGroup ( Context context ) { super ( context ) ; } @ Override protected void onSizeChanged ( final int w , final int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; if ( getChildCount ( ) > 0 ) { ( ( ReactContext ) getContext ( ) ) . runOnNativeModulesQueueThread ( new Runnable ( ) { @ Override public void run ( ) { ( ( ReactContext ) getContext ( ) ) . getNativeModule ( UIManagerModule . class ) . updateNodeSize ( getChildAt ( 0 ) . getId ( ) , w , h ) ; } } ) ; } } @ Override public boolean onInterceptTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; return super . onInterceptTouchEvent ( event ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; super . onTouchEvent ( event ) ; return true ; } @ Override public void onChildStartedNativeGesture ( MotionEvent androidEvent ) { mJSTouchDispatcher . onChildStartedNativeGesture ( androidEvent , getEventDispatcher ( ) ) ; } @ Override public void requestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private EventDispatcher getEventDispatcher ( ) { ReactContext reactContext = ( ReactContext ) getContext ( ) ; return reactContext . getNativeModule ( UIManagerModule . class ) . getEventDispatcher ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="maxammann/SimpleClans2/tree/master/SimpleClans2/src/main/java/com/p000ison/dev/simpleclans2/converter/Converter.java"> package com . p000ison . dev . simpleclans2 . converter ; import com . p000ison . dev . simpleclans2 . api . KillType ; import com . p000ison . dev . simpleclans2 . api . logging . Logging ; import com . p000ison . dev . sqlapi . jbdc . JBDCDatabase ; import org . json . simple . JSONArray ; import org . json . simple . JSONObject ; import org . json . simple . parser . JSONParser ; import org . json . simple . parser . ParseException ; import java . sql . * ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; @ SuppressWarnings ( " unchecked " ) public class Converter implements Runnable { private JBDCDatabase from ; private JBDCDatabase to ; private PreparedStatement insertClan , insertBB , updateClan , insertKill ; private PreparedStatement insertClanPlayer ; private Set < ConvertedClan > clans = new HashSet < ConvertedClan > ( ) ; private Set < ConvertedClanPlayer > players = new HashSet < ConvertedClanPlayer > ( ) ; public Converter ( JBDCDatabase from , JBDCDatabase to ) { this . from = from ; this . to = to ; insertBB = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ bb ` ▁ ( ` clan ` , ▁ ` text ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? ▁ ) ; " ) ; updateClan = to . prepare ( " UPDATE ▁ ` sc2 _ clans ` ▁ SET ▁ allies ▁ = ▁ ? , ▁ rivals ▁ = ▁ ? , ▁ warring ▁ = ▁ ? ▁ WHERE ▁ id ▁ = ▁ ? ; " ) ; insertKill = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ kills ` ▁ ( ▁ ` attacker ` , ▁ ` attacker _ clan ` , ▁ ` victim ` , ▁ ` victim _ clan ` , ▁ ` war ` , ▁ ` type ` , ▁ ` date ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; prepareClan ( ) ; prepareClanPlayer ( ) ; } private void prepareClan ( ) { if ( insertClan != null ) { try { insertClan . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClan = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ clans ` ▁ ( ` name ` , ▁ ` tag ` , ▁ ` verified ` , ▁ ` founded ` , ▁ ` last _ action ` , ▁ ` flags ` , ▁ ` balance ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; } private void prepareClanPlayer ( ) { if ( insertClanPlayer != null ) { try { insertClanPlayer . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClanPlayer = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ players ` ▁ ( ▁ ` name ` , ▁ ` leader ` , ▁ ` trusted ` , ▁ ` join _ date ` , ▁ ` last _ seen ` , ▁ ` clan ` , ▁ ` neutral _ kills ` , ▁ ` rival _ Kills ` , ▁ ` civilian _ Kills ` , ▁ ` deaths ` , ▁ ` flags ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) " ) ; } public void convertAll ( ) { try { convertClans ( ) ; convertPlayers ( ) ; convertKills ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } clans = null ; players = null ; } @ Override public void run ( ) { convertAll ( ) ; } public void convertPlayers ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ players ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; try { JSONParser parser = new JSONParser ( ) ; String flagsString = result . getString ( " flags " ) ; JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; boolean friendlyFire = result . getBoolean ( " friendly _ fire " ) ; boolean bb = ( Boolean ) object . get ( " bb - enabled " ) ; boolean cape = ( Boolean ) object . get ( " cape - enabled " ) ; if ( friendlyFire ) { flags . put ( " ff " , friendlyFire ) ; } if ( bb ) { flags . put ( " bb " , bb ) ; } if ( cape ) { flags . put ( " cape " , cape ) ; } } catch ( ParseException e ) { e . printStackTrace ( ) ; continue ; } String name = result . getString ( " name " ) ; insertPlayer ( name , result . getBoolean ( " leader " ) , result . getBoolean ( " trusted " ) , result . getLong ( " join _ date " ) , result . getLong ( " last _ seen " ) , getIDByTag ( result . getString ( " tag " ) ) , result . getInt ( " neutral _ kills " ) , result . getInt ( " rival _ kills " ) , result . getInt ( " civilian _ kills " ) , result . getInt ( " deaths " ) , flags . toJSONString ( ) ) ; ResultSet idResult = to . query ( " SELECT ▁ id ▁ FROM ▁ ` sc2 _ players ` ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ) ; idResult . next ( ) ; players . add ( new ConvertedClanPlayer ( idResult . getLong ( " id " ) , name ) ) ; } } public void insertPlayer ( String name , boolean leader , boolean trusted , long joinDate , long lastSeen , long clan , int neutralKills , int rivalKills , int civilianKills , int deaths , String flags ) throws SQLException { insertClanPlayer . setString ( 1 , name ) ; insertClanPlayer . setBoolean ( 2 , leader ) ; insertClanPlayer . setBoolean ( 3 , trusted ) ; insertClanPlayer . setTimestamp ( 4 , new Timestamp ( joinDate ) ) ; insertClanPlayer . setTimestamp ( 5 , new Timestamp ( lastSeen ) ) ; insertClanPlayer . setLong ( 6 , clan ) ; insertClanPlayer . setInt ( 7 , neutralKills ) ; insertClanPlayer . setInt ( 8 , rivalKills ) ; insertClanPlayer . setInt ( 9 , civilianKills ) ; insertClanPlayer . setInt ( 10 , deaths ) ; if ( flags != null ) { insertClanPlayer . setString ( 11 , flags ) ; } else { insertClanPlayer . setNull ( 11 , Types . VARCHAR ) ; } try { insertClanPlayer . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clanPlayer ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClanPlayer ( ) ; } } public long getClanPlayerIDbyName ( String tag ) { for ( ConvertedClanPlayer cp : players ) { if ( cp . getName ( ) . equals ( tag ) ) { return cp . getId ( ) ; } } return - 1 ; } public void convertClans ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ clans ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; String name = result . getString ( " name " ) ; String tag = result . getString ( " tag " ) ; boolean verified = result . getBoolean ( " verified " ) ; boolean friendly_fire = result . getBoolean ( " friendly _ fire " ) ; long founded = result . getLong ( " founded " ) ; long last_used = result . getLong ( " last _ used " ) ; String flagsString = result . getString ( " flags " ) ; String cape = result . getString ( " cape _ url " ) ; ConvertedClan clan = new ConvertedClan ( tag ) ; clan . setPackedAllies ( result . getString ( " packed _ allies " ) ) ; clan . serPackedRivals ( result . getString ( " packed _ rivals " ) ) ; if ( friendly_fire ) { flags . put ( " ff " , friendly_fire ) ; } if ( cape != null && ! cape . isEmpty ( ) ) { flags . put ( " cape - url " , cape ) ; } JSONParser parser = new JSONParser ( ) ; try { JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; String world = object . get ( " homeWorld " ) . toString ( ) ; if ( ! world . isEmpty ( ) ) { int x = ( ( Long ) object . get ( " homeX " ) ) . intValue ( ) ; int y = ( ( Long ) object . get ( " homeY " ) ) . intValue ( ) ; int z = ( ( Long ) object . get ( " homeZ " ) ) . intValue ( ) ; flags . put ( " home " , x + " : " + y + " : " + z + " : " + world + " : 0:0" ) ; } clan . setRawWarring ( ( JSONArray ) object . get ( " warring " ) ) ; } catch ( ParseException e ) { Logging . debug ( e , true ) ; continue ; } insertClan ( name , tag , verified , founded , last_used , flags . isEmpty ( ) ? null : flags . toJSONString ( ) , result . getDouble ( " balance " ) ) ; String selectLastQuery = " SELECT ▁ ` id ` ▁ FROM ▁ ` sc2 _ clans ` ▁ ORDER ▁ BY ▁ ID ▁ DESC ▁ LIMIT ▁ 1 ; " ; ResultSet selectLast = to . query ( selectLastQuery ) ; selectLast . next ( ) ; clan . setId ( selectLast . getLong ( " id " ) ) ; selectLast . close ( ) ; insertBB ( Arrays . asList ( result . getString ( " packed _ bb " ) . split ( " \\s * ( \\ | | $ ) " ) ) , clan . getId ( ) ) ; clans . add ( clan ) ; } for ( ConvertedClan clan : clans ) { JSONArray allies = new JSONArray ( ) ; JSONArray rivals = new JSONArray ( ) ; JSONArray warring = new JSONArray ( ) ; for ( String allyTag : clan . getRawAllies ( ) ) { long allyID = getIDByTag ( allyTag ) ; if ( allyID != - 1 ) { allies . add ( allyID ) ; } } for ( String rivalTag : clan . getRawAllies ( ) ) { long rivalID = getIDByTag ( rivalTag ) ; if ( rivalID != - 1 ) { rivals . add ( rivalID ) ; } } for ( String warringTag : clan . getRawWarring ( ) ) { long warringID = getIDByTag ( warringTag ) ; if ( warringID != - 1 ) { warring . add ( warringID ) ; } } if ( ! allies . isEmpty ( ) ) { updateClan . setString ( 1 , allies . toJSONString ( ) ) ; } else { updateClan . setNull ( 1 , Types . VARCHAR ) ; } if ( ! rivals . isEmpty ( ) ) { updateClan . setString ( 2 , rivals . toJSONString ( ) ) ; } else { updateClan . setNull ( 2 , Types . VARCHAR ) ; } if ( ! warring . isEmpty ( ) ) { updateClan . setString ( 3 , warring . toJSONString ( ) ) ; } else { updateClan . setNull ( 3 , Types . VARCHAR ) ; } updateClan . setLong ( 4 , clan . getId ( ) ) ; updateClan . executeUpdate ( ) ; } } public long getIDByTag ( String tag ) { for ( ConvertedClan clan : clans ) { if ( clan . getTag ( ) . equals ( tag ) ) { return clan . getId ( ) ; } } return - 1 ; } public void insertBB ( List < String > bb , long clan ) throws SQLException { for ( String text : bb ) { insertBB . setLong ( 1 , clan ) ; insertBB . setString ( 2 , text ) ; insertBB . executeUpdate ( ) ; } } public void insertClan ( String name , String tag , boolean verified , long founded , long last_action , String flags , double balance ) throws SQLException { insertClan . setString ( 1 , name ) ; insertClan . setString ( 2 , tag ) ; insertClan . setBoolean ( 3 , verified ) ; insertClan . setTimestamp ( 4 , new Timestamp ( founded ) ) ; insertClan . setTimestamp ( 5 , new Timestamp ( last_action ) ) ; if ( flags != null ) { insertClan . setString ( 6 , flags ) ; } else { insertClan . setNull ( 6 , Types . VARCHAR ) ; } insertClan . setDouble ( 7 , balance ) ; try { insertClan . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clan ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClan ( ) ; } } public void convertKills ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ kills ` ; " ) ; while ( result . next ( ) ) { Timestamp date ; try { date = result . getTimestamp ( " date " ) ; } catch ( Exception e ) { date = new Timestamp ( System . currentTimeMillis ( ) ) ; } insertKill ( result . getString ( " attacker " ) , result . getString ( " attacker _ tag " ) , result . getString ( " victim " ) , result . getString ( " victim _ tag " ) , result . getString ( " kill _ type " ) , result . getBoolean ( " war " ) , date ) ; } } public void insertKill ( String attacker , String attacker_clan , String victim , String victim_clan , String type , boolean war , Timestamp date ) throws SQLException { long attackerID = getClanPlayerIDbyName ( attacker ) ; if ( attackerID == - 1 ) { return ; } long victimID = getClanPlayerIDbyName ( victim ) ; if ( victimID == - 1 ) { return ; } insertKill . setLong ( 1 , attackerID ) ; insertKill . setLong ( 2 , getIDByTag ( attacker_clan ) ) ; insertKill . setLong ( 3 , victimID ) ; insertKill . setLong ( 4 , getIDByTag ( victim_clan ) ) ; KillType realType ; switch ( type . charAt ( 0 ) ) { case ' c ' : realType = KillType . CIVILIAN ; break ; case ' n ' : realType = KillType . NEUTRAL ; break ; case ' r ' : realType = KillType . RIVAL ; break ; default : throw new UnsupportedOperationException ( " Failed ▁ at ▁ inserting ▁ kill ! ▁ Type ▁ not ▁ found : ▁ " + type ) ; } insertKill . setByte ( 5 , realType . getType ( ) ) ; insertKill . setBoolean ( 6 , war ) ; insertKill . setTimestamp ( 7 , date ) ; insertKill . executeUpdate ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="irwinai/zxing/tree/master/android/src/com/google/zxing/client/android/result/AddressBookResultHandler.java"> package com . google . zxing . client . android . result ; import com . google . zxing . client . android . R ; import com . google . zxing . client . result . AddressBookParsedResult ; import com . google . zxing . client . result . ParsedResult ; import android . app . Activity ; import android . telephony . PhoneNumberUtils ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . style . StyleSpan ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; public final class AddressBookResultHandler extends ResultHandler { private static final DateFormat [ ] DATE_FORMATS = { new SimpleDateFormat ( " yyyyMMdd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyyMMdd ' T ' HHmmss " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd ' T ' HH : mm : ss " , Locale . ENGLISH ) , } ; static { for ( DateFormat format : DATE_FORMATS ) { format . setLenient ( false ) ; } } private static final int [ ] BUTTON_TEXTS = { R . string . button_add_contact , R . string . button_show_map , R . string . button_dial , R . string . button_email , } ; private final boolean [ ] fields ; private int buttonCount ; private int mapIndexToAction ( int index ) { if ( index < buttonCount ) { int count = - 1 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { count ++ ; } if ( count == index ) { return x ; } } } return - 1 ; } public AddressBookResultHandler ( Activity activity , ParsedResult result ) { super ( activity , result ) ; AddressBookParsedResult addressResult = ( AddressBookParsedResult ) result ; String [ ] addresses = addressResult . getAddresses ( ) ; boolean hasAddress = addresses != null && addresses . length > 0 && addresses [ 0 ] != null && ! addresses [ 0 ] . isEmpty ( ) ; String [ ] phoneNumbers = addressResult . getPhoneNumbers ( ) ; boolean hasPhoneNumber = phoneNumbers != null && phoneNumbers . length > 0 ; String [ ] emails = addressResult . getEmails ( ) ; boolean hasEmailAddress = emails != null && emails . length > 0 ; fields = new boolean [ MAX_BUTTON_COUNT ] ; fields [ 0 ] = true ; fields [ 1 ] = hasAddress ; fields [ 2 ] = hasPhoneNumber ; fields [ 3 ] = hasEmailAddress ; buttonCount = 0 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { buttonCount ++ ; } } } @ Override public int getButtonCount ( ) { return buttonCount ; } @ Override public int getButtonText ( int index ) { return BUTTON_TEXTS [ mapIndexToAction ( index ) ] ; } @ Override public void handleButtonPress ( int index ) { AddressBookParsedResult addressResult = ( AddressBookParsedResult ) getResult ( ) ; String [ ] addresses = addressResult . getAddresses ( ) ; String address1 = addresses == null || addresses . length < 1 ? null : addresses [ 0 ] ; String [ ] addressTypes = addressResult . getAddressTypes ( ) ; String address1Type = addressTypes == null || addressTypes . length < 1 ? null : addressTypes [ 0 ] ; int action = mapIndexToAction ( index ) ; switch ( action ) { case 0 : addContact ( addressResult . getNames ( ) , addressResult . getNicknames ( ) , addressResult . getPronunciation ( ) , addressResult . getPhoneNumbers ( ) , addressResult . getPhoneTypes ( ) , addressResult . getEmails ( ) , addressResult . getEmailTypes ( ) , addressResult . getNote ( ) , addressResult . getInstantMessenger ( ) , address1 , address1Type , addressResult . getOrg ( ) , addressResult . getTitle ( ) , addressResult . getURLs ( ) , addressResult . getBirthday ( ) , addressResult . getGeo ( ) ) ; break ; case 1 : searchMap ( address1 ) ; break ; case 2 : dialPhone ( addressResult . getPhoneNumbers ( ) [ 0 ] ) ; break ; case 3 : sendEmail ( addressResult . getEmails ( ) , null , null , null , null ) ; break ; default : break ; } } private static Date parseDate ( String s ) { for ( DateFormat currentFormat : DATE_FORMATS ) { try { return currentFormat . parse ( s ) ; } catch ( ParseException e ) { } } return null ; } @ Override public CharSequence getDisplayContents ( ) { AddressBookParsedResult result = ( AddressBookParsedResult ) getResult ( ) ; StringBuilder contents = new StringBuilder ( 100 ) ; ParsedResult . maybeAppend ( result . getNames ( ) , contents ) ; int namesLength = contents . length ( ) ; String pronunciation = result . getPronunciation ( ) ; if ( pronunciation != null && ! pronunciation . isEmpty ( ) ) { contents . append ( " \n ( " ) ; contents . append ( pronunciation ) ; contents . append ( ' ) ' ) ; } ParsedResult . maybeAppend ( result . getTitle ( ) , contents ) ; ParsedResult . maybeAppend ( result . getOrg ( ) , contents ) ; ParsedResult . maybeAppend ( result . getAddresses ( ) , contents ) ; String [ ] numbers = result . getPhoneNumbers ( ) ; if ( numbers != null ) { for ( String number : numbers ) { if ( number != null ) { ParsedResult . maybeAppend ( PhoneNumberUtils . formatNumber ( number ) , contents ) ; } } } ParsedResult . maybeAppend ( result . getEmails ( ) , contents ) ; ParsedResult . maybeAppend ( result . getURLs ( ) , contents ) ; String birthday = result . getBirthday ( ) ; if ( birthday != null && ! birthday . isEmpty ( ) ) { Date date = parseDate ( birthday ) ; if ( date != null ) { ParsedResult . maybeAppend ( DateFormat . getDateInstance ( DateFormat . MEDIUM ) . format ( date . getTime ( ) ) , contents ) ; } } ParsedResult . maybeAppend ( result . getNote ( ) , contents ) ; if ( namesLength > 0 ) { Spannable styled = new SpannableString ( contents . toString ( ) ) ; styled . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , 0 , namesLength , 0 ) ; return styled ; } else { return contents . toString ( ) ; } } @ Override public int getDisplayTitle ( ) { return R . string . result_address_book ; } } </DOCUMENT>
