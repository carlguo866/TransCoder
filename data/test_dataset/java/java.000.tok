<DOCUMENT_ID="Lotusun/OfficeHelper/tree/master/src/main/java/com/charlesdream/office/word/objects/Style.java"> package com . charlesdream . office . word . objects ; import com . charlesdream . office . BaseObject ; import com . jacob . com . Dispatch ; public class Style extends BaseObject { public Style ( Dispatch dispatch ) { super ( dispatch ) ; } } </DOCUMENT>
<DOCUMENT_ID="apixandru/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="idea4bsd/idea4bsd/tree/master/java/java-psi-api/src/com/intellij/psi/PsiVariable.java"> package com . intellij . psi ; import com . intellij . pom . PomRenameableTarget ; import com . intellij . util . IncorrectOperationException ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import org . jetbrains . annotations . NonNls ; public interface PsiVariable extends PsiModifierListOwner , PsiNameIdentifierOwner , PsiTarget , PomRenameableTarget < PsiElement > { @ NotNull PsiType getType ( ) ; @ Nullable PsiTypeElement getTypeElement ( ) ; @ Nullable PsiExpression getInitializer ( ) ; boolean hasInitializer ( ) ; void normalizeDeclaration ( ) throws IncorrectOperationException ; @ Nullable Object computeConstantValue ( ) ; @ Override @ Nullable PsiIdentifier getNameIdentifier ( ) ; @ Override PsiElement setName ( @ NonNls @ NotNull String name ) throws IncorrectOperationException ; } </DOCUMENT>
<DOCUMENT_ID="bobocop/gsn35/tree/master/src/endymion/alarm/senders/GSNAlarmSender.java"> package endymion . alarm . senders ; import endymion . exception . EndymionException ; public abstract class GSNAlarmSender { public abstract void setSendParameters ( String ... parameters ) throws EndymionException ; public abstract void sendAlarm ( String subjectLine , String alarmMessage ) throws EndymionException ; } </DOCUMENT>
<DOCUMENT_ID="scnakandala/derby/tree/master/java/engine/org/apache/derby/iapi/services/crypto/CipherProvider.java"> package org . apache . derby . iapi . services . crypto ; import java . security . Key ; import org . apache . derby . iapi . error . StandardException ; public interface CipherProvider { int encrypt ( byte [ ] cleartext , int offset , int length , byte [ ] ciphertext , int outputOffset ) throws StandardException ; int decrypt ( byte [ ] ciphertext , int offset , int length , byte [ ] cleartext , int outputOffset ) throws StandardException ; public int getEncryptionBlockSize ( ) ; } </DOCUMENT>
<DOCUMENT_ID="WelcomeHUME/svn-caucho-com-resin/tree/master/modules/jca/src/javax/resource/cci/ResourceAdapterMetaData.java"> package javax . resource . cci ; public interface ResourceAdapterMetaData { public String getAdapterVersion ( ) ; public String getAdapterVendorName ( ) ; public String getAdapterName ( ) ; public String getAdapterShortDescription ( ) ; public String getSpecVersion ( ) ; public String [ ] getInteractionSpecsSupported ( ) ; public boolean supportsExecuteWithInputAndOutputRecord ( ) ; public boolean supportsExecuteWithInputRecordOnly ( ) ; public boolean supportsLocalTransactionDemarcation ( ) ; } </DOCUMENT>
<DOCUMENT_ID="skofra0/pentaho-kettle/tree/master/engine/src/org/pentaho/di/job/JobEntryListener.java"> package org . pentaho . di . job ; import org . pentaho . di . core . Result ; import org . pentaho . di . job . entry . JobEntryCopy ; import org . pentaho . di . job . entry . JobEntryInterface ; public interface JobEntryListener { public void beforeExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface ) ; public void afterExecution ( Job job , JobEntryCopy jobEntryCopy , JobEntryInterface jobEntryInterface , Result result ) ; } </DOCUMENT>
<DOCUMENT_ID="Maccimo/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/explicit2var/beforeAnonymous.java"> class MyTest { private void m ( ) { Ru < caret > nnable r = new Runnable ( ) { @ Override public void run ( ) { } } ; } } </DOCUMENT>
<DOCUMENT_ID="seanzwx/tmp/tree/master/shop/android/imageloader/src/com/nostra13/universalimageloader/cache/memory/impl/LimitedAgeMemoryCache.java"> package com . nostra13 . universalimageloader . cache . memory . impl ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import com . nostra13 . universalimageloader . cache . memory . MemoryCacheAware ; public class LimitedAgeMemoryCache < K , V > implements MemoryCacheAware < K , V > { private final MemoryCacheAware < K , V > cache ; private final long maxAge ; private final Map < K , Long > loadingDates = Collections . synchronizedMap ( new HashMap < K , Long > ( ) ) ; public LimitedAgeMemoryCache ( MemoryCacheAware < K , V > cache , long maxAge ) { this . cache = cache ; this . maxAge = maxAge * 1000 ; } @ Override public boolean put ( K key , V value ) { boolean putSuccesfully = cache . put ( key , value ) ; if ( putSuccesfully ) { loadingDates . put ( key , System . currentTimeMillis ( ) ) ; } return putSuccesfully ; } @ Override public V get ( K key ) { Long loadingDate = loadingDates . get ( key ) ; if ( loadingDate != null && System . currentTimeMillis ( ) - loadingDate > maxAge ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } return cache . get ( key ) ; } @ Override public void remove ( K key ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } @ Override public Collection < K > keys ( ) { return cache . keys ( ) ; } @ Override public void clear ( ) { cache . clear ( ) ; loadingDates . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="aporter/coursera-android/tree/master/Examples/BluetoothSetupAndTransferData/src/course/examples/bluetooth/setupandtransferdata/ConnectionThread.java"> package course . examples . bluetooth . setupandtransferdata ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import android . bluetooth . BluetoothSocket ; import android . os . Handler ; public class ConnectionThread extends Thread { BluetoothSocket mBluetoothSocket ; private final Handler mHandler ; private InputStream mInStream ; private OutputStream mOutStream ; ConnectionThread ( BluetoothSocket socket , Handler handler ) { super ( ) ; mBluetoothSocket = socket ; mHandler = handler ; try { mInStream = mBluetoothSocket . getInputStream ( ) ; mOutStream = mBluetoothSocket . getOutputStream ( ) ; } catch ( IOException e ) { } } @ Override public void run ( ) { byte [ ] buffer = new byte [ 1024 ] ; int bytes ; while ( true ) { try { bytes = mInStream . read ( buffer ) ; String data = new String ( buffer , 0 , bytes ) ; mHandler . obtainMessage ( DataTransferActivity . DATA_RECEIVED , data ) . sendToTarget ( ) ; } catch ( IOException e ) { break ; } } } public void write ( byte [ ] bytes ) { try { mOutStream . write ( bytes ) ; } catch ( IOException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="agibsonccc/cloud-bigtable-client/tree/master/bigtable-hbase/src/main/java/com/google/cloud/bigtable/hbase/adapters/BigtableResultScannerAdapter.java"> package com . google . cloud . bigtable . hbase . adapters ; import com . google . api . client . util . Throwables ; import com . google . bigtable . v1 . Row ; import org . apache . hadoop . hbase . client . AbstractClientScanner ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . ResultScanner ; import java . io . IOException ; public class BigtableResultScannerAdapter { final ResponseAdapter < Row , Result > rowAdapter ; public BigtableResultScannerAdapter ( ResponseAdapter < Row , Result > rowAdapter ) { this . rowAdapter = rowAdapter ; } public ResultScanner adapt ( final com . google . cloud . bigtable . grpc . scanner . ResultScanner < Row > bigtableResultScanner ) { return new AbstractClientScanner ( ) { @ Override public Result next ( ) throws IOException { Row row = bigtableResultScanner . next ( ) ; if ( row == null ) { return null ; } return rowAdapter . adaptResponse ( row ) ; } @ Override public void close ( ) { try { bigtableResultScanner . close ( ) ; } catch ( IOException ioe ) { throw Throwables . propagate ( ioe ) ; } } } ; } } </DOCUMENT>
<DOCUMENT_ID="JetBrains/intellij-community/tree/master/java/java-tests/testData/codeInsight/daemonCodeAnalyzer/quickFix/lambda2methodReference/afterAmbiguityWithoutSuperMethodNonStatic.java"> interface I { String foo ( Foo i ) ; } class Foo { public String foo ( ) { return null ; } String foo ( int i ) { return null ; } String foo ( Foo foo ) { return null ; } public static void main ( String [ ] args ) { I i = Foo :: foo ; } } </DOCUMENT>
<DOCUMENT_ID="pressgang-ccms/PressGangCCMSCommonUtilities/tree/master/src/main/java/org/jboss/pressgang/ccms/utils/common/ExceptionUtilities.java"> package org . jboss . pressgang . ccms . utils . common ; import java . io . PrintWriter ; import java . io . StringWriter ; public class ExceptionUtilities { public static String getStackTrace ( final Throwable ex ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw , true ) ; ex . printStackTrace ( pw ) ; pw . flush ( ) ; sw . flush ( ) ; return sw . toString ( ) ; } public static Throwable getRootCause ( Throwable throwable ) { if ( throwable . getCause ( ) != null ) return getRootCause ( throwable . getCause ( ) ) ; return throwable ; } } </DOCUMENT>
<DOCUMENT_ID="Communote/communote-server/tree/master/communote/persistence/src/main/java/com/communote/server/core/tag/TagStoreNotFoundException.java"> package com . communote . server . core . tag ; import com . communote . server . api . core . common . NotFoundException ; public class TagStoreNotFoundException extends NotFoundException { private static final long serialVersionUID = - 5089679368783279854L ; public TagStoreNotFoundException ( String message ) { super ( message ) ; } } </DOCUMENT>
<DOCUMENT_ID="jrversteegh/softsailor/tree/master/deps/swig-2.0.4/Examples/ruby/java/Example.java"> public class Example { public int mPublicInt ; public Example ( ) { mPublicInt = 0 ; } public Example ( int IntVal ) { mPublicInt = IntVal ; } public int Add ( int a , int b ) { return ( a + b ) ; } public float Add ( float a , float b ) { return ( a + b ) ; } public String Add ( String a , String b ) { return ( a + b ) ; } public Example Add ( Example a , Example b ) { return new Example ( a . mPublicInt + b . mPublicInt ) ; } } </DOCUMENT>
<DOCUMENT_ID="fitermay/intellij-community/tree/master/plugins/InspectionGadgets/test/com/siyeh/igtest/bugs/MisspelledToStringInsspection.java"> package com . siyeh . igtest . bugs ; public class MisspelledToStringInsspection { private int m_bar ; public MisspelledToStringInsspection ( ) { m_bar = 0 ; } public String tostring ( ) { return String . valueOf ( m_bar == 3 ) ; } } </DOCUMENT>
<DOCUMENT_ID="forever342/dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="davidzchen/bazel/tree/master/third_party/java/proguard/proguard5.3.3/src/proguard/optimize/info/InstanceofClassMarker.java"> package proguard . optimize . info ; import proguard . classfile . * ; import proguard . classfile . attribute . CodeAttribute ; import proguard . classfile . constant . ClassConstant ; import proguard . classfile . constant . visitor . ConstantVisitor ; import proguard . classfile . instruction . * ; import proguard . classfile . instruction . visitor . InstructionVisitor ; import proguard . classfile . util . SimplifiedVisitor ; import proguard . classfile . visitor . ClassVisitor ; public class InstanceofClassMarker extends SimplifiedVisitor implements InstructionVisitor , ConstantVisitor , ClassVisitor { public void visitAnyInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , Instruction instruction ) { } public void visitConstantInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , ConstantInstruction constantInstruction ) { if ( constantInstruction . opcode == InstructionConstants . OP_INSTANCEOF ) { clazz . constantPoolEntryAccept ( constantInstruction . constantIndex , this ) ; } } public void visitClassConstant ( Clazz clazz , ClassConstant classConstant ) { classConstant . referencedClassAccept ( this ) ; } public void visitLibraryClass ( LibraryClass libraryClass ) { } public void visitProgramClass ( ProgramClass programClass ) { setInstanceofed ( programClass ) ; } private static void setInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; if ( info != null ) { info . setInstanceofed ( ) ; } } public static boolean isInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; return info == null || info . isInstanceofed ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="dotunolafunmiloye/hadoop-common/tree/master/src/test/core/org/apache/hadoop/io/file/tfile/Timer.java"> package org . apache . hadoop . io . file . tfile ; import java . io . IOException ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; public class Timer { long startTimeEpoch ; long finishTimeEpoch ; private DateFormat formatter = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; public void startTime ( ) throws IOException { startTimeEpoch = System . currentTimeMillis ( ) ; } public void stopTime ( ) throws IOException { finishTimeEpoch = System . currentTimeMillis ( ) ; } public long getIntervalMillis ( ) throws IOException { return finishTimeEpoch - startTimeEpoch ; } public void printlnWithTimestamp ( String message ) throws IOException { System . out . println ( formatCurrentTime ( ) + " ▁ ▁ " + message ) ; } public String formatTime ( long millis ) { return formatter . format ( millis ) ; } public String getIntervalString ( ) throws IOException { long time = getIntervalMillis ( ) ; return formatTime ( time ) ; } public String formatCurrentTime ( ) { return formatTime ( System . currentTimeMillis ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="deeplearning4j/deeplearning4j/tree/master/nd4j/nd4j-backends/nd4j-api-parent/nd4j-api/src/main/java/org/nd4j/linalg/api/ops/impl/transforms/custom/segment/SegmentMin.java"> package org . nd4j . linalg . api . ops . impl . transforms . custom . segment ; import org . nd4j . autodiff . samediff . SDVariable ; import org . nd4j . autodiff . samediff . SameDiff ; import org . nd4j . base . Preconditions ; import org . nd4j . linalg . api . buffer . DataType ; import org . nd4j . linalg . api . ops . DynamicCustomOp ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class SegmentMin extends DynamicCustomOp { public SegmentMin ( SameDiff sameDiff , SDVariable data , SDVariable segmentIds ) { super ( null , sameDiff , new SDVariable [ ] { data , segmentIds } , false ) ; } public SegmentMin ( ) { } @ Override public String opName ( ) { return " segment _ min " ; } @ Override public String tensorflowName ( ) { return " SegmentMin " ; } @ Override public List < SDVariable > doDiff ( List < SDVariable > gradients ) { return Arrays . asList ( f ( ) . segmentMinBp ( arg ( 0 ) , arg ( 1 ) , gradients . get ( 0 ) ) ) ; } @ Override public List < DataType > calculateOutputDataTypes ( List < DataType > inputDataTypes ) { Preconditions . checkState ( inputDataTypes != null && inputDataTypes . size ( ) == 2 , " Expected ▁ exactly ▁ 2 ▁ input ▁ datatypes ▁ for ▁ % s , ▁ got ▁ % s " , getClass ( ) , inputDataTypes ) ; Preconditions . checkState ( inputDataTypes . get ( 1 ) . isIntType ( ) , " Datatype ▁ for ▁ input ▁ 1 ▁ ( Segment ▁ IDs ) ▁ must ▁ be ▁ an ▁ integer ▁ type , ▁ got ▁ % s " , inputDataTypes . get ( 1 ) ) ; return Collections . singletonList ( inputDataTypes . get ( 0 ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="jondong/crosswalk/tree/master/third_party/lzma_sdk/src/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
<DOCUMENT_ID="nuwanw/product-apim-2015-09-04/tree/master/modules/integration/tests-common/backend-service/src/main/java/org/wso2/am/integration.services/jaxrs/peoplesample/AppConfig.java"> package org . wso2 . am . integration . services . jaxrs . peoplesample ; import org . apache . cxf . bus . spring . SpringBus ; import org . apache . cxf . endpoint . Server ; import org . apache . cxf . jaxrs . JAXRSServerFactoryBean ; import org . codehaus . jackson . jaxrs . JacksonJsonProvider ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import javax . ws . rs . ext . RuntimeDelegate ; import java . util . Arrays ; @ Configuration public class AppConfig { @ Bean ( destroyMethod = " shutdown " ) public SpringBus cxf ( ) { return new SpringBus ( ) ; } @ Bean public Server jaxRsServer ( ) { JAXRSServerFactoryBean factory = RuntimeDelegate . getInstance ( ) . createEndpoint ( jaxRsApiApplication ( ) , JAXRSServerFactoryBean . class ) ; factory . setServiceBeans ( Arrays . < Object > asList ( peopleRestService ( ) ) ) ; factory . setAddress ( " / " + factory . getAddress ( ) ) ; factory . setProviders ( Arrays . < Object > asList ( jsonProvider ( ) ) ) ; return factory . create ( ) ; } @ Bean public JaxRsApiApplication jaxRsApiApplication ( ) { return new JaxRsApiApplication ( ) ; } @ Bean public PeopleRestService peopleRestService ( ) { return new PeopleRestService ( ) ; } @ Bean public PeopleService peopleService ( ) { return new PeopleService ( ) ; } @ Bean public JacksonJsonProvider jsonProvider ( ) { return new JacksonJsonProvider ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="1and1/aesh/tree/master/src/main/java/org/jboss/aesh/cl/builder/OptionBuilder.java"> package org . jboss . aesh . cl . builder ; import org . jboss . aesh . cl . completer . OptionCompleter ; import org . jboss . aesh . cl . converter . CLConverter ; import org . jboss . aesh . cl . exception . OptionParserException ; import org . jboss . aesh . cl . internal . OptionInt ; import org . jboss . aesh . cl . internal . OptionType ; import java . util . ArrayList ; import java . util . List ; public class OptionBuilder { private char shortName ; private String name ; private String description ; private String argument ; private Class < ? > type ; private boolean hasValue = true ; private boolean required = false ; private boolean isProperty = false ; private boolean hasMultipleValues = false ; private char valueSeparator = ' , ' ; private OptionType optionType ; private Class < ? extends CLConverter > converter ; private String fieldName ; private OptionCompleter completer ; private List < String > defaultValues ; public OptionBuilder ( ) { defaultValues = new ArrayList < String > ( ) ; } public OptionBuilder shortName ( char n ) { shortName = n ; return this ; } public OptionBuilder name ( String name ) { this . name = name ; return this ; } public OptionBuilder description ( String description ) { this . description = description ; return this ; } public OptionBuilder argument ( String argument ) { this . argument = argument ; return this ; } public OptionBuilder type ( Class < ? > type ) { this . type = type ; return this ; } public OptionBuilder required ( boolean required ) { this . required = required ; return this ; } public OptionBuilder fieldName ( String fieldName ) { this . fieldName = fieldName ; return this ; } public OptionBuilder hasValue ( boolean hasValue ) { this . hasValue = hasValue ; return this ; } public OptionBuilder isProperty ( boolean isProperty ) { this . isProperty = isProperty ; return this ; } public OptionBuilder hasMultipleValues ( boolean hasMultipleValues ) { this . hasMultipleValues = hasMultipleValues ; return this ; } public OptionBuilder addDefaultValue ( String defaultValue ) { this . defaultValues . add ( defaultValue ) ; return this ; } public OptionBuilder valueSeparator ( char valueSeparator ) { this . valueSeparator = valueSeparator ; return this ; } public OptionBuilder optionType ( OptionType optionType ) { this . optionType = optionType ; return this ; } public OptionBuilder converter ( Class < ? extends CLConverter > converter ) { this . converter = converter ; return this ; } public OptionBuilder completer ( OptionCompleter completer ) { this . completer = completer ; return this ; } public OptionInt create ( ) throws OptionParserException { if ( optionType == null ) { if ( ! hasValue ) optionType = OptionType . BOOLEAN ; else if ( isProperty ) optionType = OptionType . GROUP ; else if ( hasMultipleValues ) optionType = OptionType . LIST ; else optionType = OptionType . NORMAL ; } if ( name == null || ( name . length ( ) < 1 && optionType != OptionType . ARGUMENT ) ) { if ( fieldName == null || fieldName . length ( ) < 1 ) throw new OptionParserException ( " Name ▁ must ▁ be ▁ defined ▁ to ▁ create ▁ an ▁ Option " ) ; else name = fieldName ; } return new OptionInt ( shortName , name , description , argument , required , valueSeparator , defaultValues , type , fieldName , optionType , converter , completer ) ; } } </DOCUMENT>
<DOCUMENT_ID="iLoop2/openmrs-core/tree/master/api/src/test/java/org/openmrs/PersonAttributeTest.java"> package org . openmrs ; import java . util . Date ; import org . junit . Assert ; import org . junit . Test ; import org . openmrs . api . context . Context ; import org . openmrs . test . BaseContextSensitiveTest ; import org . openmrs . test . Verifies ; public class PersonAttributeTest extends BaseContextSensitiveTest { @ Test @ Verifies ( value = " should ▁ return ▁ toString ▁ of ▁ hydrated ▁ value " , method = " toString ( ) " ) public void toString_shouldReturnToStringOfHydratedValue ( ) throws Exception { PersonAttributeType type = Context . getPersonService ( ) . getPersonAttributeType ( 8 ) ; PersonAttribute attr = new PersonAttribute ( type , "6" ) ; Assert . assertEquals ( " MARRIED " , attr . toString ( ) ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ is ▁ voided " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeIsVoided ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setVoided ( true ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ earlier ▁ date ▁ created " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasEarlierDateCreated ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setDateCreated ( new Date ( ) ) ; PersonAttribute other = new PersonAttribute ( ) ; pa . setDateCreated ( new Date ( pa . getDateCreated ( ) . getTime ( ) - 1000 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ type ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeTypeThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 2 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ not ▁ throw ▁ exception ▁ if ▁ attribute ▁ type ▁ is ▁ null " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldNotThrowExceptionIfAttributeTypeIdIsNull ( ) throws Exception { Assert . assertTrue ( new PersonAttribute ( 1 ) . compareTo ( new PersonAttribute ( 1 ) ) == 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ other ▁ attribute ▁ has ▁ lower ▁ value " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfOtherAttributeHasLowerValue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "2" ) ; PersonAttribute other = new PersonAttribute ( ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; other . setValue ( "1" ) ; Assert . assertTrue ( pa . compareTo ( other ) > 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ negative ▁ if ▁ this ▁ attribute ▁ has ▁ lower ▁ attribute ▁ id ▁ than ▁ argument " , method = " compareTo ( PersonAttribute ) " ) public void compareTo_shouldReturnNegativeIfThisAttributeHasLowerAttributeIdThanArgument ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 1 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( 2 ) ; other . setAttributeType ( new PersonAttributeType ( 1 ) ) ; Assert . assertTrue ( pa . compareTo ( other ) < 0 ) ; } @ Test @ Verifies ( value = " should ▁ return ▁ true ▁ if ▁ attributeType ▁ value ▁ and ▁ void ▁ status ▁ are ▁ the ▁ same " , method = " equalsContent ( PersonAttribute ) " ) public void equalsContent_shouldReturnTrueIfAttributeTypeValueAndVoidStatusAreTheSame ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; PersonAttribute other = new PersonAttribute ( 1 ) ; pa . setAttributeType ( new PersonAttributeType ( 1 ) ) ; pa . setValue ( "1" ) ; pa . setVoided ( false ) ; Assert . assertTrue ( pa . equalsContent ( other ) ) ; } @ Test @ Verifies ( value = " should ▁ load ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . Concept " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "5089" ) ; Concept concept = ( Concept ) pa . getHydratedObject ( ) ; Assert . assertEquals ( 5089 , concept . getConceptId ( ) . intValue ( ) ) ; } @ Test @ Verifies ( value = " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldLoadUserClassInFormatProperty ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " org . openmrs . User " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( "1" ) ; Object value = pa . getHydratedObject ( ) ; Assert . assertTrue ( " should ▁ load ▁ user ▁ class ▁ in ▁ format ▁ property " , ( value instanceof User ) ) ; } @ Test @ Verifies ( value = " should ▁ still ▁ load ▁ class ▁ in ▁ format ▁ property ▁ if ▁ not ▁ Attributable " , method = " getHydratedObject ( ) " ) public void getHydratedObject_shouldStillLoadClassInFormatPropertyIfNotAttributable ( ) throws Exception { PersonAttributeType type = new PersonAttributeType ( ) ; type . setFormat ( " java . lang . String " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setAttributeType ( type ) ; pa . setValue ( " lalapalooza " ) ; String value = ( String ) pa . getHydratedObject ( ) ; Assert . assertEquals ( " lalapalooza " , value ) ; } @ Test @ Verifies ( value = " should ▁ set ▁ voided ▁ bit ▁ to ▁ true " , method = " voidAttribute ( String ) " ) public void voidAttribute_shouldSetVoidedBitToTrue ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . setVoided ( false ) ; pa . voidAttribute ( " Because " ) ; Assert . assertTrue ( pa . isVoided ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="victos/opencms-core/tree/master/src-gwt/org/opencms/gwt/client/ui/history/CmsResourceHistoryTable.java"> package org . opencms . gwt . client . ui . history ; import org . opencms . gwt . client . CmsCoreProvider ; import org . opencms . gwt . client . ui . css . I_CmsCellTableResources ; import org . opencms . gwt . client . ui . css . I_CmsImageBundle ; import org . opencms . gwt . shared . CmsHistoryResourceBean ; import org . opencms . gwt . shared . CmsHistoryResourceCollection ; import com . google . common . base . Predicate ; import com . google . gwt . cell . client . AbstractCell ; import com . google . gwt . cell . client . ActionCell ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Style . Unit ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . user . cellview . client . CellTable ; import com . google . gwt . user . cellview . client . Column ; import com . google . gwt . user . cellview . client . IdentityColumn ; import com . google . gwt . user . cellview . client . TextColumn ; import com . google . gwt . view . client . ListDataProvider ; import com . google . gwt . view . client . ProvidesKey ; public class CmsResourceHistoryTable extends CellTable < CmsHistoryResourceBean > { static interface Templates extends SafeHtmlTemplates { @ Template ( " < span ▁ class = \ " {1 } \ " ▁ title = \ " {0 } \ " > < / span > " ) SafeHtml button ( String title , String cssClass ) ; @ Template ( " < span ▁ title = \ " {1 } \ " > { 0 } < / span > " ) SafeHtml textSpanWithTitle ( String text , String title ) ; } static Templates templates = GWT . create ( Templates . class ) ; private I_CmsHistoryActionHandler m_handler ; public CmsResourceHistoryTable ( CmsHistoryResourceCollection data , I_CmsHistoryActionHandler handler ) { super ( Integer . MAX_VALUE , ( CellTable . Resources ) GWT . create ( I_CmsCellTableResources . class ) , new ProvidesKey < CmsHistoryResourceBean > ( ) { public Object getKey ( CmsHistoryResourceBean item ) { return item . getStructureId ( ) + " _ " + item . getVersion ( ) ; } } ) ; m_handler = handler ; setWidth ( "100 % " , true ) ; setTableLayoutFixed ( true ) ; addVersionColumn ( ) ; addPreviewColumn ( ) ; addRevertColumn ( ) ; addPathColumn ( ) ; addSizeColumn ( ) ; addModificationDateColumn ( ) ; addUserLastModifiedColumn ( ) ; addPublishDateColumn ( ) ; ListDataProvider < CmsHistoryResourceBean > dataProvider = new ListDataProvider < CmsHistoryResourceBean > ( ) ; dataProvider . addDataDisplay ( this ) ; dataProvider . setList ( data . getResources ( ) ) ; } private void addColumn ( String label , int width , Column < CmsHistoryResourceBean , ? > col ) { addColumn ( col , label ) ; setColumnWidth ( col , width , Unit . PX ) ; } private void addModificationDateColumn ( ) { addColumn ( CmsHistoryMessages . columnModificationDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getModificationDate ( ) . getDateText ( ) ; } } ) ; } private void addPathColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { String path = historyRes . getRootPath ( ) ; String siteRoot = CmsCoreProvider . get ( ) . getSiteRoot ( ) ; if ( path . startsWith ( siteRoot ) ) { path = path . substring ( siteRoot . length ( ) ) ; if ( ! path . startsWith ( " / " ) ) { path = " / " + path ; } } return path ; } } ; addColumn ( col , CmsHistoryMessages . columnPath ( ) ) ; setColumnWidth ( col , 100 , Unit . PCT ) ; } private void addPreviewColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > previewCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titlePreview ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tablePreviewIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . showPreview ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return true ; } } ) ; addColumn ( CmsHistoryMessages . columnPreview ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( previewCell ) ) ; } private void addPublishDateColumn ( ) { addColumn ( CmsHistoryMessages . columnPublishDate ( ) , 190 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { if ( historyRes . getPublishDate ( ) != null ) { return historyRes . getPublishDate ( ) . getDateText ( ) ; } return " - " ; } } ) ; } private void addRevertColumn ( ) { CmsButtonCell < CmsHistoryResourceBean > replaceCell = new CmsButtonCell < CmsHistoryResourceBean > ( CmsHistoryMessages . titleRevert ( ) , I_CmsImageBundle . INSTANCE . style ( ) . tableReplaceIcon ( ) , new ActionCell . Delegate < CmsHistoryResourceBean > ( ) { @ SuppressWarnings ( " synthetic - access " ) public void execute ( CmsHistoryResourceBean historyRes ) { m_handler . revert ( historyRes ) ; } } , new Predicate < CmsHistoryResourceBean > ( ) { public boolean apply ( CmsHistoryResourceBean bean ) { return bean . getVersion ( ) . getVersionNumber ( ) != null ; } } ) ; addColumn ( CmsHistoryMessages . columnReplace ( ) , 30 , new IdentityColumn < CmsHistoryResourceBean > ( replaceCell ) ) ; } private void addSizeColumn ( ) { Column < CmsHistoryResourceBean , ? > col = new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return " " + historyRes . getSize ( ) ; } } ; addColumn ( col , CmsHistoryMessages . columnSize ( ) ) ; setColumnWidth ( col , 100 , Unit . PX ) ; } private void addUserLastModifiedColumn ( ) { addColumn ( CmsHistoryMessages . columnUserLastModified ( ) , 120 , new TextColumn < CmsHistoryResourceBean > ( ) { @ Override public String getValue ( CmsHistoryResourceBean historyRes ) { return historyRes . getUserLastModified ( ) ; } } ) ; } private void addVersionColumn ( ) { AbstractCell < CmsHistoryResourceBean > cell = new CmsVersionCell ( ) ; addColumn ( CmsHistoryMessages . columnVersion ( ) , 40 , new IdentityColumn < CmsHistoryResourceBean > ( cell ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="lucafavatella/intellij-community/tree/master/platform/platform-api/src/com/intellij/openapi/ide/KillRingTransferable.java"> package com . intellij . openapi . ide ; import com . intellij . openapi . editor . Document ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . annotations . Nullable ; import java . awt . datatransfer . DataFlavor ; import java . awt . datatransfer . StringSelection ; import java . awt . datatransfer . Transferable ; import java . awt . datatransfer . UnsupportedFlavorException ; import java . io . IOException ; import java . lang . ref . WeakReference ; public class KillRingTransferable implements Transferable { private static final DataFlavor [ ] DATA_FLAVORS = { DataFlavor . stringFlavor } ; private final String myData ; private final WeakReference < Document > myDocument ; private final int myStartOffset ; private final int myEndOffset ; private final boolean myCut ; private volatile boolean myReadyToCombine = true ; public KillRingTransferable ( @ NotNull String data , @ NotNull Document document , int startOffset , int endOffset , boolean cut ) { myData = data ; myDocument = new WeakReference < Document > ( document ) ; myStartOffset = startOffset ; myEndOffset = endOffset ; myCut = cut ; } @ Override public DataFlavor [ ] getTransferDataFlavors ( ) { return DATA_FLAVORS ; } @ Override public boolean isDataFlavorSupported ( DataFlavor flavor ) { return flavor == DataFlavor . stringFlavor ; } @ Nullable @ Override public Object getTransferData ( DataFlavor flavor ) throws UnsupportedFlavorException , IOException { return isDataFlavorSupported ( flavor ) ? myData : null ; } @ Nullable public Document getDocument ( ) { return myDocument . get ( ) ; } public int getStartOffset ( ) { return myStartOffset ; } public int getEndOffset ( ) { return myEndOffset ; } public boolean isCut ( ) { return myCut ; } public boolean isReadyToCombine ( ) { return myReadyToCombine ; } public void setReadyToCombine ( boolean readyToCombine ) { myReadyToCombine = readyToCombine ; } @ Override public String toString ( ) { return " data = ' " + myData + " ' , ▁ startOffset = " + myStartOffset + " , ▁ endOffset = " + myEndOffset + " , ▁ cut = " + myCut ; } } </DOCUMENT>
<DOCUMENT_ID="telerik/platform-friends-android/tree/master/Friends/facebook/src/main/java/com/facebook/internal/ImageResponseCache.java"> package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="nafae/developer/tree/master/modules/dfp_axis/src/main/java/com/google/api/ads/dfp/axis/v201308/ActivityGroupPage.java"> package com . google . api . ads . dfp . axis . v201308 ; public class ActivityGroupPage implements java . io . Serializable { private java . lang . Integer totalResultSetSize ; private java . lang . Integer startIndex ; private com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ; public ActivityGroupPage ( ) { } public ActivityGroupPage ( java . lang . Integer totalResultSetSize , java . lang . Integer startIndex , com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . totalResultSetSize = totalResultSetSize ; this . startIndex = startIndex ; this . results = results ; } public java . lang . Integer getTotalResultSetSize ( ) { return totalResultSetSize ; } public void setTotalResultSetSize ( java . lang . Integer totalResultSetSize ) { this . totalResultSetSize = totalResultSetSize ; } public java . lang . Integer getStartIndex ( ) { return startIndex ; } public void setStartIndex ( java . lang . Integer startIndex ) { this . startIndex = startIndex ; } public com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] getResults ( ) { return results ; } public void setResults ( com . google . api . ads . dfp . axis . v201308 . ActivityGroup [ ] results ) { this . results = results ; } public com . google . api . ads . dfp . axis . v201308 . ActivityGroup getResults ( int i ) { return this . results [ i ] ; } public void setResults ( int i , com . google . api . ads . dfp . axis . v201308 . ActivityGroup _value ) { this . results [ i ] = _value ; } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof ActivityGroupPage ) ) return false ; ActivityGroupPage other = ( ActivityGroupPage ) obj ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true && ( ( this . totalResultSetSize == null && other . getTotalResultSetSize ( ) == null ) || ( this . totalResultSetSize != null && this . totalResultSetSize . equals ( other . getTotalResultSetSize ( ) ) ) ) && ( ( this . startIndex == null && other . getStartIndex ( ) == null ) || ( this . startIndex != null && this . startIndex . equals ( other . getStartIndex ( ) ) ) ) && ( ( this . results == null && other . getResults ( ) == null ) || ( this . results != null && java . util . Arrays . equals ( this . results , other . getResults ( ) ) ) ) ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; if ( getTotalResultSetSize ( ) != null ) { _hashCode += getTotalResultSetSize ( ) . hashCode ( ) ; } if ( getStartIndex ( ) != null ) { _hashCode += getStartIndex ( ) . hashCode ( ) ; } if ( getResults ( ) != null ) { for ( int i = 0 ; i < java . lang . reflect . Array . getLength ( getResults ( ) ) ; i ++ ) { java . lang . Object obj = java . lang . reflect . Array . get ( getResults ( ) , i ) ; if ( obj != null && ! obj . getClass ( ) . isArray ( ) ) { _hashCode += obj . hashCode ( ) ; } } } __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( ActivityGroupPage . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroupPage " ) ) ; org . apache . axis . description . ElementDesc elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " totalResultSetSize " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " totalResultSetSize " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " startIndex " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " startIndex " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " http : // www . w3 . org / 2001 / XMLSchema " , " int " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( " results " ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " results " ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( " https : // www . google . com / apis / ads / publisher / v201308" , " ActivityGroup " ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( false ) ; elemField . setMaxOccursUnbounded ( true ) ; typeDesc . addFieldDesc ( elemField ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; } public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanDeserializer ( _javaType , _xmlType , typeDesc ) ; } } </DOCUMENT>
<DOCUMENT_ID="nezuvian/Library-webapp/tree/master/src/test/java/top2lz/libapp/web/rest/TestUtil.java"> package top2lz . libapp . web . rest ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . datatype . joda . JodaModule ; import com . fasterxml . jackson . datatype . joda . ser . DateTimeSerializer ; import com . fasterxml . jackson . datatype . joda . ser . JacksonJodaFormat ; import org . joda . time . DateTime ; import org . springframework . format . annotation . DateTimeFormat ; import org . springframework . format . datetime . joda . DateTimeFormatterFactory ; import org . springframework . http . MediaType ; import java . io . IOException ; import java . nio . charset . Charset ; public class TestUtil { public static final MediaType APPLICATION_JSON_UTF8 = new MediaType ( MediaType . APPLICATION_JSON . getType ( ) , MediaType . APPLICATION_JSON . getSubtype ( ) , Charset . forName ( " utf8" ) ) ; public static byte [ ] convertObjectToJsonBytes ( Object object ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; mapper . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ; JodaModule module = new JodaModule ( ) ; DateTimeFormatterFactory formatterFactory = new DateTimeFormatterFactory ( ) ; formatterFactory . setIso ( DateTimeFormat . ISO . DATE ) ; module . addSerializer ( DateTime . class , new DateTimeSerializer ( new JacksonJodaFormat ( formatterFactory . createDateTimeFormatter ( ) . withZoneUTC ( ) ) ) ) ; mapper . registerModule ( module ) ; return mapper . writeValueAsBytes ( object ) ; } } </DOCUMENT>
<DOCUMENT_ID="HasanAliKaraca/Telegram/tree/master/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java"> package org . telegram . ui . Adapters ; import android . content . Context ; import android . view . View ; import android . view . ViewGroup ; import org . telegram . android . MessageObject ; import org . telegram . android . MessagesController ; import org . telegram . android . UserObject ; import org . telegram . messenger . TLRPC ; import org . telegram . ui . Cells . MentionCell ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; public class MentionsAdapter extends BaseSearchAdapter { public interface MentionsAdapterDelegate { void needChangePanelVisibility ( boolean show ) ; } private Context mContext ; private TLRPC . ChatParticipants info ; private ArrayList < TLRPC . User > searchResultUsernames ; private ArrayList < String > searchResultHashtags ; private ArrayList < String > searchResultCommands ; private ArrayList < String > searchResultCommandsHelp ; private ArrayList < TLRPC . User > searchResultCommandsUsers ; private MentionsAdapterDelegate delegate ; private HashMap < Integer , TLRPC . BotInfo > botInfo ; private int resultStartPosition ; private int resultLength ; private String lastText ; private int lastPosition ; private ArrayList < MessageObject > messages ; private boolean needUsernames = true ; private boolean isDarkTheme ; private int botsCount ; public MentionsAdapter ( Context context , boolean isDarkTheme , MentionsAdapterDelegate delegate ) { mContext = context ; this . delegate = delegate ; this . isDarkTheme = isDarkTheme ; } public void setChatInfo ( TLRPC . ChatParticipants chatParticipants ) { info = chatParticipants ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void setNeedUsernames ( boolean value ) { needUsernames = value ; } public void setBotInfo ( HashMap < Integer , TLRPC . BotInfo > info ) { botInfo = info ; } public void setBotsCount ( int count ) { botsCount = count ; } @ Override public void clearRecentHashtags ( ) { super . clearRecentHashtags ( ) ; searchResultHashtags . clear ( ) ; notifyDataSetChanged ( ) ; if ( delegate != null ) { delegate . needChangePanelVisibility ( false ) ; } } @ Override protected void setHashtags ( ArrayList < HashtagObject > arrayList , HashMap < String , HashtagObject > hashMap ) { super . setHashtags ( arrayList , hashMap ) ; if ( lastText != null ) { searchUsernameOrHashtag ( lastText , lastPosition , messages ) ; } } public void searchUsernameOrHashtag ( String text , int position , ArrayList < MessageObject > messageObjects ) { if ( text == null || text . length ( ) == 0 ) { delegate . needChangePanelVisibility ( false ) ; lastText = null ; return ; } int searchPostion = position ; if ( text . length ( ) > 0 ) { searchPostion -- ; } lastText = null ; StringBuilder result = new StringBuilder ( ) ; int foundType = - 1 ; boolean hasIllegalUsernameCharacters = false ; for ( int a = searchPostion ; a >= 0 ; a -- ) { if ( a >= text . length ( ) ) { continue ; } char ch = text . charAt ( a ) ; if ( a == 0 || text . charAt ( a - 1 ) == ' ▁ ' || text . charAt ( a - 1 ) == ' \n ' ) { if ( needUsernames && ch == ' @ ' ) { if ( hasIllegalUsernameCharacters ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( info == null ) { lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 0 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } else if ( ch == ' # ' ) { if ( ! hashtagsLoadedFromDb ) { loadRecentHashtags ( ) ; lastText = text ; lastPosition = position ; messages = messageObjects ; delegate . needChangePanelVisibility ( false ) ; return ; } foundType = 1 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; result . insert ( 0 , ch ) ; break ; } else if ( a == 0 && botInfo != null && ch == ' / ' ) { foundType = 2 ; resultStartPosition = a ; resultLength = result . length ( ) + 1 ; break ; } } if ( ! ( ch >= '0' && ch <= '9' || ch >= ' a ' && ch <= ' z ' || ch >= ' A ' && ch <= ' Z ' || ch == ' _ ' ) ) { hasIllegalUsernameCharacters = true ; } result . insert ( 0 , ch ) ; } if ( foundType == - 1 ) { delegate . needChangePanelVisibility ( false ) ; return ; } if ( foundType == 0 ) { final ArrayList < Integer > users = new ArrayList < > ( ) ; for ( int a = 0 ; a < Math . min ( 100 , messageObjects . size ( ) ) ; a ++ ) { int from_id = messageObjects . get ( a ) . messageOwner . from_id ; if ( ! users . contains ( from_id ) ) { users . add ( from_id ) ; } } String usernameString = result . toString ( ) . toLowerCase ( ) ; ArrayList < TLRPC . User > newResult = new ArrayList < > ( ) ; for ( TLRPC . TL_chatParticipant chatParticipant : info . participants ) { TLRPC . User user = MessagesController . getInstance ( ) . getUser ( chatParticipant . user_id ) ; if ( user == null || UserObject . isUserSelf ( user ) ) { continue ; } if ( user . username != null && user . username . length ( ) > 0 && ( usernameString . length ( ) > 0 && user . username . toLowerCase ( ) . startsWith ( usernameString ) || usernameString . length ( ) == 0 ) ) { newResult . add ( user ) ; } } searchResultHashtags = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; searchResultUsernames = newResult ; Collections . sort ( searchResultUsernames , new Comparator < TLRPC . User > ( ) { @ Override public int compare ( TLRPC . User lhs , TLRPC . User rhs ) { int lhsNum = users . indexOf ( lhs . id ) ; int rhsNum = users . indexOf ( rhs . id ) ; if ( lhsNum != - 1 && rhsNum != - 1 ) { return lhsNum < rhsNum ? - 1 : ( lhsNum == rhsNum ? 0 : 1 ) ; } else if ( lhsNum != - 1 && rhsNum == - 1 ) { return - 1 ; } else if ( lhsNum == - 1 && rhsNum != - 1 ) { return 1 ; } return 0 ; } } ) ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 1 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; String hashtagString = result . toString ( ) . toLowerCase ( ) ; for ( HashtagObject hashtagObject : hashtags ) { if ( hashtagObject != null && hashtagObject . hashtag != null && hashtagObject . hashtag . startsWith ( hashtagString ) ) { newResult . add ( hashtagObject . hashtag ) ; } } searchResultHashtags = newResult ; searchResultUsernames = null ; searchResultCommands = null ; searchResultCommandsHelp = null ; searchResultCommandsUsers = null ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } else if ( foundType == 2 ) { ArrayList < String > newResult = new ArrayList < > ( ) ; ArrayList < String > newResultHelp = new ArrayList < > ( ) ; ArrayList < TLRPC . User > newResultUsers = new ArrayList < > ( ) ; String command = result . toString ( ) . toLowerCase ( ) ; for ( HashMap . Entry < Integer , TLRPC . BotInfo > entry : botInfo . entrySet ( ) ) { for ( TLRPC . TL_botCommand botCommand : entry . getValue ( ) . commands ) { if ( botCommand != null && botCommand . command != null && botCommand . command . startsWith ( command ) ) { newResult . add ( " / " + botCommand . command ) ; newResultHelp . add ( botCommand . description ) ; newResultUsers . add ( MessagesController . getInstance ( ) . getUser ( entry . getValue ( ) . user_id ) ) ; } } } searchResultHashtags = null ; searchResultUsernames = null ; searchResultCommands = newResult ; searchResultCommandsHelp = newResultHelp ; searchResultCommandsUsers = newResultUsers ; notifyDataSetChanged ( ) ; delegate . needChangePanelVisibility ( ! newResult . isEmpty ( ) ) ; } } public int getResultStartPosition ( ) { return resultStartPosition ; } public int getResultLength ( ) { return resultLength ; } @ Override public int getViewTypeCount ( ) { return 1 ; } @ Override public int getCount ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . size ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . size ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . size ( ) ; } return 0 ; } @ Override public boolean isEmpty ( ) { if ( searchResultUsernames != null ) { return searchResultUsernames . isEmpty ( ) ; } else if ( searchResultHashtags != null ) { return searchResultHashtags . isEmpty ( ) ; } else if ( searchResultCommands != null ) { return searchResultCommands . isEmpty ( ) ; } return true ; } @ Override public int getItemViewType ( int position ) { return 0 ; } @ Override public boolean hasStableIds ( ) { return true ; } @ Override public boolean areAllItemsEnabled ( ) { return true ; } @ Override public boolean isEnabled ( int position ) { return true ; } @ Override public Object getItem ( int i ) { if ( searchResultUsernames != null ) { if ( i < 0 || i >= searchResultUsernames . size ( ) ) { return null ; } return searchResultUsernames . get ( i ) ; } else if ( searchResultHashtags != null ) { if ( i < 0 || i >= searchResultHashtags . size ( ) ) { return null ; } return searchResultHashtags . get ( i ) ; } else if ( searchResultCommands != null ) { if ( i < 0 || i >= searchResultCommands . size ( ) ) { return null ; } if ( searchResultCommandsUsers != null && botsCount != 1 ) { return String . format ( " % s @ % s " , searchResultCommands . get ( i ) , searchResultCommandsUsers . get ( i ) . username ) ; } return searchResultCommands . get ( i ) ; } return null ; } public boolean isLongClickEnabled ( ) { return searchResultHashtags != null ; } public boolean isBotCommands ( ) { return searchResultCommands != null ; } @ Override public View getView ( int i , View view , ViewGroup viewGroup ) { if ( view == null ) { view = new MentionCell ( mContext ) ; ( ( MentionCell ) view ) . setIsDarkTheme ( isDarkTheme ) ; } if ( searchResultUsernames != null ) { ( ( MentionCell ) view ) . setUser ( searchResultUsernames . get ( i ) ) ; } else if ( searchResultHashtags != null ) { ( ( MentionCell ) view ) . setText ( searchResultHashtags . get ( i ) ) ; } else if ( searchResultCommands != null ) { ( ( MentionCell ) view ) . setBotCommand ( searchResultCommands . get ( i ) , searchResultCommandsHelp . get ( i ) , searchResultCommandsUsers . get ( i ) ) ; } return view ; } } </DOCUMENT>
<DOCUMENT_ID="34benma/openjdk/tree/master/nashorn/test/src/jdk/nashorn/internal/runtime/test/LexicalBindingTest.java"> package jdk . nashorn . internal . runtime . test ; import jdk . nashorn . api . scripting . NashornScriptEngineFactory ; import org . testng . annotations . Test ; import javax . script . Bindings ; import javax . script . ScriptContext ; import javax . script . ScriptEngine ; import javax . script . ScriptException ; import javax . script . SimpleScriptContext ; import static org . testng . Assert . assertEquals ; @ SuppressWarnings ( " javadoc " ) public class LexicalBindingTest { final static String LANGUAGE_ES6 = " - - language = es6" ; final static int NUMBER_OF_CONTEXTS = 20 ; final static int MEGAMORPHIC_LOOP_COUNT = 20 ; @ Test public static void megamorphicVarTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " var ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } @ Test public static void megamorphicMultiGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } } @ Test public static void megamorphicSingleGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } @ Test public static void megamorphicInheritedGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ Object . prototype . foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; } @ Test public static void multiThreadedLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final Bindings b = e . createBindings ( ) ; final ScriptContext origContext = e . getContext ( ) ; final ScriptContext newCtxt = new SimpleScriptContext ( ) ; newCtxt . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; final String sharedScript = " foo " ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' original ▁ context ' ; " , origContext ) , null ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' new ▁ context ' ; " , newCtxt ) , null ) ; final Thread t1 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t2 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " new ▁ context " , 1000 ) ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( e . eval ( " foo ▁ = ▁ ' newer ▁ context ' ; " , newCtxt ) , " newer ▁ context " ) ; final Thread t3 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t4 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " newer ▁ context " , 1000 ) ) ; t3 . start ( ) ; t4 . start ( ) ; t3 . join ( ) ; t4 . join ( ) ; assertEquals ( e . eval ( sharedScript ) , " original ▁ context " ) ; assertEquals ( e . eval ( sharedScript , newCtxt ) , " newer ▁ context " ) ; } private static class ScriptRunner implements Runnable { final ScriptEngine engine ; final ScriptContext context ; final String source ; final Object expected ; final int iterations ; ScriptRunner ( final ScriptEngine engine , final ScriptContext context , final String source , final Object expected , final int iterations ) { this . engine = engine ; this . context = context ; this . source = source ; this . expected = expected ; this . iterations = iterations ; } @ Override public void run ( ) { try { for ( int i = 0 ; i < iterations ; i ++ ) { assertEquals ( engine . eval ( source , context ) , expected ) ; } } catch ( final ScriptException se ) { throw new RuntimeException ( se ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="arunmk/CoreNLP/tree/master/test/src/edu/stanford/nlp/util/IterablesTest.java"> package edu . stanford . nlp . util ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . function . Function ; import junit . framework . Assert ; import junit . framework . TestCase ; public class IterablesTest extends TestCase { public void testZip ( ) { String [ ] s1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int count = 0 ; for ( Pair < String , Integer > pair : Iterables . zip ( s1 , s2 ) ) { assertEquals ( pair . first , s1 [ count ] ) ; assertEquals ( pair . second , s2 [ count ] ) ; count ++ ; } assertEquals ( s1 . length < s2 . length ? s1 . length : s2 . length , count ) ; } @ SuppressWarnings ( " unchecked " ) public void testChain ( ) { List < String > s1 = Arrays . asList ( new String [ ] { " hi " , " there " } ) ; List < String > s2 = Arrays . asList ( new String [ ] { } ) ; List < String > s3 = Arrays . asList ( new String [ ] { " yoo " } ) ; List < String > s4 = Arrays . asList ( new String [ ] { } ) ; List < String > answer = Arrays . asList ( new String [ ] { " yoo " , " hi " , " there " , " yoo " } ) ; List < String > chained = new ArrayList < String > ( ) ; for ( String s : Iterables . chain ( s3 , s1 , s2 , s3 , s4 ) ) { chained . add ( s ) ; } assertEquals ( answer , chained ) ; } public void testFilter ( ) { List < String > values = Arrays . asList ( " a " , " HI " , " tHere " , " YO " ) ; Iterator < String > iterator = Iterables . filter ( values , new Function < String , Boolean > ( ) { public Boolean apply ( String in ) { return in . equals ( in . toUpperCase ( ) ) ; } } ) . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( iterator . next ( ) , " HI " ) ; assertEquals ( iterator . next ( ) , " YO " ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testTransform ( ) { List < Integer > values = Arrays . asList ( 1 , 2 , 3 , 4 ) ; List < Integer > squares = Arrays . asList ( 1 , 4 , 9 , 16 ) ; Function < Integer , Integer > squarer = new Function < Integer , Integer > ( ) { public Integer apply ( Integer in ) { return in * in ; } } ; for ( Pair < Integer , Integer > pair : Iterables . zip ( Iterables . transform ( values , squarer ) , squares ) ) { assertEquals ( pair . first , pair . second ) ; } } public void testMerge ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Pair < String , String > > iter = Iterables . merge ( a , b , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " d " , " d " ) ) ; assertEquals ( iter . next ( ) , new Pair < String , String > ( " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testMerge3 ( ) { List < String > a = Arrays . asList ( " a " , " b " , " d " , " e " ) ; List < String > b = Arrays . asList ( " b " , " c " , " d " , " e " ) ; List < String > c = Arrays . asList ( " a " , " b " , " c " , " e " , " f " ) ; Comparator < String > comparator = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ; Iterator < Triple < String , String , String > > iter = Iterables . merge ( a , b , c , comparator ) . iterator ( ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( iter . next ( ) , new Triple < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! iter . hasNext ( ) ) ; } public void testGroup ( ) { String [ ] input = new String [ ] { "0 ▁ ab " , "0 ▁ bb " , "0 ▁ cc " , "1 ▁ dd " , "2 ▁ dd " , "2 ▁ kj " , "3 ▁ kj " , "3 ▁ kk " } ; int [ ] counts = new int [ ] { 3 , 1 , 2 , 2 } ; Comparator < String > fieldOne = new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return o1 . split ( " ▁ " ) [ 0 ] . compareTo ( o2 . split ( " ▁ " ) [ 0 ] ) ; } } ; int index = 0 ; int group = 0 ; for ( Iterable < String > set : Iterables . group ( Arrays . asList ( input ) , fieldOne ) ) { String sharedKey = null ; int thisCount = 0 ; for ( String line : set ) { String thisKey = line . split ( " ▁ " ) [ 0 ] ; if ( sharedKey == null ) { sharedKey = thisKey ; } else { assertEquals ( " Wrong ▁ key " , sharedKey , thisKey ) ; } assertEquals ( " Wrong ▁ input ▁ line " , line , input [ index ++ ] ) ; thisCount ++ ; } assertEquals ( " Wrong ▁ number ▁ of ▁ items ▁ in ▁ this ▁ iterator " , counts [ group ++ ] , thisCount ) ; } assertEquals ( " Didn ' t ▁ get ▁ all ▁ inputs " , input . length , index ) ; assertEquals ( " Wrong ▁ number ▁ of ▁ groups " , counts . length , group ) ; } public void testSample ( ) { Iterable < Integer > items = Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ; int count = 0 ; for ( Integer item : Iterables . sample ( items , 5 , 2 , new Random ( ) ) ) { ++ count ; Assert . assertTrue ( item <= 5 ) ; Assert . assertTrue ( item >= 1 ) ; } Assert . assertEquals ( 2 , count ) ; } } </DOCUMENT>
<DOCUMENT_ID="murador/ignite/tree/master/modules/core/src/main/java/org/apache/ignite/internal/GridJobSiblingsResponse.java"> package org . apache . ignite . internal ; import java . io . Externalizable ; import java . nio . ByteBuffer ; import java . util . Collection ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . compute . ComputeJobSibling ; import org . apache . ignite . internal . util . typedef . internal . S ; import org . apache . ignite . marshaller . Marshaller ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . plugin . extensions . communication . MessageReader ; import org . apache . ignite . plugin . extensions . communication . MessageWriter ; import org . jetbrains . annotations . Nullable ; public class GridJobSiblingsResponse implements Message { private static final long serialVersionUID = 0L ; @ GridDirectTransient private Collection < ComputeJobSibling > siblings ; private byte [ ] siblingsBytes ; public GridJobSiblingsResponse ( ) { } public GridJobSiblingsResponse ( @ Nullable Collection < ComputeJobSibling > siblings , @ Nullable byte [ ] siblingsBytes ) { this . siblings = siblings ; this . siblingsBytes = siblingsBytes ; } public Collection < ComputeJobSibling > jobSiblings ( ) { return siblings ; } public void unmarshalSiblings ( Marshaller marsh ) throws IgniteCheckedException { assert marsh != null ; if ( siblingsBytes != null ) siblings = marsh . unmarshal ( siblingsBytes , null ) ; } @ Override public void onAckReceived ( ) { } @ Override public boolean writeTo ( ByteBuffer buf , MessageWriter writer ) { writer . setBuffer ( buf ) ; if ( ! writer . isHeaderWritten ( ) ) { if ( ! writer . writeHeader ( directType ( ) , fieldsCount ( ) ) ) return false ; writer . onHeaderWritten ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . writeByteArray ( " siblingsBytes " , siblingsBytes ) ) return false ; writer . incrementState ( ) ; } return true ; } @ Override public boolean readFrom ( ByteBuffer buf , MessageReader reader ) { reader . setBuffer ( buf ) ; if ( ! reader . beforeMessageRead ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : siblingsBytes = reader . readByteArray ( " siblingsBytes " ) ; if ( ! reader . isLastRead ( ) ) return false ; reader . incrementState ( ) ; } return reader . afterMessageRead ( GridJobSiblingsResponse . class ) ; } @ Override public byte directType ( ) { return 4 ; } @ Override public byte fieldsCount ( ) { return 1 ; } @ Override public String toString ( ) { return S . toString ( GridJobSiblingsResponse . class , this ) ; } } </DOCUMENT>
<DOCUMENT_ID="noonehide/CoolW/tree/master/app/src/main/java/bauhinia/coolw/beans/City.java"> package bauhinia . coolw . beans ; import com . lidroid . xutils . db . annotation . Column ; import com . lidroid . xutils . db . annotation . Id ; import com . lidroid . xutils . db . annotation . Table ; @ Table ( name = " city " ) public class City { @ Id ( column = " _ id " ) int id ; @ Column ( column = " province _ name " ) String city_name ; @ Column ( column = " province _ code " ) String city_code ; @ Column ( column = " province _ id " ) int province_id ; public City ( ) { } public City ( String city_name , String city_code , int province_id ) { this . city_name = city_name ; this . city_code = city_code ; this . province_id = province_id ; } public int getProvince_id ( ) { return province_id ; } public void setProvince_id ( int province_id ) { this . province_id = province_id ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public String getCity_name ( ) { return city_name ; } public void setCity_name ( String city_name ) { this . city_name = city_name ; } public String getCity_code ( ) { return city_code ; } public void setCity_code ( String city_code ) { this . city_code = city_code ; } } </DOCUMENT>
<DOCUMENT_ID="ajhalani/elasticsearch/tree/master/src/main/java/org/elasticsearch/common/logging/log4j/LogConfigurator.java"> package org . elasticsearch . common . logging . log4j ; import com . google . common . collect . ImmutableMap ; import org . apache . log4j . PropertyConfigurator ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . settings . ImmutableSettings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . FailedToResolveConfigException ; import java . io . IOException ; import java . net . MalformedURLException ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . EnumSet ; import java . util . Map ; import java . util . Properties ; import static org . elasticsearch . common . settings . ImmutableSettings . settingsBuilder ; public class LogConfigurator { private static boolean loaded ; private static ImmutableMap < String , String > replacements = new MapBuilder < String , String > ( ) . put ( " console " , " org . elasticsearch . common . logging . log4j . ConsoleAppender " ) . put ( " async " , " org . apache . log4j . AsyncAppender " ) . put ( " dailyRollingFile " , " org . apache . log4j . DailyRollingFileAppender " ) . put ( " externallyRolledFile " , " org . apache . log4j . ExternallyRolledFileAppender " ) . put ( " file " , " org . apache . log4j . FileAppender " ) . put ( " jdbc " , " org . apache . log4j . jdbc . JDBCAppender " ) . put ( " jms " , " org . apache . log4j . net . JMSAppender " ) . put ( " lf5" , " org . apache . log4j . lf5 . LF5Appender " ) . put ( " ntevent " , " org . apache . log4j . nt . NTEventLogAppender " ) . put ( " null " , " org . apache . log4j . NullAppender " ) . put ( " rollingFile " , " org . apache . log4j . RollingFileAppender " ) . put ( " smtp " , " org . apache . log4j . net . SMTPAppender " ) . put ( " socket " , " org . apache . log4j . net . SocketAppender " ) . put ( " socketHub " , " org . apache . log4j . net . SocketHubAppender " ) . put ( " syslog " , " org . apache . log4j . net . SyslogAppender " ) . put ( " telnet " , " org . apache . log4j . net . TelnetAppender " ) . put ( " simple " , " org . apache . log4j . SimpleLayout " ) . put ( " html " , " org . apache . log4j . HTMLLayout " ) . put ( " pattern " , " org . apache . log4j . PatternLayout " ) . put ( " consolePattern " , " org . apache . log4j . PatternLayout " ) . put ( " ttcc " , " org . apache . log4j . TTCCLayout " ) . put ( " xml " , " org . apache . log4j . XMLLayout " ) . immutableMap ( ) ; public static void configure ( Settings settings ) { if ( loaded ) { return ; } loaded = true ; Environment environment = new Environment ( settings ) ; ImmutableSettings . Builder settingsBuilder = settingsBuilder ( ) . put ( settings ) ; resolveConfig ( environment , settingsBuilder ) ; settingsBuilder . putProperties ( " elasticsearch . " , System . getProperties ( ) ) . putProperties ( " es . " , System . getProperties ( ) ) . replacePropertyPlaceholders ( ) ; Properties props = new Properties ( ) ; for ( Map . Entry < String , String > entry : settingsBuilder . build ( ) . getAsMap ( ) . entrySet ( ) ) { String key = " log4j . " + entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( replacements . containsKey ( value ) ) { value = replacements . get ( value ) ; } if ( key . endsWith ( " . value " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . endsWith ( " . type " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { props . setProperty ( key , value ) ; } } PropertyConfigurator . configure ( props ) ; } public static void resolveConfig ( Environment env , final ImmutableSettings . Builder settingsBuilder ) { try { Files . walkFileTree ( env . configFile ( ) . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . startsWith ( " logging . " ) ) { loadConfig ( file , settingsBuilder ) ; } return FileVisitResult . CONTINUE ; } } ) ; } catch ( IOException ioe ) { throw new ElasticsearchException ( " Failed ▁ to ▁ load ▁ logging ▁ configuration " , ioe ) ; } } public static void loadConfig ( Path file , ImmutableSettings . Builder settingsBuilder ) { try { settingsBuilder . loadFromUrl ( file . toUri ( ) . toURL ( ) ) ; } catch ( FailedToResolveConfigException | NoClassDefFoundError | MalformedURLException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="IllusionRom-deprecated/android_platform_tools_idea/tree/master/java/java-analysis-impl/src/com/intellij/codeInspection/NumericOverflowInspection.java"> package com . intellij . codeInspection ; import com . intellij . codeInsight . daemon . GroupNames ; import com . intellij . codeInsight . daemon . JavaErrorMessages ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . util . Key ; import com . intellij . psi . * ; import com . intellij . psi . util . ConstantEvaluationOverflowException ; import com . intellij . psi . util . TypeConversionUtil ; import org . jetbrains . annotations . Nls ; import org . jetbrains . annotations . NotNull ; public class NumericOverflowInspection extends BaseJavaBatchLocalInspectionTool { private static final Key < String > HAS_OVERFLOW_IN_CHILD = Key . create ( " HAS _ OVERFLOW _ IN _ CHILD " ) ; @ Nls @ NotNull @ Override public String getGroupDisplayName ( ) { return GroupNames . NUMERIC_GROUP_NAME ; } @ Nls @ NotNull @ Override public String getDisplayName ( ) { return " Numeric ▁ overflow " ; } @ NotNull @ Override public String getShortName ( ) { return " NumericOverflow " ; } @ NotNull @ Override public PsiElementVisitor buildVisitor ( @ NotNull final ProblemsHolder holder , boolean isOnTheFly ) { return new JavaElementVisitor ( ) { @ Override public void visitReferenceExpression ( PsiReferenceExpression expression ) { visitExpression ( expression ) ; } @ Override public void visitExpression ( PsiExpression expression ) { boolean info = hasOverflow ( expression , holder . getProject ( ) ) ; if ( info ) { holder . registerProblem ( expression , JavaErrorMessages . message ( " numeric . overflow . in . expression " ) , ProblemHighlightType . GENERIC_ERROR_OR_WARNING ) ; } } } ; } private static boolean hasOverflow ( PsiExpression expr , @ NotNull Project project ) { if ( ! TypeConversionUtil . isNumericType ( expr . getType ( ) ) ) return false ; boolean overflow = false ; try { if ( expr . getUserData ( HAS_OVERFLOW_IN_CHILD ) == null ) { JavaPsiFacade . getInstance ( project ) . getConstantEvaluationHelper ( ) . computeConstantExpression ( expr , true ) ; } else { overflow = true ; } } catch ( ConstantEvaluationOverflowException e ) { overflow = true ; } finally { PsiElement parent = expr . getParent ( ) ; if ( overflow && parent instanceof PsiExpression ) { parent . putUserData ( HAS_OVERFLOW_IN_CHILD , " " ) ; } } return overflow ; } } </DOCUMENT>
<DOCUMENT_ID="clintjhill/saguaro/tree/master/src/com/stoneworks/BrickCanvasConverter.java"> package com . stoneworks ; import com . thoughtworks . xstream . converters . Converter ; import com . thoughtworks . xstream . converters . MarshallingContext ; import com . thoughtworks . xstream . converters . UnmarshallingContext ; import com . thoughtworks . xstream . io . HierarchicalStreamReader ; import com . thoughtworks . xstream . io . HierarchicalStreamWriter ; public class BrickCanvasConverter implements Converter { public BrickCanvasConverter ( ) { } public boolean canConvert ( Class type ) { return ( type == BrickCanvas . class ) ; } public void marshal ( Object source , HierarchicalStreamWriter writer , MarshallingContext context ) { BrickCanvas canvas = ( BrickCanvas ) source ; writer . startNode ( " canvasBackgroundImage " ) ; context . convertAnother ( canvas . getBackgroundImage ( ) ) ; writer . endNode ( ) ; writer . startNode ( " bricksOnCanvas " ) ; for ( Object obj : canvas . getBricks ( ) ) { if ( obj instanceof Brick ) { writer . startNode ( obj . getClass ( ) . getName ( ) ) ; context . convertAnother ( obj ) ; writer . endNode ( ) ; } } writer . endNode ( ) ; } public Object unmarshal ( HierarchicalStreamReader reader , UnmarshallingContext context ) { BrickCanvas canvas = BrickCanvas . getInstance ( ) ; while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( " canvasBackgroundImage " ) ) { canvas . setBackgroundImage ( ( BackgroundImage ) context . convertAnother ( reader , BackgroundImage . class ) ) ; } if ( reader . getNodeName ( ) . equals ( " bricksOnCanvas " ) ) { while ( reader . hasMoreChildren ( ) ) { reader . moveDown ( ) ; if ( reader . getNodeName ( ) . equals ( Brick . class . getName ( ) ) ) { canvas . getLayer ( ) . addChild ( ( Brick ) context . convertAnother ( reader , Brick . class ) ) ; } reader . moveUp ( ) ; } } reader . moveUp ( ) ; } return canvas ; } } </DOCUMENT>
<DOCUMENT_ID="popstr/undertow/tree/master/core/src/main/java/io/undertow/util/CanonicalPathUtils.java"> package io . undertow . util ; import java . util . ArrayList ; import java . util . List ; public class CanonicalPathUtils { public static String canonicalize ( final String path ) { int state = START ; for ( int i = path . length ( ) - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( c ) { case ' / ' : if ( state == FIRST_SLASH ) { return realCanonicalize ( path , i + 1 , FIRST_SLASH ) ; } else if ( state == ONE_DOT ) { return realCanonicalize ( path , i + 2 , FIRST_SLASH ) ; } else if ( state == TWO_DOT ) { return realCanonicalize ( path , i + 3 , FIRST_SLASH ) ; } state = FIRST_SLASH ; break ; case ' . ' : if ( state == FIRST_SLASH || state == START ) { state = ONE_DOT ; } else if ( state == ONE_DOT ) { state = TWO_DOT ; } else { state = NORMAL ; } break ; default : state = NORMAL ; break ; } } return path ; } static final int START = - 1 ; static final int NORMAL = 0 ; static final int FIRST_SLASH = 1 ; static final int ONE_DOT = 2 ; static final int TWO_DOT = 3 ; private static String realCanonicalize ( final String path , final int lastDot , final int initialState ) { int state = initialState ; int eatCount = 0 ; int tokenEnd = path . length ( ) ; final List < String > parts = new ArrayList < > ( ) ; for ( int i = lastDot - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( state ) { case NORMAL : { if ( c == ' / ' ) { state = FIRST_SLASH ; if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } } break ; } case FIRST_SLASH : { if ( c == ' . ' ) { state = ONE_DOT ; } else if ( c == ' / ' ) { if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } else { parts . add ( path . substring ( i + 1 , tokenEnd ) ) ; tokenEnd = i ; } } else { state = NORMAL ; } break ; } case ONE_DOT : { if ( c == ' . ' ) { state = TWO_DOT ; } else if ( c == ' / ' ) { if ( i + 2 != tokenEnd ) { parts . add ( path . substring ( i + 2 , tokenEnd ) ) ; } tokenEnd = i ; state = FIRST_SLASH ; } else { state = NORMAL ; } break ; } case TWO_DOT : { if ( c == ' / ' ) { if ( i + 3 != tokenEnd ) { parts . add ( path . substring ( i + 3 , tokenEnd ) ) ; } tokenEnd = i ; eatCount ++ ; state = FIRST_SLASH ; } else { state = NORMAL ; } } } } final StringBuilder result = new StringBuilder ( ) ; if ( tokenEnd != 0 ) { result . append ( path . substring ( 0 , tokenEnd ) ) ; } for ( int i = parts . size ( ) - 1 ; i >= 0 ; -- i ) { result . append ( parts . get ( i ) ) ; } if ( result . length ( ) == 0 ) { return " / " ; } return result . toString ( ) ; } private CanonicalPathUtils ( ) { } } </DOCUMENT>
<DOCUMENT_ID="pkdevbox/Kundera/tree/master/src/kundera-cassandra/cassandra-ds-driver/src/main/java/com/impetus/kundera/client/cassandra/dsdriver/DSIdGenerator.java"> package com . impetus . kundera . client . cassandra . dsdriver ; import java . util . UUID ; import com . datastax . driver . core . ResultSet ; import com . impetus . kundera . client . Client ; import com . impetus . kundera . generator . AutoGenerator ; public class DSIdGenerator implements AutoGenerator { @ Override public Object generate ( Client < ? > client , String dataType ) { final String generatedId = " Select ▁ now ( ) ▁ from ▁ system . schema _ columns " ; ResultSet rSet = ( ( DSClient ) client ) . execute ( generatedId , null ) ; UUID uuid = rSet . iterator ( ) . next ( ) . getUUID ( 0 ) ; return uuid ; } } </DOCUMENT>
<DOCUMENT_ID="akshayabd/jenkins/tree/master/core/src/main/java/hudson/model/ListView.java"> package hudson . model ; import hudson . Extension ; import hudson . Util ; import hudson . diagnosis . OldDataMonitor ; import hudson . model . Descriptor . FormException ; import hudson . model . listeners . ItemListener ; import hudson . security . ACL ; import hudson . util . CaseInsensitiveComparator ; import hudson . util . DescribableList ; import hudson . util . FormValidation ; import hudson . util . HttpResponses ; import hudson . views . ListViewColumn ; import hudson . views . ViewJobFilter ; import java . io . IOException ; import java . util . * ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import javax . annotation . concurrent . GuardedBy ; import javax . servlet . ServletException ; import jenkins . model . Jenkins ; import net . sf . json . JSONObject ; import org . kohsuke . accmod . Restricted ; import org . kohsuke . accmod . restrictions . NoExternalUse ; import org . kohsuke . stapler . DataBoundConstructor ; import org . kohsuke . stapler . HttpResponse ; import org . kohsuke . stapler . QueryParameter ; import org . kohsuke . stapler . StaplerRequest ; import org . kohsuke . stapler . StaplerResponse ; import org . kohsuke . stapler . interceptor . RequirePOST ; public class ListView extends View implements DirectlyModifiableView { @ GuardedBy ( " this " ) SortedSet < String > jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; private DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > jobFilters ; private DescribableList < ListViewColumn , Descriptor < ListViewColumn > > columns ; private String includeRegex ; private boolean recurse ; private transient Pattern includePattern ; private Boolean statusFilter ; @ DataBoundConstructor public ListView ( String name ) { super ( name ) ; initColumns ( ) ; initJobFilters ( ) ; } public ListView ( String name , ViewGroup owner ) { this ( name ) ; this . owner = owner ; } private Object readResolve ( ) { if ( includeRegex != null ) { try { includePattern = Pattern . compile ( includeRegex ) ; } catch ( PatternSyntaxException x ) { includeRegex = null ; OldDataMonitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( jobNames == null ) { jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; } initColumns ( ) ; initJobFilters ( ) ; return this ; } protected void initColumns ( ) { if ( columns == null ) columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this , ListViewColumn . createDefaultInitialColumnList ( ) ) ; } protected void initJobFilters ( ) { if ( jobFilters == null ) jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } public boolean hasJobFilterExtensions ( ) { return ! ViewJobFilter . all ( ) . isEmpty ( ) ; } public DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > getJobFilters ( ) { return jobFilters ; } @ Override public DescribableList < ListViewColumn , Descriptor < ListViewColumn > > getColumns ( ) { return columns ; } @ Override public List < TopLevelItem > getItems ( ) { SortedSet < String > names ; List < TopLevelItem > items = new ArrayList < TopLevelItem > ( ) ; synchronized ( this ) { names = new TreeSet < String > ( jobNames ) ; } ItemGroup < ? extends TopLevelItem > parent = getOwnerItemGroup ( ) ; List < TopLevelItem > parentItems = new ArrayList < TopLevelItem > ( parent . getItems ( ) ) ; includeItems ( parent , parentItems , names ) ; Boolean statusFilter = this . statusFilter ; Iterable < ? extends TopLevelItem > candidates ; if ( recurse ) { candidates = Items . getAllItems ( parent , TopLevelItem . class ) ; } else { candidates = parent . getItems ( ) ; } for ( TopLevelItem item : candidates ) { if ( ! names . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ) continue ; if ( statusFilter == null || ! ( item instanceof AbstractProject ) || ( ( AbstractProject ) item ) . isDisabled ( ) ^ statusFilter ) items . add ( item ) ; } Iterable < ViewJobFilter > jobFilters = getJobFilters ( ) ; List < TopLevelItem > allItems = new ArrayList < TopLevelItem > ( parentItems ) ; if ( recurse ) allItems = expand ( allItems , new ArrayList < TopLevelItem > ( ) ) ; for ( ViewJobFilter jobFilter : jobFilters ) { items = jobFilter . filter ( items , allItems , this ) ; } items = new ArrayList < TopLevelItem > ( new LinkedHashSet < TopLevelItem > ( items ) ) ; return items ; } private List < TopLevelItem > expand ( Collection < TopLevelItem > items , List < TopLevelItem > allItems ) { for ( TopLevelItem item : items ) { if ( item instanceof ItemGroup ) { ItemGroup < ? extends Item > ig = ( ItemGroup < ? extends Item > ) item ; expand ( Util . filter ( ig . getItems ( ) , TopLevelItem . class ) , allItems ) ; } allItems . add ( item ) ; } return allItems ; } @ Override public boolean contains ( TopLevelItem item ) { return getItems ( ) . contains ( item ) ; } private void includeItems ( ItemGroup < ? extends TopLevelItem > root , Collection < ? extends Item > parentItems , SortedSet < String > names ) { if ( includePattern != null ) { for ( Item item : parentItems ) { if ( recurse && item instanceof ItemGroup ) { ItemGroup < ? > ig = ( ItemGroup < ? > ) item ; includeItems ( root , ig . getItems ( ) , names ) ; } if ( item instanceof TopLevelItem ) { String itemName = item . getRelativeNameFrom ( root ) ; if ( includePattern . matcher ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } } public synchronized boolean jobNamesContains ( TopLevelItem item ) { if ( item == null ) return false ; return jobNames . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } @ Override public void add ( TopLevelItem item ) throws IOException { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } save ( ) ; } @ Override public boolean remove ( TopLevelItem item ) throws IOException { synchronized ( this ) { String name = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( ! jobNames . remove ( name ) ) return false ; } save ( ) ; return true ; } public String getIncludeRegex ( ) { return includeRegex ; } public boolean isRecurse ( ) { return recurse ; } public void setRecurse ( boolean recurse ) { this . recurse = recurse ; } public Boolean getStatusFilter ( ) { return statusFilter ; } @ Override @ RequirePOST public Item doCreateItem ( StaplerRequest req , StaplerResponse rsp ) throws IOException , ServletException { ItemGroup < ? extends TopLevelItem > ig = getOwnerItemGroup ( ) ; if ( ig instanceof ModifiableItemGroup ) { TopLevelItem item = ( ( ModifiableItemGroup < ? extends TopLevelItem > ) ig ) . doCreateItem ( req , rsp ) ; if ( item != null ) { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } owner . save ( ) ; } return item ; } return null ; } @ Override @ RequirePOST public HttpResponse doAddJobToView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( item == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ does ▁ not ▁ correspond ▁ to ▁ a ▁ known ▁ item " ) ; if ( contains ( item ) ) return HttpResponses . ok ( ) ; add ( item ) ; owner . save ( ) ; return HttpResponses . ok ( ) ; } @ Override @ RequirePOST public HttpResponse doRemoveJobFromView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( remove ( item ) ) owner . save ( ) ; return HttpResponses . ok ( ) ; } private TopLevelItem resolveName ( String name ) { TopLevelItem item = getOwnerItemGroup ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( getOwnerItemGroup ( ) , name ) ; item = Jenkins . getInstance ( ) . getItemByFullName ( name , TopLevelItem . class ) ; } return item ; } @ Override protected void submit ( StaplerRequest req ) throws ServletException , FormException , IOException { JSONObject json = req . getSubmittedForm ( ) ; synchronized ( this ) { recurse = json . optBoolean ( " recurse " , true ) ; jobNames . clear ( ) ; Iterable < ? extends TopLevelItem > items ; if ( recurse ) { items = Items . getAllItems ( getOwnerItemGroup ( ) , TopLevelItem . class ) ; } else { items = getOwnerItemGroup ( ) . getItems ( ) ; } for ( TopLevelItem item : items ) { String relativeNameFrom = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( req . getParameter ( relativeNameFrom ) != null ) { jobNames . add ( relativeNameFrom ) ; } } } setIncludeRegex ( req . getParameter ( " useincluderegex " ) != null ? req . getParameter ( " includeRegex " ) : null ) ; if ( columns == null ) { columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this ) ; } columns . rebuildHetero ( req , json , ListViewColumn . all ( ) , " columns " ) ; if ( jobFilters == null ) { jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } jobFilters . rebuildHetero ( req , json , ViewJobFilter . all ( ) , " jobFilters " ) ; String filter = Util . fixEmpty ( req . getParameter ( " statusFilter " ) ) ; statusFilter = filter != null ? "1" . equals ( filter ) : null ; } public void setIncludeRegex ( String includeRegex ) { this . includeRegex = Util . nullify ( includeRegex ) ; if ( this . includeRegex == null ) this . includePattern = null ; else this . includePattern = Pattern . compile ( includeRegex ) ; } @ Extension public static class DescriptorImpl extends ViewDescriptor { @ Override public String getDisplayName ( ) { return Messages . ListView_DisplayName ( ) ; } public FormValidation doCheckIncludeRegex ( @ QueryParameter String value ) throws IOException , ServletException , InterruptedException { String v = Util . fixEmpty ( value ) ; if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( PatternSyntaxException pse ) { return FormValidation . error ( pse . getMessage ( ) ) ; } } return FormValidation . ok ( ) ; } } @ Deprecated public static List < ListViewColumn > getDefaultColumns ( ) { return ListViewColumn . createDefaultInitialColumnList ( ) ; } @ Restricted ( NoExternalUse . class ) @ Extension public static final class Listener extends ItemListener { @ Override public void onLocationChanged ( final Item item , final String oldFullName , final String newFullName ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { locationChanged ( item , oldFullName , newFullName ) ; } } ) ; } private void locationChanged ( Item item , String oldFullName , String newFullName ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { renameViewItem ( oldFullName , newFullName , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { renameViewItem ( oldFullName , newFullName , vg , ( ListView ) v ) ; } } } } } private void renameViewItem ( String oldFullName , String newFullName , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { Set < String > oldJobNames = new HashSet < String > ( lv . jobNames ) ; lv . jobNames . clear ( ) ; for ( String oldName : oldJobNames ) { lv . jobNames . add ( Items . computeRelativeNamesAfterRenaming ( oldFullName , newFullName , oldName , vg . getItemGroup ( ) ) ) ; } needsSave = ! oldJobNames . equals ( lv . jobNames ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } @ Override public void onDeleted ( final Item item ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { deleted ( item ) ; } } ) ; } private void deleted ( Item item ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { deleteViewItem ( item , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { deleteViewItem ( item , vg , ( ListView ) v ) ; } } } } } private void deleteViewItem ( Item item , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { needsSave = lv . jobNames . remove ( item . getRelativeNameFrom ( vg . getItemGroup ( ) ) ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="bhaveshdt/camel/tree/master/components/camel-freemarker/src/test/java/org/apache/camel/component/freemarker/FruitFilter.java"> package org . apache . camel . component . freemarker ; public class FruitFilter { public boolean isApple ( String body ) { return " apple " . equalsIgnoreCase ( body ) ; } public boolean isOrange ( String body ) { return " orange " . equalsIgnoreCase ( body ) ; } } </DOCUMENT>
<DOCUMENT_ID="likaiwalkman/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="pentaho/pentaho-kettle/tree/master/core/src/main/java/org/pentaho/di/core/Props.java"> package org . pentaho . di . core ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; import java . util . Properties ; import org . pentaho . di . core . exception . KettleValueException ; import org . pentaho . di . core . logging . LogChannel ; import org . pentaho . di . core . logging . LogChannelInterface ; import org . pentaho . di . core . row . ValueMetaInterface ; import org . pentaho . di . core . util . SortedFileOutputStream ; import org . pentaho . di . i18n . BaseMessages ; public class Props implements Cloneable { private static Class < ? > PKG = Const . class ; private static final String STRING_USER_PREFERENCES = " User ▁ preferences " ; protected static Props props ; public static final String STRING_FONT_FIXED_NAME = " FontFixedName " ; public static final String STRING_FONT_FIXED_SIZE = " FontFixedSize " ; public static final String STRING_FONT_FIXED_STYLE = " FontFixedStyle " ; public static final String STRING_FONT_DEFAULT_NAME = " FontDefaultName " ; public static final String STRING_FONT_DEFAULT_SIZE = " FontDefaultSize " ; public static final String STRING_FONT_DEFAULT_STYLE = " FontDefaultStyle " ; public static final String STRING_FONT_GRAPH_NAME = " FontGraphName " ; public static final String STRING_FONT_GRAPH_SIZE = " FontGraphSize " ; public static final String STRING_FONT_GRAPH_STYLE = " FontGraphStyle " ; public static final String STRING_FONT_GRID_NAME = " FontGridName " ; public static final String STRING_FONT_GRID_SIZE = " FontGridSize " ; public static final String STRING_FONT_GRID_STYLE = " FontGridStyle " ; public static final String STRING_FONT_NOTE_NAME = " FontNoteName " ; public static final String STRING_FONT_NOTE_SIZE = " FontNoteSize " ; public static final String STRING_FONT_NOTE_STYLE = " FontNoteStyle " ; public static final String STRING_BACKGROUND_COLOR_R = " BackgroundColorR " ; public static final String STRING_BACKGROUND_COLOR_G = " BackgroundColorG " ; public static final String STRING_BACKGROUND_COLOR_B = " BackgroundColorB " ; public static final String STRING_GRAPH_COLOR_R = " GraphColorR " ; public static final String STRING_GRAPH_COLOR_G = " GraphColorG " ; public static final String STRING_GRAPH_COLOR_B = " GraphColorB " ; public static final String STRING_TAB_COLOR_R = " TabColorR54" ; public static final String STRING_TAB_COLOR_G = " TabColorG54" ; public static final String STRING_TAB_COLOR_B = " TabColorB54" ; public static final String STRING_SVG_ENABLED = " EnableSVG " ; public static final String STRING_ICON_SIZE = " IconSize " ; public static final String STRING_LINE_WIDTH = " LineWidth " ; public static final String STRING_SHADOW_SIZE = " ShadowSize54" ; public static final String STRING_LOG_LEVEL = " LogLevel " ; public static final String STRING_LOG_FILTER = " LogFilter " ; public static final String STRING_MIDDLE_PCT = " MiddlePct " ; public static final String STRING_INDICATE_SLOW_TRANS_STEPS = " IndicateSlowTransSteps " ; public static final String STRING_LAST_PREVIEW_TRANS = " LastPreviewTrans " ; public static final String STRING_LAST_PREVIEW_STEP = " LastPreviewStep " ; public static final String STRING_LAST_PREVIEW_SIZE = " LastPreviewSize " ; public static final String STRING_MAX_UNDO = " MaxUndo " ; public static final String STRING_SIZE_MAX = " SizeMax " ; public static final String STRING_SIZE_X = " SizeX " ; public static final String STRING_SIZE_Y = " SizeY " ; public static final String STRING_SIZE_W = " SizeW " ; public static final String STRING_SIZE_H = " SizeH " ; public static final String STRING_SASH_W1 = " SashWeight1" ; public static final String STRING_SASH_W2 = " SashWeight2" ; public static final String STRING_AUTO_SAVE = " AutoSave " ; public static final String STRING_SAVE_CONF = " SaveConfirmation " ; public static final String STRING_AUTO_SPLIT = " AutoSplit " ; public static final String STRING_AUTO_COLLAPSE_CORE_TREE = " AutoCollapseCoreObjectsTree " ; public static final String STRING_USE_DB_CACHE = " UseDBCache " ; public static final String STRING_OPEN_LAST_FILE = " OpenLastFile " ; public static final String STRING_LAST_REPOSITORY_LOGIN = " RepositoryLastLogin " ; public static final String STRING_LAST_REPOSITORY = " RepositoryLast " ; public static final String STRING_ONLY_ACTIVE_STEPS = " OnlyActiveSteps " ; public static final String STRING_START_SHOW_REPOSITORIES = " ShowRepositoriesAtStartup " ; public static final String STRING_ANTI_ALIASING = " EnableAntiAliasing54" ; public static final String STRING_SHOW_CANVAS_GRID = " ShowCanvasGrid " ; public static final String STRING_SHOW_EXIT_WARNING = " ShowExitWarning " ; public static final String STRING_SHOW_OS_LOOK = " ShowOSLook54" ; public static final String STRING_LAST_ARGUMENT = " LastArgument " ; public static final String STRING_ARGUMENT_NAME_PREFIX = " Argument ▁ " ; public static final String STRING_CUSTOM_PARAMETER = " CustomParameter " ; public static final String STRING_PLUGIN_HISTORY = " PluginHistory " ; public static final String STRING_DEFAULT_PREVIEW_SIZE = " DefaultPreviewSize " ; public static final String STRING_ONLY_USED_DB_TO_XML = " SaveOnlyUsedConnectionsToXML " ; public static final String STRING_ASK_ABOUT_REPLACING_DATABASES = " AskAboutReplacingDatabases " ; public static final String STRING_REPLACE_DATABASES = " ReplaceDatabases " ; private static final String STRING_MAX_NR_LINES_IN_LOG = " MaxNrOfLinesInLog " ; private static final String STRING_MAX_NR_LINES_IN_HISTORY = " MaxNrOfLinesInHistory " ; private static final String STRING_LINES_IN_HISTORY_FETCH_SIZE = " LinesInHistoryFetchSize " ; public static final String STRING_DISABLE_INITIAL_EXECUTION_HISTORY = " DisableInitialExecutionHistory " ; private static final String STRING_MAX_LOG_LINE_TIMEOUT_MINUTES = " MaxLogLineTimeOutMinutes " ; public static final String STRING_RECENT_SEARCHES = " RecentSearches " ; public static final String STRING_SHOW_NEW_SUBTRANS_POPUP = " ShowNewSubtransPopup " ; protected LogChannelInterface log ; protected Properties properties ; protected ArrayList < ObjectUsageCount > pluginHistory ; protected int type ; protected String filename ; public static final int TYPE_PROPERTIES_EMPTY = 0 ; public static final int TYPE_PROPERTIES_SPOON = 1 ; public static final int TYPE_PROPERTIES_PAN = 2 ; public static final int TYPE_PROPERTIES_CHEF = 3 ; public static final int TYPE_PROPERTIES_KITCHEN = 4 ; public static final int TYPE_PROPERTIES_MENU = 5 ; public static final int TYPE_PROPERTIES_PLATE = 6 ; public static final int WIDGET_STYLE_DEFAULT = 0 ; public static final int WIDGET_STYLE_FIXED = 1 ; public static final int WIDGET_STYLE_TABLE = 2 ; public static final int WIDGET_STYLE_NOTEPAD = 3 ; public static final int WIDGET_STYLE_GRAPH = 4 ; public static final int WIDGET_STYLE_TAB = 5 ; public static final int WIDGET_STYLE_TOOLBAR = 6 ; public static final void init ( int t ) { if ( props == null ) { props = new Props ( t ) ; } else { throw new RuntimeException ( " The ▁ Properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } public static final void init ( String filename ) { if ( props == null ) { props = new Props ( filename ) ; } else { throw new RuntimeException ( " The ▁ properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } } public static boolean isInitialized ( ) { return props != null ; } public static Props getInstance ( ) { if ( props != null ) { return props ; } throw new RuntimeException ( " Properties , ▁ Kettle ▁ systems ▁ settings , ▁ not ▁ initialised ! " ) ; } protected Props ( ) { init ( ) ; } protected Props ( int t ) { type = t ; filename = getFilename ( ) ; init ( ) ; } protected void init ( ) { createLogChannel ( ) ; properties = new Properties ( ) ; pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; loadProps ( ) ; addDefaultEntries ( ) ; loadPluginHistory ( ) ; } protected Props ( String filename ) { properties = new Properties ( ) ; this . type = TYPE_PROPERTIES_EMPTY ; this . filename = filename ; init ( ) ; } @ Override public String toString ( ) { return STRING_USER_PREFERENCES ; } protected void createLogChannel ( ) { log = new LogChannel ( STRING_USER_PREFERENCES ) ; } public String getFilename ( ) { String filename = " " ; String directory = Const . getKettleDirectory ( ) ; switch ( type ) { case TYPE_PROPERTIES_SPOON : case TYPE_PROPERTIES_PAN : filename = directory + Const . FILE_SEPARATOR + " . spoonrc " ; break ; case TYPE_PROPERTIES_CHEF : case TYPE_PROPERTIES_KITCHEN : filename = directory + Const . FILE_SEPARATOR + " . chefrc " ; break ; case TYPE_PROPERTIES_MENU : filename = directory + Const . FILE_SEPARATOR + " . menurc " ; break ; case TYPE_PROPERTIES_PLATE : filename = directory + Const . FILE_SEPARATOR + " . platerc " ; break ; default : break ; } return filename ; } public String getLicenseFilename ( ) { String directory = Const . getKettleDirectory ( ) ; String filename = directory + Const . FILE_SEPARATOR + " . licence " ; File dir = new File ( directory ) ; if ( ! dir . exists ( ) ) { try { dir . mkdirs ( ) ; } catch ( Exception e ) { } } return filename ; } public boolean fileExists ( ) { File f = new File ( filename ) ; return f . exists ( ) ; } public void setType ( int t ) { type = t ; } public int getType ( ) { return type ; } public boolean loadProps ( ) { try { FileInputStream fis = new FileInputStream ( filename ) ; try { properties . load ( fis ) ; } finally { try { fis . close ( ) ; } catch ( IOException ignored ) { } } } catch ( Exception e ) { return false ; } return true ; } protected void addDefaultEntries ( ) { if ( ! properties . containsKey ( " JobDialogStyle " ) ) { properties . setProperty ( " JobDialogStyle " , " RESIZE , MAX , MIN " ) ; } } public void saveProps ( ) { File spoonRc = new File ( filename ) ; try { SortedFileOutputStream fos = new SortedFileOutputStream ( spoonRc ) ; fos . setLogger ( log ) ; properties . store ( fos , " Kettle ▁ Properties ▁ file " ) ; fos . close ( ) ; log . logDetailed ( BaseMessages . getString ( PKG , " Spoon . Log . SaveProperties " ) ) ; } catch ( IOException e ) { if ( spoonRc . isHidden ( ) && filename . indexOf ( ' \\ ' ) != - 1 ) { log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailedWindowsBugAttr " , filename ) ) ; } else { log . logError ( BaseMessages . getString ( PKG , " Spoon . Log . SavePropertiesFailed " ) + e . getMessage ( ) ) ; } } } public void setLogLevel ( String level ) { properties . setProperty ( STRING_LOG_LEVEL , level ) ; } public String getLogLevel ( ) { String level = properties . getProperty ( STRING_LOG_LEVEL , " Basic " ) ; return level ; } public void setLogFilter ( String filter ) { properties . setProperty ( STRING_LOG_FILTER , Const . NVL ( filter , " " ) ) ; } public String getLogFilter ( ) { String level = properties . getProperty ( STRING_LOG_FILTER , " " ) ; return level ; } public void setUseDBCache ( boolean use ) { properties . setProperty ( STRING_USE_DB_CACHE , use ? " Y " : " N " ) ; } public boolean useDBCache ( ) { String use = properties . getProperty ( STRING_USE_DB_CACHE ) ; return ! " N " . equalsIgnoreCase ( use ) ; } public void setLastRepository ( String repname ) { properties . setProperty ( STRING_LAST_REPOSITORY , repname ) ; } public String getLastRepository ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY ) ; } public void setLastRepositoryLogin ( String login ) { properties . setProperty ( STRING_LAST_REPOSITORY_LOGIN , login ) ; } public String getLastRepositoryLogin ( ) { return properties . getProperty ( STRING_LAST_REPOSITORY_LOGIN ) ; } public void setOnlyActiveSteps ( boolean only ) { properties . setProperty ( STRING_ONLY_ACTIVE_STEPS , only ? " Y " : " N " ) ; } public boolean getOnlyActiveSteps ( ) { String only = properties . getProperty ( STRING_ONLY_ACTIVE_STEPS , " N " ) ; return " Y " . equalsIgnoreCase ( only ) ; } public boolean askAboutReplacingDatabaseConnections ( ) { String ask = properties . getProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , " N " ) ; return " Y " . equalsIgnoreCase ( ask ) ; } public void setProperty ( String propertyName , String value ) { properties . setProperty ( propertyName , value ) ; } public String getProperty ( String propertyName ) { return properties . getProperty ( propertyName ) ; } public void setAskAboutReplacingDatabaseConnections ( boolean ask ) { properties . setProperty ( STRING_ASK_ABOUT_REPLACING_DATABASES , ask ? " Y " : " N " ) ; } public String getCustomParameter ( String parameterName , String defaultValue ) { return properties . getProperty ( STRING_CUSTOM_PARAMETER + parameterName , defaultValue ) ; } public void setCustomParameter ( String parameterName , String value ) { properties . setProperty ( STRING_CUSTOM_PARAMETER + parameterName , value ) ; } public void clearCustomParameters ( ) { Enumeration < Object > keys = properties . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; if ( key . startsWith ( STRING_CUSTOM_PARAMETER ) ) { properties . remove ( key ) ; } } } public static final int getArgumentNumber ( ValueMetaInterface value ) { if ( value != null && value . getName ( ) . startsWith ( Props . STRING_ARGUMENT_NAME_PREFIX ) ) { return Const . toInt ( value . getName ( ) . substring ( Props . STRING_ARGUMENT_NAME_PREFIX . length ( ) ) , - 1 ) ; } return - 1 ; } public static final String [ ] convertArguments ( RowMetaAndData row ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < row . size ( ) ; i ++ ) { ValueMetaInterface valueMeta = row . getValueMeta ( i ) ; int argNr = getArgumentNumber ( valueMeta ) ; if ( argNr >= 0 && argNr < 10 ) { try { args [ argNr ] = row . getString ( i , " " ) ; } catch ( KettleValueException e ) { args [ argNr ] = " " ; } } } return args ; } public void setLastArguments ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] != null ) { properties . setProperty ( STRING_LAST_ARGUMENT + " _ " + i , args [ i ] ) ; } } } public String [ ] getLastArguments ( ) { String [ ] args = new String [ 10 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = properties . getProperty ( STRING_LAST_ARGUMENT + " _ " + i ) ; } return args ; } public List < ObjectUsageCount > getPluginHistory ( ) { return pluginHistory ; } public int increasePluginHistory ( String pluginID ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; if ( usage . getObjectName ( ) . equalsIgnoreCase ( pluginID ) ) { int uses = usage . increment ( ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return uses ; } } addPluginHistory ( pluginID , 1 ) ; Collections . sort ( pluginHistory ) ; savePluginHistory ( ) ; return 1 ; } public void addPluginHistory ( String pluginID , int uses ) { pluginHistory . add ( new ObjectUsageCount ( pluginID , uses ) ) ; } protected void loadPluginHistory ( ) { pluginHistory = new ArrayList < ObjectUsageCount > ( ) ; int i = 0 ; String string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; while ( string != null ) { pluginHistory . add ( ObjectUsageCount . fromString ( string ) ) ; i ++ ; string = properties . getProperty ( STRING_PLUGIN_HISTORY + " _ " + i ) ; } Collections . sort ( pluginHistory ) ; } private void savePluginHistory ( ) { for ( int i = 0 ; i < pluginHistory . size ( ) ; i ++ ) { ObjectUsageCount usage = pluginHistory . get ( i ) ; properties . setProperty ( STRING_PLUGIN_HISTORY + " _ " + i , usage . toString ( ) ) ; } } public boolean areOnlyUsedConnectionsSavedToXML ( ) { String show = properties . getProperty ( STRING_ONLY_USED_DB_TO_XML , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; } public void setOnlyUsedConnectionsSavedToXML ( boolean onlyUsedConnections ) { properties . setProperty ( STRING_ONLY_USED_DB_TO_XML , onlyUsedConnections ? " Y " : " N " ) ; } public boolean replaceExistingDatabaseConnections ( ) { String replace = properties . getProperty ( STRING_REPLACE_DATABASES , " Y " ) ; return " Y " . equalsIgnoreCase ( replace ) ; } public void setReplaceDatabaseConnections ( boolean replace ) { properties . setProperty ( STRING_REPLACE_DATABASES , replace ? " Y " : " N " ) ; } public boolean showNewSubtransPopup ( ) { String show = properties . getProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , " Y " ) ; return " Y " . equalsIgnoreCase ( show ) ; } public void setShowNewSubtransPopup ( boolean show ) { properties . setProperty ( STRING_SHOW_NEW_SUBTRANS_POPUP , show ? " Y " : " N " ) ; } public int getMaxNrLinesInLog ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_LOG ) ; return Const . toInt ( lines , Const . MAX_NR_LOG_LINES ) ; } public void setMaxNrLinesInLog ( int maxNrLinesInLog ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_LOG , Integer . toString ( maxNrLinesInLog ) ) ; } public int getMaxNrLinesInHistory ( ) { String lines = properties . getProperty ( STRING_MAX_NR_LINES_IN_HISTORY ) ; return Const . toInt ( lines , Const . MAX_NR_HISTORY_LINES ) ; } public int getLinesInHistoryFetchSize ( ) { String fetchSize = properties . getProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE ) ; return Const . toInt ( fetchSize , Const . HISTORY_LINES_FETCH_SIZE ) ; } public boolean disableInitialExecutionHistory ( ) { String disable = properties . getProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , " N " ) ; return " Y " . equalsIgnoreCase ( disable ) ; } public void setMaxNrLinesInHistory ( int maxNrLinesInHistory ) { properties . setProperty ( STRING_MAX_NR_LINES_IN_HISTORY , Integer . toString ( maxNrLinesInHistory ) ) ; } public void setLinesInHistoryFetchSize ( int linesInHistoryFetchSize ) { properties . setProperty ( STRING_LINES_IN_HISTORY_FETCH_SIZE , Integer . toString ( linesInHistoryFetchSize ) ) ; } public void setDisableInitialExecutionHistory ( boolean disable ) { properties . setProperty ( STRING_DISABLE_INITIAL_EXECUTION_HISTORY , disable ? " Y " : " N " ) ; } public int getMaxLogLineTimeoutMinutes ( ) { String minutes = properties . getProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES ) ; return Const . toInt ( minutes , Const . MAX_LOG_LINE_TIMEOUT_MINUTES ) ; } public void setMaxLogLineTimeoutMinutes ( int maxLogLineTimeoutMinutes ) { properties . setProperty ( STRING_MAX_LOG_LINE_TIMEOUT_MINUTES , Integer . toString ( maxLogLineTimeoutMinutes ) ) ; } public void reset ( ) { props = null ; properties . clear ( ) ; pluginHistory . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="mstine/polyglot-osgi/tree/master/lib/osgi/felix/org.apache.felix.framework-1.8.1/src/main/java/org/apache/felix/framework/util/JarFileX.java"> package org . apache . felix . framework . util ; import java . io . File ; import java . io . IOException ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . zip . ZipEntry ; public class JarFileX extends JarFile { public JarFileX ( File file ) throws IOException { super ( file ) ; } public JarFileX ( File file , boolean verify ) throws IOException { super ( file , verify ) ; } public JarFileX ( File file , boolean verify , int mode ) throws IOException { super ( file , verify , mode ) ; } public JarFileX ( String name ) throws IOException { super ( name ) ; } public JarFileX ( String name , boolean verify ) throws IOException { super ( name , verify ) ; } public ZipEntry getEntry ( String name ) { ZipEntry entry = super . getEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { ZipEntry dirEntry = super . getEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } public JarEntry getJarEntry ( String name ) { JarEntry entry = super . getJarEntry ( name ) ; if ( ( entry != null ) && ( entry . getSize ( ) == 0 ) && ! entry . isDirectory ( ) ) { JarEntry dirEntry = super . getJarEntry ( name + ' / ' ) ; if ( dirEntry != null ) { entry = dirEntry ; } } return entry ; } } </DOCUMENT>
<DOCUMENT_ID="sklintyg/infra/tree/master/sjukfall/engine/src/test/java/se/inera/intyg/infra/sjukfall/engine/SjukfallIntygEnhetCreatorTest.java"> package se . inera . intyg . infra . sjukfall . engine ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import java . io . IOException ; import java . time . LocalDate ; import java . util . List ; import java . util . Map ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . junit . MockitoJUnitRunner ; import se . inera . intyg . infra . sjukfall . dto . IntygData ; import se . inera . intyg . infra . sjukfall . dto . IntygParametrar ; import se . inera . intyg . infra . sjukfall . dto . SjukfallIntyg ; import se . inera . intyg . infra . sjukfall . testdata . SjukfallIntygGenerator ; @ RunWith ( MockitoJUnitRunner . class ) public class SjukfallIntygEnhetCreatorTest { private static final String LOCATION_INTYGSDATA = " classpath : Sjukfall / Enhet / intygsdata - creator . csv " ; private static List < IntygData > intygDataList ; private SjukfallIntygEnhetCreator creator ; private IntygParametrar parameters ; @ BeforeClass public static void initTestData ( ) throws IOException { SjukfallIntygGenerator generator = new SjukfallIntygGenerator ( LOCATION_INTYGSDATA ) ; intygDataList = generator . generate ( ) . get ( ) ; assertTrue ( " Expected ▁ 16 ▁ but ▁ was ▁ " + intygDataList . size ( ) , intygDataList . size ( ) == 16 ) ; } @ Before public void setup ( ) { creator = new SjukfallIntygEnhetCreator ( ) ; parameters = new IntygParametrar ( 5 , LocalDate . parse ( "2016-02-16" ) ) ; } @ Test public void testCreatingMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; assertTrue ( " Expected ▁ 7 ▁ but ▁ was ▁ " + map . size ( ) , map . size ( ) == 7 ) ; } @ Test public void testReducedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > reducedMap = creator . reduceMap ( map ) ; assertTrue ( " Expected ▁ 6 ▁ but ▁ was ▁ " + reducedMap . size ( ) , reducedMap . size ( ) == 6 ) ; } @ Test public void testSortedMap ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > sortedMap = creator . sortValues ( map ) ; for ( Map . Entry < String , List < SjukfallIntyg > > entry : sortedMap . entrySet ( ) ) { if ( entry . getValue ( ) . size ( ) > 1 ) { SjukfallIntyg [ ] arr = entry . getValue ( ) . toArray ( new SjukfallIntyg [ entry . getValue ( ) . size ( ) ] ) ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { assertTrue ( arr [ i ] . getSlutDatum ( ) . isBefore ( arr [ i + 1 ] . getSlutDatum ( ) ) ) ; } } } } @ Test public void testSetActiveCertificate ( ) { Map < String , List < SjukfallIntyg > > map = creator . createMap ( intygDataList , parameters ) ; Map < String , List < SjukfallIntyg > > activeMap = creator . setActive ( map ) ; assertTrue ( activeMap . entrySet ( ) . stream ( ) . allMatch ( e -> e . getValue ( ) . stream ( ) . filter ( o -> o . isAktivtIntyg ( ) ) . count ( ) < 2 ) ) ; } @ Test public void testFall1 ( ) { String key = "19791110-9291" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall2 ( ) { String key = "19791123-9262" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-20" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall3 ( ) { String key = "19791212-9280" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall4 ( ) { String key = "19800113-9297" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 3 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-01" ) ; assertEndDate ( list . get ( 2 ) , "2016-02-25" ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall5 ( ) { String key = "19800124-9286" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertTrue ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertFalse ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall6 ( ) { String key = "19800207-9294" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Expected ▁ 2 ▁ but ▁ was ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assertStartDate ( list . get ( 0 ) , "2016-02-12" ) ; assertEndDate ( list . get ( 1 ) , "2016-02-25" ) ; assertFalse ( list . get ( 0 ) . isAktivtIntyg ( ) ) ; assertTrue ( list . get ( 1 ) . isAktivtIntyg ( ) ) ; } @ Test public void testFall7 ( ) { String key = "19800228-9224" ; Map < String , List < SjukfallIntyg > > map = creator . create ( intygDataList , parameters ) ; assertNull ( map . get ( key ) ) ; } private static void assertStartDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getStartDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } private static void assertEndDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getSlutDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="sg26565/hott-transmitter-config/tree/master/lzma-sdk/src/main/java/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
<DOCUMENT_ID="maxammann/SimpleClans2/tree/master/SimpleClans2/src/main/java/com/p000ison/dev/simpleclans2/converter/Converter.java"> package com . p000ison . dev . simpleclans2 . converter ; import com . p000ison . dev . simpleclans2 . api . KillType ; import com . p000ison . dev . simpleclans2 . api . logging . Logging ; import com . p000ison . dev . sqlapi . jbdc . JBDCDatabase ; import org . json . simple . JSONArray ; import org . json . simple . JSONObject ; import org . json . simple . parser . JSONParser ; import org . json . simple . parser . ParseException ; import java . sql . * ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; @ SuppressWarnings ( " unchecked " ) public class Converter implements Runnable { private JBDCDatabase from ; private JBDCDatabase to ; private PreparedStatement insertClan , insertBB , updateClan , insertKill ; private PreparedStatement insertClanPlayer ; private Set < ConvertedClan > clans = new HashSet < ConvertedClan > ( ) ; private Set < ConvertedClanPlayer > players = new HashSet < ConvertedClanPlayer > ( ) ; public Converter ( JBDCDatabase from , JBDCDatabase to ) { this . from = from ; this . to = to ; insertBB = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ bb ` ▁ ( ` clan ` , ▁ ` text ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? ▁ ) ; " ) ; updateClan = to . prepare ( " UPDATE ▁ ` sc2 _ clans ` ▁ SET ▁ allies ▁ = ▁ ? , ▁ rivals ▁ = ▁ ? , ▁ warring ▁ = ▁ ? ▁ WHERE ▁ id ▁ = ▁ ? ; " ) ; insertKill = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ kills ` ▁ ( ▁ ` attacker ` , ▁ ` attacker _ clan ` , ▁ ` victim ` , ▁ ` victim _ clan ` , ▁ ` war ` , ▁ ` type ` , ▁ ` date ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; prepareClan ( ) ; prepareClanPlayer ( ) ; } private void prepareClan ( ) { if ( insertClan != null ) { try { insertClan . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClan = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ clans ` ▁ ( ` name ` , ▁ ` tag ` , ▁ ` verified ` , ▁ ` founded ` , ▁ ` last _ action ` , ▁ ` flags ` , ▁ ` balance ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; } private void prepareClanPlayer ( ) { if ( insertClanPlayer != null ) { try { insertClanPlayer . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClanPlayer = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ players ` ▁ ( ▁ ` name ` , ▁ ` leader ` , ▁ ` trusted ` , ▁ ` join _ date ` , ▁ ` last _ seen ` , ▁ ` clan ` , ▁ ` neutral _ kills ` , ▁ ` rival _ Kills ` , ▁ ` civilian _ Kills ` , ▁ ` deaths ` , ▁ ` flags ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) " ) ; } public void convertAll ( ) { try { convertClans ( ) ; convertPlayers ( ) ; convertKills ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } clans = null ; players = null ; } @ Override public void run ( ) { convertAll ( ) ; } public void convertPlayers ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ players ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; try { JSONParser parser = new JSONParser ( ) ; String flagsString = result . getString ( " flags " ) ; JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; boolean friendlyFire = result . getBoolean ( " friendly _ fire " ) ; boolean bb = ( Boolean ) object . get ( " bb - enabled " ) ; boolean cape = ( Boolean ) object . get ( " cape - enabled " ) ; if ( friendlyFire ) { flags . put ( " ff " , friendlyFire ) ; } if ( bb ) { flags . put ( " bb " , bb ) ; } if ( cape ) { flags . put ( " cape " , cape ) ; } } catch ( ParseException e ) { e . printStackTrace ( ) ; continue ; } String name = result . getString ( " name " ) ; insertPlayer ( name , result . getBoolean ( " leader " ) , result . getBoolean ( " trusted " ) , result . getLong ( " join _ date " ) , result . getLong ( " last _ seen " ) , getIDByTag ( result . getString ( " tag " ) ) , result . getInt ( " neutral _ kills " ) , result . getInt ( " rival _ kills " ) , result . getInt ( " civilian _ kills " ) , result . getInt ( " deaths " ) , flags . toJSONString ( ) ) ; ResultSet idResult = to . query ( " SELECT ▁ id ▁ FROM ▁ ` sc2 _ players ` ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ) ; idResult . next ( ) ; players . add ( new ConvertedClanPlayer ( idResult . getLong ( " id " ) , name ) ) ; } } public void insertPlayer ( String name , boolean leader , boolean trusted , long joinDate , long lastSeen , long clan , int neutralKills , int rivalKills , int civilianKills , int deaths , String flags ) throws SQLException { insertClanPlayer . setString ( 1 , name ) ; insertClanPlayer . setBoolean ( 2 , leader ) ; insertClanPlayer . setBoolean ( 3 , trusted ) ; insertClanPlayer . setTimestamp ( 4 , new Timestamp ( joinDate ) ) ; insertClanPlayer . setTimestamp ( 5 , new Timestamp ( lastSeen ) ) ; insertClanPlayer . setLong ( 6 , clan ) ; insertClanPlayer . setInt ( 7 , neutralKills ) ; insertClanPlayer . setInt ( 8 , rivalKills ) ; insertClanPlayer . setInt ( 9 , civilianKills ) ; insertClanPlayer . setInt ( 10 , deaths ) ; if ( flags != null ) { insertClanPlayer . setString ( 11 , flags ) ; } else { insertClanPlayer . setNull ( 11 , Types . VARCHAR ) ; } try { insertClanPlayer . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clanPlayer ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClanPlayer ( ) ; } } public long getClanPlayerIDbyName ( String tag ) { for ( ConvertedClanPlayer cp : players ) { if ( cp . getName ( ) . equals ( tag ) ) { return cp . getId ( ) ; } } return - 1 ; } public void convertClans ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ clans ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; String name = result . getString ( " name " ) ; String tag = result . getString ( " tag " ) ; boolean verified = result . getBoolean ( " verified " ) ; boolean friendly_fire = result . getBoolean ( " friendly _ fire " ) ; long founded = result . getLong ( " founded " ) ; long last_used = result . getLong ( " last _ used " ) ; String flagsString = result . getString ( " flags " ) ; String cape = result . getString ( " cape _ url " ) ; ConvertedClan clan = new ConvertedClan ( tag ) ; clan . setPackedAllies ( result . getString ( " packed _ allies " ) ) ; clan . serPackedRivals ( result . getString ( " packed _ rivals " ) ) ; if ( friendly_fire ) { flags . put ( " ff " , friendly_fire ) ; } if ( cape != null && ! cape . isEmpty ( ) ) { flags . put ( " cape - url " , cape ) ; } JSONParser parser = new JSONParser ( ) ; try { JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; String world = object . get ( " homeWorld " ) . toString ( ) ; if ( ! world . isEmpty ( ) ) { int x = ( ( Long ) object . get ( " homeX " ) ) . intValue ( ) ; int y = ( ( Long ) object . get ( " homeY " ) ) . intValue ( ) ; int z = ( ( Long ) object . get ( " homeZ " ) ) . intValue ( ) ; flags . put ( " home " , x + " : " + y + " : " + z + " : " + world + " : 0:0" ) ; } clan . setRawWarring ( ( JSONArray ) object . get ( " warring " ) ) ; } catch ( ParseException e ) { Logging . debug ( e , true ) ; continue ; } insertClan ( name , tag , verified , founded , last_used , flags . isEmpty ( ) ? null : flags . toJSONString ( ) , result . getDouble ( " balance " ) ) ; String selectLastQuery = " SELECT ▁ ` id ` ▁ FROM ▁ ` sc2 _ clans ` ▁ ORDER ▁ BY ▁ ID ▁ DESC ▁ LIMIT ▁ 1 ; " ; ResultSet selectLast = to . query ( selectLastQuery ) ; selectLast . next ( ) ; clan . setId ( selectLast . getLong ( " id " ) ) ; selectLast . close ( ) ; insertBB ( Arrays . asList ( result . getString ( " packed _ bb " ) . split ( " \\s * ( \\ | | $ ) " ) ) , clan . getId ( ) ) ; clans . add ( clan ) ; } for ( ConvertedClan clan : clans ) { JSONArray allies = new JSONArray ( ) ; JSONArray rivals = new JSONArray ( ) ; JSONArray warring = new JSONArray ( ) ; for ( String allyTag : clan . getRawAllies ( ) ) { long allyID = getIDByTag ( allyTag ) ; if ( allyID != - 1 ) { allies . add ( allyID ) ; } } for ( String rivalTag : clan . getRawAllies ( ) ) { long rivalID = getIDByTag ( rivalTag ) ; if ( rivalID != - 1 ) { rivals . add ( rivalID ) ; } } for ( String warringTag : clan . getRawWarring ( ) ) { long warringID = getIDByTag ( warringTag ) ; if ( warringID != - 1 ) { warring . add ( warringID ) ; } } if ( ! allies . isEmpty ( ) ) { updateClan . setString ( 1 , allies . toJSONString ( ) ) ; } else { updateClan . setNull ( 1 , Types . VARCHAR ) ; } if ( ! rivals . isEmpty ( ) ) { updateClan . setString ( 2 , rivals . toJSONString ( ) ) ; } else { updateClan . setNull ( 2 , Types . VARCHAR ) ; } if ( ! warring . isEmpty ( ) ) { updateClan . setString ( 3 , warring . toJSONString ( ) ) ; } else { updateClan . setNull ( 3 , Types . VARCHAR ) ; } updateClan . setLong ( 4 , clan . getId ( ) ) ; updateClan . executeUpdate ( ) ; } } public long getIDByTag ( String tag ) { for ( ConvertedClan clan : clans ) { if ( clan . getTag ( ) . equals ( tag ) ) { return clan . getId ( ) ; } } return - 1 ; } public void insertBB ( List < String > bb , long clan ) throws SQLException { for ( String text : bb ) { insertBB . setLong ( 1 , clan ) ; insertBB . setString ( 2 , text ) ; insertBB . executeUpdate ( ) ; } } public void insertClan ( String name , String tag , boolean verified , long founded , long last_action , String flags , double balance ) throws SQLException { insertClan . setString ( 1 , name ) ; insertClan . setString ( 2 , tag ) ; insertClan . setBoolean ( 3 , verified ) ; insertClan . setTimestamp ( 4 , new Timestamp ( founded ) ) ; insertClan . setTimestamp ( 5 , new Timestamp ( last_action ) ) ; if ( flags != null ) { insertClan . setString ( 6 , flags ) ; } else { insertClan . setNull ( 6 , Types . VARCHAR ) ; } insertClan . setDouble ( 7 , balance ) ; try { insertClan . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clan ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClan ( ) ; } } public void convertKills ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ kills ` ; " ) ; while ( result . next ( ) ) { Timestamp date ; try { date = result . getTimestamp ( " date " ) ; } catch ( Exception e ) { date = new Timestamp ( System . currentTimeMillis ( ) ) ; } insertKill ( result . getString ( " attacker " ) , result . getString ( " attacker _ tag " ) , result . getString ( " victim " ) , result . getString ( " victim _ tag " ) , result . getString ( " kill _ type " ) , result . getBoolean ( " war " ) , date ) ; } } public void insertKill ( String attacker , String attacker_clan , String victim , String victim_clan , String type , boolean war , Timestamp date ) throws SQLException { long attackerID = getClanPlayerIDbyName ( attacker ) ; if ( attackerID == - 1 ) { return ; } long victimID = getClanPlayerIDbyName ( victim ) ; if ( victimID == - 1 ) { return ; } insertKill . setLong ( 1 , attackerID ) ; insertKill . setLong ( 2 , getIDByTag ( attacker_clan ) ) ; insertKill . setLong ( 3 , victimID ) ; insertKill . setLong ( 4 , getIDByTag ( victim_clan ) ) ; KillType realType ; switch ( type . charAt ( 0 ) ) { case ' c ' : realType = KillType . CIVILIAN ; break ; case ' n ' : realType = KillType . NEUTRAL ; break ; case ' r ' : realType = KillType . RIVAL ; break ; default : throw new UnsupportedOperationException ( " Failed ▁ at ▁ inserting ▁ kill ! ▁ Type ▁ not ▁ found : ▁ " + type ) ; } insertKill . setByte ( 5 , realType . getType ( ) ) ; insertKill . setBoolean ( 6 , war ) ; insertKill . setTimestamp ( 7 , date ) ; insertKill . executeUpdate ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="volyrique/FrameworkBenchmarks/tree/master/frameworks/Java/dropwizard/src/main/java/com/example/helloworld/HelloJDBIService.java"> package com . example . helloworld ; import com . example . helloworld . db . jdbi . FortuneRepository ; import io . dropwizard . Application ; import io . dropwizard . jdbi3 . JdbiFactory ; import io . dropwizard . jdbi3 . bundles . JdbiExceptionsBundle ; import io . dropwizard . setup . Bootstrap ; import io . dropwizard . setup . Environment ; import io . dropwizard . views . ViewBundle ; import org . jdbi . v3 . core . Jdbi ; import com . example . helloworld . config . HelloWorldConfiguration ; import com . example . helloworld . db . jdbi . WorldRepository ; import com . example . helloworld . resources . FortuneResource ; import com . example . helloworld . resources . WorldResource ; public class HelloJDBIService extends Application < HelloWorldConfiguration > { public static void main ( String [ ] args ) throws Exception { new HelloJDBIService ( ) . run ( args ) ; } @ Override public void initialize ( Bootstrap < HelloWorldConfiguration > bootstrap ) { bootstrap . addBundle ( new ViewBundle < > ( ) ) ; bootstrap . addBundle ( new JdbiExceptionsBundle ( ) ) ; } @ Override public void run ( HelloWorldConfiguration config , Environment environment ) { final JdbiFactory factory = new JdbiFactory ( ) ; final Jdbi jdbi = factory . build ( environment , config . getDatabaseConfiguration ( ) , " RDBMS " ) ; environment . jersey ( ) . register ( new WorldResource ( new WorldRepository ( jdbi ) ) ) ; environment . jersey ( ) . register ( new FortuneResource ( new FortuneRepository ( jdbi ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="beano/gocd/tree/master/plugin-infra/go-plugin-infra/test/com/thoughtworks/go/plugin/infra/MultipleExtensionPluginWithPluginManagerIntegrationTest.java"> package com . thoughtworks . go . plugin . infra ; import java . io . File ; import java . io . IOException ; import com . thoughtworks . go . util . SystemEnvironment ; import com . thoughtworks . go . plugin . activation . DefaultGoPluginActivator ; import com . thoughtworks . go . plugin . infra . listeners . DefaultPluginJarChangeListener ; import com . thoughtworks . go . plugin . infra . monitor . PluginFileDetails ; import com . thoughtworks . go . plugin . infra . plugininfo . GoPluginDescriptor ; import org . apache . commons . io . FileUtils ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_ACTIVATOR_JAR_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_BUNDLE_PATH ; import static com . thoughtworks . go . util . SystemEnvironment . PLUGIN_FRAMEWORK_ENABLED ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . MatcherAssert . assertThat ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { " classpath : / applicationContext - plugin - infra . xml " } ) public class MultipleExtensionPluginWithPluginManagerIntegrationTest { public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 = " testplugin . multiple . extension . DescriptorPlugin1 . setPluginDescriptor . invoked " ; public static final String PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 = " testplugin . multiple . extension . DescriptorPlugin2 . setPluginDescriptor . invoked " ; private static final String PLUGIN_DIR_NAME = " . / tmp - DefPlgnMgrIntTest " ; private static final String BUNDLE_DIR_NAME = " . / tmp - bundles - DefPlgnMgrIntTest " ; private static final File PLUGIN_DIR = new File ( PLUGIN_DIR_NAME ) ; private static final File BUNDLE_DIR = new File ( BUNDLE_DIR_NAME ) ; private static final String PLUGIN_ID = " testplugin . multiple . extension " ; @ Autowired DefaultPluginManager pluginManager ; @ Autowired DefaultPluginJarChangeListener jarChangeListener ; @ Autowired SystemEnvironment systemEnvironment ; static { System . setProperty ( PLUGIN_ACTIVATOR_JAR_PATH . propertyName ( ) , " defaultFiles / go - plugin - activator . jar " ) ; System . setProperty ( PLUGIN_BUNDLE_PATH . propertyName ( ) , BUNDLE_DIR_NAME ) ; System . setProperty ( PLUGIN_FRAMEWORK_ENABLED . propertyName ( ) , " Y " ) ; } private static File pathOfFileInDefaultFiles ( String filePath ) { return new File ( MultipleExtensionPluginWithPluginManagerIntegrationTest . class . getClassLoader ( ) . getResource ( " defaultFiles / " + filePath ) . getFile ( ) ) ; } @ Test public void shouldProvideDescriptorToMultipleExtensionsImplementingThePluginDescriptorAwareInterface ( ) throws Exception { GoPluginDescriptor plugin = pluginManager . getPluginDescriptorFor ( PLUGIN_ID ) ; assertThat ( plugin . id ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleSymbolicName ( ) , is ( PLUGIN_ID ) ) ; assertThat ( plugin . bundleClassPath ( ) , is ( " lib / go - plugin - activator . jar , . " ) ) ; assertThat ( plugin . bundleActivator ( ) , is ( DefaultGoPluginActivator . class . getCanonicalName ( ) ) ) ; assertThat ( plugin . isInvalid ( ) , is ( false ) ) ; assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) , is ( plugin . toString ( ) ) ) ; assertThat ( System . getProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) , is ( plugin . toString ( ) ) ) ; } @ Before public void setUpPluginInfrastructure ( ) throws IOException { PLUGIN_DIR . mkdirs ( ) ; BUNDLE_DIR . mkdirs ( ) ; try { pluginManager . startInfrastructure ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } jarChangeListener . pluginJarAdded ( new PluginFileDetails ( pathOfFileInDefaultFiles ( " plugin - with - multiple - extensions . jar " ) , false ) ) ; } @ After public void tearDown ( ) throws Exception { System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_1 ) ; System . clearProperty ( PLUGIN_DESC_PROPERTY_SET_BY_PLUGIN_EXT_2 ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; pluginManager . stopInfrastructure ( ) ; FileUtils . deleteQuietly ( PLUGIN_DIR ) ; FileUtils . deleteQuietly ( BUNDLE_DIR ) ; } } </DOCUMENT>
