<DOCUMENT_ID="crockpotveggies/deeplearning4j/tree/master/deeplearning4j-ui-parent/deeplearning4j-ui/src/test/java/org/deeplearning4j/ui/weights/HistogramBinTest.java"> package org . deeplearning4j . ui . weights ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import java . math . BigDecimal ; import static org . junit . Assert . assertEquals ; public class HistogramBinTest { @ Before public void setUp ( ) throws Exception { } @ Test public void testGetBins ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getBins ( ) ) ; assertEquals ( 2 , histogram . getBins ( ) . getDouble ( 9 ) , 0.001 ) ; } @ Test public void testGetData1 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; } @ Test public void testGetData2 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } @ Test public void testGetData4 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 50 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 50 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="farkas-arpad/KROKI-mockup-tool/tree/master/GraphEdit/src/graphedit/state/SelectionState.java"> package graphedit . state ; import graphedit . actions . popup . LinkPopupMenu ; import graphedit . app . MainFrame ; import graphedit . command . ChangeAssociationPropertiesCommand ; import graphedit . command . ChangeElementPropertiesCommand ; import graphedit . command . ChangeLinkTypeCommand ; import graphedit . command . Command ; import graphedit . gui . dialog . AssociationLinkDialog ; import graphedit . gui . dialog . ClassElementDialog ; import graphedit . model . components . AggregationLink ; import graphedit . model . components . AssociationLink ; import graphedit . model . components . Class ; import graphedit . model . components . CompositionLink ; import graphedit . model . components . GraphElement ; import graphedit . model . components . Link ; import graphedit . model . components . LinkNode ; import graphedit . model . components . Package ; import graphedit . model . properties . PropertyEnums . GraphElementProperties ; import graphedit . view . AggregationLinkPainter ; import graphedit . view . AssociationLinkPainter ; import graphedit . view . CompositionLinkPainter ; import graphedit . view . ElementPainter ; import graphedit . view . LinkPainter ; import java . awt . Cursor ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . geom . Dimension2D ; import java . awt . geom . Point2D ; import java . util . ArrayList ; import java . util . List ; import javax . swing . SwingUtilities ; public class SelectionState extends State { private Point2D popupPoint ; public SelectionState ( ) { super ( ) ; } @ Override public void mouseReleased ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isRightMouseButton ( e ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; if ( hitElement != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; showGraphElementPopup ( e ) ; } else if ( hitLink != null || hitNode != null ) { showLinkElementPopup ( e ) ; } else showGraphElementPopup ( e ) ; view . repaint ( ) ; } } @ Override public void mousePressed ( MouseEvent e ) { Link hitLink = controller . getCurrentLink ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; GraphElement hitElement = controller . getCurrentElement ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null ) view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; else { view . getSelectionModel ( ) . setSelectedLink ( null ) ; if ( hitElement != null ) { if ( e . isControlDown ( ) ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeSelectedElement ( hitElement ) ; } else { view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } else { if ( ! view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { if ( ! e . isControlDown ( ) ) view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; } } } else if ( SwingUtilities . isRightMouseButton ( e ) ) { if ( hitElement != null ) { view . getSelectionModel ( ) . setSelectedLink ( null ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } else if ( hitNode != null ) { view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; } } view . repaint ( ) ; } @ Override public void mouseDragged ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = view . getSelectionModel ( ) . getSelectedNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null || ( hitLink != null && hitElement == null ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; state . mousePressed ( e ) ; } else if ( hitElement != null ) { if ( MainFrame . getInstance ( ) . getCurrentView ( ) . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { if ( e . isControlDown ( ) ) { } if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; ( ( MoveElementState ) state ) . setElements ( view . getSelectionModel ( ) . getSelectedElements ( ) ) ; ( ( MoveElementState ) state ) . setRightMove ( false ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getResizeState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . mousePressed ( e ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getLassoSelectionState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else if ( SwingUtilities . isRightMouseButton ( e ) && hitElement != null ) { if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; List < GraphElement > shadowElements = new ArrayList < GraphElement > ( ) ; List < ElementPainter > shadowPainters = new ArrayList < ElementPainter > ( ) ; for ( GraphElement element : view . getSelectionModel ( ) . getSelectedElements ( ) ) { try { GraphElement clone = ( GraphElement ) element . clone ( ) ; clone . setShadowElement ( true ) ; ElementPainter clonePainter = ( ElementPainter ) view . getElementPainter ( element ) . clone ( ) ; clonePainter . setElement ( clone ) ; shadowElements . add ( clone ) ; shadowPainters . add ( clonePainter ) ; } catch ( CloneNotSupportedException e1 ) { e1 . printStackTrace ( ) ; } } view . setShadowPainters ( shadowPainters ) ; ( ( MoveElementState ) state ) . setElements ( shadowElements ) ; ( ( MoveElementState ) state ) . setRightMove ( true ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else { if ( hitElement != null ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { } } } } @ Override public void mouseMoved ( MouseEvent e ) { int xPos = e . getX ( ) ; int yPos = e . getY ( ) ; MainFrame . getInstance ( ) . setPositionTrack ( xPos , yPos ) ; if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) == 1 ) { GraphElement selectedElement = view . getSelectionModel ( ) . getSelectedElements ( ) . get ( 0 ) ; Dimension2D size = ( Dimension2D ) selectedElement . getProperty ( GraphElementProperties . SIZE ) ; Point2D position = new Point2D . Double ( ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getX ( ) - size . getWidth ( ) / 2 , ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getY ( ) - size . getHeight ( ) / 2 ) ; if ( position . getX ( ) <= xPos && xPos <= position . getX ( ) + 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NW_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . W_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SW_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + 4 < xPos && xPos < position . getX ( ) + size . getWidth ( ) - 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . N_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . S_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + size . getWidth ( ) - 4 <= xPos && xPos <= position . getX ( ) + size . getWidth ( ) ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NE_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . E_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SE_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } @ Override public void keyPressed ( KeyEvent e ) { if ( e . isControlDown ( ) && e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) > 0 ) { } } } @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) if ( e . getClickCount ( ) == 2 ) { Link hitLink = controller . getCurrentLink ( ) ; if ( hitLink != null ) { if ( hitLink instanceof AssociationLink ) { AssociationLinkDialog d = new AssociationLinkDialog ( ( AssociationLink ) hitLink ) ; d . setVisible ( true ) ; if ( d . isSomethingChanged ( ) ) { if ( d . isCreateNewLink ( ) ) { AssociationLink newLink ; LinkPainter painter = null ; if ( d . isAssociation ( ) ) { newLink = new AssociationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AssociationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AssociationLinkPainter ( newLink ) ; } else if ( d . isAggregation ( ) ) { newLink = new AggregationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AggregationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AggregationLinkPainter ( newLink ) ; } else { newLink = new CompositionLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " CompositionLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new CompositionLinkPainter ( newLink ) ; } Command command = new ChangeLinkTypeCommand ( view , hitLink , newLink , painter ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; newLink . getSourceConnector ( ) . setLink ( newLink ) ; newLink . getDestinationConnector ( ) . setLink ( newLink ) ; } else { Command command = new ChangeAssociationPropertiesCommand ( view , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , ( AssociationLink ) hitLink ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; } view . repaint ( ) ; } } } else { GraphElement element = controller . getCurrentElement ( ) ; if ( element instanceof Package ) MainFrame . getInstance ( ) . showDiagram ( ( ( Package ) element ) . getHierarchyPackage ( ) . getDiagram ( ) ) ; else if ( element instanceof graphedit . model . components . Class ) { ClassElementDialog dialog = new ClassElementDialog ( ( Class ) element ) ; dialog . setVisible ( true ) ; if ( dialog . isOk ( ) ) { Command command = new ChangeElementPropertiesCommand ( view , dialog . getName ( ) , dialog . getStereotype ( ) , element ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; view . repaint ( ) ; } } } } } public void showGraphElementPopup ( MouseEvent e ) { MainFrame . getInstance ( ) . getViewPopupMenu ( ) . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } public void showLinkElementPopup ( MouseEvent e ) { LinkPopupMenu popup = MainFrame . getInstance ( ) . getLinkPopupMenu ( ) ; popup . preparePopup ( ) ; popup . setActionPoint ( e . getPoint ( ) ) ; popup . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } @ Override public boolean isAutoScrollOnDragEnabled ( ) { return false ; } @ Override public boolean isAutoScrollOnMoveEnabled ( ) { return false ; } public Point2D getPopupPoint ( ) { return popupPoint ; } public void setPopupPoint ( Point2D popupPoint ) { this . popupPoint = popupPoint ; } } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/compiler/impl/src/com/intellij/compiler/impl/javaCompiler/javac/JavacCompiler.java"> package com . intellij . compiler . impl . javaCompiler . javac ; import com . intellij . compiler . impl . javaCompiler . BackendCompiler ; import com . intellij . openapi . compiler . CompilerBundle ; import com . intellij . openapi . fileTypes . FileType ; import com . intellij . openapi . fileTypes . StdFileTypes ; import com . intellij . openapi . options . Configurable ; import com . intellij . openapi . project . Project ; import org . jetbrains . annotations . NonNls ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . jps . model . java . compiler . JavaCompilers ; import java . util . Collections ; import java . util . Set ; public class JavacCompiler implements BackendCompiler { private final Project myProject ; public JavacCompiler ( Project project ) { myProject = project ; } @ NotNull @ NonNls public String getId ( ) { return JavaCompilers . JAVAC_ID ; } @ NotNull public String getPresentableName ( ) { return CompilerBundle . message ( " compiler . javac . name " ) ; } @ NotNull public Configurable createConfigurable ( ) { return new JavacConfigurable ( JavacConfiguration . getOptions ( myProject , JavacConfiguration . class ) ) ; } @ NotNull public Set < FileType > getCompilableFileTypes ( ) { return Collections . < FileType > singleton ( StdFileTypes . JAVA ) ; } } </DOCUMENT>
<DOCUMENT_ID="jondong/crosswalk/tree/master/third_party/lzma_sdk/src/SevenZip/LzmaAlone.java"> package SevenZip ; public class LzmaAlone { static public class CommandLine { public static final int kEncode = 0 ; public static final int kDecode = 1 ; public static final int kBenchmak = 2 ; public int Command = - 1 ; public int NumBenchmarkPasses = 10 ; public int DictionarySize = 1 << 23 ; public boolean DictionarySizeIsDefined = false ; public int Lc = 3 ; public int Lp = 0 ; public int Pb = 2 ; public int Fb = 128 ; public boolean FbIsDefined = false ; public boolean Eos = false ; public int Algorithm = 2 ; public int MatchFinder = 1 ; public String InFile ; public String OutFile ; boolean ParseSwitch ( String s ) { if ( s . startsWith ( " d " ) ) { DictionarySize = 1 << Integer . parseInt ( s . substring ( 1 ) ) ; DictionarySizeIsDefined = true ; } else if ( s . startsWith ( " fb " ) ) { Fb = Integer . parseInt ( s . substring ( 2 ) ) ; FbIsDefined = true ; } else if ( s . startsWith ( " a " ) ) Algorithm = Integer . parseInt ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " lc " ) ) Lc = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " lp " ) ) Lp = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " pb " ) ) Pb = Integer . parseInt ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " eos " ) ) Eos = true ; else if ( s . startsWith ( " mf " ) ) { String mfs = s . substring ( 2 ) ; if ( mfs . equals ( " bt2" ) ) MatchFinder = 0 ; else if ( mfs . equals ( " bt4" ) ) MatchFinder = 1 ; else if ( mfs . equals ( " bt4b " ) ) MatchFinder = 2 ; else return false ; } else return false ; return true ; } public boolean Parse ( String [ ] args ) throws Exception { int pos = 0 ; boolean switchMode = true ; for ( int i = 0 ; i < args . length ; i ++ ) { String s = args [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( switchMode ) { if ( s . compareTo ( " - - " ) == 0 ) { switchMode = false ; continue ; } if ( s . charAt ( 0 ) == ' - ' ) { String sw = s . substring ( 1 ) . toLowerCase ( ) ; if ( sw . length ( ) == 0 ) return false ; try { if ( ! ParseSwitch ( sw ) ) return false ; } catch ( NumberFormatException e ) { return false ; } continue ; } } if ( pos == 0 ) { if ( s . equalsIgnoreCase ( " e " ) ) Command = kEncode ; else if ( s . equalsIgnoreCase ( " d " ) ) Command = kDecode ; else if ( s . equalsIgnoreCase ( " b " ) ) Command = kBenchmak ; else return false ; } else if ( pos == 1 ) { if ( Command == kBenchmak ) { try { NumBenchmarkPasses = Integer . parseInt ( s ) ; if ( NumBenchmarkPasses < 1 ) return false ; } catch ( NumberFormatException e ) { return false ; } } else InFile = s ; } else if ( pos == 2 ) OutFile = s ; else return false ; pos ++ ; continue ; } return true ; } } static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; } public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize > > > ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; } } </DOCUMENT>
<DOCUMENT_ID="ajhalani/elasticsearch/tree/master/src/main/java/org/elasticsearch/common/logging/log4j/LogConfigurator.java"> package org . elasticsearch . common . logging . log4j ; import com . google . common . collect . ImmutableMap ; import org . apache . log4j . PropertyConfigurator ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . settings . ImmutableSettings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . FailedToResolveConfigException ; import java . io . IOException ; import java . net . MalformedURLException ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . EnumSet ; import java . util . Map ; import java . util . Properties ; import static org . elasticsearch . common . settings . ImmutableSettings . settingsBuilder ; public class LogConfigurator { private static boolean loaded ; private static ImmutableMap < String , String > replacements = new MapBuilder < String , String > ( ) . put ( " console " , " org . elasticsearch . common . logging . log4j . ConsoleAppender " ) . put ( " async " , " org . apache . log4j . AsyncAppender " ) . put ( " dailyRollingFile " , " org . apache . log4j . DailyRollingFileAppender " ) . put ( " externallyRolledFile " , " org . apache . log4j . ExternallyRolledFileAppender " ) . put ( " file " , " org . apache . log4j . FileAppender " ) . put ( " jdbc " , " org . apache . log4j . jdbc . JDBCAppender " ) . put ( " jms " , " org . apache . log4j . net . JMSAppender " ) . put ( " lf5" , " org . apache . log4j . lf5 . LF5Appender " ) . put ( " ntevent " , " org . apache . log4j . nt . NTEventLogAppender " ) . put ( " null " , " org . apache . log4j . NullAppender " ) . put ( " rollingFile " , " org . apache . log4j . RollingFileAppender " ) . put ( " smtp " , " org . apache . log4j . net . SMTPAppender " ) . put ( " socket " , " org . apache . log4j . net . SocketAppender " ) . put ( " socketHub " , " org . apache . log4j . net . SocketHubAppender " ) . put ( " syslog " , " org . apache . log4j . net . SyslogAppender " ) . put ( " telnet " , " org . apache . log4j . net . TelnetAppender " ) . put ( " simple " , " org . apache . log4j . SimpleLayout " ) . put ( " html " , " org . apache . log4j . HTMLLayout " ) . put ( " pattern " , " org . apache . log4j . PatternLayout " ) . put ( " consolePattern " , " org . apache . log4j . PatternLayout " ) . put ( " ttcc " , " org . apache . log4j . TTCCLayout " ) . put ( " xml " , " org . apache . log4j . XMLLayout " ) . immutableMap ( ) ; public static void configure ( Settings settings ) { if ( loaded ) { return ; } loaded = true ; Environment environment = new Environment ( settings ) ; ImmutableSettings . Builder settingsBuilder = settingsBuilder ( ) . put ( settings ) ; resolveConfig ( environment , settingsBuilder ) ; settingsBuilder . putProperties ( " elasticsearch . " , System . getProperties ( ) ) . putProperties ( " es . " , System . getProperties ( ) ) . replacePropertyPlaceholders ( ) ; Properties props = new Properties ( ) ; for ( Map . Entry < String , String > entry : settingsBuilder . build ( ) . getAsMap ( ) . entrySet ( ) ) { String key = " log4j . " + entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( replacements . containsKey ( value ) ) { value = replacements . get ( value ) ; } if ( key . endsWith ( " . value " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . endsWith ( " . type " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { props . setProperty ( key , value ) ; } } PropertyConfigurator . configure ( props ) ; } public static void resolveConfig ( Environment env , final ImmutableSettings . Builder settingsBuilder ) { try { Files . walkFileTree ( env . configFile ( ) . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . startsWith ( " logging . " ) ) { loadConfig ( file , settingsBuilder ) ; } return FileVisitResult . CONTINUE ; } } ) ; } catch ( IOException ioe ) { throw new ElasticsearchException ( " Failed ▁ to ▁ load ▁ logging ▁ configuration " , ioe ) ; } } public static void loadConfig ( Path file , ImmutableSettings . Builder settingsBuilder ) { try { settingsBuilder . loadFromUrl ( file . toUri ( ) . toURL ( ) ) ; } catch ( FailedToResolveConfigException | NoClassDefFoundError | MalformedURLException e ) { } } } </DOCUMENT>
<DOCUMENT_ID="rsf/RSFUtil/tree/master/src/uk/org/ponder/rsf/flow/jsfnav/support/NavigationRule.java"> package uk . org . ponder . rsf . flow . jsfnav . support ; import java . util . List ; import uk . org . ponder . rsf . viewstate . ViewParameters ; public class NavigationRule { public ViewParameters fromViewId ; public List navigationCases ; } </DOCUMENT>
<DOCUMENT_ID="IllusionRom-deprecated/android_platform_tools_idea/tree/master/java/java-analysis-impl/src/com/intellij/codeInspection/NumericOverflowInspection.java"> package com . intellij . codeInspection ; import com . intellij . codeInsight . daemon . GroupNames ; import com . intellij . codeInsight . daemon . JavaErrorMessages ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . util . Key ; import com . intellij . psi . * ; import com . intellij . psi . util . ConstantEvaluationOverflowException ; import com . intellij . psi . util . TypeConversionUtil ; import org . jetbrains . annotations . Nls ; import org . jetbrains . annotations . NotNull ; public class NumericOverflowInspection extends BaseJavaBatchLocalInspectionTool { private static final Key < String > HAS_OVERFLOW_IN_CHILD = Key . create ( " HAS _ OVERFLOW _ IN _ CHILD " ) ; @ Nls @ NotNull @ Override public String getGroupDisplayName ( ) { return GroupNames . NUMERIC_GROUP_NAME ; } @ Nls @ NotNull @ Override public String getDisplayName ( ) { return " Numeric ▁ overflow " ; } @ NotNull @ Override public String getShortName ( ) { return " NumericOverflow " ; } @ NotNull @ Override public PsiElementVisitor buildVisitor ( @ NotNull final ProblemsHolder holder , boolean isOnTheFly ) { return new JavaElementVisitor ( ) { @ Override public void visitReferenceExpression ( PsiReferenceExpression expression ) { visitExpression ( expression ) ; } @ Override public void visitExpression ( PsiExpression expression ) { boolean info = hasOverflow ( expression , holder . getProject ( ) ) ; if ( info ) { holder . registerProblem ( expression , JavaErrorMessages . message ( " numeric . overflow . in . expression " ) , ProblemHighlightType . GENERIC_ERROR_OR_WARNING ) ; } } } ; } private static boolean hasOverflow ( PsiExpression expr , @ NotNull Project project ) { if ( ! TypeConversionUtil . isNumericType ( expr . getType ( ) ) ) return false ; boolean overflow = false ; try { if ( expr . getUserData ( HAS_OVERFLOW_IN_CHILD ) == null ) { JavaPsiFacade . getInstance ( project ) . getConstantEvaluationHelper ( ) . computeConstantExpression ( expr , true ) ; } else { overflow = true ; } } catch ( ConstantEvaluationOverflowException e ) { overflow = true ; } finally { PsiElement parent = expr . getParent ( ) ; if ( overflow && parent instanceof PsiExpression ) { parent . putUserData ( HAS_OVERFLOW_IN_CHILD , " " ) ; } } return overflow ; } } </DOCUMENT>
<DOCUMENT_ID="yuanke/hadoop-hbase/tree/master/src/test/org/apache/hadoop/mapred/TestKillCompletedJob.java"> package org . apache . hadoop . mapred ; import java . io . * ; import java . net . * ; import junit . framework . TestCase ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hdfs . MiniDFSCluster ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IntWritable ; import org . apache . hadoop . io . Text ; public class TestKillCompletedJob extends TestCase { static Boolean launchWordCount ( String fileSys , String jobTracker , JobConf conf , String input , int numMaps , int numReduces ) throws IOException { final Path inDir = new Path ( " / testing / wc / input " ) ; final Path outDir = new Path ( " / testing / wc / output " ) ; FileSystem fs = FileSystem . get ( URI . create ( fileSys ) , conf ) ; fs . delete ( outDir , true ) ; if ( ! fs . mkdirs ( inDir ) ) { throw new IOException ( " Mkdirs ▁ failed ▁ to ▁ create ▁ " + inDir . toString ( ) ) ; } { DataOutputStream file = fs . create ( new Path ( inDir , " part - 0" ) ) ; file . writeBytes ( input ) ; file . close ( ) ; } FileSystem . setDefaultUri ( conf , fileSys ) ; conf . set ( " mapred . job . tracker " , jobTracker ) ; conf . setJobName ( " wordcount " ) ; conf . setInputFormat ( TextInputFormat . class ) ; conf . setOutputKeyClass ( Text . class ) ; conf . setOutputValueClass ( IntWritable . class ) ; conf . setMapperClass ( WordCount . MapClass . class ) ; conf . setCombinerClass ( WordCount . Reduce . class ) ; conf . setReducerClass ( WordCount . Reduce . class ) ; FileInputFormat . setInputPaths ( conf , inDir ) ; FileOutputFormat . setOutputPath ( conf , outDir ) ; conf . setNumMapTasks ( numMaps ) ; conf . setNumReduceTasks ( numReduces ) ; RunningJob rj = JobClient . runJob ( conf ) ; JobID jobId = rj . getID ( ) ; if ( rj . isSuccessful ( ) ) { System . out . println ( " Job ▁ Id : " + jobId + " ▁ completed ▁ successfully . ▁ Killing ▁ it ▁ now " ) ; rj . killJob ( ) ; } return rj . isSuccessful ( ) ; } public void testKillCompJob ( ) throws IOException { String namenode = null ; MiniDFSCluster dfs = null ; MiniMRCluster mr = null ; FileSystem fileSys = null ; try { final int taskTrackers = 1 ; Configuration conf = new Configuration ( ) ; dfs = new MiniDFSCluster ( conf , 1 , true , null ) ; fileSys = dfs . getFileSystem ( ) ; namenode = fileSys . getUri ( ) . toString ( ) ; mr = new MiniMRCluster ( taskTrackers , namenode , 3 ) ; JobConf jobConf = new JobConf ( ) ; Boolean result ; final String jobTrackerName = " localhost : " + mr . getJobTrackerPort ( ) ; result = launchWordCount ( namenode , jobTrackerName , jobConf , " Small ▁ text \n " , 1 , 0 ) ; assertTrue ( result ) ; } finally { if ( dfs != null ) { dfs . shutdown ( ) ; } if ( mr != null ) { mr . shutdown ( ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="Communote/communote-server/tree/master/communote/persistence/src/main/java/com/communote/server/core/tag/TagStoreNotFoundException.java"> package com . communote . server . core . tag ; import com . communote . server . api . core . common . NotFoundException ; public class TagStoreNotFoundException extends NotFoundException { private static final long serialVersionUID = - 5089679368783279854L ; public TagStoreNotFoundException ( String message ) { super ( message ) ; } } </DOCUMENT>
