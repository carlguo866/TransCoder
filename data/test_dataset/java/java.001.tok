<DOCUMENT_ID="signed/intellij-community/tree/master/java/java-tests/testData/psi/parser-full/declarationParsing/class/NoType.java"> class ClassName { new X ( ) ; } </DOCUMENT>
<DOCUMENT_ID="lumenrobot/relex-id/tree/master/core/src/main/java/id/ac/itb/ee/lskk/relexid/core/PartOfSpeech.java"> package id . ac . itb . ee . lskk . relexid . core ; import java . util . Locale ; import java . util . Map ; import javax . xml . namespace . QName ; import org . eclipse . emf . ecore . EObject ; public interface PartOfSpeech extends EObject { String getLiteral ( ) ; void setLiteral ( String value ) ; QName getResource ( ) ; void setResource ( QName value ) ; QName getWord ( ) ; void setWord ( QName value ) ; String getName ( ) ; void setName ( String value ) ; GeneratedLiteral generate ( Locale locale , Map < String , String > dict , Translator translator ) ; } </DOCUMENT>
<DOCUMENT_ID="fengyouchao/sockslib/tree/master/src/main/java/sockslib/client/CommandReplyMessage.java"> package sockslib . client ; import sockslib . common . AddressType ; import sockslib . utils . SocksUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . UnknownHostException ; public class CommandReplyMessage implements SocksMessage { protected Logger logger = LoggerFactory . getLogger ( CommandReplyMessage . class ) ; private byte [ ] replyBytes ; public CommandReplyMessage ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } public boolean isSuccess ( ) { if ( replyBytes . length < 10 ) { return false ; } return replyBytes [ 1 ] == 0 ; } public InetAddress getIp ( ) throws UnknownHostException { byte [ ] addressBytes = null ; if ( replyBytes [ 3 ] == AddressType . IPV4 ) { addressBytes = new byte [ 4 ] ; } else if ( replyBytes [ 3 ] == AddressType . IPV6 ) { addressBytes = new byte [ 16 ] ; } System . arraycopy ( replyBytes , 4 , addressBytes , 0 , addressBytes . length ) ; return InetAddress . getByAddress ( addressBytes ) ; } public int getPort ( ) { return SocksUtil . bytesToInt ( replyBytes [ replyBytes . length - 2 ] , replyBytes [ replyBytes . length - 1 ] ) ; } public byte [ ] getReplyBytes ( ) { return replyBytes ; } public void setReplyBytes ( byte [ ] replyBytes ) { this . replyBytes = replyBytes ; } public SocketAddress getSocketAddress ( ) { try { return new InetSocketAddress ( getIp ( ) , getPort ( ) ) ; } catch ( UnknownHostException e ) { logger . error ( e . getMessage ( ) , e ) ; } return null ; } } </DOCUMENT>
<DOCUMENT_ID="13366348079/Dubbo/tree/master/dubbo-cluster/src/main/java/com/alibaba/dubbo/rpc/cluster/support/BroadcastCluster.java"> package com . alibaba . dubbo . rpc . cluster . support ; import com . alibaba . dubbo . rpc . Invoker ; import com . alibaba . dubbo . rpc . RpcException ; import com . alibaba . dubbo . rpc . cluster . Cluster ; import com . alibaba . dubbo . rpc . cluster . Directory ; public class BroadcastCluster implements Cluster { public < T > Invoker < T > join ( Directory < T > directory ) throws RpcException { return new BroadcastClusterInvoker < T > ( directory ) ; } } </DOCUMENT>
<DOCUMENT_ID="da1z/intellij-community/tree/master/java/java-tests/testData/inspection/deadCode/junitAbstractClassWithInheritor/src/ChildTest.java"> public class ChildTest extends AbstractTest { } </DOCUMENT>
<DOCUMENT_ID="iliat/gatk-tools-java/tree/master/src/main/java/com/google/cloud/genomics/gatk/common/GenomicsConverterBase.java"> package com . google . cloud . genomics . gatk . common ; import htsjdk . samtools . SAMFileHeader ; import htsjdk . samtools . SAMRecord ; import java . util . List ; public abstract class GenomicsConverterBase < Read , ReadGroupSet , Reference > implements GenomicsConverter < Read , ReadGroupSet , Reference > { @ Override public SAMRecord makeSAMRecord ( Read read , ReadGroupSet readGroupSet , List < Reference > references , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , makeSAMFileHeader ( readGroupSet , references ) ) ; } @ Override public SAMRecord makeSAMRecord ( Read read , boolean forceSetMatePositionToThisPosition ) { return makeSAMRecord ( read , new SAMFileHeader ( ) ) ; } @ Override public abstract SAMFileHeader makeSAMFileHeader ( ReadGroupSet readGroupSet , List < Reference > references ) ; @ Override public abstract SAMRecord makeSAMRecord ( Read read , SAMFileHeader header ) ; } </DOCUMENT>
<DOCUMENT_ID="MeetMe/selenium/tree/master/java/server/src/org/openqa/grid/internal/listeners/Prioritizer.java"> package org . openqa . grid . internal . listeners ; import java . util . Map ; public interface Prioritizer { public int compareTo ( Map < String , Object > a , Map < String , Object > b ) ; } </DOCUMENT>
<DOCUMENT_ID="mayonghui2112/helloWorld/tree/master/sourceCode/OnJava8-Examples-master/patterns/trash/Paper.java"> package patterns . trash ; public class Paper extends Trash { private static double val = 0.10f ; public Paper ( double wt ) { super ( wt ) ; } @ Override public double value ( ) { return val ; } public static void value ( double newVal ) { val = newVal ; } } </DOCUMENT>
<DOCUMENT_ID="davidfestal/che/tree/master/plugins/plugin-java/che-plugin-java-ext-lang-server/src/test/resources/RenamePackage/testFail10/in/r/A.java"> package r ; class C { } </DOCUMENT>
<DOCUMENT_ID="Authorlove/hadoop/tree/master/hadoop-tools/hadoop-rumen/src/main/java/org/apache/hadoop/tools/rumen/DefaultInputDemuxer.java"> package org . apache . hadoop . tools . rumen ; import java . io . IOException ; import java . io . InputStream ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; public class DefaultInputDemuxer implements InputDemuxer { String name ; InputStream input ; @ Override public void bindTo ( Path path , Configuration conf ) throws IOException { if ( name != null ) { close ( ) ; } name = path . getName ( ) ; input = new PossiblyDecompressedInputStream ( path , conf ) ; return ; } @ Override public Pair < String , InputStream > getNext ( ) throws IOException { if ( name != null ) { Pair < String , InputStream > ret = new Pair < String , InputStream > ( name , input ) ; name = null ; input = null ; return ret ; } return null ; } @ Override public void close ( ) throws IOException { try { if ( input != null ) { input . close ( ) ; } } finally { name = null ; input = null ; } } } </DOCUMENT>
<DOCUMENT_ID="elastic-grid/Elastic-Grid/tree/master/modules/replicated-storage/src/main/java/com/elasticgrid/storage/replicated/ReplicatedContainer.java"> package com . elasticgrid . storage . replicated ; import com . elasticgrid . storage . Container ; import com . elasticgrid . storage . Storable ; import com . elasticgrid . storage . StorageException ; import com . elasticgrid . storage . StorableNotFoundException ; import java . util . Arrays ; import java . util . List ; import java . util . logging . Logger ; import java . io . File ; import java . io . InputStream ; public class ReplicatedContainer implements Container { private final Container preferred ; private final List < Container > otherContainers ; private static final Logger logger = Logger . getLogger ( ReplicatedContainer . class . getName ( ) ) ; public ReplicatedContainer ( Container preferred , List < Container > otherContainers ) { this . preferred = preferred ; this . otherContainers = otherContainers ; } public String getName ( ) { return null ; } public List < Storable > listStorables ( ) throws StorageException { return null ; } public Storable findStorableByName ( String name ) throws StorableNotFoundException , StorageException { return null ; } public Storable uploadStorable ( File file ) throws StorageException { return null ; } public Storable uploadStorable ( String name , File file ) throws StorageException { return null ; } public Storable uploadStorable ( String name , InputStream stream , String mimeType ) throws StorageException { return null ; } public void deleteStorable ( String name ) throws StorageException { } } </DOCUMENT>
<DOCUMENT_ID="rsf/RSFUtil/tree/master/src/uk/org/ponder/rsf/flow/jsfnav/support/NavigationRule.java"> package uk . org . ponder . rsf . flow . jsfnav . support ; import java . util . List ; import uk . org . ponder . rsf . viewstate . ViewParameters ; public class NavigationRule { public ViewParameters fromViewId ; public List navigationCases ; } </DOCUMENT>
<DOCUMENT_ID="sourcepit/osgifier/tree/master/org.sourcepit.osgifier.core/gen/main/emf/org/sourcepit/osgifier/core/model/java/Named.java"> package org . sourcepit . osgifier . core . model . java ; import org . eclipse . emf . ecore . EObject ; public interface Named extends EObject { String getName ( ) ; void setName ( String value ) ; } </DOCUMENT>
<DOCUMENT_ID="lowiki-org/localwiki-backend-server/tree/master/sapling-daisydiff/src/java/org/eclipse/compare/rangedifferencer/DifferencesIterator.java"> package org . eclipse . compare . rangedifferencer ; import java . util . ArrayList ; import java . util . List ; class DifferencesIterator { List fRange ; int fIndex ; RangeDifference [ ] fArray ; RangeDifference fDifference ; DifferencesIterator ( RangeDifference [ ] differenceRanges ) { fArray = differenceRanges ; fIndex = 0 ; fRange = new ArrayList ( ) ; if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } int getCount ( ) { return fRange . size ( ) ; } void next ( ) { fRange . add ( fDifference ) ; if ( fDifference != null ) { if ( fIndex < fArray . length ) fDifference = fArray [ fIndex ++ ] ; else fDifference = null ; } } DifferencesIterator other ( DifferencesIterator right , DifferencesIterator left ) { if ( this == right ) return left ; return right ; } void removeAll ( ) { fRange . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="esi-mineset/spark/tree/master/sql/core/src/test/java/test/org/apache/spark/sql/JavaStringLength.java"> package test . org . apache . spark . sql ; import org . apache . spark . sql . api . java . UDF1 ; public class JavaStringLength implements UDF1 < String , Integer > { @ Override public Integer call ( String str ) throws Exception { return new Integer ( str . length ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="slburson/fast-serialization/tree/master/src/main/java/org/nustaq/serialization/serializers/FSTCPEnumSetSerializer.java"> package org . nustaq . serialization . serializers ; import org . nustaq . serialization . FSTBasicObjectSerializer ; import org . nustaq . serialization . FSTClazzInfo ; import org . nustaq . serialization . FSTObjectInput ; import org . nustaq . serialization . FSTObjectOutput ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . EnumSet ; public class FSTCPEnumSetSerializer extends FSTBasicObjectSerializer { Field elemType ; @ Override public void writeObject ( FSTObjectOutput out , Object toWrite , FSTClazzInfo clzInfo , FSTClazzInfo . FSTFieldInfo referencedBy , int streamPosition ) throws IOException { EnumSet enset = ( EnumSet ) toWrite ; int count = 0 ; out . writeInt ( enset . size ( ) ) ; if ( enset . isEmpty ( ) ) { EnumSet compl = EnumSet . complementOf ( enset ) ; out . writeClassTag ( compl . iterator ( ) . next ( ) . getClass ( ) ) ; } else { for ( Object element : enset ) { if ( count == 0 ) { out . writeStringUTF ( element . getClass ( ) . getName ( ) ) ; } out . writeStringUTF ( element . toString ( ) ) ; count ++ ; } } } @ Override public boolean alwaysCopy ( ) { return false ; } @ Override public Object instantiate ( Class objectClass , FSTObjectInput in , FSTClazzInfo serializationInfo , FSTClazzInfo . FSTFieldInfo referencee , int streamPosition ) throws Exception { int len = in . readInt ( ) ; Class elemCl = in . getClassForName ( in . readStringUTF ( ) ) ; EnumSet enSet = EnumSet . noneOf ( elemCl ) ; in . registerObject ( enSet , streamPosition , serializationInfo , referencee ) ; for ( int i = 0 ; i < len ; i ++ ) { String val = in . readStringUTF ( ) ; enSet . add ( Enum . valueOf ( elemCl , val ) ) ; } return enSet ; } } </DOCUMENT>
<DOCUMENT_ID="elijah513/ice/tree/master/java/test/src/main/java/test/Ice/location/ServerLocatorRegistry.java"> package test . Ice . location ; import test . Ice . location . Test . _TestLocatorRegistryDisp ; public class ServerLocatorRegistry extends _TestLocatorRegistryDisp { @ Override public void setAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setAdapterDirectProxy cb , String adapter , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; } else { _adapters . remove ( adapter ) ; } cb . ice_response ( ) ; } @ Override public void setReplicatedAdapterDirectProxy_async ( Ice . AMD_LocatorRegistry_setReplicatedAdapterDirectProxy cb , String adapter , String replica , Ice . ObjectPrx object , Ice . Current current ) { if ( object != null ) { _adapters . put ( adapter , object ) ; _adapters . put ( replica , object ) ; } else { _adapters . remove ( adapter ) ; _adapters . remove ( replica ) ; } cb . ice_response ( ) ; } @ Override public void setServerProcessProxy_async ( Ice . AMD_LocatorRegistry_setServerProcessProxy cb , String id , Ice . ProcessPrx proxy , Ice . Current current ) { } @ Override public void addObject ( Ice . ObjectPrx object , Ice . Current current ) { _objects . put ( object . ice_getIdentity ( ) , object ) ; } public Ice . ObjectPrx getAdapter ( String adapter ) throws Ice . AdapterNotFoundException { Ice . ObjectPrx obj = _adapters . get ( adapter ) ; if ( obj == null ) { throw new Ice . AdapterNotFoundException ( ) ; } return obj ; } public Ice . ObjectPrx getObject ( Ice . Identity id ) throws Ice . ObjectNotFoundException { Ice . ObjectPrx obj = _objects . get ( id ) ; if ( obj == null ) { throw new Ice . ObjectNotFoundException ( ) ; } return obj ; } private java . util . HashMap < String , Ice . ObjectPrx > _adapters = new java . util . HashMap < String , Ice . ObjectPrx > ( ) ; private java . util . HashMap < Ice . Identity , Ice . ObjectPrx > _objects = new java . util . HashMap < Ice . Identity , Ice . ObjectPrx > ( ) ; } </DOCUMENT>
<DOCUMENT_ID="didoupimpon/CC152/tree/master/src/main/java/net/minecraft/server/ItemReed.java"> package net . minecraft . server ; import org . bukkit . block . BlockState ; import org . bukkit . craftbukkit . block . CraftBlockState ; import org . bukkit . craftbukkit . event . CraftEventFactory ; import org . bukkit . event . block . BlockPlaceEvent ; public class ItemReed extends Item { private int id ; public ItemReed ( int i , Block block ) { super ( i ) ; this . id = block . id ; } public boolean a ( ItemStack itemstack , EntityHuman entityhuman , World world , int i , int j , int k , int l ) { int clickedX = i , clickedY = j , clickedZ = k ; if ( world . getTypeId ( i , j , k ) == Block . SNOW . id ) { l = 0 ; } else { if ( l == 0 ) { -- j ; } if ( l == 1 ) { ++ j ; } if ( l == 2 ) { -- k ; } if ( l == 3 ) { ++ k ; } if ( l == 4 ) { -- i ; } if ( l == 5 ) { ++ i ; } } if ( itemstack . count == 0 ) { return false ; } else { if ( world . a ( this . id , i , j , k , false ) ) { Block block = Block . byId [ this . id ] ; BlockState replacedBlockState = CraftBlockState . getBlockState ( world , i , j , k ) ; if ( world . setRawTypeId ( i , j , k , this . id ) ) { BlockPlaceEvent event = CraftEventFactory . callBlockPlaceEvent ( world , entityhuman , replacedBlockState , clickedX , clickedY , clickedZ , block ) ; if ( event . isCancelled ( ) || ! event . canBuild ( ) ) { world . setTypeIdAndData ( i , j , k , replacedBlockState . getTypeId ( ) , replacedBlockState . getRawData ( ) ) ; } else { world . update ( i , j , k , this . id ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , l ) ; Block . byId [ this . id ] . postPlace ( world , i , j , k , entityhuman ) ; world . makeSound ( ( double ) ( ( float ) i + 0.5F ) , ( double ) ( ( float ) j + 0.5F ) , ( double ) ( ( float ) k + 0.5F ) , block . stepSound . getName ( ) , ( block . stepSound . getVolume1 ( ) + 1.0F ) / 2.0F , block . stepSound . getVolume2 ( ) * 0.8F ) ; -- itemstack . count ; } } } return true ; } } } </DOCUMENT>
<DOCUMENT_ID="charlesvinette/react-native/tree/master/ReactAndroid/src/main/java/com/facebook/react/views/modal/ReactModalHostView.java"> package com . facebook . react . views . modal ; import javax . annotation . Nullable ; import java . util . ArrayList ; import android . app . Activity ; import android . app . Dialog ; import android . content . Context ; import android . content . DialogInterface ; import android . view . KeyEvent ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewGroup ; import android . view . WindowManager ; import android . view . accessibility . AccessibilityEvent ; import android . widget . FrameLayout ; import com . facebook . infer . annotation . Assertions ; import com . facebook . react . R ; import com . facebook . react . bridge . LifecycleEventListener ; import com . facebook . react . bridge . ReactContext ; import com . facebook . react . common . annotations . VisibleForTesting ; import com . facebook . react . uimanager . JSTouchDispatcher ; import com . facebook . react . uimanager . RootView ; import com . facebook . react . uimanager . UIManagerModule ; import com . facebook . react . uimanager . events . EventDispatcher ; import com . facebook . react . views . view . ReactViewGroup ; public class ReactModalHostView extends ViewGroup implements LifecycleEventListener { public interface OnRequestCloseListener { void onRequestClose ( DialogInterface dialog ) ; } private DialogRootViewGroup mHostView ; private @ Nullable Dialog mDialog ; private boolean mTransparent ; private String mAnimationType ; private boolean mPropertyRequiresNewDialog ; private @ Nullable DialogInterface . OnShowListener mOnShowListener ; private @ Nullable OnRequestCloseListener mOnRequestCloseListener ; public ReactModalHostView ( Context context ) { super ( context ) ; ( ( ReactContext ) context ) . addLifecycleEventListener ( this ) ; mHostView = new DialogRootViewGroup ( context ) ; } @ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { } @ Override public void addView ( View child , int index ) { mHostView . addView ( child , index ) ; } @ Override public int getChildCount ( ) { return mHostView . getChildCount ( ) ; } @ Override public View getChildAt ( int index ) { return mHostView . getChildAt ( index ) ; } @ Override public void removeView ( View child ) { mHostView . removeView ( child ) ; } @ Override public void removeViewAt ( int index ) { View child = getChildAt ( index ) ; mHostView . removeView ( child ) ; } @ Override public void addChildrenForAccessibility ( ArrayList < View > outChildren ) { } @ Override public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { return false ; } public void onDropInstance ( ) { ( ( ReactContext ) getContext ( ) ) . removeLifecycleEventListener ( this ) ; dismiss ( ) ; } private void dismiss ( ) { if ( mDialog != null ) { mDialog . dismiss ( ) ; mDialog = null ; ViewGroup parent = ( ViewGroup ) mHostView . getParent ( ) ; parent . removeViewAt ( 0 ) ; } } protected void setOnRequestCloseListener ( OnRequestCloseListener listener ) { mOnRequestCloseListener = listener ; } protected void setOnShowListener ( DialogInterface . OnShowListener listener ) { mOnShowListener = listener ; } protected void setTransparent ( boolean transparent ) { mTransparent = transparent ; } protected void setAnimationType ( String animationType ) { mAnimationType = animationType ; mPropertyRequiresNewDialog = true ; } @ Override public void onHostResume ( ) { showOrUpdate ( ) ; } @ Override public void onHostPause ( ) { dismiss ( ) ; } @ Override public void onHostDestroy ( ) { onDropInstance ( ) ; } @ VisibleForTesting public @ Nullable Dialog getDialog ( ) { return mDialog ; } protected void showOrUpdate ( ) { if ( mDialog != null ) { if ( mPropertyRequiresNewDialog ) { dismiss ( ) ; } else { updateProperties ( ) ; return ; } } mPropertyRequiresNewDialog = false ; int theme = R . style . Theme_FullScreenDialog ; if ( mAnimationType . equals ( " fade " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedFade ; } else if ( mAnimationType . equals ( " slide " ) ) { theme = R . style . Theme_FullScreenDialogAnimatedSlide ; } mDialog = new Dialog ( getContext ( ) , theme ) ; mDialog . setContentView ( getContentView ( ) ) ; updateProperties ( ) ; mDialog . setOnShowListener ( mOnShowListener ) ; mDialog . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { @ Override public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent event ) { if ( event . getAction ( ) == KeyEvent . ACTION_UP ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { Assertions . assertNotNull ( mOnRequestCloseListener , " setOnRequestCloseListener ▁ must ▁ be ▁ called ▁ by ▁ the ▁ manager " ) ; mOnRequestCloseListener . onRequestClose ( dialog ) ; return true ; } else { Activity currentActivity = ( ( ReactContext ) getContext ( ) ) . getCurrentActivity ( ) ; if ( currentActivity != null ) { return currentActivity . onKeyUp ( keyCode , event ) ; } } } return false ; } } ) ; mDialog . getWindow ( ) . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_ADJUST_RESIZE ) ; mDialog . show ( ) ; } private View getContentView ( ) { FrameLayout frameLayout = new FrameLayout ( getContext ( ) ) ; frameLayout . addView ( mHostView ) ; frameLayout . setFitsSystemWindows ( true ) ; return frameLayout ; } private void updateProperties ( ) { Assertions . assertNotNull ( mDialog , " mDialog ▁ must ▁ exist ▁ when ▁ we ▁ call ▁ updateProperties " ) ; if ( mTransparent ) { mDialog . getWindow ( ) . clearFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } else { mDialog . getWindow ( ) . setDimAmount ( 0.5f ) ; mDialog . getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_DIM_BEHIND , WindowManager . LayoutParams . FLAG_DIM_BEHIND ) ; } } static class DialogRootViewGroup extends ReactViewGroup implements RootView { private final JSTouchDispatcher mJSTouchDispatcher = new JSTouchDispatcher ( this ) ; public DialogRootViewGroup ( Context context ) { super ( context ) ; } @ Override protected void onSizeChanged ( final int w , final int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; if ( getChildCount ( ) > 0 ) { ( ( ReactContext ) getContext ( ) ) . runOnNativeModulesQueueThread ( new Runnable ( ) { @ Override public void run ( ) { ( ( ReactContext ) getContext ( ) ) . getNativeModule ( UIManagerModule . class ) . updateNodeSize ( getChildAt ( 0 ) . getId ( ) , w , h ) ; } } ) ; } } @ Override public boolean onInterceptTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; return super . onInterceptTouchEvent ( event ) ; } @ Override public boolean onTouchEvent ( MotionEvent event ) { mJSTouchDispatcher . handleTouchEvent ( event , getEventDispatcher ( ) ) ; super . onTouchEvent ( event ) ; return true ; } @ Override public void onChildStartedNativeGesture ( MotionEvent androidEvent ) { mJSTouchDispatcher . onChildStartedNativeGesture ( androidEvent , getEventDispatcher ( ) ) ; } @ Override public void requestDisallowInterceptTouchEvent ( boolean disallowIntercept ) { } private EventDispatcher getEventDispatcher ( ) { ReactContext reactContext = ( ReactContext ) getContext ( ) ; return reactContext . getNativeModule ( UIManagerModule . class ) . getEventDispatcher ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="qqming113/hadoop/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/webapp/dao/TaskAttemptsInfo.java"> package org . apache . hadoop . mapreduce . v2 . app . webapp . dao ; import java . util . ArrayList ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement ( name = " taskAttempts " ) @ XmlAccessorType ( XmlAccessType . FIELD ) public class TaskAttemptsInfo { protected ArrayList < TaskAttemptInfo > taskAttempt = new ArrayList < TaskAttemptInfo > ( ) ; public TaskAttemptsInfo ( ) { } public void add ( TaskAttemptInfo taskattemptInfo ) { taskAttempt . add ( taskattemptInfo ) ; } public ArrayList < TaskAttemptInfo > getTaskAttempts ( ) { return taskAttempt ; } } </DOCUMENT>
<DOCUMENT_ID="crockpotveggies/deeplearning4j/tree/master/deeplearning4j-ui-parent/deeplearning4j-ui/src/test/java/org/deeplearning4j/ui/weights/HistogramBinTest.java"> package org . deeplearning4j . ui . weights ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import java . math . BigDecimal ; import static org . junit . Assert . assertEquals ; public class HistogramBinTest { @ Before public void setUp ( ) throws Exception { } @ Test public void testGetBins ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getBins ( ) ) ; assertEquals ( 2 , histogram . getBins ( ) . getDouble ( 9 ) , 0.001 ) ; } @ Test public void testGetData1 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { 0.1 , 0.2 , 0.3 , 0.4 , 0.5 , 0.6 , 0.7 , 0.8 , 0.9 , 1.0 , 1.0 } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( 0.1 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; } @ Test public void testGetData2 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 10 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 10 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } @ Test public void testGetData4 ( ) throws Exception { INDArray array = Nd4j . create ( new double [ ] { - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f , - 1.0f , - 0.50f , 0.0f , 0.50f , 1.0f } ) ; HistogramBin histogram = new HistogramBin . Builder ( array ) . setBinCount ( 50 ) . build ( ) ; assertEquals ( - 1.0 , histogram . getMin ( ) , 0.001 ) ; assertEquals ( 1.0 , histogram . getMax ( ) , 0.001 ) ; System . out . println ( " Result : ▁ " + histogram . getData ( ) ) ; assertEquals ( 50 , histogram . getData ( ) . size ( ) ) ; assertEquals ( 2 , histogram . getData ( ) . get ( new BigDecimal ( "1.00" ) ) . get ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="tharindum/opennms_dashboard/tree/master/opennms-webapp/src/main/java/org/opennms/web/report/database/ReportParametersValidator.java"> package org . opennms . web . report . database ; import java . util . Iterator ; import java . util . List ; import org . opennms . api . reporting . parameter . ReportDoubleParm ; import org . opennms . api . reporting . parameter . ReportFloatParm ; import org . opennms . api . reporting . parameter . ReportParameters ; import org . opennms . api . reporting . parameter . ReportDateParm ; import org . opennms . api . reporting . parameter . ReportIntParm ; import org . opennms . api . reporting . parameter . ReportStringParm ; import org . springframework . binding . message . MessageBuilder ; import org . springframework . binding . message . MessageContext ; import org . springframework . binding . validation . ValidationContext ; public class ReportParametersValidator { public void validateReportParameters ( ReportParameters reportCriteria , ValidationContext context ) { MessageContext messages = context . getMessageContext ( ) ; List < ReportDateParm > dateParms = reportCriteria . getDateParms ( ) ; for ( Iterator < ReportDateParm > dateParmIter = dateParms . iterator ( ) ; dateParmIter . hasNext ( ) ; ) { ReportDateParm dateParm = dateParmIter . next ( ) ; if ( dateParm . getDate ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " date ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ date ▁ field " + dateParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportStringParm > stringParms = reportCriteria . getStringParms ( ) ; for ( Iterator < ReportStringParm > stringParmIter = stringParms . iterator ( ) ; stringParmIter . hasNext ( ) ; ) { ReportStringParm stringParm = stringParmIter . next ( ) ; if ( stringParm . getValue ( ) == " " ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " string ▁ parms " ) . defaultText ( " cannot ▁ have ▁ empty ▁ string ▁ field " + stringParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportIntParm > intParms = reportCriteria . getIntParms ( ) ; for ( Iterator < ReportIntParm > intParmIter = intParms . iterator ( ) ; intParmIter . hasNext ( ) ; ) { ReportIntParm intParm = intParmIter . next ( ) ; if ( intParm . getValue ( ) == 0 ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " int ▁ parms " ) . defaultText ( " cannot ▁ have ▁ zero ▁ integer ▁ field " + intParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportFloatParm > floatParms = reportCriteria . getFloatParms ( ) ; for ( Iterator < ReportFloatParm > floatParmIter = floatParms . iterator ( ) ; floatParmIter . hasNext ( ) ; ) { ReportFloatParm floatParm = floatParmIter . next ( ) ; if ( floatParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " float ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ float ▁ field " + floatParm . getDisplayName ( ) ) . build ( ) ) ; } } List < ReportDoubleParm > doubleParms = reportCriteria . getDoubleParms ( ) ; for ( Iterator < ReportDoubleParm > doubleParmIter = doubleParms . iterator ( ) ; doubleParmIter . hasNext ( ) ; ) { ReportDoubleParm doubleParm = doubleParmIter . next ( ) ; if ( doubleParm . getValue ( ) == null ) { messages . addMessage ( new MessageBuilder ( ) . error ( ) . source ( " double ▁ parms " ) . defaultText ( " cannot ▁ have ▁ null ▁ double ▁ field " + doubleParm . getDisplayName ( ) ) . build ( ) ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="poiru/uni-spiffer/tree/master/spiffer/src/test/java/com/mohanathas/spiffer/algorithm/NodeTest.java"> package com . mohanathas . spiffer . algorithm ; import com . mohanathas . spiffer . util . Point ; import org . junit . Test ; import static org . junit . Assert . * ; public class NodeTest { public NodeTest ( ) { } @ Test public void testConstructor ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( 1 , node . getX ( ) ) ; assertEquals ( 2 , node . getY ( ) ) ; assertEquals ( new Point ( 1 , 2 ) , node . getPoint ( ) ) ; assertEquals ( Float . MAX_VALUE , node . getStartDistance ( ) , 0.001f ) ; assertEquals ( 0.0f , node . getGoalDistance ( ) , 0.001f ) ; } @ Test public void testCompareTo ( ) { final Node node1 = new Node ( 0 , 0 ) ; final Node node2 = new Node ( 0 , 0 ) ; node1 . setStartDistance ( 1.0f ) ; node1 . setGoalDistance ( 2.0f ) ; node2 . setStartDistance ( 2.0f ) ; node2 . setGoalDistance ( 1.0f ) ; assertEquals ( 0 , node1 . compareTo ( node2 ) ) ; node2 . setGoalDistance ( 3.0f ) ; assertEquals ( - 1 , node1 . compareTo ( node2 ) ) ; } @ Test public void testToString ( ) { final Node node = new Node ( 1 , 2 ) ; assertEquals ( " ( 1 , ▁ 2 ) " , node . toString ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="Metaswitch/jitsi/tree/master/src/net/java/sip/communicator/impl/protocol/rss/ContactGroupRssImpl.java"> package net . java . sip . communicator . impl . protocol . rss ; import java . util . * ; import net . java . sip . communicator . service . protocol . * ; public class ContactGroupRssImpl implements ContactGroup { private String groupName = null ; private Vector < Contact > contacts = new Vector < Contact > ( ) ; private Vector < ContactGroup > subGroups = new Vector < ContactGroup > ( ) ; private ContactGroupRssImpl parentGroup = null ; private boolean isPersistent = true ; private ProtocolProviderServiceRssImpl parentProvider = null ; private boolean isResolved = true ; private String uid = null ; private static final String UID_SUFFIX = " . uid " ; public ContactGroupRssImpl ( String groupName , ProtocolProviderServiceRssImpl parentProvider ) { this . groupName = groupName ; this . uid = groupName + UID_SUFFIX ; this . parentProvider = parentProvider ; } public boolean canContainSubgroups ( ) { return true ; } public ProtocolProviderService getProtocolProvider ( ) { return parentProvider ; } public Iterator < Contact > contacts ( ) { return contacts . iterator ( ) ; } public void addContact ( ContactRssImpl contactToAdd ) { this . contacts . add ( contactToAdd ) ; contactToAdd . setParentGroup ( this ) ; } public int countContacts ( ) { return contacts . size ( ) ; } public int countSubgroups ( ) { return subGroups . size ( ) ; } public void addSubgroup ( ContactGroupRssImpl subgroup ) { this . subGroups . add ( subgroup ) ; subgroup . setParentGroup ( this ) ; } void setParentGroup ( ContactGroupRssImpl parent ) { this . parentGroup = parent ; } public ContactGroup getParentContactGroup ( ) { return this . parentGroup ; } public void removeSubGroup ( ContactGroupRssImpl subgroup ) { this . subGroups . remove ( subgroup ) ; subgroup . setParentGroup ( null ) ; } public ContactGroupRssImpl findGroupParent ( ContactGroupRssImpl rssGroup ) { if ( subGroups . contains ( rssGroup ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findGroupParent ( rssGroup ) ; if ( parent != null ) return parent ; } return null ; } public ContactGroupRssImpl findContactParent ( ContactRssImpl rssContact ) { if ( contacts . contains ( rssContact ) ) return this ; Iterator < ContactGroup > subGroupsIter = subgroups ( ) ; while ( subGroupsIter . hasNext ( ) ) { ContactGroupRssImpl subgroup = ( ContactGroupRssImpl ) subGroupsIter . next ( ) ; ContactGroupRssImpl parent = subgroup . findContactParent ( rssContact ) ; if ( parent != null ) return parent ; } return null ; } public Contact getContact ( String id ) { Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( contact . getAddress ( ) . equals ( id ) ) return contact ; } return null ; } public ContactGroup getGroup ( int index ) { return subGroups . get ( index ) ; } public ContactGroup getGroup ( String groupName ) { Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl contactGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; if ( contactGroup . getGroupName ( ) . equals ( groupName ) ) return contactGroup ; } return null ; } public String getGroupName ( ) { return this . groupName ; } public void setGroupName ( String newGrpName ) { this . groupName = newGrpName ; } public Iterator < ContactGroup > subgroups ( ) { return subGroups . iterator ( ) ; } public void removeContact ( ContactRssImpl contact ) { this . contacts . remove ( contact ) ; } public ContactRssImpl findContactByID ( String id ) { Iterator < Contact > contactsIter = contacts ( ) ; while ( contactsIter . hasNext ( ) ) { ContactRssImpl mContact = ( ContactRssImpl ) contactsIter . next ( ) ; if ( mContact . getAddress ( ) . equals ( id ) ) return mContact ; } Iterator < ContactGroup > groupsIter = subgroups ( ) ; while ( groupsIter . hasNext ( ) ) { ContactGroupRssImpl mGroup = ( ContactGroupRssImpl ) groupsIter . next ( ) ; ContactRssImpl mContact = mGroup . findContactByID ( id ) ; if ( mContact != null ) return mContact ; } return null ; } @ Override public String toString ( ) { StringBuffer buff = new StringBuffer ( getGroupName ( ) ) ; buff . append ( " . subGroups = " + countSubgroups ( ) + " : \n " ) ; Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; buff . append ( group . toString ( ) ) ; if ( subGroups . hasNext ( ) ) buff . append ( " \n " ) ; } buff . append ( " \n ChildContacts = " + countContacts ( ) + " : [ " ) ; Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; buff . append ( contact . toString ( ) ) ; if ( contacts . hasNext ( ) ) buff . append ( " , ▁ " ) ; } return buff . append ( " ] " ) . toString ( ) ; } public void getRssURLList ( List < ContactRssImpl > rssURLList ) { Iterator < ContactGroup > subGroups = subgroups ( ) ; while ( subGroups . hasNext ( ) ) { ContactGroupRssImpl group = ( ContactGroupRssImpl ) subGroups . next ( ) ; group . getRssURLList ( rssURLList ) ; } Iterator < Contact > contacts = contacts ( ) ; while ( contacts . hasNext ( ) ) { ContactRssImpl contact = ( ContactRssImpl ) contacts . next ( ) ; rssURLList . add ( contact ) ; } } public void setPersistent ( boolean isPersistent ) { this . isPersistent = isPersistent ; } public boolean isPersistent ( ) { return isPersistent ; } public String getPersistentData ( ) { return null ; } public boolean isResolved ( ) { return isResolved ; } public void setResolved ( boolean resolved ) { this . isResolved = resolved ; } public String getUID ( ) { return uid ; } static String createNameFromUID ( String uid ) { return uid . substring ( 0 , uid . length ( ) - ( UID_SUFFIX . length ( ) ) ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof ContactGroupRssImpl ) ) return false ; ContactGroupRssImpl rssGroup = ( ContactGroupRssImpl ) obj ; if ( ! rssGroup . getGroupName ( ) . equals ( getGroupName ( ) ) || ! rssGroup . getUID ( ) . equals ( getUID ( ) ) || rssGroup . countContacts ( ) != countContacts ( ) || rssGroup . countSubgroups ( ) != countSubgroups ( ) ) return false ; Iterator < Contact > theirContacts = rssGroup . contacts ( ) ; while ( theirContacts . hasNext ( ) ) { ContactRssImpl theirContact = ( ContactRssImpl ) theirContacts . next ( ) ; ContactRssImpl ourContact = ( ContactRssImpl ) getContact ( theirContact . getAddress ( ) ) ; if ( ourContact == null || ! ourContact . equals ( theirContact ) ) return false ; } Iterator < ContactGroup > theirSubgroups = rssGroup . subgroups ( ) ; while ( theirSubgroups . hasNext ( ) ) { ContactGroupRssImpl theirSubgroup = ( ContactGroupRssImpl ) theirSubgroups . next ( ) ; ContactGroupRssImpl ourSubgroup = ( ContactGroupRssImpl ) getGroup ( theirSubgroup . getGroupName ( ) ) ; if ( ourSubgroup == null || ! ourSubgroup . equals ( theirSubgroup ) ) return false ; } return true ; } } </DOCUMENT>
<DOCUMENT_ID="Rachels-Courses/Course-Common-Files/tree/master/STUDENT_REFERENCE/EXAMPLE_CODE/File IO/Java/OutputCSV/FileOutputter.java"> import java . io . * ; public class FileOutputter { private BufferedWriter m_writer ; private String m_filename ; public static void print ( String filename , String text ) { try { File file = new File ( filename ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; bw . write ( text ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void println ( String filename , String text ) { print ( filename , text + " \n " ) ; } public FileOutputter ( ) { m_filename = " default . txt " ; } public FileOutputter ( String filename ) { m_filename = filename ; } public void print ( String text ) { openFile ( m_filename ) ; try { m_writer . write ( text ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } closeFile ( ) ; } public void println ( String text ) { print ( text + " \n " ) ; } private void openFile ( String filename ) { try { File file = new File ( filename ) ; m_writer = new BufferedWriter ( new FileWriter ( file . getAbsoluteFile ( ) , true ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void closeFile ( ) { try { m_writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="karianna/jdk8_tl/tree/master/hotspot/test/compiler/5091921/Test6850611.java"> public class Test6850611 { public static void main ( String [ ] args ) { test ( ) ; } private static void test ( ) { for ( int j = 0 ; j < 5 ; ++ j ) { long x = 0 ; for ( int i = Integer . MIN_VALUE ; i < Integer . MAX_VALUE ; ++ i ) { x += i ; } System . out . println ( " sum : ▁ " + x ) ; if ( x != - 4294967295l ) { System . out . println ( " FAILED " ) ; System . exit ( 97 ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="farkas-arpad/KROKI-mockup-tool/tree/master/GraphEdit/src/graphedit/state/SelectionState.java"> package graphedit . state ; import graphedit . actions . popup . LinkPopupMenu ; import graphedit . app . MainFrame ; import graphedit . command . ChangeAssociationPropertiesCommand ; import graphedit . command . ChangeElementPropertiesCommand ; import graphedit . command . ChangeLinkTypeCommand ; import graphedit . command . Command ; import graphedit . gui . dialog . AssociationLinkDialog ; import graphedit . gui . dialog . ClassElementDialog ; import graphedit . model . components . AggregationLink ; import graphedit . model . components . AssociationLink ; import graphedit . model . components . Class ; import graphedit . model . components . CompositionLink ; import graphedit . model . components . GraphElement ; import graphedit . model . components . Link ; import graphedit . model . components . LinkNode ; import graphedit . model . components . Package ; import graphedit . model . properties . PropertyEnums . GraphElementProperties ; import graphedit . view . AggregationLinkPainter ; import graphedit . view . AssociationLinkPainter ; import graphedit . view . CompositionLinkPainter ; import graphedit . view . ElementPainter ; import graphedit . view . LinkPainter ; import java . awt . Cursor ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . geom . Dimension2D ; import java . awt . geom . Point2D ; import java . util . ArrayList ; import java . util . List ; import javax . swing . SwingUtilities ; public class SelectionState extends State { private Point2D popupPoint ; public SelectionState ( ) { super ( ) ; } @ Override public void mouseReleased ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isRightMouseButton ( e ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; if ( hitElement != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; showGraphElementPopup ( e ) ; } else if ( hitLink != null || hitNode != null ) { showLinkElementPopup ( e ) ; } else showGraphElementPopup ( e ) ; view . repaint ( ) ; } } @ Override public void mousePressed ( MouseEvent e ) { Link hitLink = controller . getCurrentLink ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; GraphElement hitElement = controller . getCurrentElement ( ) ; LinkNode hitNode = controller . getCurrentLinkNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null ) view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; else { view . getSelectionModel ( ) . setSelectedLink ( null ) ; if ( hitElement != null ) { if ( e . isControlDown ( ) ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeSelectedElement ( hitElement ) ; } else { view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } else { if ( ! view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } } } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { if ( ! e . isControlDown ( ) ) view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; } } } else if ( SwingUtilities . isRightMouseButton ( e ) ) { if ( hitElement != null ) { view . getSelectionModel ( ) . setSelectedLink ( null ) ; view . getSelectionModel ( ) . addSelectedElement ( hitElement ) ; } else if ( hitNode != null ) { view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else if ( hitLink != null ) { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedLink ( hitLink ) ; hitNode = view . getSelectedLinkNode ( hitLink , e . getPoint ( ) ) ; view . getSelectionModel ( ) . setSelectedNode ( hitNode ) ; } else { view . getSelectionModel ( ) . removeAllSelectedElements ( ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; view . getSelectionModel ( ) . setSelectedNode ( null ) ; } } view . repaint ( ) ; } @ Override public void mouseDragged ( MouseEvent e ) { GraphElement hitElement = controller . getCurrentElement ( ) ; Link hitLink = controller . getCurrentLink ( ) ; LinkNode hitNode = view . getSelectionModel ( ) . getSelectedNode ( ) ; if ( SwingUtilities . isLeftMouseButton ( e ) ) { if ( hitNode != null || ( hitLink != null && hitElement == null ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; state . mousePressed ( e ) ; } else if ( hitElement != null ) { if ( MainFrame . getInstance ( ) . getCurrentView ( ) . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { if ( e . isControlDown ( ) ) { } if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; ( ( MoveElementState ) state ) . setElements ( view . getSelectionModel ( ) . getSelectedElements ( ) ) ; ( ( MoveElementState ) state ) . setRightMove ( false ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getResizeState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . mousePressed ( e ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } } else { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getLassoSelectionState ( ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else if ( SwingUtilities . isRightMouseButton ( e ) && hitElement != null ) { if ( view . getCursor ( ) . getName ( ) . equals ( Cursor . getDefaultCursor ( ) . getName ( ) ) ) { State state = MainFrame . getInstance ( ) . getCurrentView ( ) . getModel ( ) . getMoveElementState ( ) ; state . mousePressed ( e ) ; state . setView ( view ) ; state . setController ( controller ) ; state . setCursor ( Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ) ; List < GraphElement > shadowElements = new ArrayList < GraphElement > ( ) ; List < ElementPainter > shadowPainters = new ArrayList < ElementPainter > ( ) ; for ( GraphElement element : view . getSelectionModel ( ) . getSelectedElements ( ) ) { try { GraphElement clone = ( GraphElement ) element . clone ( ) ; clone . setShadowElement ( true ) ; ElementPainter clonePainter = ( ElementPainter ) view . getElementPainter ( element ) . clone ( ) ; clonePainter . setElement ( clone ) ; shadowElements . add ( clone ) ; shadowPainters . add ( clonePainter ) ; } catch ( CloneNotSupportedException e1 ) { e1 . printStackTrace ( ) ; } } view . setShadowPainters ( shadowPainters ) ; ( ( MoveElementState ) state ) . setElements ( shadowElements ) ; ( ( MoveElementState ) state ) . setRightMove ( true ) ; MainFrame . getInstance ( ) . setStatusTrack ( state . toString ( ) ) ; controller . setCurrentState ( state ) ; } } else { if ( hitElement != null ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . contains ( hitElement ) ) { } } } } @ Override public void mouseMoved ( MouseEvent e ) { int xPos = e . getX ( ) ; int yPos = e . getY ( ) ; MainFrame . getInstance ( ) . setPositionTrack ( xPos , yPos ) ; if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) == 1 ) { GraphElement selectedElement = view . getSelectionModel ( ) . getSelectedElements ( ) . get ( 0 ) ; Dimension2D size = ( Dimension2D ) selectedElement . getProperty ( GraphElementProperties . SIZE ) ; Point2D position = new Point2D . Double ( ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getX ( ) - size . getWidth ( ) / 2 , ( ( Point2D ) selectedElement . getProperty ( GraphElementProperties . POSITION ) ) . getY ( ) - size . getHeight ( ) / 2 ) ; if ( position . getX ( ) <= xPos && xPos <= position . getX ( ) + 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NW_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . W_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SW_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + 4 < xPos && xPos < position . getX ( ) + size . getWidth ( ) - 4 ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . N_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . S_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else if ( position . getX ( ) + size . getWidth ( ) - 4 <= xPos && xPos <= position . getX ( ) + size . getWidth ( ) ) { if ( position . getY ( ) <= yPos && yPos <= position . getY ( ) + 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . NE_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + 4 < yPos && yPos < position . getY ( ) + size . getHeight ( ) - 4 ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . E_RESIZE_CURSOR ) ) ; } else if ( position . getY ( ) + size . getHeight ( ) - 4 <= yPos && yPos <= position . getY ( ) + size . getHeight ( ) ) { setCursor ( Cursor . getPredefinedCursor ( Cursor . SE_RESIZE_CURSOR ) ) ; } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } else { setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; } } @ Override public void keyPressed ( KeyEvent e ) { if ( e . isControlDown ( ) && e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { if ( view . getSelectionModel ( ) . getSelectedElements ( ) . size ( ) > 0 ) { } } } @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) ) if ( e . getClickCount ( ) == 2 ) { Link hitLink = controller . getCurrentLink ( ) ; if ( hitLink != null ) { if ( hitLink instanceof AssociationLink ) { AssociationLinkDialog d = new AssociationLinkDialog ( ( AssociationLink ) hitLink ) ; d . setVisible ( true ) ; if ( d . isSomethingChanged ( ) ) { if ( d . isCreateNewLink ( ) ) { AssociationLink newLink ; LinkPainter painter = null ; if ( d . isAssociation ( ) ) { newLink = new AssociationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AssociationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AssociationLinkPainter ( newLink ) ; } else if ( d . isAggregation ( ) ) { newLink = new AggregationLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " AggregationLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new AggregationLinkPainter ( newLink ) ; } else { newLink = new CompositionLink ( hitLink . getNodes ( ) , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , " CompositionLink " + ( ( AssociationLink ) hitLink ) . getCurrentCount ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , MainFrame . getInstance ( ) . incrementLinkCounter ( ) ) ; painter = new CompositionLinkPainter ( newLink ) ; } Command command = new ChangeLinkTypeCommand ( view , hitLink , newLink , painter ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; newLink . getSourceConnector ( ) . setLink ( newLink ) ; newLink . getDestinationConnector ( ) . setLink ( newLink ) ; } else { Command command = new ChangeAssociationPropertiesCommand ( view , d . getSourceCardinality ( ) , d . getDestinationCardinality ( ) , d . getSourceRole ( ) , d . getDestinationRole ( ) , d . isSourceNavigable ( ) , d . isDestinationNavigable ( ) , d . isShowSourceRole ( ) , d . isShowDestinationRole ( ) , ( AssociationLink ) hitLink ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; } view . repaint ( ) ; } } } else { GraphElement element = controller . getCurrentElement ( ) ; if ( element instanceof Package ) MainFrame . getInstance ( ) . showDiagram ( ( ( Package ) element ) . getHierarchyPackage ( ) . getDiagram ( ) ) ; else if ( element instanceof graphedit . model . components . Class ) { ClassElementDialog dialog = new ClassElementDialog ( ( Class ) element ) ; dialog . setVisible ( true ) ; if ( dialog . isOk ( ) ) { Command command = new ChangeElementPropertiesCommand ( view , dialog . getName ( ) , dialog . getStereotype ( ) , element ) ; view . getModel ( ) . getCommandManager ( ) . executeCommand ( command ) ; view . repaint ( ) ; } } } } } public void showGraphElementPopup ( MouseEvent e ) { MainFrame . getInstance ( ) . getViewPopupMenu ( ) . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } public void showLinkElementPopup ( MouseEvent e ) { LinkPopupMenu popup = MainFrame . getInstance ( ) . getLinkPopupMenu ( ) ; popup . preparePopup ( ) ; popup . setActionPoint ( e . getPoint ( ) ) ; popup . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } @ Override public boolean isAutoScrollOnDragEnabled ( ) { return false ; } @ Override public boolean isAutoScrollOnMoveEnabled ( ) { return false ; } public Point2D getPopupPoint ( ) { return popupPoint ; } public void setPopupPoint ( Point2D popupPoint ) { this . popupPoint = popupPoint ; } } </DOCUMENT>
<DOCUMENT_ID="innerverse/libjitsi/tree/master/src/org/jitsi/util/xml/DOMElementWriter.java"> package org . jitsi . util . xml ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static final String lSep = System . getProperty ( " line . separator " ) ; public static String decodeName ( String name ) { int length = name . length ( ) ; StringBuilder value = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; ) { int start = name . indexOf ( ' _ ' , i ) ; if ( start == - 1 ) { value . append ( name , i , length ) ; break ; } if ( i != start ) value . append ( name , i , start ) ; int end = start + 6 ; if ( ( end < length ) && ( name . charAt ( start + 1 ) == ' x ' ) && ( name . charAt ( end ) == ' _ ' ) && isHexDigit ( name . charAt ( start + 2 ) ) && isHexDigit ( name . charAt ( start + 3 ) ) && isHexDigit ( name . charAt ( start + 4 ) ) && isHexDigit ( name . charAt ( start + 5 ) ) ) { char c = ( char ) Integer . parseInt ( name . substring ( start + 2 , end ) , 16 ) ; if ( ( start == 0 ) ? ! isNameStartChar ( c ) : ! isNameChar ( c ) ) { value . append ( c ) ; i = end + 1 ; continue ; } } value . append ( name . charAt ( start ) ) ; i = start + 1 ; } return value . toString ( ) ; } public static String encodeName ( String value ) { int length = value . length ( ) ; StringBuilder name = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = value . charAt ( i ) ; if ( i == 0 ) { if ( isNameStartChar ( c ) ) { name . append ( c ) ; continue ; } } else if ( isNameChar ( c ) ) { name . append ( c ) ; continue ; } name . append ( " _ x " ) ; if ( c <= 0x000F ) name . append ( "000" ) ; else if ( c <= 0x00FF ) name . append ( "00" ) ; else if ( c <= 0x0FFF ) name . append ( '0' ) ; name . append ( Integer . toHexString ( c ) . toUpperCase ( ) ) ; name . append ( ' _ ' ) ; } return name . toString ( ) ; } private static boolean isHexDigit ( char c ) { return ( ( '0' <= c ) && ( c <= '9' ) ) || ( ( ' A ' <= c ) && ( c <= ' F ' ) ) || ( ( ' a ' <= c ) && ( c <= ' f ' ) ) ; } private static boolean isNameChar ( char c ) { if ( isNameStartChar ( c ) ) return true ; else if ( ( c == ' - ' ) || ( c == ' . ' ) ) return true ; else if ( ( '0' <= c ) && ( c <= '9' ) ) return true ; else if ( c == 0xB7 ) return true ; else if ( c < 0x0300 ) return false ; else if ( c <= 0x036F ) return true ; else if ( c < 0x203F ) return false ; else if ( c <= 0x2040 ) return true ; else return false ; } private static boolean isNameStartChar ( char c ) { if ( ( c == ' : ' ) || ( c == ' _ ' ) ) return true ; else if ( ( ' A ' <= c ) && ( c <= ' Z ' ) ) return true ; else if ( ( ' a ' <= c ) && ( c <= ' z ' ) ) return true ; else if ( c < 0xC0 ) return false ; else if ( c <= 0xD6 ) return true ; else if ( c < 0xD8 ) return false ; else if ( c <= 0xF6 ) return true ; else if ( c < 0xF8 ) return false ; else if ( c <= 0x2FF ) return true ; else if ( c < 0x370 ) return false ; else if ( c <= 0x37D ) return true ; else if ( c < 0x37F ) return false ; else if ( c <= 0x1FFF ) return true ; else if ( c < 0x200C ) return false ; else if ( c <= 0x200D ) return true ; else if ( c < 0x2070 ) return false ; else if ( c <= 0x218F ) return true ; else if ( c < 0x2C00 ) return false ; else if ( c <= 0x2FEF ) return true ; else if ( c < 0x3001 ) return false ; else if ( c <= 0xD7FF ) return true ; else if ( c < 0xF900 ) return false ; else if ( c <= 0xFDCF ) return true ; else if ( c < 0xFDF0 ) return false ; else if ( c <= 0xFFFD ) return true ; else return false ; } protected String [ ] knownEntities = { " gt " , " amp " , " lt " , " apos " , " quot " } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , " UTF - 8" ) ; wri . write ( " < ? xml ▁ version = \ " 1.0\ " ▁ encoding = \ " UTF - 8\ " ? > " + lSep ) ; write ( root , wri , 0 , " ▁ ▁ " ) ; wri . flush ( ) ; } public void write ( Node element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } if ( element . getNodeType ( ) == Node . COMMENT_NODE ) { out . write ( " < ! - - " ) ; out . write ( encode ( element . getNodeValue ( ) ) ) ; out . write ( " - - > " ) ; } else { out . write ( " < " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " ▁ " ) ; out . write ( attr . getName ( ) ) ; out . write ( " = \ " " ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( " \ " " ) ; } out . write ( " > " ) ; } boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; element . hasChildNodes ( ) && i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : case Node . COMMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : if ( child . getNodeValue ( ) != null && ( child . getNodeValue ( ) . indexOf ( " \n " ) == - 1 || child . getNodeValue ( ) . trim ( ) . length ( ) != 0 ) ) out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( " < ! [ CDATA [ " ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( " ] ] > " ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( ' & ' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ' ; ' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( " < ? " ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ▁ ' ) ; out . write ( data ) ; } out . write ( " ? > " ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } if ( element . getNodeType ( ) == Node . ELEMENT_NODE ) { out . write ( " < / " ) ; out . write ( ( ( Element ) element ) . getTagName ( ) ) ; out . write ( " > " ) ; } out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case ' < ' : sb . append ( " & lt ; " ) ; break ; case ' > ' : sb . append ( " & gt ; " ) ; break ; case ' \ ' ' : sb . append ( " & apos ; " ) ; break ; case ' \ " ' : sb . append ( " & quot ; " ) ; break ; case ' & ' : int nextSemi = value . indexOf ( " ; " , i ) ; if ( ( nextSemi < 0 ) || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) sb . append ( " & amp ; " ) ; else sb . append ( ' & ' ) ; break ; default : if ( isLegalCharacter ( c ) ) sb . append ( c ) ; break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( " ] ] > " ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( " & # x5d ; & # x5d ; & gt ; " ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( " ] ] > " ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == ' & ' ) || ! ent . endsWith ( " ; " ) ) return false ; if ( ent . charAt ( 1 ) == ' # ' ) { if ( ent . charAt ( 2 ) == ' x ' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="ptupitsyn/ignite/tree/master/modules/core/src/test/java/org/apache/ignite/internal/IgniteClientRejoinTest.java"> package org . apache . ignite . internal ; import java . io . IOException ; import java . io . OutputStream ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketException ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . ignite . Ignite ; import org . apache . ignite . IgniteCache ; import org . apache . ignite . IgniteCheckedException ; import org . apache . ignite . IgniteClientDisconnectedException ; import org . apache . ignite . IgniteException ; import org . apache . ignite . Ignition ; import org . apache . ignite . cluster . ClusterNode ; import org . apache . ignite . configuration . IgniteConfiguration ; import org . apache . ignite . failure . AbstractFailureHandler ; import org . apache . ignite . failure . FailureContext ; import org . apache . ignite . failure . TestFailureHandler ; import org . apache . ignite . internal . util . typedef . internal . U ; import org . apache . ignite . lang . IgniteInClosure ; import org . apache . ignite . plugin . extensions . communication . Message ; import org . apache . ignite . spi . IgniteSpiException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutException ; import org . apache . ignite . spi . IgniteSpiOperationTimeoutHelper ; import org . apache . ignite . spi . discovery . tcp . TcpDiscoverySpi ; import org . apache . ignite . spi . discovery . tcp . messages . TcpDiscoveryAbstractMessage ; import org . apache . ignite . testframework . GridTestUtils ; import org . apache . ignite . testframework . junits . common . GridCommonAbstractTest ; import org . junit . Test ; public class IgniteClientRejoinTest extends GridCommonAbstractTest { private volatile boolean block ; private volatile boolean blockAll ; private volatile ClusterNode crd ; private boolean clientReconnectDisabled ; @ Override protected void beforeTestsStarted ( ) throws Exception { System . setProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " , " true " ) ; } @ Override protected void afterTestsStopped ( ) throws Exception { System . clearProperty ( " IGNITE _ SKIP _ CONFIGURATION _ CONSISTENCY _ CHECK " ) ; } @ Override protected void afterTest ( ) throws Exception { stopAllGrids ( ) ; } @ Override protected void beforeTest ( ) throws Exception { clientReconnectDisabled = false ; } @ Override protected IgniteConfiguration getConfiguration ( String gridName ) throws Exception { IgniteConfiguration cfg = super . getConfiguration ( gridName ) ; if ( gridName . contains ( " client " ) ) { cfg . setCommunicationSpi ( new TcpCommunicationSpi ( ) ) ; TcpDiscoverySpi spi = ( TcpDiscoverySpi ) cfg . getDiscoverySpi ( ) ; DiscoverySpi dspi = new DiscoverySpi ( ) ; dspi . setIpFinder ( spi . getIpFinder ( ) ) ; cfg . setDiscoverySpi ( dspi ) ; dspi . setJoinTimeout ( 60_000 ) ; dspi . setClientReconnectDisabled ( clientReconnectDisabled ) ; cfg . setClientMode ( true ) ; } cfg . setPeerClassLoadingEnabled ( false ) ; return cfg ; } @ Test public void testClientsReconnectAfterStart ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; List < Ignite > clientNodes = new ArrayList < > ( ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) clientNodes . add ( startGrid ( " client " + i ) ) ; blockAll = true ; GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { U . sleep ( 5_000 ) ; block = true ; blockAll = false ; System . out . println ( " > > > ▁ Allow ▁ with ▁ blocked ▁ coordinator . " ) ; latch . countDown ( ) ; return null ; } } ) ; IgniteInternalFuture < Object > fut = GridTestUtils . runAsync ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { latch . await ( ) ; U . sleep ( ( new Random ( ) . nextInt ( 15 ) + 30 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ Allow ▁ coordinator . " ) ; return null ; } } ) ; fut . get ( ) ; for ( Ignite client : clientNodes ) { while ( true ) { try { IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( " some " ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assertEquals ( ( Integer ) i , cache . get ( i ) ) ; cache . clear ( ) ; break ; } catch ( IgniteClientDisconnectedException e ) { e . reconnectFuture ( ) . get ( ) ; } } } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Test public void testClientsReconnect ( ) throws Exception { Ignite srv1 = startGrid ( " server1" ) ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String nodeName = " client " + idx ; IgniteConfiguration cfg = getConfiguration ( nodeName ) . setFailureHandler ( new AbstractFailureHandler ( ) { @ Override protected boolean handle ( Ignite ignite , FailureContext failureCtx ) { Runtime . getRuntime ( ) . halt ( Ignition . KILL_EXIT_CODE ) ; return false ; } } ) ; return startGrid ( nodeName , optimize ( cfg ) , null ) ; } } ) ; futs . add ( fut ) ; } GridTestUtils . runAsync ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { latch . countDown ( ) ; Random rnd = new Random ( ) ; U . sleep ( ( rnd . nextInt ( 15 ) + 15 ) * 1000 ) ; block = false ; System . out . println ( " > > > ▁ ALLOW ▁ connection ▁ to ▁ coordinator . " ) ; return true ; } } ) ; for ( IgniteInternalFuture < Ignite > clientFut : futs ) { Ignite client = clientFut . get ( ) ; IgniteCache < Integer , Integer > cache = client . getOrCreateCache ( client . name ( ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) cache . put ( i , i ) ; for ( int i = 0 ; i < 100 ; i ++ ) assert i == cache . get ( i ) ; } assertEquals ( CLIENTS_NUM , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( CLIENTS_NUM , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Test public void testClientsReconnectDisabled ( ) throws Exception { clientReconnectDisabled = true ; Ignite srv1 = startGrid ( " server1" ) ; if ( ! tcpDiscovery ( ) ) return ; crd = ( ( IgniteKernal ) srv1 ) . localNode ( ) ; Ignite srv2 = startGrid ( " server2" ) ; block = true ; List < IgniteInternalFuture < Ignite > > futs = new ArrayList < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int CLIENTS_NUM = 5 ; final CountDownLatch failureHndLatch = new CountDownLatch ( CLIENTS_NUM ) ; for ( int i = 0 ; i < CLIENTS_NUM ; i ++ ) { final int idx = i ; IgniteInternalFuture < Ignite > fut = GridTestUtils . runAsync ( new Callable < Ignite > ( ) { @ Override public Ignite call ( ) throws Exception { latch . await ( ) ; String igniteInstanceName = " client " + idx ; return startGrid ( igniteInstanceName , getConfiguration ( igniteInstanceName ) . setFailureHandler ( new TestFailureHandler ( true , failureHndLatch ) ) ) ; } } ) ; futs . add ( fut ) ; } latch . countDown ( ) ; for ( final IgniteInternalFuture < Ignite > clientFut : futs ) { GridTestUtils . assertThrows ( log , new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { clientFut . get ( ) ; return null ; } } , IgniteCheckedException . class , null ) ; } assertTrue ( failureHndLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 0 , srv1 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; assertEquals ( 0 , srv2 . cluster ( ) . forClients ( ) . nodes ( ) . size ( ) ) ; } @ Override protected long getTestTimeout ( ) { return 3 * 60_000 ; } private class TcpCommunicationSpi extends org . apache . ignite . spi . communication . tcp . TcpCommunicationSpi { @ Override public void sendMessage ( ClusterNode node , Message msg ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg ) ; } @ Override public void sendMessage ( ClusterNode node , Message msg , IgniteInClosure < IgniteException > ackC ) throws IgniteSpiException { if ( blockAll || block && node . id ( ) . equals ( crd . id ( ) ) ) throw new IgniteSpiException ( new SocketException ( " Test ▁ communication ▁ exception " ) ) ; super . sendMessage ( node , msg , ackC ) ; } } private class DiscoverySpi extends TcpDiscoverySpi { @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , byte [ ] data , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , data , timeout ) ; } @ Override protected void writeToSocket ( Socket sock , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , msg , timeout ) ; } @ Override protected void writeToSocket ( Socket sock , OutputStream out , TcpDiscoveryAbstractMessage msg , long timeout ) throws IOException , IgniteCheckedException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( sock , out , msg , timeout ) ; } @ Override protected void writeToSocket ( TcpDiscoveryAbstractMessage msg , Socket sock , int res , long timeout ) throws IOException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; super . writeToSocket ( msg , sock , res , timeout ) ; } @ Override protected Socket openSocket ( Socket sock , InetSocketAddress remAddr , IgniteSpiOperationTimeoutHelper timeoutHelper ) throws IOException , IgniteSpiOperationTimeoutException { if ( blockAll || block && sock . getPort ( ) == 47500 ) throw new SocketException ( " Test ▁ discovery ▁ exception " ) ; return super . openSocket ( sock , remAddr , timeoutHelper ) ; } } } </DOCUMENT>
<DOCUMENT_ID="yuanke/hadoop-hbase/tree/master/src/test/org/apache/hadoop/mapred/TestKillCompletedJob.java"> package org . apache . hadoop . mapred ; import java . io . * ; import java . net . * ; import junit . framework . TestCase ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hdfs . MiniDFSCluster ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IntWritable ; import org . apache . hadoop . io . Text ; public class TestKillCompletedJob extends TestCase { static Boolean launchWordCount ( String fileSys , String jobTracker , JobConf conf , String input , int numMaps , int numReduces ) throws IOException { final Path inDir = new Path ( " / testing / wc / input " ) ; final Path outDir = new Path ( " / testing / wc / output " ) ; FileSystem fs = FileSystem . get ( URI . create ( fileSys ) , conf ) ; fs . delete ( outDir , true ) ; if ( ! fs . mkdirs ( inDir ) ) { throw new IOException ( " Mkdirs ▁ failed ▁ to ▁ create ▁ " + inDir . toString ( ) ) ; } { DataOutputStream file = fs . create ( new Path ( inDir , " part - 0" ) ) ; file . writeBytes ( input ) ; file . close ( ) ; } FileSystem . setDefaultUri ( conf , fileSys ) ; conf . set ( " mapred . job . tracker " , jobTracker ) ; conf . setJobName ( " wordcount " ) ; conf . setInputFormat ( TextInputFormat . class ) ; conf . setOutputKeyClass ( Text . class ) ; conf . setOutputValueClass ( IntWritable . class ) ; conf . setMapperClass ( WordCount . MapClass . class ) ; conf . setCombinerClass ( WordCount . Reduce . class ) ; conf . setReducerClass ( WordCount . Reduce . class ) ; FileInputFormat . setInputPaths ( conf , inDir ) ; FileOutputFormat . setOutputPath ( conf , outDir ) ; conf . setNumMapTasks ( numMaps ) ; conf . setNumReduceTasks ( numReduces ) ; RunningJob rj = JobClient . runJob ( conf ) ; JobID jobId = rj . getID ( ) ; if ( rj . isSuccessful ( ) ) { System . out . println ( " Job ▁ Id : " + jobId + " ▁ completed ▁ successfully . ▁ Killing ▁ it ▁ now " ) ; rj . killJob ( ) ; } return rj . isSuccessful ( ) ; } public void testKillCompJob ( ) throws IOException { String namenode = null ; MiniDFSCluster dfs = null ; MiniMRCluster mr = null ; FileSystem fileSys = null ; try { final int taskTrackers = 1 ; Configuration conf = new Configuration ( ) ; dfs = new MiniDFSCluster ( conf , 1 , true , null ) ; fileSys = dfs . getFileSystem ( ) ; namenode = fileSys . getUri ( ) . toString ( ) ; mr = new MiniMRCluster ( taskTrackers , namenode , 3 ) ; JobConf jobConf = new JobConf ( ) ; Boolean result ; final String jobTrackerName = " localhost : " + mr . getJobTrackerPort ( ) ; result = launchWordCount ( namenode , jobTrackerName , jobConf , " Small ▁ text \n " , 1 , 0 ) ; assertTrue ( result ) ; } finally { if ( dfs != null ) { dfs . shutdown ( ) ; } if ( mr != null ) { mr . shutdown ( ) ; } } } } </DOCUMENT>
<DOCUMENT_ID="moosbusch/xbLIDO/tree/master/src/net/opengis/gml/GridCoverageDocument.java"> package net . opengis . gml ; public interface GridCoverageDocument extends net . opengis . gml . DiscreteCoverageDocument { public static final org . apache . xmlbeans . SchemaType type = ( org . apache . xmlbeans . SchemaType ) org . apache . xmlbeans . XmlBeans . typeSystemForClassLoader ( GridCoverageDocument . class . getClassLoader ( ) , " schemaorg _ apache _ xmlbeans . system . s6E28D279B6C224D74769DB8B98AF1665" ) . resolveHandle ( " gridcoveragea6fddoctype " ) ; net . opengis . gml . GridCoverageType getGridCoverage ( ) ; void setGridCoverage ( net . opengis . gml . GridCoverageType gridCoverage ) ; net . opengis . gml . GridCoverageType addNewGridCoverage ( ) ; public static final class Factory { public static net . opengis . gml . GridCoverageDocument newInstance ( ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } public static net . opengis . gml . GridCoverageDocument newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . lang . String xmlAsString , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xmlAsString , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . File file , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( file , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( javax . xml . stream . XMLStreamReader sr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( sr , type , options ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } public static net . opengis . gml . GridCoverageDocument parse ( org . w3c . dom . Node node , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( node , type , options ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } @ Deprecated public static net . opengis . gml . GridCoverageDocument parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( net . opengis . gml . GridCoverageDocument ) org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } @ Deprecated public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return org . apache . xmlbeans . XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } private Factory ( ) { } } } </DOCUMENT>
<DOCUMENT_ID="kingargyle/adt-leanback-support/tree/master/leanback-v17/src/main/java/android/support/v17/leanback/app/HeadersFragment.java"> package android . support . v17 . leanback . app ; import android . content . Context ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . graphics . drawable . GradientDrawable ; import android . os . Bundle ; import android . support . v17 . leanback . R ; import android . support . v17 . leanback . widget . FocusHighlightHelper ; import android . support . v17 . leanback . widget . ItemBridgeAdapter ; import android . support . v17 . leanback . widget . PresenterSelector ; import android . support . v17 . leanback . widget . OnItemSelectedListener ; import android . support . v17 . leanback . widget . Row ; import android . support . v17 . leanback . widget . RowHeaderPresenter ; import android . support . v17 . leanback . widget . SinglePresenterSelector ; import android . support . v17 . leanback . widget . VerticalGridView ; import android . util . TypedValue ; import android . view . View ; import android . view . ViewGroup ; import android . view . View . OnLayoutChangeListener ; import android . widget . FrameLayout ; public class HeadersFragment extends BaseRowFragment { interface OnHeaderClickedListener { void onHeaderClicked ( ) ; } private OnItemSelectedListener mOnItemSelectedListener ; private OnHeaderClickedListener mOnHeaderClickedListener ; private boolean mHeadersEnabled = true ; private boolean mHeadersGone = false ; private int mBackgroundColor ; private boolean mBackgroundColorSet ; private static final PresenterSelector sHeaderPresenter = new SinglePresenterSelector ( new RowHeaderPresenter ( R . layout . lb_header ) ) ; public HeadersFragment ( ) { setPresenterSelector ( sHeaderPresenter ) ; } public void setOnHeaderClickedListener ( OnHeaderClickedListener listener ) { mOnHeaderClickedListener = listener ; } public void setOnItemSelectedListener ( OnItemSelectedListener listener ) { mOnItemSelectedListener = listener ; } @ Override protected VerticalGridView findGridViewFromRoot ( View view ) { return ( VerticalGridView ) view . findViewById ( R . id . browse_headers ) ; } @ Override protected void onRowSelected ( ViewGroup parent , View view , int position , long id ) { if ( mOnItemSelectedListener != null ) { if ( position >= 0 ) { Row row = ( Row ) getAdapter ( ) . get ( position ) ; mOnItemSelectedListener . onItemSelected ( null , row ) ; } else { mOnItemSelectedListener . onItemSelected ( null , null ) ; } } } private final ItemBridgeAdapter . AdapterListener mAdapterListener = new ItemBridgeAdapter . AdapterListener ( ) { @ Override public void onCreate ( ItemBridgeAdapter . ViewHolder viewHolder ) { View headerView = viewHolder . getViewHolder ( ) . view ; headerView . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( mOnHeaderClickedListener != null ) { mOnHeaderClickedListener . onHeaderClicked ( ) ; } } } ) ; headerView . setFocusable ( true ) ; headerView . setFocusableInTouchMode ( true ) ; if ( mWrapper != null ) { viewHolder . itemView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } else { headerView . addOnLayoutChangeListener ( sLayoutChangeListener ) ; } } } ; private static OnLayoutChangeListener sLayoutChangeListener = new OnLayoutChangeListener ( ) { @ Override public void onLayoutChange ( View v , int left , int top , int right , int bottom , int oldLeft , int oldTop , int oldRight , int oldBottom ) { v . setPivotX ( 0 ) ; v . setPivotY ( v . getMeasuredHeight ( ) / 2 ) ; } } ; @ Override protected int getLayoutResourceId ( ) { return R . layout . lb_headers_fragment ; } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView == null ) { return ; } if ( getBridgeAdapter ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( listView ) ; } view . setBackgroundColor ( getBackgroundColor ( ) ) ; updateFadingEdgeToBrandColor ( getBackgroundColor ( ) ) ; updateListViewVisibility ( ) ; } private void updateListViewVisibility ( ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { getView ( ) . setVisibility ( mHeadersGone ? View . GONE : View . VISIBLE ) ; if ( ! mHeadersGone ) { if ( mHeadersEnabled ) { listView . setChildrenVisibility ( View . VISIBLE ) ; } else { listView . setChildrenVisibility ( View . INVISIBLE ) ; } } } } void setHeadersEnabled ( boolean enabled ) { mHeadersEnabled = enabled ; updateListViewVisibility ( ) ; } void setHeadersGone ( boolean gone ) { mHeadersGone = gone ; updateListViewVisibility ( ) ; } static class NoOverlappingFrameLayout extends FrameLayout { public NoOverlappingFrameLayout ( Context context ) { super ( context ) ; } @ Override public boolean hasOverlappingRendering ( ) { return false ; } } private final ItemBridgeAdapter . Wrapper mWrapper = new ItemBridgeAdapter . Wrapper ( ) { @ Override public void wrap ( View wrapper , View wrapped ) { ( ( FrameLayout ) wrapper ) . addView ( wrapped ) ; } @ Override public View createWrapper ( View root ) { return new NoOverlappingFrameLayout ( root . getContext ( ) ) ; } } ; @ Override protected void updateAdapter ( ) { super . updateAdapter ( ) ; ItemBridgeAdapter adapter = getBridgeAdapter ( ) ; if ( adapter != null ) { adapter . setAdapterListener ( mAdapterListener ) ; adapter . setWrapper ( mWrapper ) ; } if ( adapter != null && getVerticalGridView ( ) != null ) { FocusHighlightHelper . setupHeaderItemFocusHighlight ( getVerticalGridView ( ) ) ; } } void setBackgroundColor ( int color ) { mBackgroundColor = color ; mBackgroundColorSet = true ; if ( getView ( ) != null ) { getView ( ) . setBackgroundColor ( mBackgroundColor ) ; updateFadingEdgeToBrandColor ( mBackgroundColor ) ; } } private void updateFadingEdgeToBrandColor ( int backgroundColor ) { View fadingView = getView ( ) . findViewById ( R . id . fade_out_edge ) ; Drawable background = fadingView . getBackground ( ) ; if ( background instanceof GradientDrawable ) { background . mutate ( ) ; ( ( GradientDrawable ) background ) . setColors ( new int [ ] { Color . TRANSPARENT , backgroundColor } ) ; } } int getBackgroundColor ( ) { if ( getActivity ( ) == null ) { throw new IllegalStateException ( " Activity ▁ must ▁ be ▁ attached " ) ; } if ( mBackgroundColorSet ) { return mBackgroundColor ; } TypedValue outValue = new TypedValue ( ) ; getActivity ( ) . getTheme ( ) . resolveAttribute ( R . attr . defaultBrandColor , outValue , true ) ; return getResources ( ) . getColor ( outValue . resourceId ) ; } @ Override void onTransitionStart ( ) { super . onTransitionStart ( ) ; if ( ! mHeadersEnabled ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_BEFORE_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } } @ Override void onTransitionEnd ( ) { if ( mHeadersEnabled ) { final VerticalGridView listView = getVerticalGridView ( ) ; if ( listView != null ) { listView . setDescendantFocusability ( ViewGroup . FOCUS_AFTER_DESCENDANTS ) ; if ( listView . hasFocus ( ) ) { listView . requestFocus ( ) ; } } } super . onTransitionEnd ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="avasilevskiy/presto/tree/master/presto-raptor/src/main/java/com/facebook/presto/raptor/metadata/ShardNodes.java"> package com . facebook . presto . raptor . metadata ; import com . google . common . collect . ImmutableSet ; import java . util . Objects ; import java . util . Set ; import java . util . UUID ; import static com . google . common . base . MoreObjects . toStringHelper ; import static com . google . common . base . Preconditions . checkNotNull ; public class ShardNodes { private final UUID shardUuid ; private final Set < String > nodeIdentifiers ; public ShardNodes ( UUID shardUuid , Set < String > nodeIdentifiers ) { this . shardUuid = checkNotNull ( shardUuid , " shardUuid ▁ is ▁ null " ) ; this . nodeIdentifiers = ImmutableSet . copyOf ( checkNotNull ( nodeIdentifiers , " nodeIdentifiers ▁ is ▁ null " ) ) ; } public UUID getShardUuid ( ) { return shardUuid ; } public Set < String > getNodeIdentifiers ( ) { return nodeIdentifiers ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } ShardNodes other = ( ShardNodes ) obj ; return Objects . equals ( this . shardUuid , other . shardUuid ) && Objects . equals ( this . nodeIdentifiers , other . nodeIdentifiers ) ; } @ Override public int hashCode ( ) { return Objects . hash ( shardUuid , nodeIdentifiers ) ; } @ Override public String toString ( ) { return toStringHelper ( this ) . add ( " shardUuid " , shardUuid ) . add ( " nodeIdentifiers " , nodeIdentifiers ) . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="tuchida/rhino/tree/master/testsrc/org/mozilla/javascript/tests/Bug688021Test.java"> package org . mozilla . javascript . tests ; import static org . junit . Assert . assertEquals ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mozilla . javascript . CompilerEnvirons ; import org . mozilla . javascript . Context ; import org . mozilla . javascript . ErrorReporter ; import org . mozilla . javascript . Parser ; import org . mozilla . javascript . ast . AstRoot ; public class Bug688021Test { private Context cx ; @ Before public void setUp ( ) { cx = Context . enter ( ) ; cx . setLanguageVersion ( Context . VERSION_1_8 ) ; } @ After public void tearDown ( ) { Context . exit ( ) ; } private AstRoot parse ( CharSequence cs ) { CompilerEnvirons compilerEnv = new CompilerEnvirons ( ) ; compilerEnv . initFromContext ( cx ) ; ErrorReporter compilationErrorReporter = compilerEnv . getErrorReporter ( ) ; Parser p = new Parser ( compilerEnv , compilationErrorReporter ) ; return p . parse ( cs . toString ( ) , " < eval > " , 1 ) ; } private String toSource ( CharSequence cs ) { return parse ( cs ) . toSource ( ) ; } @ Test public void testToSource ( ) { assertEquals ( " debugger ; \n " , toSource ( " debugger " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; " ) ) ; assertEquals ( " debugger ; \n " , toSource ( " debugger ; \n " ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="huangbop/takeout/tree/master/app/src/main/java/com/huangbop/takeout/IndexActivity.java"> package com . huangbop . takeout ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . DialogInterface ; import android . content . Intent ; import android . os . Bundle ; import android . view . KeyEvent ; import android . view . View ; import android . widget . Button ; import android . widget . Toast ; public class IndexActivity extends Activity { private Button btnIndex0 ; private Button btnIndex1 ; private Button btnIndex2 ; private ButtonListener listener ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_index ) ; listener = new ButtonListener ( ) ; findButtons ( ) ; setClickListener ( ) ; } private long exitTime = 0 ; @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK && event . getAction ( ) == KeyEvent . ACTION_DOWN ) { if ( ( System . currentTimeMillis ( ) - exitTime ) > 2000 ) { Toast . makeText ( this , " Press ▁ again ▁ to ▁ exit . " , Toast . LENGTH_SHORT ) . show ( ) ; exitTime = System . currentTimeMillis ( ) ; } else { finish ( ) ; System . exit ( 0 ) ; } return true ; } return super . onKeyDown ( keyCode , event ) ; } private void setClickListener ( ) { btnIndex0 . setOnClickListener ( listener ) ; btnIndex1 . setOnClickListener ( listener ) ; btnIndex2 . setOnClickListener ( listener ) ; } private void findButtons ( ) { btnIndex0 = ( Button ) findViewById ( R . id . btnIndex0 ) ; btnIndex1 = ( Button ) findViewById ( R . id . btnIndex1 ) ; btnIndex2 = ( Button ) findViewById ( R . id . btnIndex2 ) ; } private class ButtonListener implements View . OnClickListener { @ Override public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . btnIndex0 : Intent intent0 = new Intent ( IndexActivity . this , MainActivity . class ) ; startActivity ( intent0 ) ; break ; case R . id . btnIndex1 : Intent intent1 = new Intent ( IndexActivity . this , SecondActivity . class ) ; startActivity ( intent1 ) ; break ; case R . id . btnIndex2 : Intent intent2 = new Intent ( IndexActivity . this , LifeCycle . class ) ; startActivity ( intent2 ) ; break ; } } } } </DOCUMENT>
<DOCUMENT_ID="dslomov/intellij-community/tree/master/java/compiler/impl/src/com/intellij/compiler/impl/javaCompiler/javac/JavacCompiler.java"> package com . intellij . compiler . impl . javaCompiler . javac ; import com . intellij . compiler . impl . javaCompiler . BackendCompiler ; import com . intellij . openapi . compiler . CompilerBundle ; import com . intellij . openapi . fileTypes . FileType ; import com . intellij . openapi . fileTypes . StdFileTypes ; import com . intellij . openapi . options . Configurable ; import com . intellij . openapi . project . Project ; import org . jetbrains . annotations . NonNls ; import org . jetbrains . annotations . NotNull ; import org . jetbrains . jps . model . java . compiler . JavaCompilers ; import java . util . Collections ; import java . util . Set ; public class JavacCompiler implements BackendCompiler { private final Project myProject ; public JavacCompiler ( Project project ) { myProject = project ; } @ NotNull @ NonNls public String getId ( ) { return JavaCompilers . JAVAC_ID ; } @ NotNull public String getPresentableName ( ) { return CompilerBundle . message ( " compiler . javac . name " ) ; } @ NotNull public Configurable createConfigurable ( ) { return new JavacConfigurable ( JavacConfiguration . getOptions ( myProject , JavacConfiguration . class ) ) ; } @ NotNull public Set < FileType > getCompilableFileTypes ( ) { return Collections . < FileType > singleton ( StdFileTypes . JAVA ) ; } } </DOCUMENT>
<DOCUMENT_ID="AtwooTM/cassandra/tree/master/src/java/org/apache/cassandra/cql3/UTName.java"> package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; public class UTName { private String ksName ; private final ColumnIdentifier utName ; public UTName ( ColumnIdentifier ksName , ColumnIdentifier utName ) { this . ksName = ksName == null ? null : ksName . toString ( ) ; this . utName = utName ; } public boolean hasKeyspace ( ) { return ksName != null ; } public void setKeyspace ( String keyspace ) { this . ksName = keyspace ; } public String getKeyspace ( ) { return ksName ; } public ByteBuffer getUserTypeName ( ) { return utName . bytes ; } public String getStringTypeName ( ) { return utName . toString ( ) ; } @ Override public String toString ( ) { return ( hasKeyspace ( ) ? ( ksName + " . " ) : " " ) + utName ; } } </DOCUMENT>
<DOCUMENT_ID="skyHALud/codenameone/tree/master/Ports/iOSPort/xmlvm/apache-harmony-6.0-src-r991881/classlib/modules/luni/src/test/api/common/org/apache/harmony/luni/tests/java/lang/ThreadTest.java"> package org . apache . harmony . luni . tests . java . lang ; import java . lang . Thread . UncaughtExceptionHandler ; import java . security . Permission ; import java . util . Map ; public class ThreadTest extends junit . framework . TestCase { static class SimpleThread implements Runnable { int delay ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; this . wait ( delay ) ; } } catch ( InterruptedException e ) { return ; } } public SimpleThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class YieldThread implements Runnable { volatile int delay ; public void run ( ) { int x = 0 ; while ( true ) { ++ x ; } } public YieldThread ( int d ) { if ( d >= 0 ) delay = d ; } } static class ResSupThread implements Runnable { Thread parent ; volatile int checkVal = - 1 ; public void run ( ) { try { synchronized ( this ) { this . notify ( ) ; } while ( true ) { checkVal ++ ; zz ( ) ; Thread . sleep ( 100 ) ; } } catch ( InterruptedException e ) { return ; } catch ( BogusException e ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException x ) { } parent . interrupt ( ) ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException x ) { break ; } } } } public void zz ( ) throws BogusException { } public ResSupThread ( Thread t ) { parent = t ; } public synchronized int getCheckVal ( ) { return checkVal ; } } static class BogusException extends Throwable { private static final long serialVersionUID = 1L ; public BogusException ( String s ) { super ( s ) ; } } Thread st , ct , spinner ; static boolean calledMySecurityManager = false ; public void test_Constructor ( ) { Thread t ; SecurityManager m = new SecurityManager ( ) { @ Override public ThreadGroup getThreadGroup ( ) { calledMySecurityManager = true ; return Thread . currentThread ( ) . getThreadGroup ( ) ; } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } ; try { System . setSecurityManager ( m ) ; t = new Thread ( ) ; } finally { System . setSecurityManager ( null ) ; } assertTrue ( " Did ▁ not ▁ call ▁ SecurityManager . getThreadGroup ▁ ( ) " , calledMySecurityManager ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_Runnable ( ) { ct = new Thread ( new SimpleThread ( 10 ) ) ; ct . start ( ) ; } public void test_ConstructorLjava_lang_RunnableLjava_lang_String ( ) { Thread st1 = new Thread ( new SimpleThread ( 1 ) , " SimpleThread1" ) ; assertEquals ( " Constructed ▁ thread ▁ with ▁ incorrect ▁ thread ▁ name " , " SimpleThread1" , st1 . getName ( ) ) ; st1 . start ( ) ; } public void test_ConstructorLjava_lang_String ( ) { Thread t = new Thread ( " Testing " ) ; assertEquals ( " Created ▁ tread ▁ with ▁ incorrect ▁ name " , " Testing " , t . getName ( ) ) ; t . start ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_Runnable ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group1" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread2" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_RunnableLjava_lang_String ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group2" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread3" ) ; assertTrue ( " Constructed ▁ incorrect ▁ thread " , ( st . getThreadGroup ( ) == tg ) && st . getName ( ) . equals ( " SimpleThread3" ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; Runnable r = new Runnable ( ) { public void run ( ) { } } ; ThreadGroup foo = null ; try { new Thread ( foo = new ThreadGroup ( " foo " ) , r , null ) ; fail ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " ) ; } catch ( NullPointerException npe ) { assertTrue ( " Null ▁ cannot ▁ be ▁ accepted ▁ as ▁ Thread ▁ name " , true ) ; foo . destroy ( ) ; } } public void test_ConstructorLjava_lang_ThreadGroupLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread4" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread4" , st . getName ( ) ) ; st . start ( ) ; } public void test_activeCount ( ) { Thread t = new Thread ( new SimpleThread ( 10 ) ) ; int active = 0 ; synchronized ( t ) { t . start ( ) ; active = Thread . activeCount ( ) ; } assertTrue ( " Incorrect ▁ activeCount ▁ for ▁ current ▁ group : ▁ " + active , active > 1 ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { } } public void test_checkAccess ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group3" ) ; try { st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread5" ) ; st . checkAccess ( ) ; assertTrue ( " CheckAccess ▁ passed " , true ) ; } catch ( SecurityException e ) { fail ( " CheckAccess ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; } st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_countStackFrames ( ) { Thread . currentThread ( ) . countStackFrames ( ) ; } public void test_currentThread ( ) { assertNotNull ( Thread . currentThread ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_destroy ( ) { try { new Thread ( ) . destroy ( ) ; } catch ( NoSuchMethodError e ) { } } public void test_enumerate$Ljava_lang_Thread ( ) { class MyThread extends Thread { MyThread ( ThreadGroup tg , String name ) { super ( tg , name ) ; } boolean failed = false ; String failMessage = null ; public void run ( ) { SimpleThread st1 = null ; SimpleThread st2 = null ; ThreadGroup mytg = null ; Thread firstOne = null ; Thread secondOne = null ; try { int arrayLength = 10 ; Thread [ ] tarray = new Thread [ arrayLength ] ; st1 = new SimpleThread ( - 1 ) ; st2 = new SimpleThread ( - 1 ) ; mytg = new ThreadGroup ( " jp " ) ; firstOne = new Thread ( mytg , st1 , " firstOne2" ) ; secondOne = new Thread ( mytg , st2 , " secondOne1" ) ; int count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned1" , 1 , count ) ; synchronized ( st1 ) { firstOne . start ( ) ; try { st1 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned2" , 2 , count ) ; synchronized ( st2 ) { secondOne . start ( ) ; try { st2 . wait ( ) ; } catch ( InterruptedException e ) { } } count = Thread . enumerate ( tarray ) ; assertEquals ( " Incorrect ▁ value ▁ returned3" , 3 , count ) ; } catch ( junit . framework . AssertionFailedError e ) { failed = true ; failMessage = e . getMessage ( ) ; } finally { synchronized ( st1 ) { firstOne . interrupt ( ) ; } synchronized ( st2 ) { secondOne . interrupt ( ) ; } try { firstOne . join ( ) ; secondOne . join ( ) ; } catch ( InterruptedException e ) { } mytg . destroy ( ) ; } } } ; ThreadGroup tg = new ThreadGroup ( " tg " ) ; MyThread t = new MyThread ( tg , " top " ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt " ) ; } finally { tg . destroy ( ) ; } assertFalse ( t . failMessage , t . failed ) ; } public void test_getContextClassLoader ( ) { Thread t = new Thread ( ) ; assertTrue ( " Incorrect ▁ class ▁ loader ▁ returned " , t . getContextClassLoader ( ) == Thread . currentThread ( ) . getContextClassLoader ( ) ) ; t . start ( ) ; } public void test_getName ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread6" ) ; assertEquals ( " Returned ▁ incorrect ▁ thread ▁ name " , " SimpleThread6" , st . getName ( ) ) ; st . start ( ) ; } public void test_getPriority ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_getThreadGroup ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group4" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread8" ) ; assertTrue ( " Returned ▁ incorrect ▁ thread ▁ group " , st . getThreadGroup ( ) == tg ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } assertNull ( " group ▁ should ▁ be ▁ null " , st . getThreadGroup ( ) ) ; assertNotNull ( " toString ( ) ▁ should ▁ not ▁ be ▁ null " , st . toString ( ) ) ; tg . destroy ( ) ; final Object lock = new Object ( ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } } ; synchronized ( lock ) { t . start ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } int running = 0 ; while ( t . isAlive ( ) ) running ++ ; ThreadGroup group = t . getThreadGroup ( ) ; assertNull ( " ThreadGroup ▁ is ▁ not ▁ null " , group ) ; } public void test_interrupt ( ) { final Object lock = new Object ( ) ; class ChildThread1 extends Thread { Thread parent ; boolean sync ; @ Override public void run ( ) { if ( sync ) { synchronized ( lock ) { lock . notify ( ) ; try { lock . wait ( ) ; } catch ( InterruptedException e ) { } } } parent . interrupt ( ) ; } public ChildThread1 ( Thread p , String name , boolean sync ) { super ( name ) ; parent = p ; this . sync = sync ; } } boolean interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test1" , false ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; } } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread1" , interrupted ) ; interrupted = false ; try { ct = new ChildThread1 ( Thread . currentThread ( ) , " Interrupt ▁ Test2" , true ) ; synchronized ( lock ) { ct . start ( ) ; lock . wait ( ) ; lock . notify ( ) ; } Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { interrupted = true ; } assertTrue ( " Failed ▁ to ▁ Interrupt ▁ thread2" , interrupted ) ; } public void test_interrupted ( ) { assertFalse ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; assertTrue ( " Interrupted ▁ returned ▁ true ▁ for ▁ non - interrupted ▁ thread " , Thread . interrupted ( ) ) ; assertFalse ( " Failed ▁ to ▁ clear ▁ interrupted ▁ flag " , Thread . interrupted ( ) ) ; } public void test_isAlive ( ) { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 500 ) ) ; assertFalse ( " A ▁ thread ▁ that ▁ wasn ' t ▁ started ▁ is ▁ alive . " , st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; try { simple . wait ( ) ; } catch ( InterruptedException e ) { } } assertTrue ( " Started ▁ thread ▁ returned ▁ false " , st . isAlive ( ) ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Thread ▁ did ▁ not ▁ die " ) ; } assertTrue ( " Stopped ▁ thread ▁ returned ▁ true " , ! st . isAlive ( ) ) ; } public void test_isDaemon ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread10" ) ; assertTrue ( " Non - Daemon ▁ thread ▁ returned ▁ true " , ! st . isDaemon ( ) ) ; st . setDaemon ( true ) ; assertTrue ( " Daemon ▁ thread ▁ returned ▁ false " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_isInterrupted ( ) { class SpinThread implements Runnable { public volatile boolean done = false ; public void run ( ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) ; while ( ! done ) ; } } SpinThread spin = new SpinThread ( ) ; spinner = new Thread ( spin ) ; spinner . start ( ) ; Thread . yield ( ) ; try { assertTrue ( " Non - Interrupted ▁ thread ▁ returned ▁ true " , ! spinner . isInterrupted ( ) ) ; spinner . interrupt ( ) ; assertTrue ( " Interrupted ▁ thread ▁ returned ▁ false " , spinner . isInterrupted ( ) ) ; spin . done = true ; } finally { spinner . interrupt ( ) ; spin . done = true ; } } public void test_join ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 100 ) ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { th . join ( ) ; } catch ( InterruptedException e ) { result = false ; } assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJ ( ) { SimpleThread simple ; try { st = new Thread ( simple = new SimpleThread ( 1000 ) , " SimpleThread12" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 10 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ " ) ; } assertTrue ( " Join ▁ failed ▁ to ▁ timeout " , st . isAlive ( ) ) ; st . interrupt ( ) ; try { st = new Thread ( simple = new SimpleThread ( 100 ) , " SimpleThread13" ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } st . join ( 1000 ) ; } catch ( InterruptedException e ) { fail ( " Join ▁ failed ▁ : ▁ " + e . getMessage ( ) ) ; return ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! st . isAlive ( ) ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } public void test_joinJI ( ) throws Exception { SimpleThread simple ; st = new Thread ( simple = new SimpleThread ( 1000 ) , " Squawk1" ) ; assertTrue ( " Thread ▁ is ▁ alive " , ! st . isAlive ( ) ) ; synchronized ( simple ) { st . start ( ) ; simple . wait ( ) ; } long firstRead = System . currentTimeMillis ( ) ; st . join ( 100 , 999999 ) ; long secondRead = System . currentTimeMillis ( ) ; assertTrue ( " Did ▁ not ▁ join ▁ by ▁ appropriate ▁ time : ▁ " + secondRead + " - " + firstRead + " = " + ( secondRead - firstRead ) , secondRead - firstRead <= 300 ) ; assertTrue ( " Joined ▁ thread ▁ is ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; final Object lock = new Object ( ) ; final Thread main = Thread . currentThread ( ) ; Thread killer = new Thread ( new Runnable ( ) { public void run ( ) { try { synchronized ( lock ) { lock . notify ( ) ; } Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { return ; } main . interrupt ( ) ; } } ) ; boolean result = true ; Thread th = new Thread ( " test " ) ; try { synchronized ( lock ) { killer . start ( ) ; lock . wait ( ) ; } th . join ( 200 , 20 ) ; } catch ( InterruptedException e ) { result = false ; } killer . interrupt ( ) ; assertTrue ( " Hung ▁ joining ▁ a ▁ non - started ▁ thread " , result ) ; th . start ( ) ; } @ SuppressWarnings ( " deprecation " ) public void test_resume ( ) { int orgval ; ResSupThread t ; try { t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test2" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred ▁ : ▁ " + e . getMessage ( ) ) ; } } public void test_run ( ) { class RunThread implements Runnable { boolean didThreadRun = false ; public void run ( ) { didThreadRun = true ; } } RunThread rt = new RunThread ( ) ; Thread t = new Thread ( rt ) ; try { t . start ( ) ; int count = 0 ; while ( ! rt . didThreadRun && count < 20 ) { Thread . sleep ( 100 ) ; count ++ ; } assertTrue ( " Thread ▁ did ▁ not ▁ run " , rt . didThreadRun ) ; t . join ( ) ; } catch ( InterruptedException e ) { assertTrue ( " Joined ▁ thread ▁ was ▁ interrupted " , true ) ; } assertTrue ( " Joined ▁ thread ▁ is ▁ still ▁ alive " , ! t . isAlive ( ) ) ; } public void test_setDaemonZ ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread14" ) ; st . setDaemon ( true ) ; assertTrue ( " Failed ▁ to ▁ set ▁ thread ▁ as ▁ daemon ▁ thread " , st . isDaemon ( ) ) ; st . start ( ) ; } public void test_setNameLjava_lang_String ( ) { st = new Thread ( new SimpleThread ( 1 ) , " SimpleThread15" ) ; st . setName ( " Bogus ▁ Name " ) ; assertEquals ( " Failed ▁ to ▁ set ▁ thread ▁ name " , " Bogus ▁ Name " , st . getName ( ) ) ; try { st . setName ( null ) ; fail ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " ) ; } catch ( NullPointerException e ) { assertTrue ( " Null ▁ should ▁ not ▁ be ▁ accepted ▁ as ▁ a ▁ valid ▁ name " , true ) ; } st . start ( ) ; } public void test_setPriorityI ( ) { st = new Thread ( new SimpleThread ( 1 ) ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; assertTrue ( " Failed ▁ to ▁ set ▁ priority " , st . getPriority ( ) == Thread . MAX_PRIORITY ) ; st . start ( ) ; } public void test_sleepJ ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough " , ( ftime - stime ) >= 800 ) ; } public void test_sleepJI ( ) { long stime = 0 , ftime = 0 ; try { stime = System . currentTimeMillis ( ) ; Thread . sleep ( 1000 , 999999 ) ; ftime = System . currentTimeMillis ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } long result = ftime - stime ; assertTrue ( " Failed ▁ to ▁ sleep ▁ long ▁ enough : ▁ " + result , result >= 900 && result <= 1100 ) ; } public void test_start ( ) { try { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { ct = new Thread ( t , " Interrupt ▁ Test4" ) ; ct . start ( ) ; t . wait ( ) ; } assertTrue ( " Thread ▁ is ▁ not ▁ running1" , ct . isAlive ( ) ) ; int orgval = t . getCheckVal ( ) ; Thread . sleep ( 150 ) ; assertTrue ( " Thread ▁ is ▁ not ▁ running2" , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stop ( ) { try { Runnable r = new ResSupThread ( null ) ; synchronized ( r ) { st = new Thread ( r , " Interupt ▁ Test5" ) ; st . start ( ) ; r . wait ( ) ; } } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ received " ) ; } st . stop ( ) ; try { st . join ( 10000 ) ; } catch ( InterruptedException e1 ) { st . interrupt ( ) ; fail ( " Failed ▁ to ▁ stopThread ▁ before ▁ 10000 ▁ timeout " ) ; } assertTrue ( " Failed ▁ to ▁ stopThread " , ! st . isAlive ( ) ) ; } @ SuppressWarnings ( " deprecation " ) public void test_stop_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { fail ( " checkAccess ▁ called " ) ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; try { t . stop ( ) ; } catch ( SecurityException e ) { } sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable_subtest0 ( ) { Thread t = new Thread ( " t " ) ; class MySecurityManager extends SecurityManager { public boolean intest = false ; public boolean checkAccess = false ; @ Override public void checkAccess ( Thread t ) { if ( intest ) { checkAccess = true ; } } @ Override public void checkPermission ( Permission permission ) { if ( permission . getName ( ) . equals ( " setSecurityManager " ) ) { return ; } super . checkPermission ( permission ) ; } } MySecurityManager sm = new MySecurityManager ( ) ; System . setSecurityManager ( sm ) ; try { sm . intest = true ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } sm . intest = false ; assertTrue ( " no ▁ checkAccess ▁ 1" , sm . checkAccess ) ; t . start ( ) ; try { t . join ( 2000 ) ; } catch ( InterruptedException e ) { } sm . intest = true ; sm . checkAccess = false ; try { t . stop ( new ThreadDeath ( ) ) ; } catch ( SecurityException e ) { } assertTrue ( " no ▁ checkAccess ▁ 2" , sm . checkAccess ) ; sm . intest = false ; } finally { System . setSecurityManager ( null ) ; } } @ SuppressWarnings ( " deprecation " ) public void test_stopLjava_lang_Throwable ( ) { ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; synchronized ( t ) { st = new Thread ( t , " StopThread " ) ; st . setPriority ( Thread . MAX_PRIORITY ) ; st . start ( ) ; try { t . wait ( ) ; } catch ( InterruptedException e ) { } } try { st . stop ( new BogusException ( " Bogus " ) ) ; Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { assertTrue ( " Stopped ▁ child ▁ with ▁ exception ▁ not ▁ alive " , st . isAlive ( ) ) ; st . interrupt ( ) ; return ; } st . interrupt ( ) ; fail ( " Stopped ▁ child ▁ did ▁ not ▁ throw ▁ exception " ) ; } @ SuppressWarnings ( " deprecation " ) public void test_suspend ( ) { int orgval ; ResSupThread t = new ResSupThread ( Thread . currentThread ( ) ) ; try { synchronized ( t ) { ct = new Thread ( t , " Interupt ▁ Test6" ) ; ct . start ( ) ; t . wait ( ) ; } ct . suspend ( ) ; Thread . sleep ( 500 ) ; orgval = t . getCheckVal ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ suspend ▁ thread " , orgval == t . getCheckVal ( ) ) ; ct . resume ( ) ; Thread . sleep ( 500 ) ; assertTrue ( " Failed ▁ to ▁ resume ▁ thread " , orgval != t . getCheckVal ( ) ) ; ct . interrupt ( ) ; } catch ( InterruptedException e ) { fail ( " Unexpected ▁ interrupt ▁ occurred " ) ; } final Object notify = new Object ( ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { synchronized ( notify ) { notify . notify ( ) ; } Thread . currentThread ( ) . suspend ( ) ; } } ) ; try { synchronized ( notify ) { t1 . start ( ) ; notify . wait ( ) ; } Thread . sleep ( 500 ) ; assertTrue ( " Thread ▁ should ▁ be ▁ alive " , t1 . isAlive ( ) ) ; t1 . resume ( ) ; t1 . join ( ) ; } catch ( InterruptedException e ) { } } public void test_toString ( ) { ThreadGroup tg = new ThreadGroup ( " Test ▁ Group5" ) ; st = new Thread ( tg , new SimpleThread ( 1 ) , " SimpleThread17" ) ; final String stString = st . toString ( ) ; final String expected = " Thread [ SimpleThread17,5 , Test ▁ Group5 ] " ; assertTrue ( " Returned ▁ incorrect ▁ string : ▁ " + stString + " \t ( expecting ▁ : " + expected + " ) " , stString . equals ( expected ) ) ; st . start ( ) ; try { st . join ( ) ; } catch ( InterruptedException e ) { } tg . destroy ( ) ; } public void test_getAllStackTraces ( ) { Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; assertNotNull ( stMap ) ; } public void test_get_setDefaultUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . getDefaultUncaughtExceptionHandler ( ) ) ; Thread . setDefaultUncaughtExceptionHandler ( null ) ; assertNull ( Thread . getDefaultUncaughtExceptionHandler ( ) ) ; } public void test_getStackTrace ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; assertNotNull ( stackTrace ) ; stack_trace_loop : { for ( int i = 0 ; i < stackTrace . length ; i ++ ) { StackTraceElement e = stackTrace [ i ] ; if ( getClass ( ) . getName ( ) . equals ( e . getClassName ( ) ) ) { if ( " test _ getStackTrace " . equals ( e . getMethodName ( ) ) ) { break stack_trace_loop ; } } } fail ( " class ▁ and ▁ method ▁ not ▁ found ▁ in ▁ stack ▁ trace " ) ; } } public void test_getState ( ) { Thread . State state = Thread . currentThread ( ) . getState ( ) ; assertNotNull ( state ) ; assertEquals ( Thread . State . RUNNABLE , state ) ; } public void test_get_setUncaughtExceptionHandler ( ) { class Handler implements UncaughtExceptionHandler { public void uncaughtException ( Thread thread , Throwable ex ) { } } final Handler handler = new Handler ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( handler ) ; assertSame ( handler , Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; } public void test_getId ( ) { assertTrue ( " current ▁ thread ' s ▁ ID ▁ is ▁ not ▁ positive " , Thread . currentThread ( ) . getId ( ) > 0 ) ; Map < Thread , StackTraceElement [ ] > stMap = Thread . getAllStackTraces ( ) ; for ( Thread thread : stMap . keySet ( ) ) { assertTrue ( " thread ' s ▁ ID ▁ is ▁ not ▁ positive : ▁ " + thread . getName ( ) , thread . getId ( ) > 0 ) ; } } @ Override protected void tearDown ( ) { try { if ( st != null ) st . interrupt ( ) ; } catch ( Exception e ) { } try { if ( spinner != null ) spinner . interrupt ( ) ; } catch ( Exception e ) { } try { if ( ct != null ) ct . interrupt ( ) ; } catch ( Exception e ) { } try { spinner = null ; st = null ; ct = null ; System . runFinalization ( ) ; } catch ( Exception e ) { } } } </DOCUMENT>
<DOCUMENT_ID="tuxillo/aarch64-dragonfly-gcc/tree/master/libjava/classpath/gnu/java/net/protocol/jar/Handler.java"> package gnu . java . net . protocol . jar ; import gnu . java . lang . CPStringBuilder ; import gnu . java . net . URLParseError ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLStreamHandler ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; public class Handler extends URLStreamHandler { public Handler ( ) { } protected URLConnection openConnection ( URL url ) throws IOException { return new Connection ( url ) ; } protected void parseURL ( URL url , String url_string , int start , int end ) { String file = url . getFile ( ) ; if ( ! file . equals ( " " ) ) { url_string = url_string . substring ( start , end ) ; if ( url_string . startsWith ( " / " ) ) { int idx = file . lastIndexOf ( " ! / " ) ; if ( idx < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; file = file . substring ( 0 , idx + 1 ) + url_string ; } else if ( url_string . length ( ) > 0 ) { int idx = file . lastIndexOf ( " / " ) ; if ( idx == - 1 ) file = " / " + url_string ; else if ( idx == ( file . length ( ) - 1 ) ) file = file + url_string ; else file = file . substring ( 0 , idx + 1 ) + url_string ; } setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , flat ( file ) , null ) ; return ; } if ( end < start ) return ; if ( end - start < 2 ) return ; if ( start > url_string . length ( ) ) return ; url_string = url_string . substring ( start , end ) ; int jar_stop ; if ( ( jar_stop = url_string . indexOf ( " ! / " ) ) < 0 ) throw new URLParseError ( " no ▁ ! / ▁ in ▁ spec " ) ; try { new URL ( url_string . substring ( 0 , jar_stop ) ) ; } catch ( MalformedURLException e ) { throw new URLParseError ( " invalid ▁ inner ▁ URL : ▁ " + e . getMessage ( ) ) ; } if ( ! url . getProtocol ( ) . equals ( " jar " ) ) throw new URLParseError ( " unexpected ▁ protocol ▁ " + url . getProtocol ( ) ) ; setURL ( url , " jar " , url . getHost ( ) , url . getPort ( ) , url_string , null ) ; } private static String flat ( String url_string ) { int jar_stop = url_string . indexOf ( " ! / " ) ; String jar_path = url_string . substring ( jar_stop + 1 , url_string . length ( ) ) ; if ( jar_path . indexOf ( " / . " ) < 0 ) return url_string ; ArrayList < String > tokens = new ArrayList < String > ( ) ; StringTokenizer st = new StringTokenizer ( jar_path , " / " ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; if ( token . equals ( " . " ) ) continue ; else if ( token . equals ( " . . " ) ) { if ( ! tokens . isEmpty ( ) ) tokens . remove ( tokens . size ( ) - 1 ) ; } else tokens . add ( token ) ; } CPStringBuilder path = new CPStringBuilder ( url_string . length ( ) ) ; path . append ( url_string . substring ( 0 , jar_stop + 1 ) ) ; Iterator < String > it = tokens . iterator ( ) ; while ( it . hasNext ( ) ) path . append ( ' / ' ) . append ( it . next ( ) ) ; return path . toString ( ) ; } protected String toExternalForm ( URL url ) { String file = url . getFile ( ) ; String ref = url . getRef ( ) ; CPStringBuilder sb = new CPStringBuilder ( file . length ( ) + 5 ) ; sb . append ( " jar : " ) ; sb . append ( file ) ; if ( ref != null ) sb . append ( ' # ' ) . append ( ref ) ; return sb . toString ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="christer155/IntegratingFacebookTutorial/tree/master/IntegratingFacebookTutorial-Unity/Assets/Plugins/Android/facebook/src/com/facebook/internal/ImageResponseCache.java"> package com . facebook . internal ; import android . content . Context ; import android . util . Log ; import com . facebook . LoggingBehavior ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; class ImageResponseCache { static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; private volatile static FileLruCache imageCache ; synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; } static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; } static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; } private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; } static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } } private static class BufferedHttpInputStream extends BufferedInputStream { HttpURLConnection connection ; BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; this . connection = connection ; } @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; } } } </DOCUMENT>
<DOCUMENT_ID="weebl2000/modeshape/tree/master/modeshape-jcr/src/main/java/org/modeshape/jcr/ModeShape.java"> package org . modeshape . jcr ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import org . modeshape . common . collection . UnmodifiableProperties ; import org . modeshape . common . logging . Logger ; public final class ModeShape { private static final Properties bundleProperties = loadBundleProperties ( ) ; private static Properties loadBundleProperties ( ) { InputStream stream = null ; try { stream = JcrRepository . class . getClassLoader ( ) . getResourceAsStream ( " org / modeshape / jcr / repository . properties " ) ; assert stream != null ; Properties props = new Properties ( ) ; props . load ( stream ) ; return new UnmodifiableProperties ( props ) ; } catch ( IOException e ) { throw new IllegalStateException ( JcrI18n . failedToReadPropertiesFromManifest . text ( e . getLocalizedMessage ( ) ) , e ) ; } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } finally { stream = null ; } } } } static { Logger . getLogger ( JcrRepository . class ) . info ( JcrI18n . initializing , getName ( ) , getVersion ( ) ) ; } public static final String getName ( ) { return bundleProperties . getProperty ( " name " ) ; } public static final String getVendor ( ) { return bundleProperties . getProperty ( " vendor " ) ; } public static final String getUrl ( ) { return bundleProperties . getProperty ( " url " ) ; } public static final String getVersion ( ) { return bundleProperties . getProperty ( " version " ) ; } } </DOCUMENT>
<DOCUMENT_ID="medsob/Tanaguru/tree/master/web-app/tgol-web-app/src/main/java/org/tanaguru/webapp/command/helper/UploadAuditSetUpCommandHelper.java"> package org . tanaguru . webapp . command . helper ; import java . io . IOException ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import org . tanaguru . crawler . util . CrawlUtils ; import org . springframework . web . multipart . commons . CommonsMultipartFile ; public final class UploadAuditSetUpCommandHelper { private static Map < String , Integer > fileNameCounterMap = new HashMap < String , Integer > ( ) ; public synchronized static Map < String , String > convertFilesToMap ( CommonsMultipartFile [ ] fileInputList ) { Map < String , String > fileMap = new LinkedHashMap < String , String > ( ) ; CommonsMultipartFile tmpMultiFile ; String tmpCharset ; fileNameCounterMap . clear ( ) ; for ( int i = 0 ; i < fileInputList . length ; i ++ ) { tmpMultiFile = fileInputList [ i ] ; try { if ( tmpMultiFile != null && ! tmpMultiFile . isEmpty ( ) && tmpMultiFile . getInputStream ( ) != null ) { tmpCharset = CrawlUtils . extractCharset ( tmpMultiFile . getInputStream ( ) ) ; fileMap . put ( getFileName ( tmpMultiFile . getOriginalFilename ( ) ) , tmpMultiFile . getFileItem ( ) . getString ( tmpCharset ) ) ; } } catch ( IOException e ) { } } return fileMap ; } private static String getFileName ( String originalFileName ) { StringBuilder fileName = new StringBuilder ( ) ; fileName . append ( ' / ' ) ; if ( fileNameCounterMap . containsKey ( originalFileName ) ) { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( fileNameCounterMap . get ( originalFileName ) + 1 ) ) ; fileName . append ( originalFileName ) ; fileName . append ( ' _ ' ) ; fileName . append ( fileNameCounterMap . get ( originalFileName ) ) ; return fileName . toString ( ) ; } else { fileNameCounterMap . put ( originalFileName , Integer . valueOf ( 1 ) ) ; fileName . append ( originalFileName ) ; return fileName . toString ( ) ; } } } </DOCUMENT>
<DOCUMENT_ID="borcsokj/camel/tree/master/components/camel-apns/src/test/java/org/apache/camel/component/apns/ApnsProducerTest.java"> package org . apache . camel . component . apns ; import com . notnoop . apns . APNS ; import com . notnoop . apns . ApnsService ; import com . notnoop . apns . EnhancedApnsNotification ; import com . notnoop . apns . utils . ApnsServerStub ; import org . apache . camel . CamelContext ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . component . apns . factory . ApnsServiceFactory ; import org . apache . camel . component . apns . model . ApnsConstants ; import org . apache . camel . component . apns . model . MessageType ; import org . apache . camel . component . apns . util . ApnsUtils ; import org . apache . camel . component . apns . util . TestConstants ; import org . apache . camel . test . junit4 . CamelTestSupport ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; public class ApnsProducerTest extends CamelTestSupport { private static final String FAKE_TOKEN = "19308314834701ACD8313AEBD92AEFDE192120371FE13982392831701318B943" ; private ApnsServerStub server ; @ Before public void startup ( ) { server = ApnsUtils . prepareAndStartServer ( TestConstants . TEST_GATEWAY_PORT , TestConstants . TEST_FEEDBACK_PORT ) ; } @ After public void stop ( ) { server . stop ( ) ; } @ Test ( timeout = 5000 ) public void testProducer ( ) throws Exception { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 1 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : test " , message ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } @ Test ( timeout = 5000 ) public void testProducerWithApnsNotification ( ) throws InterruptedException { String message = " Hello ▁ World " ; String messagePayload = APNS . newPayload ( ) . alertBody ( message ) . build ( ) ; final EnhancedApnsNotification apnsNotification = new EnhancedApnsNotification ( 14 , EnhancedApnsNotification . MAXIMUM_EXPIRY , FAKE_TOKEN , messagePayload ) ; server . stopAt ( apnsNotification . length ( ) ) ; template . sendBody ( " direct : testWithApnsNotification " , apnsNotification ) ; server . getMessages ( ) . acquire ( ) ; assertArrayEquals ( apnsNotification . marshall ( ) , server . getReceived ( ) . toByteArray ( ) ) ; } protected CamelContext createCamelContext ( ) throws Exception { CamelContext camelContext = super . createCamelContext ( ) ; ApnsServiceFactory apnsServiceFactory = ApnsUtils . createDefaultTestConfiguration ( camelContext ) ; ApnsService apnsService = apnsServiceFactory . getApnsService ( ) ; ApnsComponent apnsComponent = new ApnsComponent ( apnsService ) ; camelContext . addComponent ( " apns " , apnsComponent ) ; return camelContext ; } protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : test " ) . setHeader ( ApnsConstants . HEADER_TOKENS , constant ( FAKE_TOKEN ) ) . to ( " apns : notify " ) ; from ( " direct : testWithApnsNotification " ) . setHeader ( ApnsConstants . HEADER_MESSAGE_TYPE , constant ( MessageType . APNS_NOTIFICATION . name ( ) ) ) . to ( " apns : notify " ) ; } } ; } } </DOCUMENT>
<DOCUMENT_ID="iweiss/activemq-artemis/tree/master/tests/activemq5-unit-tests/src/test/java/org/apache/activemq/spring/SpringConsumer.java"> package org . apache . activemq . spring ; import javax . jms . Connection ; import javax . jms . ConnectionFactory ; import javax . jms . Destination ; import javax . jms . JMSException ; import javax . jms . Message ; import javax . jms . MessageConsumer ; import javax . jms . MessageListener ; import javax . jms . Session ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . jms . core . JmsTemplate ; public class SpringConsumer extends ConsumerBean implements MessageListener { private static final Logger LOG = LoggerFactory . getLogger ( SpringConsumer . class ) ; private JmsTemplate template ; private String myId = " foo " ; private Destination destination ; private Connection connection ; private Session session ; private MessageConsumer consumer ; public void start ( ) throws JMSException { String selector = " next ▁ = ▁ ' " + myId + " ' " ; try { ConnectionFactory factory = template . getConnectionFactory ( ) ; final Connection c = connection = factory . createConnection ( ) ; synchronized ( c ) { if ( c . getClientID ( ) == null ) { c . setClientID ( myId ) ; } } connection . start ( ) ; session = connection . createSession ( true , Session . CLIENT_ACKNOWLEDGE ) ; consumer = session . createConsumer ( destination , selector , false ) ; consumer . setMessageListener ( this ) ; } catch ( JMSException ex ) { LOG . error ( " " , ex ) ; throw ex ; } } public void stop ( ) throws JMSException { if ( consumer != null ) { consumer . close ( ) ; } if ( session != null ) { session . close ( ) ; } if ( connection != null ) { connection . close ( ) ; } } @ Override public void onMessage ( Message message ) { super . onMessage ( message ) ; try { message . acknowledge ( ) ; } catch ( JMSException e ) { LOG . error ( " Failed ▁ to ▁ acknowledge : ▁ " + e , e ) ; } } public Destination getDestination ( ) { return destination ; } public void setDestination ( Destination destination ) { this . destination = destination ; } public String getMyId ( ) { return myId ; } public void setMyId ( String myId ) { this . myId = myId ; } public JmsTemplate getTemplate ( ) { return template ; } public void setTemplate ( JmsTemplate template ) { this . template = template ; } } </DOCUMENT>
<DOCUMENT_ID="irwinai/zxing/tree/master/android/src/com/google/zxing/client/android/result/AddressBookResultHandler.java"> package com . google . zxing . client . android . result ; import com . google . zxing . client . android . R ; import com . google . zxing . client . result . AddressBookParsedResult ; import com . google . zxing . client . result . ParsedResult ; import android . app . Activity ; import android . telephony . PhoneNumberUtils ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . style . StyleSpan ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; public final class AddressBookResultHandler extends ResultHandler { private static final DateFormat [ ] DATE_FORMATS = { new SimpleDateFormat ( " yyyyMMdd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyyMMdd ' T ' HHmmss " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd " , Locale . ENGLISH ) , new SimpleDateFormat ( " yyyy - MM - dd ' T ' HH : mm : ss " , Locale . ENGLISH ) , } ; static { for ( DateFormat format : DATE_FORMATS ) { format . setLenient ( false ) ; } } private static final int [ ] BUTTON_TEXTS = { R . string . button_add_contact , R . string . button_show_map , R . string . button_dial , R . string . button_email , } ; private final boolean [ ] fields ; private int buttonCount ; private int mapIndexToAction ( int index ) { if ( index < buttonCount ) { int count = - 1 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { count ++ ; } if ( count == index ) { return x ; } } } return - 1 ; } public AddressBookResultHandler ( Activity activity , ParsedResult result ) { super ( activity , result ) ; AddressBookParsedResult addressResult = ( AddressBookParsedResult ) result ; String [ ] addresses = addressResult . getAddresses ( ) ; boolean hasAddress = addresses != null && addresses . length > 0 && addresses [ 0 ] != null && ! addresses [ 0 ] . isEmpty ( ) ; String [ ] phoneNumbers = addressResult . getPhoneNumbers ( ) ; boolean hasPhoneNumber = phoneNumbers != null && phoneNumbers . length > 0 ; String [ ] emails = addressResult . getEmails ( ) ; boolean hasEmailAddress = emails != null && emails . length > 0 ; fields = new boolean [ MAX_BUTTON_COUNT ] ; fields [ 0 ] = true ; fields [ 1 ] = hasAddress ; fields [ 2 ] = hasPhoneNumber ; fields [ 3 ] = hasEmailAddress ; buttonCount = 0 ; for ( int x = 0 ; x < MAX_BUTTON_COUNT ; x ++ ) { if ( fields [ x ] ) { buttonCount ++ ; } } } @ Override public int getButtonCount ( ) { return buttonCount ; } @ Override public int getButtonText ( int index ) { return BUTTON_TEXTS [ mapIndexToAction ( index ) ] ; } @ Override public void handleButtonPress ( int index ) { AddressBookParsedResult addressResult = ( AddressBookParsedResult ) getResult ( ) ; String [ ] addresses = addressResult . getAddresses ( ) ; String address1 = addresses == null || addresses . length < 1 ? null : addresses [ 0 ] ; String [ ] addressTypes = addressResult . getAddressTypes ( ) ; String address1Type = addressTypes == null || addressTypes . length < 1 ? null : addressTypes [ 0 ] ; int action = mapIndexToAction ( index ) ; switch ( action ) { case 0 : addContact ( addressResult . getNames ( ) , addressResult . getNicknames ( ) , addressResult . getPronunciation ( ) , addressResult . getPhoneNumbers ( ) , addressResult . getPhoneTypes ( ) , addressResult . getEmails ( ) , addressResult . getEmailTypes ( ) , addressResult . getNote ( ) , addressResult . getInstantMessenger ( ) , address1 , address1Type , addressResult . getOrg ( ) , addressResult . getTitle ( ) , addressResult . getURLs ( ) , addressResult . getBirthday ( ) , addressResult . getGeo ( ) ) ; break ; case 1 : searchMap ( address1 ) ; break ; case 2 : dialPhone ( addressResult . getPhoneNumbers ( ) [ 0 ] ) ; break ; case 3 : sendEmail ( addressResult . getEmails ( ) , null , null , null , null ) ; break ; default : break ; } } private static Date parseDate ( String s ) { for ( DateFormat currentFormat : DATE_FORMATS ) { try { return currentFormat . parse ( s ) ; } catch ( ParseException e ) { } } return null ; } @ Override public CharSequence getDisplayContents ( ) { AddressBookParsedResult result = ( AddressBookParsedResult ) getResult ( ) ; StringBuilder contents = new StringBuilder ( 100 ) ; ParsedResult . maybeAppend ( result . getNames ( ) , contents ) ; int namesLength = contents . length ( ) ; String pronunciation = result . getPronunciation ( ) ; if ( pronunciation != null && ! pronunciation . isEmpty ( ) ) { contents . append ( " \n ( " ) ; contents . append ( pronunciation ) ; contents . append ( ' ) ' ) ; } ParsedResult . maybeAppend ( result . getTitle ( ) , contents ) ; ParsedResult . maybeAppend ( result . getOrg ( ) , contents ) ; ParsedResult . maybeAppend ( result . getAddresses ( ) , contents ) ; String [ ] numbers = result . getPhoneNumbers ( ) ; if ( numbers != null ) { for ( String number : numbers ) { if ( number != null ) { ParsedResult . maybeAppend ( PhoneNumberUtils . formatNumber ( number ) , contents ) ; } } } ParsedResult . maybeAppend ( result . getEmails ( ) , contents ) ; ParsedResult . maybeAppend ( result . getURLs ( ) , contents ) ; String birthday = result . getBirthday ( ) ; if ( birthday != null && ! birthday . isEmpty ( ) ) { Date date = parseDate ( birthday ) ; if ( date != null ) { ParsedResult . maybeAppend ( DateFormat . getDateInstance ( DateFormat . MEDIUM ) . format ( date . getTime ( ) ) , contents ) ; } } ParsedResult . maybeAppend ( result . getNote ( ) , contents ) ; if ( namesLength > 0 ) { Spannable styled = new SpannableString ( contents . toString ( ) ) ; styled . setSpan ( new StyleSpan ( android . graphics . Typeface . BOLD ) , 0 , namesLength , 0 ) ; return styled ; } else { return contents . toString ( ) ; } } @ Override public int getDisplayTitle ( ) { return R . string . result_address_book ; } } </DOCUMENT>
<DOCUMENT_ID="shlee89/athena/tree/master/web/gui/src/main/java/org/onosproject/ui/impl/TunnelViewMessageHandler.java"> package org . onosproject . ui . impl ; import com . fasterxml . jackson . databind . node . ObjectNode ; import com . google . common . collect . ImmutableSet ; import org . onosproject . incubator . net . tunnel . Tunnel ; import org . onosproject . incubator . net . tunnel . TunnelEndPointFormatter ; import org . onosproject . incubator . net . tunnel . TunnelService ; import org . onosproject . ui . RequestHandler ; import org . onosproject . ui . UiMessageHandler ; import org . onosproject . ui . table . TableModel ; import org . onosproject . ui . table . TableRequestHandler ; import org . onosproject . ui . table . cell . EnumFormatter ; import java . util . Collection ; public class TunnelViewMessageHandler extends UiMessageHandler { private static final String TUNNEL_DATA_REQ = " tunnelDataRequest " ; private static final String TUNNEL_DATA_RESP = " tunnelDataResponse " ; private static final String TUNNELS = " tunnels " ; private static final String ID = " id " ; private static final String NAME = " name " ; private static final String ONE = " one " ; private static final String TWO = " two " ; private static final String TYPE = " type " ; private static final String GROUP_ID = " group _ id " ; private static final String BANDWIDTH = " bandwidth " ; private static final String PATH = " path " ; private static final String [ ] COL_IDS = { ID , NAME , ONE , TWO , TYPE , GROUP_ID , BANDWIDTH , PATH } ; @ Override protected Collection < RequestHandler > createRequestHandlers ( ) { return ImmutableSet . of ( new TunnelDataRequestHandler ( ) ) ; } private final class TunnelDataRequestHandler extends TableRequestHandler { private static final String NO_ROWS_MESSAGE = " No ▁ tunnels ▁ found " ; public TunnelDataRequestHandler ( ) { super ( TUNNEL_DATA_REQ , TUNNEL_DATA_RESP , TUNNELS ) ; } @ Override protected String [ ] getColumnIds ( ) { return COL_IDS ; } @ Override protected String noRowsMessage ( ObjectNode payload ) { return NO_ROWS_MESSAGE ; } @ Override protected TableModel createTableModel ( ) { TableModel tm = super . createTableModel ( ) ; tm . setFormatter ( ONE , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TWO , TunnelEndPointFormatter . INSTANCE ) ; tm . setFormatter ( TYPE , EnumFormatter . INSTANCE ) ; return tm ; } @ Override protected void populateTable ( TableModel tm , ObjectNode payload ) { TunnelService ts = get ( TunnelService . class ) ; ts . queryAllTunnels ( ) . forEach ( tunnel -> populateRow ( tm . addRow ( ) , tunnel ) ) ; } } private void populateRow ( TableModel . Row row , Tunnel tunnel ) { row . cell ( ID , tunnel . tunnelId ( ) . id ( ) ) . cell ( NAME , tunnel . tunnelName ( ) . value ( ) ) . cell ( ONE , tunnel . src ( ) ) . cell ( TWO , tunnel . dst ( ) ) . cell ( TYPE , tunnel . type ( ) ) . cell ( GROUP_ID , tunnel . groupId ( ) . id ( ) ) . cell ( BANDWIDTH , tunnel . annotations ( ) . value ( BANDWIDTH ) ) . cell ( PATH , tunnel . path ( ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="bogeo/simsamples/tree/master/src/de/hsbo/geo/simsamples/applications/PubExample.java"> package de . hsbo . geo . simsamples . applications ; import de . hsbo . geo . simsamples . common . RandomValueGenerator ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Customer ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . CustomerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . Server ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . ServerQueue ; import de . hsbo . geo . simsamples . eventqueues . servercustomer . SimpleServerCustomerSimulator ; public class PubExample { public static void main ( String [ ] args ) throws Exception { new PubExample ( ) . run ( ) ; } private void run ( ) throws Exception { Drinker peter = new Drinker ( " Peter " , 15. ) , paul = new Drinker ( " Paul " , 20. ) , harry = new Drinker ( " Harry " , 30. ) ; Barmaid elke = new Barmaid ( " Elke " , 2. ) ; CustomerQueue drinking = new CustomerQueue ( " . " ) ; CustomerQueue thursty = new CustomerQueue ( " ? " ) ; thursty . enqueue ( peter , paul , harry ) ; ServerQueue tapping = new ServerQueue ( " X " ) ; ServerQueue free = new ServerQueue ( " . " ) ; free . enqueue ( elke ) ; SimpleServerCustomerSimulator sim = new SimpleServerCustomerSimulator ( free , tapping , thursty , drinking ) ; sim . setConsoleDump ( false ) ; double M = 120. ; sim . execute ( M ) ; } protected class Drinker extends Customer { private double dt ; protected Drinker ( String name , double drinkingTime ) { super ( name ) ; this . dt = drinkingTime ; } @ Override public double getDuration ( ) { double var = RandomValueGenerator . number ( - 2. , + 2. , 0. , 1. ) ; return dt + var ; } } protected class Barmaid extends Server { private double dt ; protected Barmaid ( String name , double serviceTime ) { super ( name ) ; this . dt = serviceTime ; } public double getDuration ( ) { return dt + RandomValueGenerator . number ( - 1. , + 1. , 0. , 1. ) ; } } } </DOCUMENT>
<DOCUMENT_ID="iamjakob/elasticsearch/tree/master/core/src/test/java/org/elasticsearch/benchmark/search/aggregations/GlobalOrdinalsBenchmark.java"> package org . elasticsearch . benchmark . search . aggregations ; import com . carrotsearch . hppc . IntIntHashMap ; import com . carrotsearch . hppc . ObjectHashSet ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . stats . ClusterStatsResponse ; import org . elasticsearch . action . bulk . BulkRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . benchmark . search . aggregations . TermsAggregationSearchBenchmark . StatsResult ; import org . elasticsearch . bootstrap . BootstrapForTesting ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . indices . IndexAlreadyExistsException ; import org . elasticsearch . node . Node ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . transport . TransportModule ; import java . util . * ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . node . NodeBuilder . nodeBuilder ; public class GlobalOrdinalsBenchmark { private static final String INDEX_NAME = " index " ; private static final String TYPE_NAME = " type " ; private static final int QUERY_WARMUP = 25 ; private static final int QUERY_COUNT = 100 ; private static final int FIELD_START = 1 ; private static final int FIELD_LIMIT = 1 << 22 ; private static final boolean USE_DOC_VALUES = false ; static long COUNT = SizeValue . parseSizeValue ( "5m " ) . singles ( ) ; static Node node ; static Client client ; public static void main ( String [ ] args ) throws Exception { System . setProperty ( " es . logger . prefix " , " " ) ; BootstrapForTesting . ensureInitialized ( ) ; Random random = new Random ( ) ; Settings settings = settingsBuilder ( ) . put ( " index . refresh _ interval " , " - 1" ) . put ( SETTING_NUMBER_OF_SHARDS , 1 ) . put ( SETTING_NUMBER_OF_REPLICAS , 0 ) . put ( TransportModule . TRANSPORT_TYPE_KEY , " local " ) . build ( ) ; String clusterName = GlobalOrdinalsBenchmark . class . getSimpleName ( ) ; node = nodeBuilder ( ) . clusterName ( clusterName ) . settings ( settingsBuilder ( ) . put ( settings ) ) . node ( ) ; client = node . client ( ) ; try { client . admin ( ) . indices ( ) . prepareCreate ( INDEX_NAME ) . addMapping ( TYPE_NAME , jsonBuilder ( ) . startObject ( ) . startObject ( TYPE_NAME ) . startArray ( " dynamic _ templates " ) . startObject ( ) . startObject ( " default " ) . field ( " match " , " * " ) . field ( " match _ mapping _ type " , " string " ) . startObject ( " mapping " ) . field ( " type " , " string " ) . field ( " index " , " not _ analyzed " ) . startObject ( " fields " ) . startObject ( " doc _ values " ) . field ( " type " , " string " ) . field ( " index " , " no " ) . startObject ( " fielddata " ) . field ( " format " , " doc _ values " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; ObjectHashSet < String > uniqueTerms = new ObjectHashSet < > ( ) ; for ( int i = 0 ; i < FIELD_LIMIT ; i ++ ) { boolean added ; do { added = uniqueTerms . add ( RandomStrings . randomAsciiOfLength ( random , 16 ) ) ; } while ( ! added ) ; } String [ ] sValues = uniqueTerms . toArray ( String . class ) ; uniqueTerms = null ; BulkRequestBuilder builder = client . prepareBulk ( ) ; IntIntHashMap tracker = new IntIntHashMap ( ) ; for ( int i = 0 ; i < COUNT ; i ++ ) { Map < String , Object > fieldValues = new HashMap < > ( ) ; for ( int fieldSuffix = 1 ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { int index = tracker . putOrAdd ( fieldSuffix , 0 , 0 ) ; if ( index >= fieldSuffix ) { index = random . nextInt ( fieldSuffix ) ; fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; } else { fieldValues . put ( " field _ " + fieldSuffix , sValues [ index ] ) ; tracker . put ( fieldSuffix , ++ index ) ; } } builder . add ( client . prepareIndex ( INDEX_NAME , TYPE_NAME , String . valueOf ( i ) ) . setSource ( fieldValues ) ) ; if ( builder . numberOfActions ( ) >= 1000 ) { builder . get ( ) ; builder = client . prepareBulk ( ) ; } } if ( builder . numberOfActions ( ) > 0 ) { builder . get ( ) ; } } catch ( IndexAlreadyExistsException e ) { System . out . println ( " - - > ▁ Index ▁ already ▁ exists , ▁ ignoring ▁ indexing ▁ phase , ▁ waiting ▁ for ▁ green " ) ; ClusterHealthResponse clusterHealthResponse = client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . setTimeout ( "10m " ) . execute ( ) . actionGet ( ) ; if ( clusterHealthResponse . isTimedOut ( ) ) { System . err . println ( " - - > ▁ Timed ▁ out ▁ waiting ▁ for ▁ cluster ▁ health " ) ; } } client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( " logger . index . fielddata . ordinals " , " DEBUG " ) ) . get ( ) ; client . admin ( ) . indices ( ) . prepareRefresh ( INDEX_NAME ) . execute ( ) . actionGet ( ) ; COUNT = client . prepareCount ( INDEX_NAME ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) . getCount ( ) ; System . out . println ( " - - > ▁ Number ▁ of ▁ docs ▁ in ▁ index : ▁ " + COUNT ) ; List < StatsResult > stats = new ArrayList < > ( ) ; for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " global _ ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; } stats . add ( terms ( name , fieldName , " global _ ordinals _ low _ cardinality " ) ) ; } for ( int fieldSuffix = FIELD_START ; fieldSuffix <= FIELD_LIMIT ; fieldSuffix <<= 1 ) { String fieldName = " field _ " + fieldSuffix ; String name = " ordinals - " + fieldName ; if ( USE_DOC_VALUES ) { fieldName = fieldName + " . doc _ values " ; name = name + " _ doc _ values " ; } stats . add ( terms ( name , fieldName , " ordinals " ) ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10s % 15s \n " , " name " , " took " , " millis " , " fieldata ▁ size " ) ; for ( StatsResult stat : stats ) { System . out . format ( Locale . ENGLISH , " % 30s % 10s % 10d % 15s \n " , stat . name , TimeValue . timeValueMillis ( stat . took ) , ( stat . took / QUERY_COUNT ) , stat . fieldDataMemoryUsed ) ; } System . out . println ( " - - - - - - - - - - - - - - - - - - ▁ SUMMARY ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; client . close ( ) ; node . close ( ) ; } private static StatsResult terms ( String name , String field , String executionHint ) { long totalQueryTime ; client . admin ( ) . indices ( ) . prepareClearCache ( ) . setFieldDataCache ( true ) . execute ( ) . actionGet ( ) ; System . gc ( ) ; System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) . . . " ) ; for ( int j = 0 ; j < QUERY_WARMUP ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( j == 0 ) { System . out . println ( " - - > ▁ Loading ▁ ( " + field + " ) : ▁ took : ▁ " + searchResponse . getTook ( ) ) ; } if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } } System . out . println ( " - - > ▁ Warmup ▁ ( " + name + " ) ▁ DONE " ) ; System . out . println ( " - - > ▁ Running ▁ ( " + name + " ) . . . " ) ; totalQueryTime = 0 ; for ( int j = 0 ; j < QUERY_COUNT ; j ++ ) { SearchResponse searchResponse = client . prepareSearch ( INDEX_NAME ) . setSize ( 0 ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( AggregationBuilders . terms ( name ) . field ( field ) . executionHint ( executionHint ) ) . get ( ) ; if ( searchResponse . getHits ( ) . totalHits ( ) != COUNT ) { System . err . println ( " - - > ▁ mismatch ▁ on ▁ hits " ) ; } totalQueryTime += searchResponse . getTookInMillis ( ) ; } System . out . println ( " - - > ▁ Terms ▁ Agg ▁ ( " + name + " ) : ▁ " + ( totalQueryTime / QUERY_COUNT ) + " ms " ) ; String nodeId = node . injector ( ) . getInstance ( Discovery . class ) . localNode ( ) . getId ( ) ; ClusterStatsResponse clusterStateResponse = client . admin ( ) . cluster ( ) . prepareClusterStats ( ) . setNodesIds ( nodeId ) . get ( ) ; System . out . println ( " - - > ▁ Heap ▁ used : ▁ " + clusterStateResponse . getNodesStats ( ) . getJvm ( ) . getHeapUsed ( ) ) ; ByteSizeValue fieldDataMemoryUsed = clusterStateResponse . getIndicesStats ( ) . getFieldData ( ) . getMemorySize ( ) ; System . out . println ( " - - > ▁ Fielddata ▁ memory ▁ size : ▁ " + fieldDataMemoryUsed ) ; return new StatsResult ( name , totalQueryTime , fieldDataMemoryUsed ) ; } } </DOCUMENT>
