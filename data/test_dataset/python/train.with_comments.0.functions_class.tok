def get_for_admin ( self , admin ) : NEW_LINE INDENT """ Return ▁ the ▁ domain ▁ aliases ▁ belonging ▁ to ▁ this ▁ admin . STRNEWLINE STRNEWLINE ▁ The ▁ result ▁ is ▁ a ▁ ` ` QuerySet ` ` ▁ object , ▁ so ▁ this ▁ function ▁ can ▁ be ▁ used STRNEWLINE ▁ to ▁ fill ▁ ` ` ModelChoiceField ` ` ▁ objects . STRNEWLINE ▁ """ NEW_LINE if admin . is_superuser : NEW_LINE INDENT return self . get_queryset ( ) NEW_LINE DEDENT return self . get_queryset ( ) . filter ( owners__user = admin ) NEW_LINE DEDENT
def __str__ ( self ) : NEW_LINE INDENT return smart_text ( self . name ) NEW_LINE DEDENT
def from_csv ( self , user , row ) : NEW_LINE INDENT """ Create ▁ a ▁ domain ▁ alias ▁ from ▁ a ▁ CSV ▁ row STRNEWLINE STRNEWLINE ▁ Expected ▁ format : ▁ [ " domainalias " , ▁ domain ▁ alias ▁ name , ▁ targeted ▁ domain , ▁ enabled ] STRNEWLINE STRNEWLINE ▁ : param ▁ user : ▁ a ▁ ` ` User ` ` ▁ object STRNEWLINE ▁ : param ▁ row : ▁ a ▁ list ▁ containing ▁ the ▁ alias ▁ definition STRNEWLINE ▁ """ NEW_LINE if len ( row ) < 4 : NEW_LINE INDENT raise BadRequest ( _ ( " Invalid ▁ line " ) ) NEW_LINE DEDENT self . name = row [ 1 ] . strip ( ) NEW_LINE for model in [ DomainAlias , Domain ] : NEW_LINE INDENT if model . objects . filter ( name = self . name ) . exists ( ) : NEW_LINE INDENT raise Conflict NEW_LINE DEDENT DEDENT domname = row [ 2 ] . strip ( ) NEW_LINE try : NEW_LINE INDENT self . target = Domain . objects . get ( name = domname ) NEW_LINE DEDENT except Domain . DoesNotExist : NEW_LINE INDENT raise BadRequest ( _ ( " Unknown ▁ domain ▁ % s " ) % domname ) NEW_LINE DEDENT core_signals . can_create_object . send ( sender = " import " , context = self . target , object_type = " domain _ aliases " ) NEW_LINE self . enabled = row [ 3 ] . strip ( ) in [ " True " , "1" , " yes " , " y " ] NEW_LINE self . save ( creator = user ) NEW_LINE DEDENT
def to_csv ( self , csvwriter ) : NEW_LINE INDENT """ Export ▁ a ▁ domain ▁ alias ▁ using ▁ CSV ▁ format STRNEWLINE STRNEWLINE ▁ : param ▁ csvwriter : ▁ a ▁ ` ` csv . writer ` ` ▁ object STRNEWLINE ▁ """ NEW_LINE csvwriter . writerow ( [ " domainalias " , self . name , self . target . name , self . enabled ] ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT self . vault_password = " hunter42" NEW_LINE self . good_vault = vault . VaultLib ( self . vault_password ) NEW_LINE self . vault = self . good_vault NEW_LINE self . stream = self . _build_stream ( ) NEW_LINE self . dumper = dumper . AnsibleDumper NEW_LINE DEDENT
def _build_stream ( self , yaml_text = None ) : NEW_LINE INDENT text = yaml_text or u ' ' NEW_LINE stream = io . StringIO ( text ) NEW_LINE return stream NEW_LINE DEDENT
def _loader ( self , stream ) : NEW_LINE INDENT return AnsibleLoader ( stream , vault_password = self . vault_password ) NEW_LINE DEDENT
def test ( self ) : NEW_LINE INDENT plaintext = ' This ▁ is ▁ a ▁ string ▁ we ▁ are ▁ going ▁ to ▁ encrypt . ' NEW_LINE avu = objects . AnsibleVaultEncryptedUnicode . from_plaintext ( plaintext , vault = self . vault ) NEW_LINE yaml_out = self . _dump_string ( avu , dumper = self . dumper ) NEW_LINE stream = self . _build_stream ( yaml_out ) NEW_LINE loader = self . _loader ( stream ) NEW_LINE data_from_yaml = loader . get_single_data ( ) NEW_LINE self . assertEquals ( plaintext , data_from_yaml . data ) NEW_LINE DEDENT
def nud ( self , parser ) : NEW_LINE # ▁ Null ▁ denotation ▁ - ▁ called ▁ in ▁ prefix ▁ context ENDCOM INDENT raise parser . error_class ( " Not ▁ expecting ▁ ' % s ' ▁ in ▁ this ▁ position ▁ in ▁ if ▁ tag . " % self . id ) NEW_LINE DEDENT
def led ( self , left , parser ) : NEW_LINE # ▁ Left ▁ denotation ▁ - ▁ called ▁ in ▁ infix ▁ context ENDCOM INDENT raise parser . error_class ( " Not ▁ expecting ▁ ' % s ' ▁ as ▁ infix ▁ operator ▁ in ▁ if ▁ tag . " % self . id ) NEW_LINE DEDENT
def display ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ what ▁ to ▁ display ▁ in ▁ error ▁ messages ▁ for ▁ this ▁ node STRNEWLINE ▁ """ NEW_LINE return self . id NEW_LINE DEDENT
def __repr__ ( self ) : NEW_LINE INDENT out = [ str ( x ) for x in [ self . id , self . first , self . second ] if x is not None ] NEW_LINE return " ( " + " ▁ " . join ( out ) + " ) " NEW_LINE DEDENT
def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE DEDENT
def display ( self ) : NEW_LINE INDENT return repr ( self . value ) NEW_LINE DEDENT
def nud ( self , parser ) : NEW_LINE INDENT return self NEW_LINE DEDENT
def eval ( self , context ) : NEW_LINE INDENT return self . value NEW_LINE DEDENT
def __repr__ ( self ) : NEW_LINE INDENT return " ( % s ▁ % r ) " % ( self . id , self . value ) NEW_LINE DEDENT
def nud ( self , parser ) : NEW_LINE INDENT raise parser . error_class ( " Unexpected ▁ end ▁ of ▁ expression ▁ in ▁ if ▁ tag . " ) NEW_LINE DEDENT
def __init__ ( self , tokens ) : NEW_LINE # ▁ pre - pass ▁ necessary ▁ to ▁ turn ▁ ' not ' , ' in ' ▁ into ▁ single ▁ token ENDCOM INDENT l = len ( tokens ) NEW_LINE mapped_tokens = [ ] NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT token = tokens [ i ] NEW_LINE if token == " not " and i + 1 < l and tokens [ i + 1 ] == " in " : NEW_LINE INDENT token = " not ▁ in " NEW_LINE i += 1 # ▁ skip ▁ ' in ' ENDCOM NEW_LINE DEDENT mapped_tokens . append ( self . translate_token ( token ) ) NEW_LINE i += 1 NEW_LINE DEDENT self . tokens = mapped_tokens NEW_LINE self . pos = 0 NEW_LINE self . current_token = self . next_token ( ) NEW_LINE DEDENT
def translate_token ( self , token ) : NEW_LINE INDENT try : NEW_LINE INDENT op = OPERATORS [ token ] NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT return self . create_var ( token ) NEW_LINE DEDENT else : NEW_LINE INDENT if token == ' = ' : NEW_LINE INDENT warnings . warn ( " Operator ▁ ' = ' ▁ is ▁ deprecated ▁ and ▁ will ▁ be ▁ removed ▁ in ▁ Django ▁ 1.10 . ▁ Use ▁ ' = = ' ▁ instead . " , RemovedInDjango110Warning , stacklevel = 2 ) NEW_LINE DEDENT return op ( ) NEW_LINE DEDENT DEDENT
def next_token ( self ) : NEW_LINE INDENT if self . pos >= len ( self . tokens ) : NEW_LINE INDENT return EndToken NEW_LINE DEDENT else : NEW_LINE INDENT retval = self . tokens [ self . pos ] NEW_LINE self . pos += 1 NEW_LINE return retval NEW_LINE DEDENT DEDENT
def parse ( self ) : NEW_LINE INDENT retval = self . expression ( ) NEW_LINE # ▁ Check ▁ that ▁ we ▁ have ▁ exhausted ▁ all ▁ the ▁ tokens ENDCOM if self . current_token is not EndToken : NEW_LINE INDENT raise self . error_class ( " Unused ▁ ' % s ' ▁ at ▁ end ▁ of ▁ if ▁ expression . " % self . current_token . display ( ) ) NEW_LINE DEDENT return retval NEW_LINE DEDENT
def expression ( self , rbp = 0 ) : NEW_LINE INDENT t = self . current_token NEW_LINE self . current_token = self . next_token ( ) NEW_LINE left = t . nud ( self ) NEW_LINE while rbp < self . current_token . lbp : NEW_LINE INDENT t = self . current_token NEW_LINE self . current_token = self . next_token ( ) NEW_LINE left = t . led ( left , self ) NEW_LINE DEDENT return left NEW_LINE DEDENT
def create_var ( self , value ) : NEW_LINE INDENT return Literal ( value ) NEW_LINE DEDENT
def __init__ ( self , * args , ** kw ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def bind ( self , * args , ** kw ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def close ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def can_handle_url ( self , url ) : NEW_LINE INDENT return _url_re . match ( url ) NEW_LINE DEDENT
def _get_streams ( self ) : NEW_LINE INDENT res = http . get ( self . url , schema = _schema ) NEW_LINE streams = { } NEW_LINE for url in res [ " urls " ] : NEW_LINE INDENT parsed = urlparse ( url ) NEW_LINE if parsed . scheme . startswith ( " rtmp " ) : NEW_LINE INDENT params = { " rtmp " : url , " pageUrl " : self . url , " live " : True } NEW_LINE if res [ " swf " ] : NEW_LINE INDENT params [ " swfVfy " ] = res [ " swf " ] NEW_LINE DEDENT stream = RTMPStream ( self . session , params ) NEW_LINE streams [ " live " ] = stream NEW_LINE DEDENT elif parsed . scheme . startswith ( " http " ) : NEW_LINE INDENT name = splitext ( parsed . path ) [ 1 ] [ 1 : ] NEW_LINE stream = HTTPStream ( self . session , url ) NEW_LINE streams [ name ] = stream NEW_LINE DEDENT DEDENT return streams NEW_LINE DEDENT
def chmod ( self , path , permission ) : NEW_LINE INDENT """ Set ▁ the ▁ permission ▁ of ▁ ' path ' ▁ to ▁ ' permission ' ▁ ( specified ▁ as ▁ an ▁ octal ▁ string , ▁ e . g . STRNEWLINE ▁ ' 775 ' """ NEW_LINE uri = self . _create_uri ( path , " SETPERMISSION " , permission = permission ) NEW_LINE response = requests . put ( uri , allow_redirects = True ) NEW_LINE if not response . status_code == httplib . OK : NEW_LINE INDENT _raise_pywebhdfs_exception ( response . status_code , response . text ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def __init__ ( self , filename ) : NEW_LINE INDENT self . conf = { } NEW_LINE tree = parse ( filename ) NEW_LINE for property in tree . getroot ( ) . getiterator ( ' property ' ) : NEW_LINE INDENT self . conf [ property . find ( ' name ' ) . text ] = property . find ( ' value ' ) . text NEW_LINE DEDENT DEDENT
def get ( self , key ) : NEW_LINE INDENT return self . conf . get ( key ) NEW_LINE DEDENT
def __pyweb_hdfs_client_exists ( self , path ) : NEW_LINE INDENT """ The ▁ PyWebHdfsClient ▁ doesn ' t ▁ provide ▁ an ▁ API ▁ to ▁ cleanly ▁ detect ▁ if ▁ a ▁ file ▁ or ▁ directory STRNEWLINE ▁ exists . ▁ This ▁ method ▁ is ▁ bound ▁ to ▁ each ▁ client ▁ that ▁ is ▁ created ▁ so ▁ tests ▁ can ▁ simply ▁ call STRNEWLINE ▁ hdfs _ client . exists ( ' path ' ) ▁ and ▁ get ▁ back ▁ a ▁ bool . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . get_file_dir_status ( path ) NEW_LINE DEDENT except errors . FileNotFound : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def __init__ ( self , name , platform , uuid ) : NEW_LINE INDENT self . uuid = uuid NEW_LINE self . config_name = name NEW_LINE if " ( " in name : NEW_LINE INDENT parts = name . split ( " ( " , 1 ) NEW_LINE self . name , self . variant = parts NEW_LINE self . name = self . name . strip ( ) NEW_LINE self . variant = self . variant . strip ( ) NEW_LINE if self . variant . endswith ( " ) " ) : NEW_LINE INDENT self . variant = self . variant [ : - 1 ] NEW_LINE DEDENT self . variant = self . variant . replace ( " ) ▁ ( " , " , ▁ " ) NEW_LINE self . variant = self . variant . replace ( " ) ( " , " , ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . name = name NEW_LINE self . variant = " " NEW_LINE DEDENT self . platform = platform NEW_LINE DEDENT
def get_name ( self ) : NEW_LINE INDENT return self . name NEW_LINE DEDENT
def get_variant ( self ) : NEW_LINE INDENT return self . variant NEW_LINE DEDENT
def get_screenshot_path ( self , number ) : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT sha1 = LauncherConfig . get ( " title _ sha1" ) NEW_LINE DEDENT else : NEW_LINE INDENT sha1 = LauncherConfig . get ( " screen { 0 } _ sha1" . format ( number ) ) NEW_LINE DEDENT if sha1 : NEW_LINE INDENT return " sha1 : " + sha1 NEW_LINE DEDENT if number == 0 : NEW_LINE INDENT path = self . get_override_path ( " title _ image " ) NEW_LINE DEDENT else : NEW_LINE INDENT path = self . get_override_path ( " screen { 0 } _ image " . format ( number ) ) NEW_LINE DEDENT if path and os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT if self . uuid : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT name = " title . png " NEW_LINE DEDENT else : NEW_LINE INDENT name = " screen { 0 } . png " . format ( number ) NEW_LINE DEDENT paths = FSGSDirectories . get_images_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT p = os . path . join ( dir_ , self . platform , " Images " , self . uuid [ : 2 ] , self . uuid , name ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT p = os . path . join ( dir_ , self . platform , " Thumbnails " , self . uuid [ : 2 ] , self . uuid , name ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT name = self . name NEW_LINE if number == 0 : NEW_LINE INDENT override_dir = LauncherConfig . get ( " titles _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_titles_dirs ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT override_dir = LauncherConfig . get ( " screenshots _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_screenshots_dirs ( ) NEW_LINE DEDENT DEDENT if number >= 2 : NEW_LINE INDENT name = " { 0 } _ {1 } " . format ( name , number ) NEW_LINE DEDENT for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . gif " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . gif " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def load_screenshot ( self , number ) : NEW_LINE INDENT path = self . get_screenshot_path ( number ) NEW_LINE if path : NEW_LINE INDENT return fsui . Image ( path ) NEW_LINE DEDENT DEDENT
def load_screenshot_preview ( self , number ) : NEW_LINE INDENT image = self . load_screenshot ( number ) NEW_LINE if image is None : NEW_LINE INDENT return image NEW_LINE DEDENT if image . size == Constants . SCREEN_SIZE : NEW_LINE INDENT return image NEW_LINE DEDENT if image . size [ 0 ] < 400 : NEW_LINE INDENT image . resize ( ( image . size [ 0 ] * 2 , image . size [ 1 ] * 2 ) , fsui . Image . NEAREST ) NEW_LINE DEDENT image . resize ( Constants . SCREEN_SIZE ) NEW_LINE return image NEW_LINE DEDENT
def get_cover_path ( self ) : NEW_LINE INDENT sha1 = LauncherConfig . get ( " front _ sha1" ) NEW_LINE if sha1 : NEW_LINE INDENT return " sha1 : " + sha1 NEW_LINE DEDENT path = self . get_override_path ( " cover _ image " ) NEW_LINE if path and os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT if self . uuid : NEW_LINE INDENT paths = FSGSDirectories . get_images_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT p = os . path . join ( dir_ , self . platform , " Images " , self . uuid [ : 2 ] , self . uuid , " front . png " ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT p = os . path . join ( dir_ , self . platform , " Thumbnails " , self . uuid [ : 2 ] , self . uuid , " front . png " ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT name = self . name NEW_LINE override_dir = LauncherConfig . get ( " covers _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_covers_dirs ( ) NEW_LINE DEDENT for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , name + " . jpg " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . jpg " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def load_cover ( self ) : NEW_LINE INDENT path = self . get_cover_path ( ) NEW_LINE print ( path ) NEW_LINE if path : NEW_LINE INDENT return fsui . Image ( path ) NEW_LINE DEDENT DEDENT
def load_cover_preview ( self ) : NEW_LINE INDENT image = self . load_cover ( ) NEW_LINE if image is None : NEW_LINE INDENT return image NEW_LINE DEDENT image . resize ( Constants . COVER_SIZE ) NEW_LINE return image NEW_LINE DEDENT
def get_theme_path ( self ) : NEW_LINE INDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT paths = FSGSDirectories . get_themes_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , self . name ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def _get_state_dir ( self ) : NEW_LINE INDENT config_name = self . config_name NEW_LINE if not config_name : NEW_LINE INDENT config_name = " Default " NEW_LINE # ▁ use ▁ a ▁ temporary ▁ state ▁ dir , ▁ for ▁ now , ▁ to ▁ avoid ▁ problems ▁ with ENDCOM # ▁ floppy ▁ overlays ▁ etc ▁ interfering ▁ with ▁ net ▁ play ENDCOM DEDENT from . netplay . netplay import Netplay NEW_LINE if Netplay . current ( ) : NEW_LINE # ▁ it ▁ is ▁ possible ▁ to ▁ manually ▁ specify ▁ the ▁ state ▁ dir ENDCOM INDENT config_name = LauncherConfig . get ( " _ _ netplay _ state _ dir _ name " ) NEW_LINE if not config_name : NEW_LINE # ▁ this ▁ is ▁ the ▁ default ▁ behavior , ▁ create ▁ a ▁ clean ▁ state ENDCOM # ▁ dir ▁ for ▁ the ▁ net ▁ play ▁ session ENDCOM INDENT netplay_game = LauncherConfig . get ( " _ _ netplay _ game " ) NEW_LINE if netplay_game : NEW_LINE INDENT config_name = " Net ▁ Play ▁ ( {0 } ) " . format ( netplay_game ) NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( config_name ) NEW_LINE if not letter : NEW_LINE INDENT config_name = " Default " NEW_LINE letter = self . get_letter ( config_name ) NEW_LINE # ▁ we ▁ use ▁ an ▁ existing ▁ state ▁ dir ▁ in ▁ a ▁ " letter " ▁ dir ▁ if ▁ it ▁ exists ENDCOM # ▁ ( legacy ▁ support ) . ENDCOM DEDENT path = os . path . join ( FSGSDirectories . get_save_states_dir ( ) , letter , config_name ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE # ▁ if ▁ not , ▁ we ▁ use ▁ a ▁ direct ▁ sub - folder ▁ of ▁ save ▁ states ▁ dir ENDCOM DEDENT path = os . path . join ( FSGSDirectories . get_save_states_dir ( ) , config_name ) NEW_LINE return path NEW_LINE DEDENT
def get_state_dir ( self ) : NEW_LINE INDENT state_dir = self . _get_state_dir ( ) NEW_LINE if not os . path . exists ( state_dir ) : NEW_LINE INDENT os . makedirs ( state_dir ) NEW_LINE DEDENT return state_dir NEW_LINE DEDENT
def __init__ ( self ) : Element . __init__ ( self ) NEW_LINE def get_coordinate ( self ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Get ▁ the ▁ 0,0 ▁ coordinate . STRNEWLINE TABSYMBOL TABSYMBOL Coordinates ▁ are ▁ irrelevant ▁ in ▁ connection . STRNEWLINE TABSYMBOL TABSYMBOL @ return ▁ 0 , ▁ 0 STRNEWLINE TABSYMBOL TABSYMBOL """ NEW_LINE return ( 0 , 0 ) NEW_LINE DEDENT
def get_rotation ( self ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Get ▁ the ▁ 0 ▁ degree ▁ rotation . STRNEWLINE TABSYMBOL TABSYMBOL Rotations ▁ are ▁ irrelevant ▁ in ▁ connection . STRNEWLINE TABSYMBOL TABSYMBOL @ return ▁ 0 STRNEWLINE TABSYMBOL TABSYMBOL """ NEW_LINE return 0 NEW_LINE DEDENT
def create_shapes ( self ) : NEW_LINE INDENT """ Precalculate ▁ relative ▁ coordinates . """ NEW_LINE Element . create_shapes ( self ) NEW_LINE self . _sink_rot = None NEW_LINE self . _source_rot = None NEW_LINE self . _sink_coor = None NEW_LINE self . _source_coor = None NEW_LINE # get ▁ the ▁ source ▁ coordinate ENDCOM connector_length = self . get_source ( ) . get_connector_length ( ) NEW_LINE self . x1 , self . y1 = Utils . get_rotated_coordinate ( ( connector_length , 0 ) , self . get_source ( ) . get_rotation ( ) ) NEW_LINE # get ▁ the ▁ sink ▁ coordinate ENDCOM connector_length = self . get_sink ( ) . get_connector_length ( ) + CONNECTOR_ARROW_HEIGHT NEW_LINE self . x2 , self . y2 = Utils . get_rotated_coordinate ( ( - connector_length , 0 ) , self . get_sink ( ) . get_rotation ( ) ) NEW_LINE # build ▁ the ▁ arrow ENDCOM self . arrow = [ ( 0 , 0 ) , Utils . get_rotated_coordinate ( ( - CONNECTOR_ARROW_HEIGHT , - CONNECTOR_ARROW_BASE / 2 ) , self . get_sink ( ) . get_rotation ( ) ) , Utils . get_rotated_coordinate ( ( - CONNECTOR_ARROW_HEIGHT , CONNECTOR_ARROW_BASE / 2 ) , self . get_sink ( ) . get_rotation ( ) ) , ] NEW_LINE self . _update_after_move ( ) NEW_LINE if not self . get_enabled ( ) : self . _arrow_color = Colors . CONNECTION_DISABLED_COLOR NEW_LINE elif not self . is_valid ( ) : self . _arrow_color = Colors . CONNECTION_ERROR_COLOR NEW_LINE else : self . _arrow_color = Colors . CONNECTION_ENABLED_COLOR NEW_LINE DEDENT
def _update_after_move ( self ) : NEW_LINE INDENT """ Calculate ▁ coordinates . """ NEW_LINE self . clear ( ) # FIXME ▁ do ▁ i ▁ want ▁ this ▁ here ? ENDCOM NEW_LINE # source ▁ connector ENDCOM source = self . get_source ( ) NEW_LINE X , Y = source . get_connector_coordinate ( ) NEW_LINE x1 , y1 = self . x1 + X , self . y1 + Y NEW_LINE self . add_line ( ( x1 , y1 ) , ( X , Y ) ) NEW_LINE # sink ▁ connector ENDCOM sink = self . get_sink ( ) NEW_LINE X , Y = sink . get_connector_coordinate ( ) NEW_LINE x2 , y2 = self . x2 + X , self . y2 + Y NEW_LINE self . add_line ( ( x2 , y2 ) , ( X , Y ) ) NEW_LINE # adjust ▁ arrow ENDCOM self . _arrow = [ ( x + X , y + Y ) for x , y in self . arrow ] NEW_LINE # add ▁ the ▁ horizontal ▁ and ▁ vertical ▁ lines ▁ in ▁ this ▁ connection ENDCOM if abs ( source . get_connector_direction ( ) - sink . get_connector_direction ( ) ) == 180 : NEW_LINE # 2 ▁ possible ▁ point ▁ sets ▁ to ▁ create ▁ a ▁ 3 - line ▁ connector ENDCOM INDENT mid_x , mid_y = ( x1 + x2 ) / 2.0 , ( y1 + y2 ) / 2.0 NEW_LINE points = [ ( ( mid_x , y1 ) , ( mid_x , y2 ) ) , ( ( x1 , mid_y ) , ( x2 , mid_y ) ) ] NEW_LINE # source ▁ connector ▁ - > ▁ points [ 0 ] [ 0 ] ▁ should ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ▁ ( if ▁ possible ) ENDCOM if Utils . get_angle_from_coordinates ( ( x1 , y1 ) , points [ 0 ] [ 0 ] ) != source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] [ 0 ] ▁ - > ▁ sink ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ sink ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] [ 0 ] , ( x2 , y2 ) ) == sink . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] [ 0 ] ▁ - > ▁ source ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] [ 0 ] , ( x1 , y1 ) ) == source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # create ▁ 3 - line ▁ connector ENDCOM p1 , p2 = map ( int , points [ 0 ] [ 0 ] ) , map ( int , points [ 0 ] [ 1 ] ) NEW_LINE self . add_line ( ( x1 , y1 ) , p1 ) NEW_LINE self . add_line ( p1 , p2 ) NEW_LINE self . add_line ( ( x2 , y2 ) , p2 ) NEW_LINE DEDENT else : NEW_LINE # 2 ▁ possible ▁ points ▁ to ▁ create ▁ a ▁ right - angled ▁ connector ENDCOM INDENT points = [ ( x1 , y2 ) , ( x2 , y1 ) ] NEW_LINE # source ▁ connector ▁ - > ▁ points [ 0 ] ▁ should ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ▁ ( if ▁ possible ) ENDCOM if Utils . get_angle_from_coordinates ( ( x1 , y1 ) , points [ 0 ] ) != source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] ▁ - > ▁ sink ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ sink ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] , ( x2 , y2 ) ) == sink . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] ▁ - > ▁ source ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] , ( x1 , y1 ) ) == source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # create ▁ right - angled ▁ connector ENDCOM self . add_line ( ( x1 , y1 ) , points [ 0 ] ) NEW_LINE self . add_line ( ( x2 , y2 ) , points [ 0 ] ) NEW_LINE DEDENT DEDENT
def draw ( self , gc , window ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Draw ▁ the ▁ connection . STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ gc ▁ the ▁ graphics ▁ context STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ window ▁ the ▁ gtk ▁ window ▁ to ▁ draw ▁ on STRNEWLINE TABSYMBOL TABSYMBOL """ NEW_LINE sink = self . get_sink ( ) NEW_LINE source = self . get_source ( ) NEW_LINE # check ▁ for ▁ changes ENDCOM if self . _sink_rot != sink . get_rotation ( ) or self . _source_rot != source . get_rotation ( ) : self . create_shapes ( ) NEW_LINE elif self . _sink_coor != sink . get_coordinate ( ) or self . _source_coor != source . get_coordinate ( ) : self . _update_after_move ( ) NEW_LINE # cache ▁ values ENDCOM self . _sink_rot = sink . get_rotation ( ) NEW_LINE self . _source_rot = source . get_rotation ( ) NEW_LINE self . _sink_coor = sink . get_coordinate ( ) NEW_LINE self . _source_coor = source . get_coordinate ( ) NEW_LINE # draw ENDCOM if self . is_highlighted ( ) : border_color = Colors . HIGHLIGHT_COLOR NEW_LINE elif self . get_enabled ( ) : border_color = Colors . CONNECTION_ENABLED_COLOR NEW_LINE else : border_color = Colors . CONNECTION_DISABLED_COLOR NEW_LINE Element . draw ( self , gc , window , bg_color = None , border_color = border_color ) NEW_LINE # draw ▁ arrow ▁ on ▁ sink ▁ port ENDCOM gc . set_foreground ( self . _arrow_color ) NEW_LINE window . draw_polygon ( gc , True , self . _arrow ) NEW_LINE DEDENT
def __init__ ( self , connection ) : NEW_LINE INDENT self . connection = connection NEW_LINE DEDENT
def _digest ( self , * args ) : NEW_LINE INDENT """ STRNEWLINE ▁ Generates ▁ a ▁ 32 - bit ▁ digest ▁ of ▁ a ▁ set ▁ of ▁ arguments ▁ that ▁ can ▁ be ▁ used ▁ to STRNEWLINE ▁ shorten ▁ identifying ▁ names . STRNEWLINE ▁ """ NEW_LINE return ' % x ' % ( abs ( hash ( args ) ) % 4294967296 L ) # ▁ 2 * * 32 ENDCOM NEW_LINE DEDENT
def db_type ( self , field ) : NEW_LINE INDENT return self . _db_type ( field , field . get_internal_type ( ) ) NEW_LINE DEDENT
def related_db_type ( self , field ) : NEW_LINE INDENT return self . _db_type ( field , field . get_related_internal_type ( ) ) NEW_LINE DEDENT
def _db_type ( self , field , internal_type ) : NEW_LINE INDENT data = DictWrapper ( field . __dict__ , self . connection . ops . quote_name , " qn _ " ) NEW_LINE try : NEW_LINE INDENT return self . connection . creation . data_types [ internal_type ] % data NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def sql_create_model ( self , model , style , known_models = set ( ) ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ the ▁ SQL ▁ required ▁ to ▁ create ▁ a ▁ single ▁ model , ▁ as ▁ a ▁ tuple ▁ of : STRNEWLINE ▁ ( list _ of _ sql , ▁ pending _ references _ dict ) STRNEWLINE ▁ """ NEW_LINE opts = model . _meta NEW_LINE if not opts . managed or opts . proxy : NEW_LINE INDENT return [ ] , { } NEW_LINE DEDENT final_output = [ ] NEW_LINE table_output = [ ] NEW_LINE pending_references = { } NEW_LINE qn = self . connection . ops . quote_name NEW_LINE for f in opts . local_fields : NEW_LINE INDENT col_type = f . db_type ( connection = self . connection ) NEW_LINE tablespace = f . db_tablespace or opts . db_tablespace NEW_LINE if col_type is None : NEW_LINE # ▁ Skip ▁ ManyToManyFields , ▁ because ▁ they ' re ▁ not ▁ represented ▁ as ENDCOM # ▁ database ▁ columns ▁ in ▁ this ▁ table . ENDCOM INDENT continue NEW_LINE # ▁ Make ▁ the ▁ definition ▁ ( e . g . ▁ ' foo ▁ VARCHAR ( 30 ) ' ) ▁ for ▁ this ▁ field . ENDCOM DEDENT field_output = [ style . SQL_FIELD ( qn ( f . column ) ) , style . SQL_COLTYPE ( col_type ) ] NEW_LINE if not f . null : NEW_LINE INDENT field_output . append ( style . SQL_KEYWORD ( ' NOT ▁ NULL ' ) ) NEW_LINE DEDENT if f . primary_key : NEW_LINE INDENT field_output . append ( style . SQL_KEYWORD ( ' PRIMARY ▁ KEY ' ) ) NEW_LINE DEDENT elif f . unique : NEW_LINE INDENT field_output . append ( style . SQL_KEYWORD ( ' UNIQUE ' ) ) NEW_LINE DEDENT if tablespace and f . unique : NEW_LINE # ▁ We ▁ must ▁ specify ▁ the ▁ index ▁ tablespace ▁ inline , ▁ because ▁ we ENDCOM # ▁ won ' t ▁ be ▁ generating ▁ a ▁ CREATE ▁ INDEX ▁ statement ▁ for ▁ this ▁ field . ENDCOM INDENT field_output . append ( self . connection . ops . tablespace_sql ( tablespace , inline = True ) ) NEW_LINE DEDENT if f . rel : NEW_LINE INDENT ref_output , pending = self . sql_for_inline_foreign_key_references ( f , known_models , style ) NEW_LINE if pending : NEW_LINE INDENT pr = pending_references . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) ) NEW_LINE DEDENT else : NEW_LINE INDENT field_output . extend ( ref_output ) NEW_LINE DEDENT DEDENT table_output . append ( ' ▁ ' . join ( field_output ) ) NEW_LINE DEDENT for field_constraints in opts . unique_together : NEW_LINE INDENT table_output . append ( style . SQL_KEYWORD ( ' UNIQUE ' ) + ' ▁ ( % s ) ' % " , ▁ " . join ( [ style . SQL_FIELD ( qn ( opts . get_field ( f ) . column ) ) for f in field_constraints ] ) ) NEW_LINE DEDENT full_statement = [ style . SQL_KEYWORD ( ' CREATE ▁ TABLE ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( opts . db_table ) ) + ' ▁ ( ' ] NEW_LINE for i , line in enumerate ( table_output ) : # ▁ Combine ▁ and ▁ add ▁ commas . ENDCOM NEW_LINE INDENT full_statement . append ( ' ▁ ▁ ▁ ▁ % s % s ' % ( line , i < len ( table_output ) - 1 and ' , ' or ' ' ) ) NEW_LINE DEDENT full_statement . append ( ' ) ' ) NEW_LINE if opts . db_tablespace : NEW_LINE INDENT full_statement . append ( self . connection . ops . tablespace_sql ( opts . db_tablespace ) ) NEW_LINE DEDENT full_statement . append ( ' ; ' ) NEW_LINE final_output . append ( ' \n ' . join ( full_statement ) ) NEW_LINE if opts . has_auto_field : NEW_LINE # ▁ Add ▁ any ▁ extra ▁ SQL ▁ needed ▁ to ▁ support ▁ auto - incrementing ▁ primary ▁ keys . ENDCOM INDENT auto_column = opts . auto_field . db_column or opts . auto_field . name NEW_LINE autoinc_sql = self . connection . ops . autoinc_sql ( opts . db_table , auto_column ) NEW_LINE if autoinc_sql : NEW_LINE INDENT for stmt in autoinc_sql : NEW_LINE INDENT final_output . append ( stmt ) NEW_LINE DEDENT DEDENT DEDENT return final_output , pending_references NEW_LINE DEDENT
def sql_for_inline_foreign_key_references ( self , field , known_models , style ) : NEW_LINE INDENT " Return ▁ the ▁ SQL ▁ snippet ▁ defining ▁ the ▁ foreign ▁ key ▁ reference ▁ for ▁ a ▁ field " NEW_LINE qn = self . connection . ops . quote_name NEW_LINE if field . rel . to in known_models : NEW_LINE INDENT output = [ style . SQL_KEYWORD ( ' REFERENCES ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( field . rel . to . _meta . db_table ) ) + ' ▁ ( ' + style . SQL_FIELD ( qn ( field . rel . to . _meta . get_field ( field . rel . field_name ) . column ) ) + ' ) ' + self . connection . ops . deferrable_sql ( ) ] NEW_LINE pending = False NEW_LINE DEDENT else : NEW_LINE # ▁ We ▁ haven ' t ▁ yet ▁ created ▁ the ▁ table ▁ to ▁ which ▁ this ▁ field ENDCOM # ▁ is ▁ related , ▁ so ▁ save ▁ it ▁ for ▁ later . ENDCOM INDENT output = [ ] NEW_LINE pending = True NEW_LINE DEDENT return output , pending NEW_LINE DEDENT
def sql_for_pending_references ( self , model , style , pending_references ) : NEW_LINE INDENT " Returns ▁ any ▁ ALTER ▁ TABLE ▁ statements ▁ to ▁ add ▁ constraints ▁ after ▁ the ▁ fact . " NEW_LINE from django . db . backends . util import truncate_name NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE DEDENT qn = self . connection . ops . quote_name NEW_LINE final_output = [ ] NEW_LINE opts = model . _meta NEW_LINE if model in pending_references : NEW_LINE INDENT for rel_class , f in pending_references [ model ] : NEW_LINE INDENT rel_opts = rel_class . _meta NEW_LINE r_table = rel_opts . db_table NEW_LINE r_col = f . column NEW_LINE table = opts . db_table NEW_LINE col = opts . get_field ( f . rel . field_name ) . column NEW_LINE # ▁ For ▁ MySQL , ▁ r _ name ▁ must ▁ be ▁ unique ▁ in ▁ the ▁ first ▁ 64 ▁ characters . ENDCOM # ▁ So ▁ we ▁ are ▁ careful ▁ with ▁ character ▁ usage ▁ here . ENDCOM r_name = ' % s _ refs _ % s _ % s ' % ( r_col , col , self . _digest ( r_table , table ) ) NEW_LINE final_output . append ( style . SQL_KEYWORD ( ' ALTER ▁ TABLE ' ) + ' ▁ % s ▁ ADD ▁ CONSTRAINT ▁ % s ▁ FOREIGN ▁ KEY ▁ ( % s ) ▁ REFERENCES ▁ % s ▁ ( % s ) % s ; ' % ( qn ( r_table ) , qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) , qn ( r_col ) , qn ( table ) , qn ( col ) , self . connection . ops . deferrable_sql ( ) ) ) NEW_LINE DEDENT del pending_references [ model ] NEW_LINE DEDENT return final_output NEW_LINE DEDENT
def sql_for_many_to_many ( self , model , style ) : NEW_LINE INDENT " Return ▁ the ▁ CREATE ▁ TABLE ▁ statments ▁ for ▁ all ▁ the ▁ many - to - many ▁ tables ▁ defined ▁ on ▁ a ▁ model " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE output = [ ] NEW_LINE for f in model . _meta . local_many_to_many : NEW_LINE INDENT if model . _meta . managed or f . rel . to . _meta . managed : NEW_LINE INDENT output . extend ( self . sql_for_many_to_many_field ( model , f , style ) ) NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
def sql_for_many_to_many_field ( self , model , f , style ) : NEW_LINE INDENT " Return ▁ the ▁ CREATE ▁ TABLE ▁ statements ▁ for ▁ a ▁ single ▁ m2m ▁ field " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE from django . db import models NEW_LINE from django . db . backends . util import truncate_name NEW_LINE output = [ ] NEW_LINE if f . auto_created : NEW_LINE INDENT opts = model . _meta NEW_LINE qn = self . connection . ops . quote_name NEW_LINE tablespace = f . db_tablespace or opts . db_tablespace NEW_LINE if tablespace : NEW_LINE INDENT sql = self . connection . ops . tablespace_sql ( tablespace , inline = True ) NEW_LINE if sql : NEW_LINE INDENT tablespace_sql = ' ▁ ' + sql NEW_LINE DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT table_output = [ style . SQL_KEYWORD ( ' CREATE ▁ TABLE ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( f . m2m_db_table ( ) ) ) + ' ▁ ( ' ] NEW_LINE table_output . append ( ' ▁ ▁ ▁ ▁ % s ▁ % s ▁ % s % s , ' % ( style . SQL_FIELD ( qn ( ' id ' ) ) , style . SQL_COLTYPE ( models . AutoField ( primary_key = True ) . db_type ( connection = self . connection ) ) , style . SQL_KEYWORD ( ' NOT ▁ NULL ▁ PRIMARY ▁ KEY ' ) , tablespace_sql ) ) NEW_LINE deferred = [ ] NEW_LINE inline_output , deferred = self . sql_for_inline_many_to_many_references ( model , f , style ) NEW_LINE table_output . extend ( inline_output ) NEW_LINE table_output . append ( ' ▁ ▁ ▁ ▁ % s ▁ ( % s , ▁ % s ) % s ' % ( style . SQL_KEYWORD ( ' UNIQUE ' ) , style . SQL_FIELD ( qn ( f . m2m_column_name ( ) ) ) , style . SQL_FIELD ( qn ( f . m2m_reverse_name ( ) ) ) , tablespace_sql ) ) NEW_LINE table_output . append ( ' ) ' ) NEW_LINE if opts . db_tablespace : NEW_LINE # ▁ f . db _ tablespace ▁ is ▁ only ▁ for ▁ indices , ▁ so ▁ ignore ▁ its ▁ value ▁ here . ENDCOM INDENT table_output . append ( self . connection . ops . tablespace_sql ( opts . db_tablespace ) ) NEW_LINE DEDENT table_output . append ( ' ; ' ) NEW_LINE output . append ( ' \n ' . join ( table_output ) ) NEW_LINE for r_table , r_col , table , col in deferred : NEW_LINE INDENT r_name = ' % s _ refs _ % s _ % s ' % ( r_col , col , self . _digest ( r_table , table ) ) NEW_LINE output . append ( style . SQL_KEYWORD ( ' ALTER ▁ TABLE ' ) + ' ▁ % s ▁ ADD ▁ CONSTRAINT ▁ % s ▁ FOREIGN ▁ KEY ▁ ( % s ) ▁ REFERENCES ▁ % s ▁ ( % s ) % s ; ' % ( qn ( r_table ) , qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) , qn ( r_col ) , qn ( table ) , qn ( col ) , self . connection . ops . deferrable_sql ( ) ) ) NEW_LINE # ▁ Add ▁ any ▁ extra ▁ SQL ▁ needed ▁ to ▁ support ▁ auto - incrementing ▁ PKs ENDCOM DEDENT autoinc_sql = self . connection . ops . autoinc_sql ( f . m2m_db_table ( ) , ' id ' ) NEW_LINE if autoinc_sql : NEW_LINE INDENT for stmt in autoinc_sql : NEW_LINE INDENT output . append ( stmt ) NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT
def sql_for_inline_many_to_many_references ( self , model , field , style ) : NEW_LINE INDENT " Create ▁ the ▁ references ▁ to ▁ other ▁ tables ▁ required ▁ by ▁ a ▁ many - to - many ▁ table " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE from django . db import models NEW_LINE opts = model . _meta NEW_LINE qn = self . connection . ops . quote_name NEW_LINE table_output = [ ' ▁ ▁ ▁ ▁ % s ▁ % s ▁ % s ▁ % s ▁ ( % s ) % s , ' % ( style . SQL_FIELD ( qn ( field . m2m_column_name ( ) ) ) , style . SQL_COLTYPE ( models . ForeignKey ( model ) . db_type ( connection = self . connection ) ) , style . SQL_KEYWORD ( ' NOT ▁ NULL ▁ REFERENCES ' ) , style . SQL_TABLE ( qn ( opts . db_table ) ) , style . SQL_FIELD ( qn ( opts . pk . column ) ) , self . connection . ops . deferrable_sql ( ) ) , ' ▁ ▁ ▁ ▁ % s ▁ % s ▁ % s ▁ % s ▁ ( % s ) % s , ' % ( style . SQL_FIELD ( qn ( field . m2m_reverse_name ( ) ) ) , style . SQL_COLTYPE ( models . ForeignKey ( field . rel . to ) . db_type ( connection = self . connection ) ) , style . SQL_KEYWORD ( ' NOT ▁ NULL ▁ REFERENCES ' ) , style . SQL_TABLE ( qn ( field . rel . to . _meta . db_table ) ) , style . SQL_FIELD ( qn ( field . rel . to . _meta . pk . column ) ) , self . connection . ops . deferrable_sql ( ) ) ] NEW_LINE deferred = [ ] NEW_LINE return table_output , deferred NEW_LINE DEDENT
def sql_indexes_for_model ( self , model , style ) : NEW_LINE INDENT " Returns ▁ the ▁ CREATE ▁ INDEX ▁ SQL ▁ statements ▁ for ▁ a ▁ single ▁ model " NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE DEDENT output = [ ] NEW_LINE for f in model . _meta . local_fields : NEW_LINE INDENT output . extend ( self . sql_indexes_for_field ( model , f , style ) ) NEW_LINE DEDENT return output NEW_LINE DEDENT
def sql_indexes_for_field ( self , model , f , style ) : NEW_LINE INDENT " Return ▁ the ▁ CREATE ▁ INDEX ▁ SQL ▁ statements ▁ for ▁ a ▁ single ▁ model ▁ field " NEW_LINE from django . db . backends . util import truncate_name NEW_LINE if f . db_index and not f . unique : NEW_LINE INDENT qn = self . connection . ops . quote_name NEW_LINE tablespace = f . db_tablespace or model . _meta . db_tablespace NEW_LINE if tablespace : NEW_LINE INDENT sql = self . connection . ops . tablespace_sql ( tablespace ) NEW_LINE if sql : NEW_LINE INDENT tablespace_sql = ' ▁ ' + sql NEW_LINE DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT i_name = ' % s _ % s ' % ( model . _meta . db_table , self . _digest ( f . column ) ) NEW_LINE output = [ style . SQL_KEYWORD ( ' CREATE ▁ INDEX ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( truncate_name ( i_name , self . connection . ops . max_name_length ( ) ) ) ) + ' ▁ ' + style . SQL_KEYWORD ( ' ON ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( model . _meta . db_table ) ) + ' ▁ ' + " ( % s ) " % style . SQL_FIELD ( qn ( f . column ) ) + " % s ; " % tablespace_sql ] NEW_LINE DEDENT else : NEW_LINE INDENT output = [ ] NEW_LINE DEDENT return output NEW_LINE DEDENT
def sql_destroy_model ( self , model , references_to_delete , style ) : NEW_LINE INDENT " Return ▁ the ▁ DROP ▁ TABLE ▁ and ▁ restraint ▁ dropping ▁ statements ▁ for ▁ a ▁ single ▁ model " NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE # ▁ Drop ▁ the ▁ table ▁ now ENDCOM DEDENT qn = self . connection . ops . quote_name NEW_LINE output = [ ' % s ▁ % s ; ' % ( style . SQL_KEYWORD ( ' DROP ▁ TABLE ' ) , style . SQL_TABLE ( qn ( model . _meta . db_table ) ) ) ] NEW_LINE if model in references_to_delete : NEW_LINE INDENT output . extend ( self . sql_remove_table_constraints ( model , references_to_delete , style ) ) NEW_LINE DEDENT if model . _meta . has_auto_field : NEW_LINE INDENT ds = self . connection . ops . drop_sequence_sql ( model . _meta . db_table ) NEW_LINE if ds : NEW_LINE INDENT output . append ( ds ) NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
def sql_remove_table_constraints ( self , model , references_to_delete , style ) : NEW_LINE INDENT from django . db . backends . util import truncate_name NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE DEDENT output = [ ] NEW_LINE qn = self . connection . ops . quote_name NEW_LINE for rel_class , f in references_to_delete [ model ] : NEW_LINE INDENT table = rel_class . _meta . db_table NEW_LINE col = f . column NEW_LINE r_table = model . _meta . db_table NEW_LINE r_col = model . _meta . get_field ( f . rel . field_name ) . column NEW_LINE r_name = ' % s _ refs _ % s _ % s ' % ( col , r_col , self . _digest ( table , r_table ) ) NEW_LINE output . append ( ' % s ▁ % s ▁ % s ▁ % s ; ' % ( style . SQL_KEYWORD ( ' ALTER ▁ TABLE ' ) , style . SQL_TABLE ( qn ( table ) ) , style . SQL_KEYWORD ( self . connection . ops . drop_foreignkey_sql ( ) ) , style . SQL_FIELD ( qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) ) ) ) NEW_LINE DEDENT del references_to_delete [ model ] NEW_LINE return output NEW_LINE DEDENT
def sql_destroy_many_to_many ( self , model , f , style ) : NEW_LINE INDENT " Returns ▁ the ▁ DROP ▁ TABLE ▁ statements ▁ for ▁ a ▁ single ▁ m2m ▁ field " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE qn = self . connection . ops . quote_name NEW_LINE output = [ ] NEW_LINE if f . auto_created : NEW_LINE INDENT output . append ( " % s ▁ % s ; " % ( style . SQL_KEYWORD ( ' DROP ▁ TABLE ' ) , style . SQL_TABLE ( qn ( f . m2m_db_table ( ) ) ) ) ) NEW_LINE ds = self . connection . ops . drop_sequence_sql ( " % s _ % s " % ( model . _meta . db_table , f . column ) ) NEW_LINE if ds : NEW_LINE INDENT output . append ( ds ) NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
def _get_test_db_name ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Internal ▁ implementation ▁ - ▁ returns ▁ the ▁ name ▁ of ▁ the ▁ test ▁ DB ▁ that ▁ will ▁ be STRNEWLINE ▁ created . ▁ Only ▁ useful ▁ when ▁ called ▁ from ▁ create _ test _ db ( ) ▁ and STRNEWLINE ▁ _ create _ test _ db ( ) ▁ and ▁ when ▁ no ▁ external ▁ munging ▁ is ▁ done ▁ with ▁ the ▁ ' NAME ' STRNEWLINE ▁ or ▁ ' TEST _ NAME ' ▁ settings . STRNEWLINE ▁ """ NEW_LINE if self . connection . settings_dict [ ' TEST _ NAME ' ] : NEW_LINE INDENT return self . connection . settings_dict [ ' TEST _ NAME ' ] NEW_LINE DEDENT return TEST_DATABASE_PREFIX + self . connection . settings_dict [ ' NAME ' ] NEW_LINE DEDENT
def _destroy_test_db ( self , test_database_name , verbosity ) : NEW_LINE INDENT " Internal ▁ implementation ▁ - ▁ remove ▁ the ▁ test ▁ db ▁ tables . " NEW_LINE # ▁ Remove ▁ the ▁ test ▁ database ▁ to ▁ clean ▁ up ▁ after ENDCOM # ▁ ourselves . ▁ Connect ▁ to ▁ the ▁ previous ▁ database ▁ ( not ▁ the ▁ test ▁ database ) ENDCOM # ▁ to ▁ do ▁ so , ▁ because ▁ it ' s ▁ not ▁ allowed ▁ to ▁ delete ▁ a ▁ database ▁ while ▁ being ENDCOM # ▁ connected ▁ to ▁ it . ENDCOM cursor = self . connection . cursor ( ) NEW_LINE self . set_autocommit ( ) NEW_LINE time . sleep ( 1 ) # ▁ To ▁ avoid ▁ " database ▁ is ▁ being ▁ accessed ▁ by ▁ other ▁ users " ▁ errors . ENDCOM NEW_LINE cursor . execute ( " DROP ▁ DATABASE ▁ % s " % self . connection . ops . quote_name ( test_database_name ) ) NEW_LINE self . connection . close ( ) NEW_LINE DEDENT
def set_autocommit ( self ) : NEW_LINE INDENT " Make ▁ sure ▁ a ▁ connection ▁ is ▁ in ▁ autocommit ▁ mode . " NEW_LINE if hasattr ( self . connection . connection , " autocommit " ) : NEW_LINE INDENT if callable ( self . connection . connection . autocommit ) : NEW_LINE INDENT self . connection . connection . autocommit ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . connection . connection . autocommit = True NEW_LINE DEDENT DEDENT elif hasattr ( self . connection . connection , " set _ isolation _ level " ) : NEW_LINE INDENT self . connection . connection . set_isolation_level ( 0 ) NEW_LINE DEDENT DEDENT
def sql_table_creation_suffix ( self ) : NEW_LINE INDENT " SQL ▁ to ▁ append ▁ to ▁ the ▁ end ▁ of ▁ the ▁ test ▁ table ▁ creation ▁ statements " NEW_LINE return ' ' NEW_LINE DEDENT
def test_db_signature ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ a ▁ tuple ▁ with ▁ elements ▁ of ▁ self . connection . settings _ dict ▁ ( a STRNEWLINE ▁ DATABASES ▁ setting ▁ value ) ▁ that ▁ uniquely ▁ identify ▁ a ▁ database STRNEWLINE ▁ accordingly ▁ to ▁ the ▁ RDBMS ▁ particularities . STRNEWLINE ▁ """ NEW_LINE settings_dict = self . connection . settings_dict NEW_LINE return ( settings_dict [ ' HOST ' ] , settings_dict [ ' PORT ' ] , settings_dict [ ' ENGINE ' ] , settings_dict [ ' NAME ' ] ) NEW_LINE DEDENT
