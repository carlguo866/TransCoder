<DOCUMENT_ID="wsmith323/django/tree/master/tests/save_delete_hooks/tests.py"> from __future__ import unicode_literals NEW_LINE from django . test import TestCase NEW_LINE from django . utils import six NEW_LINE from . models import Person NEW_LINE class SaveDeleteHookTests ( TestCase ) : NEW_LINE INDENT def test_basic ( self ) : NEW_LINE INDENT p = Person ( first_name = " John " , last_name = " Smith " ) NEW_LINE self . assertEqual ( p . data , [ ] ) NEW_LINE p . save ( ) NEW_LINE self . assertEqual ( p . data , [ " Before ▁ save " , " After ▁ save " , ] ) NEW_LINE self . assertQuerysetEqual ( Person . objects . all ( ) , [ " John ▁ Smith " , ] , six . text_type ) NEW_LINE p . delete ( ) NEW_LINE self . assertEqual ( p . data , [ " Before ▁ save " , " After ▁ save " , " Before ▁ deletion " , " After ▁ deletion " , ] ) NEW_LINE self . assertQuerysetEqual ( Person . objects . all ( ) , [ ] ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="dssg/wikienergy/tree/master/disaggregator/build/pandas/pandas/io/tests/__init__.py"> def setUp ( ) : NEW_LINE INDENT import socket NEW_LINE socket . setdefaulttimeout ( 5 ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="shsingh/ansible/tree/master/lib/ansible/modules/cloud/azure/azure_rm_securitygroup.py"> # ! / usr / bin / python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2016 ▁ Matt ▁ Davis , ▁ < mdavis @ ansible . com > ENDCOM # ▁ Chris ▁ Houseknecht , ▁ < house @ redhat . com > ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ v3.0 + ▁ ( see ▁ COPYING ▁ or ▁ https : / / www . gnu . org / licenses / gpl - 3.0 . txt ) ENDCOM from __future__ import absolute_import , division , print_function NEW_LINE __metaclass__ = type NEW_LINE ANSIBLE_METADATA = { ' metadata _ version ' : '1.1' , ' status ' : [ ' preview ' ] , ' supported _ by ' : ' community ' } NEW_LINE DOCUMENTATION = ''' STRNEWLINE - - - STRNEWLINE module : ▁ azure _ rm _ securitygroup STRNEWLINE version _ added : ▁ " 2.1 " STRNEWLINE short _ description : ▁ Manage ▁ Azure ▁ network ▁ security ▁ groups . STRNEWLINE description : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ Create , ▁ update ▁ or ▁ delete ▁ a ▁ network ▁ security ▁ group . ▁ A ▁ security ▁ group ▁ contains ▁ Access ▁ Control ▁ List ▁ ( ACL ) ▁ rules STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ that ▁ allow ▁ or ▁ deny ▁ network ▁ traffic ▁ to ▁ subnets ▁ or ▁ individual ▁ network ▁ interfaces . ▁ A ▁ security ▁ group ▁ is ▁ created STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ with ▁ a ▁ set ▁ of ▁ default ▁ security ▁ rules ▁ and ▁ an ▁ empty ▁ set ▁ of ▁ security ▁ rules . ▁ Shape ▁ traffic ▁ flow ▁ by ▁ adding STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ rules ▁ to ▁ the ▁ empty ▁ set ▁ of ▁ security ▁ rules . STRNEWLINE STRNEWLINE options : STRNEWLINE ▁ ▁ ▁ ▁ default _ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ set ▁ of ▁ default ▁ rules ▁ automatically ▁ added ▁ to ▁ a ▁ security ▁ group ▁ at ▁ creation . ▁ In ▁ general ▁ default STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ rules ▁ will ▁ not ▁ be ▁ modified . ▁ Modify ▁ rules ▁ to ▁ shape ▁ the ▁ flow ▁ of ▁ traffic ▁ to ▁ or ▁ from ▁ a ▁ subnet ▁ or ▁ NIC . ▁ See STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ rules ▁ below ▁ for ▁ the ▁ makeup ▁ of ▁ a ▁ rule ▁ dict . STRNEWLINE ▁ ▁ ▁ ▁ location : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Valid ▁ azure ▁ location . ▁ Defaults ▁ to ▁ location ▁ of ▁ the ▁ resource ▁ group . STRNEWLINE ▁ ▁ ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Name ▁ of ▁ the ▁ security ▁ group ▁ to ▁ operate ▁ on . STRNEWLINE ▁ ▁ ▁ ▁ purge _ default _ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Remove ▁ any ▁ existing ▁ rules ▁ not ▁ matching ▁ those ▁ defined ▁ in ▁ the ▁ default _ rules ▁ parameter . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' no ' STRNEWLINE ▁ ▁ ▁ ▁ purge _ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Remove ▁ any ▁ existing ▁ rules ▁ not ▁ matching ▁ those ▁ defined ▁ in ▁ the ▁ rules ▁ parameters . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' no ' STRNEWLINE ▁ ▁ ▁ ▁ resource _ group : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Name ▁ of ▁ the ▁ resource ▁ group ▁ the ▁ security ▁ group ▁ belongs ▁ to . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Set ▁ of ▁ rules ▁ shaping ▁ traffic ▁ flow ▁ to ▁ or ▁ from ▁ a ▁ subnet ▁ or ▁ NIC . ▁ Each ▁ rule ▁ is ▁ a ▁ dictionary . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ suboptions : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Unique ▁ name ▁ for ▁ the ▁ rule . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Short ▁ description ▁ of ▁ the ▁ rule ' s ▁ purpose . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : ▁ Accepted ▁ traffic ▁ protocol . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Udp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ port _ range : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Port ▁ or ▁ range ▁ of ▁ ports ▁ from ▁ which ▁ traffic ▁ originates . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Port ▁ or ▁ range ▁ of ▁ ports ▁ to ▁ which ▁ traffic ▁ is ▁ headed . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ CIDR ▁ or ▁ source ▁ IP ▁ range . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Asterisk ▁ C ( * ) ▁ can ▁ also ▁ be ▁ used ▁ to ▁ match ▁ all ▁ source ▁ IPs . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Default ▁ tags ▁ such ▁ as ▁ C ( VirtualNetwork ) , ▁ C ( AzureLoadBalancer ) ▁ and ▁ C ( Internet ) ▁ can ▁ also ▁ be ▁ used . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ If ▁ this ▁ is ▁ an ▁ ingress ▁ rule , ▁ specifies ▁ where ▁ network ▁ traffic ▁ originates ▁ from . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ destination ▁ address ▁ prefix . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ CIDR ▁ or ▁ destination ▁ IP ▁ range . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Asterisk ▁ C ( * ) ▁ can ▁ also ▁ be ▁ used ▁ to ▁ match ▁ all ▁ source ▁ IPs . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Default ▁ tags ▁ such ▁ as ▁ C ( VirtualNetwork ) , ▁ C ( AzureLoadBalancer ) ▁ and ▁ C ( Internet ) ▁ can ▁ also ▁ be ▁ used . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Whether ▁ or ▁ not ▁ to ▁ allow ▁ the ▁ traffic ▁ flow . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Deny STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Order ▁ in ▁ which ▁ to ▁ apply ▁ the ▁ rule . ▁ Must ▁ a ▁ unique ▁ integer ▁ between ▁ 100 ▁ and ▁ 4096 ▁ inclusive . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Indicates ▁ the ▁ direction ▁ of ▁ the ▁ traffic ▁ flow . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Outbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Assert ▁ the ▁ state ▁ of ▁ the ▁ security ▁ group . ▁ Set ▁ to ▁ C ( present ) ▁ to ▁ create ▁ or ▁ update ▁ a ▁ security ▁ group . ▁ Set ▁ to STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ C ( absent ) ▁ to ▁ remove ▁ a ▁ security ▁ group . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ present STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ absent STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ present STRNEWLINE STRNEWLINE extends _ documentation _ fragment : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ azure STRNEWLINE ▁ ▁ ▁ ▁ - ▁ azure _ tags STRNEWLINE STRNEWLINE author : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Chris ▁ Houseknecht ▁ ( @ chouseknecht ) " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Matt ▁ Davis ▁ ( @ nitzmahone ) " STRNEWLINE STRNEWLINE ''' NEW_LINE EXAMPLES = ''' STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ security ▁ group STRNEWLINE - ▁ azure _ rm _ securitygroup : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ resource _ group : ▁ myResourceGroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ mysecgroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ purge _ rules : ▁ yes STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ DenySSH STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Deny STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 100 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ ' AllowSSH ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.158.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.159.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 101 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ ' AllowMultiplePorts ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.158.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.159.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ 80 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ 443 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 102 STRNEWLINE STRNEWLINE # ▁ Update ▁ rules ▁ on ▁ existing ▁ security ▁ group STRNEWLINE - ▁ azure _ rm _ securitygroup : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ resource _ group : ▁ myResourceGroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ mysecgroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ DenySSH STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22-23 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Deny STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 100 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ AllowSSHFromHome STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : ▁ ' 174.109.158.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22-23 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 102 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ tags : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ testing : ▁ testing STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ delete : ▁ on - exit STRNEWLINE STRNEWLINE # ▁ Delete ▁ security ▁ group STRNEWLINE - ▁ azure _ rm _ securitygroup : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ resource _ group : ▁ myResourceGroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ mysecgroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ state : ▁ absent STRNEWLINE ''' NEW_LINE RETURN = ''' STRNEWLINE state : STRNEWLINE ▁ ▁ ▁ ▁ description : ▁ Current ▁ state ▁ of ▁ the ▁ security ▁ group . STRNEWLINE ▁ ▁ ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ dict STRNEWLINE ▁ ▁ ▁ ▁ sample : ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " default _ rules " : ▁ [ STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ inbound ▁ traffic ▁ from ▁ all ▁ VMs ▁ in ▁ VNET " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowVnetInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowVnetInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65000 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ inbound ▁ traffic ▁ from ▁ azure ▁ load ▁ balancer " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowAzureLoadBalancerInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowAzureLoadBalancerInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65001 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " AzureLoadBalancer " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Deny " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Deny ▁ all ▁ inbound ▁ traffic " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / DenyAllInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " DenyAllInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65500 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ outbound ▁ traffic ▁ from ▁ all ▁ VMs ▁ to ▁ all ▁ VMs ▁ in ▁ VNET " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Outbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowVnetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowVnetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65000 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ outbound ▁ traffic ▁ from ▁ all ▁ VMs ▁ to ▁ Internet " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " Internet " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Outbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowInternetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowInternetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65001 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Deny " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Deny ▁ all ▁ outbound ▁ traffic " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Outbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / DenyAllOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " DenyAllOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65500 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " location " : ▁ " westus " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " mysecgroup " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " network _ interfaces " : ▁ [ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " rules " : ▁ [ STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Deny " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ null , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " 22 " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / securityRules / DenySSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " DenySSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 100 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " Tcp " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ null , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " 22 " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / securityRules / AllowSSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowSSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 101 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " Tcp " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " 174.109.158.0/24 " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " subnets " : ▁ [ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " tags " : ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " delete " : ▁ " on - exit " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " foo " : ▁ " bar " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " testing " : ▁ " testing " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " type " : ▁ " Microsoft . Network / networkSecurityGroups " STRNEWLINE ▁ ▁ ▁ ▁ } STRNEWLINE ''' # ▁ NOQA ENDCOM NEW_LINE try : NEW_LINE INDENT from msrestazure . azure_exceptions import CloudError NEW_LINE from azure . mgmt . network import NetworkManagementClient NEW_LINE DEDENT except ImportError : NEW_LINE # ▁ This ▁ is ▁ handled ▁ in ▁ azure _ rm _ common ENDCOM INDENT pass NEW_LINE DEDENT from ansible . module_utils . azure_rm_common import AzureRMModuleBase NEW_LINE from ansible . module_utils . six import integer_types NEW_LINE from ansible . module_utils . _text import to_native NEW_LINE def validate_rule ( self , rule , rule_type = None ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Apply ▁ defaults ▁ to ▁ a ▁ rule ▁ dictionary ▁ and ▁ check ▁ that ▁ all ▁ values ▁ are ▁ valid . STRNEWLINE STRNEWLINE ▁ : param ▁ rule : ▁ rule ▁ dict STRNEWLINE ▁ : param ▁ rule _ type : ▁ Set ▁ to ▁ ' default ' ▁ if ▁ the ▁ rule ▁ is ▁ part ▁ of ▁ the ▁ default ▁ set ▁ of ▁ rules . STRNEWLINE ▁ : return : ▁ None STRNEWLINE ▁ ''' NEW_LINE priority = rule . get ( ' priority ' , 0 ) NEW_LINE if rule_type != ' default ' and ( priority < 100 or priority > 4096 ) : NEW_LINE INDENT raise Exception ( " Rule ▁ priority ▁ must ▁ be ▁ between ▁ 100 ▁ and ▁ 4096" ) NEW_LINE DEDENT def check_plural ( src , dest ) : NEW_LINE INDENT if isinstance ( rule . get ( src ) , list ) : NEW_LINE INDENT rule [ dest ] = rule [ src ] NEW_LINE rule [ src ] = None NEW_LINE DEDENT DEDENT check_plural ( ' destination _ address _ prefix ' , ' destination _ address _ prefixes ' ) NEW_LINE check_plural ( ' source _ address _ prefix ' , ' source _ address _ prefixes ' ) NEW_LINE check_plural ( ' source _ port _ range ' , ' source _ port _ ranges ' ) NEW_LINE check_plural ( ' destination _ port _ range ' , ' destination _ port _ ranges ' ) NEW_LINE DEDENT def compare_rules_change ( old_list , new_list , purge_list ) : NEW_LINE INDENT old_list = old_list or [ ] NEW_LINE new_list = new_list or [ ] NEW_LINE changed = False NEW_LINE for old_rule in old_list : NEW_LINE INDENT matched = next ( ( x for x in new_list if x [ ' name ' ] == old_rule [ ' name ' ] ) , [ ] ) NEW_LINE if matched : # ▁ if ▁ the ▁ new ▁ one ▁ is ▁ in ▁ the ▁ old ▁ list , ▁ check ▁ whether ▁ it ▁ is ▁ updated ENDCOM NEW_LINE INDENT changed = changed or compare_rules ( old_rule , matched ) NEW_LINE DEDENT elif not purge_list : # ▁ keep ▁ this ▁ rule ENDCOM NEW_LINE INDENT new_list . append ( old_rule ) NEW_LINE DEDENT else : # ▁ one ▁ rule ▁ is ▁ removed ENDCOM NEW_LINE INDENT changed = True NEW_LINE # ▁ Compare ▁ new ▁ list ▁ and ▁ old ▁ list ▁ is ▁ the ▁ same ? ▁ here ▁ only ▁ compare ▁ names ENDCOM DEDENT DEDENT if not changed : NEW_LINE INDENT new_names = [ to_native ( x [ ' name ' ] ) for x in new_list ] NEW_LINE old_names = [ to_native ( x [ ' name ' ] ) for x in old_list ] NEW_LINE changed = ( set ( new_names ) != set ( old_names ) ) NEW_LINE DEDENT return changed , new_list NEW_LINE DEDENT def compare_rules ( old_rule , rule ) : NEW_LINE INDENT changed = False NEW_LINE if old_rule [ ' name ' ] != rule [ ' name ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule . get ( ' description ' , None ) != old_rule [ ' description ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' protocol ' ] != old_rule [ ' protocol ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' source _ port _ range ' ] ) != str ( old_rule [ ' source _ port _ range ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' destination _ port _ range ' ] ) != str ( old_rule [ ' destination _ port _ range ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' access ' ] != old_rule [ ' access ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' priority ' ] != old_rule [ ' priority ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' direction ' ] != old_rule [ ' direction ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' source _ address _ prefix ' ] ) != str ( old_rule [ ' source _ address _ prefix ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' destination _ address _ prefix ' ] ) != str ( old_rule [ ' destination _ address _ prefix ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' source _ address _ prefixes ' ) or [ ] ) != set ( old_rule . get ( ' source _ address _ prefixes ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' destination _ address _ prefixes ' ) or [ ] ) != set ( old_rule . get ( ' destination _ address _ prefixes ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' source _ port _ ranges ' ) or [ ] ) != set ( old_rule . get ( ' source _ port _ ranges ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' destination _ port _ ranges ' ) or [ ] ) != set ( old_rule . get ( ' destination _ port _ ranges ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT return changed NEW_LINE DEDENT def create_rule_instance ( self , rule ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Create ▁ an ▁ instance ▁ of ▁ SecurityRule ▁ from ▁ a ▁ dict . STRNEWLINE STRNEWLINE ▁ : param ▁ rule : ▁ dict STRNEWLINE ▁ : return : ▁ SecurityRule STRNEWLINE ▁ ''' NEW_LINE return self . nsg_models . SecurityRule ( description = rule . get ( ' description ' , None ) , protocol = rule . get ( ' protocol ' , None ) , source_port_range = rule . get ( ' source _ port _ range ' , None ) , destination_port_range = rule . get ( ' destination _ port _ range ' , None ) , source_address_prefix = rule . get ( ' source _ address _ prefix ' , None ) , source_address_prefixes = rule . get ( ' source _ address _ prefixes ' , None ) , destination_address_prefix = rule . get ( ' destination _ address _ prefix ' , None ) , destination_address_prefixes = rule . get ( ' destination _ address _ prefixes ' , None ) , source_port_ranges = rule . get ( ' source _ port _ ranges ' , None ) , destination_port_ranges = rule . get ( ' destination _ port _ ranges ' , None ) , access = rule . get ( ' access ' , None ) , priority = rule . get ( ' priority ' , None ) , direction = rule . get ( ' direction ' , None ) , provisioning_state = rule . get ( ' provisioning _ state ' , None ) , name = rule . get ( ' name ' , None ) , etag = rule . get ( ' etag ' , None ) ) NEW_LINE DEDENT def create_rule_dict_from_obj ( rule ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Create ▁ a ▁ dict ▁ from ▁ an ▁ instance ▁ of ▁ a ▁ SecurityRule . STRNEWLINE STRNEWLINE ▁ : param ▁ rule : ▁ SecurityRule STRNEWLINE ▁ : return : ▁ dict STRNEWLINE ▁ ''' NEW_LINE return dict ( id = rule . id , name = rule . name , description = rule . description , protocol = rule . protocol , source_port_range = rule . source_port_range , destination_port_range = rule . destination_port_range , source_address_prefix = rule . source_address_prefix , destination_address_prefix = rule . destination_address_prefix , source_port_ranges = rule . source_port_ranges , destination_port_ranges = rule . destination_port_ranges , source_address_prefixes = rule . source_address_prefixes , destination_address_prefixes = rule . destination_address_prefixes , access = rule . access , priority = rule . priority , direction = rule . direction , provisioning_state = rule . provisioning_state , etag = rule . etag ) NEW_LINE DEDENT def create_network_security_group_dict ( nsg ) : NEW_LINE INDENT results = dict ( id = nsg . id , name = nsg . name , type = nsg . type , location = nsg . location , tags = nsg . tags , ) NEW_LINE results [ ' rules ' ] = [ ] NEW_LINE if nsg . security_rules : NEW_LINE INDENT for rule in nsg . security_rules : NEW_LINE INDENT results [ ' rules ' ] . append ( create_rule_dict_from_obj ( rule ) ) NEW_LINE DEDENT DEDENT results [ ' default _ rules ' ] = [ ] NEW_LINE if nsg . default_security_rules : NEW_LINE INDENT for rule in nsg . default_security_rules : NEW_LINE INDENT results [ ' default _ rules ' ] . append ( create_rule_dict_from_obj ( rule ) ) NEW_LINE DEDENT DEDENT results [ ' network _ interfaces ' ] = [ ] NEW_LINE if nsg . network_interfaces : NEW_LINE INDENT for interface in nsg . network_interfaces : NEW_LINE INDENT results [ ' network _ interfaces ' ] . append ( interface . id ) NEW_LINE DEDENT DEDENT results [ ' subnets ' ] = [ ] NEW_LINE if nsg . subnets : NEW_LINE INDENT for subnet in nsg . subnets : NEW_LINE INDENT results [ ' subnets ' ] . append ( subnet . id ) NEW_LINE DEDENT DEDENT return results NEW_LINE DEDENT rule_spec = dict ( name = dict ( type = ' str ' , required = True ) , description = dict ( type = ' str ' ) , protocol = dict ( type = ' str ' , choices = [ ' Udp ' , ' Tcp ' , ' * ' ] , default = ' * ' ) , source_port_range = dict ( type = ' raw ' , default = ' * ' ) , destination_port_range = dict ( type = ' raw ' , default = ' * ' ) , source_address_prefix = dict ( type = ' raw ' , default = ' * ' ) , destination_address_prefix = dict ( type = ' raw ' , default = ' * ' ) , access = dict ( type = ' str ' , choices = [ ' Allow ' , ' Deny ' ] , default = ' Allow ' ) , priority = dict ( type = ' int ' , required = True ) , direction = dict ( type = ' str ' , choices = [ ' Inbound ' , ' Outbound ' ] , default = ' Inbound ' ) ) NEW_LINE class AzureRMSecurityGroup ( AzureRMModuleBase ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . module_arg_spec = dict ( default_rules = dict ( type = ' list ' , elements = ' dict ' , options = rule_spec ) , location = dict ( type = ' str ' ) , name = dict ( type = ' str ' , required = True ) , purge_default_rules = dict ( type = ' bool ' , default = False ) , purge_rules = dict ( type = ' bool ' , default = False ) , resource_group = dict ( required = True , type = ' str ' ) , rules = dict ( type = ' list ' , elements = ' dict ' , options = rule_spec ) , state = dict ( type = ' str ' , default = ' present ' , choices = [ ' present ' , ' absent ' ] ) , ) NEW_LINE self . default_rules = None NEW_LINE self . location = None NEW_LINE self . name = None NEW_LINE self . purge_default_rules = None NEW_LINE self . purge_rules = None NEW_LINE self . resource_group = None NEW_LINE self . rules = None NEW_LINE self . state = None NEW_LINE self . tags = None NEW_LINE self . nsg_models = None # ▁ type : ▁ azure . mgmt . network . models ENDCOM NEW_LINE self . results = dict ( changed = False , state = dict ( ) ) NEW_LINE super ( AzureRMSecurityGroup , self ) . __init__ ( self . module_arg_spec , supports_check_mode = True ) NEW_LINE DEDENT def exec_module ( self , ** kwargs ) : NEW_LINE # ▁ tighten ▁ up ▁ poll ▁ interval ▁ for ▁ security ▁ groups ; ▁ default ▁ 30s ▁ is ▁ an ▁ eternity ENDCOM # ▁ this ▁ value ▁ is ▁ still ▁ overridden ▁ by ▁ the ▁ response ▁ Retry - After ▁ header ▁ ( which ▁ is ▁ set ▁ on ▁ the ▁ initial ▁ operation ▁ response ▁ to ▁ 10s ) ENDCOM INDENT self . network_client . config . long_running_operation_timeout = 3 NEW_LINE self . nsg_models = self . network_client . network_security_groups . models NEW_LINE for key in list ( self . module_arg_spec . keys ( ) ) + [ ' tags ' ] : NEW_LINE INDENT setattr ( self , key , kwargs [ key ] ) NEW_LINE DEDENT changed = False NEW_LINE results = dict ( ) NEW_LINE resource_group = self . get_resource_group ( self . resource_group ) NEW_LINE if not self . location : NEW_LINE # ▁ Set ▁ default ▁ location ENDCOM INDENT self . location = resource_group . location NEW_LINE DEDENT if self . rules : NEW_LINE INDENT for rule in self . rules : NEW_LINE INDENT try : NEW_LINE INDENT validate_rule ( self , rule ) NEW_LINE DEDENT except Exception as exc : NEW_LINE INDENT self . fail ( " Error ▁ validating ▁ rule ▁ { 0 } ▁ - ▁ { 1 } " . format ( rule , str ( exc ) ) ) NEW_LINE DEDENT DEDENT DEDENT if self . default_rules : NEW_LINE INDENT for rule in self . default_rules : NEW_LINE INDENT try : NEW_LINE INDENT validate_rule ( self , rule , ' default ' ) NEW_LINE DEDENT except Exception as exc : NEW_LINE INDENT self . fail ( " Error ▁ validating ▁ default ▁ rule ▁ { 0 } ▁ - ▁ { 1 } " . format ( rule , str ( exc ) ) ) NEW_LINE DEDENT DEDENT DEDENT try : NEW_LINE INDENT nsg = self . network_client . network_security_groups . get ( self . resource_group , self . name ) NEW_LINE results = create_network_security_group_dict ( nsg ) NEW_LINE self . log ( " Found ▁ security ▁ group : " ) NEW_LINE self . log ( results , pretty_print = True ) NEW_LINE self . check_provisioning_state ( nsg , self . state ) NEW_LINE if self . state == ' present ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif self . state == ' absent ' : NEW_LINE INDENT self . log ( " CHANGED : ▁ security ▁ group ▁ found ▁ but ▁ state ▁ is ▁ ' absent ' " ) NEW_LINE changed = True NEW_LINE DEDENT DEDENT except CloudError : # ▁ TODO : ▁ actually ▁ check ▁ for ▁ ResourceMissingError ENDCOM NEW_LINE INDENT if self . state == ' present ' : NEW_LINE INDENT self . log ( " CHANGED : ▁ security ▁ group ▁ not ▁ found ▁ and ▁ state ▁ is ▁ ' present ' " ) NEW_LINE changed = True NEW_LINE DEDENT DEDENT if self . state == ' present ' and not changed : NEW_LINE # ▁ update ▁ the ▁ security ▁ group ENDCOM INDENT self . log ( " Update ▁ security ▁ group ▁ { 0 } " . format ( self . name ) ) NEW_LINE update_tags , results [ ' tags ' ] = self . update_tags ( results [ ' tags ' ] ) NEW_LINE if update_tags : NEW_LINE INDENT changed = True NEW_LINE DEDENT rule_changed , new_rule = compare_rules_change ( results [ ' rules ' ] , self . rules , self . purge_rules ) NEW_LINE if rule_changed : NEW_LINE INDENT changed = True NEW_LINE results [ ' rules ' ] = new_rule NEW_LINE DEDENT rule_changed , new_rule = compare_rules_change ( results [ ' default _ rules ' ] , self . default_rules , self . purge_default_rules ) NEW_LINE if rule_changed : NEW_LINE INDENT changed = True NEW_LINE results [ ' default _ rules ' ] = new_rule NEW_LINE DEDENT self . results [ ' changed ' ] = changed NEW_LINE self . results [ ' state ' ] = results NEW_LINE if not self . check_mode and changed : NEW_LINE INDENT self . results [ ' state ' ] = self . create_or_update ( results ) NEW_LINE DEDENT DEDENT elif self . state == ' present ' and changed : NEW_LINE # ▁ create ▁ the ▁ security ▁ group ENDCOM INDENT self . log ( " Create ▁ security ▁ group ▁ { 0 } " . format ( self . name ) ) NEW_LINE if not self . location : NEW_LINE INDENT self . fail ( " Parameter ▁ error : ▁ location ▁ required ▁ when ▁ creating ▁ a ▁ security ▁ group . " ) NEW_LINE DEDENT results [ ' name ' ] = self . name NEW_LINE results [ ' location ' ] = self . location NEW_LINE results [ ' rules ' ] = [ ] NEW_LINE results [ ' default _ rules ' ] = [ ] NEW_LINE results [ ' tags ' ] = { } NEW_LINE if self . rules : NEW_LINE INDENT results [ ' rules ' ] = self . rules NEW_LINE DEDENT if self . default_rules : NEW_LINE INDENT results [ ' default _ rules ' ] = self . default_rules NEW_LINE DEDENT if self . tags : NEW_LINE INDENT results [ ' tags ' ] = self . tags NEW_LINE DEDENT self . results [ ' changed ' ] = changed NEW_LINE self . results [ ' state ' ] = results NEW_LINE if not self . check_mode : NEW_LINE INDENT self . results [ ' state ' ] = self . create_or_update ( results ) NEW_LINE DEDENT DEDENT elif self . state == ' absent ' and changed : NEW_LINE INDENT self . log ( " Delete ▁ security ▁ group ▁ { 0 } " . format ( self . name ) ) NEW_LINE self . results [ ' changed ' ] = changed NEW_LINE self . results [ ' state ' ] = dict ( ) NEW_LINE if not self . check_mode : NEW_LINE INDENT self . delete ( ) NEW_LINE # ▁ the ▁ delete ▁ does ▁ not ▁ actually ▁ return ▁ anything . ▁ if ▁ no ▁ exception , ▁ then ▁ we ' ll ▁ assume ENDCOM # ▁ it ▁ worked . ENDCOM self . results [ ' state ' ] [ ' status ' ] = ' Deleted ' NEW_LINE DEDENT DEDENT return self . results NEW_LINE DEDENT def create_or_update ( self , results ) : NEW_LINE INDENT parameters = self . nsg_models . NetworkSecurityGroup ( ) NEW_LINE if results . get ( ' rules ' ) : NEW_LINE INDENT parameters . security_rules = [ ] NEW_LINE for rule in results . get ( ' rules ' ) : NEW_LINE INDENT parameters . security_rules . append ( create_rule_instance ( self , rule ) ) NEW_LINE DEDENT DEDENT if results . get ( ' default _ rules ' ) : NEW_LINE INDENT parameters . default_security_rules = [ ] NEW_LINE for rule in results . get ( ' default _ rules ' ) : NEW_LINE INDENT parameters . default_security_rules . append ( create_rule_instance ( self , rule ) ) NEW_LINE DEDENT DEDENT parameters . tags = results . get ( ' tags ' ) NEW_LINE parameters . location = results . get ( ' location ' ) NEW_LINE try : NEW_LINE INDENT poller = self . network_client . network_security_groups . create_or_update ( resource_group_name = self . resource_group , network_security_group_name = self . name , parameters = parameters ) NEW_LINE result = self . get_poller_result ( poller ) NEW_LINE DEDENT except CloudError as exc : NEW_LINE INDENT self . fail ( " Error ▁ creating / updating ▁ security ▁ group ▁ { 0 } ▁ - ▁ { 1 } " . format ( self . name , str ( exc ) ) ) NEW_LINE DEDENT return create_network_security_group_dict ( result ) NEW_LINE DEDENT def delete ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT poller = self . network_client . network_security_groups . delete ( resource_group_name = self . resource_group , network_security_group_name = self . name ) NEW_LINE result = self . get_poller_result ( poller ) NEW_LINE DEDENT except CloudError as exc : NEW_LINE INDENT raise Exception ( " Error ▁ deleting ▁ security ▁ group ▁ { 0 } ▁ - ▁ { 1 } " . format ( self . name , str ( exc ) ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT AzureRMSecurityGroup ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="apocquet/django/tree/master/django/contrib/gis/db/models/sql/conversion.py"> """ STRNEWLINE This ▁ module ▁ holds ▁ simple ▁ classes ▁ to ▁ convert ▁ geospatial ▁ values ▁ from ▁ the STRNEWLINE database . STRNEWLINE """ NEW_LINE from django . contrib . gis . db . models . fields import GeoSelectFormatMixin NEW_LINE from django . contrib . gis . geometry . backend import Geometry NEW_LINE from django . contrib . gis . measure import Area , Distance NEW_LINE class BaseField ( object ) : NEW_LINE INDENT empty_strings_allowed = True NEW_LINE def get_db_converters ( self , connection ) : NEW_LINE INDENT return [ self . from_db_value ] NEW_LINE DEDENT def select_format ( self , compiler , sql , params ) : NEW_LINE INDENT return sql , params NEW_LINE DEDENT DEDENT class AreaField ( BaseField ) : NEW_LINE INDENT " Wrapper ▁ for ▁ Area ▁ values . " NEW_LINE def __init__ ( self , area_att ) : NEW_LINE INDENT self . area_att = area_att NEW_LINE DEDENT def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT if value is not None : NEW_LINE INDENT value = Area ( ** { self . area_att : value } ) NEW_LINE DEDENT return value NEW_LINE DEDENT def get_internal_type ( self ) : NEW_LINE INDENT return ' AreaField ' NEW_LINE DEDENT DEDENT class DistanceField ( BaseField ) : NEW_LINE INDENT " Wrapper ▁ for ▁ Distance ▁ values . " NEW_LINE def __init__ ( self , distance_att ) : NEW_LINE INDENT self . distance_att = distance_att NEW_LINE DEDENT def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT if value is not None : NEW_LINE INDENT value = Distance ( ** { self . distance_att : value } ) NEW_LINE DEDENT return value NEW_LINE DEDENT def get_internal_type ( self ) : NEW_LINE INDENT return ' DistanceField ' NEW_LINE DEDENT DEDENT class GeomField ( GeoSelectFormatMixin , BaseField ) : NEW_LINE INDENT """ STRNEWLINE ▁ Wrapper ▁ for ▁ Geometry ▁ values . ▁ It ▁ is ▁ a ▁ lightweight ▁ alternative ▁ to STRNEWLINE ▁ using ▁ GeometryField ▁ ( which ▁ requires ▁ an ▁ SQL ▁ query ▁ upon ▁ instantiation ) . STRNEWLINE ▁ """ NEW_LINE # ▁ Hacky ▁ marker ▁ for ▁ get _ db _ converters ( ) ENDCOM geom_type = None NEW_LINE def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT if value is not None : NEW_LINE INDENT value = Geometry ( value ) NEW_LINE DEDENT return value NEW_LINE DEDENT def get_internal_type ( self ) : NEW_LINE INDENT return ' GeometryField ' NEW_LINE DEDENT DEDENT class GMLField ( BaseField ) : NEW_LINE INDENT """ STRNEWLINE ▁ Wrapper ▁ for ▁ GML ▁ to ▁ be ▁ used ▁ by ▁ Oracle ▁ to ▁ ensure ▁ Database . LOB ▁ conversion . STRNEWLINE ▁ """ NEW_LINE def get_internal_type ( self ) : NEW_LINE INDENT return ' GMLField ' NEW_LINE DEDENT def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT return value NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="soulxu/libvirt-xuhj/tree/master/src/esx/esx_vi_generator.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ esx _ vi _ generator . py : ▁ generates ▁ most ▁ of ▁ the ▁ SOAP ▁ type ▁ mapping ▁ code ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2010-2011 ▁ Matthias ▁ Bolte ▁ < matthias . bolte @ googlemail . com > ENDCOM # ▁ This ▁ library ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ENDCOM # ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ENDCOM # ▁ License ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ENDCOM # ▁ version ▁ 2.1 ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ library ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ▁ GNU ENDCOM # ▁ Lesser ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ENDCOM # ▁ License ▁ along ▁ with ▁ this ▁ library ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation , ▁ Inc . , ▁ 59 ▁ Temple ▁ Place , ▁ Suite ▁ 330 , ▁ Boston , ▁ MA ▁ 02111-1307 ▁ USA ENDCOM import sys NEW_LINE import os NEW_LINE import os . path NEW_LINE OCCURRENCE__REQUIRED_ITEM = " r " NEW_LINE OCCURRENCE__REQUIRED_LIST = " rl " NEW_LINE OCCURRENCE__OPTIONAL_ITEM = " o " NEW_LINE OCCURRENCE__OPTIONAL_LIST = " ol " NEW_LINE OCCURRENCE__IGNORED = " i " NEW_LINE valid_occurrences = [ OCCURRENCE__REQUIRED_ITEM , OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_ITEM , OCCURRENCE__OPTIONAL_LIST , OCCURRENCE__IGNORED ] NEW_LINE autobind_names = set ( ) NEW_LINE separator = " / * ▁ " + ( " * ▁ " * 37 ) + " * \n " NEW_LINE def aligned ( left , right , length = 59 ) : NEW_LINE INDENT while len ( left ) < length : NEW_LINE INDENT left += " ▁ " NEW_LINE DEDENT return left + right NEW_LINE DEDENT class Member : NEW_LINE INDENT def __init__ ( self , type , occurrence ) : NEW_LINE INDENT self . type = type NEW_LINE self . occurrence = occurrence NEW_LINE DEDENT def is_enum ( self ) : NEW_LINE INDENT return self . type in predefined_enums or self . type in enums_by_name NEW_LINE DEDENT def is_object ( self ) : NEW_LINE INDENT return self . type in predefined_objects or self . type in objects_by_name NEW_LINE DEDENT def is_type_generated ( self ) : NEW_LINE INDENT return self . type in enums_by_name or self . type in objects_by_name NEW_LINE DEDENT def get_occurrence_comment ( self ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__REQUIRED_ITEM : NEW_LINE INDENT return " / * ▁ required ▁ * / " NEW_LINE DEDENT elif self . occurrence == OCCURRENCE__REQUIRED_LIST : NEW_LINE INDENT return " / * ▁ required , ▁ list ▁ * / " NEW_LINE DEDENT elif self . occurrence == OCCURRENCE__OPTIONAL_ITEM : NEW_LINE INDENT return " / * ▁ optional ▁ * / " NEW_LINE DEDENT elif self . occurrence == OCCURRENCE__OPTIONAL_LIST : NEW_LINE INDENT return " / * ▁ optional , ▁ list ▁ * / " NEW_LINE DEDENT raise ValueError ( " unknown ▁ occurrence ▁ value ▁ ' % s ' " % self . occurrence ) NEW_LINE DEDENT DEDENT class Parameter ( Member ) : NEW_LINE INDENT def __init__ ( self , type , name , occurrence ) : NEW_LINE INDENT Member . __init__ ( self , type , occurrence ) NEW_LINE if ' : ' in name and name . startswith ( " _ this " ) : NEW_LINE INDENT self . name , self . autobind_name = name . split ( " : " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . name = name NEW_LINE self . autobind_name = None NEW_LINE DEDENT DEDENT def generate_parameter ( self , is_last = False , is_header = True , offset = 0 ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT raise ValueError ( " invalid ▁ function ▁ parameter ▁ occurrence ▁ value ▁ ' % s ' " % self . occurrence ) NEW_LINE DEDENT elif self . autobind_name is not None : NEW_LINE INDENT return " " NEW_LINE DEDENT else : NEW_LINE INDENT string = " ▁ ▁ ▁ ▁ ▁ ▁ ▁ " NEW_LINE string += " ▁ " * offset NEW_LINE string += " % s % s " % ( self . get_type_string ( ) , self . name ) NEW_LINE if is_last : NEW_LINE INDENT if is_header : NEW_LINE INDENT string += " ) ; ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT string += " ) , ▁ " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT string += " , ▁ " NEW_LINE DEDENT return aligned ( string , self . get_occurrence_comment ( ) + " \n " ) NEW_LINE DEDENT DEDENT def generate_return ( self , offset = 0 , end_of_line = " ; " ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT raise ValueError ( " invalid ▁ function ▁ parameter ▁ occurrence ▁ value ▁ ' % s ' " % self . occurrence ) NEW_LINE DEDENT else : NEW_LINE INDENT string = " ▁ ▁ ▁ ▁ ▁ ▁ ▁ " NEW_LINE string += " ▁ " * offset NEW_LINE string += " % s % s ) % s " % ( self . get_type_string ( True ) , self . name , end_of_line ) NEW_LINE return aligned ( string , self . get_occurrence_comment ( ) + " \n " ) NEW_LINE DEDENT DEDENT def generate_require_code ( self ) : NEW_LINE INDENT if self . occurrence in [ OCCURRENCE__REQUIRED_ITEM , OCCURRENCE__REQUIRED_LIST ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ METHOD _ _ PARAMETER _ _ REQUIRE ( % s ) \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT def generate_serialize_code ( self ) : NEW_LINE INDENT if self . occurrence in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ METHOD _ _ PARAMETER _ _ SERIALIZE _ LIST ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT elif self . type == " String " : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ METHOD _ _ PARAMETER _ _ SERIALIZE _ VALUE ( String , ▁ % s ) \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ METHOD _ _ PARAMETER _ _ SERIALIZE ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT DEDENT def get_type_string ( self , as_return_value = False ) : NEW_LINE INDENT string = " " NEW_LINE if self . type == " String " and self . occurrence not in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST ] : NEW_LINE INDENT if as_return_value : NEW_LINE INDENT string += " char ▁ * " NEW_LINE DEDENT else : NEW_LINE INDENT string += " const ▁ char ▁ * " NEW_LINE DEDENT DEDENT elif self . is_enum ( ) : NEW_LINE INDENT string += " esxVI _ % s ▁ " % self . type NEW_LINE DEDENT else : NEW_LINE INDENT string += " esxVI _ % s ▁ * " % self . type NEW_LINE DEDENT if as_return_value : NEW_LINE INDENT string += " * " NEW_LINE DEDENT return string NEW_LINE DEDENT def get_occurrence_short_enum ( self ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__REQUIRED_ITEM : NEW_LINE INDENT return " RequiredItem " NEW_LINE DEDENT elif self . occurrence == OCCURRENCE__REQUIRED_LIST : NEW_LINE INDENT return " RequiredList " NEW_LINE DEDENT elif self . occurrence == OCCURRENCE__OPTIONAL_ITEM : NEW_LINE INDENT return " OptionalItem " NEW_LINE DEDENT elif self . occurrence == OCCURRENCE__OPTIONAL_LIST : NEW_LINE INDENT return " OptionalList " NEW_LINE DEDENT raise ValueError ( " unknown ▁ occurrence ▁ value ▁ ' % s ' " % self . occurrence ) NEW_LINE DEDENT DEDENT class Method : NEW_LINE INDENT def __init__ ( self , name , parameters , returns ) : NEW_LINE INDENT self . name = name NEW_LINE self . parameters = [ ] NEW_LINE self . autobind_parameter = None NEW_LINE self . returns = returns NEW_LINE for parameter in parameters : NEW_LINE INDENT if parameter . autobind_name is None : NEW_LINE INDENT self . parameters . append ( parameter ) NEW_LINE DEDENT else : NEW_LINE INDENT self . autobind_parameter = parameter NEW_LINE DEDENT DEDENT DEDENT def generate_header ( self ) : NEW_LINE INDENT header = " int ▁ esxVI _ % s \n " % self . name NEW_LINE header += " ▁ ▁ ▁ ▁ ▁ ▁ ( esxVI _ Context ▁ * ctx " NEW_LINE if len ( self . parameters ) > 0 or self . returns is not None : NEW_LINE INDENT header += " , \n " NEW_LINE for parameter in self . parameters [ : - 1 ] : NEW_LINE INDENT header += parameter . generate_parameter ( ) NEW_LINE DEDENT if self . returns is None : NEW_LINE INDENT header += self . parameters [ - 1 ] . generate_parameter ( is_last = True ) NEW_LINE DEDENT else : NEW_LINE INDENT header += self . parameters [ - 1 ] . generate_parameter ( ) NEW_LINE header += self . returns . generate_return ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT header += " ) ; \n " NEW_LINE DEDENT header += " \n " NEW_LINE return header NEW_LINE DEDENT def generate_source ( self ) : NEW_LINE INDENT source = " / * ▁ esxVI _ % s ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ METHOD ( % s , " % self . name NEW_LINE if self . autobind_parameter is not None : NEW_LINE INDENT autobind_names . add ( self . autobind_parameter . autobind_name ) NEW_LINE source += " ▁ % s , \n " % self . autobind_parameter . autobind_name NEW_LINE DEDENT else : NEW_LINE INDENT source += " ▁ / * ▁ explicit ▁ _ this ▁ * / , \n " NEW_LINE DEDENT source += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ( esxVI _ Context ▁ * ctx " NEW_LINE if len ( self . parameters ) > 0 or self . returns is not None : NEW_LINE INDENT source += " , \n " NEW_LINE for parameter in self . parameters [ : - 1 ] : NEW_LINE INDENT source += parameter . generate_parameter ( is_header = False , offset = 9 ) NEW_LINE DEDENT if self . returns is None : NEW_LINE INDENT source += self . parameters [ - 1 ] . generate_parameter ( is_last = True , is_header = False , offset = 9 ) NEW_LINE DEDENT else : NEW_LINE INDENT source += self . parameters [ - 1 ] . generate_parameter ( is_header = False , offset = 9 ) NEW_LINE source += self . returns . generate_return ( offset = 9 , end_of_line = " , " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT source += " ) , \n " NEW_LINE DEDENT if self . returns is None : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ void , ▁ / * ▁ nothing ▁ * / , ▁ None , \n " NEW_LINE DEDENT elif self . returns . type == " String " : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ String , ▁ Value , ▁ % s , \n " % self . returns . get_occurrence_short_enum ( ) NEW_LINE DEDENT else : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % s , ▁ / * ▁ nothing ▁ * / , ▁ % s , \n " % ( self . returns . type , self . returns . get_occurrence_short_enum ( ) ) NEW_LINE DEDENT source += " { \n " NEW_LINE if self . autobind_parameter is not None : NEW_LINE INDENT source += self . autobind_parameter . generate_require_code ( ) NEW_LINE DEDENT for parameter in self . parameters : NEW_LINE INDENT source += parameter . generate_require_code ( ) NEW_LINE DEDENT source += " } , \n " NEW_LINE source += " { \n " NEW_LINE if self . autobind_parameter is not None : NEW_LINE INDENT source += self . autobind_parameter . generate_serialize_code ( ) NEW_LINE DEDENT for parameter in self . parameters : NEW_LINE INDENT source += parameter . generate_serialize_code ( ) NEW_LINE DEDENT source += " } ) \n \n \n \n " NEW_LINE return source NEW_LINE DEDENT DEDENT class Property ( Member ) : NEW_LINE INDENT def __init__ ( self , type , name , occurrence ) : NEW_LINE INDENT Member . __init__ ( self , type , occurrence ) NEW_LINE self . name = name NEW_LINE DEDENT def generate_struct_member ( self ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ / * ▁ FIXME : ▁ % s ▁ is ▁ currently ▁ ignored ▁ * / \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT string = " ▁ ▁ ▁ ▁ % s % s ; ▁ " % ( self . get_type_string ( ) , self . name ) NEW_LINE return aligned ( string , self . get_occurrence_comment ( ) + " \n " ) NEW_LINE DEDENT DEDENT def generate_free_code ( self ) : NEW_LINE INDENT if self . type == " String " and self . occurrence not in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST , OCCURRENCE__IGNORED ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ VIR _ FREE ( item - > % s ) ; \n " % self . name NEW_LINE DEDENT elif self . is_enum ( ) : NEW_LINE INDENT return " " NEW_LINE DEDENT else : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ / * ▁ FIXME : ▁ % s ▁ is ▁ currently ▁ ignored ▁ * / \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & item - > % s ) ; \n " % ( self . type , self . name ) NEW_LINE DEDENT DEDENT DEDENT def generate_validate_code ( self , managed = False ) : NEW_LINE INDENT if managed : NEW_LINE INDENT macro = " ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ MANAGED _ REQUIRE " NEW_LINE DEDENT else : NEW_LINE INDENT macro = " ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ REQUIRE " NEW_LINE DEDENT if self . occurrence in [ OCCURRENCE__REQUIRED_ITEM , OCCURRENCE__REQUIRED_LIST ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ % s ( % s ) \n " % ( macro , self . name ) NEW_LINE DEDENT elif self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ / * ▁ FIXME : ▁ % s ▁ is ▁ currently ▁ ignored ▁ * / \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT def generate_deep_copy_code ( self ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ / * ▁ FIXME : ▁ % s ▁ is ▁ currently ▁ ignored ▁ * / \n " % self . name NEW_LINE DEDENT elif self . occurrence in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ DEEP _ COPY _ LIST ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT elif self . type == " String " : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ DEEP _ COPY _ VALUE ( String , ▁ % s ) \n " % self . name NEW_LINE DEDENT elif self . is_enum ( ) : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ( * dest ) - > % s ▁ = ▁ src - > % s ; \n " % ( self . name , self . name ) NEW_LINE DEDENT else : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ DEEP _ COPY ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT DEDENT def generate_serialize_code ( self ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ / * ▁ FIXME : ▁ % s ▁ is ▁ currently ▁ ignored ▁ * / \n " % self . name NEW_LINE DEDENT elif self . occurrence in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ SERIALIZE _ LIST ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT elif self . type == " String " : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ SERIALIZE _ VALUE ( String , ▁ % s ) \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ SERIALIZE ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT DEDENT def generate_deserialize_code ( self ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ DESERIALIZE _ IGNORE ( % s ) ▁ / * ▁ FIXME ▁ * / \n " % self . name NEW_LINE DEDENT elif self . occurrence in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ DESERIALIZE _ LIST ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT elif self . type == " String " : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ DESERIALIZE _ VALUE ( String , ▁ % s ) \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ DESERIALIZE ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT DEDENT def generate_lookup_code ( self ) : NEW_LINE INDENT if self . occurrence == OCCURRENCE__IGNORED : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ CAST _ FROM _ ANY _ TYPE _ IGNORE ( % s ) ▁ / * ▁ FIXME ▁ * / \n " % self . name NEW_LINE DEDENT elif self . occurrence in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST ] : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ CAST _ LIST _ FROM _ ANY _ TYPE ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT elif self . type == " String " : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ CAST _ VALUE _ FROM _ ANY _ TYPE ( String , ▁ % s ) \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ PROPERTY _ _ CAST _ FROM _ ANY _ TYPE ( % s , ▁ % s ) \n " % ( self . type , self . name ) NEW_LINE DEDENT DEDENT def get_type_string ( self ) : NEW_LINE INDENT if self . type == " String " and self . occurrence not in [ OCCURRENCE__REQUIRED_LIST , OCCURRENCE__OPTIONAL_LIST ] : NEW_LINE INDENT return " char ▁ * " NEW_LINE DEDENT elif self . is_enum ( ) : NEW_LINE INDENT return " esxVI _ % s ▁ " % self . type NEW_LINE DEDENT else : NEW_LINE INDENT return " esxVI _ % s ▁ * " % self . type NEW_LINE DEDENT DEDENT DEDENT class Type : NEW_LINE INDENT def __init__ ( self , kind , name ) : NEW_LINE INDENT self . kind = kind NEW_LINE self . name = name NEW_LINE DEDENT def generate_typedef ( self ) : NEW_LINE INDENT return " typedef ▁ % s ▁ _ esxVI _ % s ▁ esxVI _ % s ; \n " % ( self . kind , self . name , self . name ) NEW_LINE DEDENT def generate_typeenum ( self ) : NEW_LINE INDENT return " ▁ ▁ ▁ ▁ esxVI _ Type _ % s , \n " % self . name NEW_LINE DEDENT def generate_typetostring ( self ) : NEW_LINE INDENT string = " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ case ▁ esxVI _ Type _ % s : \n " % self . name NEW_LINE string += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ \ " % s\ " ; \n \n " % self . name NEW_LINE return string NEW_LINE DEDENT def generate_typefromstring ( self ) : NEW_LINE INDENT string = " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else ▁ if ▁ ( STREQ ( type , ▁ \ " % s\ " ) ) ▁ { \n " % self . name NEW_LINE string += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ return ▁ esxVI _ Type _ % s ; \n " % self . name NEW_LINE string += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } \n " NEW_LINE return string NEW_LINE DEDENT DEDENT class Object ( Type ) : NEW_LINE INDENT FEATURE__DYNAMIC_CAST = ( 1 << 1 ) NEW_LINE FEATURE__LIST = ( 1 << 2 ) NEW_LINE FEATURE__DEEP_COPY = ( 1 << 3 ) NEW_LINE FEATURE__ANY_TYPE = ( 1 << 4 ) NEW_LINE FEATURE__SERIALIZE = ( 1 << 5 ) NEW_LINE FEATURE__DESERIALIZE = ( 1 << 6 ) NEW_LINE def __init__ ( self , name , extends , properties , features = 0 , extended_by = None ) : NEW_LINE INDENT Type . __init__ ( self , " struct " , name ) NEW_LINE self . extends = extends NEW_LINE self . features = features NEW_LINE self . properties = properties NEW_LINE self . extended_by = extended_by NEW_LINE self . candidate_for_dynamic_cast = False NEW_LINE if self . extended_by is not None : NEW_LINE INDENT self . extended_by . sort ( ) NEW_LINE DEDENT DEDENT def generate_struct_members ( self , add_banner = False , struct_gap = False ) : NEW_LINE INDENT members = " " NEW_LINE if struct_gap : NEW_LINE INDENT members += " \n " NEW_LINE DEDENT if self . extends is not None : NEW_LINE INDENT members += objects_by_name [ self . extends ] . generate_struct_members ( add_banner = True , struct_gap = False ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT members += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT for property in self . properties : NEW_LINE INDENT members += property . generate_struct_member ( ) NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT members += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT return members NEW_LINE DEDENT def generate_free_code ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += objects_by_name [ self . extends ] . generate_free_code ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT string = " " NEW_LINE for property in self . properties : NEW_LINE INDENT string += property . generate_free_code ( ) NEW_LINE DEDENT if len ( string ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ to ▁ be ▁ freed ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += string NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_validate_code ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += objects_by_name [ self . extends ] . generate_validate_code ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT string = " " NEW_LINE for property in self . properties : NEW_LINE INDENT string += property . generate_validate_code ( ) NEW_LINE DEDENT if len ( string ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ required ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += string NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_dynamic_cast_code ( self , is_first = True ) : NEW_LINE INDENT source = " " NEW_LINE if self . extended_by is not None : NEW_LINE INDENT if not is_first : NEW_LINE INDENT source += " \n " NEW_LINE DEDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE for extended_by in self . extended_by : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ CAST _ _ ACCEPT ( % s ) \n " % extended_by NEW_LINE DEDENT for extended_by in self . extended_by : NEW_LINE INDENT source += objects_by_name [ extended_by ] . generate_dynamic_cast_code ( False ) NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_deep_copy_code ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += objects_by_name [ self . extends ] . generate_deep_copy_code ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT string = " " NEW_LINE for property in self . properties : NEW_LINE INDENT string += property . generate_deep_copy_code ( ) NEW_LINE DEDENT if len ( string ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ to ▁ be ▁ deep ▁ copied ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += string NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_serialize_code ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += objects_by_name [ self . extends ] . generate_serialize_code ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT for property in self . properties : NEW_LINE INDENT source += property . generate_serialize_code ( ) NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_deserialize_code ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += objects_by_name [ self . extends ] . generate_deserialize_code ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT for property in self . properties : NEW_LINE INDENT source += property . generate_deserialize_code ( ) NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_header ( self ) : NEW_LINE INDENT header = separator NEW_LINE header += " ▁ * ▁ VI ▁ Object : ▁ % s \n " % self . name NEW_LINE if self . extends is not None : NEW_LINE INDENT header += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ extends ▁ % s \n " % self . extends NEW_LINE DEDENT first = True NEW_LINE if self . extended_by is not None : NEW_LINE INDENT for extended_by in self . extended_by : NEW_LINE INDENT if first : NEW_LINE INDENT header += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ extended ▁ by ▁ % s \n " % extended_by NEW_LINE first = False NEW_LINE DEDENT else : NEW_LINE INDENT header += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % s \n " % extended_by NEW_LINE DEDENT DEDENT DEDENT header += " ▁ * / \n \n " NEW_LINE # ▁ struct ENDCOM header += " struct ▁ _ esxVI _ % s ▁ { \n " % self . name NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += aligned ( " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * _ next ; ▁ " % self . name , " / * ▁ optional ▁ * / \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT header += aligned ( " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * _ unused ; ▁ " % self . name , " / * ▁ optional ▁ * / \n " ) NEW_LINE DEDENT header += aligned ( " ▁ ▁ ▁ ▁ esxVI _ Type ▁ _ type ; ▁ " , " / * ▁ required ▁ * / \n " ) NEW_LINE header += self . generate_struct_members ( struct_gap = True ) NEW_LINE header += " } ; \n \n " NEW_LINE # ▁ functions ENDCOM header += " int ▁ esxVI _ % s _ Alloc ( esxVI _ % s ▁ * * item ) ; \n " % ( self . name , self . name ) NEW_LINE header += " void ▁ esxVI _ % s _ Free ( esxVI _ % s ▁ * * item ) ; \n " % ( self . name , self . name ) NEW_LINE header += " int ▁ esxVI _ % s _ Validate ( esxVI _ % s ▁ * item ) ; \n " % ( self . name , self . name ) NEW_LINE if self . features & Object . FEATURE__DYNAMIC_CAST : NEW_LINE INDENT if self . extended_by is not None or self . extends is not None : NEW_LINE INDENT header += " esxVI _ % s ▁ * esxVI _ % s _ DynamicCast ( void ▁ * item ) ; \n " % ( self . name , self . name ) NEW_LINE DEDENT else : NEW_LINE INDENT report_error ( " cannot ▁ add ▁ dynamic ▁ cast ▁ support ▁ for ▁ an ▁ untyped ▁ object " ) NEW_LINE DEDENT DEDENT if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += " int ▁ esxVI _ % s _ AppendToList ( esxVI _ % s ▁ * * list , ▁ esxVI _ % s ▁ * item ) ; \n " % ( self . name , self . name , self . name ) NEW_LINE DEDENT if self . features & Object . FEATURE__DEEP_COPY : NEW_LINE INDENT header += " int ▁ esxVI _ % s _ DeepCopy ( esxVI _ % s ▁ * * dst , ▁ esxVI _ % s ▁ * src ) ; \n " % ( self . name , self . name , self . name ) NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ DeepCopyList ( esxVI _ % s ▁ * * dstList , ▁ " " esxVI _ % s ▁ * srcList ) ; \n " ) % ( self . name , self . name , self . name ) NEW_LINE DEDENT DEDENT if self . features & Object . FEATURE__ANY_TYPE : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ CastFromAnyType ( esxVI _ AnyType ▁ * anyType , ▁ " " esxVI _ % s ▁ * * item ) ; \n " ) % ( self . name , self . name ) NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ CastListFromAnyType ( esxVI _ AnyType ▁ * anyType , ▁ " " esxVI _ % s ▁ * * list ) ; \n " ) % ( self . name , self . name ) NEW_LINE DEDENT DEDENT if self . features & Object . FEATURE__SERIALIZE : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ Serialize ( esxVI _ % s ▁ * item , ▁ " " const ▁ char ▁ * element , ▁ " " virBufferPtr ▁ output ) ; \n " ) % ( self . name , self . name ) NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ SerializeList ( esxVI _ % s ▁ * list , ▁ " " const ▁ char ▁ * element , ▁ " " virBufferPtr ▁ output ) ; \n " ) % ( self . name , self . name ) NEW_LINE DEDENT DEDENT if self . features & Object . FEATURE__DESERIALIZE : NEW_LINE INDENT header += " int ▁ esxVI _ % s _ Deserialize ( xmlNodePtr ▁ node , ▁ esxVI _ % s ▁ * * item ) ; \n " % ( self . name , self . name ) NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ DeserializeList ( xmlNodePtr ▁ node , ▁ " " esxVI _ % s ▁ * * list ) ; \n " ) % ( self . name , self . name ) NEW_LINE DEDENT DEDENT header += " \n \n \n " NEW_LINE return header NEW_LINE DEDENT def generate_source ( self ) : NEW_LINE INDENT source = separator NEW_LINE source += " ▁ * ▁ VI ▁ Object : ▁ % s \n " % self . name NEW_LINE if self . extends is not None : NEW_LINE INDENT source += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ extends ▁ % s \n " % self . extends NEW_LINE DEDENT first = True NEW_LINE if self . extended_by is not None : NEW_LINE INDENT for extended_by in self . extended_by : NEW_LINE INDENT if first : NEW_LINE INDENT source += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ extended ▁ by ▁ % s \n " % extended_by NEW_LINE first = False NEW_LINE DEDENT else : NEW_LINE INDENT source += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % s \n " % extended_by NEW_LINE DEDENT DEDENT DEDENT source += " ▁ * / \n \n " NEW_LINE # ▁ functions ENDCOM source += " / * ▁ esxVI _ % s _ Alloc ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ ALLOC ( % s ) \n \n " % self . name NEW_LINE # ▁ free ENDCOM if self . extended_by is None : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Free ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ FREE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT if self . extends is not None : NEW_LINE # ▁ avoid ▁ " dereferencing ▁ type - punned ▁ pointer ▁ will ▁ break ENDCOM # ▁ strict - aliasing ▁ rules " ▁ warnings ENDCOM INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * next ▁ = ▁ ( esxVI _ % s ▁ * ) item - > _ next ; \n \n " % ( self . extends , self . extends ) NEW_LINE source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & next ) ; \n " % self . extends NEW_LINE source += " ▁ ▁ ▁ ▁ item - > _ next ▁ = ▁ ( esxVI _ % s ▁ * ) next ; \n \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & item - > _ next ) ; \n \n " % self . name NEW_LINE DEDENT DEDENT source += self . generate_free_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Free ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ FREE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE for extended_by in self . extended_by : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ DISPATCH _ _ FREE ( % s ) \n " % extended_by NEW_LINE DEDENT source += " } , \n " NEW_LINE source += " { \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT if self . extends is not None : NEW_LINE # ▁ avoid ▁ " dereferencing ▁ type - punned ▁ pointer ▁ will ▁ brea ENDCOM # ▁ strict - aliasing ▁ rules " ▁ warnings ENDCOM INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * next ▁ = ▁ ( esxVI _ % s ▁ * ) item - > _ next ; \n \n " % ( self . extends , self . extends ) NEW_LINE source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & next ) ; \n " % self . extends NEW_LINE source += " ▁ ▁ ▁ ▁ item - > _ next ▁ = ▁ ( esxVI _ % s ▁ * ) next ; \n \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & item - > _ next ) ; \n \n " % self . name NEW_LINE DEDENT DEDENT source += self . generate_free_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE # ▁ validate ENDCOM DEDENT source += " / * ▁ esxVI _ % s _ Validate ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ VALIDATE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE source += self . generate_validate_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE # ▁ dynamic ▁ cast ENDCOM if self . features & Object . FEATURE__DYNAMIC_CAST : NEW_LINE INDENT if self . extended_by is not None or self . extends is not None : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ DynamicCast ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ CAST ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE source += self . generate_dynamic_cast_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE DEDENT else : NEW_LINE INDENT report_error ( " cannot ▁ add ▁ dynamic ▁ cast ▁ support ▁ for ▁ an ▁ untyped ▁ object " ) NEW_LINE # ▁ append ▁ to ▁ list ENDCOM DEDENT DEDENT if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ AppendToList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ APPEND ( % s ) \n \n " % self . name NEW_LINE # ▁ deep ▁ copy ENDCOM DEDENT if self . extended_by is None : NEW_LINE INDENT if self . features & Object . FEATURE__DEEP_COPY : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ DeepCopy ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DEEP _ COPY ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE source += self . generate_deep_copy_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ DeepCopyList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ DEEP _ COPY ( % s ) \n \n " % self . name NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if self . features & Object . FEATURE__DEEP_COPY : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ DeepCopy ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ DEEP _ COPY ( % s ) \n " % self . name NEW_LINE source += " { \n " NEW_LINE for extended_by in self . extended_by : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ DISPATCH _ _ DEEP _ COPY ( % s ) \n " % extended_by NEW_LINE DEDENT source += " } , \n " NEW_LINE source += " { \n " NEW_LINE source += self . generate_deep_copy_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ DeepCopyList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ DEEP _ COPY ( % s ) \n \n " % self . name NEW_LINE # ▁ cast ▁ from ▁ any ▁ type ENDCOM DEDENT DEDENT DEDENT if self . features & Object . FEATURE__ANY_TYPE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ CastFromAnyType ▁ * / \n " % self . name NEW_LINE if self . extended_by is None : NEW_LINE INDENT source += " ESX _ VI _ _ TEMPLATE _ _ CAST _ FROM _ ANY _ TYPE ( % s ) \n \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT source += " ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ CAST _ FROM _ ANY _ TYPE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE for extended_by in self . extended_by : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ DISPATCH _ _ CAST _ FROM _ ANY _ TYPE ( % s ) \n " % extended_by NEW_LINE DEDENT source += " } ) \n \n " NEW_LINE DEDENT if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ CastListFromAnyType ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ CAST _ FROM _ ANY _ TYPE ( % s ) \n \n " % self . name NEW_LINE # ▁ serialize ENDCOM DEDENT DEDENT if self . extended_by is None : NEW_LINE INDENT if self . features & Object . FEATURE__SERIALIZE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Serialize ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ SERIALIZE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE source += self . generate_serialize_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ SerializeList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ SERIALIZE ( % s ) \n \n " % self . name NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if self . features & Object . FEATURE__SERIALIZE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Serialize ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ SERIALIZE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE for extended_by in self . extended_by : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ DISPATCH _ _ SERIALIZE ( % s ) \n " % extended_by NEW_LINE DEDENT source += " } , \n " NEW_LINE source += " { \n " NEW_LINE source += self . generate_serialize_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ SerializeList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ SERIALIZE ( % s ) \n \n " % self . name NEW_LINE # ▁ deserialize ENDCOM DEDENT DEDENT DEDENT if self . extended_by is None : NEW_LINE INDENT if self . features & Object . FEATURE__DESERIALIZE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Deserialize ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DESERIALIZE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE source += self . generate_deserialize_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ DeserializeList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ DESERIALIZE ( % s ) \n \n " % self . name NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if self . features & Object . FEATURE__DESERIALIZE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Deserialize ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ DESERIALIZE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE for extended_by in self . extended_by : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ DISPATCH _ _ DESERIALIZE ( % s ) \n " % extended_by NEW_LINE DEDENT source += " } , \n " NEW_LINE source += " { \n " NEW_LINE source += self . generate_deserialize_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ DeserializeList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ DESERIALIZE ( % s ) \n \n " % self . name NEW_LINE DEDENT DEDENT DEDENT source += " \n \n " NEW_LINE return source NEW_LINE DEDENT DEDENT class ManagedObject ( Type ) : NEW_LINE INDENT FEATURE__LIST = ( 1 << 2 ) NEW_LINE def __init__ ( self , name , extends , properties , features = 0 , extended_by = None ) : NEW_LINE INDENT Type . __init__ ( self , " struct " , name ) NEW_LINE self . extends = extends NEW_LINE self . features = features NEW_LINE self . properties = properties NEW_LINE self . extended_by = extended_by NEW_LINE if self . extended_by is not None : NEW_LINE INDENT self . extended_by . sort ( ) NEW_LINE DEDENT DEDENT def generate_struct_members ( self , add_banner = False , struct_gap = False ) : NEW_LINE INDENT members = " " NEW_LINE if struct_gap : NEW_LINE INDENT members += " \n " NEW_LINE DEDENT if self . extends is not None : NEW_LINE INDENT members += managed_objects_by_name [ self . extends ] . generate_struct_members ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT members += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT for property in self . properties : NEW_LINE INDENT members += property . generate_struct_member ( ) NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT members += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT return members NEW_LINE DEDENT def generate_free_code ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += managed_objects_by_name [ self . extends ] . generate_free_code ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT string = " " NEW_LINE for property in self . properties : NEW_LINE INDENT string += property . generate_free_code ( ) NEW_LINE DEDENT if len ( string ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ to ▁ be ▁ freed ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += string NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_validate_code ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += managed_objects_by_name [ self . extends ] . generate_validate_code ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT string = " " NEW_LINE for property in self . properties : NEW_LINE INDENT string += property . generate_validate_code ( managed = True ) NEW_LINE DEDENT if len ( string ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ required ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += string NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_lookup_code1 ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += managed_objects_by_name [ self . extends ] . generate_lookup_code1 ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT string = " " NEW_LINE for property in self . properties : NEW_LINE INDENT string += " ▁ ▁ ▁ ▁ \ " % s\\0\ " \n " % property . name NEW_LINE DEDENT if len ( string ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += string NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_lookup_code2 ( self , add_banner = False ) : NEW_LINE INDENT source = " " NEW_LINE if self . extends is not None : NEW_LINE INDENT source += managed_objects_by_name [ self . extends ] . generate_lookup_code2 ( add_banner = True ) + " \n " NEW_LINE DEDENT if self . extends is not None or add_banner : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ % s ▁ * / \n " % self . name NEW_LINE DEDENT if len ( self . properties ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT string = " " NEW_LINE for property in self . properties : NEW_LINE INDENT string += property . generate_lookup_code ( ) NEW_LINE DEDENT if len ( string ) < 1 : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ / * ▁ no ▁ properties ▁ * / \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += string NEW_LINE DEDENT DEDENT return source NEW_LINE DEDENT def generate_comment ( self ) : NEW_LINE INDENT comment = separator NEW_LINE comment += " ▁ * ▁ VI ▁ Managed ▁ Object : ▁ % s \n " % self . name NEW_LINE if self . extends is not None : NEW_LINE INDENT comment += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ extends ▁ % s \n " % self . extends NEW_LINE DEDENT first = True NEW_LINE if self . extended_by is not None : NEW_LINE INDENT for extended_by in self . extended_by : NEW_LINE INDENT if first : NEW_LINE INDENT comment += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ extended ▁ by ▁ % s \n " % extended_by NEW_LINE first = False NEW_LINE DEDENT else : NEW_LINE INDENT comment += " ▁ * ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % s \n " % extended_by NEW_LINE DEDENT DEDENT DEDENT comment += " ▁ * / \n \n " NEW_LINE return comment NEW_LINE DEDENT def generate_header ( self ) : NEW_LINE INDENT header = self . generate_comment ( ) NEW_LINE # ▁ struct ENDCOM header += " struct ▁ _ esxVI _ % s ▁ { \n " % self . name NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += aligned ( " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * _ next ; ▁ " % self . name , " / * ▁ optional ▁ * / \n " ) NEW_LINE DEDENT else : NEW_LINE INDENT header += aligned ( " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * _ unused ; ▁ " % self . name , " / * ▁ optional ▁ * / \n " ) NEW_LINE DEDENT header += aligned ( " ▁ ▁ ▁ ▁ esxVI _ Type ▁ _ type ; ▁ " , " / * ▁ required ▁ * / \n " ) NEW_LINE header += aligned ( " ▁ ▁ ▁ ▁ esxVI _ ManagedObjectReference ▁ * _ reference ; ▁ " , " / * ▁ required ▁ * / \n " ) NEW_LINE header += " \n " NEW_LINE header += self . generate_struct_members ( ) NEW_LINE header += " } ; \n \n " NEW_LINE # ▁ functions ENDCOM header += " int ▁ esxVI _ % s _ Alloc ( esxVI _ % s ▁ * * item ) ; \n " % ( self . name , self . name ) NEW_LINE header += " void ▁ esxVI _ % s _ Free ( esxVI _ % s ▁ * * item ) ; \n " % ( self . name , self . name ) NEW_LINE header += ( " int ▁ esxVI _ % s _ Validate ( esxVI _ % s ▁ * item , ▁ " " esxVI _ String ▁ * selectedPropertyNameList ) ; \n " ) % ( self . name , self . name ) NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT header += " int ▁ esxVI _ % s _ AppendToList ( esxVI _ % s ▁ * * list , ▁ esxVI _ % s ▁ * item ) ; \n " % ( self . name , self . name , self . name ) NEW_LINE DEDENT header += " \n \n \n " NEW_LINE return header NEW_LINE DEDENT def generate_helper_header ( self ) : NEW_LINE INDENT header = " " NEW_LINE # ▁ functions ENDCOM header += ( " int ▁ esxVI _ Lookup % s ( esxVI _ Context ▁ * ctx , ▁ " " const ▁ char ▁ * name , ▁ " " esxVI _ ManagedObjectReference ▁ * root , ▁ " " esxVI _ String ▁ * selectedPropertyNameList , ▁ " " esxVI _ % s ▁ * * item , ▁ " " esxVI _ Occurrence ▁ occurrence ) ; \n " ) % ( self . name , self . name ) NEW_LINE header += " \n " NEW_LINE return header NEW_LINE DEDENT def generate_source ( self ) : NEW_LINE INDENT source = self . generate_comment ( ) NEW_LINE # ▁ functions ENDCOM source += " / * ▁ esxVI _ % s _ Alloc ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ ALLOC ( % s ) \n \n " % self . name NEW_LINE # ▁ free ENDCOM if self . extended_by is None : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Free ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ FREE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE if self . features & ManagedObject . FEATURE__LIST : NEW_LINE INDENT if self . extends is not None : NEW_LINE # ▁ avoid ▁ " dereferencing ▁ type - punned ▁ pointer ▁ will ▁ break ENDCOM # ▁ strict - aliasing ▁ rules " ▁ warnings ENDCOM INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * next ▁ = ▁ ( esxVI _ % s ▁ * ) item - > _ next ; \n \n " % ( self . extends , self . extends ) NEW_LINE source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & next ) ; \n " % self . extends NEW_LINE source += " ▁ ▁ ▁ ▁ item - > _ next ▁ = ▁ ( esxVI _ % s ▁ * ) next ; \n \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & item - > _ next ) ; \n " % self . name NEW_LINE DEDENT DEDENT source += " ▁ ▁ ▁ ▁ esxVI _ ManagedObjectReference _ Free ( & item - > _ reference ) ; \n \n " NEW_LINE source += self . generate_free_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE DEDENT else : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Free ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ DYNAMIC _ FREE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE for extended_by in self . extended_by : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ESX _ VI _ _ TEMPLATE _ _ DISPATCH _ _ FREE ( % s ) \n " % extended_by NEW_LINE DEDENT source += " } , \n " NEW_LINE source += " { \n " NEW_LINE if self . features & Object . FEATURE__LIST : NEW_LINE INDENT if self . extends is not None : NEW_LINE # ▁ avoid ▁ " dereferencing ▁ type - punned ▁ pointer ▁ will ▁ break ENDCOM # ▁ strict - aliasing ▁ rules " ▁ warnings ENDCOM INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s ▁ * next ▁ = ▁ ( esxVI _ % s ▁ * ) item - > _ next ; \n \n " % ( self . extends , self . extends ) NEW_LINE source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & next ) ; \n " % self . extends NEW_LINE source += " ▁ ▁ ▁ ▁ item - > _ next ▁ = ▁ ( esxVI _ % s ▁ * ) next ; \n \n " % self . name NEW_LINE DEDENT else : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ esxVI _ % s _ Free ( & item - > _ next ) ; \n " % self . name NEW_LINE DEDENT DEDENT source += " ▁ ▁ ▁ ▁ esxVI _ ManagedObjectReference _ Free ( & item - > _ reference ) ; \n \n " NEW_LINE source += self . generate_free_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE # ▁ validate ENDCOM DEDENT source += " / * ▁ esxVI _ % s _ Validate ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ MANAGED _ VALIDATE ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE source += self . generate_validate_code ( ) NEW_LINE source += " } ) \n \n " NEW_LINE # ▁ append ▁ to ▁ list ENDCOM if self . features & ManagedObject . FEATURE__LIST : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ AppendToList ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LIST _ _ APPEND ( % s ) \n \n " % self . name NEW_LINE DEDENT source += " \n \n " NEW_LINE return source NEW_LINE DEDENT def generate_helper_source ( self ) : NEW_LINE INDENT source = " " NEW_LINE # ▁ lookup ENDCOM source += " / * ▁ esxVI _ Lookup % s ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ LOOKUP ( % s , \n " % self . name NEW_LINE source += " { \n " NEW_LINE source += self . generate_lookup_code1 ( ) NEW_LINE source += " } , \n " NEW_LINE source += " { \n " NEW_LINE source += self . generate_lookup_code2 ( ) NEW_LINE source += " } ) \n \n " NEW_LINE source += " \n \n " NEW_LINE return source NEW_LINE DEDENT DEDENT class Enum ( Type ) : NEW_LINE INDENT FEATURE__ANY_TYPE = ( 1 << 1 ) NEW_LINE FEATURE__SERIALIZE = ( 1 << 2 ) NEW_LINE FEATURE__DESERIALIZE = ( 1 << 3 ) NEW_LINE def __init__ ( self , name , values , features = 0 ) : NEW_LINE INDENT Type . __init__ ( self , " enum " , name ) NEW_LINE self . values = values NEW_LINE self . features = features NEW_LINE DEDENT def generate_header ( self ) : NEW_LINE INDENT header = separator NEW_LINE header += " ▁ * ▁ VI ▁ Enum : ▁ % s \n " % self . name NEW_LINE header += " ▁ * / \n \n " NEW_LINE # ▁ enum ENDCOM header += " enum ▁ _ esxVI _ % s ▁ { \n " % self . name NEW_LINE header += " ▁ ▁ ▁ ▁ esxVI _ % s _ Undefined ▁ = ▁ 0 , \n " % self . name NEW_LINE for value in self . values : NEW_LINE INDENT header += " ▁ ▁ ▁ ▁ esxVI _ % s _ % s , \n " % ( self . name , capitalize_first ( value ) ) NEW_LINE DEDENT header += " } ; \n \n " NEW_LINE # ▁ functions ENDCOM if self . features & Enum . FEATURE__ANY_TYPE : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ CastFromAnyType ( esxVI _ AnyType ▁ * anyType , ▁ " " esxVI _ % s ▁ * item ) ; \n " ) % ( self . name , self . name ) NEW_LINE DEDENT if self . features & Enum . FEATURE__SERIALIZE : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ Serialize ( esxVI _ % s ▁ item , ▁ const ▁ char ▁ * element , ▁ " " virBufferPtr ▁ output ) ; \n " ) % ( self . name , self . name ) NEW_LINE DEDENT if self . features & Enum . FEATURE__DESERIALIZE : NEW_LINE INDENT header += ( " int ▁ esxVI _ % s _ Deserialize ( xmlNodePtr ▁ node , ▁ " " esxVI _ % s ▁ * item ) ; \n " ) % ( self . name , self . name ) NEW_LINE DEDENT header += " \n \n \n " NEW_LINE return header NEW_LINE DEDENT def generate_source ( self ) : NEW_LINE INDENT source = separator NEW_LINE source += " ▁ * ▁ VI ▁ Enum : ▁ % s \n " % self . name NEW_LINE source += " ▁ * / \n \n " NEW_LINE source += " static ▁ const ▁ esxVI _ Enumeration ▁ _ esxVI _ % s _ Enumeration ▁ = ▁ { \n " % self . name NEW_LINE source += " ▁ ▁ ▁ ▁ esxVI _ Type _ % s , ▁ { \n " % self . name NEW_LINE for value in self . values : NEW_LINE INDENT source += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { ▁ \ " % s\ " , ▁ esxVI _ % s _ % s ▁ } , \n " % ( value , self . name , capitalize_first ( value ) ) NEW_LINE DEDENT source += " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { ▁ NULL , ▁ - 1 ▁ } , \n " NEW_LINE source += " ▁ ▁ ▁ ▁ } , \n " NEW_LINE source += " } ; \n \n " NEW_LINE # ▁ functions ENDCOM if self . features & Enum . FEATURE__ANY_TYPE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ CastFromAnyType ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ ENUMERATION _ _ CAST _ FROM _ ANY _ TYPE ( % s ) \n \n " % self . name NEW_LINE DEDENT if self . features & Enum . FEATURE__SERIALIZE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Serialize ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ ENUMERATION _ _ SERIALIZE ( % s ) \n \n " % self . name NEW_LINE DEDENT if self . features & Enum . FEATURE__DESERIALIZE : NEW_LINE INDENT source += " / * ▁ esxVI _ % s _ Deserialize ▁ * / \n " % self . name NEW_LINE source += " ESX _ VI _ _ TEMPLATE _ _ ENUMERATION _ _ DESERIALIZE ( % s ) \n \n " % self . name NEW_LINE DEDENT source += " \n \n " NEW_LINE return source NEW_LINE DEDENT DEDENT def report_error ( message ) : NEW_LINE INDENT print " error : ▁ " + message NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT def capitalize_first ( string ) : NEW_LINE INDENT return string [ : 1 ] . upper ( ) + string [ 1 : ] NEW_LINE DEDENT def parse_object ( block ) : NEW_LINE # ▁ expected ▁ format : ▁ [ managed ] ▁ object ▁ < name > ▁ [ extends ▁ < name > ] ENDCOM INDENT header_items = block [ 0 ] [ 1 ] . split ( ) NEW_LINE managed = False NEW_LINE if header_items [ 0 ] == " managed " : NEW_LINE INDENT managed = True NEW_LINE del header_items [ 0 ] NEW_LINE DEDENT if len ( header_items ) < 2 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT assert header_items [ 0 ] == " object " NEW_LINE name = header_items [ 1 ] NEW_LINE extends = None NEW_LINE if len ( header_items ) > 2 : NEW_LINE INDENT if header_items [ 2 ] != " extends " : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT else : NEW_LINE INDENT extends = header_items [ 3 ] NEW_LINE DEDENT DEDENT properties = [ ] NEW_LINE for line in block [ 1 : ] : NEW_LINE # ▁ expected ▁ format : ▁ < type > ▁ < name > ▁ < occurrence > ENDCOM INDENT items = line [ 1 ] . split ( ) NEW_LINE if len ( items ) != 3 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ property " % line [ 0 ] ) NEW_LINE DEDENT if items [ 2 ] not in valid_occurrences : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ occurrence " % line [ 0 ] ) NEW_LINE DEDENT properties . append ( Property ( type = items [ 0 ] , name = items [ 1 ] , occurrence = items [ 2 ] ) ) NEW_LINE DEDENT if managed : NEW_LINE INDENT return ManagedObject ( name = name , extends = extends , properties = properties ) NEW_LINE DEDENT else : NEW_LINE INDENT return Object ( name = name , extends = extends , properties = properties ) NEW_LINE DEDENT DEDENT def parse_enum ( block ) : NEW_LINE # ▁ expected ▁ format : ▁ enum ▁ < name > ENDCOM INDENT header_items = block [ 0 ] [ 1 ] . split ( ) NEW_LINE if len ( header_items ) < 2 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT assert header_items [ 0 ] == " enum " NEW_LINE name = header_items [ 1 ] NEW_LINE values = [ ] NEW_LINE for line in block [ 1 : ] : NEW_LINE # ▁ expected ▁ format : ▁ < value > ENDCOM INDENT values . append ( line [ 1 ] ) NEW_LINE DEDENT return Enum ( name = name , values = values ) NEW_LINE DEDENT def parse_method ( block ) : NEW_LINE # ▁ expected ▁ format : ▁ method ▁ < name > ▁ [ returns ▁ < type > ▁ < occurrence > ] ENDCOM INDENT header_items = block [ 0 ] [ 1 ] . split ( ) NEW_LINE if len ( header_items ) < 2 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT assert header_items [ 0 ] == " method " NEW_LINE name = header_items [ 1 ] NEW_LINE returns = None NEW_LINE if len ( header_items ) > 2 : NEW_LINE INDENT if header_items [ 2 ] != " returns " : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT else : NEW_LINE INDENT returns = Parameter ( type = header_items [ 3 ] , name = " output " , occurrence = header_items [ 4 ] ) NEW_LINE DEDENT DEDENT parameters = [ ] NEW_LINE for line in block [ 1 : ] : NEW_LINE # ▁ expected ▁ format : ▁ < type > ▁ < name > ▁ < occurrence > ENDCOM INDENT items = line [ 1 ] . split ( ) NEW_LINE if len ( items ) != 3 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ property " % line [ 0 ] ) NEW_LINE DEDENT if items [ 2 ] not in valid_occurrences : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ occurrence " % line [ 0 ] ) NEW_LINE DEDENT parameters . append ( Parameter ( type = items [ 0 ] , name = items [ 1 ] , occurrence = items [ 2 ] ) ) NEW_LINE DEDENT return Method ( name = name , parameters = parameters , returns = returns ) NEW_LINE DEDENT def is_known_type ( type ) : NEW_LINE INDENT return type in predefined_objects or type in predefined_enums or type in objects_by_name or type in managed_objects_by_name or type in enums_by_name NEW_LINE DEDENT def open_and_print ( filename ) : NEW_LINE INDENT if filename . startswith ( " . / " ) : NEW_LINE INDENT print " ▁ ▁ GEN ▁ ▁ ▁ ▁ " + filename [ 2 : ] NEW_LINE DEDENT else : NEW_LINE INDENT print " ▁ ▁ GEN ▁ ▁ ▁ ▁ " + filename NEW_LINE DEDENT return open ( filename , " wb " ) NEW_LINE DEDENT predefined_enums = [ " Boolean " ] NEW_LINE predefined_objects = [ " AnyType " , " Int " , " Long " , " String " , " DateTime " , " MethodFault " , " ManagedObjectReference " ] NEW_LINE additional_enum_features = { " ManagedEntityStatus " : Enum . FEATURE__ANY_TYPE , " TaskInfoState " : Enum . FEATURE__ANY_TYPE , " VirtualMachinePowerState " : Enum . FEATURE__ANY_TYPE } NEW_LINE additional_object_features = { " AutoStartDefaults " : Object . FEATURE__ANY_TYPE , " AutoStartPowerInfo " : Object . FEATURE__ANY_TYPE , " DatastoreHostMount " : Object . FEATURE__DEEP_COPY | Object . FEATURE__LIST | Object . FEATURE__ANY_TYPE , " DatastoreInfo " : Object . FEATURE__ANY_TYPE | Object . FEATURE__DYNAMIC_CAST , " HostConfigManager " : Object . FEATURE__ANY_TYPE , " HostCpuIdInfo " : Object . FEATURE__LIST | Object . FEATURE__ANY_TYPE , " HostDatastoreBrowserSearchResults " : Object . FEATURE__LIST | Object . FEATURE__ANY_TYPE , " ManagedObjectReference " : Object . FEATURE__ANY_TYPE , " ObjectContent " : Object . FEATURE__DEEP_COPY , " ResourcePoolResourceUsage " : Object . FEATURE__ANY_TYPE , " ServiceContent " : Object . FEATURE__DESERIALIZE , " SharesInfo " : Object . FEATURE__ANY_TYPE , " TaskInfo " : Object . FEATURE__LIST | Object . FEATURE__ANY_TYPE , " UserSession " : Object . FEATURE__ANY_TYPE , " VirtualMachineQuestionInfo " : Object . FEATURE__ANY_TYPE , " VirtualMachineSnapshotTree " : Object . FEATURE__DEEP_COPY | Object . FEATURE__ANY_TYPE , " VmEventArgument " : Object . FEATURE__DESERIALIZE } NEW_LINE removed_object_features = { } NEW_LINE if " srcdir " in os . environ : NEW_LINE INDENT input_filename = os . path . join ( os . environ [ " srcdir " ] , " esx / esx _ vi _ generator . input " ) NEW_LINE output_dirname = os . path . join ( os . environ [ " srcdir " ] , " esx " ) NEW_LINE DEDENT else : NEW_LINE INDENT input_filename = os . path . join ( os . getcwd ( ) , " esx _ vi _ generator . input " ) NEW_LINE output_dirname = os . getcwd ( ) NEW_LINE DEDENT types_typedef = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ types . generated . typedef " ) ) NEW_LINE types_typeenum = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ types . generated . typeenum " ) ) NEW_LINE types_typetostring = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ types . generated . typetostring " ) ) NEW_LINE types_typefromstring = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ types . generated . typefromstring " ) ) NEW_LINE types_header = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ types . generated . h " ) ) NEW_LINE types_source = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ types . generated . c " ) ) NEW_LINE methods_header = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ methods . generated . h " ) ) NEW_LINE methods_source = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ methods . generated . c " ) ) NEW_LINE methods_macro = open_and_print ( os . path . join ( output_dirname , " esx _ vi _ methods . generated . macro " ) ) NEW_LINE helpers_header = open_and_print ( os . path . join ( output_dirname , " esx _ vi . generated . h " ) ) NEW_LINE helpers_source = open_and_print ( os . path . join ( output_dirname , " esx _ vi . generated . c " ) ) NEW_LINE number = 0 NEW_LINE objects_by_name = { } NEW_LINE managed_objects_by_name = { } NEW_LINE enums_by_name = { } NEW_LINE methods_by_name = { } NEW_LINE block = None NEW_LINE # ▁ parse ▁ input ▁ file ENDCOM for line in file ( input_filename , " rb " ) . readlines ( ) : NEW_LINE INDENT number += 1 NEW_LINE if " # " in line : NEW_LINE INDENT line = line [ : line . index ( " # " ) ] NEW_LINE DEDENT line = line . lstrip ( ) . rstrip ( ) NEW_LINE if len ( line ) < 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if line . startswith ( " object " ) or line . startswith ( " managed ▁ object " ) or line . startswith ( " enum " ) or line . startswith ( " method " ) : NEW_LINE INDENT if block is not None : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ nested ▁ block ▁ found " % ( number ) ) NEW_LINE DEDENT else : NEW_LINE INDENT block = [ ] NEW_LINE DEDENT DEDENT if block is not None : NEW_LINE INDENT if line == " end " : NEW_LINE INDENT if block [ 0 ] [ 1 ] . startswith ( " object " ) : NEW_LINE INDENT obj = parse_object ( block ) NEW_LINE objects_by_name [ obj . name ] = obj NEW_LINE DEDENT elif block [ 0 ] [ 1 ] . startswith ( " managed ▁ object " ) : NEW_LINE INDENT obj = parse_object ( block ) NEW_LINE managed_objects_by_name [ obj . name ] = obj NEW_LINE DEDENT elif block [ 0 ] [ 1 ] . startswith ( " enum " ) : NEW_LINE INDENT enum = parse_enum ( block ) NEW_LINE enums_by_name [ enum . name ] = enum NEW_LINE DEDENT else : NEW_LINE INDENT method = parse_method ( block ) NEW_LINE methods_by_name [ method . name ] = method NEW_LINE DEDENT block = None NEW_LINE DEDENT else : NEW_LINE INDENT block . append ( ( number , line ) ) NEW_LINE DEDENT DEDENT DEDENT for method in methods_by_name . values ( ) : NEW_LINE # ▁ method ▁ parameter ▁ types ▁ must ▁ be ▁ serializable ENDCOM INDENT for parameter in method . parameters : NEW_LINE INDENT if not parameter . is_type_generated ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT if parameter . is_enum ( ) : NEW_LINE INDENT enums_by_name [ parameter . type ] . features |= Enum . FEATURE__SERIALIZE NEW_LINE DEDENT else : NEW_LINE INDENT objects_by_name [ parameter . type ] . features |= Object . FEATURE__SERIALIZE NEW_LINE objects_by_name [ parameter . type ] . candidate_for_dynamic_cast = True NEW_LINE # ▁ detect ▁ list ▁ usage ENDCOM DEDENT if parameter . occurrence == OCCURRENCE__REQUIRED_LIST or parameter . occurrence == OCCURRENCE__OPTIONAL_LIST : NEW_LINE INDENT if parameter . is_enum ( ) : NEW_LINE INDENT report_error ( " unsupported ▁ usage ▁ of ▁ enum ▁ ' % s ' ▁ as ▁ list ▁ in ▁ ' % s ' " % ( parameter . type , method . name ) ) NEW_LINE DEDENT else : NEW_LINE INDENT objects_by_name [ parameter . type ] . features |= Object . FEATURE__LIST NEW_LINE # ▁ method ▁ return ▁ types ▁ must ▁ be ▁ deserializable ENDCOM DEDENT DEDENT DEDENT if method . returns and method . returns . is_type_generated ( ) : NEW_LINE INDENT if method . returns . is_enum ( ) : NEW_LINE INDENT enums_by_name [ method . returns . type ] . features |= Enum . FEATURE__DESERIALIZE NEW_LINE DEDENT else : NEW_LINE INDENT objects_by_name [ method . returns . type ] . features |= Object . FEATURE__DESERIALIZE NEW_LINE objects_by_name [ method . returns . type ] . candidate_for_dynamic_cast = True NEW_LINE # ▁ detect ▁ list ▁ usage ENDCOM DEDENT if method . returns . occurrence == OCCURRENCE__REQUIRED_LIST or method . returns . occurrence == OCCURRENCE__OPTIONAL_LIST : NEW_LINE INDENT if method . returns . is_enum ( ) : NEW_LINE INDENT report_error ( " unsupported ▁ usage ▁ of ▁ enum ▁ ' % s ' ▁ as ▁ list ▁ in ▁ ' % s ' " % ( method . returns . type , method . name ) ) NEW_LINE DEDENT else : NEW_LINE INDENT objects_by_name [ method . returns . type ] . features |= Object . FEATURE__LIST NEW_LINE DEDENT DEDENT DEDENT DEDENT for enum in enums_by_name . values ( ) : NEW_LINE # ▁ apply ▁ additional ▁ features ENDCOM INDENT if enum . name in additional_enum_features : NEW_LINE INDENT enum . features |= additional_enum_features [ enum . name ] NEW_LINE if additional_enum_features [ enum . name ] & Enum . FEATURE__ANY_TYPE : NEW_LINE INDENT enum . features |= Enum . FEATURE__DESERIALIZE NEW_LINE DEDENT DEDENT DEDENT for obj in objects_by_name . values ( ) : NEW_LINE INDENT for property in obj . properties : NEW_LINE INDENT if property . occurrence != OCCURRENCE__IGNORED and not is_known_type ( property . type ) : NEW_LINE INDENT report_error ( " object ▁ ' % s ' ▁ contains ▁ unknown ▁ property ▁ type ▁ ' % s ' " % ( obj . name , property . type ) ) NEW_LINE DEDENT DEDENT if obj . extends is not None : NEW_LINE INDENT if not is_known_type ( obj . extends ) : NEW_LINE INDENT report_error ( " object ▁ ' % s ' ▁ extends ▁ unknown ▁ object ▁ ' % s ' " % ( obj . name , obj . extends ) ) NEW_LINE DEDENT DEDENT for property in obj . properties : NEW_LINE INDENT if not property . is_type_generated ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT if property . is_enum ( ) : NEW_LINE INDENT enums_by_name [ property . type ] . candidate_for_dynamic_cast = True NEW_LINE DEDENT else : NEW_LINE INDENT objects_by_name [ property . type ] . candidate_for_dynamic_cast = True NEW_LINE # ▁ detect ▁ list ▁ usage ENDCOM DEDENT if property . occurrence == OCCURRENCE__REQUIRED_LIST or property . occurrence == OCCURRENCE__OPTIONAL_LIST : NEW_LINE INDENT if property . is_enum ( ) : NEW_LINE INDENT report_error ( " unsupported ▁ usage ▁ of ▁ enum ▁ ' % s ' ▁ as ▁ list ▁ in ▁ ' % s ' " % ( property . type , obj . type ) ) NEW_LINE DEDENT else : NEW_LINE INDENT objects_by_name [ property . type ] . features |= Object . FEATURE__LIST NEW_LINE # ▁ apply / remove ▁ additional ▁ features ENDCOM DEDENT DEDENT DEDENT if obj . name in additional_object_features : NEW_LINE INDENT obj . features |= additional_object_features [ obj . name ] NEW_LINE if additional_object_features [ obj . name ] & Object . FEATURE__ANY_TYPE : NEW_LINE INDENT obj . features |= Object . FEATURE__DESERIALIZE NEW_LINE DEDENT DEDENT if obj . name in removed_object_features : NEW_LINE INDENT obj . features &= ~ removed_object_features [ obj . name ] NEW_LINE # ▁ detect ▁ extended _ by ▁ relation ENDCOM DEDENT if obj . extends is not None : NEW_LINE INDENT extended_obj = objects_by_name [ obj . extends ] NEW_LINE if extended_obj . extended_by is None : NEW_LINE INDENT extended_obj . extended_by = [ obj . name ] NEW_LINE DEDENT else : NEW_LINE INDENT extended_obj . extended_by . append ( obj . name ) NEW_LINE extended_obj . extended_by . sort ( ) NEW_LINE DEDENT DEDENT DEDENT for obj in objects_by_name . values ( ) : NEW_LINE # ▁ if ▁ an ▁ object ▁ is ▁ a ▁ candidate ▁ ( it ▁ is ▁ used ▁ directly ▁ as ▁ parameter ▁ or ▁ return ENDCOM # ▁ type ▁ or ▁ is ▁ a ▁ member ▁ of ▁ another ▁ object ) ▁ and ▁ it ▁ is ▁ extended ▁ by ▁ another ENDCOM # ▁ object ▁ then ▁ this ▁ type ▁ needs ▁ the ▁ dynamic ▁ cast ▁ feature ENDCOM INDENT if obj . candidate_for_dynamic_cast and obj . extended_by : NEW_LINE INDENT obj . features |= Object . FEATURE__DYNAMIC_CAST NEW_LINE DEDENT DEDENT def propagate_feature ( obj , feature ) : NEW_LINE INDENT global features_have_changed NEW_LINE if not ( obj . features & feature ) : NEW_LINE INDENT return NEW_LINE DEDENT for property in obj . properties : NEW_LINE INDENT if property . occurrence == OCCURRENCE__IGNORED or not property . is_type_generated ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT if property . is_enum ( ) : NEW_LINE INDENT if feature == Object . FEATURE__SERIALIZE and not ( enums_by_name [ property . type ] . features & Enum . FEATURE__SERIALIZE ) : NEW_LINE INDENT enums_by_name [ property . type ] . features |= Enum . FEATURE__SERIALIZE NEW_LINE features_have_changed = True NEW_LINE DEDENT elif feature == Object . FEATURE__DESERIALIZE and not ( enums_by_name [ property . type ] . features & Enum . FEATURE__DESERIALIZE ) : NEW_LINE INDENT enums_by_name [ property . type ] . features |= Enum . FEATURE__DESERIALIZE NEW_LINE features_have_changed = True NEW_LINE DEDENT DEDENT elif property . is_object ( ) : NEW_LINE INDENT if not ( objects_by_name [ property . type ] . features & feature ) : NEW_LINE INDENT objects_by_name [ property . type ] . features |= feature NEW_LINE features_have_changed = True NEW_LINE DEDENT if obj . name != property . type : NEW_LINE INDENT propagate_feature ( objects_by_name [ property . type ] , feature ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def inherit_features ( obj ) : NEW_LINE INDENT global features_have_changed NEW_LINE if obj . extended_by is not None : NEW_LINE INDENT for extended_by in obj . extended_by : NEW_LINE INDENT previous = objects_by_name [ extended_by ] . features NEW_LINE objects_by_name [ extended_by ] . features |= obj . features NEW_LINE if objects_by_name [ extended_by ] . features != previous : NEW_LINE INDENT features_have_changed = True NEW_LINE DEDENT DEDENT DEDENT if obj . extends is not None : NEW_LINE INDENT previous = objects_by_name [ obj . extends ] . features NEW_LINE objects_by_name [ obj . extends ] . features |= obj . features NEW_LINE if objects_by_name [ obj . extends ] . features != previous : NEW_LINE INDENT features_have_changed = True NEW_LINE DEDENT DEDENT if obj . extended_by is not None : NEW_LINE INDENT for extended_by in obj . extended_by : NEW_LINE INDENT inherit_features ( objects_by_name [ extended_by ] ) NEW_LINE # ▁ there ▁ are ▁ two ▁ directions ▁ to ▁ spread ▁ features : ENDCOM # ▁ 1 ) ▁ up ▁ and ▁ down ▁ the ▁ inheritance ▁ chain ENDCOM # ▁ 2 ) ▁ from ▁ object ▁ types ▁ to ▁ their ▁ member ▁ property ▁ types ENDCOM # ▁ spreading ▁ needs ▁ to ▁ be ▁ done ▁ alternating ▁ on ▁ both ▁ directions ▁ because ▁ they ▁ can ENDCOM # ▁ affect ▁ each ▁ other ENDCOM DEDENT DEDENT DEDENT features_have_changed = True NEW_LINE while features_have_changed : NEW_LINE INDENT features_have_changed = False NEW_LINE for obj in objects_by_name . values ( ) : NEW_LINE INDENT propagate_feature ( obj , Object . FEATURE__DEEP_COPY ) NEW_LINE propagate_feature ( obj , Object . FEATURE__SERIALIZE ) NEW_LINE propagate_feature ( obj , Object . FEATURE__DESERIALIZE ) NEW_LINE DEDENT for obj in objects_by_name . values ( ) : NEW_LINE INDENT inherit_features ( obj ) NEW_LINE DEDENT DEDENT for obj in managed_objects_by_name . values ( ) : NEW_LINE INDENT for property in obj . properties : NEW_LINE INDENT if property . occurrence != OCCURRENCE__IGNORED and not is_known_type ( property . type ) : NEW_LINE INDENT report_error ( " object ▁ ' % s ' ▁ contains ▁ unknown ▁ property ▁ type ▁ ' % s ' " % ( obj . name , property . type ) ) NEW_LINE DEDENT DEDENT if obj . extends is not None : NEW_LINE INDENT if not is_known_type ( obj . extends ) : NEW_LINE INDENT report_error ( " object ▁ ' % s ' ▁ extends ▁ unknown ▁ object ▁ ' % s ' " % ( obj . name , obj . extends ) ) NEW_LINE # ▁ detect ▁ extended _ by ▁ relation ENDCOM DEDENT DEDENT if obj . extends is not None : NEW_LINE INDENT extended_obj = managed_objects_by_name [ obj . extends ] NEW_LINE if extended_obj . extended_by is None : NEW_LINE INDENT extended_obj . extended_by = [ obj . name ] NEW_LINE DEDENT else : NEW_LINE INDENT extended_obj . extended_by . append ( obj . name ) NEW_LINE extended_obj . extended_by . sort ( ) NEW_LINE DEDENT DEDENT DEDENT notice = " / * ▁ Generated ▁ by ▁ esx _ vi _ generator . py ▁ * / \n \n \n \n " NEW_LINE types_typedef . write ( notice ) NEW_LINE types_typeenum . write ( notice ) NEW_LINE types_typetostring . write ( notice ) NEW_LINE types_typefromstring . write ( notice ) NEW_LINE types_header . write ( notice ) NEW_LINE types_source . write ( notice ) NEW_LINE methods_header . write ( notice ) NEW_LINE methods_source . write ( notice ) NEW_LINE methods_macro . write ( notice ) NEW_LINE helpers_header . write ( notice ) NEW_LINE helpers_source . write ( notice ) NEW_LINE # ▁ output ▁ enums ENDCOM types_typedef . write ( separator + " ▁ * ▁ VI ▁ Enums \n " + " ▁ * / \n \n " ) NEW_LINE names = enums_by_name . keys ( ) NEW_LINE names . sort ( ) NEW_LINE for name in names : NEW_LINE INDENT types_typedef . write ( enums_by_name [ name ] . generate_typedef ( ) ) NEW_LINE types_typeenum . write ( enums_by_name [ name ] . generate_typeenum ( ) ) NEW_LINE types_typetostring . write ( enums_by_name [ name ] . generate_typetostring ( ) ) NEW_LINE types_typefromstring . write ( enums_by_name [ name ] . generate_typefromstring ( ) ) NEW_LINE types_header . write ( enums_by_name [ name ] . generate_header ( ) ) NEW_LINE types_source . write ( enums_by_name [ name ] . generate_source ( ) ) NEW_LINE # ▁ output ▁ objects ENDCOM DEDENT types_typedef . write ( " \n \n \n " + separator + " ▁ * ▁ VI ▁ Objects \n " + " ▁ * / \n \n " ) NEW_LINE types_typeenum . write ( " \n " ) NEW_LINE types_typetostring . write ( " \n " ) NEW_LINE types_typefromstring . write ( " \n " ) NEW_LINE names = objects_by_name . keys ( ) NEW_LINE names . sort ( ) NEW_LINE for name in names : NEW_LINE INDENT types_typedef . write ( objects_by_name [ name ] . generate_typedef ( ) ) NEW_LINE types_typeenum . write ( objects_by_name [ name ] . generate_typeenum ( ) ) NEW_LINE types_typetostring . write ( objects_by_name [ name ] . generate_typetostring ( ) ) NEW_LINE types_typefromstring . write ( objects_by_name [ name ] . generate_typefromstring ( ) ) NEW_LINE types_header . write ( objects_by_name [ name ] . generate_header ( ) ) NEW_LINE types_source . write ( objects_by_name [ name ] . generate_source ( ) ) NEW_LINE # ▁ output ▁ managed ▁ objects ENDCOM DEDENT types_typedef . write ( " \n \n \n " + separator + " ▁ * ▁ VI ▁ Managed ▁ Objects \n " + " ▁ * / \n \n " ) NEW_LINE types_typeenum . write ( " \n " ) NEW_LINE types_typetostring . write ( " \n " ) NEW_LINE types_typefromstring . write ( " \n " ) NEW_LINE names = managed_objects_by_name . keys ( ) NEW_LINE names . sort ( ) NEW_LINE for name in names : NEW_LINE INDENT types_typedef . write ( managed_objects_by_name [ name ] . generate_typedef ( ) ) NEW_LINE types_typeenum . write ( managed_objects_by_name [ name ] . generate_typeenum ( ) ) NEW_LINE types_typetostring . write ( managed_objects_by_name [ name ] . generate_typetostring ( ) ) NEW_LINE types_typefromstring . write ( managed_objects_by_name [ name ] . generate_typefromstring ( ) ) NEW_LINE types_header . write ( managed_objects_by_name [ name ] . generate_header ( ) ) NEW_LINE types_source . write ( managed_objects_by_name [ name ] . generate_source ( ) ) NEW_LINE # ▁ output ▁ methods ENDCOM DEDENT names = methods_by_name . keys ( ) NEW_LINE names . sort ( ) NEW_LINE for name in names : NEW_LINE INDENT methods_header . write ( methods_by_name [ name ] . generate_header ( ) ) NEW_LINE methods_source . write ( methods_by_name [ name ] . generate_source ( ) ) NEW_LINE DEDENT names = list ( autobind_names ) NEW_LINE names . sort ( ) NEW_LINE for name in names : NEW_LINE INDENT string = aligned ( " # define ▁ ESX _ VI _ _ METHOD _ _ PARAMETER _ _ THIS _ _ % s ▁ " % name , " \\ \n " , 78 ) NEW_LINE string += " ▁ ▁ ▁ ▁ ESX _ VI _ _ METHOD _ _ PARAMETER _ _ THIS _ FROM _ SERVICE ( ManagedObjectReference , ▁ ▁ ▁ ▁ ▁ ▁ \\ \n " NEW_LINE string += aligned ( " " , " % s ) \n \n \n \n " % name , 49 ) NEW_LINE methods_macro . write ( string ) NEW_LINE # ▁ output ▁ helpers ENDCOM DEDENT names = managed_objects_by_name . keys ( ) NEW_LINE names . sort ( ) NEW_LINE for name in names : NEW_LINE INDENT helpers_header . write ( managed_objects_by_name [ name ] . generate_helper_header ( ) ) NEW_LINE helpers_source . write ( managed_objects_by_name [ name ] . generate_helper_source ( ) ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="robertglen/flask/tree/master/tests/test_instance_config.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM """ STRNEWLINE ▁ tests . test _ instance STRNEWLINE ▁ ~ ~ ~ ~ ~ STRNEWLINE STRNEWLINE ▁ : copyright : ▁ ( c ) ▁ 2015 ▁ by ▁ the ▁ Flask ▁ Team , ▁ see ▁ AUTHORS ▁ for ▁ more ▁ details . STRNEWLINE ▁ : license : ▁ BSD , ▁ see ▁ LICENSE ▁ for ▁ more ▁ details . STRNEWLINE """ NEW_LINE import os NEW_LINE import sys NEW_LINE import pytest NEW_LINE import flask NEW_LINE from flask . _compat import PY2 NEW_LINE def test_explicit_instance_paths ( modules_tmpdir ) : NEW_LINE INDENT with pytest . raises ( ValueError ) as excinfo : NEW_LINE INDENT flask . Flask ( __name__ , instance_path = ' instance ' ) NEW_LINE DEDENT assert ' must ▁ be ▁ absolute ' in str ( excinfo . value ) NEW_LINE app = flask . Flask ( __name__ , instance_path = str ( modules_tmpdir ) ) NEW_LINE assert app . instance_path == str ( modules_tmpdir ) NEW_LINE DEDENT def test_main_module_paths ( modules_tmpdir , purge_module ) : NEW_LINE INDENT app = modules_tmpdir . join ( ' main _ app . py ' ) NEW_LINE app . write ( ' import ▁ flask \n \n app ▁ = ▁ flask . Flask ( " _ _ main _ _ " ) ' ) NEW_LINE purge_module ( ' main _ app ' ) NEW_LINE from main_app import app NEW_LINE here = os . path . abspath ( os . getcwd ( ) ) NEW_LINE assert app . instance_path == os . path . join ( here , ' instance ' ) NEW_LINE DEDENT def test_uninstalled_module_paths ( modules_tmpdir , purge_module ) : NEW_LINE INDENT app = modules_tmpdir . join ( ' config _ module _ app . py ' ) . write ( ' import ▁ os \n ' ' import ▁ flask \n ' ' here ▁ = ▁ os . path . abspath ( os . path . dirname ( _ _ file _ _ ) ) \n ' ' app ▁ = ▁ flask . Flask ( _ _ name _ _ ) \n ' ) NEW_LINE purge_module ( ' config _ module _ app ' ) NEW_LINE from config_module_app import app NEW_LINE assert app . instance_path == str ( modules_tmpdir . join ( ' instance ' ) ) NEW_LINE DEDENT def test_uninstalled_package_paths ( modules_tmpdir , purge_module ) : NEW_LINE INDENT app = modules_tmpdir . mkdir ( ' config _ package _ app ' ) NEW_LINE init = app . join ( ' _ _ init _ _ . py ' ) NEW_LINE init . write ( ' import ▁ os \n ' ' import ▁ flask \n ' ' here ▁ = ▁ os . path . abspath ( os . path . dirname ( _ _ file _ _ ) ) \n ' ' app ▁ = ▁ flask . Flask ( _ _ name _ _ ) \n ' ) NEW_LINE purge_module ( ' config _ package _ app ' ) NEW_LINE from config_package_app import app NEW_LINE assert app . instance_path == str ( modules_tmpdir . join ( ' instance ' ) ) NEW_LINE DEDENT def test_installed_module_paths ( modules_tmpdir , modules_tmpdir_prefix , purge_module , site_packages , limit_loader ) : NEW_LINE INDENT site_packages . join ( ' site _ app . py ' ) . write ( ' import ▁ flask \n ' ' app ▁ = ▁ flask . Flask ( _ _ name _ _ ) \n ' ) NEW_LINE purge_module ( ' site _ app ' ) NEW_LINE from site_app import app NEW_LINE assert app . instance_path == modules_tmpdir . join ( ' var ' ) . join ( ' site _ app - instance ' ) NEW_LINE DEDENT def test_installed_package_paths ( limit_loader , modules_tmpdir , modules_tmpdir_prefix , purge_module , monkeypatch ) : NEW_LINE INDENT installed_path = modules_tmpdir . mkdir ( ' path ' ) NEW_LINE monkeypatch . syspath_prepend ( installed_path ) NEW_LINE app = installed_path . mkdir ( ' installed _ package ' ) NEW_LINE init = app . join ( ' _ _ init _ _ . py ' ) NEW_LINE init . write ( ' import ▁ flask \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE purge_module ( ' installed _ package ' ) NEW_LINE from installed_package import app NEW_LINE assert app . instance_path == modules_tmpdir . join ( ' var ' ) . join ( ' installed _ package - instance ' ) NEW_LINE DEDENT def test_prefix_package_paths ( limit_loader , modules_tmpdir , modules_tmpdir_prefix , purge_module , site_packages ) : NEW_LINE INDENT app = site_packages . mkdir ( ' site _ package ' ) NEW_LINE init = app . join ( ' _ _ init _ _ . py ' ) NEW_LINE init . write ( ' import ▁ flask \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE purge_module ( ' site _ package ' ) NEW_LINE import site_package NEW_LINE assert site_package . app . instance_path == modules_tmpdir . join ( ' var ' ) . join ( ' site _ package - instance ' ) NEW_LINE DEDENT def test_egg_installed_paths ( install_egg , modules_tmpdir , modules_tmpdir_prefix ) : NEW_LINE INDENT modules_tmpdir . mkdir ( ' site _ egg ' ) . join ( ' _ _ init _ _ . py ' ) . write ( ' import ▁ flask \n \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE install_egg ( ' site _ egg ' ) NEW_LINE try : NEW_LINE INDENT import site_egg NEW_LINE assert site_egg . app . instance_path == str ( modules_tmpdir . join ( ' var / ' ) . join ( ' site _ egg - instance ' ) ) NEW_LINE DEDENT finally : NEW_LINE INDENT if ' site _ egg ' in sys . modules : NEW_LINE INDENT del sys . modules [ ' site _ egg ' ] NEW_LINE DEDENT DEDENT DEDENT @ pytest . mark . skipif ( not PY2 , reason = ' This ▁ only ▁ works ▁ under ▁ Python ▁ 2 . ' ) NEW_LINE def test_meta_path_loader_without_is_package ( request , modules_tmpdir ) : NEW_LINE INDENT app = modules_tmpdir . join ( ' unimportable . py ' ) NEW_LINE app . write ( ' import ▁ flask \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE class Loader ( object ) : NEW_LINE INDENT def find_module ( self , name , path = None ) : NEW_LINE INDENT return self NEW_LINE DEDENT DEDENT sys . meta_path . append ( Loader ( ) ) NEW_LINE request . addfinalizer ( sys . meta_path . pop ) NEW_LINE with pytest . raises ( AttributeError ) : NEW_LINE INDENT import unimportable NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="dragonpt/Kernel_3.4.67_KK_Wiko_DarkMoon/tree/master/tools/perf/scripts/python/futex-contention.py"> # ▁ futex ▁ contention ENDCOM # ▁ ( c ) ▁ 2010 , ▁ Arnaldo ▁ Carvalho ▁ de ▁ Melo ▁ < acme @ redhat . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Translation ▁ of : ENDCOM # ▁ http : / / sourceware . org / systemtap / wiki / WSFutexContention ENDCOM # ▁ to ▁ perf ▁ python ▁ scripting . ENDCOM # ▁ Measures ▁ futex ▁ contention ENDCOM import os , sys NEW_LINE sys . path . append ( os . environ [ ' PERF _ EXEC _ PATH ' ] + ' / scripts / python / Perf - Trace - Util / lib / Perf / Trace ' ) NEW_LINE from Util import * NEW_LINE process_names = { } NEW_LINE thread_thislock = { } NEW_LINE thread_blocktime = { } NEW_LINE lock_waits = { } # ▁ long - lived ▁ stats ▁ on ▁ ( tid , lock ) ▁ blockage ▁ elapsed ▁ time ENDCOM NEW_LINE process_names = { } # ▁ long - lived ▁ pid - to - execname ▁ mapping ENDCOM NEW_LINE def syscalls__sys_enter_futex ( event , ctxt , cpu , s , ns , tid , comm , nr , uaddr , op , val , utime , uaddr2 , val3 ) : NEW_LINE INDENT cmd = op & FUTEX_CMD_MASK NEW_LINE if cmd != FUTEX_WAIT : NEW_LINE INDENT return # ▁ we ▁ don ' t ▁ care ▁ about ▁ originators ▁ of ▁ WAKE ▁ events ENDCOM NEW_LINE DEDENT process_names [ tid ] = comm NEW_LINE thread_thislock [ tid ] = uaddr NEW_LINE thread_blocktime [ tid ] = nsecs ( s , ns ) NEW_LINE DEDENT def syscalls__sys_exit_futex ( event , ctxt , cpu , s , ns , tid , comm , nr , ret ) : NEW_LINE INDENT if thread_blocktime . has_key ( tid ) : NEW_LINE INDENT elapsed = nsecs ( s , ns ) - thread_blocktime [ tid ] NEW_LINE add_stats ( lock_waits , ( tid , thread_thislock [ tid ] ) , elapsed ) NEW_LINE del thread_blocktime [ tid ] NEW_LINE del thread_thislock [ tid ] NEW_LINE DEDENT DEDENT def trace_begin ( ) : NEW_LINE INDENT print " Press ▁ control + C ▁ to ▁ stop ▁ and ▁ show ▁ the ▁ summary " NEW_LINE DEDENT def trace_end ( ) : NEW_LINE INDENT for ( tid , lock ) in lock_waits : NEW_LINE INDENT min , max , avg , count = lock_waits [ tid , lock ] NEW_LINE print " % s [ % d ] ▁ lock ▁ % x ▁ contended ▁ % d ▁ times , ▁ % d ▁ avg ▁ ns " % ( process_names [ tid ] , tid , lock , count , avg ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="travisdesell/csg_boinc/tree/master/test/cgiserver.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ $ Id $ ENDCOM # ▁ cgi / php ▁ web ▁ server ENDCOM import BaseHTTPServer , CGIHTTPServer NEW_LINE import sys , os , urllib , select NEW_LINE import random , time # ▁ XXX ENDCOM NEW_LINE php_path = None NEW_LINE possible_php_paths = [ ' / usr / lib / cgi - bin / php4' , ' PROGRAM _ PATH / fake _ php . py ' ] NEW_LINE def setup_php ( program_path ) : NEW_LINE INDENT global php_path NEW_LINE for p in possible_php_paths : NEW_LINE INDENT p = p . replace ( ' PROGRAM _ PATH ' , program_path ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT php_path = p NEW_LINE return NEW_LINE DEDENT DEDENT raise Exception ( " No ▁ php ▁ binary ▁ found ▁ - ▁ not ▁ even ▁ fake _ php . py ▁ ( program _ path = % s ) ▁ ! " % program_path ) NEW_LINE DEDENT class PHPHTTPRequestHandler ( CGIHTTPServer . CGIHTTPRequestHandler ) : NEW_LINE INDENT def is_cgi ( self ) : NEW_LINE INDENT if os . path . split ( self . path ) [ 1 ] == ' ' : NEW_LINE INDENT index_php = os . path . join ( self . path , ' index . php ' ) NEW_LINE if os . path . exists ( self . translate_path ( index_php ) ) : NEW_LINE INDENT self . path = index_php NEW_LINE DEDENT DEDENT if self . path . find ( ' . php ' ) != - 1 : NEW_LINE INDENT self . cgi_info = os . path . split ( self . path ) NEW_LINE return True NEW_LINE DEDENT for p in self . cgi_directories : NEW_LINE INDENT p = os . path . join ( p , ' ' ) NEW_LINE if self . path . startswith ( p ) : NEW_LINE INDENT self . cgi_info = os . path . split ( self . path ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def run_cgi ( self ) : NEW_LINE INDENT """ Execute ▁ a ▁ CGI ▁ script . """ NEW_LINE dir , rest = self . cgi_info NEW_LINE i = rest . rfind ( ' ? ' ) NEW_LINE if i >= 0 : NEW_LINE INDENT rest , query = rest [ : i ] , rest [ i + 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT query = ' ' NEW_LINE DEDENT i = rest . find ( ' / ' ) NEW_LINE if i >= 0 : NEW_LINE INDENT script , rest = rest [ : i ] , rest [ i : ] NEW_LINE DEDENT else : NEW_LINE INDENT script , rest = rest , ' ' NEW_LINE DEDENT scriptname = dir + ' / ' + script NEW_LINE is_php = script . endswith ( ' . php ' ) NEW_LINE # ▁ print ▁ " # # # # ▁ cgi _ info = % s , dir = % s , rest = % s , script = % s , scriptname = % s , is _ php = % s " % ( self . cgi _ info , dir , rest , script , scriptname , is _ php ) ENDCOM if is_php : NEW_LINE INDENT if not php_path : raise Exception ( ' php _ path ▁ not ▁ set ' ) NEW_LINE scriptfile = php_path NEW_LINE sourcefile = self . translate_path ( scriptname ) NEW_LINE DEDENT else : NEW_LINE INDENT scriptfile = self . translate_path ( scriptname ) NEW_LINE DEDENT if not os . path . exists ( scriptfile ) : NEW_LINE INDENT self . send_error ( 404 , " No ▁ such ▁ CGI ▁ script ▁ ( % s ) " %   ` scriptname ` ) NEW_LINE return NEW_LINE DEDENT if not os . path . isfile ( scriptfile ) : NEW_LINE INDENT self . send_error ( 403 , " CGI ▁ script ▁ is ▁ not ▁ a ▁ plain ▁ file ▁ ( % s ) " %                                                         ` scriptname ` ) NEW_LINE return NEW_LINE DEDENT ispy = self . is_python ( scriptname ) NEW_LINE if not ispy : NEW_LINE INDENT if not ( self . have_fork or self . have_popen2 or self . have_popen3 ) : NEW_LINE INDENT self . send_error ( 403 , " CGI ▁ script ▁ is ▁ not ▁ a ▁ Python ▁ script ▁ ( % s ) " %                                                                 ` scriptname ` ) NEW_LINE return NEW_LINE DEDENT if not self . is_executable ( scriptfile ) : NEW_LINE INDENT self . send_error ( 403 , " CGI ▁ script ▁ is ▁ not ▁ executable ▁ ( % s ) " %                                                                 ` scriptname ` ) NEW_LINE return NEW_LINE # ▁ Reference : ▁ http : / / hoohoo . ncsa . uiuc . edu / cgi / env . html ENDCOM # ▁ XXX ▁ Much ▁ of ▁ the ▁ following ▁ could ▁ be ▁ prepared ▁ ahead ▁ of ▁ time ! ENDCOM DEDENT DEDENT env = { } NEW_LINE env [ ' DOCUMENT _ ROOT ' ] = os . getcwd ( ) NEW_LINE env [ ' SERVER _ SOFTWARE ' ] = self . version_string ( ) NEW_LINE env [ ' SERVER _ NAME ' ] = self . server . server_name NEW_LINE env [ ' GATEWAY _ INTERFACE ' ] = ' CGI / 1.1' NEW_LINE env [ ' SERVER _ PROTOCOL ' ] = self . protocol_version NEW_LINE env [ ' SERVER _ PORT ' ] = str ( self . server . server_port ) NEW_LINE env [ ' REQUEST _ METHOD ' ] = self . command NEW_LINE uqrest = urllib . unquote ( self . cgi_info [ 1 ] ) NEW_LINE env [ ' REQUEST _ URI ' ] = self . path NEW_LINE # ▁ env [ ' PATH _ INFO ' ] ▁ = ▁ uqrest ENDCOM # ▁ env [ ' PATH _ TRANSLATED ' ] ▁ = ▁ self . translate _ path ( uqrest ) ENDCOM env [ ' SCRIPT _ NAME ' ] = scriptname NEW_LINE env [ ' SCRIPT _ FILENAME ' ] = self . translate_path ( scriptname ) NEW_LINE if query : NEW_LINE INDENT env [ ' QUERY _ STRING ' ] = query NEW_LINE DEDENT host = self . address_string ( ) NEW_LINE if host != self . client_address [ 0 ] : NEW_LINE INDENT env [ ' REMOTE _ HOST ' ] = host NEW_LINE DEDENT env [ ' REMOTE _ ADDR ' ] = self . client_address [ 0 ] NEW_LINE env [ ' REDIRECT _ STATUS ' ] = '1' # ▁ for ▁ php ENDCOM NEW_LINE # ▁ XXX ▁ AUTH _ TYPE ENDCOM # ▁ XXX ▁ REMOTE _ USER ENDCOM # ▁ XXX ▁ REMOTE _ IDENT ENDCOM if self . headers . typeheader is None : NEW_LINE INDENT env [ ' CONTENT _ TYPE ' ] = self . headers . type NEW_LINE DEDENT else : NEW_LINE INDENT env [ ' CONTENT _ TYPE ' ] = self . headers . typeheader NEW_LINE DEDENT length = self . headers . getheader ( ' content - length ' ) NEW_LINE if length : NEW_LINE INDENT env [ ' CONTENT _ LENGTH ' ] = length NEW_LINE DEDENT accept = [ ] NEW_LINE for line in self . headers . getallmatchingheaders ( ' accept ' ) : NEW_LINE INDENT if line [ : 1 ] in " \t \n ▁ " : NEW_LINE INDENT accept . append ( line . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT accept = accept + line [ 7 : ] . split ( ' , ' ) NEW_LINE DEDENT DEDENT env [ ' HTTP _ ACCEPT ' ] = ' , ' . join ( accept ) NEW_LINE ua = self . headers . getheader ( ' user - agent ' ) NEW_LINE if ua : NEW_LINE INDENT env [ ' HTTP _ USER _ AGENT ' ] = ua NEW_LINE DEDENT co = filter ( None , self . headers . getheaders ( ' cookie ' ) ) NEW_LINE if co : NEW_LINE INDENT env [ ' HTTP _ COOKIE ' ] = ' , ▁ ' . join ( co ) NEW_LINE # ▁ XXX ▁ Other ▁ HTTP _ * ▁ headers ENDCOM DEDENT if not self . have_fork : NEW_LINE # ▁ Since ▁ we ' re ▁ setting ▁ the ▁ env ▁ in ▁ the ▁ parent , ▁ provide ▁ empty ENDCOM # ▁ values ▁ to ▁ override ▁ previously ▁ set ▁ values ENDCOM INDENT for k in ( ' QUERY _ STRING ' , ' REMOTE _ HOST ' , ' CONTENT _ LENGTH ' , ' HTTP _ USER _ AGENT ' , ' HTTP _ COOKIE ' ) : NEW_LINE INDENT env . setdefault ( k , " " ) NEW_LINE DEDENT DEDENT os . environ . update ( env ) NEW_LINE self . send_response ( 200 , " Script ▁ output ▁ follows " ) NEW_LINE decoded_query = query . replace ( ' + ' , ' ▁ ' ) NEW_LINE if self . have_fork : NEW_LINE # ▁ Unix ▁ - - ▁ fork ▁ as ▁ we ▁ should ENDCOM INDENT if is_php : NEW_LINE INDENT args = [ php_path , sourcefile ] NEW_LINE DEDENT else : NEW_LINE INDENT args = [ script ] NEW_LINE DEDENT if ' = ' not in decoded_query : NEW_LINE INDENT args . append ( decoded_query ) NEW_LINE DEDENT self . wfile . flush ( ) # ▁ Always ▁ flush ▁ before ▁ forking ENDCOM NEW_LINE pid = os . fork ( ) NEW_LINE if pid != 0 : NEW_LINE # ▁ Parent ENDCOM INDENT pid , sts = os . waitpid ( pid , 0 ) NEW_LINE # ▁ throw ▁ away ▁ additional ▁ data ▁ [ see ▁ bug ▁ # 427345 ] ENDCOM while select . select ( [ self . rfile ] , [ ] , [ ] , 0 ) [ 0 ] : NEW_LINE INDENT try : NEW_LINE INDENT if not self . rfile . read ( 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if sts : NEW_LINE INDENT self . log_error ( " CGI ▁ script ▁ exit ▁ status ▁ % # x " , sts ) NEW_LINE DEDENT return NEW_LINE # ▁ Child ENDCOM DEDENT try : NEW_LINE INDENT if 0 : NEW_LINE INDENT time . sleep ( .1 ) NEW_LINE fn = ' / tmp / a % d ' % random . randint ( 1000 , 10000 ) NEW_LINE f = open ( fn , ' w ' ) NEW_LINE s = ' ' NEW_LINE while select . select ( [ self . rfile ] , [ ] , [ ] , 0 ) [ 0 ] : NEW_LINE INDENT try : NEW_LINE INDENT c = self . rfile . read ( 1 ) NEW_LINE if not c : NEW_LINE INDENT break NEW_LINE DEDENT s += c NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ' # # # ▁ input : ' , repr ( s ) NEW_LINE print >> f , s NEW_LINE f . close ( ) NEW_LINE self . rfile = open ( fn , ' r ' ) NEW_LINE DEDENT os . dup2 ( self . rfile . fileno ( ) , 0 ) NEW_LINE os . dup2 ( self . wfile . fileno ( ) , 1 ) NEW_LINE os . chdir ( self . translate_path ( dir ) ) # ▁ KC ENDCOM NEW_LINE os . execve ( scriptfile , args , os . environ ) NEW_LINE DEDENT except : NEW_LINE INDENT self . server . handle_error ( self . request , self . client_address ) NEW_LINE os . _exit ( 127 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT raise SystemExit ( ' need ▁ fork ( ) ' ) NEW_LINE DEDENT DEDENT DEDENT def serve ( bind = ' localhost ' , port = 8000 , handler = PHPHTTPRequestHandler ) : NEW_LINE INDENT httpd = BaseHTTPServer . HTTPServer ( ( bind , port ) , handler ) NEW_LINE httpd . serve_forever ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT setup_php ( os . path . realpath ( os . path . dirname ( sys . argv [ 0 ] ) ) ) NEW_LINE serve ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="Thhhza/XlsxWriter/tree/master/xlsxwriter/test/comparison/test_chart_column04.py"> # ▁ Tests ▁ for ▁ XlsxWriter . ENDCOM # ▁ Copyright ▁ ( c ) , ▁ 2013-2015 , ▁ John ▁ McNamara , ▁ jmcnamara @ cpan . org ENDCOM from . . excel_comparsion_test import ExcelComparisonTest NEW_LINE from ... workbook import Workbook NEW_LINE class TestCompareXLSXFiles ( ExcelComparisonTest ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ file ▁ created ▁ by ▁ XlsxWriter ▁ against ▁ a ▁ file ▁ created ▁ by ▁ Excel . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def setUp ( self ) : NEW_LINE INDENT self . maxDiff = None NEW_LINE filename = ' chart _ column04 . xlsx ' NEW_LINE test_dir = ' xlsxwriter / test / comparison / ' NEW_LINE self . got_filename = test_dir + ' _ test _ ' + filename NEW_LINE self . exp_filename = test_dir + ' xlsx _ files / ' + filename NEW_LINE self . ignore_files = [ ] NEW_LINE self . ignore_elements = { ' xl / workbook . xml ' : [ ' < fileVersion ' , ' < calcPr ' ] } NEW_LINE DEDENT def test_create_file ( self ) : NEW_LINE INDENT """ Test ▁ the ▁ creation ▁ of ▁ a ▁ simple ▁ XlsxWriter ▁ file . """ NEW_LINE workbook = Workbook ( self . got_filename ) NEW_LINE worksheet = workbook . add_worksheet ( ) NEW_LINE chart = workbook . add_chart ( { ' type ' : ' column ' } ) NEW_LINE chart . axis_ids = [ 63591936 , 63593856 ] NEW_LINE chart . axis2_ids = [ 63613568 , 63612032 ] NEW_LINE data = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 8 , 6 , 4 , 2 ] ] NEW_LINE worksheet . write_column ( ' A1' , data [ 0 ] ) NEW_LINE worksheet . write_column ( ' B1' , data [ 1 ] ) NEW_LINE chart . add_series ( { ' values ' : ' = Sheet1 ! $ A $ 1 : $ A $ 5' } ) NEW_LINE chart . add_series ( { ' values ' : ' = Sheet1 ! $ B $ 1 : $ B $ 5' , ' y2 _ axis ' : 1 } ) NEW_LINE worksheet . insert_chart ( ' E9' , chart ) NEW_LINE workbook . close ( ) NEW_LINE self . assertExcelEqual ( ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="w1ll1am23/home-assistant/tree/master/homeassistant/components/homematicip_cloud/weather.py"> """ Support ▁ for ▁ HomematicIP ▁ Cloud ▁ weather ▁ devices . """ NEW_LINE import logging NEW_LINE from homematicip . aio . device import ( AsyncWeatherSensor , AsyncWeatherSensorPlus , AsyncWeatherSensorPro ) NEW_LINE from homematicip . aio . home import AsyncHome NEW_LINE from homeassistant . components . weather import WeatherEntity NEW_LINE from homeassistant . config_entries import ConfigEntry NEW_LINE from homeassistant . const import TEMP_CELSIUS NEW_LINE from homeassistant . core import HomeAssistant NEW_LINE from . import DOMAIN as HMIPC_DOMAIN , HMIPC_HAPID , HomematicipGenericDevice NEW_LINE _LOGGER = logging . getLogger ( __name__ ) NEW_LINE async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : NEW_LINE INDENT """ Set ▁ up ▁ the ▁ HomematicIP ▁ Cloud ▁ weather ▁ sensor . """ NEW_LINE pass NEW_LINE DEDENT async def async_setup_entry ( hass : HomeAssistant , config_entry : ConfigEntry , async_add_entities ) -> None : NEW_LINE INDENT """ Set ▁ up ▁ the ▁ HomematicIP ▁ weather ▁ sensor ▁ from ▁ a ▁ config ▁ entry . """ NEW_LINE home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home NEW_LINE devices = [ ] NEW_LINE for device in home . devices : NEW_LINE INDENT if isinstance ( device , AsyncWeatherSensorPro ) : NEW_LINE INDENT devices . append ( HomematicipWeatherSensorPro ( home , device ) ) NEW_LINE DEDENT elif isinstance ( device , ( AsyncWeatherSensor , AsyncWeatherSensorPlus ) ) : NEW_LINE INDENT devices . append ( HomematicipWeatherSensor ( home , device ) ) NEW_LINE DEDENT DEDENT if devices : NEW_LINE INDENT async_add_entities ( devices ) NEW_LINE DEDENT DEDENT class HomematicipWeatherSensor ( HomematicipGenericDevice , WeatherEntity ) : NEW_LINE INDENT """ representation ▁ of ▁ a ▁ HomematicIP ▁ Cloud ▁ weather ▁ sensor ▁ plus ▁ & ▁ basic . """ NEW_LINE def __init__ ( self , home : AsyncHome , device ) -> None : NEW_LINE INDENT """ Initialize ▁ the ▁ weather ▁ sensor . """ NEW_LINE super ( ) . __init__ ( home , device ) NEW_LINE DEDENT @ property NEW_LINE def name ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ name ▁ of ▁ the ▁ sensor . """ NEW_LINE return self . _device . label NEW_LINE DEDENT @ property NEW_LINE def temperature ( self ) -> float : NEW_LINE INDENT """ Return ▁ the ▁ platform ▁ temperature . """ NEW_LINE return self . _device . actualTemperature NEW_LINE DEDENT @ property NEW_LINE def temperature_unit ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ unit ▁ of ▁ measurement . """ NEW_LINE return TEMP_CELSIUS NEW_LINE DEDENT @ property NEW_LINE def humidity ( self ) -> int : NEW_LINE INDENT """ Return ▁ the ▁ humidity . """ NEW_LINE return self . _device . humidity NEW_LINE DEDENT @ property NEW_LINE def wind_speed ( self ) -> float : NEW_LINE INDENT """ Return ▁ the ▁ wind ▁ speed . """ NEW_LINE return self . _device . windSpeed NEW_LINE DEDENT @ property NEW_LINE def attribution ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ attribution . """ NEW_LINE return " Powered ▁ by ▁ Homematic ▁ IP " NEW_LINE DEDENT @ property NEW_LINE def condition ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ current ▁ condition . """ NEW_LINE if hasattr ( self . _device , " raining " ) and self . _device . raining : NEW_LINE INDENT return ' rainy ' NEW_LINE DEDENT if self . _device . storm : NEW_LINE INDENT return ' windy ' NEW_LINE DEDENT if self . _device . sunshine : NEW_LINE INDENT return ' sunny ' NEW_LINE DEDENT return ' ' NEW_LINE DEDENT DEDENT class HomematicipWeatherSensorPro ( HomematicipWeatherSensor ) : NEW_LINE INDENT """ representation ▁ of ▁ a ▁ HomematicIP ▁ weather ▁ sensor ▁ pro . """ NEW_LINE @ property NEW_LINE def wind_bearing ( self ) -> float : NEW_LINE INDENT """ Return ▁ the ▁ wind ▁ bearing . """ NEW_LINE return self . _device . windDirection NEW_LINE DEDENT DEDENT </DOCUMENT>
