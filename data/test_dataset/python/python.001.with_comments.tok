<DOCUMENT_ID="FHannes/intellij-community/tree/master/python/testData/intentions/returnTypeInPy3Annotation2_after.py"> def my_func ( p1 = 1 ) -> object : NEW_LINE INDENT return p1 NEW_LINE DEDENT d = my_func ( 1 ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="apocquet/django/tree/master/django/contrib/gis/db/models/sql/conversion.py"> """ STRNEWLINE This ▁ module ▁ holds ▁ simple ▁ classes ▁ to ▁ convert ▁ geospatial ▁ values ▁ from ▁ the STRNEWLINE database . STRNEWLINE """ NEW_LINE from django . contrib . gis . db . models . fields import GeoSelectFormatMixin NEW_LINE from django . contrib . gis . geometry . backend import Geometry NEW_LINE from django . contrib . gis . measure import Area , Distance NEW_LINE class BaseField ( object ) : NEW_LINE INDENT empty_strings_allowed = True NEW_LINE def get_db_converters ( self , connection ) : NEW_LINE INDENT return [ self . from_db_value ] NEW_LINE DEDENT def select_format ( self , compiler , sql , params ) : NEW_LINE INDENT return sql , params NEW_LINE DEDENT DEDENT class AreaField ( BaseField ) : NEW_LINE INDENT " Wrapper ▁ for ▁ Area ▁ values . " NEW_LINE def __init__ ( self , area_att ) : NEW_LINE INDENT self . area_att = area_att NEW_LINE DEDENT def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT if value is not None : NEW_LINE INDENT value = Area ( ** { self . area_att : value } ) NEW_LINE DEDENT return value NEW_LINE DEDENT def get_internal_type ( self ) : NEW_LINE INDENT return ' AreaField ' NEW_LINE DEDENT DEDENT class DistanceField ( BaseField ) : NEW_LINE INDENT " Wrapper ▁ for ▁ Distance ▁ values . " NEW_LINE def __init__ ( self , distance_att ) : NEW_LINE INDENT self . distance_att = distance_att NEW_LINE DEDENT def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT if value is not None : NEW_LINE INDENT value = Distance ( ** { self . distance_att : value } ) NEW_LINE DEDENT return value NEW_LINE DEDENT def get_internal_type ( self ) : NEW_LINE INDENT return ' DistanceField ' NEW_LINE DEDENT DEDENT class GeomField ( GeoSelectFormatMixin , BaseField ) : NEW_LINE INDENT """ STRNEWLINE ▁ Wrapper ▁ for ▁ Geometry ▁ values . ▁ It ▁ is ▁ a ▁ lightweight ▁ alternative ▁ to STRNEWLINE ▁ using ▁ GeometryField ▁ ( which ▁ requires ▁ an ▁ SQL ▁ query ▁ upon ▁ instantiation ) . STRNEWLINE ▁ """ NEW_LINE # ▁ Hacky ▁ marker ▁ for ▁ get _ db _ converters ( ) ENDCOM geom_type = None NEW_LINE def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT if value is not None : NEW_LINE INDENT value = Geometry ( value ) NEW_LINE DEDENT return value NEW_LINE DEDENT def get_internal_type ( self ) : NEW_LINE INDENT return ' GeometryField ' NEW_LINE DEDENT DEDENT class GMLField ( BaseField ) : NEW_LINE INDENT """ STRNEWLINE ▁ Wrapper ▁ for ▁ GML ▁ to ▁ be ▁ used ▁ by ▁ Oracle ▁ to ▁ ensure ▁ Database . LOB ▁ conversion . STRNEWLINE ▁ """ NEW_LINE def get_internal_type ( self ) : NEW_LINE INDENT return ' GMLField ' NEW_LINE DEDENT def from_db_value ( self , value , expression , connection , context ) : NEW_LINE INDENT return value NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="chenlian2015/skia_from_google/tree/master/tools/skp/page_sets/skia_youtube_desktop.py"> # ▁ Copyright ▁ 2014 ▁ The ▁ Chromium ▁ Authors . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ▁ license ▁ that ▁ can ▁ be ENDCOM # ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . ENDCOM # ▁ pylint : ▁ disable = W0401 , W0614 ENDCOM from telemetry . page import page as page_module NEW_LINE from telemetry . page import page_set as page_set_module NEW_LINE class SkiaBuildbotDesktopPage ( page_module . Page ) : NEW_LINE INDENT def __init__ ( self , url , page_set ) : NEW_LINE INDENT super ( SkiaBuildbotDesktopPage , self ) . __init__ ( url = url , page_set = page_set , credentials_path = ' data / credentials . json ' ) NEW_LINE self . user_agent_type = ' desktop ' NEW_LINE self . archive_data_file = ' data / skia _ youtube _ desktop . json ' NEW_LINE DEDENT def RunNavigateSteps ( self , action_runner ) : NEW_LINE INDENT action_runner . NavigateToPage ( self ) NEW_LINE action_runner . Wait ( 25 ) NEW_LINE DEDENT DEDENT class SkiaYoutubeDesktopPageSet ( page_set_module . PageSet ) : NEW_LINE INDENT """ ▁ Pages ▁ designed ▁ to ▁ represent ▁ the ▁ median , ▁ not ▁ highly ▁ optimized ▁ web ▁ """ NEW_LINE def __init__ ( self ) : NEW_LINE INDENT super ( SkiaYoutubeDesktopPageSet , self ) . __init__ ( user_agent_type = ' desktop ' , archive_data_file = ' data / skia _ youtube _ desktop . json ' ) NEW_LINE urls_list = [ # ▁ Why : ▁ # 3 ▁ ( Alexa ▁ global ) ENDCOM ' http : / / www . youtube . com / watch ? v = PC57z - oDPLs ' , ] NEW_LINE for url in urls_list : NEW_LINE INDENT self . AddPage ( SkiaBuildbotDesktopPage ( url , self ) ) NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="mluo613/osf.io/tree/master/scripts/update_comments.py"> """ STRNEWLINE Update ▁ User . comments _ viewed _ timestamp ▁ field . STRNEWLINE """ NEW_LINE import logging NEW_LINE import sys NEW_LINE from modularodm import Q NEW_LINE from framework . auth . core import User NEW_LINE from framework . transactions . context import TokuTransaction NEW_LINE from website . models import Comment NEW_LINE from website . app import init_app NEW_LINE from scripts import utils as script_utils NEW_LINE logger = logging . getLogger ( __name__ ) NEW_LINE def main ( ) : NEW_LINE INDENT update_comments_viewed_timestamp ( ) NEW_LINE DEDENT def update_comments_viewed_timestamp ( ) : NEW_LINE INDENT users = User . find ( Q ( ' comments _ viewed _ timestamp ' , ' ne ' , None ) & Q ( ' comments _ viewed _ timestamp ' , ' ne ' , { } ) ) NEW_LINE for user in users : NEW_LINE INDENT if user . comments_viewed_timestamp : NEW_LINE INDENT timestamps = { } NEW_LINE for node_id in user . comments_viewed_timestamp : NEW_LINE INDENT node_timestamps = user . comments_viewed_timestamp [ node_id ] NEW_LINE # ▁ node ▁ timestamp ENDCOM if node_timestamps . get ( ' node ' , None ) : NEW_LINE INDENT timestamps [ node_id ] = node_timestamps [ ' node ' ] NEW_LINE # ▁ file ▁ timestamps ENDCOM DEDENT file_timestamps = node_timestamps . get ( ' files ' , None ) NEW_LINE if file_timestamps : NEW_LINE INDENT for file_id in file_timestamps : NEW_LINE INDENT timestamps [ file_id ] = file_timestamps [ file_id ] NEW_LINE DEDENT DEDENT DEDENT user . comments_viewed_timestamp = timestamps NEW_LINE user . save ( ) NEW_LINE logger . info ( ' Migrated ▁ timestamp ▁ for ▁ user ▁ { 0 } ' . format ( user . _id ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT dry = ' - - dry ' in sys . argv NEW_LINE if not dry : NEW_LINE INDENT script_utils . add_file_logger ( logger , __file__ ) NEW_LINE DEDENT init_app ( routes = False , set_backends = True ) NEW_LINE with TokuTransaction ( ) : NEW_LINE INDENT main ( ) NEW_LINE if dry : NEW_LINE INDENT raise Exception ( ' Dry ▁ Run ▁ - - ▁ Aborting ▁ Transaction ' ) NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="voidcc/PCTRL/tree/master/tests/unit/lib/mock_socket_test.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ 2011-2012 ▁ Andreas ▁ Wundsam ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ENDCOM # ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM # ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at : ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM # ▁ limitations ▁ under ▁ the ▁ License . ENDCOM import unittest NEW_LINE import sys NEW_LINE import os . path NEW_LINE from copy import copy NEW_LINE sys . path . append ( os . path . dirname ( __file__ ) + " / . . / . . / . . " ) NEW_LINE from pox . lib . mock_socket import MockSocket NEW_LINE class MockSocketTest ( unittest . TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def test_simple_send ( self ) : NEW_LINE INDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertEquals ( b . recv ( ) , " Hallo " ) NEW_LINE b . send ( " Servus " ) NEW_LINE self . assertEquals ( a . recv ( ) , " Servus " ) NEW_LINE DEDENT def test_ready_to_recv ( self ) : NEW_LINE INDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE self . assertTrue ( b . ready_to_recv ( ) ) NEW_LINE self . assertEquals ( b . recv ( ) , " Hallo " ) NEW_LINE self . assertFalse ( b . ready_to_recv ( ) ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE b . send ( " Servus " ) NEW_LINE self . assertTrue ( a . ready_to_recv ( ) ) NEW_LINE self . assertEquals ( a . recv ( ) , " Servus " ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE DEDENT def test_on_ready_to_recv ( self ) : NEW_LINE INDENT self . seen_size = - 1 NEW_LINE self . called = 0 NEW_LINE def ready ( socket , size ) : NEW_LINE INDENT self . called += 1 NEW_LINE self . seen_size = size NEW_LINE DEDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE b . set_on_ready_to_recv ( ready ) NEW_LINE self . assertEquals ( self . called , 0 ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertEquals ( self . called , 1 ) NEW_LINE self . assertEquals ( self . seen_size , 5 ) NEW_LINE # ▁ check ▁ that ▁ it ▁ doesn ' t ▁ get ▁ called ▁ on ▁ the ▁ other ▁ sockets ▁ data ENDCOM b . send ( " Huhu " ) NEW_LINE self . assertEquals ( self . called , 1 ) NEW_LINE DEDENT def test_empty_recv ( self ) : NEW_LINE INDENT """ ▁ test _ empty _ recv : ▁ Check ▁ that ▁ empty ▁ reads ▁ on ▁ socket ▁ return ▁ " " STRNEWLINE ▁ Note ▁ that ▁ this ▁ is ▁ actually ▁ non - sockety ▁ behavior ▁ and ▁ should ▁ probably ▁ be ▁ changed . ▁ This STRNEWLINE ▁ test ▁ documents ▁ it ▁ as ▁ intended ▁ for ▁ now , ▁ though STRNEWLINE ▁ """ NEW_LINE ( a , b ) = MockSocket . pair ( ) NEW_LINE self . assertEquals ( a . recv ( ) , " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT unittest . main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="txemi/ansible/tree/master/test/units/parsing/yaml/test_dumper.py"> # ▁ coding : ▁ utf - 8 ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Ansible ENDCOM # ▁ Ansible ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ Ansible ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ Ansible . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM # ▁ Make ▁ coding ▁ more ▁ python3 - ish ENDCOM from __future__ import ( absolute_import , division , print_function ) NEW_LINE __metaclass__ = type NEW_LINE import io NEW_LINE import yaml NEW_LINE try : NEW_LINE INDENT from _yaml import ParserError NEW_LINE DEDENT except ImportError : NEW_LINE INDENT from yaml . parser import ParserError NEW_LINE DEDENT from ansible . parsing . yaml import dumper NEW_LINE from ansible . parsing . yaml . loader import AnsibleLoader NEW_LINE from ansible . compat . tests import unittest NEW_LINE from ansible . parsing . yaml import objects NEW_LINE from ansible . parsing import vault NEW_LINE from units . mock . yaml_helper import YamlTestUtils NEW_LINE class TestAnsibleDumper ( unittest . TestCase , YamlTestUtils ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT self . vault_password = " hunter42" NEW_LINE self . good_vault = vault . VaultLib ( self . vault_password ) NEW_LINE self . vault = self . good_vault NEW_LINE self . stream = self . _build_stream ( ) NEW_LINE self . dumper = dumper . AnsibleDumper NEW_LINE DEDENT def _build_stream ( self , yaml_text = None ) : NEW_LINE INDENT text = yaml_text or u ' ' NEW_LINE stream = io . StringIO ( text ) NEW_LINE return stream NEW_LINE DEDENT def _loader ( self , stream ) : NEW_LINE INDENT return AnsibleLoader ( stream , vault_password = self . vault_password ) NEW_LINE DEDENT def test ( self ) : NEW_LINE INDENT plaintext = ' This ▁ is ▁ a ▁ string ▁ we ▁ are ▁ going ▁ to ▁ encrypt . ' NEW_LINE avu = objects . AnsibleVaultEncryptedUnicode . from_plaintext ( plaintext , vault = self . vault ) NEW_LINE yaml_out = self . _dump_string ( avu , dumper = self . dumper ) NEW_LINE stream = self . _build_stream ( yaml_out ) NEW_LINE loader = self . _loader ( stream ) NEW_LINE data_from_yaml = loader . get_single_data ( ) NEW_LINE self . assertEquals ( plaintext , data_from_yaml . data ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="andybab/Impala/tree/master/tests/util/hdfs_util.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2012 ▁ Cloudera , ▁ Inc . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ENDCOM # ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM # ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM # ▁ limitations ▁ under ▁ the ▁ License . ENDCOM # ▁ Hdfs ▁ access ▁ utilities ENDCOM from xml . etree . ElementTree import parse NEW_LINE from pywebhdfs . webhdfs import PyWebHdfsClient , errors , _raise_pywebhdfs_exception NEW_LINE import getpass NEW_LINE import types NEW_LINE import requests , httplib NEW_LINE class PyWebHdfsClientWithChmod ( PyWebHdfsClient ) : NEW_LINE INDENT def chmod ( self , path , permission ) : NEW_LINE INDENT """ Set ▁ the ▁ permission ▁ of ▁ ' path ' ▁ to ▁ ' permission ' ▁ ( specified ▁ as ▁ an ▁ octal ▁ string , ▁ e . g . STRNEWLINE ▁ ' 775 ' """ NEW_LINE uri = self . _create_uri ( path , " SETPERMISSION " , permission = permission ) NEW_LINE response = requests . put ( uri , allow_redirects = True ) NEW_LINE if not response . status_code == httplib . OK : NEW_LINE INDENT _raise_pywebhdfs_exception ( response . status_code , response . text ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT class HdfsConfig ( object ) : NEW_LINE INDENT """ Reads ▁ an ▁ XML ▁ configuration ▁ file ▁ ( produced ▁ by ▁ a ▁ mini - cluster ) ▁ into ▁ a ▁ dictionary STRNEWLINE ▁ accessible ▁ via ▁ get ( ) """ NEW_LINE def __init__ ( self , filename ) : NEW_LINE INDENT self . conf = { } NEW_LINE tree = parse ( filename ) NEW_LINE for property in tree . getroot ( ) . getiterator ( ' property ' ) : NEW_LINE INDENT self . conf [ property . find ( ' name ' ) . text ] = property . find ( ' value ' ) . text NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT return self . conf . get ( key ) NEW_LINE DEDENT DEDENT def get_hdfs_client_from_conf ( conf ) : NEW_LINE INDENT """ Returns ▁ a ▁ new ▁ HTTP ▁ client ▁ for ▁ an ▁ HDFS ▁ cluster ▁ using ▁ an ▁ HdfsConfig ▁ object """ NEW_LINE hostport = conf . get ( ' dfs . namenode . http - address ' ) NEW_LINE if hostport is None : NEW_LINE INDENT raise Exception ( " dfs . namenode . http - address ▁ not ▁ found ▁ in ▁ config " ) NEW_LINE DEDENT host , port = hostport . split ( " : " ) NEW_LINE return get_hdfs_client ( host = host , port = port ) NEW_LINE DEDENT def __pyweb_hdfs_client_exists ( self , path ) : NEW_LINE INDENT """ The ▁ PyWebHdfsClient ▁ doesn ' t ▁ provide ▁ an ▁ API ▁ to ▁ cleanly ▁ detect ▁ if ▁ a ▁ file ▁ or ▁ directory STRNEWLINE ▁ exists . ▁ This ▁ method ▁ is ▁ bound ▁ to ▁ each ▁ client ▁ that ▁ is ▁ created ▁ so ▁ tests ▁ can ▁ simply ▁ call STRNEWLINE ▁ hdfs _ client . exists ( ' path ' ) ▁ and ▁ get ▁ back ▁ a ▁ bool . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . get_file_dir_status ( path ) NEW_LINE DEDENT except errors . FileNotFound : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def get_hdfs_client ( host , port , user_name = getpass . getuser ( ) ) : NEW_LINE INDENT """ Returns ▁ a ▁ new ▁ HTTP ▁ client ▁ for ▁ an ▁ HDFS ▁ cluster ▁ using ▁ an ▁ explict ▁ host : port ▁ pair """ NEW_LINE hdfs_client = PyWebHdfsClientWithChmod ( host = host , port = port , user_name = user_name ) NEW_LINE # ▁ Bind ▁ our ▁ " exists " ▁ method ▁ to ▁ hdfs _ client . exists ENDCOM hdfs_client . exists = types . MethodType ( __pyweb_hdfs_client_exists , hdfs_client ) NEW_LINE return hdfs_client NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="dragonpt/Kernel_3.4.67_KK_Wiko_DarkMoon/tree/master/tools/perf/scripts/python/futex-contention.py"> # ▁ futex ▁ contention ENDCOM # ▁ ( c ) ▁ 2010 , ▁ Arnaldo ▁ Carvalho ▁ de ▁ Melo ▁ < acme @ redhat . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ Translation ▁ of : ENDCOM # ▁ http : / / sourceware . org / systemtap / wiki / WSFutexContention ENDCOM # ▁ to ▁ perf ▁ python ▁ scripting . ENDCOM # ▁ Measures ▁ futex ▁ contention ENDCOM import os , sys NEW_LINE sys . path . append ( os . environ [ ' PERF _ EXEC _ PATH ' ] + ' / scripts / python / Perf - Trace - Util / lib / Perf / Trace ' ) NEW_LINE from Util import * NEW_LINE process_names = { } NEW_LINE thread_thislock = { } NEW_LINE thread_blocktime = { } NEW_LINE lock_waits = { } # ▁ long - lived ▁ stats ▁ on ▁ ( tid , lock ) ▁ blockage ▁ elapsed ▁ time ENDCOM NEW_LINE process_names = { } # ▁ long - lived ▁ pid - to - execname ▁ mapping ENDCOM NEW_LINE def syscalls__sys_enter_futex ( event , ctxt , cpu , s , ns , tid , comm , nr , uaddr , op , val , utime , uaddr2 , val3 ) : NEW_LINE INDENT cmd = op & FUTEX_CMD_MASK NEW_LINE if cmd != FUTEX_WAIT : NEW_LINE INDENT return # ▁ we ▁ don ' t ▁ care ▁ about ▁ originators ▁ of ▁ WAKE ▁ events ENDCOM NEW_LINE DEDENT process_names [ tid ] = comm NEW_LINE thread_thislock [ tid ] = uaddr NEW_LINE thread_blocktime [ tid ] = nsecs ( s , ns ) NEW_LINE DEDENT def syscalls__sys_exit_futex ( event , ctxt , cpu , s , ns , tid , comm , nr , ret ) : NEW_LINE INDENT if thread_blocktime . has_key ( tid ) : NEW_LINE INDENT elapsed = nsecs ( s , ns ) - thread_blocktime [ tid ] NEW_LINE add_stats ( lock_waits , ( tid , thread_thislock [ tid ] ) , elapsed ) NEW_LINE del thread_blocktime [ tid ] NEW_LINE del thread_thislock [ tid ] NEW_LINE DEDENT DEDENT def trace_begin ( ) : NEW_LINE INDENT print " Press ▁ control + C ▁ to ▁ stop ▁ and ▁ show ▁ the ▁ summary " NEW_LINE DEDENT def trace_end ( ) : NEW_LINE INDENT for ( tid , lock ) in lock_waits : NEW_LINE INDENT min , max , avg , count = lock_waits [ tid , lock ] NEW_LINE print " % s [ % d ] ▁ lock ▁ % x ▁ contended ▁ % d ▁ times , ▁ % d ▁ avg ▁ ns " % ( process_names [ tid ] , tid , lock , count , avg ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="glaubitz/fs-uae-debian/tree/master/launcher/launcher/game_paths.py"> import os NEW_LINE import fsui NEW_LINE from fsbc . paths import Paths NEW_LINE from fsgs . FSGSDirectories import FSGSDirectories NEW_LINE from . launcher_config import LauncherConfig NEW_LINE from . launcher_settings import LauncherSettings NEW_LINE from . ui . Constants import Constants NEW_LINE class GamePaths ( object ) : NEW_LINE INDENT @ staticmethod NEW_LINE def current ( ) : NEW_LINE INDENT model = LauncherConfig . get ( " amiga _ model " ) NEW_LINE if model . startswith ( " CD32" ) : NEW_LINE INDENT platform = " CD32" NEW_LINE DEDENT elif model == " CDTV " : NEW_LINE INDENT platform = " CDTV " NEW_LINE DEDENT else : NEW_LINE INDENT platform = " Amiga " NEW_LINE DEDENT name = LauncherSettings . get ( " config _ name " ) NEW_LINE uuid = LauncherConfig . get ( " x _ game _ uuid " ) NEW_LINE return GamePaths ( name , platform , uuid ) NEW_LINE DEDENT def __init__ ( self , name , platform , uuid ) : NEW_LINE INDENT self . uuid = uuid NEW_LINE self . config_name = name NEW_LINE if " ( " in name : NEW_LINE INDENT parts = name . split ( " ( " , 1 ) NEW_LINE self . name , self . variant = parts NEW_LINE self . name = self . name . strip ( ) NEW_LINE self . variant = self . variant . strip ( ) NEW_LINE if self . variant . endswith ( " ) " ) : NEW_LINE INDENT self . variant = self . variant [ : - 1 ] NEW_LINE DEDENT self . variant = self . variant . replace ( " ) ▁ ( " , " , ▁ " ) NEW_LINE self . variant = self . variant . replace ( " ) ( " , " , ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . name = name NEW_LINE self . variant = " " NEW_LINE DEDENT self . platform = platform NEW_LINE DEDENT def get_name ( self ) : NEW_LINE INDENT return self . name NEW_LINE DEDENT def get_variant ( self ) : NEW_LINE INDENT return self . variant NEW_LINE DEDENT @ staticmethod NEW_LINE def get_override_path ( name ) : NEW_LINE INDENT path = LauncherConfig . get ( name ) NEW_LINE if not path : NEW_LINE INDENT return " " NEW_LINE DEDENT path = Paths . expand_path ( path ) NEW_LINE return path NEW_LINE DEDENT def get_screenshot_path ( self , number ) : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT sha1 = LauncherConfig . get ( " title _ sha1" ) NEW_LINE DEDENT else : NEW_LINE INDENT sha1 = LauncherConfig . get ( " screen { 0 } _ sha1" . format ( number ) ) NEW_LINE DEDENT if sha1 : NEW_LINE INDENT return " sha1 : " + sha1 NEW_LINE DEDENT if number == 0 : NEW_LINE INDENT path = self . get_override_path ( " title _ image " ) NEW_LINE DEDENT else : NEW_LINE INDENT path = self . get_override_path ( " screen { 0 } _ image " . format ( number ) ) NEW_LINE DEDENT if path and os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT if self . uuid : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT name = " title . png " NEW_LINE DEDENT else : NEW_LINE INDENT name = " screen { 0 } . png " . format ( number ) NEW_LINE DEDENT paths = FSGSDirectories . get_images_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT p = os . path . join ( dir_ , self . platform , " Images " , self . uuid [ : 2 ] , self . uuid , name ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT p = os . path . join ( dir_ , self . platform , " Thumbnails " , self . uuid [ : 2 ] , self . uuid , name ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT name = self . name NEW_LINE if number == 0 : NEW_LINE INDENT override_dir = LauncherConfig . get ( " titles _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_titles_dirs ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT override_dir = LauncherConfig . get ( " screenshots _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_screenshots_dirs ( ) NEW_LINE DEDENT DEDENT if number >= 2 : NEW_LINE INDENT name = " { 0 } _ {1 } " . format ( name , number ) NEW_LINE DEDENT for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . gif " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . gif " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def load_screenshot ( self , number ) : NEW_LINE INDENT path = self . get_screenshot_path ( number ) NEW_LINE if path : NEW_LINE INDENT return fsui . Image ( path ) NEW_LINE DEDENT DEDENT def load_screenshot_preview ( self , number ) : NEW_LINE INDENT image = self . load_screenshot ( number ) NEW_LINE if image is None : NEW_LINE INDENT return image NEW_LINE DEDENT if image . size == Constants . SCREEN_SIZE : NEW_LINE INDENT return image NEW_LINE DEDENT if image . size [ 0 ] < 400 : NEW_LINE INDENT image . resize ( ( image . size [ 0 ] * 2 , image . size [ 1 ] * 2 ) , fsui . Image . NEAREST ) NEW_LINE DEDENT image . resize ( Constants . SCREEN_SIZE ) NEW_LINE return image NEW_LINE DEDENT def get_cover_path ( self ) : NEW_LINE INDENT sha1 = LauncherConfig . get ( " front _ sha1" ) NEW_LINE if sha1 : NEW_LINE INDENT return " sha1 : " + sha1 NEW_LINE DEDENT path = self . get_override_path ( " cover _ image " ) NEW_LINE if path and os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT if self . uuid : NEW_LINE INDENT paths = FSGSDirectories . get_images_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT p = os . path . join ( dir_ , self . platform , " Images " , self . uuid [ : 2 ] , self . uuid , " front . png " ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT p = os . path . join ( dir_ , self . platform , " Thumbnails " , self . uuid [ : 2 ] , self . uuid , " front . png " ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT name = self . name NEW_LINE override_dir = LauncherConfig . get ( " covers _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_covers_dirs ( ) NEW_LINE DEDENT for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , name + " . jpg " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . jpg " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def load_cover ( self ) : NEW_LINE INDENT path = self . get_cover_path ( ) NEW_LINE print ( path ) NEW_LINE if path : NEW_LINE INDENT return fsui . Image ( path ) NEW_LINE DEDENT DEDENT def load_cover_preview ( self ) : NEW_LINE INDENT image = self . load_cover ( ) NEW_LINE if image is None : NEW_LINE INDENT return image NEW_LINE DEDENT image . resize ( Constants . COVER_SIZE ) NEW_LINE return image NEW_LINE DEDENT def get_theme_path ( self ) : NEW_LINE INDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT paths = FSGSDirectories . get_themes_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , self . name ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def _get_state_dir ( self ) : NEW_LINE INDENT config_name = self . config_name NEW_LINE if not config_name : NEW_LINE INDENT config_name = " Default " NEW_LINE # ▁ use ▁ a ▁ temporary ▁ state ▁ dir , ▁ for ▁ now , ▁ to ▁ avoid ▁ problems ▁ with ENDCOM # ▁ floppy ▁ overlays ▁ etc ▁ interfering ▁ with ▁ net ▁ play ENDCOM DEDENT from . netplay . netplay import Netplay NEW_LINE if Netplay . current ( ) : NEW_LINE # ▁ it ▁ is ▁ possible ▁ to ▁ manually ▁ specify ▁ the ▁ state ▁ dir ENDCOM INDENT config_name = LauncherConfig . get ( " _ _ netplay _ state _ dir _ name " ) NEW_LINE if not config_name : NEW_LINE # ▁ this ▁ is ▁ the ▁ default ▁ behavior , ▁ create ▁ a ▁ clean ▁ state ENDCOM # ▁ dir ▁ for ▁ the ▁ net ▁ play ▁ session ENDCOM INDENT netplay_game = LauncherConfig . get ( " _ _ netplay _ game " ) NEW_LINE if netplay_game : NEW_LINE INDENT config_name = " Net ▁ Play ▁ ( {0 } ) " . format ( netplay_game ) NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( config_name ) NEW_LINE if not letter : NEW_LINE INDENT config_name = " Default " NEW_LINE letter = self . get_letter ( config_name ) NEW_LINE # ▁ we ▁ use ▁ an ▁ existing ▁ state ▁ dir ▁ in ▁ a ▁ " letter " ▁ dir ▁ if ▁ it ▁ exists ENDCOM # ▁ ( legacy ▁ support ) . ENDCOM DEDENT path = os . path . join ( FSGSDirectories . get_save_states_dir ( ) , letter , config_name ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE # ▁ if ▁ not , ▁ we ▁ use ▁ a ▁ direct ▁ sub - folder ▁ of ▁ save ▁ states ▁ dir ENDCOM DEDENT path = os . path . join ( FSGSDirectories . get_save_states_dir ( ) , config_name ) NEW_LINE return path NEW_LINE DEDENT def get_state_dir ( self ) : NEW_LINE INDENT state_dir = self . _get_state_dir ( ) NEW_LINE if not os . path . exists ( state_dir ) : NEW_LINE INDENT os . makedirs ( state_dir ) NEW_LINE DEDENT return state_dir NEW_LINE DEDENT @ staticmethod NEW_LINE def get_letter ( name ) : NEW_LINE INDENT letter_name = name . upper ( ) NEW_LINE if letter_name . startswith ( " THE ▁ " ) : NEW_LINE INDENT letter_name = letter_name [ 4 : ] NEW_LINE DEDENT if letter_name . startswith ( " A ▁ " ) : NEW_LINE INDENT letter_name = letter_name [ 2 : ] NEW_LINE DEDENT for i in range ( len ( letter_name ) ) : NEW_LINE INDENT letter = letter_name [ i ] NEW_LINE if letter in "01234567890" : NEW_LINE INDENT letter = "0" NEW_LINE break NEW_LINE DEDENT if letter in " ABCDEFGHIJKLMNOPQRSTUVWXYZ " : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT return letter NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="tangyiyong/odoo/tree/master/addons/mrp/wizard/stock_move.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ OpenERP , ▁ Open ▁ Source ▁ Management ▁ Solution ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2004-2010 ▁ Tiny ▁ SPRL ▁ ( < http : / / tiny . be > ) . ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as ENDCOM # ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ENDCOM # ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM from openerp . osv import fields , osv NEW_LINE from openerp . tools import float_compare NEW_LINE from openerp . tools . translate import _ NEW_LINE import openerp . addons . decimal_precision as dp NEW_LINE class stock_move_consume ( osv . osv_memory ) : NEW_LINE INDENT _name = " stock . move . consume " NEW_LINE _description = " Consume ▁ Products " NEW_LINE _columns = { ' product _ id ' : fields . many2one ( ' product . product ' , ' Product ' , required = True , select = True ) , ' product _ qty ' : fields . float ( ' Quantity ' , digits_compute = dp . get_precision ( ' Product ▁ Unit ▁ of ▁ Measure ' ) , required = True ) , ' product _ uom ' : fields . many2one ( ' product . uom ' , ' Product ▁ Unit ▁ of ▁ Measure ' , required = True ) , ' location _ id ' : fields . many2one ( ' stock . location ' , ' Location ' , required = True ) , ' restrict _ lot _ id ' : fields . many2one ( ' stock . production . lot ' , ' Lot ' ) , } NEW_LINE # TOFIX : ▁ product _ uom ▁ should ▁ not ▁ have ▁ different ▁ category ▁ of ▁ default ▁ UOM ▁ of ▁ product . ▁ Qty ▁ should ▁ be ▁ convert ▁ into ▁ UOM ▁ of ▁ original ▁ move ▁ line ▁ before ▁ going ▁ in ▁ consume ▁ and ▁ scrap ENDCOM def default_get ( self , cr , uid , fields , context = None ) : NEW_LINE INDENT if context is None : NEW_LINE INDENT context = { } NEW_LINE DEDENT res = super ( stock_move_consume , self ) . default_get ( cr , uid , fields , context = context ) NEW_LINE move = self . pool . get ( ' stock . move ' ) . browse ( cr , uid , context [ ' active _ id ' ] , context = context ) NEW_LINE if ' product _ id ' in fields : NEW_LINE INDENT res . update ( { ' product _ id ' : move . product_id . id } ) NEW_LINE DEDENT if ' product _ uom ' in fields : NEW_LINE INDENT res . update ( { ' product _ uom ' : move . product_uom . id } ) NEW_LINE DEDENT if ' product _ qty ' in fields : NEW_LINE INDENT res . update ( { ' product _ qty ' : move . product_uom_qty } ) NEW_LINE DEDENT if ' location _ id ' in fields : NEW_LINE INDENT res . update ( { ' location _ id ' : move . location_id . id } ) NEW_LINE DEDENT return res NEW_LINE DEDENT def do_move_consume ( self , cr , uid , ids , context = None ) : NEW_LINE INDENT if context is None : NEW_LINE INDENT context = { } NEW_LINE DEDENT move_obj = self . pool . get ( ' stock . move ' ) NEW_LINE uom_obj = self . pool . get ( ' product . uom ' ) NEW_LINE production_obj = self . pool . get ( ' mrp . production ' ) NEW_LINE move_ids = context [ ' active _ ids ' ] NEW_LINE move = move_obj . browse ( cr , uid , move_ids [ 0 ] , context = context ) NEW_LINE production_id = move . raw_material_production_id . id NEW_LINE production = production_obj . browse ( cr , uid , production_id , context = context ) NEW_LINE precision = self . pool [ ' decimal . precision ' ] . precision_get ( cr , uid , ' Product ▁ Unit ▁ of ▁ Measure ' ) NEW_LINE for data in self . browse ( cr , uid , ids , context = context ) : NEW_LINE INDENT qty = uom_obj . _compute_qty ( cr , uid , data [ ' product _ uom ' ] . id , data . product_qty , data . product_id . uom_id . id ) NEW_LINE remaining_qty = move . product_qty - qty NEW_LINE # check ▁ for ▁ product ▁ quantity ▁ is ▁ less ▁ than ▁ previously ▁ planned ENDCOM if float_compare ( remaining_qty , 0 , precision_digits = precision ) >= 0 : NEW_LINE INDENT move_obj . action_consume ( cr , uid , move_ids , qty , data . location_id . id , restrict_lot_id = data . restrict_lot_id . id , context = context ) NEW_LINE DEDENT else : NEW_LINE INDENT consumed_qty = min ( move . product_qty , qty ) NEW_LINE new_moves = move_obj . action_consume ( cr , uid , move_ids , consumed_qty , data . location_id . id , restrict_lot_id = data . restrict_lot_id . id , context = context ) NEW_LINE # consumed ▁ more ▁ in ▁ wizard ▁ than ▁ previously ▁ planned ENDCOM extra_more_qty = qty - consumed_qty NEW_LINE # create ▁ new ▁ line ▁ for ▁ a ▁ remaining ▁ qty ▁ of ▁ the ▁ product ENDCOM extra_move_id = production_obj . _make_consume_line_from_data ( cr , uid , production , data . product_id , data . product_id . uom_id . id , extra_more_qty , False , 0 , context = context ) NEW_LINE move_obj . write ( cr , uid , [ extra_move_id ] , { ' restrict _ lot _ id ' : data . restrict_lot_id . id } , context = context ) NEW_LINE move_obj . action_done ( cr , uid , [ extra_move_id ] , context = context ) NEW_LINE DEDENT DEDENT return { ' type ' : ' ir . actions . act _ window _ close ' } NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="indevgr/django/tree/master/tests/servers/tests.py"> # ▁ - * - ▁ encoding : ▁ utf - 8 ▁ - * - ENDCOM """ STRNEWLINE Tests ▁ for ▁ django . core . servers . STRNEWLINE """ NEW_LINE from __future__ import unicode_literals NEW_LINE import contextlib NEW_LINE import errno NEW_LINE import os NEW_LINE import socket NEW_LINE from django . core . exceptions import ImproperlyConfigured NEW_LINE from django . test import LiveServerTestCase , override_settings NEW_LINE from django . utils . _os import upath NEW_LINE from django . utils . http import urlencode NEW_LINE from django . utils . six import text_type NEW_LINE from django . utils . six . moves . urllib . error import HTTPError NEW_LINE from django . utils . six . moves . urllib . request import urlopen NEW_LINE from . models import Person NEW_LINE TEST_ROOT = os . path . dirname ( upath ( __file__ ) ) NEW_LINE TEST_SETTINGS = { ' MEDIA _ URL ' : ' / media / ' , ' MEDIA _ ROOT ' : os . path . join ( TEST_ROOT , ' media ' ) , ' STATIC _ URL ' : ' / static / ' , ' STATIC _ ROOT ' : os . path . join ( TEST_ROOT , ' static ' ) , } NEW_LINE @ override_settings ( ROOT_URLCONF = ' servers . urls ' , ** TEST_SETTINGS ) NEW_LINE class LiveServerBase ( LiveServerTestCase ) : NEW_LINE INDENT available_apps = [ ' servers ' , ' django . contrib . auth ' , ' django . contrib . contenttypes ' , ' django . contrib . sessions ' , ] NEW_LINE fixtures = [ ' testdata . json ' ] NEW_LINE def urlopen ( self , url ) : NEW_LINE INDENT return urlopen ( self . live_server_url + url ) NEW_LINE DEDENT DEDENT class LiveServerAddress ( LiveServerBase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ address ▁ set ▁ in ▁ the ▁ environment ▁ variable ▁ is ▁ valid . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def setUpClass ( cls ) : NEW_LINE # ▁ Backup ▁ original ▁ environment ▁ variable ENDCOM INDENT address_predefined = ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' in os . environ NEW_LINE old_address = os . environ . get ( ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ) NEW_LINE # ▁ Just ▁ the ▁ host ▁ is ▁ not ▁ accepted ENDCOM cls . raises_exception ( ' localhost ' , ImproperlyConfigured ) NEW_LINE # ▁ The ▁ host ▁ must ▁ be ▁ valid ENDCOM cls . raises_exception ( ' blahblahblah : 8081' , socket . error ) NEW_LINE # ▁ The ▁ list ▁ of ▁ ports ▁ must ▁ be ▁ in ▁ a ▁ valid ▁ format ENDCOM cls . raises_exception ( ' localhost : 8081 , ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 , blah ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 - ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 - blah ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081-8082-8083' , ImproperlyConfigured ) NEW_LINE # ▁ Restore ▁ original ▁ environment ▁ variable ENDCOM if address_predefined : NEW_LINE INDENT os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] = old_address NEW_LINE DEDENT else : NEW_LINE INDENT del os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] NEW_LINE # ▁ put ▁ it ▁ in ▁ a ▁ list ▁ to ▁ prevent ▁ descriptor ▁ lookups ▁ in ▁ test ENDCOM DEDENT cls . live_server_url_test = [ cls . live_server_url ] NEW_LINE DEDENT @ classmethod NEW_LINE def tearDownClass ( cls ) : NEW_LINE # ▁ skip ▁ it , ▁ as ▁ setUpClass ▁ doesn ' t ▁ call ▁ its ▁ parent ▁ either ENDCOM INDENT pass NEW_LINE DEDENT @ classmethod NEW_LINE def raises_exception ( cls , address , exception ) : NEW_LINE INDENT os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] = address NEW_LINE try : NEW_LINE INDENT super ( LiveServerAddress , cls ) . setUpClass ( ) NEW_LINE raise Exception ( " The ▁ line ▁ above ▁ should ▁ have ▁ raised ▁ an ▁ exception " ) NEW_LINE DEDENT except exception : NEW_LINE INDENT pass NEW_LINE DEDENT finally : NEW_LINE INDENT super ( LiveServerAddress , cls ) . tearDownClass ( ) NEW_LINE DEDENT DEDENT def test_live_server_url_is_class_property ( self ) : NEW_LINE INDENT self . assertIsInstance ( self . live_server_url_test [ 0 ] , text_type ) NEW_LINE self . assertEqual ( self . live_server_url_test [ 0 ] , self . live_server_url ) NEW_LINE DEDENT DEDENT class LiveServerViews ( LiveServerBase ) : NEW_LINE INDENT def test_404 ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ 404s . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . urlopen ( ' / ' ) NEW_LINE DEDENT except HTTPError as err : NEW_LINE INDENT self . assertEqual ( err . code , 404 , ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT DEDENT def test_view ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ views . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / example _ view / ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) , b ' example ▁ view ' ) NEW_LINE DEDENT DEDENT def test_static_files ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ static ▁ files . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / static / example _ static _ file . txt ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . rstrip ( b ' \n ' ) , b ' example ▁ static ▁ file ' ) NEW_LINE DEDENT DEDENT def test_no_collectstatic_emulation ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ that ▁ LiveServerTestCase ▁ reports ▁ a ▁ 404 ▁ status ▁ code ▁ when ▁ HTTP ▁ client STRNEWLINE ▁ tries ▁ to ▁ access ▁ a ▁ static ▁ file ▁ that ▁ isn ' t ▁ explicitly ▁ put ▁ under STRNEWLINE ▁ STATIC _ ROOT . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . urlopen ( ' / static / another _ app / another _ app _ static _ file . txt ' ) NEW_LINE DEDENT except HTTPError as err : NEW_LINE INDENT self . assertEqual ( err . code , 404 , ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Expected ▁ 404 ▁ response ▁ ( got ▁ % d ) ' % err . code ) NEW_LINE DEDENT DEDENT def test_media_files ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ media ▁ files . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / media / example _ media _ file . txt ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . rstrip ( b ' \n ' ) , b ' example ▁ media ▁ file ' ) NEW_LINE DEDENT DEDENT def test_environ ( self ) : NEW_LINE INDENT with contextlib . closing ( self . urlopen ( ' / environ _ view / ? % s ' % urlencode ( { ' q ' : ' тест ' } ) ) ) as f : NEW_LINE INDENT self . assertIn ( b " QUERY _ STRING : ▁ ' q = % D1%82 % D0 % B5 % D1%81 % D1%82 ' " , f . read ( ) ) NEW_LINE DEDENT DEDENT DEDENT class LiveServerDatabase ( LiveServerBase ) : NEW_LINE INDENT def test_fixtures_loaded ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ fixtures ▁ are ▁ properly ▁ loaded ▁ and ▁ visible ▁ to ▁ the STRNEWLINE ▁ live ▁ server ▁ thread . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / model _ view / ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . splitlines ( ) , [ b ' jane ' , b ' robert ' ] ) NEW_LINE DEDENT DEDENT def test_database_writes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ data ▁ written ▁ to ▁ the ▁ database ▁ by ▁ a ▁ view ▁ can ▁ be ▁ read . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE self . urlopen ( ' / create _ model _ instance / ' ) NEW_LINE self . assertQuerysetEqual ( Person . objects . all ( ) . order_by ( ' pk ' ) , [ ' jane ' , ' robert ' , ' emily ' ] , lambda b : b . name ) NEW_LINE DEDENT DEDENT class LiveServerPort ( LiveServerBase ) : NEW_LINE INDENT def test_port_bind ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Each ▁ LiveServerTestCase ▁ binds ▁ to ▁ a ▁ unique ▁ port ▁ or ▁ fails ▁ to ▁ start ▁ a STRNEWLINE ▁ server ▁ thread ▁ when ▁ run ▁ concurrently ▁ ( # 26011 ) . STRNEWLINE ▁ """ NEW_LINE TestCase = type ( str ( " TestCase " ) , ( LiveServerBase , ) , { } ) NEW_LINE try : NEW_LINE INDENT TestCase . setUpClass ( ) NEW_LINE DEDENT except socket . error as e : NEW_LINE INDENT if e . errno == errno . EADDRINUSE : NEW_LINE # ▁ We ' re ▁ out ▁ of ▁ ports , ▁ LiveServerTestCase ▁ correctly ▁ fails ▁ with ENDCOM # ▁ a ▁ socket ▁ error . ENDCOM INDENT return NEW_LINE # ▁ Unexpected ▁ error . ENDCOM DEDENT raise NEW_LINE DEDENT try : NEW_LINE # ▁ We ' ve ▁ acquired ▁ a ▁ port , ▁ ensure ▁ our ▁ server ▁ threads ▁ acquired ENDCOM # ▁ different ▁ addresses . ENDCOM INDENT self . assertNotEqual ( self . live_server_url , TestCase . live_server_url , " Acquired ▁ duplicate ▁ server ▁ addresses ▁ for ▁ server ▁ threads : ▁ % s " % self . live_server_url ) NEW_LINE DEDENT finally : NEW_LINE INDENT TestCase . tearDownClass ( ) NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="arifgursel/pyglet/tree/master/pyglet/gl/lib.py"> # ▁ pyglet ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2006-2008 ▁ Alex ▁ Holkner ENDCOM # ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without ENDCOM # ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ ENDCOM # ▁ are ▁ met : ENDCOM # ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright ENDCOM # ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . ENDCOM # ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright ▁ ENDCOM # ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ENDCOM # ▁ the ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ENDCOM # ▁ distribution . ENDCOM # ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ pyglet ▁ nor ▁ the ▁ names ▁ of ▁ its ENDCOM # ▁ contributors ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ENDCOM # ▁ derived ▁ from ▁ this ▁ software ▁ without ▁ specific ▁ prior ▁ written ENDCOM # ▁ permission . ENDCOM # ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS ENDCOM # ▁ " AS ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ENDCOM # ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ENDCOM # ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ENDCOM # ▁ COPYRIGHT ▁ OWNER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ENDCOM # ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ENDCOM # ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ENDCOM # ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ HOWEVER ENDCOM # ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ STRICT ENDCOM # ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ▁ ARISING ▁ IN ENDCOM # ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ENDCOM # ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ENDCOM __docformat__ = ' restructuredtext ' NEW_LINE __version__ = ' $ Id $ ' NEW_LINE import ctypes NEW_LINE import pyglet NEW_LINE __all__ = [ ' link _ GL ' , ' link _ GLU ' , ' link _ AGL ' , ' link _ GLX ' , ' link _ WGL ' ] NEW_LINE _debug_gl = pyglet . options [ ' debug _ gl ' ] NEW_LINE _debug_gl_trace = pyglet . options [ ' debug _ gl _ trace ' ] NEW_LINE _debug_gl_trace_args = pyglet . options [ ' debug _ gl _ trace _ args ' ] NEW_LINE class MissingFunctionException ( Exception ) : NEW_LINE INDENT def __init__ ( self , name , requires = None , suggestions = None ) : NEW_LINE INDENT msg = ' % s ▁ is ▁ not ▁ exported ▁ by ▁ the ▁ available ▁ OpenGL ▁ driver . ' % name NEW_LINE if requires : NEW_LINE INDENT msg += ' ▁ ▁ % s ▁ is ▁ required ▁ for ▁ this ▁ functionality . ' % requires NEW_LINE DEDENT if suggestions : NEW_LINE INDENT msg += ' ▁ ▁ Consider ▁ alternative ( s ) ▁ % s . ' % ' , ▁ ' . join ( suggestions ) NEW_LINE DEDENT Exception . __init__ ( self , msg ) NEW_LINE DEDENT DEDENT def missing_function ( name , requires = None , suggestions = None ) : NEW_LINE INDENT def MissingFunction ( * args , ** kwargs ) : NEW_LINE INDENT raise MissingFunctionException ( name , requires , suggestions ) NEW_LINE DEDENT return MissingFunction NEW_LINE DEDENT _int_types = ( ctypes . c_int16 , ctypes . c_int32 ) NEW_LINE if hasattr ( ctypes , ' c _ int64' ) : NEW_LINE # ▁ Some ▁ builds ▁ of ▁ ctypes ▁ apparently ▁ do ▁ not ▁ have ▁ c _ int64 ENDCOM # ▁ defined ; ▁ it ' s ▁ a ▁ pretty ▁ good ▁ bet ▁ that ▁ these ▁ builds ▁ do ▁ not ENDCOM # ▁ have ▁ 64 - bit ▁ pointers . ENDCOM INDENT _int_types += ( ctypes . c_int64 , ) NEW_LINE DEDENT for t in _int_types : NEW_LINE INDENT if ctypes . sizeof ( t ) == ctypes . sizeof ( ctypes . c_size_t ) : NEW_LINE INDENT c_ptrdiff_t = t NEW_LINE DEDENT DEDENT class c_void ( ctypes . Structure ) : NEW_LINE # ▁ c _ void _ p ▁ is ▁ a ▁ buggy ▁ return ▁ type , ▁ converting ▁ to ▁ int , ▁ so ENDCOM # ▁ POINTER ( None ) ▁ = = ▁ c _ void _ p ▁ is ▁ actually ▁ written ▁ as ENDCOM # ▁ POINTER ( c _ void ) , ▁ so ▁ it ▁ can ▁ be ▁ treated ▁ as ▁ a ▁ real ▁ pointer . ENDCOM INDENT _fields_ = [ ( ' dummy ' , ctypes . c_int ) ] NEW_LINE DEDENT class GLException ( Exception ) : NEW_LINE INDENT pass NEW_LINE DEDENT def errcheck ( result , func , arguments ) : NEW_LINE INDENT if _debug_gl_trace : NEW_LINE INDENT try : NEW_LINE INDENT name = func . __name__ NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT name = repr ( func ) NEW_LINE DEDENT if _debug_gl_trace_args : NEW_LINE INDENT trace_args = ' , ▁ ' . join ( [ repr ( arg ) [ : 20 ] for arg in arguments ] ) NEW_LINE print ' % s ( % s ) ' % ( name , trace_args ) NEW_LINE DEDENT else : NEW_LINE INDENT print name NEW_LINE DEDENT DEDENT from pyglet import gl NEW_LINE context = gl . current_context NEW_LINE if not context : NEW_LINE INDENT raise GLException ( ' No ▁ GL ▁ context ; ▁ create ▁ a ▁ Window ▁ first ' ) NEW_LINE DEDENT if not context . _gl_begin : NEW_LINE INDENT error = gl . glGetError ( ) NEW_LINE if error : NEW_LINE INDENT msg = ctypes . cast ( gl . gluErrorString ( error ) , ctypes . c_char_p ) . value NEW_LINE raise GLException ( msg ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT def errcheck_glbegin ( result , func , arguments ) : NEW_LINE INDENT from pyglet import gl NEW_LINE context = gl . current_context NEW_LINE if not context : NEW_LINE INDENT raise GLException ( ' No ▁ GL ▁ context ; ▁ create ▁ a ▁ Window ▁ first ' ) NEW_LINE DEDENT context . _gl_begin = True NEW_LINE return result NEW_LINE DEDENT def errcheck_glend ( result , func , arguments ) : NEW_LINE INDENT from pyglet import gl NEW_LINE context = gl . current_context NEW_LINE if not context : NEW_LINE INDENT raise GLException ( ' No ▁ GL ▁ context ; ▁ create ▁ a ▁ Window ▁ first ' ) NEW_LINE DEDENT context . _gl_begin = False NEW_LINE return errcheck ( result , func , arguments ) NEW_LINE DEDENT def decorate_function ( func , name ) : NEW_LINE INDENT if _debug_gl : NEW_LINE INDENT if name == ' glBegin ' : NEW_LINE INDENT func . errcheck = errcheck_glbegin NEW_LINE DEDENT elif name == ' glEnd ' : NEW_LINE INDENT func . errcheck = errcheck_glend NEW_LINE DEDENT elif name not in ( ' glGetError ' , ' gluErrorString ' ) and name [ : 3 ] not in ( ' glX ' , ' agl ' , ' wgl ' ) : NEW_LINE INDENT func . errcheck = errcheck NEW_LINE DEDENT DEDENT DEDENT link_AGL = None NEW_LINE link_GLX = None NEW_LINE link_WGL = None NEW_LINE if pyglet . compat_platform in ( ' win32' , ' cygwin ' ) : NEW_LINE INDENT from pyglet . gl . lib_wgl import link_GL , link_GLU , link_WGL NEW_LINE DEDENT elif pyglet . compat_platform == ' darwin ' : NEW_LINE INDENT from pyglet . gl . lib_agl import link_GL , link_GLU , link_AGL NEW_LINE DEDENT else : NEW_LINE INDENT from pyglet . gl . lib_glx import link_GL , link_GLU , link_GLX NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="nikolay-fedotov/tempest/tree/master/tempest/api/object_storage/test_account_services_negative.py"> # ▁ Copyright ▁ ( C ) ▁ 2013 ▁ eNovance ▁ SAS ▁ < licensing @ enovance . com > ENDCOM # ▁ Author : ▁ Joe ▁ H . ▁ Rahme ▁ < joe . hakim . rahme @ enovance . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ENDCOM # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ENDCOM # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ENDCOM # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ENDCOM # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM # ▁ under ▁ the ▁ License . ENDCOM from tempest . api . object_storage import base NEW_LINE from tempest import clients NEW_LINE from tempest import exceptions NEW_LINE from tempest import test NEW_LINE class AccountNegativeTest ( base . BaseObjectTest ) : NEW_LINE INDENT @ test . attr ( type = [ ' negative ' , ' gate ' ] ) NEW_LINE def test_list_containers_with_non_authorized_user ( self ) : NEW_LINE # ▁ list ▁ containers ▁ using ▁ non - authorized ▁ user ENDCOM # ▁ create ▁ user ENDCOM INDENT self . data . setup_test_user ( ) NEW_LINE test_os = clients . Manager ( self . data . test_credentials ) NEW_LINE test_auth_provider = test_os . auth_provider NEW_LINE # ▁ Get ▁ auth ▁ for ▁ the ▁ test ▁ user ENDCOM test_auth_provider . auth_data NEW_LINE # ▁ Get ▁ fresh ▁ auth ▁ for ▁ test ▁ user ▁ and ▁ set ▁ it ▁ to ▁ next ▁ auth ▁ request ▁ for ENDCOM # ▁ custom _ account _ client ENDCOM delattr ( test_auth_provider , ' auth _ data ' ) NEW_LINE test_auth_new_data = test_auth_provider . auth_data NEW_LINE self . custom_account_client . auth_provider . set_alt_auth_data ( request_part = ' headers ' , auth_data = test_auth_new_data ) NEW_LINE params = { ' format ' : ' json ' } NEW_LINE # ▁ list ▁ containers ▁ with ▁ non - authorized ▁ user ▁ token ENDCOM self . assertRaises ( exceptions . Unauthorized , self . custom_account_client . list_account_containers , params = params ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="haad/ansible/tree/master/lib/ansible/modules/cloud/lxd/lxd_profile.py"> # ! / usr / bin / python ENDCOM # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ ( c ) ▁ 2016 , ▁ Hiroaki ▁ Nakamura ▁ < hnakamur @ gmail . com > ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ v3.0 + ▁ ( see ▁ COPYING ▁ or ▁ https : / / www . gnu . org / licenses / gpl - 3.0 . txt ) ENDCOM from __future__ import absolute_import , division , print_function NEW_LINE __metaclass__ = type NEW_LINE ANSIBLE_METADATA = { ' metadata _ version ' : '1.1' , ' status ' : [ ' preview ' ] , ' supported _ by ' : ' community ' } NEW_LINE DOCUMENTATION = ''' STRNEWLINE - - - STRNEWLINE module : ▁ lxd _ profile STRNEWLINE short _ description : ▁ Manage ▁ LXD ▁ profiles STRNEWLINE version _ added : ▁ " 2.2 " STRNEWLINE description : STRNEWLINE ▁ ▁ - ▁ Management ▁ of ▁ LXD ▁ profiles STRNEWLINE author : ▁ " Hiroaki ▁ Nakamura ▁ ( @ hnakamur ) " STRNEWLINE options : STRNEWLINE ▁ ▁ ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Name ▁ of ▁ a ▁ profile . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Description ▁ of ▁ the ▁ profile . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ " 2.5 " STRNEWLINE ▁ ▁ ▁ ▁ config : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' The ▁ config ▁ for ▁ the ▁ container ▁ ( e . g . ▁ { " limits . memory " : ▁ " 4GB " } ) . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ See ▁ U ( https : / / github . com / lxc / lxd / blob / master / doc / rest - api . md # patch - 3 ) ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ If ▁ the ▁ profile ▁ already ▁ exists ▁ and ▁ its ▁ " config " ▁ value ▁ in ▁ metadata STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ obtained ▁ from STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ GET ▁ / 1.0 / profiles / < name > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ U ( https : / / github . com / lxc / lxd / blob / master / doc / rest - api . md # get - 19 ) STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ are ▁ different , ▁ they ▁ this ▁ module ▁ tries ▁ to ▁ apply ▁ the ▁ configurations . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Not ▁ all ▁ config ▁ values ▁ are ▁ supported ▁ to ▁ apply ▁ the ▁ existing ▁ profile . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Maybe ▁ you ▁ need ▁ to ▁ delete ▁ and ▁ recreate ▁ a ▁ profile . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ devices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' The ▁ devices ▁ for ▁ the ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ( e . g . ▁ { " rootfs " : ▁ { " path " : ▁ " / dev / kvm " , ▁ " type " : ▁ " unix - char " } ) . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ See ▁ U ( https : / / github . com / lxc / lxd / blob / master / doc / rest - api . md # patch - 3 ) ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ new _ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ A ▁ new ▁ name ▁ of ▁ a ▁ profile . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ If ▁ this ▁ parameter ▁ is ▁ specified ▁ a ▁ profile ▁ will ▁ be ▁ renamed ▁ to ▁ this ▁ name . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ See ▁ U ( https : / / github . com / lxc / lxd / blob / master / doc / rest - api . md # post - 11 ) STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ present STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ absent STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Define ▁ the ▁ state ▁ of ▁ a ▁ profile . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ present STRNEWLINE ▁ ▁ ▁ ▁ url : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ unix ▁ domain ▁ socket ▁ path ▁ or ▁ the ▁ https ▁ URL ▁ for ▁ the ▁ LXD ▁ server . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ unix : / var / lib / lxd / unix . socket STRNEWLINE ▁ ▁ ▁ ▁ key _ file : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ client ▁ certificate ▁ key ▁ file ▁ path . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' " { } / . config / lxc / client . key " ▁ . format ( os . environ [ " HOME " ] ) ' STRNEWLINE ▁ ▁ ▁ ▁ cert _ file : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ client ▁ certificate ▁ file ▁ path . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' " { } / . config / lxc / client . crt " ▁ . format ( os . environ [ " HOME " ] ) ' STRNEWLINE ▁ ▁ ▁ ▁ trust _ password : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ client ▁ trusted ▁ password . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ You ▁ need ▁ to ▁ set ▁ this ▁ password ▁ on ▁ the ▁ LXD ▁ server ▁ before STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ running ▁ this ▁ module ▁ using ▁ the ▁ following ▁ command . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ lxc ▁ config ▁ set ▁ core . trust _ password ▁ < some ▁ random ▁ password > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ See ▁ U ( https : / / www . stgraber . org / 2016/04/18 / lxd - api - direct - interaction / ) STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ If ▁ trust _ password ▁ is ▁ set , ▁ this ▁ module ▁ send ▁ a ▁ request ▁ for STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ authentication ▁ before ▁ sending ▁ any ▁ requests . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE notes : STRNEWLINE ▁ ▁ - ▁ Profiles ▁ must ▁ have ▁ a ▁ unique ▁ name . ▁ If ▁ you ▁ attempt ▁ to ▁ create ▁ a ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ with ▁ a ▁ name ▁ that ▁ already ▁ existed ▁ in ▁ the ▁ users ▁ namespace ▁ the ▁ module ▁ will STRNEWLINE ▁ ▁ ▁ ▁ simply ▁ return ▁ as ▁ " unchanged " . STRNEWLINE ''' NEW_LINE EXAMPLES = ''' STRNEWLINE # ▁ An ▁ example ▁ for ▁ creating ▁ a ▁ profile STRNEWLINE - ▁ hosts : ▁ localhost STRNEWLINE ▁ ▁ connection : ▁ local STRNEWLINE ▁ ▁ tasks : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ name : ▁ Create ▁ a ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ lxd _ profile : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ macvlan STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state : ▁ present STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ config : ▁ { } STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : ▁ my ▁ macvlan ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ devices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ eth0 : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ nictype : ▁ macvlan STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ parent : ▁ br0 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ type : ▁ nic STRNEWLINE STRNEWLINE # ▁ An ▁ example ▁ for ▁ creating ▁ a ▁ profile ▁ via ▁ http ▁ connection STRNEWLINE - ▁ hosts : ▁ localhost STRNEWLINE ▁ ▁ connection : ▁ local STRNEWLINE ▁ ▁ tasks : STRNEWLINE ▁ ▁ - ▁ name : ▁ create ▁ macvlan ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ lxd _ profile : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ url : ▁ https : / / 127.0.0.1:8443 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ # ▁ These ▁ cert _ file ▁ and ▁ key _ file ▁ values ▁ are ▁ equal ▁ to ▁ the ▁ default ▁ values . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ # cert _ file : ▁ " { { ▁ lookup ( ' env ' , ▁ ' HOME ' ) ▁ } } / . config / lxc / client . crt " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ # key _ file : ▁ " { { ▁ lookup ( ' env ' , ▁ ' HOME ' ) ▁ } } / . config / lxc / client . key " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ trust _ password : ▁ mypassword STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ macvlan STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ state : ▁ present STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ config : ▁ { } STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ description : ▁ my ▁ macvlan ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ devices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ eth0 : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ nictype : ▁ macvlan STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ parent : ▁ br0 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ type : ▁ nic STRNEWLINE STRNEWLINE # ▁ An ▁ example ▁ for ▁ deleting ▁ a ▁ profile STRNEWLINE - ▁ hosts : ▁ localhost STRNEWLINE ▁ ▁ connection : ▁ local STRNEWLINE ▁ ▁ tasks : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ name : ▁ Delete ▁ a ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ lxd _ profile : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ macvlan STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state : ▁ absent STRNEWLINE STRNEWLINE # ▁ An ▁ example ▁ for ▁ renaming ▁ a ▁ profile STRNEWLINE - ▁ hosts : ▁ localhost STRNEWLINE ▁ ▁ connection : ▁ local STRNEWLINE ▁ ▁ tasks : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ name : ▁ Rename ▁ a ▁ profile STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ lxd _ profile : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ macvlan STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ new _ name : ▁ macvlan2 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state : ▁ present STRNEWLINE ''' NEW_LINE RETURN = ''' STRNEWLINE old _ state : STRNEWLINE ▁ ▁ description : ▁ The ▁ old ▁ state ▁ of ▁ the ▁ profile STRNEWLINE ▁ ▁ returned : ▁ success STRNEWLINE ▁ ▁ type : ▁ string STRNEWLINE ▁ ▁ sample : ▁ " absent " STRNEWLINE logs : STRNEWLINE ▁ ▁ description : ▁ The ▁ logs ▁ of ▁ requests ▁ and ▁ responses . STRNEWLINE ▁ ▁ returned : ▁ when ▁ ansible - playbook ▁ is ▁ invoked ▁ with ▁ - vvvv . STRNEWLINE ▁ ▁ type : ▁ list STRNEWLINE ▁ ▁ sample : ▁ " ( too ▁ long ▁ to ▁ be ▁ placed ▁ here ) " STRNEWLINE actions : STRNEWLINE ▁ ▁ description : ▁ List ▁ of ▁ actions ▁ performed ▁ for ▁ the ▁ profile . STRNEWLINE ▁ ▁ returned : ▁ success STRNEWLINE ▁ ▁ type : ▁ list STRNEWLINE ▁ ▁ sample : ▁ ' [ " create " ] ' STRNEWLINE ''' NEW_LINE import os NEW_LINE from ansible . module_utils . basic import AnsibleModule NEW_LINE from ansible . module_utils . lxd import LXDClient , LXDClientException NEW_LINE # ▁ PROFILE _ STATES ▁ is ▁ a ▁ list ▁ for ▁ states ▁ supported ENDCOM PROFILES_STATES = [ ' present ' , ' absent ' ] NEW_LINE # ▁ CONFIG _ PARAMS ▁ is ▁ a ▁ list ▁ of ▁ config ▁ attribute ▁ names . ENDCOM CONFIG_PARAMS = [ ' config ' , ' description ' , ' devices ' ] NEW_LINE class LXDProfileManagement ( object ) : NEW_LINE INDENT def __init__ ( self , module ) : NEW_LINE INDENT """ Management ▁ of ▁ LXC ▁ containers ▁ via ▁ Ansible . STRNEWLINE STRNEWLINE ▁ : param ▁ module : ▁ Processed ▁ Ansible ▁ Module . STRNEWLINE ▁ : type ▁ module : ▁ ` ` object ` ` STRNEWLINE ▁ """ NEW_LINE self . module = module NEW_LINE self . name = self . module . params [ ' name ' ] NEW_LINE self . _build_config ( ) NEW_LINE self . state = self . module . params [ ' state ' ] NEW_LINE self . new_name = self . module . params . get ( ' new _ name ' , None ) NEW_LINE self . url = self . module . params [ ' url ' ] NEW_LINE self . key_file = self . module . params . get ( ' key _ file ' , None ) NEW_LINE self . cert_file = self . module . params . get ( ' cert _ file ' , None ) NEW_LINE self . debug = self . module . _verbosity >= 4 NEW_LINE try : NEW_LINE INDENT self . client = LXDClient ( self . url , key_file = self . key_file , cert_file = self . cert_file , debug = self . debug ) NEW_LINE DEDENT except LXDClientException as e : NEW_LINE INDENT self . module . fail_json ( msg = e . msg ) NEW_LINE DEDENT self . trust_password = self . module . params . get ( ' trust _ password ' , None ) NEW_LINE self . actions = [ ] NEW_LINE DEDENT def _build_config ( self ) : NEW_LINE INDENT self . config = { } NEW_LINE for attr in CONFIG_PARAMS : NEW_LINE INDENT param_val = self . module . params . get ( attr , None ) NEW_LINE if param_val is not None : NEW_LINE INDENT self . config [ attr ] = param_val NEW_LINE DEDENT DEDENT DEDENT def _get_profile_json ( self ) : NEW_LINE INDENT return self . client . do ( ' GET ' , ' / 1.0 / profiles / {0 } ' . format ( self . name ) , ok_error_codes = [ 404 ] ) NEW_LINE DEDENT @ staticmethod NEW_LINE def _profile_json_to_module_state ( resp_json ) : NEW_LINE INDENT if resp_json [ ' type ' ] == ' error ' : NEW_LINE INDENT return ' absent ' NEW_LINE DEDENT return ' present ' NEW_LINE DEDENT def _update_profile ( self ) : NEW_LINE INDENT if self . state == ' present ' : NEW_LINE INDENT if self . old_state == ' absent ' : NEW_LINE INDENT if self . new_name is None : NEW_LINE INDENT self . _create_profile ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . module . fail_json ( msg = ' new _ name ▁ must ▁ not ▁ be ▁ set ▁ when ▁ the ▁ profile ▁ does ▁ not ▁ exist ▁ and ▁ the ▁ specified ▁ state ▁ is ▁ present ' , changed = False ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . new_name is not None and self . new_name != self . name : NEW_LINE INDENT self . _rename_profile ( ) NEW_LINE DEDENT if self . _needs_to_apply_profile_configs ( ) : NEW_LINE INDENT self . _apply_profile_configs ( ) NEW_LINE DEDENT DEDENT DEDENT elif self . state == ' absent ' : NEW_LINE INDENT if self . old_state == ' present ' : NEW_LINE INDENT if self . new_name is None : NEW_LINE INDENT self . _delete_profile ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . module . fail_json ( msg = ' new _ name ▁ must ▁ not ▁ be ▁ set ▁ when ▁ the ▁ profile ▁ exists ▁ and ▁ the ▁ specified ▁ state ▁ is ▁ absent ' , changed = False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def _create_profile ( self ) : NEW_LINE INDENT config = self . config . copy ( ) NEW_LINE config [ ' name ' ] = self . name NEW_LINE self . client . do ( ' POST ' , ' / 1.0 / profiles ' , config ) NEW_LINE self . actions . append ( ' create ' ) NEW_LINE DEDENT def _rename_profile ( self ) : NEW_LINE INDENT config = { ' name ' : self . new_name } NEW_LINE self . client . do ( ' POST ' , ' / 1.0 / profiles / { } ' . format ( self . name ) , config ) NEW_LINE self . actions . append ( ' rename ' ) NEW_LINE self . name = self . new_name NEW_LINE DEDENT def _needs_to_change_profile_config ( self , key ) : NEW_LINE INDENT if key not in self . config : NEW_LINE INDENT return False NEW_LINE DEDENT old_configs = self . old_profile_json [ ' metadata ' ] . get ( key , None ) NEW_LINE return self . config [ key ] != old_configs NEW_LINE DEDENT def _needs_to_apply_profile_configs ( self ) : NEW_LINE INDENT return ( self . _needs_to_change_profile_config ( ' config ' ) or self . _needs_to_change_profile_config ( ' description ' ) or self . _needs_to_change_profile_config ( ' devices ' ) ) NEW_LINE DEDENT def _apply_profile_configs ( self ) : NEW_LINE INDENT config = self . old_profile_json . copy ( ) NEW_LINE for k , v in self . config . items ( ) : NEW_LINE INDENT config [ k ] = v NEW_LINE DEDENT self . client . do ( ' PUT ' , ' / 1.0 / profiles / { } ' . format ( self . name ) , config ) NEW_LINE self . actions . append ( ' apply _ profile _ configs ' ) NEW_LINE DEDENT def _delete_profile ( self ) : NEW_LINE INDENT self . client . do ( ' DELETE ' , ' / 1.0 / profiles / { } ' . format ( self . name ) ) NEW_LINE self . actions . append ( ' delete ' ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT """ Run ▁ the ▁ main ▁ method . """ NEW_LINE try : NEW_LINE INDENT if self . trust_password is not None : NEW_LINE INDENT self . client . authenticate ( self . trust_password ) NEW_LINE DEDENT self . old_profile_json = self . _get_profile_json ( ) NEW_LINE self . old_state = self . _profile_json_to_module_state ( self . old_profile_json ) NEW_LINE self . _update_profile ( ) NEW_LINE state_changed = len ( self . actions ) > 0 NEW_LINE result_json = { ' changed ' : state_changed , ' old _ state ' : self . old_state , ' actions ' : self . actions } NEW_LINE if self . client . debug : NEW_LINE INDENT result_json [ ' logs ' ] = self . client . logs NEW_LINE DEDENT self . module . exit_json ( ** result_json ) NEW_LINE DEDENT except LXDClientException as e : NEW_LINE INDENT state_changed = len ( self . actions ) > 0 NEW_LINE fail_params = { ' msg ' : e . msg , ' changed ' : state_changed , ' actions ' : self . actions } NEW_LINE if self . client . debug : NEW_LINE INDENT fail_params [ ' logs ' ] = e . kwargs [ ' logs ' ] NEW_LINE DEDENT self . module . fail_json ( ** fail_params ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT """ Ansible ▁ Main ▁ module . """ NEW_LINE module = AnsibleModule ( argument_spec = dict ( name = dict ( type = ' str ' , required = True ) , new_name = dict ( type = ' str ' , ) , config = dict ( type = ' dict ' , ) , description = dict ( type = ' str ' , ) , devices = dict ( type = ' dict ' , ) , state = dict ( choices = PROFILES_STATES , default = ' present ' ) , url = dict ( type = ' str ' , default = ' unix : / var / lib / lxd / unix . socket ' ) , key_file = dict ( type = ' str ' , default = ' { } / . config / lxc / client . key ' . format ( os . environ [ ' HOME ' ] ) ) , cert_file = dict ( type = ' str ' , default = ' { } / . config / lxc / client . crt ' . format ( os . environ [ ' HOME ' ] ) ) , trust_password = dict ( type = ' str ' , no_log = True ) ) , supports_check_mode = False , ) NEW_LINE lxd_manage = LXDProfileManagement ( module = module ) NEW_LINE lxd_manage . run ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="shsingh/ansible/tree/master/lib/ansible/modules/cloud/azure/azure_rm_securitygroup.py"> # ! / usr / bin / python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2016 ▁ Matt ▁ Davis , ▁ < mdavis @ ansible . com > ENDCOM # ▁ Chris ▁ Houseknecht , ▁ < house @ redhat . com > ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ v3.0 + ▁ ( see ▁ COPYING ▁ or ▁ https : / / www . gnu . org / licenses / gpl - 3.0 . txt ) ENDCOM from __future__ import absolute_import , division , print_function NEW_LINE __metaclass__ = type NEW_LINE ANSIBLE_METADATA = { ' metadata _ version ' : '1.1' , ' status ' : [ ' preview ' ] , ' supported _ by ' : ' community ' } NEW_LINE DOCUMENTATION = ''' STRNEWLINE - - - STRNEWLINE module : ▁ azure _ rm _ securitygroup STRNEWLINE version _ added : ▁ " 2.1 " STRNEWLINE short _ description : ▁ Manage ▁ Azure ▁ network ▁ security ▁ groups . STRNEWLINE description : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ Create , ▁ update ▁ or ▁ delete ▁ a ▁ network ▁ security ▁ group . ▁ A ▁ security ▁ group ▁ contains ▁ Access ▁ Control ▁ List ▁ ( ACL ) ▁ rules STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ that ▁ allow ▁ or ▁ deny ▁ network ▁ traffic ▁ to ▁ subnets ▁ or ▁ individual ▁ network ▁ interfaces . ▁ A ▁ security ▁ group ▁ is ▁ created STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ with ▁ a ▁ set ▁ of ▁ default ▁ security ▁ rules ▁ and ▁ an ▁ empty ▁ set ▁ of ▁ security ▁ rules . ▁ Shape ▁ traffic ▁ flow ▁ by ▁ adding STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ rules ▁ to ▁ the ▁ empty ▁ set ▁ of ▁ security ▁ rules . STRNEWLINE STRNEWLINE options : STRNEWLINE ▁ ▁ ▁ ▁ default _ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ set ▁ of ▁ default ▁ rules ▁ automatically ▁ added ▁ to ▁ a ▁ security ▁ group ▁ at ▁ creation . ▁ In ▁ general ▁ default STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ rules ▁ will ▁ not ▁ be ▁ modified . ▁ Modify ▁ rules ▁ to ▁ shape ▁ the ▁ flow ▁ of ▁ traffic ▁ to ▁ or ▁ from ▁ a ▁ subnet ▁ or ▁ NIC . ▁ See STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ rules ▁ below ▁ for ▁ the ▁ makeup ▁ of ▁ a ▁ rule ▁ dict . STRNEWLINE ▁ ▁ ▁ ▁ location : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Valid ▁ azure ▁ location . ▁ Defaults ▁ to ▁ location ▁ of ▁ the ▁ resource ▁ group . STRNEWLINE ▁ ▁ ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Name ▁ of ▁ the ▁ security ▁ group ▁ to ▁ operate ▁ on . STRNEWLINE ▁ ▁ ▁ ▁ purge _ default _ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Remove ▁ any ▁ existing ▁ rules ▁ not ▁ matching ▁ those ▁ defined ▁ in ▁ the ▁ default _ rules ▁ parameter . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' no ' STRNEWLINE ▁ ▁ ▁ ▁ purge _ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Remove ▁ any ▁ existing ▁ rules ▁ not ▁ matching ▁ those ▁ defined ▁ in ▁ the ▁ rules ▁ parameters . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' no ' STRNEWLINE ▁ ▁ ▁ ▁ resource _ group : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Name ▁ of ▁ the ▁ resource ▁ group ▁ the ▁ security ▁ group ▁ belongs ▁ to . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Set ▁ of ▁ rules ▁ shaping ▁ traffic ▁ flow ▁ to ▁ or ▁ from ▁ a ▁ subnet ▁ or ▁ NIC . ▁ Each ▁ rule ▁ is ▁ a ▁ dictionary . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ suboptions : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Unique ▁ name ▁ for ▁ the ▁ rule . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Short ▁ description ▁ of ▁ the ▁ rule ' s ▁ purpose . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : ▁ Accepted ▁ traffic ▁ protocol . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Udp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ port _ range : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Port ▁ or ▁ range ▁ of ▁ ports ▁ from ▁ which ▁ traffic ▁ originates . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Port ▁ or ▁ range ▁ of ▁ ports ▁ to ▁ which ▁ traffic ▁ is ▁ headed . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ CIDR ▁ or ▁ source ▁ IP ▁ range . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Asterisk ▁ C ( * ) ▁ can ▁ also ▁ be ▁ used ▁ to ▁ match ▁ all ▁ source ▁ IPs . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Default ▁ tags ▁ such ▁ as ▁ C ( VirtualNetwork ) , ▁ C ( AzureLoadBalancer ) ▁ and ▁ C ( Internet ) ▁ can ▁ also ▁ be ▁ used . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ If ▁ this ▁ is ▁ an ▁ ingress ▁ rule , ▁ specifies ▁ where ▁ network ▁ traffic ▁ originates ▁ from . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ destination ▁ address ▁ prefix . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ CIDR ▁ or ▁ destination ▁ IP ▁ range . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Asterisk ▁ C ( * ) ▁ can ▁ also ▁ be ▁ used ▁ to ▁ match ▁ all ▁ source ▁ IPs . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Default ▁ tags ▁ such ▁ as ▁ C ( VirtualNetwork ) , ▁ C ( AzureLoadBalancer ) ▁ and ▁ C ( Internet ) ▁ can ▁ also ▁ be ▁ used . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ It ▁ can ▁ accept ▁ string ▁ type ▁ or ▁ a ▁ list ▁ of ▁ string ▁ type . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Whether ▁ or ▁ not ▁ to ▁ allow ▁ the ▁ traffic ▁ flow . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Deny STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Order ▁ in ▁ which ▁ to ▁ apply ▁ the ▁ rule . ▁ Must ▁ a ▁ unique ▁ integer ▁ between ▁ 100 ▁ and ▁ 4096 ▁ inclusive . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Indicates ▁ the ▁ direction ▁ of ▁ the ▁ traffic ▁ flow . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Outbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Assert ▁ the ▁ state ▁ of ▁ the ▁ security ▁ group . ▁ Set ▁ to ▁ C ( present ) ▁ to ▁ create ▁ or ▁ update ▁ a ▁ security ▁ group . ▁ Set ▁ to STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ C ( absent ) ▁ to ▁ remove ▁ a ▁ security ▁ group . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ present STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ absent STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ present STRNEWLINE STRNEWLINE extends _ documentation _ fragment : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ azure STRNEWLINE ▁ ▁ ▁ ▁ - ▁ azure _ tags STRNEWLINE STRNEWLINE author : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Chris ▁ Houseknecht ▁ ( @ chouseknecht ) " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Matt ▁ Davis ▁ ( @ nitzmahone ) " STRNEWLINE STRNEWLINE ''' NEW_LINE EXAMPLES = ''' STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ security ▁ group STRNEWLINE - ▁ azure _ rm _ securitygroup : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ resource _ group : ▁ myResourceGroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ mysecgroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ purge _ rules : ▁ yes STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ DenySSH STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Deny STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 100 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ ' AllowSSH ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.158.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.159.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 101 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ ' AllowMultiplePorts ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.158.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ' 174.109.159.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ 80 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ 443 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 102 STRNEWLINE STRNEWLINE # ▁ Update ▁ rules ▁ on ▁ existing ▁ security ▁ group STRNEWLINE - ▁ azure _ rm _ securitygroup : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ resource _ group : ▁ myResourceGroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ mysecgroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ rules : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ DenySSH STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22-23 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Deny STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 100 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name : ▁ AllowSSHFromHome STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ protocol : ▁ Tcp STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ source _ address _ prefix : ▁ ' 174.109.158.0/24 ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ destination _ port _ range : ▁ 22-23 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ access : ▁ Allow STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ priority : ▁ 102 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ direction : ▁ Inbound STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ tags : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ testing : ▁ testing STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ delete : ▁ on - exit STRNEWLINE STRNEWLINE # ▁ Delete ▁ security ▁ group STRNEWLINE - ▁ azure _ rm _ securitygroup : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ resource _ group : ▁ myResourceGroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ mysecgroup STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ state : ▁ absent STRNEWLINE ''' NEW_LINE RETURN = ''' STRNEWLINE state : STRNEWLINE ▁ ▁ ▁ ▁ description : ▁ Current ▁ state ▁ of ▁ the ▁ security ▁ group . STRNEWLINE ▁ ▁ ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ dict STRNEWLINE ▁ ▁ ▁ ▁ sample : ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " default _ rules " : ▁ [ STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ inbound ▁ traffic ▁ from ▁ all ▁ VMs ▁ in ▁ VNET " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowVnetInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowVnetInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65000 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ inbound ▁ traffic ▁ from ▁ azure ▁ load ▁ balancer " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowAzureLoadBalancerInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowAzureLoadBalancerInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65001 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " AzureLoadBalancer " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Deny " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Deny ▁ all ▁ inbound ▁ traffic " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / DenyAllInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " DenyAllInBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65500 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ outbound ▁ traffic ▁ from ▁ all ▁ VMs ▁ to ▁ all ▁ VMs ▁ in ▁ VNET " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Outbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowVnetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowVnetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65000 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " VirtualNetwork " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Allow ▁ outbound ▁ traffic ▁ from ▁ all ▁ VMs ▁ to ▁ Internet " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " Internet " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Outbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / AllowInternetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowInternetOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65001 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Deny " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ " Deny ▁ all ▁ outbound ▁ traffic " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Outbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / defaultSecurityRules / DenyAllOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " DenyAllOutBound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 65500 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " location " : ▁ " westus " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " mysecgroup " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " network _ interfaces " : ▁ [ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " rules " : ▁ [ STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Deny " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ null , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " 22 " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / securityRules / DenySSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " DenySSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 100 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " Tcp " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " access " : ▁ " Allow " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " description " : ▁ null , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ address _ prefix " : ▁ " * " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " destination _ port _ range " : ▁ " 22 " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " direction " : ▁ " Inbound " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " etag " : ▁ ' W / " edf48d56 - b315-40ca - a85d - dbcb47f2da7d " ' , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " id " : ▁ " / subscriptions / xxxxxxxx - xxxx - xxxx - xxxx - xxxxxxxxxxxx / resourceGroup / myResourceGroup / providers / Microsoft . Network / networkSecurityGroups / mysecgroup / securityRules / AllowSSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " name " : ▁ " AllowSSH " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " priority " : ▁ 101 , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " protocol " : ▁ " Tcp " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " provisioning _ state " : ▁ " Succeeded " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ address _ prefix " : ▁ " 174.109.158.0/24 " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " source _ port _ range " : ▁ " * " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " subnets " : ▁ [ ] , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " tags " : ▁ { STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " delete " : ▁ " on - exit " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " foo " : ▁ " bar " , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " testing " : ▁ " testing " STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " type " : ▁ " Microsoft . Network / networkSecurityGroups " STRNEWLINE ▁ ▁ ▁ ▁ } STRNEWLINE ''' # ▁ NOQA ENDCOM NEW_LINE try : NEW_LINE INDENT from msrestazure . azure_exceptions import CloudError NEW_LINE from azure . mgmt . network import NetworkManagementClient NEW_LINE DEDENT except ImportError : NEW_LINE # ▁ This ▁ is ▁ handled ▁ in ▁ azure _ rm _ common ENDCOM INDENT pass NEW_LINE DEDENT from ansible . module_utils . azure_rm_common import AzureRMModuleBase NEW_LINE from ansible . module_utils . six import integer_types NEW_LINE from ansible . module_utils . _text import to_native NEW_LINE def validate_rule ( self , rule , rule_type = None ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Apply ▁ defaults ▁ to ▁ a ▁ rule ▁ dictionary ▁ and ▁ check ▁ that ▁ all ▁ values ▁ are ▁ valid . STRNEWLINE STRNEWLINE ▁ : param ▁ rule : ▁ rule ▁ dict STRNEWLINE ▁ : param ▁ rule _ type : ▁ Set ▁ to ▁ ' default ' ▁ if ▁ the ▁ rule ▁ is ▁ part ▁ of ▁ the ▁ default ▁ set ▁ of ▁ rules . STRNEWLINE ▁ : return : ▁ None STRNEWLINE ▁ ''' NEW_LINE priority = rule . get ( ' priority ' , 0 ) NEW_LINE if rule_type != ' default ' and ( priority < 100 or priority > 4096 ) : NEW_LINE INDENT raise Exception ( " Rule ▁ priority ▁ must ▁ be ▁ between ▁ 100 ▁ and ▁ 4096" ) NEW_LINE DEDENT def check_plural ( src , dest ) : NEW_LINE INDENT if isinstance ( rule . get ( src ) , list ) : NEW_LINE INDENT rule [ dest ] = rule [ src ] NEW_LINE rule [ src ] = None NEW_LINE DEDENT DEDENT check_plural ( ' destination _ address _ prefix ' , ' destination _ address _ prefixes ' ) NEW_LINE check_plural ( ' source _ address _ prefix ' , ' source _ address _ prefixes ' ) NEW_LINE check_plural ( ' source _ port _ range ' , ' source _ port _ ranges ' ) NEW_LINE check_plural ( ' destination _ port _ range ' , ' destination _ port _ ranges ' ) NEW_LINE DEDENT def compare_rules_change ( old_list , new_list , purge_list ) : NEW_LINE INDENT old_list = old_list or [ ] NEW_LINE new_list = new_list or [ ] NEW_LINE changed = False NEW_LINE for old_rule in old_list : NEW_LINE INDENT matched = next ( ( x for x in new_list if x [ ' name ' ] == old_rule [ ' name ' ] ) , [ ] ) NEW_LINE if matched : # ▁ if ▁ the ▁ new ▁ one ▁ is ▁ in ▁ the ▁ old ▁ list , ▁ check ▁ whether ▁ it ▁ is ▁ updated ENDCOM NEW_LINE INDENT changed = changed or compare_rules ( old_rule , matched ) NEW_LINE DEDENT elif not purge_list : # ▁ keep ▁ this ▁ rule ENDCOM NEW_LINE INDENT new_list . append ( old_rule ) NEW_LINE DEDENT else : # ▁ one ▁ rule ▁ is ▁ removed ENDCOM NEW_LINE INDENT changed = True NEW_LINE # ▁ Compare ▁ new ▁ list ▁ and ▁ old ▁ list ▁ is ▁ the ▁ same ? ▁ here ▁ only ▁ compare ▁ names ENDCOM DEDENT DEDENT if not changed : NEW_LINE INDENT new_names = [ to_native ( x [ ' name ' ] ) for x in new_list ] NEW_LINE old_names = [ to_native ( x [ ' name ' ] ) for x in old_list ] NEW_LINE changed = ( set ( new_names ) != set ( old_names ) ) NEW_LINE DEDENT return changed , new_list NEW_LINE DEDENT def compare_rules ( old_rule , rule ) : NEW_LINE INDENT changed = False NEW_LINE if old_rule [ ' name ' ] != rule [ ' name ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule . get ( ' description ' , None ) != old_rule [ ' description ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' protocol ' ] != old_rule [ ' protocol ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' source _ port _ range ' ] ) != str ( old_rule [ ' source _ port _ range ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' destination _ port _ range ' ] ) != str ( old_rule [ ' destination _ port _ range ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' access ' ] != old_rule [ ' access ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' priority ' ] != old_rule [ ' priority ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' direction ' ] != old_rule [ ' direction ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' source _ address _ prefix ' ] ) != str ( old_rule [ ' source _ address _ prefix ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' destination _ address _ prefix ' ] ) != str ( old_rule [ ' destination _ address _ prefix ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' source _ address _ prefixes ' ) or [ ] ) != set ( old_rule . get ( ' source _ address _ prefixes ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' destination _ address _ prefixes ' ) or [ ] ) != set ( old_rule . get ( ' destination _ address _ prefixes ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' source _ port _ ranges ' ) or [ ] ) != set ( old_rule . get ( ' source _ port _ ranges ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' destination _ port _ ranges ' ) or [ ] ) != set ( old_rule . get ( ' destination _ port _ ranges ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT return changed NEW_LINE DEDENT def create_rule_instance ( self , rule ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Create ▁ an ▁ instance ▁ of ▁ SecurityRule ▁ from ▁ a ▁ dict . STRNEWLINE STRNEWLINE ▁ : param ▁ rule : ▁ dict STRNEWLINE ▁ : return : ▁ SecurityRule STRNEWLINE ▁ ''' NEW_LINE return self . nsg_models . SecurityRule ( description = rule . get ( ' description ' , None ) , protocol = rule . get ( ' protocol ' , None ) , source_port_range = rule . get ( ' source _ port _ range ' , None ) , destination_port_range = rule . get ( ' destination _ port _ range ' , None ) , source_address_prefix = rule . get ( ' source _ address _ prefix ' , None ) , source_address_prefixes = rule . get ( ' source _ address _ prefixes ' , None ) , destination_address_prefix = rule . get ( ' destination _ address _ prefix ' , None ) , destination_address_prefixes = rule . get ( ' destination _ address _ prefixes ' , None ) , source_port_ranges = rule . get ( ' source _ port _ ranges ' , None ) , destination_port_ranges = rule . get ( ' destination _ port _ ranges ' , None ) , access = rule . get ( ' access ' , None ) , priority = rule . get ( ' priority ' , None ) , direction = rule . get ( ' direction ' , None ) , provisioning_state = rule . get ( ' provisioning _ state ' , None ) , name = rule . get ( ' name ' , None ) , etag = rule . get ( ' etag ' , None ) ) NEW_LINE DEDENT def create_rule_dict_from_obj ( rule ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Create ▁ a ▁ dict ▁ from ▁ an ▁ instance ▁ of ▁ a ▁ SecurityRule . STRNEWLINE STRNEWLINE ▁ : param ▁ rule : ▁ SecurityRule STRNEWLINE ▁ : return : ▁ dict STRNEWLINE ▁ ''' NEW_LINE return dict ( id = rule . id , name = rule . name , description = rule . description , protocol = rule . protocol , source_port_range = rule . source_port_range , destination_port_range = rule . destination_port_range , source_address_prefix = rule . source_address_prefix , destination_address_prefix = rule . destination_address_prefix , source_port_ranges = rule . source_port_ranges , destination_port_ranges = rule . destination_port_ranges , source_address_prefixes = rule . source_address_prefixes , destination_address_prefixes = rule . destination_address_prefixes , access = rule . access , priority = rule . priority , direction = rule . direction , provisioning_state = rule . provisioning_state , etag = rule . etag ) NEW_LINE DEDENT def create_network_security_group_dict ( nsg ) : NEW_LINE INDENT results = dict ( id = nsg . id , name = nsg . name , type = nsg . type , location = nsg . location , tags = nsg . tags , ) NEW_LINE results [ ' rules ' ] = [ ] NEW_LINE if nsg . security_rules : NEW_LINE INDENT for rule in nsg . security_rules : NEW_LINE INDENT results [ ' rules ' ] . append ( create_rule_dict_from_obj ( rule ) ) NEW_LINE DEDENT DEDENT results [ ' default _ rules ' ] = [ ] NEW_LINE if nsg . default_security_rules : NEW_LINE INDENT for rule in nsg . default_security_rules : NEW_LINE INDENT results [ ' default _ rules ' ] . append ( create_rule_dict_from_obj ( rule ) ) NEW_LINE DEDENT DEDENT results [ ' network _ interfaces ' ] = [ ] NEW_LINE if nsg . network_interfaces : NEW_LINE INDENT for interface in nsg . network_interfaces : NEW_LINE INDENT results [ ' network _ interfaces ' ] . append ( interface . id ) NEW_LINE DEDENT DEDENT results [ ' subnets ' ] = [ ] NEW_LINE if nsg . subnets : NEW_LINE INDENT for subnet in nsg . subnets : NEW_LINE INDENT results [ ' subnets ' ] . append ( subnet . id ) NEW_LINE DEDENT DEDENT return results NEW_LINE DEDENT rule_spec = dict ( name = dict ( type = ' str ' , required = True ) , description = dict ( type = ' str ' ) , protocol = dict ( type = ' str ' , choices = [ ' Udp ' , ' Tcp ' , ' * ' ] , default = ' * ' ) , source_port_range = dict ( type = ' raw ' , default = ' * ' ) , destination_port_range = dict ( type = ' raw ' , default = ' * ' ) , source_address_prefix = dict ( type = ' raw ' , default = ' * ' ) , destination_address_prefix = dict ( type = ' raw ' , default = ' * ' ) , access = dict ( type = ' str ' , choices = [ ' Allow ' , ' Deny ' ] , default = ' Allow ' ) , priority = dict ( type = ' int ' , required = True ) , direction = dict ( type = ' str ' , choices = [ ' Inbound ' , ' Outbound ' ] , default = ' Inbound ' ) ) NEW_LINE class AzureRMSecurityGroup ( AzureRMModuleBase ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . module_arg_spec = dict ( default_rules = dict ( type = ' list ' , elements = ' dict ' , options = rule_spec ) , location = dict ( type = ' str ' ) , name = dict ( type = ' str ' , required = True ) , purge_default_rules = dict ( type = ' bool ' , default = False ) , purge_rules = dict ( type = ' bool ' , default = False ) , resource_group = dict ( required = True , type = ' str ' ) , rules = dict ( type = ' list ' , elements = ' dict ' , options = rule_spec ) , state = dict ( type = ' str ' , default = ' present ' , choices = [ ' present ' , ' absent ' ] ) , ) NEW_LINE self . default_rules = None NEW_LINE self . location = None NEW_LINE self . name = None NEW_LINE self . purge_default_rules = None NEW_LINE self . purge_rules = None NEW_LINE self . resource_group = None NEW_LINE self . rules = None NEW_LINE self . state = None NEW_LINE self . tags = None NEW_LINE self . nsg_models = None # ▁ type : ▁ azure . mgmt . network . models ENDCOM NEW_LINE self . results = dict ( changed = False , state = dict ( ) ) NEW_LINE super ( AzureRMSecurityGroup , self ) . __init__ ( self . module_arg_spec , supports_check_mode = True ) NEW_LINE DEDENT def exec_module ( self , ** kwargs ) : NEW_LINE # ▁ tighten ▁ up ▁ poll ▁ interval ▁ for ▁ security ▁ groups ; ▁ default ▁ 30s ▁ is ▁ an ▁ eternity ENDCOM # ▁ this ▁ value ▁ is ▁ still ▁ overridden ▁ by ▁ the ▁ response ▁ Retry - After ▁ header ▁ ( which ▁ is ▁ set ▁ on ▁ the ▁ initial ▁ operation ▁ response ▁ to ▁ 10s ) ENDCOM INDENT self . network_client . config . long_running_operation_timeout = 3 NEW_LINE self . nsg_models = self . network_client . network_security_groups . models NEW_LINE for key in list ( self . module_arg_spec . keys ( ) ) + [ ' tags ' ] : NEW_LINE INDENT setattr ( self , key , kwargs [ key ] ) NEW_LINE DEDENT changed = False NEW_LINE results = dict ( ) NEW_LINE resource_group = self . get_resource_group ( self . resource_group ) NEW_LINE if not self . location : NEW_LINE # ▁ Set ▁ default ▁ location ENDCOM INDENT self . location = resource_group . location NEW_LINE DEDENT if self . rules : NEW_LINE INDENT for rule in self . rules : NEW_LINE INDENT try : NEW_LINE INDENT validate_rule ( self , rule ) NEW_LINE DEDENT except Exception as exc : NEW_LINE INDENT self . fail ( " Error ▁ validating ▁ rule ▁ { 0 } ▁ - ▁ { 1 } " . format ( rule , str ( exc ) ) ) NEW_LINE DEDENT DEDENT DEDENT if self . default_rules : NEW_LINE INDENT for rule in self . default_rules : NEW_LINE INDENT try : NEW_LINE INDENT validate_rule ( self , rule , ' default ' ) NEW_LINE DEDENT except Exception as exc : NEW_LINE INDENT self . fail ( " Error ▁ validating ▁ default ▁ rule ▁ { 0 } ▁ - ▁ { 1 } " . format ( rule , str ( exc ) ) ) NEW_LINE DEDENT DEDENT DEDENT try : NEW_LINE INDENT nsg = self . network_client . network_security_groups . get ( self . resource_group , self . name ) NEW_LINE results = create_network_security_group_dict ( nsg ) NEW_LINE self . log ( " Found ▁ security ▁ group : " ) NEW_LINE self . log ( results , pretty_print = True ) NEW_LINE self . check_provisioning_state ( nsg , self . state ) NEW_LINE if self . state == ' present ' : NEW_LINE INDENT pass NEW_LINE DEDENT elif self . state == ' absent ' : NEW_LINE INDENT self . log ( " CHANGED : ▁ security ▁ group ▁ found ▁ but ▁ state ▁ is ▁ ' absent ' " ) NEW_LINE changed = True NEW_LINE DEDENT DEDENT except CloudError : # ▁ TODO : ▁ actually ▁ check ▁ for ▁ ResourceMissingError ENDCOM NEW_LINE INDENT if self . state == ' present ' : NEW_LINE INDENT self . log ( " CHANGED : ▁ security ▁ group ▁ not ▁ found ▁ and ▁ state ▁ is ▁ ' present ' " ) NEW_LINE changed = True NEW_LINE DEDENT DEDENT if self . state == ' present ' and not changed : NEW_LINE # ▁ update ▁ the ▁ security ▁ group ENDCOM INDENT self . log ( " Update ▁ security ▁ group ▁ { 0 } " . format ( self . name ) ) NEW_LINE update_tags , results [ ' tags ' ] = self . update_tags ( results [ ' tags ' ] ) NEW_LINE if update_tags : NEW_LINE INDENT changed = True NEW_LINE DEDENT rule_changed , new_rule = compare_rules_change ( results [ ' rules ' ] , self . rules , self . purge_rules ) NEW_LINE if rule_changed : NEW_LINE INDENT changed = True NEW_LINE results [ ' rules ' ] = new_rule NEW_LINE DEDENT rule_changed , new_rule = compare_rules_change ( results [ ' default _ rules ' ] , self . default_rules , self . purge_default_rules ) NEW_LINE if rule_changed : NEW_LINE INDENT changed = True NEW_LINE results [ ' default _ rules ' ] = new_rule NEW_LINE DEDENT self . results [ ' changed ' ] = changed NEW_LINE self . results [ ' state ' ] = results NEW_LINE if not self . check_mode and changed : NEW_LINE INDENT self . results [ ' state ' ] = self . create_or_update ( results ) NEW_LINE DEDENT DEDENT elif self . state == ' present ' and changed : NEW_LINE # ▁ create ▁ the ▁ security ▁ group ENDCOM INDENT self . log ( " Create ▁ security ▁ group ▁ { 0 } " . format ( self . name ) ) NEW_LINE if not self . location : NEW_LINE INDENT self . fail ( " Parameter ▁ error : ▁ location ▁ required ▁ when ▁ creating ▁ a ▁ security ▁ group . " ) NEW_LINE DEDENT results [ ' name ' ] = self . name NEW_LINE results [ ' location ' ] = self . location NEW_LINE results [ ' rules ' ] = [ ] NEW_LINE results [ ' default _ rules ' ] = [ ] NEW_LINE results [ ' tags ' ] = { } NEW_LINE if self . rules : NEW_LINE INDENT results [ ' rules ' ] = self . rules NEW_LINE DEDENT if self . default_rules : NEW_LINE INDENT results [ ' default _ rules ' ] = self . default_rules NEW_LINE DEDENT if self . tags : NEW_LINE INDENT results [ ' tags ' ] = self . tags NEW_LINE DEDENT self . results [ ' changed ' ] = changed NEW_LINE self . results [ ' state ' ] = results NEW_LINE if not self . check_mode : NEW_LINE INDENT self . results [ ' state ' ] = self . create_or_update ( results ) NEW_LINE DEDENT DEDENT elif self . state == ' absent ' and changed : NEW_LINE INDENT self . log ( " Delete ▁ security ▁ group ▁ { 0 } " . format ( self . name ) ) NEW_LINE self . results [ ' changed ' ] = changed NEW_LINE self . results [ ' state ' ] = dict ( ) NEW_LINE if not self . check_mode : NEW_LINE INDENT self . delete ( ) NEW_LINE # ▁ the ▁ delete ▁ does ▁ not ▁ actually ▁ return ▁ anything . ▁ if ▁ no ▁ exception , ▁ then ▁ we ' ll ▁ assume ENDCOM # ▁ it ▁ worked . ENDCOM self . results [ ' state ' ] [ ' status ' ] = ' Deleted ' NEW_LINE DEDENT DEDENT return self . results NEW_LINE DEDENT def create_or_update ( self , results ) : NEW_LINE INDENT parameters = self . nsg_models . NetworkSecurityGroup ( ) NEW_LINE if results . get ( ' rules ' ) : NEW_LINE INDENT parameters . security_rules = [ ] NEW_LINE for rule in results . get ( ' rules ' ) : NEW_LINE INDENT parameters . security_rules . append ( create_rule_instance ( self , rule ) ) NEW_LINE DEDENT DEDENT if results . get ( ' default _ rules ' ) : NEW_LINE INDENT parameters . default_security_rules = [ ] NEW_LINE for rule in results . get ( ' default _ rules ' ) : NEW_LINE INDENT parameters . default_security_rules . append ( create_rule_instance ( self , rule ) ) NEW_LINE DEDENT DEDENT parameters . tags = results . get ( ' tags ' ) NEW_LINE parameters . location = results . get ( ' location ' ) NEW_LINE try : NEW_LINE INDENT poller = self . network_client . network_security_groups . create_or_update ( resource_group_name = self . resource_group , network_security_group_name = self . name , parameters = parameters ) NEW_LINE result = self . get_poller_result ( poller ) NEW_LINE DEDENT except CloudError as exc : NEW_LINE INDENT self . fail ( " Error ▁ creating / updating ▁ security ▁ group ▁ { 0 } ▁ - ▁ { 1 } " . format ( self . name , str ( exc ) ) ) NEW_LINE DEDENT return create_network_security_group_dict ( result ) NEW_LINE DEDENT def delete ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT poller = self . network_client . network_security_groups . delete ( resource_group_name = self . resource_group , network_security_group_name = self . name ) NEW_LINE result = self . get_poller_result ( poller ) NEW_LINE DEDENT except CloudError as exc : NEW_LINE INDENT raise Exception ( " Error ▁ deleting ▁ security ▁ group ▁ { 0 } ▁ - ▁ { 1 } " . format ( self . name , str ( exc ) ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT AzureRMSecurityGroup ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="adobe/chromium/tree/master/third_party/closure_linter/closure_linter/error_fixer.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ 2007 ▁ The ▁ Closure ▁ Linter ▁ Authors . ▁ All ▁ Rights ▁ Reserved . ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ENDCOM # ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM # ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS - IS " ▁ BASIS , ENDCOM # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM # ▁ limitations ▁ under ▁ the ▁ License . ENDCOM """ Main ▁ class ▁ responsible ▁ for ▁ automatically ▁ fixing ▁ simple ▁ style ▁ violations . """ NEW_LINE __author__ = ' robbyw @ google . com ▁ ( Robert ▁ Walker ) ' NEW_LINE import re NEW_LINE import gflags as flags NEW_LINE from closure_linter import errors NEW_LINE from closure_linter import javascriptstatetracker NEW_LINE from closure_linter import javascripttokens NEW_LINE from closure_linter import requireprovidesorter NEW_LINE from closure_linter import tokenutil NEW_LINE from closure_linter . common import errorhandler NEW_LINE # ▁ Shorthand ENDCOM Token = javascripttokens . JavaScriptToken NEW_LINE Type = javascripttokens . JavaScriptTokenType NEW_LINE END_OF_FLAG_TYPE = re . compile ( r ' ( } ? \s * ) $ ' ) NEW_LINE # ▁ Regex ▁ to ▁ represent ▁ common ▁ mistake ▁ inverting ▁ author ▁ name ▁ and ▁ email ▁ as ENDCOM # ▁ @ author ▁ User ▁ Name ▁ ( user @ company ) ENDCOM INVERTED_AUTHOR_SPEC = re . compile ( r ' ( ? P < leading _ whitespace > \s * ) ' ' ( ? P < name > [ ^ ( ] + ) ' ' ( ? P < whitespace _ after _ name > \s + ) ' ' ( ? P < email > [ ^ \s ] + @ [ ^ ) \s ] + ) ' ' ( ? P < trailing _ characters > . * ) ' ) FLAGS = flags . FLAGS NEW_LINE flags . DEFINE_boolean ( ' disable _ indentation _ fixing ' , False , ' Whether ▁ to ▁ disable ▁ automatic ▁ fixing ▁ of ▁ indentation . ' ) NEW_LINE class ErrorFixer ( errorhandler . ErrorHandler ) : NEW_LINE INDENT """ Object ▁ that ▁ fixes ▁ simple ▁ style ▁ errors . """ NEW_LINE def __init__ ( self , external_file = None ) : NEW_LINE INDENT """ Initialize ▁ the ▁ error ▁ fixer . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ external _ file : ▁ If ▁ included , ▁ all ▁ output ▁ will ▁ be ▁ directed ▁ to ▁ this ▁ file STRNEWLINE ▁ instead ▁ of ▁ overwriting ▁ the ▁ files ▁ the ▁ errors ▁ are ▁ found ▁ in . STRNEWLINE ▁ """ NEW_LINE errorhandler . ErrorHandler . __init__ ( self ) NEW_LINE self . _file_name = None NEW_LINE self . _file_token = None NEW_LINE self . _external_file = external_file NEW_LINE DEDENT def HandleFile ( self , filename , first_token ) : NEW_LINE INDENT """ Notifies ▁ this ▁ ErrorPrinter ▁ that ▁ subsequent ▁ errors ▁ are ▁ in ▁ filename . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ filename : ▁ The ▁ name ▁ of ▁ the ▁ file ▁ about ▁ to ▁ be ▁ checked . STRNEWLINE ▁ first _ token : ▁ The ▁ first ▁ token ▁ in ▁ the ▁ file . STRNEWLINE ▁ """ NEW_LINE self . _file_name = filename NEW_LINE self . _file_token = first_token NEW_LINE self . _file_fix_count = 0 NEW_LINE self . _file_changed_lines = set ( ) NEW_LINE DEDENT def _AddFix ( self , tokens ) : NEW_LINE INDENT """ Adds ▁ the ▁ fix ▁ to ▁ the ▁ internal ▁ count . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ tokens : ▁ The ▁ token ▁ or ▁ sequence ▁ of ▁ tokens ▁ changed ▁ to ▁ fix ▁ an ▁ error . STRNEWLINE ▁ """ NEW_LINE self . _file_fix_count += 1 NEW_LINE if hasattr ( tokens , ' line _ number ' ) : NEW_LINE INDENT self . _file_changed_lines . add ( tokens . line_number ) NEW_LINE DEDENT else : NEW_LINE INDENT for token in tokens : NEW_LINE INDENT self . _file_changed_lines . add ( token . line_number ) NEW_LINE DEDENT DEDENT DEDENT def HandleError ( self , error ) : NEW_LINE INDENT """ Attempts ▁ to ▁ fix ▁ the ▁ error . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ error : ▁ The ▁ error ▁ object STRNEWLINE ▁ """ NEW_LINE code = error . code NEW_LINE token = error . token NEW_LINE if code == errors . JSDOC_PREFER_QUESTION_TO_PIPE_NULL : NEW_LINE INDENT iterator = token . attached_object . type_start_token NEW_LINE if iterator . type == Type . DOC_START_BRACE or iterator . string . isspace ( ) : NEW_LINE INDENT iterator = iterator . next NEW_LINE DEDENT leading_space = len ( iterator . string ) - len ( iterator . string . lstrip ( ) ) NEW_LINE iterator . string = ' % s ? % s ' % ( ' ▁ ' * leading_space , iterator . string . lstrip ( ) ) NEW_LINE # ▁ Cover ▁ the ▁ no ▁ outer ▁ brace ▁ case ▁ where ▁ the ▁ end ▁ token ▁ is ▁ part ▁ of ▁ the ▁ type . ENDCOM while iterator and iterator != token . attached_object . type_end_token . next : NEW_LINE INDENT iterator . string = iterator . string . replace ( ' null | ' , ' ' ) . replace ( ' | null ' , ' ' ) NEW_LINE iterator = iterator . next NEW_LINE # ▁ Create ▁ a ▁ new ▁ flag ▁ object ▁ with ▁ updated ▁ type ▁ info . ENDCOM DEDENT token . attached_object = javascriptstatetracker . JsDocFlag ( token ) NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT elif code == errors . JSDOC_MISSING_OPTIONAL_TYPE : NEW_LINE INDENT iterator = token . attached_object . type_end_token NEW_LINE if iterator . type == Type . DOC_END_BRACE or iterator . string . isspace ( ) : NEW_LINE INDENT iterator = iterator . previous NEW_LINE DEDENT ending_space = len ( iterator . string ) - len ( iterator . string . rstrip ( ) ) NEW_LINE iterator . string = ' % s = % s ' % ( iterator . string . rstrip ( ) , ' ▁ ' * ending_space ) NEW_LINE # ▁ Create ▁ a ▁ new ▁ flag ▁ object ▁ with ▁ updated ▁ type ▁ info . ENDCOM token . attached_object = javascriptstatetracker . JsDocFlag ( token ) NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT elif code in ( errors . MISSING_SEMICOLON_AFTER_FUNCTION , errors . MISSING_SEMICOLON ) : NEW_LINE INDENT semicolon_token = Token ( ' ; ' , Type . SEMICOLON , token . line , token . line_number ) NEW_LINE tokenutil . InsertTokenAfter ( semicolon_token , token ) NEW_LINE token . metadata . is_implied_semicolon = False NEW_LINE semicolon_token . metadata . is_implied_semicolon = False NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT elif code in ( errors . ILLEGAL_SEMICOLON_AFTER_FUNCTION , errors . REDUNDANT_SEMICOLON , errors . COMMA_AT_END_OF_LITERAL ) : NEW_LINE INDENT tokenutil . DeleteToken ( token ) NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT elif code == errors . INVALID_JSDOC_TAG : NEW_LINE INDENT if token . string == ' @ returns ' : NEW_LINE INDENT token . string = ' @ return ' NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT DEDENT elif code == errors . FILE_MISSING_NEWLINE : NEW_LINE # ▁ This ▁ error ▁ is ▁ fixed ▁ implicitly ▁ by ▁ the ▁ way ▁ we ▁ restore ▁ the ▁ file ENDCOM INDENT self . _AddFix ( token ) NEW_LINE DEDENT elif code == errors . MISSING_SPACE : NEW_LINE INDENT if error . position : NEW_LINE INDENT if error . position . IsAtBeginning ( ) : NEW_LINE INDENT tokenutil . InsertSpaceTokenAfter ( token . previous ) NEW_LINE DEDENT elif error . position . IsAtEnd ( token . string ) : NEW_LINE INDENT tokenutil . InsertSpaceTokenAfter ( token ) NEW_LINE DEDENT else : NEW_LINE INDENT token . string = error . position . Set ( token . string , ' ▁ ' ) NEW_LINE DEDENT self . _AddFix ( token ) NEW_LINE DEDENT DEDENT elif code == errors . EXTRA_SPACE : NEW_LINE INDENT if error . position : NEW_LINE INDENT token . string = error . position . Set ( token . string , ' ' ) NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT DEDENT elif code == errors . JSDOC_TAG_DESCRIPTION_ENDS_WITH_INVALID_CHARACTER : NEW_LINE INDENT token . string = error . position . Set ( token . string , ' . ' ) NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT elif code == errors . MISSING_LINE : NEW_LINE INDENT if error . position . IsAtBeginning ( ) : NEW_LINE INDENT tokenutil . InsertBlankLineAfter ( token . previous ) NEW_LINE DEDENT else : NEW_LINE INDENT tokenutil . InsertBlankLineAfter ( token ) NEW_LINE DEDENT self . _AddFix ( token ) NEW_LINE DEDENT elif code == errors . EXTRA_LINE : NEW_LINE INDENT tokenutil . DeleteToken ( token ) NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT elif code == errors . WRONG_BLANK_LINE_COUNT : NEW_LINE INDENT if not token . previous : NEW_LINE # ▁ TODO ( user ) : ▁ Add ▁ an ▁ insertBefore ▁ method ▁ to ▁ tokenutil . ENDCOM INDENT return NEW_LINE DEDENT num_lines = error . fix_data NEW_LINE should_delete = False NEW_LINE if num_lines < 0 : NEW_LINE INDENT num_lines *= - 1 NEW_LINE should_delete = True NEW_LINE DEDENT for i in xrange ( 1 , num_lines + 1 ) : NEW_LINE INDENT if should_delete : NEW_LINE # ▁ TODO ( user ) : ▁ DeleteToken ▁ should ▁ update ▁ line ▁ numbers . ENDCOM INDENT tokenutil . DeleteToken ( token . previous ) NEW_LINE DEDENT else : NEW_LINE INDENT tokenutil . InsertBlankLineAfter ( token . previous ) NEW_LINE DEDENT self . _AddFix ( token ) NEW_LINE DEDENT DEDENT elif code == errors . UNNECESSARY_DOUBLE_QUOTED_STRING : NEW_LINE INDENT end_quote = tokenutil . Search ( token , Type . DOUBLE_QUOTE_STRING_END ) NEW_LINE if end_quote : NEW_LINE INDENT single_quote_start = Token ( " ' " , Type . SINGLE_QUOTE_STRING_START , token . line , token . line_number ) NEW_LINE single_quote_end = Token ( " ' " , Type . SINGLE_QUOTE_STRING_START , end_quote . line , token . line_number ) NEW_LINE tokenutil . InsertTokenAfter ( single_quote_start , token ) NEW_LINE tokenutil . InsertTokenAfter ( single_quote_end , end_quote ) NEW_LINE tokenutil . DeleteToken ( token ) NEW_LINE tokenutil . DeleteToken ( end_quote ) NEW_LINE self . _AddFix ( [ token , end_quote ] ) NEW_LINE DEDENT DEDENT elif code == errors . MISSING_BRACES_AROUND_TYPE : NEW_LINE INDENT fixed_tokens = [ ] NEW_LINE start_token = token . attached_object . type_start_token NEW_LINE if start_token . type != Type . DOC_START_BRACE : NEW_LINE INDENT leading_space = ( len ( start_token . string ) - len ( start_token . string . lstrip ( ) ) ) NEW_LINE if leading_space : NEW_LINE INDENT start_token = tokenutil . SplitToken ( start_token , leading_space ) NEW_LINE # ▁ Fix ▁ case ▁ where ▁ start ▁ and ▁ end ▁ token ▁ were ▁ the ▁ same . ENDCOM if token . attached_object . type_end_token == start_token . previous : NEW_LINE INDENT token . attached_object . type_end_token = start_token NEW_LINE DEDENT DEDENT new_token = Token ( ' { ' , Type . DOC_START_BRACE , start_token . line , start_token . line_number ) NEW_LINE tokenutil . InsertTokenAfter ( new_token , start_token . previous ) NEW_LINE token . attached_object . type_start_token = new_token NEW_LINE fixed_tokens . append ( new_token ) NEW_LINE DEDENT end_token = token . attached_object . type_end_token NEW_LINE if end_token . type != Type . DOC_END_BRACE : NEW_LINE # ▁ If ▁ the ▁ start ▁ token ▁ was ▁ a ▁ brace , ▁ the ▁ end ▁ token ▁ will ▁ be ▁ a ENDCOM # ▁ FLAG _ ENDING _ TYPE ▁ token , ▁ if ▁ there ▁ wasn ' t ▁ a ▁ starting ▁ brace ▁ then ENDCOM # ▁ the ▁ end ▁ token ▁ is ▁ the ▁ last ▁ token ▁ of ▁ the ▁ actual ▁ type . ENDCOM INDENT last_type = end_token NEW_LINE if not fixed_tokens : NEW_LINE INDENT last_type = end_token . previous NEW_LINE DEDENT while last_type . string . isspace ( ) : NEW_LINE INDENT last_type = last_type . previous NEW_LINE # ▁ If ▁ there ▁ was ▁ no ▁ starting ▁ brace ▁ then ▁ a ▁ lone ▁ end ▁ brace ▁ wouldn ' t ▁ have ENDCOM # ▁ been ▁ type ▁ end ▁ token . ▁ Now ▁ that ▁ we ' ve ▁ added ▁ any ▁ missing ▁ start ▁ brace , ENDCOM # ▁ see ▁ if ▁ the ▁ last ▁ effective ▁ type ▁ token ▁ was ▁ an ▁ end ▁ brace . ENDCOM DEDENT if last_type . type != Type . DOC_END_BRACE : NEW_LINE INDENT trailing_space = ( len ( last_type . string ) - len ( last_type . string . rstrip ( ) ) ) NEW_LINE if trailing_space : NEW_LINE INDENT tokenutil . SplitToken ( last_type , len ( last_type . string ) - trailing_space ) NEW_LINE DEDENT new_token = Token ( ' } ' , Type . DOC_END_BRACE , last_type . line , last_type . line_number ) NEW_LINE tokenutil . InsertTokenAfter ( new_token , last_type ) NEW_LINE token . attached_object . type_end_token = new_token NEW_LINE fixed_tokens . append ( new_token ) NEW_LINE DEDENT DEDENT self . _AddFix ( fixed_tokens ) NEW_LINE DEDENT elif code == errors . GOOG_REQUIRES_NOT_ALPHABETIZED : NEW_LINE INDENT require_start_token = error . fix_data NEW_LINE sorter = requireprovidesorter . RequireProvideSorter ( ) NEW_LINE sorter . FixRequires ( require_start_token ) NEW_LINE self . _AddFix ( require_start_token ) NEW_LINE DEDENT elif code == errors . GOOG_PROVIDES_NOT_ALPHABETIZED : NEW_LINE INDENT provide_start_token = error . fix_data NEW_LINE sorter = requireprovidesorter . RequireProvideSorter ( ) NEW_LINE sorter . FixProvides ( provide_start_token ) NEW_LINE self . _AddFix ( provide_start_token ) NEW_LINE DEDENT elif code == errors . UNNECESSARY_BRACES_AROUND_INHERIT_DOC : NEW_LINE INDENT if token . previous . string == ' { ' and token . next . string == ' } ' : NEW_LINE INDENT tokenutil . DeleteToken ( token . previous ) NEW_LINE tokenutil . DeleteToken ( token . next ) NEW_LINE self . _AddFix ( [ token ] ) NEW_LINE DEDENT DEDENT elif code == errors . INVALID_AUTHOR_TAG_DESCRIPTION : NEW_LINE INDENT match = INVERTED_AUTHOR_SPEC . match ( token . string ) NEW_LINE if match : NEW_LINE INDENT token . string = ' % s % s % s ( % s ) % s ' % ( match . group ( ' leading _ whitespace ' ) , match . group ( ' email ' ) , match . group ( ' whitespace _ after _ name ' ) , match . group ( ' name ' ) , match . group ( ' trailing _ characters ' ) ) NEW_LINE self . _AddFix ( token ) NEW_LINE DEDENT DEDENT elif ( code == errors . WRONG_INDENTATION and not FLAGS . disable_indentation_fixing ) : NEW_LINE INDENT token = tokenutil . GetFirstTokenInSameLine ( token ) NEW_LINE actual = error . position . start NEW_LINE expected = error . position . length NEW_LINE if token . type in ( Type . WHITESPACE , Type . PARAMETERS ) and actual != 0 : NEW_LINE INDENT token . string = token . string . lstrip ( ) + ( ' ▁ ' * expected ) NEW_LINE self . _AddFix ( [ token ] ) NEW_LINE DEDENT else : NEW_LINE # ▁ We ▁ need ▁ to ▁ add ▁ indentation . ENDCOM INDENT new_token = Token ( ' ▁ ' * expected , Type . WHITESPACE , token . line , token . line_number ) NEW_LINE # ▁ Note ▁ that ▁ we ' ll ▁ never ▁ need ▁ to ▁ add ▁ indentation ▁ at ▁ the ▁ first ▁ line , ENDCOM # ▁ since ▁ it ▁ will ▁ always ▁ not ▁ be ▁ indented . ▁ Therefore ▁ it ' s ▁ safe ▁ to ▁ assume ENDCOM # ▁ token . previous ▁ exists . ENDCOM tokenutil . InsertTokenAfter ( new_token , token . previous ) NEW_LINE self . _AddFix ( [ token ] ) NEW_LINE DEDENT DEDENT elif code in [ errors . MALFORMED_END_OF_SCOPE_COMMENT , errors . MISSING_END_OF_SCOPE_COMMENT ] : NEW_LINE # ▁ Only ▁ fix ▁ cases ▁ where ▁ } ) ; ▁ is ▁ found ▁ with ▁ no ▁ trailing ▁ content ▁ on ▁ the ▁ line ENDCOM # ▁ other ▁ than ▁ a ▁ comment . ▁ Value ▁ of ▁ ' token ' ▁ is ▁ set ▁ to ▁ } ▁ for ▁ this ▁ error . ENDCOM INDENT if ( token . type == Type . END_BLOCK and token . next . type == Type . END_PAREN and token . next . next . type == Type . SEMICOLON ) : NEW_LINE INDENT current_token = token . next . next . next NEW_LINE removed_tokens = [ ] NEW_LINE while current_token and current_token . line_number == token . line_number : NEW_LINE INDENT if current_token . IsAnyType ( Type . WHITESPACE , Type . START_SINGLE_LINE_COMMENT , Type . COMMENT ) : NEW_LINE INDENT removed_tokens . append ( current_token ) NEW_LINE current_token = current_token . next NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT if removed_tokens : NEW_LINE INDENT tokenutil . DeleteTokens ( removed_tokens [ 0 ] , len ( removed_tokens ) ) NEW_LINE DEDENT whitespace_token = Token ( ' ▁ ▁ ' , Type . WHITESPACE , token . line , token . line_number ) NEW_LINE start_comment_token = Token ( ' / / ' , Type . START_SINGLE_LINE_COMMENT , token . line , token . line_number ) NEW_LINE comment_token = Token ( ' ▁ goog . scope ' , Type . COMMENT , token . line , token . line_number ) NEW_LINE insertion_tokens = [ whitespace_token , start_comment_token , comment_token ] NEW_LINE tokenutil . InsertTokensAfter ( insertion_tokens , token . next . next ) NEW_LINE self . _AddFix ( removed_tokens + insertion_tokens ) NEW_LINE DEDENT DEDENT elif code in [ errors . EXTRA_GOOG_PROVIDE , errors . EXTRA_GOOG_REQUIRE ] : NEW_LINE INDENT tokens_in_line = tokenutil . GetAllTokensInSameLine ( token ) NEW_LINE tokenutil . DeleteTokens ( tokens_in_line [ 0 ] , len ( tokens_in_line ) ) NEW_LINE self . _AddFix ( tokens_in_line ) NEW_LINE DEDENT elif code in [ errors . MISSING_GOOG_PROVIDE , errors . MISSING_GOOG_REQUIRE ] : NEW_LINE INDENT is_provide = code == errors . MISSING_GOOG_PROVIDE NEW_LINE is_require = code == errors . MISSING_GOOG_REQUIRE NEW_LINE missing_namespaces = error . fix_data [ 0 ] NEW_LINE need_blank_line = error . fix_data [ 1 ] NEW_LINE if need_blank_line is None : NEW_LINE # ▁ TODO ( user ) : ▁ This ▁ happens ▁ when ▁ there ▁ are ▁ no ▁ existing ENDCOM # ▁ goog . provide ▁ or ▁ goog . require ▁ statements ▁ to ▁ position ▁ new ▁ statements ENDCOM # ▁ relative ▁ to . ▁ Consider ▁ handling ▁ this ▁ case ▁ with ▁ a ▁ heuristic . ENDCOM INDENT return NEW_LINE DEDENT insert_location = token . previous NEW_LINE # ▁ If ▁ inserting ▁ a ▁ missing ▁ require ▁ with ▁ no ▁ existing ▁ requires , ▁ insert ▁ a ENDCOM # ▁ blank ▁ line ▁ first . ENDCOM if need_blank_line and is_require : NEW_LINE INDENT tokenutil . InsertBlankLineAfter ( insert_location ) NEW_LINE insert_location = insert_location . next NEW_LINE DEDENT for missing_namespace in missing_namespaces : NEW_LINE INDENT new_tokens = self . _GetNewRequireOrProvideTokens ( is_provide , missing_namespace , insert_location . line_number + 1 ) NEW_LINE tokenutil . InsertLineAfter ( insert_location , new_tokens ) NEW_LINE insert_location = new_tokens [ - 1 ] NEW_LINE self . _AddFix ( new_tokens ) NEW_LINE # ▁ If ▁ inserting ▁ a ▁ missing ▁ provide ▁ with ▁ no ▁ existing ▁ provides , ▁ insert ▁ a ENDCOM # ▁ blank ▁ line ▁ after . ENDCOM DEDENT if need_blank_line and is_provide : NEW_LINE INDENT tokenutil . InsertBlankLineAfter ( insert_location ) NEW_LINE DEDENT DEDENT DEDENT def _GetNewRequireOrProvideTokens ( self , is_provide , namespace , line_number ) : NEW_LINE INDENT """ Returns ▁ a ▁ list ▁ of ▁ tokens ▁ to ▁ create ▁ a ▁ goog . require / provide ▁ statement . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ is _ provide : ▁ True ▁ if ▁ getting ▁ tokens ▁ for ▁ a ▁ provide , ▁ False ▁ for ▁ require . STRNEWLINE ▁ namespace : ▁ The ▁ required ▁ or ▁ provided ▁ namespaces ▁ to ▁ get ▁ tokens ▁ for . STRNEWLINE ▁ line _ number : ▁ The ▁ line ▁ number ▁ the ▁ new ▁ require ▁ or ▁ provide ▁ statement ▁ will ▁ be STRNEWLINE ▁ on . STRNEWLINE STRNEWLINE ▁ Returns : STRNEWLINE ▁ Tokens ▁ to ▁ create ▁ a ▁ new ▁ goog . require ▁ or ▁ goog . provide ▁ statement . STRNEWLINE ▁ """ NEW_LINE string = ' goog . require ' NEW_LINE if is_provide : NEW_LINE INDENT string = ' goog . provide ' NEW_LINE DEDENT line_text = string + ' ( \ ' ' + namespace + ' \ ' ) ; \n ' NEW_LINE return [ Token ( string , Type . IDENTIFIER , line_text , line_number ) , Token ( ' ( ' , Type . START_PAREN , line_text , line_number ) , Token ( ' \ ' ' , Type . SINGLE_QUOTE_STRING_START , line_text , line_number ) , Token ( namespace , Type . STRING_TEXT , line_text , line_number ) , Token ( ' \ ' ' , Type . SINGLE_QUOTE_STRING_END , line_text , line_number ) , Token ( ' ) ' , Type . END_PAREN , line_text , line_number ) , Token ( ' ; ' , Type . SEMICOLON , line_text , line_number ) ] NEW_LINE DEDENT def FinishFile ( self ) : NEW_LINE INDENT """ Called ▁ when ▁ the ▁ current ▁ file ▁ has ▁ finished ▁ style ▁ checking . STRNEWLINE STRNEWLINE ▁ Used ▁ to ▁ go ▁ back ▁ and ▁ fix ▁ any ▁ errors ▁ in ▁ the ▁ file . STRNEWLINE ▁ """ NEW_LINE if self . _file_fix_count : NEW_LINE INDENT f = self . _external_file NEW_LINE if not f : NEW_LINE INDENT print ' Fixed ▁ % d ▁ errors ▁ in ▁ % s ' % ( self . _file_fix_count , self . _file_name ) NEW_LINE f = open ( self . _file_name , ' w ' ) NEW_LINE DEDENT token = self . _file_token NEW_LINE char_count = 0 NEW_LINE while token : NEW_LINE INDENT f . write ( token . string ) NEW_LINE char_count += len ( token . string ) NEW_LINE if token . IsLastInLine ( ) : NEW_LINE INDENT f . write ( ' \n ' ) NEW_LINE if char_count > 80 and token . line_number in self . _file_changed_lines : NEW_LINE INDENT print ' WARNING : ▁ Line ▁ % d ▁ of ▁ % s ▁ is ▁ now ▁ longer ▁ than ▁ 80 ▁ characters . ' % ( token . line_number , self . _file_name ) NEW_LINE DEDENT char_count = 0 NEW_LINE DEDENT token = token . next NEW_LINE DEDENT if not self . _external_file : NEW_LINE # ▁ Close ▁ the ▁ file ▁ if ▁ we ▁ created ▁ it ENDCOM INDENT f . close ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="rjschwei/azure-sdk-for-python/tree/master/azure-mgmt-logic/azure/mgmt/logic/models/generate_upgraded_definition_parameters.py"> # ▁ coding = utf - 8 ENDCOM # ▁ Copyright ▁ ( c ) ▁ Microsoft ▁ Corporation . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Licensed ▁ under ▁ the ▁ MIT ▁ License . ▁ See ▁ License . txt ▁ in ▁ the ▁ project ▁ root ▁ for ENDCOM # ▁ license ▁ information . ENDCOM # ▁ Code ▁ generated ▁ by ▁ Microsoft ▁ ( R ) ▁ AutoRest ▁ Code ▁ Generator . ENDCOM # ▁ Changes ▁ may ▁ cause ▁ incorrect ▁ behavior ▁ and ▁ will ▁ be ▁ lost ▁ if ▁ the ▁ code ▁ is ENDCOM # ▁ regenerated . ENDCOM from msrest . serialization import Model NEW_LINE class GenerateUpgradedDefinitionParameters ( Model ) : NEW_LINE INDENT """ GenerateUpgradedDefinitionParameters . STRNEWLINE STRNEWLINE ▁ : param ▁ target _ schema _ version : ▁ The ▁ target ▁ schema ▁ version . STRNEWLINE ▁ : type ▁ target _ schema _ version : ▁ str STRNEWLINE ▁ """ NEW_LINE _attribute_map = { ' target _ schema _ version ' : { ' key ' : ' targetSchemaVersion ' , ' type ' : ' str ' } , } NEW_LINE def __init__ ( self , target_schema_version = None ) : NEW_LINE INDENT self . target_schema_version = target_schema_version NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="BhallaLab/moose/tree/master/moose-examples/passive/passive_soma.py"> """ ▁ passive _ soma . py : ▁ STRNEWLINE STRNEWLINE In ▁ this ▁ script , ▁ we ▁ simulate ▁ a ▁ single ▁ compartment ▁ soma ▁ in ▁ MOOSE . STRNEWLINE STRNEWLINE This ▁ soma ▁ does ▁ not ▁ have ▁ any ▁ ion - channels , ▁ only ▁ passive ▁ properties . ▁ It ▁ should STRNEWLINE behave ▁ like ▁ a ▁ RC ▁ circuit . ▁ A ▁ current ▁ is ▁ injected ▁ into ▁ soma . STRNEWLINE STRNEWLINE """ NEW_LINE __author__ = " Dilawar ▁ Singh " NEW_LINE __copyright__ = " Copyright ▁ 2015 , ▁ Dilawar ▁ Singh ▁ and ▁ NCBS ▁ Bangalore " NEW_LINE __credits__ = [ " NCBS ▁ Bangalore " ] NEW_LINE __license__ = " GNU ▁ GPL " NEW_LINE __version__ = "1.0.0" NEW_LINE __maintainer__ = " Dilawar ▁ Singh " NEW_LINE __email__ = " dilawars @ ncbs . res . in " NEW_LINE __status__ = " Development " NEW_LINE import moose NEW_LINE import pylab NEW_LINE model = None NEW_LINE soma = None NEW_LINE vmtab = None NEW_LINE def buildModel ( ) : NEW_LINE INDENT global model NEW_LINE global soma NEW_LINE model = moose . Neutral ( ' / model ' ) NEW_LINE soma = moose . Compartment ( ' / model / soma ' ) NEW_LINE soma . Em = - 60e-3 NEW_LINE soma . Rm = 1e10 NEW_LINE soma . Cm = 1e-10 NEW_LINE return model NEW_LINE DEDENT def stimulus ( ) : NEW_LINE INDENT global soma NEW_LINE global vmtab NEW_LINE pulse = moose . PulseGen ( ' / model / pulse ' ) NEW_LINE pulse . delay [ 0 ] = 50e-3 NEW_LINE pulse . width [ 0 ] = 100e-3 NEW_LINE pulse . level [ 0 ] = 1e-9 NEW_LINE pulse . delay [ 1 ] = 1e9 NEW_LINE vmtab = moose . Table ( ' / soma _ Vm ' ) NEW_LINE moose . connect ( pulse , ' output ' , soma , ' injectMsg ' ) NEW_LINE moose . connect ( vmtab , ' requestOut ' , soma , ' getVm ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT global vmtab NEW_LINE buildModel ( ) NEW_LINE stimulus ( ) NEW_LINE moose . reinit ( ) NEW_LINE t = 500e-2 NEW_LINE moose . start ( t ) NEW_LINE time_vector = pylab . linspace ( 0 , t , len ( vmtab . vector ) ) NEW_LINE pylab . plot ( time_vector , vmtab . vector ) NEW_LINE pylab . show ( ) NEW_LINE # ▁ pylab . savefig ( ' soma _ passive . png ' ) ENDCOM DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="Nirlendu/Dummy-Search-Engine/tree/master/tornado-3.2/build/lib.win32-2.7/tornado/wsgi.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ 2009 ▁ Facebook ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ENDCOM # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ENDCOM # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ENDCOM # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ENDCOM # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM # ▁ under ▁ the ▁ License . ENDCOM """ WSGI ▁ support ▁ for ▁ the ▁ Tornado ▁ web ▁ framework . STRNEWLINE STRNEWLINE WSGI ▁ is ▁ the ▁ Python ▁ standard ▁ for ▁ web ▁ servers , ▁ and ▁ allows ▁ for ▁ interoperability STRNEWLINE between ▁ Tornado ▁ and ▁ other ▁ Python ▁ web ▁ frameworks ▁ and ▁ servers . ▁ This ▁ module STRNEWLINE provides ▁ WSGI ▁ support ▁ in ▁ two ▁ ways : STRNEWLINE STRNEWLINE * ▁ ` WSGIApplication ` ▁ is ▁ a ▁ version ▁ of ▁ ` tornado . web . Application ` ▁ that ▁ can ▁ run STRNEWLINE ▁ inside ▁ a ▁ WSGI ▁ server . ▁ This ▁ is ▁ useful ▁ for ▁ running ▁ a ▁ Tornado ▁ app ▁ on ▁ another STRNEWLINE ▁ HTTP ▁ server , ▁ such ▁ as ▁ Google ▁ App ▁ Engine . ▁ See ▁ the ▁ ` WSGIApplication ` ▁ class STRNEWLINE ▁ documentation ▁ for ▁ limitations ▁ that ▁ apply . STRNEWLINE * ▁ ` WSGIContainer ` ▁ lets ▁ you ▁ run ▁ other ▁ WSGI ▁ applications ▁ and ▁ frameworks ▁ on ▁ the STRNEWLINE ▁ Tornado ▁ HTTP ▁ server . ▁ For ▁ example , ▁ with ▁ this ▁ class ▁ you ▁ can ▁ mix ▁ Django STRNEWLINE ▁ and ▁ Tornado ▁ handlers ▁ in ▁ a ▁ single ▁ server . STRNEWLINE """ NEW_LINE from __future__ import absolute_import , division , print_function , with_statement NEW_LINE import sys NEW_LINE import time NEW_LINE import copy NEW_LINE import tornado NEW_LINE from tornado import escape NEW_LINE from tornado import httputil NEW_LINE from tornado . log import access_log NEW_LINE from tornado import web NEW_LINE from tornado . escape import native_str , parse_qs_bytes NEW_LINE from tornado . util import bytes_type , unicode_type NEW_LINE try : NEW_LINE INDENT from io import BytesIO # ▁ python ▁ 3 ENDCOM NEW_LINE DEDENT except ImportError : NEW_LINE INDENT from cStringIO import StringIO as BytesIO # ▁ python ▁ 2 ENDCOM NEW_LINE DEDENT try : NEW_LINE INDENT import Cookie # ▁ py2 ENDCOM NEW_LINE DEDENT except ImportError : NEW_LINE INDENT import http . cookies as Cookie # ▁ py3 ENDCOM NEW_LINE DEDENT try : NEW_LINE INDENT import urllib . parse as urllib_parse # ▁ py3 ENDCOM NEW_LINE DEDENT except ImportError : NEW_LINE INDENT import urllib as urllib_parse NEW_LINE # ▁ PEP ▁ 3333 ▁ specifies ▁ that ▁ WSGI ▁ on ▁ python ▁ 3 ▁ generally ▁ deals ▁ with ▁ byte ▁ strings ENDCOM # ▁ that ▁ are ▁ smuggled ▁ inside ▁ objects ▁ of ▁ type ▁ unicode ▁ ( via ▁ the ▁ latin1 ▁ encoding ) . ENDCOM # ▁ These ▁ functions ▁ are ▁ like ▁ those ▁ in ▁ the ▁ tornado . escape ▁ module , ▁ but ▁ defined ENDCOM # ▁ here ▁ to ▁ minimize ▁ the ▁ temptation ▁ to ▁ use ▁ them ▁ in ▁ non - wsgi ▁ contexts . ENDCOM DEDENT if str is unicode_type : NEW_LINE INDENT def to_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , bytes_type ) NEW_LINE return s . decode ( ' latin1' ) NEW_LINE DEDENT def from_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , str ) NEW_LINE return s . encode ( ' latin1' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT def to_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , bytes_type ) NEW_LINE return s NEW_LINE DEDENT def from_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , str ) NEW_LINE return s NEW_LINE DEDENT DEDENT class WSGIApplication ( web . Application ) : NEW_LINE INDENT """ A ▁ WSGI ▁ equivalent ▁ of ▁ ` tornado . web . Application ` . STRNEWLINE STRNEWLINE ▁ ` WSGIApplication ` ▁ is ▁ very ▁ similar ▁ to ▁ ` tornado . web . Application ` , STRNEWLINE ▁ except ▁ no ▁ asynchronous ▁ methods ▁ are ▁ supported ▁ ( since ▁ WSGI ▁ does ▁ not STRNEWLINE ▁ support ▁ non - blocking ▁ requests ▁ properly ) . ▁ If ▁ you ▁ call STRNEWLINE ▁ ` ` self . flush ( ) ` ` ▁ or ▁ other ▁ asynchronous ▁ methods ▁ in ▁ your ▁ request STRNEWLINE ▁ handlers ▁ running ▁ in ▁ a ▁ ` WSGIApplication ` , ▁ we ▁ throw ▁ an ▁ exception . STRNEWLINE STRNEWLINE ▁ Example ▁ usage : : STRNEWLINE STRNEWLINE ▁ import ▁ tornado . web STRNEWLINE ▁ import ▁ tornado . wsgi STRNEWLINE ▁ import ▁ wsgiref . simple _ server STRNEWLINE STRNEWLINE ▁ class ▁ MainHandler ( tornado . web . RequestHandler ) : STRNEWLINE ▁ def ▁ get ( self ) : STRNEWLINE ▁ self . write ( " Hello , ▁ world " ) STRNEWLINE STRNEWLINE ▁ if ▁ _ _ name _ _ ▁ = = ▁ " _ _ main _ _ " : STRNEWLINE ▁ application ▁ = ▁ tornado . wsgi . WSGIApplication ( [ STRNEWLINE ▁ ( r " / " , ▁ MainHandler ) , STRNEWLINE ▁ ] ) STRNEWLINE ▁ server ▁ = ▁ wsgiref . simple _ server . make _ server ( ' ' , ▁ 8888 , ▁ application ) STRNEWLINE ▁ server . serve _ forever ( ) STRNEWLINE STRNEWLINE ▁ See ▁ the ▁ ` appengine ▁ demo STRNEWLINE ▁ < https : / / github . com / facebook / tornado / tree / master / demos / appengine > ` _ STRNEWLINE ▁ for ▁ an ▁ example ▁ of ▁ using ▁ this ▁ module ▁ to ▁ run ▁ a ▁ Tornado ▁ app ▁ on ▁ Google STRNEWLINE ▁ App ▁ Engine . STRNEWLINE STRNEWLINE ▁ WSGI ▁ applications ▁ use ▁ the ▁ same ▁ ` . RequestHandler ` ▁ class , ▁ but ▁ not STRNEWLINE ▁ ` ` @ asynchronous ` ` ▁ methods ▁ or ▁ ` ` flush ( ) ` ` . ▁ This ▁ means ▁ that ▁ it ▁ is STRNEWLINE ▁ not ▁ possible ▁ to ▁ use ▁ ` . AsyncHTTPClient ` , ▁ or ▁ the ▁ ` tornado . auth ` ▁ or STRNEWLINE ▁ ` tornado . websocket ` ▁ modules . STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , handlers = None , default_host = " " , ** settings ) : NEW_LINE INDENT web . Application . __init__ ( self , handlers , default_host , transforms = [ ] , wsgi = True , ** settings ) NEW_LINE DEDENT def __call__ ( self , environ , start_response ) : NEW_LINE INDENT handler = web . Application . __call__ ( self , HTTPRequest ( environ ) ) NEW_LINE assert handler . _finished NEW_LINE reason = handler . _reason NEW_LINE status = str ( handler . _status_code ) + " ▁ " + reason NEW_LINE headers = list ( handler . _headers . get_all ( ) ) NEW_LINE if hasattr ( handler , " _ new _ cookie " ) : NEW_LINE INDENT for cookie in handler . _new_cookie . values ( ) : NEW_LINE INDENT headers . append ( ( " Set - Cookie " , cookie . OutputString ( None ) ) ) NEW_LINE DEDENT DEDENT start_response ( status , [ ( native_str ( k ) , native_str ( v ) ) for ( k , v ) in headers ] ) NEW_LINE return handler . _write_buffer NEW_LINE DEDENT DEDENT class HTTPRequest ( object ) : NEW_LINE INDENT """ Mimics ▁ ` tornado . httpserver . HTTPRequest ` ▁ for ▁ WSGI ▁ applications . """ NEW_LINE def __init__ ( self , environ ) : NEW_LINE INDENT """ Parses ▁ the ▁ given ▁ WSGI ▁ environment ▁ to ▁ construct ▁ the ▁ request . """ NEW_LINE self . method = environ [ " REQUEST _ METHOD " ] NEW_LINE self . path = urllib_parse . quote ( from_wsgi_str ( environ . get ( " SCRIPT _ NAME " , " " ) ) ) NEW_LINE self . path += urllib_parse . quote ( from_wsgi_str ( environ . get ( " PATH _ INFO " , " " ) ) ) NEW_LINE self . uri = self . path NEW_LINE self . arguments = { } NEW_LINE self . query_arguments = { } NEW_LINE self . body_arguments = { } NEW_LINE self . query = environ . get ( " QUERY _ STRING " , " " ) NEW_LINE if self . query : NEW_LINE INDENT self . uri += " ? " + self . query NEW_LINE self . arguments = parse_qs_bytes ( native_str ( self . query ) , keep_blank_values = True ) NEW_LINE self . query_arguments = copy . deepcopy ( self . arguments ) NEW_LINE DEDENT self . version = " HTTP / 1.1" NEW_LINE self . headers = httputil . HTTPHeaders ( ) NEW_LINE if environ . get ( " CONTENT _ TYPE " ) : NEW_LINE INDENT self . headers [ " Content - Type " ] = environ [ " CONTENT _ TYPE " ] NEW_LINE DEDENT if environ . get ( " CONTENT _ LENGTH " ) : NEW_LINE INDENT self . headers [ " Content - Length " ] = environ [ " CONTENT _ LENGTH " ] NEW_LINE DEDENT for key in environ : NEW_LINE INDENT if key . startswith ( " HTTP _ " ) : NEW_LINE INDENT self . headers [ key [ 5 : ] . replace ( " _ " , " - " ) ] = environ [ key ] NEW_LINE DEDENT DEDENT if self . headers . get ( " Content - Length " ) : NEW_LINE INDENT self . body = environ [ " wsgi . input " ] . read ( int ( self . headers [ " Content - Length " ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . body = " " NEW_LINE DEDENT self . protocol = environ [ " wsgi . url _ scheme " ] NEW_LINE self . remote_ip = environ . get ( " REMOTE _ ADDR " , " " ) NEW_LINE if environ . get ( " HTTP _ HOST " ) : NEW_LINE INDENT self . host = environ [ " HTTP _ HOST " ] NEW_LINE DEDENT else : NEW_LINE INDENT self . host = environ [ " SERVER _ NAME " ] NEW_LINE # ▁ Parse ▁ request ▁ body ENDCOM DEDENT self . files = { } NEW_LINE httputil . parse_body_arguments ( self . headers . get ( " Content - Type " , " " ) , self . body , self . body_arguments , self . files ) NEW_LINE for k , v in self . body_arguments . items ( ) : NEW_LINE INDENT self . arguments . setdefault ( k , [ ] ) . extend ( v ) NEW_LINE DEDENT self . _start_time = time . time ( ) NEW_LINE self . _finish_time = None NEW_LINE DEDENT def supports_http_1_1 ( self ) : NEW_LINE INDENT """ Returns ▁ True ▁ if ▁ this ▁ request ▁ supports ▁ HTTP / 1.1 ▁ semantics """ NEW_LINE return self . version == " HTTP / 1.1" NEW_LINE DEDENT @ property NEW_LINE def cookies ( self ) : NEW_LINE INDENT """ A ▁ dictionary ▁ of ▁ Cookie . Morsel ▁ objects . """ NEW_LINE if not hasattr ( self , " _ cookies " ) : NEW_LINE INDENT self . _cookies = Cookie . SimpleCookie ( ) NEW_LINE if " Cookie " in self . headers : NEW_LINE INDENT try : NEW_LINE INDENT self . _cookies . load ( native_str ( self . headers [ " Cookie " ] ) ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT self . _cookies = None NEW_LINE DEDENT DEDENT DEDENT return self . _cookies NEW_LINE DEDENT def full_url ( self ) : NEW_LINE INDENT """ Reconstructs ▁ the ▁ full ▁ URL ▁ for ▁ this ▁ request . """ NEW_LINE return self . protocol + " : / / " + self . host + self . uri NEW_LINE DEDENT def request_time ( self ) : NEW_LINE INDENT """ Returns ▁ the ▁ amount ▁ of ▁ time ▁ it ▁ took ▁ for ▁ this ▁ request ▁ to ▁ execute . """ NEW_LINE if self . _finish_time is None : NEW_LINE INDENT return time . time ( ) - self . _start_time NEW_LINE DEDENT else : NEW_LINE INDENT return self . _finish_time - self . _start_time NEW_LINE DEDENT DEDENT DEDENT class WSGIContainer ( object ) : NEW_LINE INDENT r """ Makes ▁ a ▁ WSGI - compatible ▁ function ▁ runnable ▁ on ▁ Tornado ' s ▁ HTTP ▁ server . STRNEWLINE STRNEWLINE ▁ Wrap ▁ a ▁ WSGI ▁ function ▁ in ▁ a ▁ ` WSGIContainer ` ▁ and ▁ pass ▁ it ▁ to ▁ ` . HTTPServer ` ▁ to STRNEWLINE ▁ run ▁ it . ▁ For ▁ example : : STRNEWLINE STRNEWLINE ▁ def ▁ simple _ app ( environ , ▁ start _ response ) : STRNEWLINE ▁ status ▁ = ▁ " 200 ▁ OK " STRNEWLINE ▁ response _ headers ▁ = ▁ [ ( " Content - type " , ▁ " text / plain " ) ] STRNEWLINE ▁ start _ response ( status , ▁ response _ headers ) STRNEWLINE ▁ return ▁ [ " Hello ▁ world ! \n " ] STRNEWLINE STRNEWLINE ▁ container ▁ = ▁ tornado . wsgi . WSGIContainer ( simple _ app ) STRNEWLINE ▁ http _ server ▁ = ▁ tornado . httpserver . HTTPServer ( container ) STRNEWLINE ▁ http _ server . listen ( 8888 ) STRNEWLINE ▁ tornado . ioloop . IOLoop . instance ( ) . start ( ) STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ is ▁ intended ▁ to ▁ let ▁ other ▁ frameworks ▁ ( Django , ▁ web . py , ▁ etc ) STRNEWLINE ▁ run ▁ on ▁ the ▁ Tornado ▁ HTTP ▁ server ▁ and ▁ I / O ▁ loop . STRNEWLINE STRNEWLINE ▁ The ▁ ` tornado . web . FallbackHandler ` ▁ class ▁ is ▁ often ▁ useful ▁ for ▁ mixing STRNEWLINE ▁ Tornado ▁ and ▁ WSGI ▁ apps ▁ in ▁ the ▁ same ▁ server . ▁ See STRNEWLINE ▁ https : / / github . com / bdarnell / django - tornado - demo ▁ for ▁ a ▁ complete ▁ example . STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , wsgi_application ) : NEW_LINE INDENT self . wsgi_application = wsgi_application NEW_LINE DEDENT def __call__ ( self , request ) : NEW_LINE INDENT data = { } NEW_LINE response = [ ] NEW_LINE def start_response ( status , response_headers , exc_info = None ) : NEW_LINE INDENT data [ " status " ] = status NEW_LINE data [ " headers " ] = response_headers NEW_LINE return response . append NEW_LINE DEDENT app_response = self . wsgi_application ( WSGIContainer . environ ( request ) , start_response ) NEW_LINE try : NEW_LINE INDENT response . extend ( app_response ) NEW_LINE body = b " " . join ( response ) NEW_LINE DEDENT finally : NEW_LINE INDENT if hasattr ( app_response , " close " ) : NEW_LINE INDENT app_response . close ( ) NEW_LINE DEDENT DEDENT if not data : NEW_LINE INDENT raise Exception ( " WSGI ▁ app ▁ did ▁ not ▁ call ▁ start _ response " ) NEW_LINE DEDENT status_code = int ( data [ " status " ] . split ( ) [ 0 ] ) NEW_LINE headers = data [ " headers " ] NEW_LINE header_set = set ( k . lower ( ) for ( k , v ) in headers ) NEW_LINE body = escape . utf8 ( body ) NEW_LINE if status_code != 304 : NEW_LINE INDENT if " content - length " not in header_set : NEW_LINE INDENT headers . append ( ( " Content - Length " , str ( len ( body ) ) ) ) NEW_LINE DEDENT if " content - type " not in header_set : NEW_LINE INDENT headers . append ( ( " Content - Type " , " text / html ; ▁ charset = UTF - 8" ) ) NEW_LINE DEDENT DEDENT if " server " not in header_set : NEW_LINE INDENT headers . append ( ( " Server " , " TornadoServer / % s " % tornado . version ) ) NEW_LINE DEDENT parts = [ escape . utf8 ( " HTTP / 1.1 ▁ " + data [ " status " ] + " \n " ) ] NEW_LINE for key , value in headers : NEW_LINE INDENT parts . append ( escape . utf8 ( key ) + b " : ▁ " + escape . utf8 ( value ) + b " \n " ) NEW_LINE DEDENT parts . append ( b " \n " ) NEW_LINE parts . append ( body ) NEW_LINE request . write ( b " " . join ( parts ) ) NEW_LINE request . finish ( ) NEW_LINE self . _log ( status_code , request ) NEW_LINE DEDENT @ staticmethod NEW_LINE def environ ( request ) : NEW_LINE INDENT """ Converts ▁ a ▁ ` tornado . httpserver . HTTPRequest ` ▁ to ▁ a ▁ WSGI ▁ environment . STRNEWLINE ▁ """ NEW_LINE hostport = request . host . split ( " : " ) NEW_LINE if len ( hostport ) == 2 : NEW_LINE INDENT host = hostport [ 0 ] NEW_LINE port = int ( hostport [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT host = request . host NEW_LINE port = 443 if request . protocol == " https " else 80 NEW_LINE DEDENT environ = { " REQUEST _ METHOD " : request . method , " SCRIPT _ NAME " : " " , " PATH _ INFO " : to_wsgi_str ( escape . url_unescape ( request . path , encoding = None , plus = False ) ) , " QUERY _ STRING " : request . query , " REMOTE _ ADDR " : request . remote_ip , " SERVER _ NAME " : host , " SERVER _ PORT " : str ( port ) , " SERVER _ PROTOCOL " : request . version , " wsgi . version " : ( 1 , 0 ) , " wsgi . url _ scheme " : request . protocol , " wsgi . input " : BytesIO ( escape . utf8 ( request . body ) ) , " wsgi . errors " : sys . stderr , " wsgi . multithread " : False , " wsgi . multiprocess " : True , " wsgi . run _ once " : False , } NEW_LINE if " Content - Type " in request . headers : NEW_LINE INDENT environ [ " CONTENT _ TYPE " ] = request . headers . pop ( " Content - Type " ) NEW_LINE DEDENT if " Content - Length " in request . headers : NEW_LINE INDENT environ [ " CONTENT _ LENGTH " ] = request . headers . pop ( " Content - Length " ) NEW_LINE DEDENT for key , value in request . headers . items ( ) : NEW_LINE INDENT environ [ " HTTP _ " + key . replace ( " - " , " _ " ) . upper ( ) ] = value NEW_LINE DEDENT return environ NEW_LINE DEDENT def _log ( self , status_code , request ) : NEW_LINE INDENT if status_code < 400 : NEW_LINE INDENT log_method = access_log . info NEW_LINE DEDENT elif status_code < 500 : NEW_LINE INDENT log_method = access_log . warning NEW_LINE DEDENT else : NEW_LINE INDENT log_method = access_log . error NEW_LINE DEDENT request_time = 1000.0 * request . request_time ( ) NEW_LINE summary = request . method + " ▁ " + request . uri + " ▁ ( " + request . remote_ip + " ) " NEW_LINE log_method ( " % d ▁ % s ▁ % .2fms " , status_code , summary , request_time ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="bert9bert/statsmodels/tree/master/statsmodels/sandbox/nonparametric/kernel_extras.py"> """ STRNEWLINE Multivariate ▁ Conditional ▁ and ▁ Unconditional ▁ Kernel ▁ Density ▁ Estimation STRNEWLINE with ▁ Mixed ▁ Data ▁ Types STRNEWLINE STRNEWLINE References STRNEWLINE - - - - - STRNEWLINE [ 1 ] ▁ Racine , ▁ J . , ▁ Li , ▁ Q . ▁ Nonparametric ▁ econometrics : ▁ theory ▁ and ▁ practice . STRNEWLINE ▁ Princeton ▁ University ▁ Press . ▁ ( 2007 ) STRNEWLINE [ 2 ] ▁ Racine , ▁ Jeff . ▁ " Nonparametric ▁ Econometrics : ▁ A ▁ Primer , " ▁ Foundation STRNEWLINE ▁ and ▁ Trends ▁ in ▁ Econometrics : ▁ Vol ▁ 3 : ▁ No ▁ 1 , ▁ pp1-88 . ▁ ( 2008 ) STRNEWLINE ▁ http : / / dx . doi . org / 10.1561/08000009 STRNEWLINE [ 3 ] ▁ Racine , ▁ J . , ▁ Li , ▁ Q . ▁ " Nonparametric ▁ Estimation ▁ of ▁ Distributions STRNEWLINE ▁ with ▁ Categorical ▁ and ▁ Continuous ▁ Data . " ▁ Working ▁ Paper . ▁ ( 2000 ) STRNEWLINE [ 4 ] ▁ Racine , ▁ J . ▁ Li , ▁ Q . ▁ " Kernel ▁ Estimation ▁ of ▁ Multivariate ▁ Conditional STRNEWLINE ▁ Distributions ▁ Annals ▁ of ▁ Economics ▁ and ▁ Finance ▁ 5 , ▁ 211-235 ▁ ( 2004 ) STRNEWLINE [ 5 ] ▁ Liu , ▁ R . , ▁ Yang , ▁ L . ▁ " Kernel ▁ estimation ▁ of ▁ multivariate STRNEWLINE ▁ cumulative ▁ distribution ▁ function . " STRNEWLINE ▁ Journal ▁ of ▁ Nonparametric ▁ Statistics ▁ ( 2008 ) STRNEWLINE [ 6 ] ▁ Li , ▁ R . , ▁ Ju , ▁ G . ▁ " Nonparametric ▁ Estimation ▁ of ▁ Multivariate ▁ CDF STRNEWLINE ▁ with ▁ Categorical ▁ and ▁ Continuous ▁ Data . " ▁ Working ▁ Paper STRNEWLINE [ 7 ] ▁ Li , ▁ Q . , ▁ Racine , ▁ J . ▁ " Cross - validated ▁ local ▁ linear ▁ nonparametric STRNEWLINE ▁ regression " ▁ Statistica ▁ Sinica ▁ 14(2004 ) , ▁ pp . ▁ 485-512 STRNEWLINE [ 8 ] ▁ Racine , ▁ J . : ▁ " Consistent ▁ Significance ▁ Testing ▁ for ▁ Nonparametric STRNEWLINE ▁ Regression " ▁ Journal ▁ of ▁ Business ▁ & ▁ Economics ▁ Statistics STRNEWLINE [ 9 ] ▁ Racine , ▁ J . , ▁ Hart , ▁ J . , ▁ Li , ▁ Q . , ▁ " Testing ▁ the ▁ Significance ▁ of STRNEWLINE ▁ Categorical ▁ Predictor ▁ Variables ▁ in ▁ Nonparametric ▁ Regression STRNEWLINE ▁ Models " , ▁ 2006 , ▁ Econometric ▁ Reviews ▁ 25 , ▁ 523-544 STRNEWLINE STRNEWLINE """ NEW_LINE # ▁ TODO : ▁ make ▁ default ▁ behavior ▁ efficient = True ▁ above ▁ a ▁ certain ▁ n _ obs ENDCOM from statsmodels . compat . python import range , next NEW_LINE import numpy as np NEW_LINE from scipy import optimize NEW_LINE from scipy . stats . mstats import mquantiles NEW_LINE from statsmodels . nonparametric . api import KDEMultivariate , KernelReg NEW_LINE from statsmodels . nonparametric . _kernel_base import gpke , LeaveOneOut , _get_type_pos , _adjust_shape NEW_LINE __all__ = [ ' SingleIndexModel ' , ' SemiLinear ' , ' TestFForm ' ] NEW_LINE class TestFForm ( object ) : NEW_LINE INDENT """ STRNEWLINE ▁ Nonparametric ▁ test ▁ for ▁ functional ▁ form . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ endog : ▁ list STRNEWLINE ▁ Dependent ▁ variable ▁ ( training ▁ set ) STRNEWLINE ▁ exog : ▁ list ▁ of ▁ array _ like ▁ objects STRNEWLINE ▁ The ▁ independent ▁ ( right - hand - side ) ▁ variables STRNEWLINE ▁ bw : ▁ array _ like , ▁ str STRNEWLINE ▁ Bandwidths ▁ for ▁ exog ▁ or ▁ specify ▁ method ▁ for ▁ bandwidth ▁ selection STRNEWLINE ▁ fform : ▁ function STRNEWLINE ▁ The ▁ functional ▁ form ▁ ` ` y ▁ = ▁ g ( b , ▁ x ) ` ` ▁ to ▁ be ▁ tested . ▁ Takes ▁ as ▁ inputs STRNEWLINE ▁ the ▁ RHS ▁ variables ▁ ` exog ` ▁ and ▁ the ▁ coefficients ▁ ` ` b ` ` ▁ ( betas ) STRNEWLINE ▁ and ▁ returns ▁ a ▁ fitted ▁ ` ` y _ hat ` ` . STRNEWLINE ▁ var _ type : ▁ str STRNEWLINE ▁ The ▁ type ▁ of ▁ the ▁ independent ▁ ` exog ` ▁ variables : STRNEWLINE STRNEWLINE ▁ - ▁ c : ▁ continuous STRNEWLINE ▁ - ▁ o : ▁ ordered STRNEWLINE ▁ - ▁ u : ▁ unordered STRNEWLINE STRNEWLINE ▁ estimator : ▁ function STRNEWLINE ▁ Must ▁ return ▁ the ▁ estimated ▁ coefficients ▁ b ▁ ( betas ) . ▁ Takes ▁ as ▁ inputs STRNEWLINE ▁ ` ` ( endog , ▁ exog ) ` ` . ▁ E . g . ▁ least ▁ square ▁ estimator : : STRNEWLINE STRNEWLINE ▁ lambda ▁ ( x , y ) : ▁ np . dot ( np . pinv ( np . dot ( x . T , ▁ x ) ) , ▁ np . dot ( x . T , ▁ y ) ) STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ See ▁ Racine , ▁ J . : ▁ " Consistent ▁ Significance ▁ Testing ▁ for ▁ Nonparametric STRNEWLINE ▁ Regression " ▁ Journal ▁ of ▁ Business ▁ \ & ▁ Economics ▁ Statistics . STRNEWLINE STRNEWLINE ▁ See ▁ chapter ▁ 12 ▁ in ▁ [ 1 ] ▁ pp . ▁ 355-357 . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , endog , exog , bw , var_type , fform , estimator , nboot = 100 ) : NEW_LINE INDENT self . endog = endog NEW_LINE self . exog = exog NEW_LINE self . var_type = var_type NEW_LINE self . fform = fform NEW_LINE self . estimator = estimator NEW_LINE self . nboot = nboot NEW_LINE self . bw = KDEMultivariate ( exog , bw = bw , var_type = var_type ) . bw NEW_LINE self . sig = self . _compute_sig ( ) NEW_LINE DEDENT def _compute_sig ( self ) : NEW_LINE INDENT Y = self . endog NEW_LINE X = self . exog NEW_LINE b = self . estimator ( Y , X ) NEW_LINE m = self . fform ( X , b ) NEW_LINE n = np . shape ( X ) [ 0 ] NEW_LINE resid = Y - m NEW_LINE resid = resid - np . mean ( resid ) # ▁ center ▁ residuals ENDCOM NEW_LINE self . test_stat = self . _compute_test_stat ( resid ) NEW_LINE sqrt5 = np . sqrt ( 5. ) NEW_LINE fct1 = ( 1 - sqrt5 ) / 2. NEW_LINE fct2 = ( 1 + sqrt5 ) / 2. NEW_LINE u1 = fct1 * resid NEW_LINE u2 = fct2 * resid NEW_LINE r = fct2 / sqrt5 NEW_LINE I_dist = np . empty ( ( self . nboot , 1 ) ) NEW_LINE for j in range ( self . nboot ) : NEW_LINE INDENT u_boot = u2 . copy ( ) NEW_LINE prob = np . random . uniform ( 0 , 1 , size = ( n , ) ) NEW_LINE ind = prob < r NEW_LINE u_boot [ ind ] = u1 [ ind ] NEW_LINE Y_boot = m + u_boot NEW_LINE b_hat = self . estimator ( Y_boot , X ) NEW_LINE m_hat = self . fform ( X , b_hat ) NEW_LINE u_boot_hat = Y_boot - m_hat NEW_LINE I_dist [ j ] = self . _compute_test_stat ( u_boot_hat ) NEW_LINE DEDENT self . boots_results = I_dist NEW_LINE sig = " Not ▁ Significant " NEW_LINE if self . test_stat > mquantiles ( I_dist , 0.9 ) : NEW_LINE INDENT sig = " * " NEW_LINE DEDENT if self . test_stat > mquantiles ( I_dist , 0.95 ) : NEW_LINE INDENT sig = " * * " NEW_LINE DEDENT if self . test_stat > mquantiles ( I_dist , 0.99 ) : NEW_LINE INDENT sig = " * * * " NEW_LINE DEDENT return sig NEW_LINE DEDENT def _compute_test_stat ( self , u ) : NEW_LINE INDENT n = np . shape ( u ) [ 0 ] NEW_LINE XLOO = LeaveOneOut ( self . exog ) NEW_LINE uLOO = LeaveOneOut ( u [ : , None ] ) . __iter__ ( ) NEW_LINE I = 0 NEW_LINE S2 = 0 NEW_LINE for i , X_not_i in enumerate ( XLOO ) : NEW_LINE INDENT u_j = next ( uLOO ) NEW_LINE u_j = np . squeeze ( u_j ) NEW_LINE # ▁ See ▁ Bootstrapping ▁ procedure ▁ on ▁ p . ▁ 357 ▁ in ▁ [ 1 ] ENDCOM K = gpke ( self . bw , data = - X_not_i , data_predict = - self . exog [ i , : ] , var_type = self . var_type , tosum = False ) NEW_LINE f_i = ( u [ i ] * u_j * K ) NEW_LINE assert u_j . shape == K . shape NEW_LINE I += f_i . sum ( ) # ▁ See ▁ eq . ▁ 12.7 ▁ on ▁ p . ▁ 355 ▁ in ▁ [ 1 ] ENDCOM NEW_LINE S2 += ( f_i ** 2 ) . sum ( ) # ▁ See ▁ Theorem ▁ 12.1 ▁ on ▁ p . 356 ▁ in ▁ [ 1 ] ENDCOM NEW_LINE assert np . size ( I ) == 1 NEW_LINE assert np . size ( S2 ) == 1 NEW_LINE DEDENT I *= 1. / ( n * ( n - 1 ) ) NEW_LINE ix_cont = _get_type_pos ( self . var_type ) [ 0 ] NEW_LINE hp = self . bw [ ix_cont ] . prod ( ) NEW_LINE S2 *= 2 * hp / ( n * ( n - 1 ) ) NEW_LINE T = n * I * np . sqrt ( hp / S2 ) NEW_LINE return T NEW_LINE DEDENT DEDENT class SingleIndexModel ( KernelReg ) : NEW_LINE INDENT """ STRNEWLINE ▁ Single ▁ index ▁ semiparametric ▁ model ▁ ` ` y ▁ = ▁ g ( X ▁ * ▁ b ) ▁ + ▁ e ` ` . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ endog : ▁ array _ like STRNEWLINE ▁ The ▁ dependent ▁ variable STRNEWLINE ▁ exog : ▁ array _ like STRNEWLINE ▁ The ▁ independent ▁ variable ( s ) STRNEWLINE ▁ var _ type : ▁ str STRNEWLINE ▁ The ▁ type ▁ of ▁ variables ▁ in ▁ X : STRNEWLINE STRNEWLINE ▁ - ▁ c : ▁ continuous STRNEWLINE ▁ - ▁ o : ▁ ordered STRNEWLINE ▁ - ▁ u : ▁ unordered STRNEWLINE STRNEWLINE ▁ Attributes STRNEWLINE ▁ - - - - - STRNEWLINE ▁ b : ▁ array _ like STRNEWLINE ▁ The ▁ linear ▁ coefficients ▁ b ▁ ( betas ) STRNEWLINE ▁ bw : ▁ array _ like STRNEWLINE ▁ Bandwidths STRNEWLINE STRNEWLINE ▁ Methods STRNEWLINE ▁ - - - - - STRNEWLINE ▁ fit ( ) : ▁ Computes ▁ the ▁ fitted ▁ values ▁ ` ` E [ Y | X ] ▁ = ▁ g ( X ▁ * ▁ b ) ` ` STRNEWLINE ▁ and ▁ the ▁ marginal ▁ effects ▁ ` ` dY / dX ` ` . STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ See ▁ chapter ▁ on ▁ semiparametric ▁ models ▁ in ▁ [ 1 ] STRNEWLINE STRNEWLINE ▁ Notes STRNEWLINE ▁ - - - - - STRNEWLINE ▁ This ▁ model ▁ resembles ▁ the ▁ binary ▁ choice ▁ models . ▁ The ▁ user ▁ knows STRNEWLINE ▁ that ▁ X ▁ and ▁ b ▁ interact ▁ linearly , ▁ but ▁ ` ` g ( X ▁ * ▁ b ) ` ` ▁ is ▁ unknown . STRNEWLINE ▁ In ▁ the ▁ parametric ▁ binary ▁ choice ▁ models ▁ the ▁ user ▁ usually ▁ assumes STRNEWLINE ▁ some ▁ distribution ▁ of ▁ g ( ) ▁ such ▁ as ▁ normal ▁ or ▁ logistic . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , endog , exog , var_type ) : NEW_LINE INDENT self . var_type = var_type NEW_LINE self . K = len ( var_type ) NEW_LINE self . var_type = self . var_type [ 0 ] NEW_LINE self . endog = _adjust_shape ( endog , 1 ) NEW_LINE self . exog = _adjust_shape ( exog , self . K ) NEW_LINE self . nobs = np . shape ( self . exog ) [ 0 ] NEW_LINE self . data_type = self . var_type NEW_LINE self . func = self . _est_loc_linear NEW_LINE self . b , self . bw = self . _est_b_bw ( ) NEW_LINE DEDENT def _est_b_bw ( self ) : NEW_LINE INDENT params0 = np . random . uniform ( size = ( self . K + 1 , ) ) NEW_LINE b_bw = optimize . fmin ( self . cv_loo , params0 , disp = 0 ) NEW_LINE b = b_bw [ 0 : self . K ] NEW_LINE bw = b_bw [ self . K : ] NEW_LINE bw = self . _set_bw_bounds ( bw ) NEW_LINE return b , bw NEW_LINE DEDENT def cv_loo ( self , params ) : NEW_LINE # ▁ See ▁ p . ▁ 254 ▁ in ▁ Textbook ENDCOM INDENT params = np . asarray ( params ) NEW_LINE b = params [ 0 : self . K ] NEW_LINE bw = params [ self . K : ] NEW_LINE LOO_X = LeaveOneOut ( self . exog ) NEW_LINE LOO_Y = LeaveOneOut ( self . endog ) . __iter__ ( ) NEW_LINE L = 0 NEW_LINE for i , X_not_i in enumerate ( LOO_X ) : NEW_LINE INDENT Y = next ( LOO_Y ) NEW_LINE # print ▁ b . shape , ▁ np . dot ( self . exog [ i : i + 1 , ▁ : ] , ▁ b ) . shape , ▁ bw , ENDCOM G = self . func ( bw , endog = Y , exog = - np . dot ( X_not_i , b ) [ : , None ] , # data _ predict = - b * self . exog [ i , ▁ : ] ) [0 ] ENDCOM data_predict = - np . dot ( self . exog [ i : i + 1 , : ] , b ) ) [ 0 ] NEW_LINE # print ▁ G . shape ENDCOM L += ( self . endog [ i ] - G ) ** 2 NEW_LINE # ▁ Note : ▁ There ▁ might ▁ be ▁ a ▁ way ▁ to ▁ vectorize ▁ this . ▁ See ▁ p . 72 ▁ in ▁ [ 1 ] ENDCOM DEDENT return L / self . nobs NEW_LINE DEDENT def fit ( self , data_predict = None ) : NEW_LINE INDENT if data_predict is None : NEW_LINE INDENT data_predict = self . exog NEW_LINE DEDENT else : NEW_LINE INDENT data_predict = _adjust_shape ( data_predict , self . K ) NEW_LINE DEDENT N_data_predict = np . shape ( data_predict ) [ 0 ] NEW_LINE mean = np . empty ( ( N_data_predict , ) ) NEW_LINE mfx = np . empty ( ( N_data_predict , self . K ) ) NEW_LINE for i in range ( N_data_predict ) : NEW_LINE INDENT mean_mfx = self . func ( self . bw , self . endog , np . dot ( self . exog , self . b ) [ : , None ] , data_predict = np . dot ( data_predict [ i : i + 1 , : ] , self . b ) ) NEW_LINE mean [ i ] = mean_mfx [ 0 ] NEW_LINE mfx_c = np . squeeze ( mean_mfx [ 1 ] ) NEW_LINE mfx [ i , : ] = mfx_c NEW_LINE DEDENT return mean , mfx NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT """ Provide ▁ something ▁ sane ▁ to ▁ print . """ NEW_LINE repr = " Single ▁ Index ▁ Model ▁ \n " NEW_LINE repr += " Number ▁ of ▁ variables : ▁ K ▁ = ▁ " + str ( self . K ) + " \n " NEW_LINE repr += " Number ▁ of ▁ samples : ▁ ▁ ▁ nobs ▁ = ▁ " + str ( self . nobs ) + " \n " NEW_LINE repr += " Variable ▁ types : ▁ ▁ ▁ ▁ ▁ ▁ " + self . var_type + " \n " NEW_LINE repr += " BW ▁ selection ▁ method : ▁ cv _ ls " + " \n " NEW_LINE repr += " Estimator ▁ type : ▁ local ▁ constant " + " \n " NEW_LINE return repr NEW_LINE DEDENT DEDENT class SemiLinear ( KernelReg ) : NEW_LINE INDENT """ STRNEWLINE ▁ Semiparametric ▁ partially ▁ linear ▁ model , ▁ ` ` Y ▁ = ▁ Xb ▁ + ▁ g ( Z ) ▁ + ▁ e ` ` . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ endog : ▁ array _ like STRNEWLINE ▁ The ▁ dependent ▁ variable STRNEWLINE ▁ exog : ▁ array _ like STRNEWLINE ▁ The ▁ linear ▁ component ▁ in ▁ the ▁ regression STRNEWLINE ▁ exog _ nonparametric : ▁ array _ like STRNEWLINE ▁ The ▁ nonparametric ▁ component ▁ in ▁ the ▁ regression STRNEWLINE ▁ var _ type : ▁ str STRNEWLINE ▁ The ▁ type ▁ of ▁ the ▁ variables ▁ in ▁ the ▁ nonparametric ▁ component ; STRNEWLINE STRNEWLINE ▁ - ▁ c : ▁ continuous STRNEWLINE ▁ - ▁ o : ▁ ordered STRNEWLINE ▁ - ▁ u : ▁ unordered STRNEWLINE STRNEWLINE ▁ k _ linear ▁ : ▁ int STRNEWLINE ▁ The ▁ number ▁ of ▁ variables ▁ that ▁ comprise ▁ the ▁ linear ▁ component . STRNEWLINE STRNEWLINE ▁ Attributes STRNEWLINE ▁ - - - - - STRNEWLINE ▁ bw : ▁ array _ like STRNEWLINE ▁ Bandwidths ▁ for ▁ the ▁ nonparametric ▁ component ▁ exog _ nonparametric STRNEWLINE ▁ b : ▁ array _ like STRNEWLINE ▁ Coefficients ▁ in ▁ the ▁ linear ▁ component STRNEWLINE ▁ nobs ▁ : ▁ int STRNEWLINE ▁ The ▁ number ▁ of ▁ observations . STRNEWLINE ▁ k _ linear ▁ : ▁ int STRNEWLINE ▁ The ▁ number ▁ of ▁ variables ▁ that ▁ comprise ▁ the ▁ linear ▁ component . STRNEWLINE STRNEWLINE ▁ Methods STRNEWLINE ▁ - - - - - STRNEWLINE ▁ fit ( ) : ▁ Returns ▁ the ▁ fitted ▁ mean ▁ and ▁ marginal ▁ effects ▁ dy / dz STRNEWLINE STRNEWLINE ▁ Notes STRNEWLINE ▁ - - - - - STRNEWLINE ▁ This ▁ model ▁ uses ▁ only ▁ the ▁ local ▁ constant ▁ regression ▁ estimator STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ See ▁ chapter ▁ on ▁ Semiparametric ▁ Models ▁ in ▁ [ 1 ] STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , endog , exog , exog_nonparametric , var_type , k_linear ) : NEW_LINE INDENT self . endog = _adjust_shape ( endog , 1 ) NEW_LINE self . exog = _adjust_shape ( exog , k_linear ) NEW_LINE self . K = len ( var_type ) NEW_LINE self . exog_nonparametric = _adjust_shape ( exog_nonparametric , self . K ) NEW_LINE self . k_linear = k_linear NEW_LINE self . nobs = np . shape ( self . exog ) [ 0 ] NEW_LINE self . var_type = var_type NEW_LINE self . data_type = self . var_type NEW_LINE self . func = self . _est_loc_linear NEW_LINE self . b , self . bw = self . _est_b_bw ( ) NEW_LINE DEDENT def _est_b_bw ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Computes ▁ the ▁ ( beta ) ▁ coefficients ▁ and ▁ the ▁ bandwidths . STRNEWLINE STRNEWLINE ▁ Minimizes ▁ ` ` cv _ loo ` ` ▁ with ▁ respect ▁ to ▁ ` ` b ` ` ▁ and ▁ ` ` bw ` ` . STRNEWLINE ▁ """ NEW_LINE params0 = np . random . uniform ( size = ( self . k_linear + self . K , ) ) NEW_LINE b_bw = optimize . fmin ( self . cv_loo , params0 , disp = 0 ) NEW_LINE b = b_bw [ 0 : self . k_linear ] NEW_LINE bw = b_bw [ self . k_linear : ] NEW_LINE # bw ▁ = ▁ self . _ set _ bw _ bounds ( np . asarray ( bw ) ) ENDCOM return b , bw NEW_LINE DEDENT def cv_loo ( self , params ) : NEW_LINE INDENT """ STRNEWLINE ▁ Similar ▁ to ▁ the ▁ cross ▁ validation ▁ leave - one - out ▁ estimator . STRNEWLINE STRNEWLINE ▁ Modified ▁ to ▁ reflect ▁ the ▁ linear ▁ components . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ params : ▁ array _ like STRNEWLINE ▁ Vector ▁ consisting ▁ of ▁ the ▁ coefficients ▁ ( b ) ▁ and ▁ the ▁ bandwidths ▁ ( bw ) . STRNEWLINE ▁ The ▁ first ▁ ` ` k _ linear ` ` ▁ elements ▁ are ▁ the ▁ coefficients . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ L : ▁ float STRNEWLINE ▁ The ▁ value ▁ of ▁ the ▁ objective ▁ function STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ See ▁ p . 254 ▁ in ▁ [ 1 ] STRNEWLINE ▁ """ NEW_LINE params = np . asarray ( params ) NEW_LINE b = params [ 0 : self . k_linear ] NEW_LINE bw = params [ self . k_linear : ] NEW_LINE LOO_X = LeaveOneOut ( self . exog ) NEW_LINE LOO_Y = LeaveOneOut ( self . endog ) . __iter__ ( ) NEW_LINE LOO_Z = LeaveOneOut ( self . exog_nonparametric ) . __iter__ ( ) NEW_LINE Xb = np . dot ( self . exog , b ) [ : , None ] NEW_LINE L = 0 NEW_LINE for ii , X_not_i in enumerate ( LOO_X ) : NEW_LINE INDENT Y = next ( LOO_Y ) NEW_LINE Z = next ( LOO_Z ) NEW_LINE Xb_j = np . dot ( X_not_i , b ) [ : , None ] NEW_LINE Yx = Y - Xb_j NEW_LINE G = self . func ( bw , endog = Yx , exog = - Z , data_predict = - self . exog_nonparametric [ ii , : ] ) [ 0 ] NEW_LINE lt = Xb [ ii , : ] # . sum ( ) ▁ # ▁ linear ▁ term ENDCOM NEW_LINE L += ( self . endog [ ii ] - lt - G ) ** 2 NEW_LINE DEDENT return L NEW_LINE DEDENT def fit ( self , exog_predict = None , exog_nonparametric_predict = None ) : NEW_LINE INDENT """ Computes ▁ fitted ▁ values ▁ and ▁ marginal ▁ effects """ NEW_LINE if exog_predict is None : NEW_LINE INDENT exog_predict = self . exog NEW_LINE DEDENT else : NEW_LINE INDENT exog_predict = _adjust_shape ( exog_predict , self . k_linear ) NEW_LINE DEDENT if exog_nonparametric_predict is None : NEW_LINE INDENT exog_nonparametric_predict = self . exog_nonparametric NEW_LINE DEDENT else : NEW_LINE INDENT exog_nonparametric_predict = _adjust_shape ( exog_nonparametric_predict , self . K ) NEW_LINE DEDENT N_data_predict = np . shape ( exog_nonparametric_predict ) [ 0 ] NEW_LINE mean = np . empty ( ( N_data_predict , ) ) NEW_LINE mfx = np . empty ( ( N_data_predict , self . K ) ) NEW_LINE Y = self . endog - np . dot ( exog_predict , self . b ) [ : , None ] NEW_LINE for i in range ( N_data_predict ) : NEW_LINE INDENT mean_mfx = self . func ( self . bw , Y , self . exog_nonparametric , data_predict = exog_nonparametric_predict [ i , : ] ) NEW_LINE mean [ i ] = mean_mfx [ 0 ] NEW_LINE mfx_c = np . squeeze ( mean_mfx [ 1 ] ) NEW_LINE mfx [ i , : ] = mfx_c NEW_LINE DEDENT return mean , mfx NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT """ Provide ▁ something ▁ sane ▁ to ▁ print . """ NEW_LINE repr = " Semiparamatric ▁ Partially ▁ Linear ▁ Model ▁ \n " NEW_LINE repr += " Number ▁ of ▁ variables : ▁ K ▁ = ▁ " + str ( self . K ) + " \n " NEW_LINE repr += " Number ▁ of ▁ samples : ▁ ▁ ▁ N ▁ = ▁ " + str ( self . nobs ) + " \n " NEW_LINE repr += " Variable ▁ types : ▁ ▁ ▁ ▁ ▁ ▁ " + self . var_type + " \n " NEW_LINE repr += " BW ▁ selection ▁ method : ▁ cv _ ls " + " \n " NEW_LINE repr += " Estimator ▁ type : ▁ local ▁ constant " + " \n " NEW_LINE return repr NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="w1ll1am23/home-assistant/tree/master/homeassistant/components/homematicip_cloud/weather.py"> """ Support ▁ for ▁ HomematicIP ▁ Cloud ▁ weather ▁ devices . """ NEW_LINE import logging NEW_LINE from homematicip . aio . device import ( AsyncWeatherSensor , AsyncWeatherSensorPlus , AsyncWeatherSensorPro ) NEW_LINE from homematicip . aio . home import AsyncHome NEW_LINE from homeassistant . components . weather import WeatherEntity NEW_LINE from homeassistant . config_entries import ConfigEntry NEW_LINE from homeassistant . const import TEMP_CELSIUS NEW_LINE from homeassistant . core import HomeAssistant NEW_LINE from . import DOMAIN as HMIPC_DOMAIN , HMIPC_HAPID , HomematicipGenericDevice NEW_LINE _LOGGER = logging . getLogger ( __name__ ) NEW_LINE async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : NEW_LINE INDENT """ Set ▁ up ▁ the ▁ HomematicIP ▁ Cloud ▁ weather ▁ sensor . """ NEW_LINE pass NEW_LINE DEDENT async def async_setup_entry ( hass : HomeAssistant , config_entry : ConfigEntry , async_add_entities ) -> None : NEW_LINE INDENT """ Set ▁ up ▁ the ▁ HomematicIP ▁ weather ▁ sensor ▁ from ▁ a ▁ config ▁ entry . """ NEW_LINE home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home NEW_LINE devices = [ ] NEW_LINE for device in home . devices : NEW_LINE INDENT if isinstance ( device , AsyncWeatherSensorPro ) : NEW_LINE INDENT devices . append ( HomematicipWeatherSensorPro ( home , device ) ) NEW_LINE DEDENT elif isinstance ( device , ( AsyncWeatherSensor , AsyncWeatherSensorPlus ) ) : NEW_LINE INDENT devices . append ( HomematicipWeatherSensor ( home , device ) ) NEW_LINE DEDENT DEDENT if devices : NEW_LINE INDENT async_add_entities ( devices ) NEW_LINE DEDENT DEDENT class HomematicipWeatherSensor ( HomematicipGenericDevice , WeatherEntity ) : NEW_LINE INDENT """ representation ▁ of ▁ a ▁ HomematicIP ▁ Cloud ▁ weather ▁ sensor ▁ plus ▁ & ▁ basic . """ NEW_LINE def __init__ ( self , home : AsyncHome , device ) -> None : NEW_LINE INDENT """ Initialize ▁ the ▁ weather ▁ sensor . """ NEW_LINE super ( ) . __init__ ( home , device ) NEW_LINE DEDENT @ property NEW_LINE def name ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ name ▁ of ▁ the ▁ sensor . """ NEW_LINE return self . _device . label NEW_LINE DEDENT @ property NEW_LINE def temperature ( self ) -> float : NEW_LINE INDENT """ Return ▁ the ▁ platform ▁ temperature . """ NEW_LINE return self . _device . actualTemperature NEW_LINE DEDENT @ property NEW_LINE def temperature_unit ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ unit ▁ of ▁ measurement . """ NEW_LINE return TEMP_CELSIUS NEW_LINE DEDENT @ property NEW_LINE def humidity ( self ) -> int : NEW_LINE INDENT """ Return ▁ the ▁ humidity . """ NEW_LINE return self . _device . humidity NEW_LINE DEDENT @ property NEW_LINE def wind_speed ( self ) -> float : NEW_LINE INDENT """ Return ▁ the ▁ wind ▁ speed . """ NEW_LINE return self . _device . windSpeed NEW_LINE DEDENT @ property NEW_LINE def attribution ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ attribution . """ NEW_LINE return " Powered ▁ by ▁ Homematic ▁ IP " NEW_LINE DEDENT @ property NEW_LINE def condition ( self ) -> str : NEW_LINE INDENT """ Return ▁ the ▁ current ▁ condition . """ NEW_LINE if hasattr ( self . _device , " raining " ) and self . _device . raining : NEW_LINE INDENT return ' rainy ' NEW_LINE DEDENT if self . _device . storm : NEW_LINE INDENT return ' windy ' NEW_LINE DEDENT if self . _device . sunshine : NEW_LINE INDENT return ' sunny ' NEW_LINE DEDENT return ' ' NEW_LINE DEDENT DEDENT class HomematicipWeatherSensorPro ( HomematicipWeatherSensor ) : NEW_LINE INDENT """ representation ▁ of ▁ a ▁ HomematicIP ▁ weather ▁ sensor ▁ pro . """ NEW_LINE @ property NEW_LINE def wind_bearing ( self ) -> float : NEW_LINE INDENT """ Return ▁ the ▁ wind ▁ bearing . """ NEW_LINE return self . _device . windDirection NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="apollo13/ansible/tree/master/lib/ansible/modules/cloud/amazon/elasticache.py"> # ! / usr / bin / python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2017 ▁ Ansible ▁ Project ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ v3.0 + ▁ ( see ▁ COPYING ▁ or ▁ https : / / www . gnu . org / licenses / gpl - 3.0 . txt ) ENDCOM ANSIBLE_METADATA = { ' metadata _ version ' : '1.1' , ' status ' : [ ' preview ' ] , ' supported _ by ' : ' community ' } NEW_LINE DOCUMENTATION = """ STRNEWLINE - - - STRNEWLINE module : ▁ elasticache STRNEWLINE short _ description : ▁ Manage ▁ cache ▁ clusters ▁ in ▁ Amazon ▁ Elasticache . STRNEWLINE description : STRNEWLINE ▁ ▁ - ▁ Manage ▁ cache ▁ clusters ▁ in ▁ Amazon ▁ Elasticache . STRNEWLINE ▁ ▁ - ▁ Returns ▁ information ▁ about ▁ the ▁ specified ▁ cache ▁ cluster . STRNEWLINE version _ added : ▁ " 1.4 " STRNEWLINE requirements : ▁ [ ▁ boto3 ▁ ] STRNEWLINE author : ▁ " Jim ▁ Dalton ▁ ( @ jsdalton ) " STRNEWLINE options : STRNEWLINE ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ C ( absent ) ▁ or ▁ C ( present ) ▁ are ▁ idempotent ▁ actions ▁ that ▁ will ▁ create ▁ or ▁ destroy ▁ a ▁ cache ▁ cluster ▁ as ▁ needed . ▁ C ( rebooted ) ▁ will ▁ reboot ▁ the ▁ cluster , STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ resulting ▁ in ▁ a ▁ momentary ▁ outage . STRNEWLINE ▁ ▁ ▁ ▁ choices : ▁ [ ' present ' , ▁ ' absent ' , ▁ ' rebooted ' ] STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ cache ▁ cluster ▁ identifier STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ engine : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Name ▁ of ▁ the ▁ cache ▁ engine ▁ to ▁ be ▁ used . STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ memcached STRNEWLINE ▁ ▁ ▁ ▁ choices : ▁ [ ' redis ' , ▁ ' memcached ' ] STRNEWLINE ▁ ▁ cache _ engine _ version : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ version ▁ number ▁ of ▁ the ▁ cache ▁ engine STRNEWLINE ▁ ▁ node _ type : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ compute ▁ and ▁ memory ▁ capacity ▁ of ▁ the ▁ nodes ▁ in ▁ the ▁ cache ▁ cluster STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ cache . m1 . small STRNEWLINE ▁ ▁ num _ nodes : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ initial ▁ number ▁ of ▁ cache ▁ nodes ▁ that ▁ the ▁ cache ▁ cluster ▁ will ▁ have . ▁ Required ▁ when ▁ state = present . STRNEWLINE ▁ ▁ cache _ port : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ port ▁ number ▁ on ▁ which ▁ each ▁ of ▁ the ▁ cache ▁ nodes ▁ will ▁ accept ▁ connections STRNEWLINE ▁ ▁ cache _ parameter _ group : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ name ▁ of ▁ the ▁ cache ▁ parameter ▁ group ▁ to ▁ associate ▁ with ▁ this ▁ cache ▁ cluster . ▁ If ▁ this ▁ argument ▁ is ▁ omitted , ▁ the ▁ default ▁ cache ▁ parameter ▁ group STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ the ▁ specified ▁ engine ▁ will ▁ be ▁ used . STRNEWLINE ▁ ▁ ▁ ▁ version _ added : ▁ " 2.0 " STRNEWLINE ▁ ▁ ▁ ▁ aliases : ▁ [ ▁ ' parameter _ group ' ▁ ] STRNEWLINE ▁ ▁ cache _ subnet _ group : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ subnet ▁ group ▁ name ▁ to ▁ associate ▁ with . ▁ Only ▁ use ▁ if ▁ inside ▁ a ▁ vpc . ▁ Required ▁ if ▁ inside ▁ a ▁ vpc STRNEWLINE ▁ ▁ ▁ ▁ version _ added : ▁ " 2.0 " STRNEWLINE ▁ ▁ security _ group _ ids : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ A ▁ list ▁ of ▁ vpc ▁ security ▁ group ▁ names ▁ to ▁ associate ▁ with ▁ this ▁ cache ▁ cluster . ▁ Only ▁ use ▁ if ▁ inside ▁ a ▁ vpc STRNEWLINE ▁ ▁ ▁ ▁ version _ added : ▁ " 1.6 " STRNEWLINE ▁ ▁ cache _ security _ groups : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ A ▁ list ▁ of ▁ cache ▁ security ▁ group ▁ names ▁ to ▁ associate ▁ with ▁ this ▁ cache ▁ cluster . ▁ Must ▁ be ▁ an ▁ empty ▁ list ▁ if ▁ inside ▁ a ▁ vpc STRNEWLINE ▁ ▁ zone : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ The ▁ EC2 ▁ Availability ▁ Zone ▁ in ▁ which ▁ the ▁ cache ▁ cluster ▁ will ▁ be ▁ created STRNEWLINE ▁ ▁ wait : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Wait ▁ for ▁ cache ▁ cluster ▁ result ▁ before ▁ returning STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ ' yes ' STRNEWLINE ▁ ▁ hard _ modify : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Whether ▁ to ▁ destroy ▁ and ▁ recreate ▁ an ▁ existing ▁ cache ▁ cluster ▁ if ▁ necessary ▁ in ▁ order ▁ to ▁ modify ▁ its ▁ state STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ ' no ' STRNEWLINE extends _ documentation _ fragment : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ aws STRNEWLINE ▁ ▁ ▁ ▁ - ▁ ec2 STRNEWLINE """ NEW_LINE EXAMPLES = """ STRNEWLINE # ▁ Note : ▁ None ▁ of ▁ these ▁ examples ▁ set ▁ aws _ access _ key , ▁ aws _ secret _ key , ▁ or ▁ region . STRNEWLINE # ▁ It ▁ is ▁ assumed ▁ that ▁ their ▁ matching ▁ environment ▁ variables ▁ are ▁ set . STRNEWLINE STRNEWLINE # ▁ Basic ▁ example STRNEWLINE - ▁ elasticache : STRNEWLINE ▁ ▁ ▁ ▁ name : ▁ " test - please - delete " STRNEWLINE ▁ ▁ ▁ ▁ state : ▁ present STRNEWLINE ▁ ▁ ▁ ▁ engine : ▁ memcached STRNEWLINE ▁ ▁ ▁ ▁ cache _ engine _ version : ▁ 1.4.14 STRNEWLINE ▁ ▁ ▁ ▁ node _ type : ▁ cache . m1 . small STRNEWLINE ▁ ▁ ▁ ▁ num _ nodes : ▁ 1 STRNEWLINE ▁ ▁ ▁ ▁ cache _ port : ▁ 11211 STRNEWLINE ▁ ▁ ▁ ▁ cache _ security _ groups : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ default STRNEWLINE ▁ ▁ ▁ ▁ zone : ▁ us - east - 1d STRNEWLINE STRNEWLINE STRNEWLINE # ▁ Ensure ▁ cache ▁ cluster ▁ is ▁ gone STRNEWLINE - ▁ elasticache : STRNEWLINE ▁ ▁ ▁ ▁ name : ▁ " test - please - delete " STRNEWLINE ▁ ▁ ▁ ▁ state : ▁ absent STRNEWLINE STRNEWLINE # ▁ Reboot ▁ cache ▁ cluster STRNEWLINE - ▁ elasticache : STRNEWLINE ▁ ▁ ▁ ▁ name : ▁ " test - please - delete " STRNEWLINE ▁ ▁ ▁ ▁ state : ▁ rebooted STRNEWLINE STRNEWLINE """ NEW_LINE from time import sleep NEW_LINE from traceback import format_exc NEW_LINE from ansible . module_utils . basic import AnsibleModule NEW_LINE from ansible . module_utils . ec2 import ec2_argument_spec , get_aws_connection_info , boto3_conn , HAS_BOTO3 , camel_dict_to_snake_dict NEW_LINE try : NEW_LINE INDENT import boto3 NEW_LINE import botocore NEW_LINE DEDENT except ImportError : NEW_LINE INDENT pass # ▁ will ▁ be ▁ detected ▁ by ▁ imported ▁ HAS _ BOTO3 ENDCOM NEW_LINE DEDENT class ElastiCacheManager ( object ) : NEW_LINE INDENT """ Handles ▁ elasticache ▁ creation ▁ and ▁ destruction """ NEW_LINE EXIST_STATUSES = [ ' available ' , ' creating ' , ' rebooting ' , ' modifying ' ] NEW_LINE def __init__ ( self , module , name , engine , cache_engine_version , node_type , num_nodes , cache_port , cache_parameter_group , cache_subnet_group , cache_security_groups , security_group_ids , zone , wait , hard_modify , region , ** aws_connect_kwargs ) : NEW_LINE INDENT self . module = module NEW_LINE self . name = name NEW_LINE self . engine = engine . lower ( ) NEW_LINE self . cache_engine_version = cache_engine_version NEW_LINE self . node_type = node_type NEW_LINE self . num_nodes = num_nodes NEW_LINE self . cache_port = cache_port NEW_LINE self . cache_parameter_group = cache_parameter_group NEW_LINE self . cache_subnet_group = cache_subnet_group NEW_LINE self . cache_security_groups = cache_security_groups NEW_LINE self . security_group_ids = security_group_ids NEW_LINE self . zone = zone NEW_LINE self . wait = wait NEW_LINE self . hard_modify = hard_modify NEW_LINE self . region = region NEW_LINE self . aws_connect_kwargs = aws_connect_kwargs NEW_LINE self . changed = False NEW_LINE self . data = None NEW_LINE self . status = ' gone ' NEW_LINE self . conn = self . _get_elasticache_connection ( ) NEW_LINE self . _refresh_data ( ) NEW_LINE DEDENT def ensure_present ( self ) : NEW_LINE INDENT """ Ensure ▁ cache ▁ cluster ▁ exists ▁ or ▁ create ▁ it ▁ if ▁ not """ NEW_LINE if self . exists ( ) : NEW_LINE INDENT self . sync ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . create ( ) NEW_LINE DEDENT DEDENT def ensure_absent ( self ) : NEW_LINE INDENT """ Ensure ▁ cache ▁ cluster ▁ is ▁ gone ▁ or ▁ delete ▁ it ▁ if ▁ not """ NEW_LINE self . delete ( ) NEW_LINE DEDENT def ensure_rebooted ( self ) : NEW_LINE INDENT """ Ensure ▁ cache ▁ cluster ▁ is ▁ gone ▁ or ▁ delete ▁ it ▁ if ▁ not """ NEW_LINE self . reboot ( ) NEW_LINE DEDENT def exists ( self ) : NEW_LINE INDENT """ Check ▁ if ▁ cache ▁ cluster ▁ exists """ NEW_LINE return self . status in self . EXIST_STATUSES NEW_LINE DEDENT def create ( self ) : NEW_LINE INDENT """ Create ▁ an ▁ ElastiCache ▁ cluster """ NEW_LINE if self . status == ' available ' : NEW_LINE INDENT return NEW_LINE DEDENT if self . status in [ ' creating ' , ' rebooting ' , ' modifying ' ] : NEW_LINE INDENT if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' available ' ) NEW_LINE DEDENT return NEW_LINE DEDENT if self . status == ' deleting ' : NEW_LINE INDENT if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' gone ' ) NEW_LINE DEDENT else : NEW_LINE INDENT msg = " ' % s ' ▁ is ▁ currently ▁ deleting . ▁ Cannot ▁ create . " NEW_LINE self . module . fail_json ( msg = msg % self . name ) NEW_LINE DEDENT DEDENT kwargs = dict ( CacheClusterId = self . name , NumCacheNodes = self . num_nodes , CacheNodeType = self . node_type , Engine = self . engine , EngineVersion = self . cache_engine_version , CacheSecurityGroupNames = self . cache_security_groups , SecurityGroupIds = self . security_group_ids , CacheParameterGroupName = self . cache_parameter_group , CacheSubnetGroupName = self . cache_subnet_group ) NEW_LINE if self . cache_port is not None : NEW_LINE INDENT kwargs [ ' Port ' ] = self . cache_port NEW_LINE DEDENT if self . zone is not None : NEW_LINE INDENT kwargs [ ' PreferredAvailabilityZone ' ] = self . zone NEW_LINE DEDENT try : NEW_LINE INDENT self . conn . create_cache_cluster ( ** kwargs ) NEW_LINE DEDENT except botocore . exceptions . ClientError as e : NEW_LINE INDENT self . module . fail_json ( msg = e . message , exception = format_exc ( ) , ** camel_dict_to_snake_dict ( e . response ) ) NEW_LINE DEDENT self . _refresh_data ( ) NEW_LINE self . changed = True NEW_LINE if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' available ' ) NEW_LINE DEDENT return True NEW_LINE DEDENT def delete ( self ) : NEW_LINE INDENT """ Destroy ▁ an ▁ ElastiCache ▁ cluster """ NEW_LINE if self . status == ' gone ' : NEW_LINE INDENT return NEW_LINE DEDENT if self . status == ' deleting ' : NEW_LINE INDENT if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' gone ' ) NEW_LINE DEDENT return NEW_LINE DEDENT if self . status in [ ' creating ' , ' rebooting ' , ' modifying ' ] : NEW_LINE INDENT if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' available ' ) NEW_LINE DEDENT else : NEW_LINE INDENT msg = " ' % s ' ▁ is ▁ currently ▁ % s . ▁ Cannot ▁ delete . " NEW_LINE self . module . fail_json ( msg = msg % ( self . name , self . status ) ) NEW_LINE DEDENT DEDENT try : NEW_LINE INDENT response = self . conn . delete_cache_cluster ( CacheClusterId = self . name ) NEW_LINE DEDENT except botocore . exceptions . ClientError as e : NEW_LINE INDENT self . module . fail_json ( msg = e . message , exception = format_exc ( ) , ** camel_dict_to_snake_dict ( e . response ) ) NEW_LINE DEDENT cache_cluster_data = response [ ' CacheCluster ' ] NEW_LINE self . _refresh_data ( cache_cluster_data ) NEW_LINE self . changed = True NEW_LINE if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' gone ' ) NEW_LINE DEDENT DEDENT def sync ( self ) : NEW_LINE INDENT """ Sync ▁ settings ▁ to ▁ cluster ▁ if ▁ required """ NEW_LINE if not self . exists ( ) : NEW_LINE INDENT msg = " ' % s ' ▁ is ▁ % s . ▁ Cannot ▁ sync . " NEW_LINE self . module . fail_json ( msg = msg % ( self . name , self . status ) ) NEW_LINE DEDENT if self . status in [ ' creating ' , ' rebooting ' , ' modifying ' ] : NEW_LINE INDENT if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' available ' ) NEW_LINE DEDENT else : NEW_LINE # ▁ Cluster ▁ can ▁ only ▁ be ▁ synced ▁ if ▁ available . ▁ If ▁ we ▁ can ' t ▁ wait ENDCOM # ▁ for ▁ this , ▁ then ▁ just ▁ be ▁ done . ENDCOM INDENT return NEW_LINE DEDENT DEDENT if self . _requires_destroy_and_create ( ) : NEW_LINE INDENT if not self . hard_modify : NEW_LINE INDENT msg = " ' % s ' ▁ requires ▁ destructive ▁ modification . ▁ ' hard _ modify ' ▁ must ▁ be ▁ set ▁ to ▁ true ▁ to ▁ proceed . " NEW_LINE self . module . fail_json ( msg = msg % self . name ) NEW_LINE DEDENT if not self . wait : NEW_LINE INDENT msg = " ' % s ' ▁ requires ▁ destructive ▁ modification . ▁ ' wait ' ▁ must ▁ be ▁ set ▁ to ▁ true . " NEW_LINE self . module . fail_json ( msg = msg % self . name ) NEW_LINE DEDENT self . delete ( ) NEW_LINE self . create ( ) NEW_LINE return NEW_LINE DEDENT if self . _requires_modification ( ) : NEW_LINE INDENT self . modify ( ) NEW_LINE DEDENT DEDENT def modify ( self ) : NEW_LINE INDENT """ Modify ▁ the ▁ cache ▁ cluster . ▁ Note ▁ it ' s ▁ only ▁ possible ▁ to ▁ modify ▁ a ▁ few ▁ select ▁ options . """ NEW_LINE nodes_to_remove = self . _get_nodes_to_remove ( ) NEW_LINE try : NEW_LINE INDENT self . conn . modify_cache_cluster ( CacheClusterId = self . name , NumCacheNodes = self . num_nodes , CacheNodeIdsToRemove = nodes_to_remove , CacheSecurityGroupNames = self . cache_security_groups , CacheParameterGroupName = self . cache_parameter_group , SecurityGroupIds = self . security_group_ids , ApplyImmediately = True , EngineVersion = self . cache_engine_version ) NEW_LINE DEDENT except botocore . exceptions . ClientError as e : NEW_LINE INDENT self . module . fail_json ( msg = e . message , exception = format_exc ( ) , ** camel_dict_to_snake_dict ( e . response ) ) NEW_LINE DEDENT self . _refresh_data ( ) NEW_LINE self . changed = True NEW_LINE if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' available ' ) NEW_LINE DEDENT DEDENT def reboot ( self ) : NEW_LINE INDENT """ Reboot ▁ the ▁ cache ▁ cluster """ NEW_LINE if not self . exists ( ) : NEW_LINE INDENT msg = " ' % s ' ▁ is ▁ % s . ▁ Cannot ▁ reboot . " NEW_LINE self . module . fail_json ( msg = msg % ( self . name , self . status ) ) NEW_LINE DEDENT if self . status == ' rebooting ' : NEW_LINE INDENT return NEW_LINE DEDENT if self . status in [ ' creating ' , ' modifying ' ] : NEW_LINE INDENT if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' available ' ) NEW_LINE DEDENT else : NEW_LINE INDENT msg = " ' % s ' ▁ is ▁ currently ▁ % s . ▁ Cannot ▁ reboot . " NEW_LINE self . module . fail_json ( msg = msg % ( self . name , self . status ) ) NEW_LINE # ▁ Collect ▁ ALL ▁ nodes ▁ for ▁ reboot ENDCOM DEDENT DEDENT cache_node_ids = [ cn [ ' CacheNodeId ' ] for cn in self . data [ ' CacheNodes ' ] ] NEW_LINE try : NEW_LINE INDENT self . conn . reboot_cache_cluster ( CacheClusterId = self . name , CacheNodeIdsToReboot = cache_node_ids ) NEW_LINE DEDENT except botocore . exceptions . ClientError as e : NEW_LINE INDENT self . module . fail_json ( msg = e . message , exception = format_exc ( ) , ** camel_dict_to_snake_dict ( e . response ) ) NEW_LINE DEDENT self . _refresh_data ( ) NEW_LINE self . changed = True NEW_LINE if self . wait : NEW_LINE INDENT self . _wait_for_status ( ' available ' ) NEW_LINE DEDENT DEDENT def get_info ( self ) : NEW_LINE INDENT """ Return ▁ basic ▁ info ▁ about ▁ the ▁ cache ▁ cluster """ NEW_LINE info = { ' name ' : self . name , ' status ' : self . status } NEW_LINE if self . data : NEW_LINE INDENT info [ ' data ' ] = self . data NEW_LINE DEDENT return info NEW_LINE DEDENT def _wait_for_status ( self , awaited_status ) : NEW_LINE INDENT """ Wait ▁ for ▁ status ▁ to ▁ change ▁ from ▁ present ▁ status ▁ to ▁ awaited _ status """ NEW_LINE status_map = { ' creating ' : ' available ' , ' rebooting ' : ' available ' , ' modifying ' : ' available ' , ' deleting ' : ' gone ' } NEW_LINE if self . status == awaited_status : NEW_LINE # ▁ No ▁ need ▁ to ▁ wait , ▁ we ' re ▁ already ▁ done ENDCOM INDENT return NEW_LINE DEDENT if status_map [ self . status ] != awaited_status : NEW_LINE INDENT msg = " Invalid ▁ awaited ▁ status . ▁ ' % s ' ▁ cannot ▁ transition ▁ to ▁ ' % s ' " NEW_LINE self . module . fail_json ( msg = msg % ( self . status , awaited_status ) ) NEW_LINE DEDENT if awaited_status not in set ( status_map . values ( ) ) : NEW_LINE INDENT msg = " ' % s ' ▁ is ▁ not ▁ a ▁ valid ▁ awaited ▁ status . " NEW_LINE self . module . fail_json ( msg = msg % awaited_status ) NEW_LINE DEDENT while True : NEW_LINE INDENT sleep ( 1 ) NEW_LINE self . _refresh_data ( ) NEW_LINE if self . status == awaited_status : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT def _requires_modification ( self ) : NEW_LINE INDENT """ Check ▁ if ▁ cluster ▁ requires ▁ ( nondestructive ) ▁ modification """ NEW_LINE # ▁ Check ▁ modifiable ▁ data ▁ attributes ENDCOM modifiable_data = { ' NumCacheNodes ' : self . num_nodes , ' EngineVersion ' : self . cache_engine_version } NEW_LINE for key , value in modifiable_data . items ( ) : NEW_LINE INDENT if value is not None and value and self . data [ key ] != value : NEW_LINE INDENT return True NEW_LINE # ▁ Check ▁ cache ▁ security ▁ groups ENDCOM DEDENT DEDENT cache_security_groups = [ ] NEW_LINE for sg in self . data [ ' CacheSecurityGroups ' ] : NEW_LINE INDENT cache_security_groups . append ( sg [ ' CacheSecurityGroupName ' ] ) NEW_LINE DEDENT if set ( cache_security_groups ) != set ( self . cache_security_groups ) : NEW_LINE INDENT return True NEW_LINE # ▁ check ▁ vpc ▁ security ▁ groups ENDCOM DEDENT if self . security_group_ids : NEW_LINE INDENT vpc_security_groups = [ ] NEW_LINE security_groups = self . data [ ' SecurityGroups ' ] or [ ] NEW_LINE for sg in security_groups : NEW_LINE INDENT vpc_security_groups . append ( sg [ ' SecurityGroupId ' ] ) NEW_LINE DEDENT if set ( vpc_security_groups ) != set ( self . security_group_ids ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def _requires_destroy_and_create ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Check ▁ whether ▁ a ▁ destroy ▁ and ▁ create ▁ is ▁ required ▁ to ▁ synchronize ▁ cluster . STRNEWLINE ▁ """ NEW_LINE unmodifiable_data = { ' node _ type ' : self . data [ ' CacheNodeType ' ] , ' engine ' : self . data [ ' Engine ' ] , ' cache _ port ' : self . _get_port ( ) } NEW_LINE # ▁ Only ▁ check ▁ for ▁ modifications ▁ if ▁ zone ▁ is ▁ specified ENDCOM if self . zone is not None : NEW_LINE INDENT unmodifiable_data [ ' zone ' ] = self . data [ ' PreferredAvailabilityZone ' ] NEW_LINE DEDENT for key , value in unmodifiable_data . items ( ) : NEW_LINE INDENT if getattr ( self , key ) is not None and getattr ( self , key ) != value : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def _get_elasticache_connection ( self ) : NEW_LINE INDENT """ Get ▁ an ▁ elasticache ▁ connection """ NEW_LINE region , ec2_url , aws_connect_params = get_aws_connection_info ( self . module , boto3 = True ) NEW_LINE if region : NEW_LINE INDENT return boto3_conn ( self . module , conn_type = ' client ' , resource = ' elasticache ' , region = region , endpoint = ec2_url , ** aws_connect_params ) NEW_LINE DEDENT else : NEW_LINE INDENT self . module . fail_json ( msg = " region ▁ must ▁ be ▁ specified " ) NEW_LINE DEDENT DEDENT def _get_port ( self ) : NEW_LINE INDENT """ Get ▁ the ▁ port . ▁ Where ▁ this ▁ information ▁ is ▁ retrieved ▁ from ▁ is ▁ engine ▁ dependent . """ NEW_LINE if self . data [ ' Engine ' ] == ' memcached ' : NEW_LINE INDENT return self . data [ ' ConfigurationEndpoint ' ] [ ' Port ' ] NEW_LINE DEDENT elif self . data [ ' Engine ' ] == ' redis ' : NEW_LINE # ▁ Redis ▁ only ▁ supports ▁ a ▁ single ▁ node ▁ ( presently ) ▁ so ▁ just ▁ use ENDCOM # ▁ the ▁ first ▁ and ▁ only ENDCOM INDENT return self . data [ ' CacheNodes ' ] [ 0 ] [ ' Endpoint ' ] [ ' Port ' ] NEW_LINE DEDENT DEDENT def _refresh_data ( self , cache_cluster_data = None ) : NEW_LINE INDENT """ Refresh ▁ data ▁ about ▁ this ▁ cache ▁ cluster """ NEW_LINE if cache_cluster_data is None : NEW_LINE INDENT try : NEW_LINE INDENT response = self . conn . describe_cache_clusters ( CacheClusterId = self . name , ShowCacheNodeInfo = True ) NEW_LINE DEDENT except botocore . exceptions . ClientError as e : NEW_LINE INDENT if e . response [ ' Error ' ] [ ' Code ' ] == ' CacheClusterNotFound ' : NEW_LINE INDENT self . data = None NEW_LINE self . status = ' gone ' NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT self . module . fail_json ( msg = e . message , exception = format_exc ( ) , ** camel_dict_to_snake_dict ( e . response ) ) NEW_LINE DEDENT DEDENT cache_cluster_data = response [ ' CacheClusters ' ] [ 0 ] NEW_LINE DEDENT self . data = cache_cluster_data NEW_LINE self . status = self . data [ ' CacheClusterStatus ' ] NEW_LINE # ▁ The ▁ documentation ▁ for ▁ elasticache ▁ lies ▁ - - ▁ status ▁ on ▁ rebooting ▁ is ▁ set ENDCOM # ▁ to ▁ ' rebooting ▁ cache ▁ cluster ▁ nodes ' ▁ instead ▁ of ▁ ' rebooting ' . ▁ Fix ▁ it ENDCOM # ▁ here ▁ to ▁ make ▁ status ▁ checks ▁ etc . ▁ more ▁ sane . ENDCOM if self . status == ' rebooting ▁ cache ▁ cluster ▁ nodes ' : NEW_LINE INDENT self . status = ' rebooting ' NEW_LINE DEDENT DEDENT def _get_nodes_to_remove ( self ) : NEW_LINE INDENT """ If ▁ there ▁ are ▁ nodes ▁ to ▁ remove , ▁ it ▁ figures ▁ out ▁ which ▁ need ▁ to ▁ be ▁ removed """ NEW_LINE num_nodes_to_remove = self . data [ ' NumCacheNodes ' ] - self . num_nodes NEW_LINE if num_nodes_to_remove <= 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if not self . hard_modify : NEW_LINE INDENT msg = " ' % s ' ▁ requires ▁ removal ▁ of ▁ cache ▁ nodes . ▁ ' hard _ modify ' ▁ must ▁ be ▁ set ▁ to ▁ true ▁ to ▁ proceed . " NEW_LINE self . module . fail_json ( msg = msg % self . name ) NEW_LINE DEDENT cache_node_ids = [ cn [ ' CacheNodeId ' ] for cn in self . data [ ' CacheNodes ' ] ] NEW_LINE return cache_node_ids [ - num_nodes_to_remove : ] NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT """ ▁ elasticache ▁ ansible ▁ module ▁ """ NEW_LINE argument_spec = ec2_argument_spec ( ) NEW_LINE argument_spec . update ( dict ( state = dict ( required = True , choices = [ ' present ' , ' absent ' , ' rebooted ' ] ) , name = dict ( required = True ) , engine = dict ( default = ' memcached ' ) , cache_engine_version = dict ( default = " " ) , node_type = dict ( default = ' cache . t2 . small ' ) , num_nodes = dict ( default = 1 , type = ' int ' ) , # ▁ alias ▁ for ▁ compat ▁ with ▁ the ▁ original ▁ PR ▁ 1950 ENDCOM cache_parameter_group = dict ( default = " " , aliases = [ ' parameter _ group ' ] ) , cache_port = dict ( type = ' int ' ) , cache_subnet_group = dict ( default = " " ) , cache_security_groups = dict ( default = [ ] , type = ' list ' ) , security_group_ids = dict ( default = [ ] , type = ' list ' ) , zone = dict ( ) , wait = dict ( default = True , type = ' bool ' ) , hard_modify = dict ( type = ' bool ' ) ) ) NEW_LINE module = AnsibleModule ( argument_spec = argument_spec , ) NEW_LINE if not HAS_BOTO3 : NEW_LINE INDENT module . fail_json ( msg = ' boto3 ▁ required ▁ for ▁ this ▁ module ' ) NEW_LINE DEDENT region , ec2_url , aws_connect_kwargs = get_aws_connection_info ( module ) NEW_LINE name = module . params [ ' name ' ] NEW_LINE state = module . params [ ' state ' ] NEW_LINE engine = module . params [ ' engine ' ] NEW_LINE cache_engine_version = module . params [ ' cache _ engine _ version ' ] NEW_LINE node_type = module . params [ ' node _ type ' ] NEW_LINE num_nodes = module . params [ ' num _ nodes ' ] NEW_LINE cache_port = module . params [ ' cache _ port ' ] NEW_LINE cache_subnet_group = module . params [ ' cache _ subnet _ group ' ] NEW_LINE cache_security_groups = module . params [ ' cache _ security _ groups ' ] NEW_LINE security_group_ids = module . params [ ' security _ group _ ids ' ] NEW_LINE zone = module . params [ ' zone ' ] NEW_LINE wait = module . params [ ' wait ' ] NEW_LINE hard_modify = module . params [ ' hard _ modify ' ] NEW_LINE cache_parameter_group = module . params [ ' cache _ parameter _ group ' ] NEW_LINE if cache_subnet_group and cache_security_groups : NEW_LINE INDENT module . fail_json ( msg = " Can ' t ▁ specify ▁ both ▁ cache _ subnet _ group ▁ and ▁ cache _ security _ groups " ) NEW_LINE DEDENT if state == ' present ' and not num_nodes : NEW_LINE INDENT module . fail_json ( msg = " ' num _ nodes ' ▁ is ▁ a ▁ required ▁ parameter . ▁ Please ▁ specify ▁ num _ nodes ▁ > ▁ 0" ) NEW_LINE DEDENT elasticache_manager = ElastiCacheManager ( module , name , engine , cache_engine_version , node_type , num_nodes , cache_port , cache_parameter_group , cache_subnet_group , cache_security_groups , security_group_ids , zone , wait , hard_modify , region , ** aws_connect_kwargs ) NEW_LINE if state == ' present ' : NEW_LINE INDENT elasticache_manager . ensure_present ( ) NEW_LINE DEDENT elif state == ' absent ' : NEW_LINE INDENT elasticache_manager . ensure_absent ( ) NEW_LINE DEDENT elif state == ' rebooted ' : NEW_LINE INDENT elasticache_manager . ensure_rebooted ( ) NEW_LINE DEDENT facts_result = dict ( changed = elasticache_manager . changed , elasticache = elasticache_manager . get_info ( ) ) NEW_LINE module . exit_json ( ** facts_result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="40223205/w16b_test-/tree/master/static/Brython3.1.1-20150328-091302/Lib/_socket.py"> """ Implementation ▁ module ▁ for ▁ socket ▁ operations . STRNEWLINE STRNEWLINE See ▁ the ▁ socket ▁ module ▁ for ▁ documentation . """ NEW_LINE AF_APPLETALK = 16 NEW_LINE AF_DECnet = 12 NEW_LINE AF_INET = 2 NEW_LINE AF_INET6 = 23 NEW_LINE AF_IPX = 6 NEW_LINE AF_IRDA = 26 NEW_LINE AF_SNA = 11 NEW_LINE AF_UNSPEC = 0 NEW_LINE AI_ADDRCONFIG = 1024 NEW_LINE AI_ALL = 256 NEW_LINE AI_CANONNAME = 2 NEW_LINE AI_NUMERICHOST = 4 NEW_LINE AI_NUMERICSERV = 8 NEW_LINE AI_PASSIVE = 1 NEW_LINE AI_V4MAPPED = 2048 NEW_LINE CAPI = ' < capsule ▁ object ▁ " _ socket . CAPI " ▁ at ▁ 0x00BC4F38 > ' NEW_LINE EAI_AGAIN = 11002 NEW_LINE EAI_BADFLAGS = 10022 NEW_LINE EAI_FAIL = 11003 NEW_LINE EAI_FAMILY = 10047 NEW_LINE EAI_MEMORY = 8 NEW_LINE EAI_NODATA = 11001 NEW_LINE EAI_NONAME = 11001 NEW_LINE EAI_SERVICE = 10109 NEW_LINE EAI_SOCKTYPE = 10044 NEW_LINE INADDR_ALLHOSTS_GROUP = - 536870911 NEW_LINE INADDR_ANY = 0 NEW_LINE INADDR_BROADCAST = - 1 NEW_LINE INADDR_LOOPBACK = 2130706433 NEW_LINE INADDR_MAX_LOCAL_GROUP = - 536870657 NEW_LINE INADDR_NONE = - 1 NEW_LINE INADDR_UNSPEC_GROUP = - 536870912 NEW_LINE IPPORT_RESERVED = 1024 NEW_LINE IPPORT_USERRESERVED = 5000 NEW_LINE IPPROTO_ICMP = 1 NEW_LINE IPPROTO_IP = 0 NEW_LINE IPPROTO_RAW = 255 NEW_LINE IPPROTO_TCP = 6 NEW_LINE IPPROTO_UDP = 17 NEW_LINE IPV6_CHECKSUM = 26 NEW_LINE IPV6_DONTFRAG = 14 NEW_LINE IPV6_HOPLIMIT = 21 NEW_LINE IPV6_HOPOPTS = 1 NEW_LINE IPV6_JOIN_GROUP = 12 NEW_LINE IPV6_LEAVE_GROUP = 13 NEW_LINE IPV6_MULTICAST_HOPS = 10 NEW_LINE IPV6_MULTICAST_IF = 9 NEW_LINE IPV6_MULTICAST_LOOP = 11 NEW_LINE IPV6_PKTINFO = 19 NEW_LINE IPV6_RECVRTHDR = 38 NEW_LINE IPV6_RECVTCLASS = 40 NEW_LINE IPV6_RTHDR = 32 NEW_LINE IPV6_TCLASS = 39 NEW_LINE IPV6_UNICAST_HOPS = 4 NEW_LINE IPV6_V6ONLY = 27 NEW_LINE IP_ADD_MEMBERSHIP = 12 NEW_LINE IP_DROP_MEMBERSHIP = 13 NEW_LINE IP_HDRINCL = 2 NEW_LINE IP_MULTICAST_IF = 9 NEW_LINE IP_MULTICAST_LOOP = 11 NEW_LINE IP_MULTICAST_TTL = 10 NEW_LINE IP_OPTIONS = 1 NEW_LINE IP_RECVDSTADDR = 25 NEW_LINE IP_TOS = 3 NEW_LINE IP_TTL = 4 NEW_LINE MSG_BCAST = 1024 NEW_LINE MSG_CTRUNC = 512 NEW_LINE MSG_DONTROUTE = 4 NEW_LINE MSG_MCAST = 2048 NEW_LINE MSG_OOB = 1 NEW_LINE MSG_PEEK = 2 NEW_LINE MSG_TRUNC = 256 NEW_LINE NI_DGRAM = 16 NEW_LINE NI_MAXHOST = 1025 NEW_LINE NI_MAXSERV = 32 NEW_LINE NI_NAMEREQD = 4 NEW_LINE NI_NOFQDN = 1 NEW_LINE NI_NUMERICHOST = 2 NEW_LINE NI_NUMERICSERV = 8 NEW_LINE RCVALL_MAX = 3 NEW_LINE RCVALL_OFF = 0 NEW_LINE RCVALL_ON = 1 NEW_LINE RCVALL_SOCKETLEVELONLY = 2 NEW_LINE SHUT_RD = 0 NEW_LINE SHUT_RDWR = 2 NEW_LINE SHUT_WR = 1 NEW_LINE SIO_KEEPALIVE_VALS = 2550136836 NEW_LINE SIO_RCVALL = 2550136833 NEW_LINE SOCK_DGRAM = 2 NEW_LINE SOCK_RAW = 3 NEW_LINE SOCK_RDM = 4 NEW_LINE SOCK_SEQPACKET = 5 NEW_LINE SOCK_STREAM = 1 NEW_LINE SOL_IP = 0 NEW_LINE SOL_SOCKET = 65535 NEW_LINE SOL_TCP = 6 NEW_LINE SOL_UDP = 17 NEW_LINE SOMAXCONN = 2147483647 NEW_LINE SO_ACCEPTCONN = 2 NEW_LINE SO_BROADCAST = 32 NEW_LINE SO_DEBUG = 1 NEW_LINE SO_DONTROUTE = 16 NEW_LINE SO_ERROR = 4103 NEW_LINE SO_EXCLUSIVEADDRUSE = - 5 NEW_LINE SO_KEEPALIVE = 8 NEW_LINE SO_LINGER = 128 NEW_LINE SO_OOBINLINE = 256 NEW_LINE SO_RCVBUF = 4098 NEW_LINE SO_RCVLOWAT = 4100 NEW_LINE SO_RCVTIMEO = 4102 NEW_LINE SO_REUSEADDR = 4 NEW_LINE SO_SNDBUF = 4097 NEW_LINE SO_SNDLOWAT = 4099 NEW_LINE SO_SNDTIMEO = 4101 NEW_LINE SO_TYPE = 4104 NEW_LINE SO_USELOOPBACK = 64 NEW_LINE class SocketType : NEW_LINE INDENT pass NEW_LINE DEDENT TCP_MAXSEG = 4 NEW_LINE TCP_NODELAY = 1 NEW_LINE __loader__ = ' < _ frozen _ importlib . ExtensionFileLoader ▁ object ▁ at ▁ 0x00CA2D90 > ' NEW_LINE def dup ( * args , ** kw ) : NEW_LINE INDENT """ dup ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Duplicate ▁ an ▁ integer ▁ socket ▁ file ▁ descriptor . ▁ This ▁ is ▁ like ▁ os . dup ( ) , ▁ but ▁ for STRNEWLINE ▁ sockets ; ▁ on ▁ some ▁ platforms ▁ os . dup ( ) ▁ won ' t ▁ work ▁ for ▁ socket ▁ file ▁ descriptors . """ NEW_LINE pass NEW_LINE DEDENT class error : NEW_LINE INDENT pass NEW_LINE DEDENT class gaierror : NEW_LINE INDENT pass NEW_LINE DEDENT def getaddrinfo ( * args , ** kw ) : NEW_LINE INDENT """ getaddrinfo ( host , ▁ port ▁ [ , ▁ family , ▁ socktype , ▁ proto , ▁ flags ] ) ▁ - > ▁ list ▁ of ▁ ( family , ▁ socktype , ▁ proto , ▁ canonname , ▁ sockaddr ) STRNEWLINE ▁ STRNEWLINE ▁ Resolve ▁ host ▁ and ▁ port ▁ into ▁ addrinfo ▁ struct . """ NEW_LINE pass NEW_LINE DEDENT def getdefaulttimeout ( * args , ** kw ) : NEW_LINE INDENT """ getdefaulttimeout ( ) ▁ - > ▁ timeout ▁ STRNEWLINE ▁ Returns ▁ the ▁ default ▁ timeout ▁ in ▁ seconds ▁ ( float ) ▁ for ▁ new ▁ socket ▁ objects . STRNEWLINE ▁ A ▁ value ▁ of ▁ None ▁ indicates ▁ that ▁ new ▁ socket ▁ objects ▁ have ▁ no ▁ timeout . STRNEWLINE ▁ When ▁ the ▁ socket ▁ module ▁ is ▁ first ▁ imported , ▁ the ▁ default ▁ is ▁ None . """ NEW_LINE pass NEW_LINE DEDENT def gethostbyaddr ( * args , ** kw ) : NEW_LINE INDENT """ gethostbyaddr ( host ) ▁ - > ▁ ( name , ▁ aliaslist , ▁ addresslist ) ▁ STRNEWLINE ▁ Return ▁ the ▁ true ▁ host ▁ name , ▁ a ▁ list ▁ of ▁ aliases , ▁ and ▁ a ▁ list ▁ of ▁ IP ▁ addresses , STRNEWLINE ▁ for ▁ a ▁ host . ▁ The ▁ host ▁ argument ▁ is ▁ a ▁ string ▁ giving ▁ a ▁ host ▁ name ▁ or ▁ IP ▁ number . """ NEW_LINE pass NEW_LINE DEDENT def gethostbyname ( * args , ** kw ) : NEW_LINE INDENT """ gethostbyname ( host ) ▁ - > ▁ address ▁ STRNEWLINE ▁ Return ▁ the ▁ IP ▁ address ▁ ( a ▁ string ▁ of ▁ the ▁ form ▁ ' 255.255.255.255 ' ) ▁ for ▁ a ▁ host . """ NEW_LINE pass NEW_LINE DEDENT def gethostbyname_ex ( * args , ** kw ) : NEW_LINE INDENT """ gethostbyname _ ex ( host ) ▁ - > ▁ ( name , ▁ aliaslist , ▁ addresslist ) ▁ STRNEWLINE ▁ Return ▁ the ▁ true ▁ host ▁ name , ▁ a ▁ list ▁ of ▁ aliases , ▁ and ▁ a ▁ list ▁ of ▁ IP ▁ addresses , STRNEWLINE ▁ for ▁ a ▁ host . ▁ The ▁ host ▁ argument ▁ is ▁ a ▁ string ▁ giving ▁ a ▁ host ▁ name ▁ or ▁ IP ▁ number . """ NEW_LINE pass NEW_LINE DEDENT def gethostname ( * args , ** kw ) : NEW_LINE INDENT """ gethostname ( ) ▁ - > ▁ string ▁ STRNEWLINE ▁ Return ▁ the ▁ current ▁ host ▁ name . """ NEW_LINE pass NEW_LINE DEDENT def getnameinfo ( * args , ** kw ) : NEW_LINE INDENT """ getnameinfo ( sockaddr , ▁ flags ) ▁ - - > ▁ ( host , ▁ port ) ▁ STRNEWLINE ▁ Get ▁ host ▁ and ▁ port ▁ for ▁ a ▁ sockaddr . """ NEW_LINE pass NEW_LINE DEDENT def getprotobyname ( * args , ** kw ) : NEW_LINE INDENT """ getprotobyname ( name ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Return ▁ the ▁ protocol ▁ number ▁ for ▁ the ▁ named ▁ protocol . ▁ ( Rarely ▁ used . ) """ NEW_LINE pass NEW_LINE DEDENT def getservbyname ( * args , ** kw ) : NEW_LINE INDENT """ getservbyname ( servicename [ , ▁ protocolname ] ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Return ▁ a ▁ port ▁ number ▁ from ▁ a ▁ service ▁ name ▁ and ▁ protocol ▁ name . STRNEWLINE ▁ The ▁ optional ▁ protocol ▁ name , ▁ if ▁ given , ▁ should ▁ be ▁ ' tcp ' ▁ or ▁ ' udp ' , STRNEWLINE ▁ otherwise ▁ any ▁ protocol ▁ will ▁ match . """ NEW_LINE pass NEW_LINE DEDENT def getservbyport ( * args , ** kw ) : NEW_LINE INDENT """ getservbyport ( port [ , ▁ protocolname ] ) ▁ - > ▁ string ▁ STRNEWLINE ▁ Return ▁ the ▁ service ▁ name ▁ from ▁ a ▁ port ▁ number ▁ and ▁ protocol ▁ name . STRNEWLINE ▁ The ▁ optional ▁ protocol ▁ name , ▁ if ▁ given , ▁ should ▁ be ▁ ' tcp ' ▁ or ▁ ' udp ' , STRNEWLINE ▁ otherwise ▁ any ▁ protocol ▁ will ▁ match . """ NEW_LINE pass NEW_LINE DEDENT has_ipv6 = True NEW_LINE class herror : NEW_LINE INDENT pass NEW_LINE DEDENT def htonl ( * args , ** kw ) : NEW_LINE INDENT """ htonl ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 32 - bit ▁ integer ▁ from ▁ host ▁ to ▁ network ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def htons ( * args , ** kw ) : NEW_LINE INDENT """ htons ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 16 - bit ▁ integer ▁ from ▁ host ▁ to ▁ network ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def inet_aton ( * args , ** kw ) : NEW_LINE INDENT """ inet _ aton ( string ) ▁ - > ▁ bytes ▁ giving ▁ packed ▁ 32 - bit ▁ IP ▁ representation ▁ STRNEWLINE ▁ Convert ▁ an ▁ IP ▁ address ▁ in ▁ string ▁ format ▁ ( 123.45.67.89 ) ▁ to ▁ the ▁ 32 - bit ▁ packed STRNEWLINE ▁ binary ▁ format ▁ used ▁ in ▁ low - level ▁ network ▁ functions . """ NEW_LINE pass NEW_LINE DEDENT def inet_ntoa ( * args , ** kw ) : NEW_LINE INDENT """ inet _ ntoa ( packed _ ip ) ▁ - > ▁ ip _ address _ string ▁ STRNEWLINE ▁ Convert ▁ an ▁ IP ▁ address ▁ from ▁ 32 - bit ▁ packed ▁ binary ▁ format ▁ to ▁ string ▁ format """ NEW_LINE pass NEW_LINE DEDENT def ntohl ( * args , ** kw ) : NEW_LINE INDENT """ ntohl ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 32 - bit ▁ integer ▁ from ▁ network ▁ to ▁ host ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def ntohs ( * args , ** kw ) : NEW_LINE INDENT """ ntohs ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 16 - bit ▁ integer ▁ from ▁ network ▁ to ▁ host ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def setdefaulttimeout ( * args , ** kw ) : NEW_LINE INDENT """ setdefaulttimeout ( timeout ) ▁ STRNEWLINE ▁ Set ▁ the ▁ default ▁ timeout ▁ in ▁ seconds ▁ ( float ) ▁ for ▁ new ▁ socket ▁ objects . STRNEWLINE ▁ A ▁ value ▁ of ▁ None ▁ indicates ▁ that ▁ new ▁ socket ▁ objects ▁ have ▁ no ▁ timeout . STRNEWLINE ▁ When ▁ the ▁ socket ▁ module ▁ is ▁ first ▁ imported , ▁ the ▁ default ▁ is ▁ None . """ NEW_LINE pass NEW_LINE DEDENT class socket : NEW_LINE INDENT def __init__ ( self , * args , ** kw ) : NEW_LINE INDENT pass NEW_LINE DEDENT def bind ( self , * args , ** kw ) : NEW_LINE INDENT pass NEW_LINE DEDENT def close ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT class timeout : NEW_LINE INDENT pass NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="tommy-u/chaco/tree/master/chaco/base_plot_container.py"> """ ▁ Defines ▁ the ▁ BasePlotContainer ▁ class . STRNEWLINE """ NEW_LINE import warnings NEW_LINE # ▁ Enthought ▁ library ▁ imports ENDCOM from enable . api import Container NEW_LINE from traits . api import Bool , Instance , Property , Str , Tuple NEW_LINE # ▁ Local , ▁ relative ▁ imports ENDCOM from plot_component import DEFAULT_DRAWING_ORDER , PlotComponent NEW_LINE class BasePlotContainer ( Container ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ container ▁ for ▁ PlotComponents ▁ that ▁ conforms ▁ to ▁ being ▁ laid ▁ out ▁ by STRNEWLINE ▁ PlotFrames . ▁ Serves ▁ as ▁ the ▁ base ▁ class ▁ for ▁ other ▁ PlotContainers . STRNEWLINE STRNEWLINE ▁ PlotContainers ▁ define ▁ a ▁ layout , ▁ i . e . , ▁ a ▁ spatial ▁ relationship ▁ between STRNEWLINE ▁ their ▁ contained ▁ components . ▁ ( BasePlotContainer ▁ doesn ' t ▁ define ▁ one , STRNEWLINE ▁ but ▁ its ▁ various ▁ subclasses ▁ do . ) STRNEWLINE STRNEWLINE ▁ BasePlotContainer ▁ is ▁ a ▁ subclass ▁ of ▁ Enable ▁ Container , ▁ so ▁ it ▁ is ▁ possible ▁ to STRNEWLINE ▁ insert ▁ Enable - level ▁ components ▁ into ▁ it . ▁ However , ▁ because ▁ Enable STRNEWLINE ▁ components ▁ don ' t ▁ have ▁ the ▁ correct ▁ interfaces ▁ to ▁ participate ▁ in ▁ layout , STRNEWLINE ▁ the ▁ visual ▁ results ▁ will ▁ probably ▁ be ▁ incorrect . STRNEWLINE ▁ """ NEW_LINE # ▁ Redefine ▁ the ▁ container ▁ layers ▁ to ▁ name ▁ the ▁ main ▁ layer ▁ as ▁ " plot " ▁ instead ENDCOM # ▁ of ▁ the ▁ Enable ▁ default ▁ of ▁ " mainlayer " ENDCOM container_under_layers = Tuple ( " background " , " image " , " underlay " , " plot " ) NEW_LINE # ▁ Duplicate ▁ trait ▁ declarations ▁ from ▁ PlotComponent . ▁ We ▁ don ' t ▁ subclass ENDCOM # ▁ PlotComponent ▁ to ▁ avoid ▁ MRO ▁ complications ▁ with ▁ trait ▁ handlers ▁ and ▁ property ENDCOM # ▁ getters / setters . ENDCOM draw_order = Instance ( list , args = ( DEFAULT_DRAWING_ORDER , ) ) NEW_LINE draw_layer = Str ( " plot " ) NEW_LINE # ▁ Deprecated ▁ traits ENDCOM # ▁ Deprecated ▁ flag ▁ to ▁ indicate ▁ that ▁ a ▁ component ▁ needed ▁ to ▁ do ▁ old - style ENDCOM # ▁ drawing . ▁ Unused ▁ by ▁ any ▁ recent ▁ Chaco ▁ component . ENDCOM use_draw_order = Bool ( True ) NEW_LINE # ▁ Deprecated ▁ property ▁ for ▁ accessing ▁ the ▁ components ▁ in ▁ the ▁ container . ENDCOM plot_components = Property NEW_LINE def _get_plot_components ( self ) : NEW_LINE INDENT warnings . warn ( " Use ▁ of ▁ plot _ components ▁ attribute ▁ deprecated . " " Use ▁ components ▁ attribute ▁ instead . " , DeprecationWarning ) NEW_LINE return self . _components NEW_LINE DEDENT def _set_plot_components ( self , new ) : NEW_LINE INDENT warnings . warn ( " Use ▁ of ▁ plot _ components ▁ attribute ▁ deprecated . " " Use ▁ components ▁ attribute ▁ instead . " , DeprecationWarning ) NEW_LINE self . _components = new NEW_LINE DEDENT def _use_draw_order_changed ( self , old , new ) : NEW_LINE INDENT """ ▁ Handler ▁ to ▁ catch ▁ the ▁ case ▁ when ▁ someone ▁ is ▁ trying ▁ to ▁ use ▁ the STRNEWLINE ▁ old - style ▁ drawing ▁ mechanism , ▁ which ▁ is ▁ now ▁ unsupported . STRNEWLINE ▁ """ NEW_LINE if new == False : NEW_LINE INDENT raise RuntimeError ( " The ▁ old - style ▁ drawing ▁ mechanism ▁ is ▁ no ▁ longer ▁ " " supported ▁ in ▁ Chaco . " ) NEW_LINE # ▁ EOF ENDCOM DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="roandelyf/iTerm2/tree/master/tests/esctest/tests/el.py"> from esc import NUL , blank NEW_LINE import escargs NEW_LINE import esccmd NEW_LINE import escio NEW_LINE from esctypes import Point , Rect NEW_LINE from escutil import AssertEQ , AssertScreenCharsInRectEqual , GetCursorPosition , knownBug NEW_LINE class ELTests ( object ) : NEW_LINE INDENT def prepare ( self ) : NEW_LINE INDENT """ Initializes ▁ the ▁ screen ▁ to ▁ abcdefghij ▁ on ▁ the ▁ first ▁ line ▁ with ▁ the ▁ cursor STRNEWLINE ▁ on ▁ the ▁ ' e ' . """ NEW_LINE esccmd . CUP ( Point ( 1 , 1 ) ) NEW_LINE escio . Write ( " abcdefghij " ) NEW_LINE esccmd . CUP ( Point ( 5 , 1 ) ) NEW_LINE DEDENT def test_EL_Default ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ to ▁ right ▁ of ▁ cursor . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ " abcd " + 6 * NUL ] ) NEW_LINE DEDENT def test_EL_0 ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ to ▁ right ▁ of ▁ cursor . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( 0 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ " abcd " + 6 * NUL ] ) NEW_LINE DEDENT def test_EL_1 ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ to ▁ left ▁ of ▁ cursor . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( 1 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ 5 * blank ( ) + " fghij " ] ) NEW_LINE DEDENT def test_EL_2 ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ whole ▁ line . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ 10 * NUL ] ) NEW_LINE DEDENT def test_EL_IgnoresScrollRegion ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ whole ▁ line . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . DECSET ( esccmd . DECLRMM ) NEW_LINE esccmd . DECSLRM ( 2 , 4 ) NEW_LINE esccmd . CUP ( Point ( 5 , 1 ) ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE esccmd . DECRESET ( esccmd . DECLRMM ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ 10 * NUL ] ) NEW_LINE DEDENT def test_EL_doesNotRespectDECProtection ( self ) : NEW_LINE INDENT """ EL ▁ respects ▁ DECSCA . """ NEW_LINE escio . Write ( " a " ) NEW_LINE escio . Write ( " b " ) NEW_LINE esccmd . DECSCA ( 1 ) NEW_LINE escio . Write ( " c " ) NEW_LINE esccmd . DECSCA ( 0 ) NEW_LINE esccmd . CUP ( Point ( 1 , 1 ) ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 3 , 1 ) , [ NUL * 3 ] ) NEW_LINE DEDENT @ knownBug ( terminal = " iTerm2" , reason = " Protection ▁ not ▁ implemented . " ) NEW_LINE def test_EL_respectsISOProtection ( self ) : NEW_LINE INDENT """ EL ▁ respects ▁ SPA / EPA . """ NEW_LINE escio . Write ( " a " ) NEW_LINE escio . Write ( " b " ) NEW_LINE esccmd . SPA ( ) NEW_LINE escio . Write ( " c " ) NEW_LINE esccmd . EPA ( ) NEW_LINE esccmd . CUP ( Point ( 1 , 1 ) ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 3 , 1 ) , [ blank ( ) * 2 + " c " ] ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="Taketrung/betfair.py/tree/master/tests/fixtures.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM import pytest NEW_LINE import os NEW_LINE from betfair import betfair NEW_LINE from tests . utils import response_fixture_factory NEW_LINE @ pytest . fixture NEW_LINE def client ( ) : NEW_LINE INDENT return betfair . Betfair ( app_key = ' test ' , cert_file = ' path / to / cert ' ) NEW_LINE DEDENT @ pytest . fixture NEW_LINE def logged_in_client ( client ) : NEW_LINE INDENT client = betfair . Betfair ( app_key = ' test ' , cert_file = ' path / to / cert ' ) NEW_LINE client . session_token = ' secret ' NEW_LINE return client NEW_LINE DEDENT login_success = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' certlogin ' ) , { ' loginStatus ' : ' SUCCESS ' , ' sessionToken ' : ' secret ' , } , ) NEW_LINE login_failure = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' certlogin ' ) , { ' loginStatus ' : ' INVALID _ USERNAME _ OR _ PASSWORD ' } , ) NEW_LINE login_bad_code = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' certlogin ' ) , status = 422 , ) NEW_LINE keepalive_success = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' keepAlive ' ) , { ' status ' : ' SUCCESS ' } , ) NEW_LINE keepalive_failure = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' keepAlive ' ) , { ' status ' : ' FAIL ' , ' error ' : ' NO _ SESSION ' , } , ) NEW_LINE logout_success = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' logout ' ) , { ' status ' : ' SUCCESS ' } , ) NEW_LINE logout_failure = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' logout ' ) , { ' status ' : ' FAIL ' , ' error ' : ' NO _ SESSION ' , } , ) NEW_LINE login_required_methods = [ ' keep _ alive ' , ' logout ' , ' list _ event _ types ' , ' list _ competitions ' , ' list _ time _ ranges ' , ' list _ events ' , ' list _ market _ types ' , ' list _ countries ' , ' list _ venues ' , ' list _ market _ catalogue ' , ' list _ market _ book ' , ' list _ market _ profit _ and _ loss ' , ' list _ current _ orders ' , ' list _ cleared _ orders ' , ' place _ orders ' , ' cancel _ orders ' , ' replace _ orders ' , ' update _ orders ' , ] NEW_LINE </DOCUMENT>
<DOCUMENT_ID="2014cdbg14/2014cdbg14/tree/master/wsgi/static/Brython2.1.0-20140419-113919/Lib/collections/abc.py"> # ▁ Copyright ▁ 2007 ▁ Google , ▁ Inc . ▁ All ▁ Rights ▁ Reserved . ENDCOM # ▁ Licensed ▁ to ▁ PSF ▁ under ▁ a ▁ Contributor ▁ Agreement . ENDCOM """ Abstract ▁ Base ▁ Classes ▁ ( ABCs ) ▁ for ▁ collections , ▁ according ▁ to ▁ PEP ▁ 3119 . STRNEWLINE STRNEWLINE Unit ▁ tests ▁ are ▁ in ▁ test _ collections . STRNEWLINE """ NEW_LINE from abc import ABCMeta , abstractmethod NEW_LINE import sys NEW_LINE __all__ = [ " Hashable " , " Iterable " , " Iterator " , " Sized " , " Container " , " Callable " , " Set " , " MutableSet " , " Mapping " , " MutableMapping " , " MappingView " , " KeysView " , " ItemsView " , " ValuesView " , " Sequence " , " MutableSequence " , " ByteString " , ] NEW_LINE # ▁ Private ▁ list ▁ of ▁ types ▁ that ▁ we ▁ want ▁ to ▁ register ▁ with ▁ the ▁ various ▁ ABCs ENDCOM # ▁ so ▁ that ▁ they ▁ will ▁ pass ▁ tests ▁ like : ENDCOM # ▁ it ▁ = ▁ iter ( somebytearray ) ENDCOM # ▁ assert ▁ isinstance ( it , ▁ Iterable ) ENDCOM # ▁ Note : ▁ in ▁ other ▁ implementations , ▁ these ▁ types ▁ many ▁ not ▁ be ▁ distinct ENDCOM # ▁ and ▁ they ▁ make ▁ have ▁ their ▁ own ▁ implementation ▁ specific ▁ types ▁ that ENDCOM # ▁ are ▁ not ▁ included ▁ on ▁ this ▁ list . ENDCOM bytes_iterator = type ( iter ( b ' ' ) ) NEW_LINE bytearray_iterator = type ( iter ( bytearray ( ) ) ) NEW_LINE # callable _ iterator ▁ = ▁ ? ? ? ENDCOM dict_keyiterator = type ( iter ( { } . keys ( ) ) ) NEW_LINE dict_valueiterator = type ( iter ( { } . values ( ) ) ) NEW_LINE dict_itemiterator = type ( iter ( { } . items ( ) ) ) NEW_LINE list_iterator = type ( iter ( [ ] ) ) NEW_LINE list_reverseiterator = type ( iter ( reversed ( [ ] ) ) ) NEW_LINE range_iterator = type ( iter ( range ( 0 ) ) ) NEW_LINE set_iterator = type ( iter ( set ( ) ) ) NEW_LINE str_iterator = type ( iter ( " " ) ) NEW_LINE tuple_iterator = type ( iter ( ( ) ) ) NEW_LINE zip_iterator = type ( iter ( zip ( ) ) ) NEW_LINE # # ▁ views ▁ # # ENDCOM dict_keys = type ( { } . keys ( ) ) NEW_LINE dict_values = type ( { } . values ( ) ) NEW_LINE dict_items = type ( { } . items ( ) ) NEW_LINE # # ▁ misc ▁ # # ENDCOM mappingproxy = type ( type . __dict__ ) NEW_LINE # # # ▁ ONE - TRICK ▁ PONIES ▁ # # # ENDCOM class Hashable ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __hash__ ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Hashable : NEW_LINE INDENT for B in C . __mro__ : NEW_LINE INDENT if " _ _ hash _ _ " in B . __dict__ : NEW_LINE INDENT if B . __dict__ [ " _ _ hash _ _ " ] : NEW_LINE INDENT return True NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Iterable ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __iter__ ( self ) : NEW_LINE INDENT while False : NEW_LINE INDENT yield None NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Iterable : NEW_LINE INDENT if any ( " _ _ iter _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Iterator ( Iterable ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __next__ ( self ) : NEW_LINE INDENT raise StopIteration NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return self NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Iterator : NEW_LINE INDENT if ( any ( " _ _ next _ _ " in B . __dict__ for B in C . __mro__ ) and any ( " _ _ iter _ _ " in B . __dict__ for B in C . __mro__ ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT Iterator . register ( bytes_iterator ) NEW_LINE Iterator . register ( bytearray_iterator ) NEW_LINE # Iterator . register ( callable _ iterator ) ENDCOM Iterator . register ( dict_keyiterator ) NEW_LINE Iterator . register ( dict_valueiterator ) NEW_LINE Iterator . register ( dict_itemiterator ) NEW_LINE Iterator . register ( list_iterator ) NEW_LINE Iterator . register ( list_reverseiterator ) NEW_LINE Iterator . register ( range_iterator ) NEW_LINE Iterator . register ( set_iterator ) NEW_LINE Iterator . register ( str_iterator ) NEW_LINE Iterator . register ( tuple_iterator ) NEW_LINE Iterator . register ( zip_iterator ) NEW_LINE class Sized ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __len__ ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Sized : NEW_LINE INDENT if any ( " _ _ len _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Container ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __contains__ ( self , x ) : NEW_LINE INDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Container : NEW_LINE INDENT if any ( " _ _ contains _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Callable ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __call__ ( self , * args , ** kwds ) : NEW_LINE INDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Callable : NEW_LINE INDENT if any ( " _ _ call _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE # # # ▁ SETS ▁ # # # ENDCOM DEDENT DEDENT class Set ( Sized , Iterable , Container ) : NEW_LINE INDENT """ A ▁ set ▁ is ▁ a ▁ finite , ▁ iterable ▁ container . STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ provides ▁ concrete ▁ generic ▁ implementations ▁ of ▁ all STRNEWLINE ▁ methods ▁ except ▁ for ▁ _ _ contains _ _ , ▁ _ _ iter _ _ ▁ and ▁ _ _ len _ _ . STRNEWLINE STRNEWLINE ▁ To ▁ override ▁ the ▁ comparisons ▁ ( presumably ▁ for ▁ speed , ▁ as ▁ the STRNEWLINE ▁ semantics ▁ are ▁ fixed ) , ▁ all ▁ you ▁ have ▁ to ▁ do ▁ is ▁ redefine ▁ _ _ le _ _ ▁ and STRNEWLINE ▁ then ▁ the ▁ other ▁ operations ▁ will ▁ automatically ▁ follow ▁ suit . STRNEWLINE ▁ """ NEW_LINE __slots__ = ( ) NEW_LINE def __le__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT if len ( self ) > len ( other ) : NEW_LINE INDENT return False NEW_LINE DEDENT for elem in self : NEW_LINE INDENT if elem not in other : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return len ( self ) < len ( other ) and self . __le__ ( other ) NEW_LINE DEDENT def __gt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return other < self NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return other <= self NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return len ( self ) == len ( other ) and self . __le__ ( other ) NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return not ( self == other ) NEW_LINE DEDENT @ classmethod NEW_LINE def _from_iterable ( cls , it ) : NEW_LINE INDENT ''' Construct ▁ an ▁ instance ▁ of ▁ the ▁ class ▁ from ▁ any ▁ iterable ▁ input . STRNEWLINE STRNEWLINE ▁ Must ▁ override ▁ this ▁ method ▁ if ▁ the ▁ class ▁ constructor ▁ signature STRNEWLINE ▁ does ▁ not ▁ accept ▁ an ▁ iterable ▁ for ▁ an ▁ input . STRNEWLINE ▁ ''' NEW_LINE return cls ( it ) NEW_LINE DEDENT def __and__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . _from_iterable ( value for value in other if value in self ) NEW_LINE DEDENT def isdisjoint ( self , other ) : NEW_LINE INDENT for value in other : NEW_LINE INDENT if value in self : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def __or__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT chain = ( e for s in ( self , other ) for e in s ) NEW_LINE return self . _from_iterable ( chain ) NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT other = self . _from_iterable ( other ) NEW_LINE DEDENT return self . _from_iterable ( value for value in self if value not in other ) NEW_LINE DEDENT def __xor__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT other = self . _from_iterable ( other ) NEW_LINE DEDENT return ( self - other ) | ( other - self ) NEW_LINE DEDENT def _hash ( self ) : NEW_LINE INDENT """ Compute ▁ the ▁ hash ▁ value ▁ of ▁ a ▁ set . STRNEWLINE STRNEWLINE ▁ Note ▁ that ▁ we ▁ don ' t ▁ define ▁ _ _ hash _ _ : ▁ not ▁ all ▁ sets ▁ are ▁ hashable . STRNEWLINE ▁ But ▁ if ▁ you ▁ define ▁ a ▁ hashable ▁ set ▁ type , ▁ its ▁ _ _ hash _ _ ▁ should STRNEWLINE ▁ call ▁ this ▁ function . STRNEWLINE STRNEWLINE ▁ This ▁ must ▁ be ▁ compatible ▁ _ _ eq _ _ . STRNEWLINE STRNEWLINE ▁ All ▁ sets ▁ ought ▁ to ▁ compare ▁ equal ▁ if ▁ they ▁ contain ▁ the ▁ same STRNEWLINE ▁ elements , ▁ regardless ▁ of ▁ how ▁ they ▁ are ▁ implemented , ▁ and STRNEWLINE ▁ regardless ▁ of ▁ the ▁ order ▁ of ▁ the ▁ elements ; ▁ so ▁ there ' s ▁ not ▁ much STRNEWLINE ▁ freedom ▁ for ▁ _ _ eq _ _ ▁ or ▁ _ _ hash _ _ . ▁ We ▁ match ▁ the ▁ algorithm ▁ used STRNEWLINE ▁ by ▁ the ▁ built - in ▁ frozenset ▁ type . STRNEWLINE ▁ """ NEW_LINE MAX = sys . maxsize NEW_LINE MASK = 2 * MAX + 1 NEW_LINE n = len ( self ) NEW_LINE h = 1927868237 * ( n + 1 ) NEW_LINE h &= MASK NEW_LINE for x in self : NEW_LINE INDENT hx = hash ( x ) NEW_LINE h ^= ( hx ^ ( hx << 16 ) ^ 89869747 ) * 3644798167 NEW_LINE h &= MASK NEW_LINE DEDENT h = h * 69069 + 907133923 NEW_LINE h &= MASK NEW_LINE if h > MAX : NEW_LINE INDENT h -= MASK + 1 NEW_LINE DEDENT if h == - 1 : NEW_LINE INDENT h = 590923713 NEW_LINE DEDENT return h NEW_LINE DEDENT DEDENT Set . register ( frozenset ) NEW_LINE class MutableSet ( Set ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def add ( self , value ) : NEW_LINE INDENT """ Add ▁ an ▁ element . """ NEW_LINE raise NotImplementedError NEW_LINE DEDENT @ abstractmethod NEW_LINE def discard ( self , value ) : NEW_LINE INDENT """ Remove ▁ an ▁ element . ▁ Do ▁ not ▁ raise ▁ an ▁ exception ▁ if ▁ absent . """ NEW_LINE raise NotImplementedError NEW_LINE DEDENT def remove ( self , value ) : NEW_LINE INDENT """ Remove ▁ an ▁ element . ▁ If ▁ not ▁ a ▁ member , ▁ raise ▁ a ▁ KeyError . """ NEW_LINE if value not in self : NEW_LINE INDENT raise KeyError ( value ) NEW_LINE DEDENT self . discard ( value ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT """ Return ▁ the ▁ popped ▁ value . ▁ Raise ▁ KeyError ▁ if ▁ empty . """ NEW_LINE it = iter ( self ) NEW_LINE try : NEW_LINE INDENT value = next ( it ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT self . discard ( value ) NEW_LINE return value NEW_LINE DEDENT def clear ( self ) : NEW_LINE INDENT """ This ▁ is ▁ slow ▁ ( creates ▁ N ▁ new ▁ iterators ! ) ▁ but ▁ effective . """ NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT self . pop ( ) NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def __ior__ ( self , it ) : NEW_LINE INDENT for value in it : NEW_LINE INDENT self . add ( value ) NEW_LINE DEDENT return self NEW_LINE DEDENT def __iand__ ( self , it ) : NEW_LINE INDENT for value in ( self - it ) : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT return self NEW_LINE DEDENT def __ixor__ ( self , it ) : NEW_LINE INDENT if it is self : NEW_LINE INDENT self . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT if not isinstance ( it , Set ) : NEW_LINE INDENT it = self . _from_iterable ( it ) NEW_LINE DEDENT for value in it : NEW_LINE INDENT if value in self : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT else : NEW_LINE INDENT self . add ( value ) NEW_LINE DEDENT DEDENT DEDENT return self NEW_LINE DEDENT def __isub__ ( self , it ) : NEW_LINE INDENT if it is self : NEW_LINE INDENT self . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for value in it : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT DEDENT return self NEW_LINE DEDENT DEDENT MutableSet . register ( set ) NEW_LINE # # # ▁ MAPPINGS ▁ # # # ENDCOM class Mapping ( Sized , Iterable , Container ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __getitem__ ( self , key ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT def get ( self , key , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT def __contains__ ( self , key ) : NEW_LINE INDENT try : NEW_LINE INDENT self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def keys ( self ) : NEW_LINE INDENT return KeysView ( self ) NEW_LINE DEDENT def items ( self ) : NEW_LINE INDENT return ItemsView ( self ) NEW_LINE DEDENT def values ( self ) : NEW_LINE INDENT return ValuesView ( self ) NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Mapping ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return dict ( self . items ( ) ) == dict ( other . items ( ) ) NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return not ( self == other ) NEW_LINE DEDENT DEDENT Mapping . register ( mappingproxy ) NEW_LINE class MappingView ( Sized ) : NEW_LINE INDENT def __init__ ( self , mapping ) : NEW_LINE INDENT self . _mapping = mapping NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . _mapping ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' { 0 . _ _ class _ _ . _ _ name _ _ } ( { 0 . _ mapping ! r } ) ' . format ( self ) NEW_LINE DEDENT DEDENT class KeysView ( MappingView , Set ) : NEW_LINE INDENT @ classmethod NEW_LINE def _from_iterable ( self , it ) : NEW_LINE INDENT return set ( it ) NEW_LINE DEDENT def __contains__ ( self , key ) : NEW_LINE INDENT return key in self . _mapping NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield key NEW_LINE DEDENT DEDENT DEDENT KeysView . register ( dict_keys ) NEW_LINE class ItemsView ( MappingView , Set ) : NEW_LINE INDENT @ classmethod NEW_LINE def _from_iterable ( self , it ) : NEW_LINE INDENT return set ( it ) NEW_LINE DEDENT def __contains__ ( self , item ) : NEW_LINE INDENT key , value = item NEW_LINE try : NEW_LINE INDENT v = self . _mapping [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return v == value NEW_LINE DEDENT DEDENT def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield ( key , self . _mapping [ key ] ) NEW_LINE DEDENT DEDENT DEDENT ItemsView . register ( dict_items ) NEW_LINE class ValuesView ( MappingView ) : NEW_LINE INDENT def __contains__ ( self , value ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT if value == self . _mapping [ key ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield self . _mapping [ key ] NEW_LINE DEDENT DEDENT DEDENT ValuesView . register ( dict_values ) NEW_LINE class MutableMapping ( Mapping ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __setitem__ ( self , key , value ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT @ abstractmethod NEW_LINE def __delitem__ ( self , key ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT __marker = object ( ) NEW_LINE def pop ( self , key , default = __marker ) : NEW_LINE INDENT try : NEW_LINE INDENT value = self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT if default is self . __marker : NEW_LINE INDENT raise NEW_LINE DEDENT return default NEW_LINE DEDENT else : NEW_LINE INDENT del self [ key ] NEW_LINE return value NEW_LINE DEDENT DEDENT def popitem ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT key = next ( iter ( self ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT value = self [ key ] NEW_LINE del self [ key ] NEW_LINE return key , value NEW_LINE DEDENT def clear ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT self . popitem ( ) NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def update ( * args , ** kwds ) : NEW_LINE INDENT if len ( args ) > 2 : NEW_LINE INDENT raise TypeError ( " update ( ) ▁ takes ▁ at ▁ most ▁ 2 ▁ positional ▁ " " arguments ▁ ( { } ▁ given ) " . format ( len ( args ) ) ) NEW_LINE DEDENT elif not args : NEW_LINE INDENT raise TypeError ( " update ( ) ▁ takes ▁ at ▁ least ▁ 1 ▁ argument ▁ ( 0 ▁ given ) " ) NEW_LINE DEDENT self = args [ 0 ] NEW_LINE other = args [ 1 ] if len ( args ) >= 2 else ( ) NEW_LINE if isinstance ( other , Mapping ) : NEW_LINE INDENT for key in other : NEW_LINE INDENT self [ key ] = other [ key ] NEW_LINE DEDENT DEDENT elif hasattr ( other , " keys " ) : NEW_LINE INDENT for key in other . keys ( ) : NEW_LINE INDENT self [ key ] = other [ key ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for key , value in other : NEW_LINE INDENT self [ key ] = value NEW_LINE DEDENT DEDENT for key , value in kwds . items ( ) : NEW_LINE INDENT self [ key ] = value NEW_LINE DEDENT DEDENT def setdefault ( self , key , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT self [ key ] = default NEW_LINE DEDENT return default NEW_LINE DEDENT DEDENT MutableMapping . register ( dict ) NEW_LINE # # # ▁ SEQUENCES ▁ # # # ENDCOM class Sequence ( Sized , Iterable , Container ) : NEW_LINE INDENT """ All ▁ the ▁ operations ▁ on ▁ a ▁ read - only ▁ sequence . STRNEWLINE STRNEWLINE ▁ Concrete ▁ subclasses ▁ must ▁ override ▁ _ _ new _ _ ▁ or ▁ _ _ init _ _ , STRNEWLINE ▁ _ _ getitem _ _ , ▁ and ▁ _ _ len _ _ . STRNEWLINE ▁ """ NEW_LINE __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __getitem__ ( self , index ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT i = 0 NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT v = self [ i ] NEW_LINE yield v NEW_LINE i += 1 NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT def __contains__ ( self , value ) : NEW_LINE INDENT for v in self : NEW_LINE INDENT if v == value : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def __reversed__ ( self ) : NEW_LINE INDENT for i in reversed ( range ( len ( self ) ) ) : NEW_LINE INDENT yield self [ i ] NEW_LINE DEDENT DEDENT def index ( self , value ) : NEW_LINE INDENT for i , v in enumerate ( self ) : NEW_LINE INDENT if v == value : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT raise ValueError NEW_LINE DEDENT def count ( self , value ) : NEW_LINE INDENT return sum ( 1 for v in self if v == value ) NEW_LINE DEDENT DEDENT Sequence . register ( tuple ) NEW_LINE Sequence . register ( str ) NEW_LINE Sequence . register ( range ) NEW_LINE class ByteString ( Sequence ) : NEW_LINE INDENT """ This ▁ unifies ▁ bytes ▁ and ▁ bytearray . STRNEWLINE STRNEWLINE ▁ XXX ▁ Should ▁ add ▁ all ▁ their ▁ methods . STRNEWLINE ▁ """ NEW_LINE __slots__ = ( ) NEW_LINE DEDENT ByteString . register ( bytes ) NEW_LINE ByteString . register ( bytearray ) NEW_LINE class MutableSequence ( Sequence ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __setitem__ ( self , index , value ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT @ abstractmethod NEW_LINE def __delitem__ ( self , index ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT @ abstractmethod NEW_LINE def insert ( self , index , value ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT def append ( self , value ) : NEW_LINE INDENT self . insert ( len ( self ) , value ) NEW_LINE DEDENT def clear ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT self . pop ( ) NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def reverse ( self ) : NEW_LINE INDENT n = len ( self ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT self [ i ] , self [ n - i - 1 ] = self [ n - i - 1 ] , self [ i ] NEW_LINE DEDENT DEDENT def extend ( self , values ) : NEW_LINE INDENT for v in values : NEW_LINE INDENT self . append ( v ) NEW_LINE DEDENT DEDENT def pop ( self , index = - 1 ) : NEW_LINE INDENT v = self [ index ] NEW_LINE del self [ index ] NEW_LINE return v NEW_LINE DEDENT def remove ( self , value ) : NEW_LINE INDENT del self [ self . index ( value ) ] NEW_LINE DEDENT def __iadd__ ( self , values ) : NEW_LINE INDENT self . extend ( values ) NEW_LINE return self NEW_LINE DEDENT DEDENT MutableSequence . register ( list ) NEW_LINE MutableSequence . register ( bytearray ) # ▁ Multiply ▁ inheriting , ▁ see ▁ ByteString ENDCOM NEW_LINE </DOCUMENT>
<DOCUMENT_ID="yatinkumbhare/openstack-nova/tree/master/nova/db/sqlalchemy/migrate_repo/versions/284_placeholder.py"> # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ENDCOM # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ENDCOM # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ENDCOM # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ENDCOM # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM # ▁ under ▁ the ▁ License . ENDCOM # ▁ This ▁ is ▁ a ▁ placeholder ▁ for ▁ Kilo ▁ backports . ENDCOM # ▁ Do ▁ not ▁ use ▁ this ▁ number ▁ for ▁ new ▁ Liberty ▁ work . ▁ New ▁ work ▁ starts ▁ after ENDCOM # ▁ all ▁ the ▁ placeholders . ENDCOM # ▁ See ▁ this ▁ for ▁ more ▁ information : ENDCOM # ▁ http : / / lists . openstack . org / pipermail / openstack - dev / 2013 - March / 006827 . html ENDCOM def upgrade ( migrate_engine ) : NEW_LINE INDENT pass NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="jasonseminara/OpenSourceFinal/tree/master/myvenv/lib/python3.5/site-packages/django/template/smartif.py"> """ STRNEWLINE Parser ▁ and ▁ utilities ▁ for ▁ the ▁ smart ▁ ' if ' ▁ tag STRNEWLINE """ NEW_LINE import warnings NEW_LINE from django . utils . deprecation import RemovedInDjango110Warning NEW_LINE # ▁ Using ▁ a ▁ simple ▁ top ▁ down ▁ parser , ▁ as ▁ described ▁ here : ENDCOM # ▁ http : / / effbot . org / zone / simple - top - down - parsing . htm . ENDCOM # ▁ ' led ' ▁ = ▁ left ▁ denotation ENDCOM # ▁ ' nud ' ▁ = ▁ null ▁ denotation ENDCOM # ▁ ' bp ' ▁ = ▁ binding ▁ power ▁ ( left ▁ = ▁ lbp , ▁ right ▁ = ▁ rbp ) ENDCOM class TokenBase ( object ) : NEW_LINE INDENT """ STRNEWLINE ▁ Base ▁ class ▁ for ▁ operators ▁ and ▁ literals , ▁ mainly ▁ for ▁ debugging ▁ and ▁ for ▁ throwing STRNEWLINE ▁ syntax ▁ errors . STRNEWLINE ▁ """ NEW_LINE id = None # ▁ node / token ▁ type ▁ name ENDCOM NEW_LINE value = None # ▁ used ▁ by ▁ literals ENDCOM NEW_LINE first = second = None # ▁ used ▁ by ▁ tree ▁ nodes ENDCOM NEW_LINE def nud ( self , parser ) : NEW_LINE # ▁ Null ▁ denotation ▁ - ▁ called ▁ in ▁ prefix ▁ context ENDCOM INDENT raise parser . error_class ( " Not ▁ expecting ▁ ' % s ' ▁ in ▁ this ▁ position ▁ in ▁ if ▁ tag . " % self . id ) NEW_LINE DEDENT def led ( self , left , parser ) : NEW_LINE # ▁ Left ▁ denotation ▁ - ▁ called ▁ in ▁ infix ▁ context ENDCOM INDENT raise parser . error_class ( " Not ▁ expecting ▁ ' % s ' ▁ as ▁ infix ▁ operator ▁ in ▁ if ▁ tag . " % self . id ) NEW_LINE DEDENT def display ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ what ▁ to ▁ display ▁ in ▁ error ▁ messages ▁ for ▁ this ▁ node STRNEWLINE ▁ """ NEW_LINE return self . id NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT out = [ str ( x ) for x in [ self . id , self . first , self . second ] if x is not None ] NEW_LINE return " ( " + " ▁ " . join ( out ) + " ) " NEW_LINE DEDENT DEDENT def infix ( bp , func ) : NEW_LINE INDENT """ STRNEWLINE ▁ Creates ▁ an ▁ infix ▁ operator , ▁ given ▁ a ▁ binding ▁ power ▁ and ▁ a ▁ function ▁ that STRNEWLINE ▁ evaluates ▁ the ▁ node STRNEWLINE ▁ """ NEW_LINE class Operator ( TokenBase ) : NEW_LINE INDENT lbp = bp NEW_LINE def led ( self , left , parser ) : NEW_LINE INDENT self . first = left NEW_LINE self . second = parser . expression ( bp ) NEW_LINE return self NEW_LINE DEDENT def eval ( self , context ) : NEW_LINE INDENT try : NEW_LINE INDENT return func ( context , self . first , self . second ) NEW_LINE DEDENT except Exception : NEW_LINE # ▁ Templates ▁ shouldn ' t ▁ throw ▁ exceptions ▁ when ▁ rendering . ▁ We ▁ are ENDCOM # ▁ most ▁ likely ▁ to ▁ get ▁ exceptions ▁ for ▁ things ▁ like ▁ { % ▁ if ▁ foo ▁ in ▁ bar ENDCOM # ▁ % } ▁ where ▁ ' bar ' ▁ does ▁ not ▁ support ▁ ' in ' , ▁ so ▁ default ▁ to ▁ False ENDCOM INDENT return False NEW_LINE DEDENT DEDENT DEDENT return Operator NEW_LINE DEDENT def prefix ( bp , func ) : NEW_LINE INDENT """ STRNEWLINE ▁ Creates ▁ a ▁ prefix ▁ operator , ▁ given ▁ a ▁ binding ▁ power ▁ and ▁ a ▁ function ▁ that STRNEWLINE ▁ evaluates ▁ the ▁ node . STRNEWLINE ▁ """ NEW_LINE class Operator ( TokenBase ) : NEW_LINE INDENT lbp = bp NEW_LINE def nud ( self , parser ) : NEW_LINE INDENT self . first = parser . expression ( bp ) NEW_LINE self . second = None NEW_LINE return self NEW_LINE DEDENT def eval ( self , context ) : NEW_LINE INDENT try : NEW_LINE INDENT return func ( context , self . first ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return Operator NEW_LINE # ▁ Operator ▁ precedence ▁ follows ▁ Python . ENDCOM # ▁ NB ▁ - ▁ we ▁ can ▁ get ▁ slightly ▁ more ▁ accurate ▁ syntax ▁ error ▁ messages ▁ by ▁ not ▁ using ▁ the ENDCOM # ▁ same ▁ object ▁ for ▁ ' = = ' ▁ and ▁ ' = ' . ENDCOM # ▁ We ▁ defer ▁ variable ▁ evaluation ▁ to ▁ the ▁ lambda ▁ to ▁ ensure ▁ that ▁ terms ▁ are ENDCOM # ▁ lazily ▁ evaluated ▁ using ▁ Python ' s ▁ boolean ▁ parsing ▁ logic . ENDCOM DEDENT OPERATORS = { ' or ' : infix ( 6 , lambda context , x , y : x . eval ( context ) or y . eval ( context ) ) , ' and ' : infix ( 7 , lambda context , x , y : x . eval ( context ) and y . eval ( context ) ) , ' not ' : prefix ( 8 , lambda context , x : not x . eval ( context ) ) , ' in ' : infix ( 9 , lambda context , x , y : x . eval ( context ) in y . eval ( context ) ) , ' not ▁ in ' : infix ( 9 , lambda context , x , y : x . eval ( context ) not in y . eval ( context ) ) , # ▁ This ▁ should ▁ be ▁ removed ▁ in ▁ Django ▁ 1.10 : ENDCOM ' = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) , ' = = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) , ' ! = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) != y . eval ( context ) ) , ' > ' : infix ( 10 , lambda context , x , y : x . eval ( context ) > y . eval ( context ) ) , ' > = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) >= y . eval ( context ) ) , ' < ' : infix ( 10 , lambda context , x , y : x . eval ( context ) < y . eval ( context ) ) , ' < = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) <= y . eval ( context ) ) , } NEW_LINE # ▁ Assign ▁ ' id ' ▁ to ▁ each : ENDCOM for key , op in OPERATORS . items ( ) : NEW_LINE INDENT op . id = key NEW_LINE DEDENT class Literal ( TokenBase ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ basic ▁ self - resolvable ▁ object ▁ similar ▁ to ▁ a ▁ Django ▁ template ▁ variable . STRNEWLINE ▁ """ NEW_LINE # ▁ IfParser ▁ uses ▁ Literal ▁ in ▁ create _ var , ▁ but ▁ TemplateIfParser ▁ overrides ENDCOM # ▁ create _ var ▁ so ▁ that ▁ a ▁ proper ▁ implementation ▁ that ▁ actually ▁ resolves ENDCOM # ▁ variables , ▁ filters ▁ etc ▁ is ▁ used . ENDCOM id = " literal " NEW_LINE lbp = 0 NEW_LINE def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE DEDENT def display ( self ) : NEW_LINE INDENT return repr ( self . value ) NEW_LINE DEDENT def nud ( self , parser ) : NEW_LINE INDENT return self NEW_LINE DEDENT def eval ( self , context ) : NEW_LINE INDENT return self . value NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " ( % s ▁ % r ) " % ( self . id , self . value ) NEW_LINE DEDENT DEDENT class EndToken ( TokenBase ) : NEW_LINE INDENT lbp = 0 NEW_LINE def nud ( self , parser ) : NEW_LINE INDENT raise parser . error_class ( " Unexpected ▁ end ▁ of ▁ expression ▁ in ▁ if ▁ tag . " ) NEW_LINE DEDENT DEDENT EndToken = EndToken ( ) NEW_LINE class IfParser ( object ) : NEW_LINE INDENT error_class = ValueError NEW_LINE def __init__ ( self , tokens ) : NEW_LINE # ▁ pre - pass ▁ necessary ▁ to ▁ turn ▁ ' not ' , ' in ' ▁ into ▁ single ▁ token ENDCOM INDENT l = len ( tokens ) NEW_LINE mapped_tokens = [ ] NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT token = tokens [ i ] NEW_LINE if token == " not " and i + 1 < l and tokens [ i + 1 ] == " in " : NEW_LINE INDENT token = " not ▁ in " NEW_LINE i += 1 # ▁ skip ▁ ' in ' ENDCOM NEW_LINE DEDENT mapped_tokens . append ( self . translate_token ( token ) ) NEW_LINE i += 1 NEW_LINE DEDENT self . tokens = mapped_tokens NEW_LINE self . pos = 0 NEW_LINE self . current_token = self . next_token ( ) NEW_LINE DEDENT def translate_token ( self , token ) : NEW_LINE INDENT try : NEW_LINE INDENT op = OPERATORS [ token ] NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT return self . create_var ( token ) NEW_LINE DEDENT else : NEW_LINE INDENT if token == ' = ' : NEW_LINE INDENT warnings . warn ( " Operator ▁ ' = ' ▁ is ▁ deprecated ▁ and ▁ will ▁ be ▁ removed ▁ in ▁ Django ▁ 1.10 . ▁ Use ▁ ' = = ' ▁ instead . " , RemovedInDjango110Warning , stacklevel = 2 ) NEW_LINE DEDENT return op ( ) NEW_LINE DEDENT DEDENT def next_token ( self ) : NEW_LINE INDENT if self . pos >= len ( self . tokens ) : NEW_LINE INDENT return EndToken NEW_LINE DEDENT else : NEW_LINE INDENT retval = self . tokens [ self . pos ] NEW_LINE self . pos += 1 NEW_LINE return retval NEW_LINE DEDENT DEDENT def parse ( self ) : NEW_LINE INDENT retval = self . expression ( ) NEW_LINE # ▁ Check ▁ that ▁ we ▁ have ▁ exhausted ▁ all ▁ the ▁ tokens ENDCOM if self . current_token is not EndToken : NEW_LINE INDENT raise self . error_class ( " Unused ▁ ' % s ' ▁ at ▁ end ▁ of ▁ if ▁ expression . " % self . current_token . display ( ) ) NEW_LINE DEDENT return retval NEW_LINE DEDENT def expression ( self , rbp = 0 ) : NEW_LINE INDENT t = self . current_token NEW_LINE self . current_token = self . next_token ( ) NEW_LINE left = t . nud ( self ) NEW_LINE while rbp < self . current_token . lbp : NEW_LINE INDENT t = self . current_token NEW_LINE self . current_token = self . next_token ( ) NEW_LINE left = t . led ( left , self ) NEW_LINE DEDENT return left NEW_LINE DEDENT def create_var ( self , value ) : NEW_LINE INDENT return Literal ( value ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="anas-taji/knowledge/tree/master/attachment_edit/models/ir_attachment.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ © ▁ 2015 ▁ Therp ▁ BV ▁ < http : / / therp . nl > ENDCOM # ▁ License ▁ AGPL - 3.0 ▁ or ▁ later ▁ ( http : / / www . gnu . org / licenses / agpl . html ) . ENDCOM # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM from openerp import models , fields , api NEW_LINE class IrAttachment ( models . Model ) : NEW_LINE INDENT _inherit = ' ir . attachment ' NEW_LINE res_reference = fields . Reference ( selection = ' _ selection _ res _ reference ' , string = ' Resource ▁ reference ' , compute = ' _ compute _ res _ reference ' , inverse = ' _ inverse _ res _ reference ' ) NEW_LINE @ api . one NEW_LINE @ api . depends ( ' res _ id ' , ' res _ model ' ) NEW_LINE def _compute_res_reference ( self ) : NEW_LINE INDENT if self . res_model and self . res_id : NEW_LINE INDENT self . res_reference = ' % s , % s ' % ( self . res_model , self . res_id ) NEW_LINE DEDENT DEDENT @ api . one NEW_LINE def _inverse_res_reference ( self ) : NEW_LINE INDENT if self . res_reference : NEW_LINE INDENT self . write ( { ' res _ model ' : self . res_reference . _model . _model , ' res _ id ' : self . res_reference . id , } ) NEW_LINE DEDENT else : NEW_LINE INDENT self . write ( { ' res _ model ' : False , ' res _ id ' : False } ) NEW_LINE DEDENT DEDENT @ api . model NEW_LINE def _selection_res_reference ( self ) : NEW_LINE INDENT return self . env [ ' ir . model ' ] . search ( [ ( ' osv _ memory ' , ' = ' , False ) , ( ' access _ ids . group _ id . users ' , ' = ' , self . env . uid ) ] ) . mapped ( lambda rec : ( rec . model , rec . name ) ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="giorgiop/scipy/tree/master/scipy/interpolate/tests/test_fitpack2.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Created ▁ by ▁ Pearu ▁ Peterson , ▁ June ▁ 2003 ENDCOM from __future__ import division , print_function , absolute_import NEW_LINE import warnings NEW_LINE import numpy as np NEW_LINE from numpy . testing import ( assert_equal , assert_almost_equal , assert_array_equal , assert_array_almost_equal , assert_allclose , assert_raises , TestCase , run_module_suite ) NEW_LINE from numpy import array , diff , linspace , meshgrid , ones , pi , shape NEW_LINE from scipy . interpolate . fitpack import bisplrep , bisplev NEW_LINE from scipy . interpolate . fitpack2 import ( UnivariateSpline , LSQUnivariateSpline , InterpolatedUnivariateSpline , LSQBivariateSpline , SmoothBivariateSpline , RectBivariateSpline , LSQSphereBivariateSpline , SmoothSphereBivariateSpline , RectSphereBivariateSpline ) NEW_LINE class TestUnivariateSpline ( TestCase ) : NEW_LINE INDENT def test_linear_constant ( self ) : NEW_LINE INDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 3 , 3 , 3 ] NEW_LINE lut = UnivariateSpline ( x , y , k = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , [ 1 , 3 ] ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 3 , 3 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] ) , [ 3 , 3 , 3 ] ) NEW_LINE DEDENT def test_preserve_shape ( self ) : NEW_LINE INDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 0 , 2 , 4 ] NEW_LINE lut = UnivariateSpline ( x , y , k = 1 ) NEW_LINE arg = 2 NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg ) ) ) NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg , nu = 1 ) ) ) NEW_LINE arg = [ 1.5 , 2 , 2.5 ] NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg ) ) ) NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg , nu = 1 ) ) ) NEW_LINE DEDENT def test_linear_1d ( self ) : NEW_LINE INDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 0 , 2 , 4 ] NEW_LINE lut = UnivariateSpline ( x , y , k = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , [ 1 , 3 ] ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 0 , 4 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] ) , [ 0 , 1 , 2 ] ) NEW_LINE DEDENT def test_subclassing ( self ) : NEW_LINE # ▁ See ▁ # 731 ENDCOM INDENT class ZeroSpline ( UnivariateSpline ) : NEW_LINE INDENT def __call__ ( self , x ) : NEW_LINE INDENT return 0 * array ( x ) NEW_LINE DEDENT DEDENT sp = ZeroSpline ( [ 1 , 2 , 3 , 4 , 5 ] , [ 3 , 2 , 3 , 2 , 3 ] , k = 2 ) NEW_LINE assert_array_equal ( sp ( [ 1.5 , 2.5 ] ) , [ 0. , 0. ] ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE # ▁ Test ▁ whether ▁ empty ▁ input ▁ returns ▁ an ▁ empty ▁ output . ▁ Ticket ▁ 1014 ENDCOM INDENT x = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE y = [ 0 , 4 , 9 , 12 , 21 ] NEW_LINE spl = UnivariateSpline ( x , y , k = 3 ) NEW_LINE assert_array_equal ( spl ( [ ] ) , array ( [ ] ) ) NEW_LINE DEDENT def test_resize_regression ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 1375 . """ NEW_LINE x = [ - 1. , - 0.65016502 , - 0.58856235 , - 0.26903553 , - 0.17370892 , - 0.10011001 , 0. , 0.10011001 , 0.17370892 , 0.26903553 , 0.58856235 , 0.65016502 , 1. ] NEW_LINE y = [ 1. , 0.62928599 , 0.5797223 , 0.39965815 , 0.36322694 , 0.3508061 , 0.35214793 , 0.3508061 , 0.36322694 , 0.39965815 , 0.5797223 , 0.62928599 , 1. ] NEW_LINE w = [ 1.00000000e+12 , 6.88875973e+02 , 4.89314737e+02 , 4.26864807e+02 , 6.07746770e+02 , 4.51341444e+02 , 3.17480210e+02 , 4.51341444e+02 , 6.07746770e+02 , 4.26864807e+02 , 4.89314737e+02 , 6.88875973e+02 , 1.00000000e+12 ] NEW_LINE spl = UnivariateSpline ( x = x , y = y , w = w , s = None ) NEW_LINE desired = array ( [ 0.35100374 , 0.51715855 , 0.87789547 , 0.98719344 ] ) NEW_LINE assert_allclose ( spl ( [ 0.1 , 0.5 , 0.9 , 0.99 ] ) , desired , atol = 5e-4 ) NEW_LINE DEDENT def test_out_of_range_regression ( self ) : NEW_LINE # ▁ Test ▁ different ▁ extrapolation ▁ modes . ▁ See ▁ ticket ▁ 3557 ENDCOM INDENT x = np . arange ( 5 , dtype = float ) NEW_LINE y = x ** 3 NEW_LINE xp = linspace ( - 8 , 13 , 100 ) NEW_LINE xp_zeros = xp . copy ( ) NEW_LINE xp_zeros [ np . logical_or ( xp_zeros < 0. , xp_zeros > 4. ) ] = 0 NEW_LINE xp_clip = xp . copy ( ) NEW_LINE xp_clip [ xp_clip < x [ 0 ] ] = x [ 0 ] NEW_LINE xp_clip [ xp_clip > x [ - 1 ] ] = x [ - 1 ] NEW_LINE for cls in [ UnivariateSpline , InterpolatedUnivariateSpline ] : NEW_LINE INDENT spl = cls ( x = x , y = y ) NEW_LINE for ext in [ 0 , ' extrapolate ' ] : NEW_LINE INDENT assert_allclose ( spl ( xp , ext = ext ) , xp ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( cls ( x , y , ext = ext ) ( xp ) , xp ** 3 , atol = 1e-16 ) NEW_LINE DEDENT for ext in [ 1 , ' zeros ' ] : NEW_LINE INDENT assert_allclose ( spl ( xp , ext = ext ) , xp_zeros ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( cls ( x , y , ext = ext ) ( xp ) , xp_zeros ** 3 , atol = 1e-16 ) NEW_LINE DEDENT for ext in [ 2 , ' raise ' ] : NEW_LINE INDENT assert_raises ( ValueError , spl , xp , ** dict ( ext = ext ) ) NEW_LINE DEDENT for ext in [ 3 , ' const ' ] : NEW_LINE INDENT assert_allclose ( spl ( xp , ext = ext ) , xp_clip ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( cls ( x , y , ext = ext ) ( xp ) , xp_clip ** 3 , atol = 1e-16 ) NEW_LINE # ▁ also ▁ test ▁ LSQUnivariateSpline ▁ [ which ▁ needs ▁ explicit ▁ knots ] ENDCOM DEDENT DEDENT t = spl . get_knots ( ) [ 3 : 4 ] # ▁ interior ▁ knots ▁ w / ▁ default ▁ k = 3 ENDCOM NEW_LINE spl = LSQUnivariateSpline ( x , y , t ) NEW_LINE assert_allclose ( spl ( xp , ext = 0 ) , xp ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( spl ( xp , ext = 1 ) , xp_zeros ** 3 , atol = 1e-16 ) NEW_LINE assert_raises ( ValueError , spl , xp , ** dict ( ext = 2 ) ) NEW_LINE assert_allclose ( spl ( xp , ext = 3 ) , xp_clip ** 3 , atol = 1e-16 ) NEW_LINE # ▁ also ▁ make ▁ sure ▁ that ▁ unknown ▁ values ▁ for ▁ ` ext ` ▁ are ▁ caught ▁ early ENDCOM for ext in [ - 1 , ' unknown ' ] : NEW_LINE INDENT spl = UnivariateSpline ( x , y ) NEW_LINE assert_raises ( ValueError , spl , xp , ** dict ( ext = ext ) ) NEW_LINE assert_raises ( ValueError , UnivariateSpline , ** dict ( x = x , y = y , ext = ext ) ) NEW_LINE DEDENT DEDENT def test_lsq_fpchec ( self ) : NEW_LINE INDENT xs = np . arange ( 100 ) * 1. NEW_LINE ys = np . arange ( 100 ) * 1. NEW_LINE knots = np . linspace ( 0 , 99 , 10 ) NEW_LINE bbox = ( - 1 , 101 ) NEW_LINE assert_raises ( ValueError , LSQUnivariateSpline , xs , ys , knots , bbox = bbox ) NEW_LINE DEDENT def test_derivative_and_antiderivative ( self ) : NEW_LINE # ▁ Thin ▁ wrappers ▁ to ▁ splder / splantider , ▁ so ▁ light ▁ smoke ▁ test ▁ only . ENDCOM INDENT x = np . linspace ( 0 , 1 , 70 ) ** 3 NEW_LINE y = np . cos ( x ) NEW_LINE spl = UnivariateSpline ( x , y , s = 0 ) NEW_LINE spl2 = spl . antiderivative ( 2 ) . derivative ( 2 ) NEW_LINE assert_allclose ( spl ( 0.3 ) , spl2 ( 0.3 ) ) NEW_LINE spl2 = spl . antiderivative ( 1 ) NEW_LINE assert_allclose ( spl2 ( 0.6 ) - spl2 ( 0.2 ) , spl . integral ( 0.2 , 0.6 ) ) NEW_LINE DEDENT def test_nan ( self ) : NEW_LINE # ▁ bail ▁ out ▁ early ▁ if ▁ the ▁ input ▁ data ▁ contains ▁ nans ENDCOM INDENT x = np . arange ( 10 , dtype = float ) NEW_LINE y = x ** 3 NEW_LINE for z in [ np . nan , np . inf , - np . inf ] : NEW_LINE INDENT y [ - 1 ] = z NEW_LINE assert_raises ( ValueError , UnivariateSpline , ** dict ( x = x , y = y , check_finite = True ) ) NEW_LINE DEDENT DEDENT DEDENT class TestLSQBivariateSpline ( TestCase ) : NEW_LINE # ▁ NOTE : ▁ The ▁ systems ▁ in ▁ this ▁ test ▁ class ▁ are ▁ rank - deficient ENDCOM INDENT def test_linear_constant ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( record = True ) : # ▁ coefficients ▁ of ▁ the ▁ . . . ENDCOM NEW_LINE INDENT lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT assert_almost_equal ( lut ( 2 , 2 ) , 3. ) NEW_LINE DEDENT def test_bilinearity ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 0 , 7 , 8 , 3 , 4 , 7 , 1 , 3 , 4 ] NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( ) : NEW_LINE # ▁ This ▁ seems ▁ to ▁ fail ▁ ( ier = 1 , ▁ see ▁ ticket ▁ 1642 ) . ENDCOM INDENT warnings . simplefilter ( ' ignore ' , UserWarning ) NEW_LINE lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT tx , ty = lut . get_knots ( ) NEW_LINE for xa , xb in zip ( tx [ : - 1 ] , tx [ 1 : ] ) : NEW_LINE INDENT for ya , yb in zip ( ty [ : - 1 ] , ty [ 1 : ] ) : NEW_LINE INDENT for t in [ 0.1 , 0.5 , 0.9 ] : NEW_LINE INDENT for s in [ 0.3 , 0.4 , 0.7 ] : NEW_LINE INDENT xp = xa * ( 1 - t ) + xb * t NEW_LINE yp = ya * ( 1 - s ) + yb * s NEW_LINE zp = ( + lut ( xa , ya ) * ( 1 - t ) * ( 1 - s ) + lut ( xb , ya ) * t * ( 1 - s ) + lut ( xa , yb ) * ( 1 - t ) * s + lut ( xb , yb ) * t * s ) NEW_LINE assert_almost_equal ( lut ( xp , yp ) , zp ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def test_integral ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 8 , 8 , 8 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = array ( [ 0 , 7 , 8 , 3 , 4 , 7 , 1 , 3 , 4 ] ) NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( record = True ) : # ▁ coefficients ▁ of ▁ the ▁ . . . ENDCOM NEW_LINE INDENT lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT tx , ty = lut . get_knots ( ) NEW_LINE tz = lut ( tx , ty ) NEW_LINE trpz = .25 * ( diff ( tx ) [ : , None ] * diff ( ty ) [ None , : ] * ( tz [ : - 1 , : - 1 ] + tz [ 1 : , : - 1 ] + tz [ : - 1 , 1 : ] + tz [ 1 : , 1 : ] ) ) . sum ( ) NEW_LINE assert_almost_equal ( lut . integral ( tx [ 0 ] , tx [ - 1 ] , ty [ 0 ] , ty [ - 1 ] ) , trpz ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE # ▁ Test ▁ whether ▁ empty ▁ inputs ▁ returns ▁ an ▁ empty ▁ output . ▁ Ticket ▁ 1014 ENDCOM INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( record = True ) : # ▁ coefficients ▁ of ▁ the ▁ . . . ENDCOM NEW_LINE INDENT lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT assert_array_equal ( lut ( [ ] , [ ] ) , np . zeros ( ( 0 , 0 ) ) ) NEW_LINE assert_array_equal ( lut ( [ ] , [ ] , grid = False ) , np . zeros ( ( 0 , ) ) ) NEW_LINE DEDENT DEDENT class TestSmoothBivariateSpline ( TestCase ) : NEW_LINE INDENT def test_linear_constant ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE lut = SmoothBivariateSpline ( x , y , z , kx = 1 , ky = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , ( [ 1 , 1 , 3 , 3 ] , [ 1 , 1 , 3 , 3 ] ) ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 3 , 3 , 3 , 3 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] , [ 1 , 1.5 ] ) , [ [ 3 , 3 ] , [ 3 , 3 ] , [ 3 , 3 ] ] ) NEW_LINE DEDENT def test_linear_1d ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 0 , 0 , 0 , 2 , 2 , 2 , 4 , 4 , 4 ] NEW_LINE lut = SmoothBivariateSpline ( x , y , z , kx = 1 , ky = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , ( [ 1 , 1 , 3 , 3 ] , [ 1 , 1 , 3 , 3 ] ) ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 0 , 0 , 4 , 4 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] , [ 1 , 1.5 ] ) , [ [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ] ) NEW_LINE DEDENT def test_integral ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 4 , 4 , 4 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = array ( [ 0 , 7 , 8 , 3 , 4 , 7 , 1 , 3 , 4 ] ) NEW_LINE with warnings . catch_warnings ( ) : NEW_LINE # ▁ This ▁ seems ▁ to ▁ fail ▁ ( ier = 1 , ▁ see ▁ ticket ▁ 1642 ) . ENDCOM INDENT warnings . simplefilter ( ' ignore ' , UserWarning ) NEW_LINE lut = SmoothBivariateSpline ( x , y , z , kx = 1 , ky = 1 , s = 0 ) NEW_LINE DEDENT tx = [ 1 , 2 , 4 ] NEW_LINE ty = [ 1 , 2 , 3 ] NEW_LINE tz = lut ( tx , ty ) NEW_LINE trpz = .25 * ( diff ( tx ) [ : , None ] * diff ( ty ) [ None , : ] * ( tz [ : - 1 , : - 1 ] + tz [ 1 : , : - 1 ] + tz [ : - 1 , 1 : ] + tz [ 1 : , 1 : ] ) ) . sum ( ) NEW_LINE assert_almost_equal ( lut . integral ( tx [ 0 ] , tx [ - 1 ] , ty [ 0 ] , ty [ - 1 ] ) , trpz ) NEW_LINE lut2 = SmoothBivariateSpline ( x , y , z , kx = 2 , ky = 2 , s = 0 ) NEW_LINE assert_almost_equal ( lut2 . integral ( tx [ 0 ] , tx [ - 1 ] , ty [ 0 ] , ty [ - 1 ] ) , trpz , decimal = 0 ) # ▁ the ▁ quadratures ▁ give ▁ 23.75 ▁ and ▁ 23.85 ENDCOM NEW_LINE tz = lut ( tx [ : - 1 ] , ty [ : - 1 ] ) NEW_LINE trpz = .25 * ( diff ( tx [ : - 1 ] ) [ : , None ] * diff ( ty [ : - 1 ] ) [ None , : ] * ( tz [ : - 1 , : - 1 ] + tz [ 1 : , : - 1 ] + tz [ : - 1 , 1 : ] + tz [ 1 : , 1 : ] ) ) . sum ( ) NEW_LINE assert_almost_equal ( lut . integral ( tx [ 0 ] , tx [ - 2 ] , ty [ 0 ] , ty [ - 2 ] ) , trpz ) NEW_LINE DEDENT def test_rerun_lwrk2_too_small ( self ) : NEW_LINE # ▁ in ▁ this ▁ setting , ▁ lwrk2 ▁ is ▁ too ▁ small ▁ in ▁ the ▁ default ▁ run . ▁ Here ▁ we ENDCOM # ▁ check ▁ for ▁ equality ▁ with ▁ the ▁ bisplrep / bisplev ▁ output ▁ because ▁ there , ENDCOM # ▁ an ▁ automatic ▁ re - run ▁ of ▁ the ▁ spline ▁ representation ▁ is ▁ done ▁ if ▁ ier > 10 . ENDCOM INDENT x = np . linspace ( - 2 , 2 , 80 ) NEW_LINE y = np . linspace ( - 2 , 2 , 80 ) NEW_LINE z = x + y NEW_LINE xi = np . linspace ( - 1 , 1 , 100 ) NEW_LINE yi = np . linspace ( - 2 , 2 , 100 ) NEW_LINE tck = bisplrep ( x , y , z ) NEW_LINE res1 = bisplev ( xi , yi , tck ) NEW_LINE interp_ = SmoothBivariateSpline ( x , y , z ) NEW_LINE res2 = interp_ ( xi , yi ) NEW_LINE assert_almost_equal ( res1 , res2 ) NEW_LINE DEDENT DEDENT class TestLSQSphereBivariateSpline ( TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE # ▁ define ▁ the ▁ input ▁ data ▁ and ▁ coordinates ENDCOM INDENT ntheta , nphi = 70 , 90 NEW_LINE theta = linspace ( 0.5 / ( ntheta - 1 ) , 1 - 0.5 / ( ntheta - 1 ) , ntheta ) * pi NEW_LINE phi = linspace ( 0.5 / ( nphi - 1 ) , 1 - 0.5 / ( nphi - 1 ) , nphi ) * 2. * pi NEW_LINE data = ones ( ( theta . shape [ 0 ] , phi . shape [ 0 ] ) ) NEW_LINE # ▁ define ▁ knots ▁ and ▁ extract ▁ data ▁ values ▁ at ▁ the ▁ knots ENDCOM knotst = theta [ : : 5 ] NEW_LINE knotsp = phi [ : : 5 ] NEW_LINE knotdata = data [ : : 5 , : : 5 ] NEW_LINE # ▁ calculate ▁ spline ▁ coefficients ENDCOM lats , lons = meshgrid ( theta , phi ) NEW_LINE lut_lsq = LSQSphereBivariateSpline ( lats . ravel ( ) , lons . ravel ( ) , data . T . ravel ( ) , knotst , knotsp ) NEW_LINE self . lut_lsq = lut_lsq NEW_LINE self . data = knotdata NEW_LINE self . new_lons , self . new_lats = knotsp , knotst NEW_LINE DEDENT def test_linear_constant ( self ) : NEW_LINE INDENT assert_almost_equal ( self . lut_lsq . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( self . lut_lsq ( self . new_lats , self . new_lons ) , self . data ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE INDENT assert_array_almost_equal ( self . lut_lsq ( [ ] , [ ] ) , np . zeros ( ( 0 , 0 ) ) ) NEW_LINE assert_array_almost_equal ( self . lut_lsq ( [ ] , [ ] , grid = False ) , np . zeros ( ( 0 , ) ) ) NEW_LINE DEDENT DEDENT class TestSmoothSphereBivariateSpline ( TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT theta = array ( [ .25 * pi , .25 * pi , .25 * pi , .5 * pi , .5 * pi , .5 * pi , .75 * pi , .75 * pi , .75 * pi ] ) NEW_LINE phi = array ( [ .5 * pi , pi , 1.5 * pi , .5 * pi , pi , 1.5 * pi , .5 * pi , pi , 1.5 * pi ] ) NEW_LINE r = array ( [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] ) NEW_LINE self . lut = SmoothSphereBivariateSpline ( theta , phi , r , s = 1E10 ) NEW_LINE DEDENT def test_linear_constant ( self ) : NEW_LINE INDENT assert_almost_equal ( self . lut . get_residual ( ) , 0. ) NEW_LINE assert_array_almost_equal ( self . lut ( [ 1 , 1.5 , 2 ] , [ 1 , 1.5 ] ) , [ [ 3 , 3 ] , [ 3 , 3 ] , [ 3 , 3 ] ] ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE INDENT assert_array_almost_equal ( self . lut ( [ ] , [ ] ) , np . zeros ( ( 0 , 0 ) ) ) NEW_LINE assert_array_almost_equal ( self . lut ( [ ] , [ ] , grid = False ) , np . zeros ( ( 0 , ) ) ) NEW_LINE DEDENT DEDENT class TestRectBivariateSpline ( TestCase ) : NEW_LINE INDENT def test_defaults ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y ) , z ) NEW_LINE DEDENT def test_evaluate ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE xi = [ 1 , 2.3 , 5.3 , 0.5 , 3.3 , 1.2 , 3 ] NEW_LINE yi = [ 1 , 3.3 , 1.2 , 4.0 , 5.0 , 1.0 , 3 ] NEW_LINE zi = lut . ev ( xi , yi ) NEW_LINE zi2 = array ( [ lut ( xp , yp ) [ 0 , 0 ] for xp , yp in zip ( xi , yi ) ] ) NEW_LINE assert_almost_equal ( zi , zi2 ) NEW_LINE DEDENT def test_derivatives_grid ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE dx = array ( [ [ 0 , 0 , - 20 , 0 , 0 ] , [ 0 , 0 , 13 , 0 , 0 ] , [ 0 , 0 , 4 , 0 , 0 ] , [ 0 , 0 , - 11 , 0 , 0 ] , [ 0 , 0 , 4 , 0 , 0 ] ] ) / 6. NEW_LINE dy = array ( [ [ 4 , - 1 , 0 , 1 , - 4 ] , [ 4 , - 1 , 0 , 1 , - 4 ] , [ 0 , 1.5 , 0 , - 1.5 , 0 ] , [ 2 , .25 , 0 , - .25 , - 2 ] , [ 4 , - 1 , 0 , 1 , - 4 ] ] ) NEW_LINE dxdy = array ( [ [ 40 , - 25 , 0 , 25 , - 40 ] , [ - 26 , 16.25 , 0 , - 16.25 , 26 ] , [ - 8 , 5 , 0 , - 5 , 8 ] , [ 22 , - 13.75 , 0 , 13.75 , - 22 ] , [ - 8 , 5 , 0 , - 5 , 8 ] ] ) / 6. NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 ) , dx ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dy = 1 ) , dy ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 , dy = 1 ) , dxdy ) NEW_LINE DEDENT def test_derivatives ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE dx = array ( [ 0 , 0 , 2. / 3 , 0 , 0 ] ) NEW_LINE dy = array ( [ 4 , - 1 , 0 , - .25 , - 4 ] ) NEW_LINE dxdy = array ( [ 160 , 65 , 0 , 55 , 32 ] ) / 24. NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 , grid = False ) , dx ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dy = 1 , grid = False ) , dy ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 , dy = 1 , grid = False ) , dxdy ) NEW_LINE DEDENT def test_broadcast ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_allclose ( lut ( x , y ) , lut ( x [ : , None ] , y [ None , : ] , grid = False ) ) NEW_LINE DEDENT DEDENT class TestRectSphereBivariateSpline ( TestCase ) : NEW_LINE INDENT def test_defaults ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y ) , z ) NEW_LINE DEDENT def test_evaluate ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE yi = [ 0.2 , 1 , 2.3 , 2.35 , 3.0 , 3.99 , 5.25 ] NEW_LINE xi = [ 1.5 , 0.4 , 1.1 , 0.45 , 0.2345 , 1. , 0.0001 ] NEW_LINE zi = lut . ev ( xi , yi ) NEW_LINE zi2 = array ( [ lut ( xp , yp ) [ 0 , 0 ] for xp , yp in zip ( xi , yi ) ] ) NEW_LINE assert_almost_equal ( zi , zi2 ) NEW_LINE DEDENT def test_derivatives_grid ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE y = linspace ( 0.02 , 2 * pi - 0.02 , 7 ) NEW_LINE x = linspace ( 0.02 , pi - 0.02 , 7 ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 ) , _numdiff_2d ( lut , x , y , dx = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dphi = 1 ) , _numdiff_2d ( lut , x , y , dy = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 , dphi = 1 ) , _numdiff_2d ( lut , x , y , dx = 1 , dy = 1 , eps = 1e-6 ) , rtol = 1e-3 , atol = 1e-3 ) NEW_LINE DEDENT def test_derivatives ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE y = linspace ( 0.02 , 2 * pi - 0.02 , 7 ) NEW_LINE x = linspace ( 0.02 , pi - 0.02 , 7 ) NEW_LINE assert_equal ( lut ( x , y , dtheta = 1 , grid = False ) . shape , x . shape ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 , grid = False ) , _numdiff_2d ( lambda x , y : lut ( x , y , grid = False ) , x , y , dx = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dphi = 1 , grid = False ) , _numdiff_2d ( lambda x , y : lut ( x , y , grid = False ) , x , y , dy = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 , dphi = 1 , grid = False ) , _numdiff_2d ( lambda x , y : lut ( x , y , grid = False ) , x , y , dx = 1 , dy = 1 , eps = 1e-6 ) , rtol = 1e-3 , atol = 1e-3 ) NEW_LINE DEDENT DEDENT def _numdiff_2d ( func , x , y , dx = 0 , dy = 0 , eps = 1e-8 ) : NEW_LINE INDENT if dx == 0 and dy == 0 : NEW_LINE INDENT return func ( x , y ) NEW_LINE DEDENT elif dx == 1 and dy == 0 : NEW_LINE INDENT return ( func ( x + eps , y ) - func ( x - eps , y ) ) / ( 2 * eps ) NEW_LINE DEDENT elif dx == 0 and dy == 1 : NEW_LINE INDENT return ( func ( x , y + eps ) - func ( x , y - eps ) ) / ( 2 * eps ) NEW_LINE DEDENT elif dx == 1 and dy == 1 : NEW_LINE INDENT return ( func ( x + eps , y + eps ) - func ( x - eps , y + eps ) - func ( x + eps , y - eps ) + func ( x - eps , y - eps ) ) / ( 2 * eps ) ** 2 NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " invalid ▁ derivative ▁ order " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT run_module_suite ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="carragom/modoboa/tree/master/modoboa/admin/models/domain_alias.py"> """ Models ▁ related ▁ to ▁ domain ▁ aliases ▁ management . """ NEW_LINE from django . db import models NEW_LINE from django . utils . encoding import python_2_unicode_compatible , smart_text NEW_LINE from django . utils . translation import ugettext as _ , ugettext_lazy NEW_LINE from django . contrib . contenttypes . fields import GenericRelation NEW_LINE from reversion import revisions as reversion NEW_LINE from modoboa . core import models as core_models NEW_LINE from modoboa . core import signals as core_signals NEW_LINE from modoboa . lib . exceptions import BadRequest , Conflict NEW_LINE from . base import AdminObject NEW_LINE from . domain import Domain NEW_LINE class DomainAliasManager ( models . Manager ) : NEW_LINE INDENT def get_for_admin ( self , admin ) : NEW_LINE INDENT """ Return ▁ the ▁ domain ▁ aliases ▁ belonging ▁ to ▁ this ▁ admin . STRNEWLINE STRNEWLINE ▁ The ▁ result ▁ is ▁ a ▁ ` ` QuerySet ` ` ▁ object , ▁ so ▁ this ▁ function ▁ can ▁ be ▁ used STRNEWLINE ▁ to ▁ fill ▁ ` ` ModelChoiceField ` ` ▁ objects . STRNEWLINE ▁ """ NEW_LINE if admin . is_superuser : NEW_LINE INDENT return self . get_queryset ( ) NEW_LINE DEDENT return self . get_queryset ( ) . filter ( owners__user = admin ) NEW_LINE DEDENT DEDENT @ python_2_unicode_compatible NEW_LINE class DomainAlias ( AdminObject ) : NEW_LINE INDENT """ Domain ▁ aliases . """ NEW_LINE name = models . CharField ( ugettext_lazy ( " name " ) , max_length = 100 , unique = True , help_text = ugettext_lazy ( " The ▁ alias ▁ name " ) ) NEW_LINE target = models . ForeignKey ( Domain , verbose_name = ugettext_lazy ( ' target ' ) , help_text = ugettext_lazy ( " The ▁ domain ▁ this ▁ alias ▁ points ▁ to " ) ) NEW_LINE enabled = models . BooleanField ( ugettext_lazy ( ' enabled ' ) , help_text = ugettext_lazy ( " Check ▁ to ▁ activate ▁ this ▁ alias " ) , default = True ) NEW_LINE owners = GenericRelation ( core_models . ObjectAccess ) NEW_LINE objects = DomainAliasManager ( ) NEW_LINE class Meta : NEW_LINE INDENT permissions = ( ( " view _ domaliases " , " View ▁ domain ▁ aliases " ) , ) NEW_LINE app_label = " admin " NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return smart_text ( self . name ) NEW_LINE DEDENT def from_csv ( self , user , row ) : NEW_LINE INDENT """ Create ▁ a ▁ domain ▁ alias ▁ from ▁ a ▁ CSV ▁ row STRNEWLINE STRNEWLINE ▁ Expected ▁ format : ▁ [ " domainalias " , ▁ domain ▁ alias ▁ name , ▁ targeted ▁ domain , ▁ enabled ] STRNEWLINE STRNEWLINE ▁ : param ▁ user : ▁ a ▁ ` ` User ` ` ▁ object STRNEWLINE ▁ : param ▁ row : ▁ a ▁ list ▁ containing ▁ the ▁ alias ▁ definition STRNEWLINE ▁ """ NEW_LINE if len ( row ) < 4 : NEW_LINE INDENT raise BadRequest ( _ ( " Invalid ▁ line " ) ) NEW_LINE DEDENT self . name = row [ 1 ] . strip ( ) NEW_LINE for model in [ DomainAlias , Domain ] : NEW_LINE INDENT if model . objects . filter ( name = self . name ) . exists ( ) : NEW_LINE INDENT raise Conflict NEW_LINE DEDENT DEDENT domname = row [ 2 ] . strip ( ) NEW_LINE try : NEW_LINE INDENT self . target = Domain . objects . get ( name = domname ) NEW_LINE DEDENT except Domain . DoesNotExist : NEW_LINE INDENT raise BadRequest ( _ ( " Unknown ▁ domain ▁ % s " ) % domname ) NEW_LINE DEDENT core_signals . can_create_object . send ( sender = " import " , context = self . target , object_type = " domain _ aliases " ) NEW_LINE self . enabled = row [ 3 ] . strip ( ) in [ " True " , "1" , " yes " , " y " ] NEW_LINE self . save ( creator = user ) NEW_LINE DEDENT def to_csv ( self , csvwriter ) : NEW_LINE INDENT """ Export ▁ a ▁ domain ▁ alias ▁ using ▁ CSV ▁ format STRNEWLINE STRNEWLINE ▁ : param ▁ csvwriter : ▁ a ▁ ` ` csv . writer ` ` ▁ object STRNEWLINE ▁ """ NEW_LINE csvwriter . writerow ( [ " domainalias " , self . name , self . target . name , self . enabled ] ) NEW_LINE DEDENT DEDENT reversion . register ( DomainAlias ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="michalkurka/h2o-3/tree/master/h2o-py/tests/testdir_algos/pca/pyunit_pubdev_4961_pca_implementations.py"> from __future__ import print_function NEW_LINE from builtins import str NEW_LINE from builtins import range NEW_LINE import sys NEW_LINE sys . path . insert ( 1 , " . . / . . / . . / " ) NEW_LINE import h2o NEW_LINE from tests import pyunit_utils NEW_LINE from h2o . estimators . pca import H2OPrincipalComponentAnalysisEstimator as H2OPCA NEW_LINE def pca_arrests ( ) : NEW_LINE INDENT print ( " Importing ▁ USArrests . csv ▁ data . . . " ) NEW_LINE arrestsH2O = h2o . upload_file ( pyunit_utils . locate ( " smalldata / pca _ test / USArrests . csv " ) ) NEW_LINE print ( " Testing ▁ to ▁ see ▁ whether ▁ the ▁ trained ▁ PCA ▁ are ▁ essentially ▁ the ▁ same ▁ using ▁ different ▁ implementation . . . " ) NEW_LINE eigenvector_standard = None NEW_LINE for impl in [ " MTJ _ EVD _ DENSEMATRIX " , " MTJ _ EVD _ SYMMMATRIX " , " MTJ _ SVD _ DENSEMATRIX " , " JAMA " ] : NEW_LINE INDENT print ( " Run ▁ PCA ▁ with ▁ implementation : ▁ " + impl ) NEW_LINE model = H2OPCA ( k = 4 , pca_impl = impl , seed = 1234 ) NEW_LINE model . train ( x = list ( range ( 4 ) ) , training_frame = arrestsH2O ) NEW_LINE eigenvectors = model . _model_json [ " output " ] [ " eigenvectors " ] NEW_LINE if eigenvector_standard is not None : NEW_LINE # ▁ Compare ▁ to ▁ see ▁ if ▁ they ▁ are ▁ fundamentally ▁ the ▁ same ENDCOM INDENT pyunit_utils . assert_H2OTwoDimTable_equal ( eigenvector_standard , eigenvectors , model . _model_json [ " output " ] [ " names " ] , tolerance = 1e-6 , check_sign = True , check_all = False ) NEW_LINE DEDENT else : NEW_LINE INDENT eigenvector_standard = eigenvectors NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT pyunit_utils . standalone_test ( pca_arrests ) NEW_LINE DEDENT else : NEW_LINE INDENT pca_arrests ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="srvg/ansible/tree/master/lib/ansible/modules/network/netvisor/pn_vtep.py"> # ! / usr / bin / python ENDCOM # ▁ Copyright : ▁ ( c ) ▁ 2018 , ▁ Pluribus ▁ Networks ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ v3.0 + ▁ ( see ▁ COPYING ▁ or ▁ https : / / www . gnu . org / licenses / gpl - 3.0 . txt ) ENDCOM from __future__ import absolute_import , division , print_function NEW_LINE __metaclass__ = type NEW_LINE ANSIBLE_METADATA = { ' metadata _ version ' : '1.1' , ' status ' : [ ' preview ' ] , ' supported _ by ' : ' community ' } NEW_LINE DOCUMENTATION = """ STRNEWLINE - - - STRNEWLINE module : ▁ pn _ vtep STRNEWLINE author : ▁ " Pluribus ▁ Networks ▁ ( @ rajaspachipulusu17 ) " STRNEWLINE version _ added : ▁ " 2.9 " STRNEWLINE short _ description : ▁ CLI ▁ command ▁ to ▁ create / delete ▁ vtep STRNEWLINE description : STRNEWLINE ▁ ▁ - ▁ This ▁ module ▁ can ▁ be ▁ used ▁ to ▁ create ▁ a ▁ vtep ▁ and ▁ delete ▁ a ▁ vtep . STRNEWLINE options : STRNEWLINE ▁ ▁ pn _ cliswitch : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Target ▁ switch ▁ to ▁ run ▁ the ▁ CLI ▁ on . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ vtep ▁ configuration ▁ command . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ choices : ▁ [ ' present ' , ▁ ' absent ' ] STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ ' present ' STRNEWLINE ▁ ▁ pn _ name : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ vtep ▁ name . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ ip : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Primary ▁ IP ▁ address . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ vrouter _ name : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name ▁ of ▁ the ▁ vrouter ▁ service . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ virtual _ ip : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Virtual / Secondary ▁ IP ▁ address . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ location : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ switch ▁ name . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ switch _ in _ cluster : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Tells ▁ whether ▁ switch ▁ in ▁ cluster ▁ or ▁ not . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ True STRNEWLINE """ NEW_LINE EXAMPLES = """ STRNEWLINE - ▁ name : ▁ create ▁ vtep STRNEWLINE ▁ ▁ pn _ vtep : STRNEWLINE ▁ ▁ ▁ ▁ pn _ cliswitch : ▁ ' sw01 ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ name : ▁ ' foo ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ vrouter _ name : ▁ ' foo - vrouter ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ ip : ▁ ' 22.22.22.2 ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ location : ▁ ' sw01 ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ virtual _ ip : ▁ " 22.22.22.1 " STRNEWLINE STRNEWLINE - ▁ name : ▁ delete ▁ vtep STRNEWLINE ▁ ▁ pn _ vtep : STRNEWLINE ▁ ▁ ▁ ▁ pn _ cliswitch : ▁ ' sw01 ' STRNEWLINE ▁ ▁ ▁ ▁ state : ▁ ' absent ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ name : ▁ ' foo ' STRNEWLINE """ NEW_LINE RETURN = """ STRNEWLINE command : STRNEWLINE ▁ ▁ description : ▁ the ▁ CLI ▁ command ▁ run ▁ on ▁ the ▁ target ▁ node . STRNEWLINE ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ type : ▁ str STRNEWLINE stdout : STRNEWLINE ▁ ▁ description : ▁ set ▁ of ▁ responses ▁ from ▁ the ▁ vtep ▁ command . STRNEWLINE ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ type : ▁ list STRNEWLINE stderr : STRNEWLINE ▁ ▁ description : ▁ set ▁ of ▁ error ▁ responses ▁ from ▁ the ▁ vtep ▁ command . STRNEWLINE ▁ ▁ returned : ▁ on ▁ error STRNEWLINE ▁ ▁ type : ▁ list STRNEWLINE changed : STRNEWLINE ▁ ▁ description : ▁ indicates ▁ whether ▁ the ▁ CLI ▁ caused ▁ changes ▁ on ▁ the ▁ target . STRNEWLINE ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ type : ▁ bool STRNEWLINE """ NEW_LINE from ansible . module_utils . basic import AnsibleModule NEW_LINE from ansible . module_utils . network . netvisor . pn_nvos import pn_cli , run_cli NEW_LINE from ansible . module_utils . network . netvisor . netvisor import run_commands NEW_LINE def check_cli ( module , cli ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ method ▁ checks ▁ for ▁ idempotency ▁ using ▁ the ▁ vtep - show ▁ command . STRNEWLINE ▁ If ▁ a ▁ name ▁ exists , ▁ return ▁ True ▁ if ▁ name ▁ exists ▁ else ▁ False . STRNEWLINE ▁ : param ▁ module : ▁ The ▁ Ansible ▁ module ▁ to ▁ fetch ▁ input ▁ parameters STRNEWLINE ▁ : param ▁ cli : ▁ The ▁ CLI ▁ string STRNEWLINE ▁ """ NEW_LINE name = module . params [ ' pn _ name ' ] NEW_LINE cli += ' ▁ vtep - show ▁ format ▁ name ▁ no - show - headers ' NEW_LINE out = run_commands ( module , cli ) [ 1 ] NEW_LINE if out : NEW_LINE INDENT out = out . split ( ) NEW_LINE DEDENT return True if name in out else False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT """ ▁ This ▁ section ▁ is ▁ for ▁ arguments ▁ parsing ▁ """ NEW_LINE state_map = dict ( present = ' vtep - create ' , absent = ' vtep - delete ' ) NEW_LINE argument_spec = dict ( pn_cliswitch = dict ( required = False , type = ' str ' ) , state = dict ( required = False , type = ' str ' , choices = state_map . keys ( ) , default = ' present ' ) , pn_name = dict ( required = False , type = ' str ' ) , pn_ip = dict ( required = False , type = ' str ' ) , pn_vrouter_name = dict ( required = False , type = ' str ' ) , pn_virtual_ip = dict ( required = False , type = ' str ' ) , pn_location = dict ( required = False , type = ' str ' ) , pn_switch_in_cluster = dict ( required = False , type = ' bool ' , default = ' True ' ) ) NEW_LINE module = AnsibleModule ( argument_spec = argument_spec , required_if = ( [ " state " , " present " , [ " pn _ name " , " pn _ ip " , " pn _ vrouter _ name " , " pn _ location " ] ] , [ " state " , " absent " , [ " pn _ name " ] ] , ) , ) NEW_LINE # ▁ Accessing ▁ the ▁ arguments ENDCOM cliswitch = module . params [ ' pn _ cliswitch ' ] NEW_LINE state = module . params [ ' state ' ] NEW_LINE name = module . params [ ' pn _ name ' ] NEW_LINE ip = module . params [ ' pn _ ip ' ] NEW_LINE vrouter_name = module . params [ ' pn _ vrouter _ name ' ] NEW_LINE virtual_ip = module . params [ ' pn _ virtual _ ip ' ] NEW_LINE location = module . params [ ' pn _ location ' ] NEW_LINE switch_in_cluster = module . params [ ' pn _ switch _ in _ cluster ' ] NEW_LINE if switch_in_cluster and not virtual_ip and state == ' present ' : NEW_LINE INDENT module . exit_json ( failed = True , msg = ' virtual ▁ ip ▁ is ▁ required ▁ when ▁ switch ▁ is ▁ in ▁ cluster ' ) NEW_LINE DEDENT command = state_map [ state ] NEW_LINE # ▁ Building ▁ the ▁ CLI ▁ command ▁ string ENDCOM cli = pn_cli ( module , cliswitch ) NEW_LINE NAME_EXISTS = check_cli ( module , cli ) NEW_LINE cli += ' ▁ % s ▁ name ▁ % s ▁ ' % ( command , name ) NEW_LINE if command == ' vtep - delete ' : NEW_LINE INDENT if NAME_EXISTS is False : NEW_LINE INDENT module . exit_json ( skipped = True , msg = ' vtep ▁ with ▁ name ▁ % s ▁ does ▁ not ▁ exist ' % name ) NEW_LINE DEDENT DEDENT if command == ' vtep - create ' : NEW_LINE INDENT if NAME_EXISTS is True : NEW_LINE INDENT module . exit_json ( skipped = True , msg = ' vtpe ▁ with ▁ name ▁ % s ▁ already ▁ exists ' % name ) NEW_LINE DEDENT cli += ' vrouter - name ▁ % s ▁ ' % vrouter_name NEW_LINE cli += ' ip ▁ % s ▁ ' % ip NEW_LINE cli += ' location ▁ % s ▁ ' % location NEW_LINE if virtual_ip : NEW_LINE INDENT cli += ' virtual - ip ▁ % s ▁ ' % virtual_ip NEW_LINE DEDENT DEDENT run_cli ( module , cli , state_map ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="rpmcpp/Audacity/tree/master/lib-src/lv2/lv2/plugins/eg03-metro.lv2/waflib/Tools/vala.py"> # ! ▁ / usr / bin / env ▁ python ENDCOM # ▁ encoding : ▁ utf - 8 ENDCOM # ▁ WARNING ! ▁ Do ▁ not ▁ edit ! ▁ http : / / waf . googlecode . com / git / docs / wafbook / single . html # _ obtaining _ the _ waf _ file ENDCOM import os . path , shutil , re NEW_LINE from waflib import Context , Task , Utils , Logs , Options , Errors NEW_LINE from waflib . TaskGen import extension , taskgen_method NEW_LINE from waflib . Configure import conf NEW_LINE class valac ( Task . Task ) : NEW_LINE INDENT vars = [ " VALAC " , " VALAC _ VERSION " , " VALAFLAGS " ] NEW_LINE ext_out = [ ' . h ' ] NEW_LINE def run ( self ) : NEW_LINE INDENT cmd = [ self . env [ ' VALAC ' ] ] + self . env [ ' VALAFLAGS ' ] NEW_LINE cmd . extend ( [ a . abspath ( ) for a in self . inputs ] ) NEW_LINE ret = self . exec_command ( cmd , cwd = self . outputs [ 0 ] . parent . abspath ( ) ) NEW_LINE if ret : NEW_LINE INDENT return ret NEW_LINE DEDENT for x in self . outputs : NEW_LINE INDENT if id ( x . parent ) != id ( self . outputs [ 0 ] . parent ) : NEW_LINE INDENT shutil . move ( self . outputs [ 0 ] . parent . abspath ( ) + os . sep + x . name , x . abspath ( ) ) NEW_LINE DEDENT DEDENT if self . generator . dump_deps_node : NEW_LINE INDENT self . generator . dump_deps_node . write ( ' \n ' . join ( self . generator . packages ) ) NEW_LINE DEDENT return ret NEW_LINE DEDENT DEDENT valac = Task . update_outputs ( valac ) NEW_LINE @ taskgen_method NEW_LINE def init_vala_task ( self ) : NEW_LINE INDENT self . profile = getattr ( self , ' profile ' , ' gobject ' ) NEW_LINE if self . profile == ' gobject ' : NEW_LINE INDENT self . uselib = Utils . to_list ( getattr ( self , ' uselib ' , [ ] ) ) NEW_LINE if not ' GOBJECT ' in self . uselib : NEW_LINE INDENT self . uselib . append ( ' GOBJECT ' ) NEW_LINE DEDENT DEDENT def addflags ( flags ) : NEW_LINE INDENT self . env . append_value ( ' VALAFLAGS ' , flags ) NEW_LINE DEDENT if self . profile : NEW_LINE INDENT addflags ( ' - - profile = % s ' % self . profile ) NEW_LINE DEDENT if hasattr ( self , ' threading ' ) : NEW_LINE INDENT if self . profile == ' gobject ' : NEW_LINE INDENT if not ' GTHREAD ' in self . uselib : NEW_LINE INDENT self . uselib . append ( ' GTHREAD ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Logs . warn ( " Profile ▁ % s ▁ means ▁ no ▁ threading ▁ support " % self . profile ) NEW_LINE self . threading = False NEW_LINE DEDENT if self . threading : NEW_LINE INDENT addflags ( ' - - threading ' ) NEW_LINE DEDENT DEDENT valatask = self . valatask NEW_LINE self . is_lib = ' cprogram ' not in self . features NEW_LINE if self . is_lib : NEW_LINE INDENT addflags ( ' - - library = % s ' % self . target ) NEW_LINE h_node = self . path . find_or_declare ( ' % s . h ' % self . target ) NEW_LINE valatask . outputs . append ( h_node ) NEW_LINE addflags ( ' - - header = % s ' % h_node . name ) NEW_LINE valatask . outputs . append ( self . path . find_or_declare ( ' % s . vapi ' % self . target ) ) NEW_LINE if getattr ( self , ' gir ' , None ) : NEW_LINE INDENT gir_node = self . path . find_or_declare ( ' % s . gir ' % self . gir ) NEW_LINE addflags ( ' - - gir = % s ' % gir_node . name ) NEW_LINE valatask . outputs . append ( gir_node ) NEW_LINE DEDENT DEDENT self . vala_target_glib = getattr ( self , ' vala _ target _ glib ' , getattr ( Options . options , ' vala _ target _ glib ' , None ) ) NEW_LINE if self . vala_target_glib : NEW_LINE INDENT addflags ( ' - - target - glib = % s ' % self . vala_target_glib ) NEW_LINE DEDENT addflags ( [ ' - - define = % s ' % x for x in getattr ( self , ' vala _ defines ' , [ ] ) ] ) NEW_LINE packages_private = Utils . to_list ( getattr ( self , ' packages _ private ' , [ ] ) ) NEW_LINE addflags ( [ ' - - pkg = % s ' % x for x in packages_private ] ) NEW_LINE def _get_api_version ( ) : NEW_LINE INDENT api_version = '1.0' NEW_LINE if hasattr ( Context . g_module , ' API _ VERSION ' ) : NEW_LINE INDENT version = Context . g_module . API_VERSION . split ( " . " ) NEW_LINE if version [ 0 ] == "0" : NEW_LINE INDENT api_version = "0 . " + version [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT api_version = version [ 0 ] + " . 0" NEW_LINE DEDENT DEDENT return api_version NEW_LINE DEDENT self . includes = Utils . to_list ( getattr ( self , ' includes ' , [ ] ) ) NEW_LINE self . uselib = self . to_list ( getattr ( self , ' uselib ' , [ ] ) ) NEW_LINE valatask . install_path = getattr ( self , ' install _ path ' , ' ' ) NEW_LINE valatask . vapi_path = getattr ( self , ' vapi _ path ' , ' $ { DATAROOTDIR } / vala / vapi ' ) NEW_LINE valatask . pkg_name = getattr ( self , ' pkg _ name ' , self . env [ ' PACKAGE ' ] ) NEW_LINE valatask . header_path = getattr ( self , ' header _ path ' , ' $ { INCLUDEDIR } / % s - % s ' % ( valatask . pkg_name , _get_api_version ( ) ) ) NEW_LINE valatask . install_binding = getattr ( self , ' install _ binding ' , True ) NEW_LINE self . packages = packages = Utils . to_list ( getattr ( self , ' packages ' , [ ] ) ) NEW_LINE self . vapi_dirs = vapi_dirs = Utils . to_list ( getattr ( self , ' vapi _ dirs ' , [ ] ) ) NEW_LINE includes = [ ] NEW_LINE if hasattr ( self , ' use ' ) : NEW_LINE INDENT local_packages = Utils . to_list ( self . use ) [ : ] NEW_LINE seen = [ ] NEW_LINE while len ( local_packages ) > 0 : NEW_LINE INDENT package = local_packages . pop ( ) NEW_LINE if package in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . append ( package ) NEW_LINE try : NEW_LINE INDENT package_obj = self . bld . get_tgen_by_name ( package ) NEW_LINE DEDENT except Errors . WafError : NEW_LINE INDENT continue NEW_LINE DEDENT package_name = package_obj . target NEW_LINE package_node = package_obj . path NEW_LINE package_dir = package_node . path_from ( self . path ) NEW_LINE for task in package_obj . tasks : NEW_LINE INDENT for output in task . outputs : NEW_LINE INDENT if output . name == package_name + " . vapi " : NEW_LINE INDENT valatask . set_run_after ( task ) NEW_LINE if package_name not in packages : NEW_LINE INDENT packages . append ( package_name ) NEW_LINE DEDENT if package_dir not in vapi_dirs : NEW_LINE INDENT vapi_dirs . append ( package_dir ) NEW_LINE DEDENT if package_dir not in includes : NEW_LINE INDENT includes . append ( package_dir ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if hasattr ( package_obj , ' use ' ) : NEW_LINE INDENT lst = self . to_list ( package_obj . use ) NEW_LINE lst . reverse ( ) NEW_LINE local_packages = [ pkg for pkg in lst if pkg not in seen ] + local_packages NEW_LINE DEDENT DEDENT DEDENT addflags ( [ ' - - pkg = % s ' % p for p in packages ] ) NEW_LINE for vapi_dir in vapi_dirs : NEW_LINE INDENT v_node = self . path . find_dir ( vapi_dir ) NEW_LINE if not v_node : NEW_LINE INDENT Logs . warn ( ' Unable ▁ to ▁ locate ▁ Vala ▁ API ▁ directory : ▁ % r ' % vapi_dir ) NEW_LINE DEDENT else : NEW_LINE INDENT addflags ( ' - - vapidir = % s ' % v_node . abspath ( ) ) NEW_LINE addflags ( ' - - vapidir = % s ' % v_node . get_bld ( ) . abspath ( ) ) NEW_LINE DEDENT DEDENT self . dump_deps_node = None NEW_LINE if self . is_lib and self . packages : NEW_LINE INDENT self . dump_deps_node = self . path . find_or_declare ( ' % s . deps ' % self . target ) NEW_LINE valatask . outputs . append ( self . dump_deps_node ) NEW_LINE DEDENT self . includes . append ( self . bld . srcnode . abspath ( ) ) NEW_LINE self . includes . append ( self . bld . bldnode . abspath ( ) ) NEW_LINE for include in includes : NEW_LINE INDENT try : NEW_LINE INDENT self . includes . append ( self . path . find_dir ( include ) . abspath ( ) ) NEW_LINE self . includes . append ( self . path . find_dir ( include ) . get_bld ( ) . abspath ( ) ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT Logs . warn ( " Unable ▁ to ▁ locate ▁ include ▁ directory : ▁ ' % s ' " % include ) NEW_LINE DEDENT DEDENT if self . is_lib and valatask . install_binding : NEW_LINE INDENT headers_list = [ o for o in valatask . outputs if o . suffix ( ) == " . h " ] NEW_LINE try : NEW_LINE INDENT self . install_vheader . source = headers_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_vheader = self . bld . install_files ( valatask . header_path , headers_list , self . env ) NEW_LINE DEDENT vapi_list = [ o for o in valatask . outputs if ( o . suffix ( ) in ( " . vapi " , " . deps " ) ) ] NEW_LINE try : NEW_LINE INDENT self . install_vapi . source = vapi_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_vapi = self . bld . install_files ( valatask . vapi_path , vapi_list , self . env ) NEW_LINE DEDENT gir_list = [ o for o in valatask . outputs if o . suffix ( ) == ' . gir ' ] NEW_LINE try : NEW_LINE INDENT self . install_gir . source = gir_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_gir = self . bld . install_files ( getattr ( self , ' gir _ path ' , ' $ { DATAROOTDIR } / gir - 1.0' ) , gir_list , self . env ) NEW_LINE DEDENT DEDENT DEDENT @ extension ( ' . vala ' , ' . gs ' ) NEW_LINE def vala_file ( self , node ) : NEW_LINE INDENT try : NEW_LINE INDENT valatask = self . valatask NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT valatask = self . valatask = self . create_task ( ' valac ' ) NEW_LINE self . init_vala_task ( ) NEW_LINE DEDENT valatask . inputs . append ( node ) NEW_LINE c_node = node . change_ext ( ' . c ' ) NEW_LINE valatask . outputs . append ( c_node ) NEW_LINE self . source . append ( c_node ) NEW_LINE DEDENT @ conf NEW_LINE def find_valac ( self , valac_name , min_version ) : NEW_LINE INDENT valac = self . find_program ( valac_name , var = ' VALAC ' ) NEW_LINE try : NEW_LINE INDENT output = self . cmd_and_log ( valac + ' ▁ - - version ' ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT valac_version = None NEW_LINE DEDENT else : NEW_LINE INDENT ver = re . search ( r ' \d + . \d + . \d + ' , output ) . group ( 0 ) . split ( ' . ' ) NEW_LINE valac_version = tuple ( [ int ( x ) for x in ver ] ) NEW_LINE DEDENT self . msg ( ' Checking ▁ for ▁ % s ▁ version ▁ > = ▁ % r ' % ( valac_name , min_version ) , valac_version , valac_version and valac_version >= min_version ) NEW_LINE if valac and valac_version < min_version : NEW_LINE INDENT self . fatal ( " % s ▁ version ▁ % r ▁ is ▁ too ▁ old , ▁ need ▁ > = ▁ % r " % ( valac_name , valac_version , min_version ) ) NEW_LINE DEDENT self . env [ ' VALAC _ VERSION ' ] = valac_version NEW_LINE return valac NEW_LINE DEDENT @ conf NEW_LINE def check_vala ( self , min_version = ( 0 , 8 , 0 ) , branch = None ) : NEW_LINE INDENT if not branch : NEW_LINE INDENT branch = min_version [ : 2 ] NEW_LINE DEDENT try : NEW_LINE INDENT find_valac ( self , ' valac - % d . % d ' % ( branch [ 0 ] , branch [ 1 ] ) , min_version ) NEW_LINE DEDENT except self . errors . ConfigurationError : NEW_LINE INDENT find_valac ( self , ' valac ' , min_version ) NEW_LINE DEDENT DEDENT @ conf NEW_LINE def check_vala_deps ( self ) : NEW_LINE INDENT if not self . env [ ' HAVE _ GOBJECT ' ] : NEW_LINE INDENT pkg_args = { ' package ' : ' gobject - 2.0' , ' uselib _ store ' : ' GOBJECT ' , ' args ' : ' - - cflags ▁ - - libs ' } NEW_LINE if getattr ( Options . options , ' vala _ target _ glib ' , None ) : NEW_LINE INDENT pkg_args [ ' atleast _ version ' ] = Options . options . vala_target_glib NEW_LINE DEDENT self . check_cfg ( ** pkg_args ) NEW_LINE DEDENT if not self . env [ ' HAVE _ GTHREAD ' ] : NEW_LINE INDENT pkg_args = { ' package ' : ' gthread - 2.0' , ' uselib _ store ' : ' GTHREAD ' , ' args ' : ' - - cflags ▁ - - libs ' } NEW_LINE if getattr ( Options . options , ' vala _ target _ glib ' , None ) : NEW_LINE INDENT pkg_args [ ' atleast _ version ' ] = Options . options . vala_target_glib NEW_LINE DEDENT self . check_cfg ( ** pkg_args ) NEW_LINE DEDENT DEDENT def configure ( self ) : NEW_LINE INDENT self . load ( ' gnu _ dirs ' ) NEW_LINE self . check_vala_deps ( ) NEW_LINE self . check_vala ( ) NEW_LINE self . env . VALAFLAGS = [ ' - C ' , ' - - quiet ' ] NEW_LINE DEDENT def options ( opt ) : NEW_LINE INDENT opt . load ( ' gnu _ dirs ' ) NEW_LINE valaopts = opt . add_option_group ( ' Vala ▁ Compiler ▁ Options ' ) NEW_LINE valaopts . add_option ( ' - - vala - target - glib ' , default = None , dest = ' vala _ target _ glib ' , metavar = ' MAJOR . MINOR ' , help = ' Target ▁ version ▁ of ▁ glib ▁ for ▁ Vala ▁ GObject ▁ code ▁ generation ' ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="ryfeus/lambda-packs/tree/master/Skimage_numpy/source/PIL/JpegImagePlugin.py"> # ▁ The ▁ Python ▁ Imaging ▁ Library . ENDCOM # ▁ $ Id $ ENDCOM # ▁ JPEG ▁ ( JFIF ) ▁ file ▁ handling ENDCOM # ▁ See ▁ " Digital ▁ Compression ▁ and ▁ Coding ▁ of ▁ Continuous - Tone ▁ Still ▁ Images , ENDCOM # ▁ Part ▁ 1 , ▁ Requirements ▁ and ▁ Guidelines " ▁ ( CCITT ▁ T . 81 ▁ / ▁ ISO ▁ 10918-1 ) ENDCOM # ▁ History : ENDCOM # ▁ 1995-09-09 ▁ fl ▁ Created ENDCOM # ▁ 1995-09-13 ▁ fl ▁ Added ▁ full ▁ parser ENDCOM # ▁ 1996-03-25 ▁ fl ▁ Added ▁ hack ▁ to ▁ use ▁ the ▁ IJG ▁ command ▁ line ▁ utilities ENDCOM # ▁ 1996-05-05 ▁ fl ▁ Workaround ▁ Photoshop ▁ 2.5 ▁ CMYK ▁ polarity ▁ bug ENDCOM # ▁ 1996-05-28 ▁ fl ▁ Added ▁ draft ▁ support , ▁ JFIF ▁ version ▁ ( 0.1 ) ENDCOM # ▁ 1996-12-30 ▁ fl ▁ Added ▁ encoder ▁ options , ▁ added ▁ progression ▁ property ▁ ( 0.2 ) ENDCOM # ▁ 1997-08-27 ▁ fl ▁ Save ▁ mode ▁ 1 ▁ images ▁ as ▁ BW ▁ ( 0.3 ) ENDCOM # ▁ 1998-07-12 ▁ fl ▁ Added ▁ YCbCr ▁ to ▁ draft ▁ and ▁ save ▁ methods ▁ ( 0.4 ) ENDCOM # ▁ 1998-10-19 ▁ fl ▁ Don ' t ▁ hang ▁ on ▁ files ▁ using ▁ 16 - bit ▁ DQT ' s ▁ ( 0.4.1 ) ENDCOM # ▁ 2001-04-16 ▁ fl ▁ Extract ▁ DPI ▁ settings ▁ from ▁ JFIF ▁ files ▁ ( 0.4.2 ) ENDCOM # ▁ 2002-07-01 ▁ fl ▁ Skip ▁ pad ▁ bytes ▁ before ▁ markers ; ▁ identify ▁ Exif ▁ files ▁ ( 0.4.3 ) ENDCOM # ▁ 2003-04-25 ▁ fl ▁ Added ▁ experimental ▁ EXIF ▁ decoder ▁ ( 0.5 ) ENDCOM # ▁ 2003-06-06 ▁ fl ▁ Added ▁ experimental ▁ EXIF ▁ GPSinfo ▁ decoder ENDCOM # ▁ 2003-09-13 ▁ fl ▁ Extract ▁ COM ▁ markers ENDCOM # ▁ 2009-09-06 ▁ fl ▁ Added ▁ icc _ profile ▁ support ▁ ( from ▁ Florian ▁ Hoech ) ENDCOM # ▁ 2009-03-06 ▁ fl ▁ Changed ▁ CMYK ▁ handling ; ▁ always ▁ use ▁ Adobe ▁ polarity ▁ ( 0.6 ) ENDCOM # ▁ 2009-03-08 ▁ fl ▁ Added ▁ subsampling ▁ support ▁ ( from ▁ Justin ▁ Huff ) . ENDCOM # ▁ Copyright ▁ ( c ) ▁ 1997-2003 ▁ by ▁ Secret ▁ Labs ▁ AB . ENDCOM # ▁ Copyright ▁ ( c ) ▁ 1995-1996 ▁ by ▁ Fredrik ▁ Lundh . ENDCOM # ▁ See ▁ the ▁ README ▁ file ▁ for ▁ information ▁ on ▁ usage ▁ and ▁ redistribution . ENDCOM from __future__ import print_function NEW_LINE import array NEW_LINE import struct NEW_LINE import io NEW_LINE import warnings NEW_LINE from struct import unpack_from NEW_LINE from PIL import Image , ImageFile , TiffImagePlugin , _binary NEW_LINE from PIL . JpegPresets import presets NEW_LINE from PIL . _util import isStringType NEW_LINE i8 = _binary . i8 NEW_LINE o8 = _binary . o8 NEW_LINE i16 = _binary . i16be NEW_LINE i32 = _binary . i32be NEW_LINE __version__ = "0.6" NEW_LINE # ▁ Parser ENDCOM def Skip ( self , marker ) : NEW_LINE INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE ImageFile . _safe_read ( self . fp , n ) NEW_LINE DEDENT def APP ( self , marker ) : NEW_LINE # ▁ Application ▁ marker . ▁ Store ▁ these ▁ in ▁ the ▁ APP ▁ dictionary . ENDCOM # ▁ Also ▁ look ▁ for ▁ well - known ▁ application ▁ markers . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE app = " APP % d " % ( marker & 15 ) NEW_LINE self . app [ app ] = s # ▁ compatibility ENDCOM NEW_LINE self . applist . append ( ( app , s ) ) NEW_LINE if marker == 0xFFE0 and s [ : 4 ] == b " JFIF " : NEW_LINE # ▁ extract ▁ JFIF ▁ information ENDCOM INDENT self . info [ " jfif " ] = version = i16 ( s , 5 ) # ▁ version ENDCOM NEW_LINE self . info [ " jfif _ version " ] = divmod ( version , 256 ) NEW_LINE # ▁ extract ▁ JFIF ▁ properties ENDCOM try : NEW_LINE INDENT jfif_unit = i8 ( s [ 7 ] ) NEW_LINE jfif_density = i16 ( s , 8 ) , i16 ( s , 10 ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT if jfif_unit == 1 : NEW_LINE INDENT self . info [ " dpi " ] = jfif_density NEW_LINE DEDENT self . info [ " jfif _ unit " ] = jfif_unit NEW_LINE self . info [ " jfif _ density " ] = jfif_density NEW_LINE DEDENT DEDENT elif marker == 0xFFE1 and s [ : 5 ] == b " Exif\0" : NEW_LINE # ▁ extract ▁ Exif ▁ information ▁ ( incomplete ) ENDCOM INDENT self . info [ " exif " ] = s # ▁ FIXME : ▁ value ▁ will ▁ change ENDCOM NEW_LINE DEDENT elif marker == 0xFFE2 and s [ : 5 ] == b " FPXR\0" : NEW_LINE # ▁ extract ▁ FlashPix ▁ information ▁ ( incomplete ) ENDCOM INDENT self . info [ " flashpix " ] = s # ▁ FIXME : ▁ value ▁ will ▁ change ENDCOM NEW_LINE DEDENT elif marker == 0xFFE2 and s [ : 12 ] == b " ICC _ PROFILE\0" : NEW_LINE # ▁ Since ▁ an ▁ ICC ▁ profile ▁ can ▁ be ▁ larger ▁ than ▁ the ▁ maximum ▁ size ▁ of ENDCOM # ▁ a ▁ JPEG ▁ marker ▁ ( 64K ) , ▁ we ▁ need ▁ provisions ▁ to ▁ split ▁ it ▁ into ENDCOM # ▁ multiple ▁ markers . ▁ The ▁ format ▁ defined ▁ by ▁ the ▁ ICC ▁ specifies ENDCOM # ▁ one ▁ or ▁ more ▁ APP2 ▁ markers ▁ containing ▁ the ▁ following ▁ data : ENDCOM # ▁ Identifying ▁ string ▁ ASCII ▁ " ICC _ PROFILE\0 " ▁ ( 12 ▁ bytes ) ENDCOM # ▁ Marker ▁ sequence ▁ number ▁ 1 , ▁ 2 , ▁ etc ▁ ( 1 ▁ byte ) ENDCOM # ▁ Number ▁ of ▁ markers ▁ Total ▁ of ▁ APP2 ' s ▁ used ▁ ( 1 ▁ byte ) ENDCOM # ▁ Profile ▁ data ▁ ( remainder ▁ of ▁ APP2 ▁ data ) ENDCOM # ▁ Decoders ▁ should ▁ use ▁ the ▁ marker ▁ sequence ▁ numbers ▁ to ENDCOM # ▁ reassemble ▁ the ▁ profile , ▁ rather ▁ than ▁ assuming ▁ that ▁ the ▁ APP2 ENDCOM # ▁ markers ▁ appear ▁ in ▁ the ▁ correct ▁ sequence . ENDCOM INDENT self . icclist . append ( s ) NEW_LINE DEDENT elif marker == 0xFFEE and s [ : 5 ] == b " Adobe " : NEW_LINE INDENT self . info [ " adobe " ] = i16 ( s , 5 ) NEW_LINE # ▁ extract ▁ Adobe ▁ custom ▁ properties ENDCOM try : NEW_LINE INDENT adobe_transform = i8 ( s [ 1 ] ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT self . info [ " adobe _ transform " ] = adobe_transform NEW_LINE DEDENT DEDENT elif marker == 0xFFE2 and s [ : 4 ] == b " MPF\0" : NEW_LINE # ▁ extract ▁ MPO ▁ information ENDCOM INDENT self . info [ " mp " ] = s [ 4 : ] NEW_LINE # ▁ offset ▁ is ▁ current ▁ location ▁ minus ▁ buffer ▁ size ENDCOM # ▁ plus ▁ constant ▁ header ▁ size ENDCOM self . info [ " mpoffset " ] = self . fp . tell ( ) - n + 4 NEW_LINE DEDENT DEDENT def COM ( self , marker ) : NEW_LINE # ▁ Comment ▁ marker . ▁ Store ▁ these ▁ in ▁ the ▁ APP ▁ dictionary . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE self . app [ " COM " ] = s # ▁ compatibility ENDCOM NEW_LINE self . applist . append ( ( " COM " , s ) ) NEW_LINE DEDENT def SOF ( self , marker ) : NEW_LINE # ▁ Start ▁ of ▁ frame ▁ marker . ▁ Defines ▁ the ▁ size ▁ and ▁ mode ▁ of ▁ the ENDCOM # ▁ image . ▁ JPEG ▁ is ▁ colour ▁ blind , ▁ so ▁ we ▁ use ▁ some ▁ simple ENDCOM # ▁ heuristics ▁ to ▁ map ▁ the ▁ number ▁ of ▁ layers ▁ to ▁ an ▁ appropriate ENDCOM # ▁ mode . ▁ Note ▁ that ▁ this ▁ could ▁ be ▁ made ▁ a ▁ bit ▁ brighter , ▁ by ENDCOM # ▁ looking ▁ for ▁ JFIF ▁ and ▁ Adobe ▁ APP ▁ markers . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE self . size = i16 ( s [ 3 : ] ) , i16 ( s [ 1 : ] ) NEW_LINE self . bits = i8 ( s [ 0 ] ) NEW_LINE if self . bits != 8 : NEW_LINE INDENT raise SyntaxError ( " cannot ▁ handle ▁ % d - bit ▁ layers " % self . bits ) NEW_LINE DEDENT self . layers = i8 ( s [ 5 ] ) NEW_LINE if self . layers == 1 : NEW_LINE INDENT self . mode = " L " NEW_LINE DEDENT elif self . layers == 3 : NEW_LINE INDENT self . mode = " RGB " NEW_LINE DEDENT elif self . layers == 4 : NEW_LINE INDENT self . mode = " CMYK " NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " cannot ▁ handle ▁ % d - layer ▁ images " % self . layers ) NEW_LINE DEDENT if marker in [ 0xFFC2 , 0xFFC6 , 0xFFCA , 0xFFCE ] : NEW_LINE INDENT self . info [ " progressive " ] = self . info [ " progression " ] = 1 NEW_LINE DEDENT if self . icclist : NEW_LINE # ▁ fixup ▁ icc ▁ profile ENDCOM INDENT self . icclist . sort ( ) # ▁ sort ▁ by ▁ sequence ▁ number ENDCOM NEW_LINE if i8 ( self . icclist [ 0 ] [ 13 ] ) == len ( self . icclist ) : NEW_LINE INDENT profile = [ ] NEW_LINE for p in self . icclist : NEW_LINE INDENT profile . append ( p [ 14 : ] ) NEW_LINE DEDENT icc_profile = b " " . join ( profile ) NEW_LINE DEDENT else : NEW_LINE INDENT icc_profile = None # ▁ wrong ▁ number ▁ of ▁ fragments ENDCOM NEW_LINE DEDENT self . info [ " icc _ profile " ] = icc_profile NEW_LINE self . icclist = None NEW_LINE DEDENT for i in range ( 6 , len ( s ) , 3 ) : NEW_LINE INDENT t = s [ i : i + 3 ] NEW_LINE # ▁ 4 - tuples : ▁ id , ▁ vsamp , ▁ hsamp , ▁ qtable ENDCOM self . layer . append ( ( t [ 0 ] , i8 ( t [ 1 ] ) // 16 , i8 ( t [ 1 ] ) & 15 , i8 ( t [ 2 ] ) ) ) NEW_LINE DEDENT DEDENT def DQT ( self , marker ) : NEW_LINE # ▁ Define ▁ quantization ▁ table . ▁ Support ▁ baseline ▁ 8 - bit ▁ tables ENDCOM # ▁ only . ▁ Note ▁ that ▁ there ▁ might ▁ be ▁ more ▁ than ▁ one ▁ table ▁ in ENDCOM # ▁ each ▁ marker . ENDCOM # ▁ FIXME : ▁ The ▁ quantization ▁ tables ▁ can ▁ be ▁ used ▁ to ▁ estimate ▁ the ENDCOM # ▁ compression ▁ quality . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE while len ( s ) : NEW_LINE INDENT if len ( s ) < 65 : NEW_LINE INDENT raise SyntaxError ( " bad ▁ quantization ▁ table ▁ marker " ) NEW_LINE DEDENT v = i8 ( s [ 0 ] ) NEW_LINE if v // 16 == 0 : NEW_LINE INDENT self . quantization [ v & 15 ] = array . array ( " B " , s [ 1 : 65 ] ) NEW_LINE s = s [ 65 : ] NEW_LINE DEDENT else : NEW_LINE INDENT return # ▁ FIXME : ▁ add ▁ code ▁ to ▁ read ▁ 16 - bit ▁ tables ! ENDCOM NEW_LINE # ▁ raise ▁ SyntaxError , ▁ " bad ▁ quantization ▁ table ▁ element ▁ size " ENDCOM # ▁ JPEG ▁ marker ▁ table ENDCOM DEDENT DEDENT DEDENT MARKER = { 0xFFC0 : ( " SOF0" , " Baseline ▁ DCT " , SOF ) , 0xFFC1 : ( " SOF1" , " Extended ▁ Sequential ▁ DCT " , SOF ) , 0xFFC2 : ( " SOF2" , " Progressive ▁ DCT " , SOF ) , 0xFFC3 : ( " SOF3" , " Spatial ▁ lossless " , SOF ) , 0xFFC4 : ( " DHT " , " Define ▁ Huffman ▁ table " , Skip ) , 0xFFC5 : ( " SOF5" , " Differential ▁ sequential ▁ DCT " , SOF ) , 0xFFC6 : ( " SOF6" , " Differential ▁ progressive ▁ DCT " , SOF ) , 0xFFC7 : ( " SOF7" , " Differential ▁ spatial " , SOF ) , 0xFFC8 : ( " JPG " , " Extension " , None ) , 0xFFC9 : ( " SOF9" , " Extended ▁ sequential ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCA : ( " SOF10" , " Progressive ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCB : ( " SOF11" , " Spatial ▁ lossless ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCC : ( " DAC " , " Define ▁ arithmetic ▁ coding ▁ conditioning " , Skip ) , 0xFFCD : ( " SOF13" , " Differential ▁ sequential ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCE : ( " SOF14" , " Differential ▁ progressive ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCF : ( " SOF15" , " Differential ▁ spatial ▁ ( AC ) " , SOF ) , 0xFFD0 : ( " RST0" , " Restart ▁ 0" , None ) , 0xFFD1 : ( " RST1" , " Restart ▁ 1" , None ) , 0xFFD2 : ( " RST2" , " Restart ▁ 2" , None ) , 0xFFD3 : ( " RST3" , " Restart ▁ 3" , None ) , 0xFFD4 : ( " RST4" , " Restart ▁ 4" , None ) , 0xFFD5 : ( " RST5" , " Restart ▁ 5" , None ) , 0xFFD6 : ( " RST6" , " Restart ▁ 6" , None ) , 0xFFD7 : ( " RST7" , " Restart ▁ 7" , None ) , 0xFFD8 : ( " SOI " , " Start ▁ of ▁ image " , None ) , 0xFFD9 : ( " EOI " , " End ▁ of ▁ image " , None ) , 0xFFDA : ( " SOS " , " Start ▁ of ▁ scan " , Skip ) , 0xFFDB : ( " DQT " , " Define ▁ quantization ▁ table " , DQT ) , 0xFFDC : ( " DNL " , " Define ▁ number ▁ of ▁ lines " , Skip ) , 0xFFDD : ( " DRI " , " Define ▁ restart ▁ interval " , Skip ) , 0xFFDE : ( " DHP " , " Define ▁ hierarchical ▁ progression " , SOF ) , 0xFFDF : ( " EXP " , " Expand ▁ reference ▁ component " , Skip ) , 0xFFE0 : ( " APP0" , " Application ▁ segment ▁ 0" , APP ) , 0xFFE1 : ( " APP1" , " Application ▁ segment ▁ 1" , APP ) , 0xFFE2 : ( " APP2" , " Application ▁ segment ▁ 2" , APP ) , 0xFFE3 : ( " APP3" , " Application ▁ segment ▁ 3" , APP ) , 0xFFE4 : ( " APP4" , " Application ▁ segment ▁ 4" , APP ) , 0xFFE5 : ( " APP5" , " Application ▁ segment ▁ 5" , APP ) , 0xFFE6 : ( " APP6" , " Application ▁ segment ▁ 6" , APP ) , 0xFFE7 : ( " APP7" , " Application ▁ segment ▁ 7" , APP ) , 0xFFE8 : ( " APP8" , " Application ▁ segment ▁ 8" , APP ) , 0xFFE9 : ( " APP9" , " Application ▁ segment ▁ 9" , APP ) , 0xFFEA : ( " APP10" , " Application ▁ segment ▁ 10" , APP ) , 0xFFEB : ( " APP11" , " Application ▁ segment ▁ 11" , APP ) , 0xFFEC : ( " APP12" , " Application ▁ segment ▁ 12" , APP ) , 0xFFED : ( " APP13" , " Application ▁ segment ▁ 13" , APP ) , 0xFFEE : ( " APP14" , " Application ▁ segment ▁ 14" , APP ) , 0xFFEF : ( " APP15" , " Application ▁ segment ▁ 15" , APP ) , 0xFFF0 : ( " JPG0" , " Extension ▁ 0" , None ) , 0xFFF1 : ( " JPG1" , " Extension ▁ 1" , None ) , 0xFFF2 : ( " JPG2" , " Extension ▁ 2" , None ) , 0xFFF3 : ( " JPG3" , " Extension ▁ 3" , None ) , 0xFFF4 : ( " JPG4" , " Extension ▁ 4" , None ) , 0xFFF5 : ( " JPG5" , " Extension ▁ 5" , None ) , 0xFFF6 : ( " JPG6" , " Extension ▁ 6" , None ) , 0xFFF7 : ( " JPG7" , " Extension ▁ 7" , None ) , 0xFFF8 : ( " JPG8" , " Extension ▁ 8" , None ) , 0xFFF9 : ( " JPG9" , " Extension ▁ 9" , None ) , 0xFFFA : ( " JPG10" , " Extension ▁ 10" , None ) , 0xFFFB : ( " JPG11" , " Extension ▁ 11" , None ) , 0xFFFC : ( " JPG12" , " Extension ▁ 12" , None ) , 0xFFFD : ( " JPG13" , " Extension ▁ 13" , None ) , 0xFFFE : ( " COM " , " Comment " , COM ) } NEW_LINE def _accept ( prefix ) : NEW_LINE INDENT return prefix [ 0 : 1 ] == b " \377" NEW_LINE # ▁ Image ▁ plugin ▁ for ▁ JPEG ▁ and ▁ JFIF ▁ images . ENDCOM DEDENT class JpegImageFile ( ImageFile . ImageFile ) : NEW_LINE INDENT format = " JPEG " NEW_LINE format_description = " JPEG ▁ ( ISO ▁ 10918 ) " NEW_LINE def _open ( self ) : NEW_LINE INDENT s = self . fp . read ( 1 ) NEW_LINE if i8 ( s ) != 255 : NEW_LINE INDENT raise SyntaxError ( " not ▁ a ▁ JPEG ▁ file " ) NEW_LINE # ▁ Create ▁ attributes ENDCOM DEDENT self . bits = self . layers = 0 NEW_LINE # ▁ JPEG ▁ specifics ▁ ( internal ) ENDCOM self . layer = [ ] NEW_LINE self . huffman_dc = { } NEW_LINE self . huffman_ac = { } NEW_LINE self . quantization = { } NEW_LINE self . app = { } # ▁ compatibility ENDCOM NEW_LINE self . applist = [ ] NEW_LINE self . icclist = [ ] NEW_LINE while True : NEW_LINE INDENT i = i8 ( s ) NEW_LINE if i == 0xFF : NEW_LINE INDENT s = s + self . fp . read ( 1 ) NEW_LINE i = i16 ( s ) NEW_LINE DEDENT else : NEW_LINE # ▁ Skip ▁ non - 0xFF ▁ junk ENDCOM INDENT s = self . fp . read ( 1 ) NEW_LINE continue NEW_LINE DEDENT if i in MARKER : NEW_LINE INDENT name , description , handler = MARKER [ i ] NEW_LINE # ▁ print ( hex ( i ) , ▁ name , ▁ description ) ENDCOM if handler is not None : NEW_LINE INDENT handler ( self , i ) NEW_LINE DEDENT if i == 0xFFDA : # ▁ start ▁ of ▁ scan ENDCOM NEW_LINE INDENT rawmode = self . mode NEW_LINE if self . mode == " CMYK " : NEW_LINE INDENT rawmode = " CMYK ; I " # ▁ assume ▁ adobe ▁ conventions ENDCOM NEW_LINE DEDENT self . tile = [ ( " jpeg " , ( 0 , 0 ) + self . size , 0 , ( rawmode , " " ) ) ] NEW_LINE # ▁ self . _ _ offset ▁ = ▁ self . fp . tell ( ) ENDCOM break NEW_LINE DEDENT s = self . fp . read ( 1 ) NEW_LINE DEDENT elif i == 0 or i == 0xFFFF : NEW_LINE # ▁ padded ▁ marker ▁ or ▁ junk ; ▁ move ▁ on ENDCOM INDENT s = b " \xff " NEW_LINE DEDENT elif i == 0xFF00 : # ▁ Skip ▁ extraneous ▁ data ▁ ( escaped ▁ 0xFF ) ENDCOM NEW_LINE INDENT s = self . fp . read ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " no ▁ marker ▁ found " ) NEW_LINE DEDENT DEDENT DEDENT def draft ( self , mode , size ) : NEW_LINE INDENT if len ( self . tile ) != 1 : NEW_LINE INDENT return NEW_LINE # ▁ Protect ▁ from ▁ second ▁ call ENDCOM DEDENT if self . decoderconfig : NEW_LINE INDENT return NEW_LINE DEDENT d , e , o , a = self . tile [ 0 ] NEW_LINE scale = 0 NEW_LINE if a [ 0 ] == " RGB " and mode in [ " L " , " YCbCr " ] : NEW_LINE INDENT self . mode = mode NEW_LINE a = mode , " " NEW_LINE DEDENT if size : NEW_LINE INDENT scale = min ( self . size [ 0 ] // size [ 0 ] , self . size [ 1 ] // size [ 1 ] ) NEW_LINE for s in [ 8 , 4 , 2 , 1 ] : NEW_LINE INDENT if scale >= s : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT e = e [ 0 ] , e [ 1 ] , ( e [ 2 ] - e [ 0 ] + s - 1 ) // s + e [ 0 ] , ( e [ 3 ] - e [ 1 ] + s - 1 ) // s + e [ 1 ] NEW_LINE self . size = ( ( self . size [ 0 ] + s - 1 ) // s , ( self . size [ 1 ] + s - 1 ) // s ) NEW_LINE scale = s NEW_LINE DEDENT self . tile = [ ( d , e , o , a ) ] NEW_LINE self . decoderconfig = ( scale , 0 ) NEW_LINE return self NEW_LINE DEDENT def load_djpeg ( self ) : NEW_LINE # ▁ ALTERNATIVE : ▁ handle ▁ JPEGs ▁ via ▁ the ▁ IJG ▁ command ▁ line ▁ utilities ENDCOM INDENT import subprocess NEW_LINE import tempfile NEW_LINE import os NEW_LINE f , path = tempfile . mkstemp ( ) NEW_LINE os . close ( f ) NEW_LINE if os . path . exists ( self . filename ) : NEW_LINE INDENT subprocess . check_call ( [ " djpeg " , " - outfile " , path , self . filename ] ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " Invalid ▁ Filename " ) NEW_LINE DEDENT try : NEW_LINE INDENT _im = Image . open ( path ) NEW_LINE _im . load ( ) NEW_LINE self . im = _im . im NEW_LINE DEDENT finally : NEW_LINE INDENT try : NEW_LINE INDENT os . unlink ( path ) NEW_LINE DEDENT except OSError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT self . mode = self . im . mode NEW_LINE self . size = self . im . size NEW_LINE self . tile = [ ] NEW_LINE DEDENT def _getexif ( self ) : NEW_LINE INDENT return _getexif ( self ) NEW_LINE DEDENT def _getmp ( self ) : NEW_LINE INDENT return _getmp ( self ) NEW_LINE DEDENT DEDENT def _fixup_dict ( src_dict ) : NEW_LINE # ▁ Helper ▁ function ▁ for ▁ _ getexif ( ) ENDCOM # ▁ returns ▁ a ▁ dict ▁ with ▁ any ▁ single ▁ item ▁ tuples / lists ▁ as ▁ individual ▁ values ENDCOM INDENT def _fixup ( value ) : NEW_LINE INDENT try : NEW_LINE INDENT if len ( value ) == 1 and not isinstance ( value , dict ) : NEW_LINE INDENT return value [ 0 ] NEW_LINE DEDENT DEDENT except : pass NEW_LINE return value NEW_LINE DEDENT return { k : _fixup ( v ) for k , v in src_dict . items ( ) } NEW_LINE DEDENT def _getexif ( self ) : NEW_LINE # ▁ Extract ▁ EXIF ▁ information . ▁ This ▁ method ▁ is ▁ highly ▁ experimental , ENDCOM # ▁ and ▁ is ▁ likely ▁ to ▁ be ▁ replaced ▁ with ▁ something ▁ better ▁ in ▁ a ▁ future ENDCOM # ▁ version . ENDCOM # ▁ The ▁ EXIF ▁ record ▁ consists ▁ of ▁ a ▁ TIFF ▁ file ▁ embedded ▁ in ▁ a ▁ JPEG ENDCOM # ▁ application ▁ marker ▁ ( ! ) . ENDCOM INDENT try : NEW_LINE INDENT data = self . info [ " exif " ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT file = io . BytesIO ( data [ 6 : ] ) NEW_LINE head = file . read ( 8 ) NEW_LINE # ▁ process ▁ dictionary ENDCOM info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif = dict ( _fixup_dict ( info ) ) NEW_LINE # ▁ get ▁ exif ▁ extension ENDCOM try : NEW_LINE # ▁ exif ▁ field ▁ 0x8769 ▁ is ▁ an ▁ offset ▁ pointer ▁ to ▁ the ▁ location ENDCOM # ▁ of ▁ the ▁ nested ▁ embedded ▁ exif ▁ ifd . ENDCOM # ▁ It ▁ should ▁ be ▁ a ▁ long , ▁ but ▁ may ▁ be ▁ corrupted . ENDCOM INDENT file . seek ( exif [ 0x8769 ] ) NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif . update ( _fixup_dict ( info ) ) NEW_LINE # ▁ get ▁ gpsinfo ▁ extension ENDCOM DEDENT try : NEW_LINE # ▁ exif ▁ field ▁ 0x8825 ▁ is ▁ an ▁ offset ▁ pointer ▁ to ▁ the ▁ location ENDCOM # ▁ of ▁ the ▁ nested ▁ embedded ▁ gps ▁ exif ▁ ifd . ENDCOM # ▁ It ▁ should ▁ be ▁ a ▁ long , ▁ but ▁ may ▁ be ▁ corrupted . ENDCOM INDENT file . seek ( exif [ 0x8825 ] ) NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif [ 0x8825 ] = _fixup_dict ( info ) NEW_LINE DEDENT return exif NEW_LINE DEDENT def _getmp ( self ) : NEW_LINE # ▁ Extract ▁ MP ▁ information . ▁ This ▁ method ▁ was ▁ inspired ▁ by ▁ the ▁ " highly ENDCOM # ▁ experimental " ▁ _ getexif ▁ version ▁ that ' s ▁ been ▁ in ▁ use ▁ for ▁ years ▁ now , ENDCOM # ▁ itself ▁ based ▁ on ▁ the ▁ ImageFileDirectory ▁ class ▁ in ▁ the ▁ TIFF ▁ plug - in . ENDCOM # ▁ The ▁ MP ▁ record ▁ essentially ▁ consists ▁ of ▁ a ▁ TIFF ▁ file ▁ embedded ▁ in ▁ a ▁ JPEG ENDCOM # ▁ application ▁ marker . ENDCOM INDENT try : NEW_LINE INDENT data = self . info [ " mp " ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT file_contents = io . BytesIO ( data ) NEW_LINE head = file_contents . read ( 8 ) NEW_LINE endianness = ' > ' if head [ : 4 ] == b ' \x4d\x4d\x00\x2a ' else ' < ' NEW_LINE # ▁ process ▁ dictionary ENDCOM try : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v2 ( head ) NEW_LINE info . load ( file_contents ) NEW_LINE mp = dict ( info ) NEW_LINE DEDENT except : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( unreadable ▁ directory ) " ) NEW_LINE # ▁ it ' s ▁ an ▁ error ▁ not ▁ to ▁ have ▁ a ▁ number ▁ of ▁ images ENDCOM DEDENT try : NEW_LINE INDENT quant = mp [ 0xB001 ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( no ▁ number ▁ of ▁ images ) " ) NEW_LINE # ▁ get ▁ MP ▁ entries ENDCOM DEDENT mpentries = [ ] NEW_LINE try : NEW_LINE INDENT rawmpentries = mp [ 0xB002 ] NEW_LINE for entrynum in range ( 0 , quant ) : NEW_LINE INDENT unpackedentry = unpack_from ( ' { } LLLHH ' . format ( endianness ) , rawmpentries , entrynum * 16 ) NEW_LINE labels = ( ' Attribute ' , ' Size ' , ' DataOffset ' , ' EntryNo1' , ' EntryNo2' ) NEW_LINE mpentry = dict ( zip ( labels , unpackedentry ) ) NEW_LINE mpentryattr = { ' DependentParentImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 31 ) ) , ' DependentChildImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 30 ) ) , ' RepresentativeImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 29 ) ) , ' Reserved ' : ( mpentry [ ' Attribute ' ] & ( 3 << 27 ) ) >> 27 , ' ImageDataFormat ' : ( mpentry [ ' Attribute ' ] & ( 7 << 24 ) ) >> 24 , ' MPType ' : mpentry [ ' Attribute ' ] & 0x00FFFFFF } NEW_LINE if mpentryattr [ ' ImageDataFormat ' ] == 0 : NEW_LINE INDENT mpentryattr [ ' ImageDataFormat ' ] = ' JPEG ' NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " unsupported ▁ picture ▁ format ▁ in ▁ MPO " ) NEW_LINE DEDENT mptypemap = { 0x000000 : ' Undefined ' , 0x010001 : ' Large ▁ Thumbnail ▁ ( VGA ▁ Equivalent ) ' , 0x010002 : ' Large ▁ Thumbnail ▁ ( Full ▁ HD ▁ Equivalent ) ' , 0x020001 : ' Multi - Frame ▁ Image ▁ ( Panorama ) ' , 0x020002 : ' Multi - Frame ▁ Image : ▁ ( Disparity ) ' , 0x020003 : ' Multi - Frame ▁ Image : ▁ ( Multi - Angle ) ' , 0x030000 : ' Baseline ▁ MP ▁ Primary ▁ Image ' } NEW_LINE mpentryattr [ ' MPType ' ] = mptypemap . get ( mpentryattr [ ' MPType ' ] , ' Unknown ' ) NEW_LINE mpentry [ ' Attribute ' ] = mpentryattr NEW_LINE mpentries . append ( mpentry ) NEW_LINE DEDENT mp [ 0xB002 ] = mpentries NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( bad ▁ MP ▁ Entry ) " ) NEW_LINE # ▁ Next ▁ we ▁ should ▁ try ▁ and ▁ parse ▁ the ▁ individual ▁ image ▁ unique ▁ ID ▁ list ; ENDCOM # ▁ we ▁ don ' t ▁ because ▁ I ' ve ▁ never ▁ seen ▁ this ▁ actually ▁ used ▁ in ▁ a ▁ real ▁ MPO ENDCOM # ▁ file ▁ and ▁ so ▁ can ' t ▁ test ▁ it . ENDCOM DEDENT return mp NEW_LINE # ▁ stuff ▁ to ▁ save ▁ JPEG ▁ files ENDCOM DEDENT RAWMODE = { "1" : " L " , " L " : " L " , " RGB " : " RGB " , " RGBA " : " RGB " , " RGBX " : " RGB " , " CMYK " : " CMYK ; I " , # ▁ assume ▁ adobe ▁ conventions ENDCOM " YCbCr " : " YCbCr " , } NEW_LINE zigzag_index = ( 0 , 1 , 5 , 6 , 14 , 15 , 27 , 28 , 2 , 4 , 7 , 13 , 16 , 26 , 29 , 42 , 3 , 8 , 12 , 17 , 25 , 30 , 41 , 43 , 9 , 11 , 18 , 24 , 31 , 40 , 44 , 53 , 10 , 19 , 23 , 32 , 39 , 45 , 52 , 54 , 20 , 22 , 33 , 38 , 46 , 51 , 55 , 60 , 21 , 34 , 37 , 47 , 50 , 56 , 59 , 61 , 35 , 36 , 48 , 49 , 57 , 58 , 62 , 63 ) NEW_LINE samplings = { ( 1 , 1 , 1 , 1 , 1 , 1 ) : 0 , ( 2 , 1 , 1 , 1 , 1 , 1 ) : 1 , ( 2 , 2 , 1 , 1 , 1 , 1 ) : 2 , } NEW_LINE def convert_dict_qtables ( qtables ) : NEW_LINE INDENT qtables = [ qtables [ key ] for key in range ( len ( qtables ) ) if key in qtables ] NEW_LINE for idx , table in enumerate ( qtables ) : NEW_LINE INDENT qtables [ idx ] = [ table [ i ] for i in zigzag_index ] NEW_LINE DEDENT return qtables NEW_LINE DEDENT def get_sampling ( im ) : NEW_LINE # ▁ There ' s ▁ no ▁ subsampling ▁ when ▁ image ▁ have ▁ only ▁ 1 ▁ layer ENDCOM # ▁ ( grayscale ▁ images ) ▁ or ▁ when ▁ they ▁ are ▁ CMYK ▁ ( 4 ▁ layers ) , ENDCOM # ▁ so ▁ set ▁ subsampling ▁ to ▁ default ▁ value . ENDCOM # ▁ NOTE : ▁ currently ▁ Pillow ▁ can ' t ▁ encode ▁ JPEG ▁ to ▁ YCCK ▁ format . ENDCOM # ▁ If ▁ YCCK ▁ support ▁ is ▁ added ▁ in ▁ the ▁ future , ▁ subsampling ▁ code ▁ will ▁ have ENDCOM # ▁ to ▁ be ▁ updated ▁ ( here ▁ and ▁ in ▁ JpegEncode . c ) ▁ to ▁ deal ▁ with ▁ 4 ▁ layers . ENDCOM INDENT if not hasattr ( im , ' layers ' ) or im . layers in ( 1 , 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sampling = im . layer [ 0 ] [ 1 : 3 ] + im . layer [ 1 ] [ 1 : 3 ] + im . layer [ 2 ] [ 1 : 3 ] NEW_LINE return samplings . get ( sampling , - 1 ) NEW_LINE DEDENT def _save ( im , fp , filename ) : NEW_LINE INDENT try : NEW_LINE INDENT rawmode = RAWMODE [ im . mode ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise IOError ( " cannot ▁ write ▁ mode ▁ % s ▁ as ▁ JPEG " % im . mode ) NEW_LINE DEDENT if im . mode == ' RGBA ' : NEW_LINE INDENT warnings . warn ( ' You ▁ are ▁ saving ▁ RGBA ▁ image ▁ as ▁ JPEG . ▁ The ▁ alpha ▁ channel ▁ will ▁ be ▁ ' ' discarded . ▁ This ▁ conversion ▁ is ▁ deprecated ▁ and ▁ will ▁ be ▁ disabled ▁ ' ' in ▁ Pillow ▁ 3.7 . ▁ Please , ▁ convert ▁ the ▁ image ▁ to ▁ RGB ▁ explicitly . ' , DeprecationWarning ) NEW_LINE DEDENT info = im . encoderinfo NEW_LINE dpi = [ int ( round ( x ) ) for x in info . get ( " dpi " , ( 0 , 0 ) ) ] NEW_LINE quality = info . get ( " quality " , 0 ) NEW_LINE subsampling = info . get ( " subsampling " , - 1 ) NEW_LINE qtables = info . get ( " qtables " ) NEW_LINE if quality == " keep " : NEW_LINE INDENT quality = 0 NEW_LINE subsampling = " keep " NEW_LINE qtables = " keep " NEW_LINE DEDENT elif quality in presets : NEW_LINE INDENT preset = presets [ quality ] NEW_LINE quality = 0 NEW_LINE subsampling = preset . get ( ' subsampling ' , - 1 ) NEW_LINE qtables = preset . get ( ' quantization ' ) NEW_LINE DEDENT elif not isinstance ( quality , int ) : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quality ▁ setting " ) NEW_LINE DEDENT else : NEW_LINE INDENT if subsampling in presets : NEW_LINE INDENT subsampling = presets [ subsampling ] . get ( ' subsampling ' , - 1 ) NEW_LINE DEDENT if isStringType ( qtables ) and qtables in presets : NEW_LINE INDENT qtables = presets [ qtables ] . get ( ' quantization ' ) NEW_LINE DEDENT DEDENT if subsampling == "4:4:4" : NEW_LINE INDENT subsampling = 0 NEW_LINE DEDENT elif subsampling == "4:2:2" : NEW_LINE INDENT subsampling = 1 NEW_LINE DEDENT elif subsampling == "4:1:1" : NEW_LINE INDENT subsampling = 2 NEW_LINE DEDENT elif subsampling == " keep " : NEW_LINE INDENT if im . format != " JPEG " : NEW_LINE INDENT raise ValueError ( " Cannot ▁ use ▁ ' keep ' ▁ when ▁ original ▁ image ▁ is ▁ not ▁ a ▁ JPEG " ) NEW_LINE DEDENT subsampling = get_sampling ( im ) NEW_LINE DEDENT def validate_qtables ( qtables ) : NEW_LINE INDENT if qtables is None : NEW_LINE INDENT return qtables NEW_LINE DEDENT if isStringType ( qtables ) : NEW_LINE INDENT try : NEW_LINE INDENT lines = [ int ( num ) for line in qtables . splitlines ( ) for num in line . split ( ' # ' , 1 ) [ 0 ] . split ( ) ] NEW_LINE DEDENT except ValueError : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quantization ▁ table " ) NEW_LINE DEDENT else : NEW_LINE INDENT qtables = [ lines [ s : s + 64 ] for s in range ( 0 , len ( lines ) , 64 ) ] NEW_LINE DEDENT DEDENT if isinstance ( qtables , ( tuple , list , dict ) ) : NEW_LINE INDENT if isinstance ( qtables , dict ) : NEW_LINE INDENT qtables = convert_dict_qtables ( qtables ) NEW_LINE DEDENT elif isinstance ( qtables , tuple ) : NEW_LINE INDENT qtables = list ( qtables ) NEW_LINE DEDENT if not ( 0 < len ( qtables ) < 5 ) : NEW_LINE INDENT raise ValueError ( " None ▁ or ▁ too ▁ many ▁ quantization ▁ tables " ) NEW_LINE DEDENT for idx , table in enumerate ( qtables ) : NEW_LINE INDENT try : NEW_LINE INDENT if len ( table ) != 64 : NEW_LINE INDENT raise NEW_LINE DEDENT table = array . array ( ' B ' , table ) NEW_LINE DEDENT except TypeError : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quantization ▁ table " ) NEW_LINE DEDENT else : NEW_LINE INDENT qtables [ idx ] = list ( table ) NEW_LINE DEDENT DEDENT return qtables NEW_LINE DEDENT DEDENT if qtables == " keep " : NEW_LINE INDENT if im . format != " JPEG " : NEW_LINE INDENT raise ValueError ( " Cannot ▁ use ▁ ' keep ' ▁ when ▁ original ▁ image ▁ is ▁ not ▁ a ▁ JPEG " ) NEW_LINE DEDENT qtables = getattr ( im , " quantization " , None ) NEW_LINE DEDENT qtables = validate_qtables ( qtables ) NEW_LINE extra = b " " NEW_LINE icc_profile = info . get ( " icc _ profile " ) NEW_LINE if icc_profile : NEW_LINE INDENT ICC_OVERHEAD_LEN = 14 NEW_LINE MAX_BYTES_IN_MARKER = 65533 NEW_LINE MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN NEW_LINE markers = [ ] NEW_LINE while icc_profile : NEW_LINE INDENT markers . append ( icc_profile [ : MAX_DATA_BYTES_IN_MARKER ] ) NEW_LINE icc_profile = icc_profile [ MAX_DATA_BYTES_IN_MARKER : ] NEW_LINE DEDENT i = 1 NEW_LINE for marker in markers : NEW_LINE INDENT size = struct . pack ( " > H " , 2 + ICC_OVERHEAD_LEN + len ( marker ) ) NEW_LINE extra += ( b " \xFF\xE2" + size + b " ICC _ PROFILE\0" + o8 ( i ) + o8 ( len ( markers ) ) + marker ) NEW_LINE i += 1 NEW_LINE # ▁ " progressive " ▁ is ▁ the ▁ official ▁ name , ▁ but ▁ older ▁ documentation ENDCOM # ▁ says ▁ " progression " ENDCOM # ▁ FIXME : ▁ issue ▁ a ▁ warning ▁ if ▁ the ▁ wrong ▁ form ▁ is ▁ used ▁ ( post - 1.1.7 ) ENDCOM DEDENT DEDENT progressive = info . get ( " progressive " , False ) or info . get ( " progression " , False ) NEW_LINE optimize = info . get ( " optimize " , False ) NEW_LINE # ▁ get ▁ keyword ▁ arguments ENDCOM im . encoderconfig = ( quality , progressive , info . get ( " smooth " , 0 ) , optimize , info . get ( " streamtype " , 0 ) , dpi [ 0 ] , dpi [ 1 ] , subsampling , qtables , extra , info . get ( " exif " , b " " ) ) NEW_LINE # ▁ if ▁ we ▁ optimize , ▁ libjpeg ▁ needs ▁ a ▁ buffer ▁ big ▁ enough ▁ to ▁ hold ▁ the ▁ whole ▁ image ENDCOM # ▁ in ▁ a ▁ shot . ▁ Guessing ▁ on ▁ the ▁ size , ▁ at ▁ im . size ▁ bytes . ▁ ( raw ▁ pizel ▁ size ▁ is ENDCOM # ▁ channels * size , ▁ this ▁ is ▁ a ▁ value ▁ that ' s ▁ been ▁ used ▁ in ▁ a ▁ django ▁ patch . ENDCOM # ▁ https : / / github . com / matthewwithanm / django - imagekit / issues / 50 ENDCOM bufsize = 0 NEW_LINE if optimize or progressive : NEW_LINE # ▁ CMYK ▁ can ▁ be ▁ bigger ENDCOM INDENT if im . mode == ' CMYK ' : NEW_LINE INDENT bufsize = 4 * im . size [ 0 ] * im . size [ 1 ] NEW_LINE # ▁ keep ▁ sets ▁ quality ▁ to ▁ 0 , ▁ but ▁ the ▁ actual ▁ value ▁ may ▁ be ▁ high . ENDCOM DEDENT elif quality >= 95 or quality == 0 : NEW_LINE INDENT bufsize = 2 * im . size [ 0 ] * im . size [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT bufsize = im . size [ 0 ] * im . size [ 1 ] NEW_LINE # ▁ The ▁ exif ▁ info ▁ needs ▁ to ▁ be ▁ written ▁ as ▁ one ▁ block , ▁ + ▁ APP1 , ▁ + ▁ one ▁ spare ▁ byte . ENDCOM # ▁ Ensure ▁ that ▁ our ▁ buffer ▁ is ▁ big ▁ enough ENDCOM DEDENT DEDENT bufsize = max ( ImageFile . MAXBLOCK , bufsize , len ( info . get ( " exif " , b " " ) ) + 5 ) NEW_LINE ImageFile . _save ( im , fp , [ ( " jpeg " , ( 0 , 0 ) + im . size , 0 , rawmode ) ] , bufsize ) NEW_LINE DEDENT def _save_cjpeg ( im , fp , filename ) : NEW_LINE # ▁ ALTERNATIVE : ▁ handle ▁ JPEGs ▁ via ▁ the ▁ IJG ▁ command ▁ line ▁ utilities . ENDCOM INDENT import os NEW_LINE import subprocess NEW_LINE tempfile = im . _dump ( ) NEW_LINE subprocess . check_call ( [ " cjpeg " , " - outfile " , filename , tempfile ] ) NEW_LINE try : NEW_LINE INDENT os . unlink ( tempfile ) NEW_LINE DEDENT except OSError : NEW_LINE INDENT pass NEW_LINE # ▁ Factory ▁ for ▁ making ▁ JPEG ▁ and ▁ MPO ▁ instances ENDCOM DEDENT DEDENT def jpeg_factory ( fp = None , filename = None ) : NEW_LINE INDENT im = JpegImageFile ( fp , filename ) NEW_LINE try : NEW_LINE INDENT mpheader = im . _getmp ( ) NEW_LINE if mpheader [ 45057 ] > 1 : NEW_LINE # ▁ It ' s ▁ actually ▁ an ▁ MPO ENDCOM INDENT from . MpoImagePlugin import MpoImageFile NEW_LINE im = MpoImageFile ( fp , filename ) NEW_LINE DEDENT DEDENT except ( TypeError , IndexError ) : NEW_LINE # ▁ It ▁ is ▁ really ▁ a ▁ JPEG ENDCOM INDENT pass NEW_LINE DEDENT except SyntaxError : NEW_LINE INDENT warnings . warn ( " Image ▁ appears ▁ to ▁ be ▁ a ▁ malformed ▁ MPO ▁ file , ▁ it ▁ will ▁ be ▁ " " interpreted ▁ as ▁ a ▁ base ▁ JPEG ▁ file " ) NEW_LINE DEDENT return im NEW_LINE # ▁ Registry ▁ stuff ENDCOM DEDENT Image . register_open ( JpegImageFile . format , jpeg_factory , _accept ) NEW_LINE Image . register_save ( JpegImageFile . format , _save ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jfif " ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jpe " ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jpg " ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jpeg " ) NEW_LINE Image . register_mime ( JpegImageFile . format , " image / jpeg " ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="peonycredit/peonycredit/tree/master/qa/pull-tester/pull-tester.py"> # ! / usr / bin / python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2013 ▁ The ▁ Bitcoin ▁ Core ▁ developers ENDCOM # ▁ Distributed ▁ under ▁ the ▁ MIT / X11 ▁ software ▁ license , ▁ see ▁ the ▁ accompanying ENDCOM # ▁ file ▁ COPYING ▁ or ▁ http : / / www . opensource . org / licenses / mit - license . php . ENDCOM import json NEW_LINE from urllib import urlopen NEW_LINE import requests NEW_LINE import getpass NEW_LINE from string import Template NEW_LINE import sys NEW_LINE import os NEW_LINE import subprocess NEW_LINE class RunError ( Exception ) : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return repr ( self . value ) NEW_LINE DEDENT DEDENT def run ( command , ** kwargs ) : NEW_LINE INDENT fail_hard = kwargs . pop ( " fail _ hard " , True ) NEW_LINE # ▁ output ▁ to ▁ / dev / null ▁ by ▁ default : ENDCOM kwargs . setdefault ( " stdout " , open ( ' / dev / null ' , ' w ' ) ) NEW_LINE kwargs . setdefault ( " stderr " , open ( ' / dev / null ' , ' w ' ) ) NEW_LINE command = Template ( command ) . substitute ( os . environ ) NEW_LINE if " TRACE " in os . environ : NEW_LINE INDENT if ' cwd ' in kwargs : NEW_LINE INDENT print ( " [ cwd = % s ] ▁ % s " % ( kwargs [ ' cwd ' ] , command ) ) NEW_LINE DEDENT else : print ( command ) NEW_LINE DEDENT try : NEW_LINE INDENT process = subprocess . Popen ( command . split ( ' ▁ ' ) , ** kwargs ) NEW_LINE process . wait ( ) NEW_LINE DEDENT except KeyboardInterrupt : NEW_LINE INDENT process . terminate ( ) NEW_LINE raise NEW_LINE DEDENT if process . returncode != 0 and fail_hard : NEW_LINE INDENT raise RunError ( " Failed : ▁ " + command ) NEW_LINE DEDENT return process . returncode NEW_LINE DEDENT def checkout_pull ( clone_url , commit , out ) : NEW_LINE # ▁ Init ENDCOM INDENT build_dir = os . environ [ " BUILD _ DIR " ] NEW_LINE run ( " umount ▁ $ { CHROOT _ COPY } / proc " , fail_hard = False ) NEW_LINE run ( " rsync ▁ - - delete ▁ - apv ▁ $ { CHROOT _ MASTER } / ▁ $ { CHROOT _ COPY } " ) NEW_LINE run ( " rm ▁ - rf ▁ $ { CHROOT _ COPY } $ { SCRIPTS _ DIR } " ) NEW_LINE run ( " cp ▁ - a ▁ $ { SCRIPTS _ DIR } ▁ $ { CHROOT _ COPY } $ { SCRIPTS _ DIR } " ) NEW_LINE # ▁ Merge ▁ onto ▁ upstream / master ENDCOM run ( " rm ▁ - rf ▁ $ { BUILD _ DIR } " ) NEW_LINE run ( " mkdir ▁ - p ▁ $ { BUILD _ DIR } " ) NEW_LINE run ( " git ▁ clone ▁ $ { CLONE _ URL } ▁ $ { BUILD _ DIR } " ) NEW_LINE run ( " git ▁ remote ▁ add ▁ pull ▁ " + clone_url , cwd = build_dir , stdout = out , stderr = out ) NEW_LINE run ( " git ▁ fetch ▁ pull " , cwd = build_dir , stdout = out , stderr = out ) NEW_LINE if run ( " git ▁ merge ▁ " + commit , fail_hard = False , cwd = build_dir , stdout = out , stderr = out ) != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT run ( " chown ▁ - R ▁ $ { BUILD _ USER } : $ { BUILD _ GROUP } ▁ $ { BUILD _ DIR } " , stdout = out , stderr = out ) NEW_LINE run ( " mount ▁ - - bind ▁ / proc ▁ $ { CHROOT _ COPY } / proc " ) NEW_LINE return True NEW_LINE DEDENT def commentOn ( commentUrl , success , inMerge , needTests , linkUrl ) : NEW_LINE INDENT common_message = """ STRNEWLINE This ▁ test ▁ script ▁ verifies ▁ pulls ▁ every ▁ time ▁ they ▁ are ▁ updated . ▁ It , ▁ however , ▁ dies ▁ sometimes ▁ and ▁ fails ▁ to ▁ test ▁ properly . ▁ ▁ If ▁ you ▁ are ▁ waiting ▁ on ▁ a ▁ test , ▁ please ▁ check ▁ timestamps ▁ to ▁ verify ▁ that ▁ the ▁ test . log ▁ is ▁ moving ▁ at ▁ http : / / jenkins . bluematt . me / pull - tester / current / STRNEWLINE Contact ▁ BlueMatt ▁ on ▁ freenode ▁ if ▁ something ▁ looks ▁ broken . """ NEW_LINE # ▁ Remove ▁ old ▁ BitcoinPullTester ▁ comments ▁ ( I ' m ▁ being ▁ lazy ▁ and ▁ not ▁ paginating ▁ here ) ENDCOM recentcomments = requests . get ( commentUrl + " ? sort = created & direction = desc " , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) . json NEW_LINE for comment in recentcomments : NEW_LINE INDENT if comment [ " user " ] [ " login " ] == os . environ [ " GITHUB _ USER " ] and common_message in comment [ " body " ] : NEW_LINE INDENT requests . delete ( comment [ " url " ] , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) NEW_LINE DEDENT DEDENT if success == True : NEW_LINE INDENT if needTests : NEW_LINE INDENT message = " Automatic ▁ sanity - testing : ▁ PLEASE ▁ ADD ▁ TEST - CASES , ▁ though ▁ technically ▁ passed . ▁ See ▁ " + linkUrl + " ▁ for ▁ binaries ▁ and ▁ test ▁ log . " NEW_LINE DEDENT else : NEW_LINE INDENT message = " Automatic ▁ sanity - testing : ▁ PASSED , ▁ see ▁ " + linkUrl + " ▁ for ▁ binaries ▁ and ▁ test ▁ log . " NEW_LINE DEDENT post_data = { " body " : message + common_message } NEW_LINE DEDENT elif inMerge : NEW_LINE INDENT post_data = { " body " : " Automatic ▁ sanity - testing : ▁ FAILED ▁ MERGE , ▁ see ▁ " + linkUrl + " ▁ for ▁ test ▁ log . " + """ STRNEWLINE STRNEWLINE This ▁ pull ▁ does ▁ not ▁ merge ▁ cleanly ▁ onto ▁ current ▁ master """ + common_message } NEW_LINE DEDENT else : NEW_LINE INDENT post_data = { " body " : " Automatic ▁ sanity - testing : ▁ FAILED ▁ BUILD / TEST , ▁ see ▁ " + linkUrl + " ▁ for ▁ binaries ▁ and ▁ test ▁ log . " + """ STRNEWLINE STRNEWLINE This ▁ could ▁ happen ▁ for ▁ one ▁ of ▁ several ▁ reasons : STRNEWLINE 1 . ▁ It ▁ chanages ▁ changes ▁ build ▁ scripts ▁ in ▁ a ▁ way ▁ that ▁ made ▁ them ▁ incompatible ▁ with ▁ the ▁ automated ▁ testing ▁ scripts ▁ ( please ▁ tweak ▁ those ▁ patches ▁ in ▁ qa / pull - tester ) STRNEWLINE 2 . ▁ It ▁ adds / modifies ▁ tests ▁ which ▁ test ▁ network ▁ rules ▁ ( thanks ▁ for ▁ doing ▁ that ) , ▁ which ▁ conflicts ▁ with ▁ a ▁ patch ▁ applied ▁ at ▁ test ▁ time STRNEWLINE 3 . ▁ It ▁ does ▁ not ▁ build ▁ on ▁ either ▁ Linux ▁ i386 ▁ or ▁ Win32 ▁ ( via ▁ MinGW ▁ cross ▁ compile ) STRNEWLINE 4 . ▁ The ▁ test ▁ suite ▁ fails ▁ on ▁ either ▁ Linux ▁ i386 ▁ or ▁ Win32 STRNEWLINE 5 . ▁ The ▁ block ▁ test - cases ▁ failed ▁ ( lookup ▁ the ▁ first ▁ bNN ▁ identifier ▁ which ▁ failed ▁ in ▁ https : / / github . com / TheBlueMatt / test - scripts / blob / master / FullBlockTestGenerator . java ) STRNEWLINE STRNEWLINE If ▁ you ▁ believe ▁ this ▁ to ▁ be ▁ in ▁ error , ▁ please ▁ ping ▁ BlueMatt ▁ on ▁ freenode ▁ or ▁ TheBlueMatt ▁ here . STRNEWLINE """ + common_message } NEW_LINE DEDENT resp = requests . post ( commentUrl , json . dumps ( post_data ) , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) NEW_LINE DEDENT def testpull ( number , comment_url , clone_url , commit ) : NEW_LINE INDENT print ( " Testing ▁ pull ▁ % d : ▁ % s ▁ : ▁ % s " % ( number , clone_url , commit ) ) NEW_LINE dir = os . environ [ " RESULTS _ DIR " ] + " / " + commit + " / " NEW_LINE print ( " ▁ ouput ▁ to ▁ % s " % dir ) NEW_LINE if os . path . exists ( dir ) : NEW_LINE INDENT os . system ( " rm ▁ - r ▁ " + dir ) NEW_LINE DEDENT os . makedirs ( dir ) NEW_LINE currentdir = os . environ [ " RESULTS _ DIR " ] + " / current " NEW_LINE os . system ( " rm ▁ - r ▁ " + currentdir ) NEW_LINE os . system ( " ln ▁ - s ▁ " + dir + " ▁ " + currentdir ) NEW_LINE out = open ( dir + " test . log " , ' w + ' ) NEW_LINE resultsurl = os . environ [ " RESULTS _ URL " ] + commit NEW_LINE checkedout = checkout_pull ( clone_url , commit , out ) NEW_LINE if checkedout != True : NEW_LINE INDENT print ( " Failed ▁ to ▁ test ▁ pull ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , False , True , False , resultsurl ) NEW_LINE open ( os . environ [ " TESTED _ DB " ] , " a " ) . write ( commit + " \n " ) NEW_LINE return NEW_LINE DEDENT run ( " rm ▁ - rf ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } " , fail_hard = False ) ; NEW_LINE run ( " mkdir ▁ - p ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } " , fail_hard = False ) ; NEW_LINE run ( " chown ▁ - R ▁ $ { BUILD _ USER } : $ { BUILD _ GROUP } ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } " , fail_hard = False ) NEW_LINE script = os . environ [ " BUILD _ PATH " ] + " / qa / pull - tester / pull - tester . sh " NEW_LINE script += " ▁ $ { BUILD _ PATH } ▁ $ { MINGW _ DEPS _ DIR } ▁ $ { SCRIPTS _ DIR } / BitcoindComparisonTool _ jar / BitcoindComparisonTool . jar ▁ 0 ▁ 6 ▁ $ { OUT _ DIR } " NEW_LINE returncode = run ( " chroot ▁ $ { CHROOT _ COPY } ▁ sudo ▁ - u ▁ $ { BUILD _ USER } ▁ - H ▁ timeout ▁ $ { TEST _ TIMEOUT } ▁ " + script , fail_hard = False , stdout = out , stderr = out ) NEW_LINE run ( " mv ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } ▁ " + dir ) NEW_LINE run ( " mv ▁ $ { BUILD _ DIR } ▁ " + dir ) NEW_LINE if returncode == 42 : NEW_LINE INDENT print ( " Successfully ▁ tested ▁ pull ▁ ( needs ▁ tests ) ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , True , False , True , resultsurl ) NEW_LINE DEDENT elif returncode != 0 : NEW_LINE INDENT print ( " Failed ▁ to ▁ test ▁ pull ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , False , False , False , resultsurl ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Successfully ▁ tested ▁ pull ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , True , False , False , resultsurl ) NEW_LINE DEDENT open ( os . environ [ " TESTED _ DB " ] , " a " ) . write ( commit + " \n " ) NEW_LINE DEDENT def environ_default ( setting , value ) : NEW_LINE INDENT if not setting in os . environ : NEW_LINE INDENT os . environ [ setting ] = value NEW_LINE DEDENT DEDENT if getpass . getuser ( ) != " root " : NEW_LINE INDENT print ( " Run ▁ me ▁ as ▁ root ! " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if " GITHUB _ USER " not in os . environ or " GITHUB _ AUTH _ TOKEN " not in os . environ : NEW_LINE INDENT print ( " GITHUB _ USER ▁ and / or ▁ GITHUB _ AUTH _ TOKEN ▁ environment ▁ variables ▁ not ▁ set " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT environ_default ( " CLONE _ URL " , " https : / / github . com / bitcoin / bitcoin . git " ) NEW_LINE environ_default ( " MINGW _ DEPS _ DIR " , " / mnt / w32deps " ) NEW_LINE environ_default ( " SCRIPTS _ DIR " , " / mnt / test - scripts " ) NEW_LINE environ_default ( " CHROOT _ COPY " , " / mnt / chroot - tmp " ) NEW_LINE environ_default ( " CHROOT _ MASTER " , " / mnt / chroot " ) NEW_LINE environ_default ( " OUT _ DIR " , " / mnt / out " ) NEW_LINE environ_default ( " BUILD _ PATH " , " / mnt / bitcoin " ) NEW_LINE os . environ [ " BUILD _ DIR " ] = os . environ [ " CHROOT _ COPY " ] + os . environ [ " BUILD _ PATH " ] NEW_LINE environ_default ( " RESULTS _ DIR " , " / mnt / www / pull - tester " ) NEW_LINE environ_default ( " RESULTS _ URL " , " http : / / jenkins . bluematt . me / pull - tester / " ) NEW_LINE environ_default ( " GITHUB _ REPO " , " bitcoin / bitcoin " ) NEW_LINE environ_default ( " TESTED _ DB " , " / mnt / commits - tested . txt " ) NEW_LINE environ_default ( " BUILD _ USER " , " matt " ) NEW_LINE environ_default ( " BUILD _ GROUP " , " matt " ) NEW_LINE environ_default ( " TEST _ TIMEOUT " , str ( 60 * 60 * 2 ) ) NEW_LINE print ( " Optional ▁ usage : ▁ pull - tester . py ▁ 2112" ) NEW_LINE f = open ( os . environ [ " TESTED _ DB " ] ) NEW_LINE tested = set ( line . rstrip ( ) for line in f . readlines ( ) ) NEW_LINE f . close ( ) NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT pull = requests . get ( " https : / / api . github . com / repos / " + os . environ [ " GITHUB _ REPO " ] + " / pulls / " + sys . argv [ 1 ] , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) . json NEW_LINE testpull ( pull [ " number " ] , pull [ " _ links " ] [ " comments " ] [ " href " ] , pull [ " head " ] [ " repo " ] [ " clone _ url " ] , pull [ " head " ] [ " sha " ] ) NEW_LINE DEDENT else : NEW_LINE INDENT for page in range ( 1 , 100 ) : NEW_LINE INDENT result = requests . get ( " https : / / api . github . com / repos / " + os . environ [ " GITHUB _ REPO " ] + " / pulls ? state = open & page = % d " % ( page , ) , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) . json NEW_LINE if len ( result ) == 0 : break ; NEW_LINE for pull in result : NEW_LINE INDENT if pull [ " head " ] [ " sha " ] in tested : NEW_LINE INDENT print ( " Pull ▁ % d ▁ already ▁ tested " % ( pull [ " number " ] , ) ) NEW_LINE continue NEW_LINE DEDENT testpull ( pull [ " number " ] , pull [ " _ links " ] [ " comments " ] [ " href " ] , pull [ " head " ] [ " repo " ] [ " clone _ url " ] , pull [ " head " ] [ " sha " ] ) NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="tianweizhang/nova/tree/master/nova/cmd/network.py"> # ▁ Copyright ▁ 2010 ▁ United ▁ States ▁ Government ▁ as ▁ represented ▁ by ▁ the ENDCOM # ▁ Administrator ▁ of ▁ the ▁ National ▁ Aeronautics ▁ and ▁ Space ▁ Administration . ENDCOM # ▁ All ▁ Rights ▁ Reserved . ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ENDCOM # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ENDCOM # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ENDCOM # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ENDCOM # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM # ▁ under ▁ the ▁ License . ENDCOM """ Starter ▁ script ▁ for ▁ Nova ▁ Network . """ NEW_LINE import sys NEW_LINE import traceback NEW_LINE from oslo . config import cfg NEW_LINE from nova . conductor import rpcapi as conductor_rpcapi NEW_LINE from nova import config NEW_LINE import nova . db . api NEW_LINE from nova import exception NEW_LINE from nova . i18n import _ NEW_LINE from nova import objects NEW_LINE from nova . objects import base as objects_base NEW_LINE from nova . openstack . common import log as logging NEW_LINE from nova . openstack . common . report import guru_meditation_report as gmr NEW_LINE from nova import service NEW_LINE from nova import utils NEW_LINE from nova import version NEW_LINE CONF = cfg . CONF NEW_LINE CONF . import_opt ( ' network _ topic ' , ' nova . network . rpcapi ' ) NEW_LINE CONF . import_opt ( ' use _ local ' , ' nova . conductor . api ' , group = ' conductor ' ) NEW_LINE def block_db_access ( ) : NEW_LINE INDENT class NoDB ( object ) : NEW_LINE INDENT def __getattr__ ( self , attr ) : NEW_LINE INDENT return self NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT stacktrace = " " . join ( traceback . format_stack ( ) ) NEW_LINE LOG = logging . getLogger ( ' nova . network ' ) NEW_LINE LOG . error ( _ ( ' No ▁ db ▁ access ▁ allowed ▁ in ▁ nova - network : ▁ % s ' ) , stacktrace ) NEW_LINE raise exception . DBNotAllowed ( ' nova - network ' ) NEW_LINE DEDENT DEDENT nova . db . api . IMPL = NoDB ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT config . parse_args ( sys . argv ) NEW_LINE logging . setup ( " nova " ) NEW_LINE utils . monkey_patch ( ) NEW_LINE objects . register_all ( ) NEW_LINE gmr . TextGuruMeditation . setup_autorun ( version ) NEW_LINE if not CONF . conductor . use_local : NEW_LINE INDENT block_db_access ( ) NEW_LINE objects_base . NovaObject . indirection_api = conductor_rpcapi . ConductorAPI ( ) NEW_LINE DEDENT server = service . Service . create ( binary = ' nova - network ' , topic = CONF . network_topic , db_allowed = CONF . conductor . use_local ) NEW_LINE service . serve ( server ) NEW_LINE service . wait ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="mjtamlyn/django/tree/master/django/contrib/auth/hashers.py"> import base64 NEW_LINE import binascii NEW_LINE import functools NEW_LINE import hashlib NEW_LINE import importlib NEW_LINE import warnings NEW_LINE from collections import OrderedDict NEW_LINE from django . conf import settings NEW_LINE from django . core . exceptions import ImproperlyConfigured NEW_LINE from django . core . signals import setting_changed NEW_LINE from django . dispatch import receiver NEW_LINE from django . utils . crypto import ( constant_time_compare , get_random_string , pbkdf2 , ) NEW_LINE from django . utils . encoding import force_bytes , force_text NEW_LINE from django . utils . module_loading import import_string NEW_LINE from django . utils . translation import gettext_noop as _ NEW_LINE UNUSABLE_PASSWORD_PREFIX = ' ! ' # ▁ This ▁ will ▁ never ▁ be ▁ a ▁ valid ▁ encoded ▁ hash ENDCOM NEW_LINE UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40 # ▁ number ▁ of ▁ random ▁ chars ▁ to ▁ add ▁ after ▁ UNUSABLE _ PASSWORD _ PREFIX ENDCOM NEW_LINE def is_password_usable ( encoded ) : NEW_LINE INDENT if encoded is None or encoded . startswith ( UNUSABLE_PASSWORD_PREFIX ) : NEW_LINE INDENT return False NEW_LINE DEDENT try : NEW_LINE INDENT identify_hasher ( encoded ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def check_password ( password , encoded , setter = None , preferred = ' default ' ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ boolean ▁ of ▁ whether ▁ the ▁ raw ▁ password ▁ matches ▁ the ▁ three STRNEWLINE ▁ part ▁ encoded ▁ digest . STRNEWLINE STRNEWLINE ▁ If ▁ setter ▁ is ▁ specified , ▁ it ' ll ▁ be ▁ called ▁ when ▁ you ▁ need ▁ to STRNEWLINE ▁ regenerate ▁ the ▁ password . STRNEWLINE ▁ """ NEW_LINE if password is None or not is_password_usable ( encoded ) : NEW_LINE INDENT return False NEW_LINE DEDENT preferred = get_hasher ( preferred ) NEW_LINE hasher = identify_hasher ( encoded ) NEW_LINE hasher_changed = hasher . algorithm != preferred . algorithm NEW_LINE must_update = hasher_changed or preferred . must_update ( encoded ) NEW_LINE is_correct = hasher . verify ( password , encoded ) NEW_LINE # ▁ If ▁ the ▁ hasher ▁ didn ' t ▁ change ▁ ( we ▁ don ' t ▁ protect ▁ against ▁ enumeration ▁ if ▁ it ENDCOM # ▁ does ) ▁ and ▁ the ▁ password ▁ should ▁ get ▁ updated , ▁ try ▁ to ▁ close ▁ the ▁ timing ▁ gap ENDCOM # ▁ between ▁ the ▁ work ▁ factor ▁ of ▁ the ▁ current ▁ encoded ▁ password ▁ and ▁ the ▁ default ENDCOM # ▁ work ▁ factor . ENDCOM if not is_correct and not hasher_changed and must_update : NEW_LINE INDENT hasher . harden_runtime ( password , encoded ) NEW_LINE DEDENT if setter and is_correct and must_update : NEW_LINE INDENT setter ( password ) NEW_LINE DEDENT return is_correct NEW_LINE DEDENT def make_password ( password , salt = None , hasher = ' default ' ) : NEW_LINE INDENT """ STRNEWLINE ▁ Turn ▁ a ▁ plain - text ▁ password ▁ into ▁ a ▁ hash ▁ for ▁ database ▁ storage STRNEWLINE STRNEWLINE ▁ Same ▁ as ▁ encode ( ) ▁ but ▁ generate ▁ a ▁ new ▁ random ▁ salt . ▁ If ▁ password ▁ is ▁ None ▁ then STRNEWLINE ▁ return ▁ a ▁ concatenation ▁ of ▁ UNUSABLE _ PASSWORD _ PREFIX ▁ and ▁ a ▁ random ▁ string , STRNEWLINE ▁ which ▁ disallows ▁ logins . ▁ Additional ▁ random ▁ string ▁ reduces ▁ chances ▁ of ▁ gaining STRNEWLINE ▁ access ▁ to ▁ staff ▁ or ▁ superuser ▁ accounts . ▁ See ▁ ticket ▁ # 20079 ▁ for ▁ more ▁ info . STRNEWLINE ▁ """ NEW_LINE if password is None : NEW_LINE INDENT return UNUSABLE_PASSWORD_PREFIX + get_random_string ( UNUSABLE_PASSWORD_SUFFIX_LENGTH ) NEW_LINE DEDENT hasher = get_hasher ( hasher ) NEW_LINE if not salt : NEW_LINE INDENT salt = hasher . salt ( ) NEW_LINE DEDENT return hasher . encode ( password , salt ) NEW_LINE DEDENT @ functools . lru_cache ( ) NEW_LINE def get_hashers ( ) : NEW_LINE INDENT hashers = [ ] NEW_LINE for hasher_path in settings . PASSWORD_HASHERS : NEW_LINE INDENT hasher_cls = import_string ( hasher_path ) NEW_LINE hasher = hasher_cls ( ) NEW_LINE if not getattr ( hasher , ' algorithm ' ) : NEW_LINE INDENT raise ImproperlyConfigured ( " hasher ▁ doesn ' t ▁ specify ▁ an ▁ " " algorithm ▁ name : ▁ % s " % hasher_path ) NEW_LINE DEDENT hashers . append ( hasher ) NEW_LINE DEDENT return hashers NEW_LINE DEDENT @ functools . lru_cache ( ) NEW_LINE def get_hashers_by_algorithm ( ) : NEW_LINE INDENT return { hasher . algorithm : hasher for hasher in get_hashers ( ) } NEW_LINE DEDENT @ receiver ( setting_changed ) NEW_LINE def reset_hashers ( ** kwargs ) : NEW_LINE INDENT if kwargs [ ' setting ' ] == ' PASSWORD _ HASHERS ' : NEW_LINE INDENT get_hashers . cache_clear ( ) NEW_LINE get_hashers_by_algorithm . cache_clear ( ) NEW_LINE DEDENT DEDENT def get_hasher ( algorithm = ' default ' ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ an ▁ instance ▁ of ▁ a ▁ loaded ▁ password ▁ hasher . STRNEWLINE STRNEWLINE ▁ If ▁ algorithm ▁ is ▁ ' default ' , ▁ return ▁ the ▁ default ▁ hasher . ▁ Lazily ▁ import ▁ hashers STRNEWLINE ▁ specified ▁ in ▁ the ▁ project ' s ▁ settings ▁ file ▁ if ▁ needed . STRNEWLINE ▁ """ NEW_LINE if hasattr ( algorithm , ' algorithm ' ) : NEW_LINE INDENT return algorithm NEW_LINE DEDENT elif algorithm == ' default ' : NEW_LINE INDENT return get_hashers ( ) [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT hashers = get_hashers_by_algorithm ( ) NEW_LINE try : NEW_LINE INDENT return hashers [ algorithm ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise ValueError ( " Unknown ▁ password ▁ hashing ▁ algorithm ▁ ' % s ' . ▁ " " Did ▁ you ▁ specify ▁ it ▁ in ▁ the ▁ PASSWORD _ HASHERS ▁ " " setting ? " % algorithm ) NEW_LINE DEDENT DEDENT DEDENT def identify_hasher ( encoded ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ an ▁ instance ▁ of ▁ a ▁ loaded ▁ password ▁ hasher . STRNEWLINE STRNEWLINE ▁ Identify ▁ hasher ▁ algorithm ▁ by ▁ examining ▁ encoded ▁ hash , ▁ and ▁ call STRNEWLINE ▁ get _ hasher ( ) ▁ to ▁ return ▁ hasher . ▁ Raise ▁ ValueError ▁ if STRNEWLINE ▁ algorithm ▁ cannot ▁ be ▁ identified , ▁ or ▁ if ▁ hasher ▁ is ▁ not ▁ loaded . STRNEWLINE ▁ """ NEW_LINE # ▁ Ancient ▁ versions ▁ of ▁ Django ▁ created ▁ plain ▁ MD5 ▁ passwords ▁ and ▁ accepted ENDCOM # ▁ MD5 ▁ passwords ▁ with ▁ an ▁ empty ▁ salt . ENDCOM if ( ( len ( encoded ) == 32 and ' $ ' not in encoded ) or ( len ( encoded ) == 37 and encoded . startswith ( ' md5 $ $ ' ) ) ) : NEW_LINE INDENT algorithm = ' unsalted _ md5' NEW_LINE # ▁ Ancient ▁ versions ▁ of ▁ Django ▁ accepted ▁ SHA1 ▁ passwords ▁ with ▁ an ▁ empty ▁ salt . ENDCOM DEDENT elif len ( encoded ) == 46 and encoded . startswith ( ' sha1 $ $ ' ) : NEW_LINE INDENT algorithm = ' unsalted _ sha1' NEW_LINE DEDENT else : NEW_LINE INDENT algorithm = encoded . split ( ' $ ' , 1 ) [ 0 ] NEW_LINE DEDENT return get_hasher ( algorithm ) NEW_LINE DEDENT def mask_hash ( hash , show = 6 , char = " * " ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ given ▁ hash , ▁ with ▁ only ▁ the ▁ first ▁ ` ` show ` ` ▁ number ▁ shown . ▁ The STRNEWLINE ▁ rest ▁ are ▁ masked ▁ with ▁ ` ` char ` ` ▁ for ▁ security ▁ reasons . STRNEWLINE ▁ """ NEW_LINE masked = hash [ : show ] NEW_LINE masked += char * len ( hash [ show : ] ) NEW_LINE return masked NEW_LINE DEDENT class BasePasswordHasher : NEW_LINE INDENT """ STRNEWLINE ▁ Abstract ▁ base ▁ class ▁ for ▁ password ▁ hashers STRNEWLINE STRNEWLINE ▁ When ▁ creating ▁ your ▁ own ▁ hasher , ▁ you ▁ need ▁ to ▁ override ▁ algorithm , STRNEWLINE ▁ verify ( ) , ▁ encode ( ) ▁ and ▁ safe _ summary ( ) . STRNEWLINE STRNEWLINE ▁ PasswordHasher ▁ objects ▁ are ▁ immutable . STRNEWLINE ▁ """ NEW_LINE algorithm = None NEW_LINE library = None NEW_LINE def _load_library ( self ) : NEW_LINE INDENT if self . library is not None : NEW_LINE INDENT if isinstance ( self . library , ( tuple , list ) ) : NEW_LINE INDENT name , mod_path = self . library NEW_LINE DEDENT else : NEW_LINE INDENT mod_path = self . library NEW_LINE DEDENT try : NEW_LINE INDENT module = importlib . import_module ( mod_path ) NEW_LINE DEDENT except ImportError as e : NEW_LINE INDENT raise ValueError ( " Couldn ' t ▁ load ▁ % r ▁ algorithm ▁ library : ▁ % s " % ( self . __class__ . __name__ , e ) ) NEW_LINE DEDENT return module NEW_LINE DEDENT raise ValueError ( " Hasher ▁ % r ▁ doesn ' t ▁ specify ▁ a ▁ library ▁ attribute " % self . __class__ . __name__ ) NEW_LINE DEDENT def salt ( self ) : NEW_LINE INDENT """ Generate ▁ a ▁ cryptographically ▁ secure ▁ nonce ▁ salt ▁ in ▁ ASCII . """ NEW_LINE return get_random_string ( ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT """ Check ▁ if ▁ the ▁ given ▁ password ▁ is ▁ correct . """ NEW_LINE raise NotImplementedError ( ' subclasses ▁ of ▁ BasePasswordHasher ▁ must ▁ provide ▁ a ▁ verify ( ) ▁ method ' ) NEW_LINE DEDENT def encode ( self , password , salt ) : NEW_LINE INDENT """ STRNEWLINE ▁ Create ▁ an ▁ encoded ▁ database ▁ value . STRNEWLINE STRNEWLINE ▁ The ▁ result ▁ is ▁ normally ▁ formatted ▁ as ▁ " algorithm $ salt $ hash " ▁ and STRNEWLINE ▁ must ▁ be ▁ fewer ▁ than ▁ 128 ▁ characters . STRNEWLINE ▁ """ NEW_LINE raise NotImplementedError ( ' subclasses ▁ of ▁ BasePasswordHasher ▁ must ▁ provide ▁ an ▁ encode ( ) ▁ method ' ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ summary ▁ of ▁ safe ▁ values . STRNEWLINE STRNEWLINE ▁ The ▁ result ▁ is ▁ a ▁ dictionary ▁ and ▁ will ▁ be ▁ used ▁ where ▁ the ▁ password ▁ field STRNEWLINE ▁ must ▁ be ▁ displayed ▁ to ▁ construct ▁ a ▁ safe ▁ representation ▁ of ▁ the ▁ password . STRNEWLINE ▁ """ NEW_LINE raise NotImplementedError ( ' subclasses ▁ of ▁ BasePasswordHasher ▁ must ▁ provide ▁ a ▁ safe _ summary ( ) ▁ method ' ) NEW_LINE DEDENT def must_update ( self , encoded ) : NEW_LINE INDENT return False NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT """ STRNEWLINE ▁ Bridge ▁ the ▁ runtime ▁ gap ▁ between ▁ the ▁ work ▁ factor ▁ supplied ▁ in ▁ ` encoded ` STRNEWLINE ▁ and ▁ the ▁ work ▁ factor ▁ suggested ▁ by ▁ this ▁ hasher . STRNEWLINE STRNEWLINE ▁ Taking ▁ PBKDF2 ▁ as ▁ an ▁ example , ▁ if ▁ ` encoded ` ▁ contains ▁ 20000 ▁ iterations ▁ and STRNEWLINE ▁ ` self . iterations ` ▁ is ▁ 30000 , ▁ this ▁ method ▁ should ▁ run ▁ password ▁ through STRNEWLINE ▁ another ▁ 10000 ▁ iterations ▁ of ▁ PBKDF2 . ▁ Similar ▁ approaches ▁ should ▁ exist STRNEWLINE ▁ for ▁ any ▁ hasher ▁ that ▁ has ▁ a ▁ work ▁ factor . ▁ If ▁ not , ▁ this ▁ method ▁ should ▁ be STRNEWLINE ▁ defined ▁ as ▁ a ▁ no - op ▁ to ▁ silence ▁ the ▁ warning . STRNEWLINE ▁ """ NEW_LINE warnings . warn ( ' subclasses ▁ of ▁ BasePasswordHasher ▁ should ▁ provide ▁ a ▁ harden _ runtime ( ) ▁ method ' ) NEW_LINE DEDENT DEDENT class PBKDF2PasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Secure ▁ password ▁ hashing ▁ using ▁ the ▁ PBKDF2 ▁ algorithm ▁ ( recommended ) STRNEWLINE STRNEWLINE ▁ Configured ▁ to ▁ use ▁ PBKDF2 ▁ + ▁ HMAC ▁ + ▁ SHA256 . STRNEWLINE ▁ The ▁ result ▁ is ▁ a ▁ 64 ▁ byte ▁ binary ▁ string . ▁ Iterations ▁ may ▁ be ▁ changed STRNEWLINE ▁ safely ▁ but ▁ you ▁ must ▁ rename ▁ the ▁ algorithm ▁ if ▁ you ▁ change ▁ SHA256 . STRNEWLINE ▁ """ NEW_LINE algorithm = " pbkdf2 _ sha256" NEW_LINE iterations = 100000 NEW_LINE digest = hashlib . sha256 NEW_LINE def encode ( self , password , salt , iterations = None ) : NEW_LINE INDENT assert password is not None NEW_LINE assert salt and ' $ ' not in salt NEW_LINE if not iterations : NEW_LINE INDENT iterations = self . iterations NEW_LINE DEDENT hash = pbkdf2 ( password , salt , iterations , digest = self . digest ) NEW_LINE hash = base64 . b64encode ( hash ) . decode ( ' ascii ' ) . strip ( ) NEW_LINE return " % s $ % d $ % s $ % s " % ( self . algorithm , iterations , salt , hash ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT algorithm , iterations , salt , hash = encoded . split ( ' $ ' , 3 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE encoded_2 = self . encode ( password , salt , int ( iterations ) ) NEW_LINE return constant_time_compare ( encoded , encoded_2 ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT algorithm , iterations , salt , hash = encoded . split ( ' $ ' , 3 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE return OrderedDict ( [ ( _ ( ' algorithm ' ) , algorithm ) , ( _ ( ' iterations ' ) , iterations ) , ( _ ( ' salt ' ) , mask_hash ( salt ) ) , ( _ ( ' hash ' ) , mask_hash ( hash ) ) , ] ) NEW_LINE DEDENT def must_update ( self , encoded ) : NEW_LINE INDENT algorithm , iterations , salt , hash = encoded . split ( ' $ ' , 3 ) NEW_LINE return int ( iterations ) != self . iterations NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT algorithm , iterations , salt , hash = encoded . split ( ' $ ' , 3 ) NEW_LINE extra_iterations = self . iterations - int ( iterations ) NEW_LINE if extra_iterations > 0 : NEW_LINE INDENT self . encode ( password , salt , extra_iterations ) NEW_LINE DEDENT DEDENT DEDENT class PBKDF2SHA1PasswordHasher ( PBKDF2PasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Alternate ▁ PBKDF2 ▁ hasher ▁ which ▁ uses ▁ SHA1 , ▁ the ▁ default ▁ PRF STRNEWLINE ▁ recommended ▁ by ▁ PKCS ▁ # 5 . ▁ This ▁ is ▁ compatible ▁ with ▁ other STRNEWLINE ▁ implementations ▁ of ▁ PBKDF2 , ▁ such ▁ as ▁ openssl ' s STRNEWLINE ▁ PKCS5 _ PBKDF2 _ HMAC _ SHA1 ( ) . STRNEWLINE ▁ """ NEW_LINE algorithm = " pbkdf2 _ sha1" NEW_LINE digest = hashlib . sha1 NEW_LINE DEDENT class Argon2PasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Secure ▁ password ▁ hashing ▁ using ▁ the ▁ argon2 ▁ algorithm . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ the ▁ winner ▁ of ▁ the ▁ Password ▁ Hashing ▁ Competition ▁ 2013-2015 STRNEWLINE ▁ ( https : / / password - hashing . net ) . ▁ It ▁ requires ▁ the ▁ argon2 - cffi ▁ library ▁ which STRNEWLINE ▁ depends ▁ on ▁ native ▁ C ▁ code ▁ and ▁ might ▁ cause ▁ portability ▁ issues . STRNEWLINE ▁ """ NEW_LINE algorithm = ' argon2' NEW_LINE library = ' argon2' NEW_LINE time_cost = 2 NEW_LINE memory_cost = 512 NEW_LINE parallelism = 2 NEW_LINE def encode ( self , password , salt ) : NEW_LINE INDENT argon2 = self . _load_library ( ) NEW_LINE data = argon2 . low_level . hash_secret ( force_bytes ( password ) , force_bytes ( salt ) , time_cost = self . time_cost , memory_cost = self . memory_cost , parallelism = self . parallelism , hash_len = argon2 . DEFAULT_HASH_LENGTH , type = argon2 . low_level . Type . I , ) NEW_LINE return self . algorithm + data . decode ( ' ascii ' ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT argon2 = self . _load_library ( ) NEW_LINE algorithm , rest = encoded . split ( ' $ ' , 1 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE try : NEW_LINE INDENT return argon2 . low_level . verify_secret ( force_bytes ( ' $ ' + rest ) , force_bytes ( password ) , type = argon2 . low_level . Type . I , ) NEW_LINE DEDENT except argon2 . exceptions . VerificationError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT ( algorithm , variety , version , time_cost , memory_cost , parallelism , salt , data ) = self . _decode ( encoded ) NEW_LINE assert algorithm == self . algorithm NEW_LINE return OrderedDict ( [ ( _ ( ' algorithm ' ) , algorithm ) , ( _ ( ' variety ' ) , variety ) , ( _ ( ' version ' ) , version ) , ( _ ( ' memory ▁ cost ' ) , memory_cost ) , ( _ ( ' time ▁ cost ' ) , time_cost ) , ( _ ( ' parallelism ' ) , parallelism ) , ( _ ( ' salt ' ) , mask_hash ( salt ) ) , ( _ ( ' hash ' ) , mask_hash ( data ) ) , ] ) NEW_LINE DEDENT def must_update ( self , encoded ) : NEW_LINE INDENT ( algorithm , variety , version , time_cost , memory_cost , parallelism , salt , data ) = self . _decode ( encoded ) NEW_LINE assert algorithm == self . algorithm NEW_LINE argon2 = self . _load_library ( ) NEW_LINE return ( argon2 . low_level . ARGON2_VERSION != version or self . time_cost != time_cost or self . memory_cost != memory_cost or self . parallelism != parallelism ) NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE # ▁ The ▁ runtime ▁ for ▁ Argon2 ▁ is ▁ too ▁ complicated ▁ to ▁ implement ▁ a ▁ sensible ENDCOM # ▁ hardening ▁ algorithm . ENDCOM INDENT pass NEW_LINE DEDENT def _decode ( self , encoded ) : NEW_LINE INDENT """ STRNEWLINE ▁ Split ▁ an ▁ encoded ▁ hash ▁ and ▁ return : ▁ ( STRNEWLINE ▁ algorithm , ▁ variety , ▁ version , ▁ time _ cost , ▁ memory _ cost , STRNEWLINE ▁ parallelism , ▁ salt , ▁ data , STRNEWLINE ▁ ) . STRNEWLINE ▁ """ NEW_LINE bits = encoded . split ( ' $ ' ) NEW_LINE if len ( bits ) == 5 : NEW_LINE # ▁ Argon2 ▁ < ▁ 1.3 ENDCOM INDENT algorithm , variety , raw_params , salt , data = bits NEW_LINE version = 0x10 NEW_LINE DEDENT else : NEW_LINE INDENT assert len ( bits ) == 6 NEW_LINE algorithm , variety , raw_version , raw_params , salt , data = bits NEW_LINE assert raw_version . startswith ( ' v = ' ) NEW_LINE version = int ( raw_version [ len ( ' v = ' ) : ] ) NEW_LINE DEDENT params = dict ( bit . split ( ' = ' , 1 ) for bit in raw_params . split ( ' , ' ) ) NEW_LINE assert len ( params ) == 3 and all ( x in params for x in ( ' t ' , ' m ' , ' p ' ) ) NEW_LINE time_cost = int ( params [ ' t ' ] ) NEW_LINE memory_cost = int ( params [ ' m ' ] ) NEW_LINE parallelism = int ( params [ ' p ' ] ) NEW_LINE return ( algorithm , variety , version , time_cost , memory_cost , parallelism , salt , data , ) NEW_LINE DEDENT DEDENT class BCryptSHA256PasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Secure ▁ password ▁ hashing ▁ using ▁ the ▁ bcrypt ▁ algorithm ▁ ( recommended ) STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ considered ▁ by ▁ many ▁ to ▁ be ▁ the ▁ most ▁ secure ▁ algorithm ▁ but ▁ you STRNEWLINE ▁ must ▁ first ▁ install ▁ the ▁ bcrypt ▁ library . ▁ Please ▁ be ▁ warned ▁ that STRNEWLINE ▁ this ▁ library ▁ depends ▁ on ▁ native ▁ C ▁ code ▁ and ▁ might ▁ cause ▁ portability STRNEWLINE ▁ issues . STRNEWLINE ▁ """ NEW_LINE algorithm = " bcrypt _ sha256" NEW_LINE digest = hashlib . sha256 NEW_LINE library = ( " bcrypt " , " bcrypt " ) NEW_LINE rounds = 12 NEW_LINE def salt ( self ) : NEW_LINE INDENT bcrypt = self . _load_library ( ) NEW_LINE return bcrypt . gensalt ( self . rounds ) NEW_LINE DEDENT def encode ( self , password , salt ) : NEW_LINE INDENT bcrypt = self . _load_library ( ) NEW_LINE # ▁ Hash ▁ the ▁ password ▁ prior ▁ to ▁ using ▁ bcrypt ▁ to ▁ prevent ▁ password ENDCOM # ▁ truncation ▁ as ▁ described ▁ in ▁ # 20138 . ENDCOM if self . digest is not None : NEW_LINE # ▁ Use ▁ binascii . hexlify ( ) ▁ because ▁ a ▁ hex ▁ encoded ▁ bytestring ▁ is ▁ str . ENDCOM INDENT password = binascii . hexlify ( self . digest ( force_bytes ( password ) ) . digest ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT password = force_bytes ( password ) NEW_LINE DEDENT data = bcrypt . hashpw ( password , salt ) NEW_LINE return " % s $ % s " % ( self . algorithm , force_text ( data ) ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT algorithm , data = encoded . split ( ' $ ' , 1 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE encoded_2 = self . encode ( password , force_bytes ( data ) ) NEW_LINE return constant_time_compare ( encoded , encoded_2 ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT algorithm , empty , algostr , work_factor , data = encoded . split ( ' $ ' , 4 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE salt , checksum = data [ : 22 ] , data [ 22 : ] NEW_LINE return OrderedDict ( [ ( _ ( ' algorithm ' ) , algorithm ) , ( _ ( ' work ▁ factor ' ) , work_factor ) , ( _ ( ' salt ' ) , mask_hash ( salt ) ) , ( _ ( ' checksum ' ) , mask_hash ( checksum ) ) , ] ) NEW_LINE DEDENT def must_update ( self , encoded ) : NEW_LINE INDENT algorithm , empty , algostr , rounds , data = encoded . split ( ' $ ' , 4 ) NEW_LINE return int ( rounds ) != self . rounds NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT _ , data = encoded . split ( ' $ ' , 1 ) NEW_LINE salt = data [ : 29 ] # ▁ Length ▁ of ▁ the ▁ salt ▁ in ▁ bcrypt . ENDCOM NEW_LINE rounds = data . split ( ' $ ' ) [ 2 ] NEW_LINE # ▁ work ▁ factor ▁ is ▁ logarithmic , ▁ adding ▁ one ▁ doubles ▁ the ▁ load . ENDCOM diff = 2 ** ( self . rounds - int ( rounds ) ) - 1 NEW_LINE while diff > 0 : NEW_LINE INDENT self . encode ( password , force_bytes ( salt ) ) NEW_LINE diff -= 1 NEW_LINE DEDENT DEDENT DEDENT class BCryptPasswordHasher ( BCryptSHA256PasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Secure ▁ password ▁ hashing ▁ using ▁ the ▁ bcrypt ▁ algorithm STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ considered ▁ by ▁ many ▁ to ▁ be ▁ the ▁ most ▁ secure ▁ algorithm ▁ but ▁ you STRNEWLINE ▁ must ▁ first ▁ install ▁ the ▁ bcrypt ▁ library . ▁ Please ▁ be ▁ warned ▁ that STRNEWLINE ▁ this ▁ library ▁ depends ▁ on ▁ native ▁ C ▁ code ▁ and ▁ might ▁ cause ▁ portability STRNEWLINE ▁ issues . STRNEWLINE STRNEWLINE ▁ This ▁ hasher ▁ does ▁ not ▁ first ▁ hash ▁ the ▁ password ▁ which ▁ means ▁ it ▁ is ▁ subject ▁ to STRNEWLINE ▁ the ▁ 72 ▁ character ▁ bcrypt ▁ password ▁ truncation , ▁ most ▁ use ▁ cases ▁ should ▁ prefer STRNEWLINE ▁ the ▁ BCryptSHA256PasswordHasher . STRNEWLINE STRNEWLINE ▁ See : ▁ https : / / code . djangoproject . com / ticket / 20138 STRNEWLINE ▁ """ NEW_LINE algorithm = " bcrypt " NEW_LINE digest = None NEW_LINE DEDENT class SHA1PasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ SHA1 ▁ password ▁ hashing ▁ algorithm ▁ ( not ▁ recommended ) STRNEWLINE ▁ """ NEW_LINE algorithm = " sha1" NEW_LINE def encode ( self , password , salt ) : NEW_LINE INDENT assert password is not None NEW_LINE assert salt and ' $ ' not in salt NEW_LINE hash = hashlib . sha1 ( force_bytes ( salt + password ) ) . hexdigest ( ) NEW_LINE return " % s $ % s $ % s " % ( self . algorithm , salt , hash ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT algorithm , salt , hash = encoded . split ( ' $ ' , 2 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE encoded_2 = self . encode ( password , salt ) NEW_LINE return constant_time_compare ( encoded , encoded_2 ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT algorithm , salt , hash = encoded . split ( ' $ ' , 2 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE return OrderedDict ( [ ( _ ( ' algorithm ' ) , algorithm ) , ( _ ( ' salt ' ) , mask_hash ( salt , show = 2 ) ) , ( _ ( ' hash ' ) , mask_hash ( hash ) ) , ] ) NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT class MD5PasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ Salted ▁ MD5 ▁ password ▁ hashing ▁ algorithm ▁ ( not ▁ recommended ) STRNEWLINE ▁ """ NEW_LINE algorithm = " md5" NEW_LINE def encode ( self , password , salt ) : NEW_LINE INDENT assert password is not None NEW_LINE assert salt and ' $ ' not in salt NEW_LINE hash = hashlib . md5 ( force_bytes ( salt + password ) ) . hexdigest ( ) NEW_LINE return " % s $ % s $ % s " % ( self . algorithm , salt , hash ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT algorithm , salt , hash = encoded . split ( ' $ ' , 2 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE encoded_2 = self . encode ( password , salt ) NEW_LINE return constant_time_compare ( encoded , encoded_2 ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT algorithm , salt , hash = encoded . split ( ' $ ' , 2 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE return OrderedDict ( [ ( _ ( ' algorithm ' ) , algorithm ) , ( _ ( ' salt ' ) , mask_hash ( salt , show = 2 ) ) , ( _ ( ' hash ' ) , mask_hash ( hash ) ) , ] ) NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT class UnsaltedSHA1PasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Very ▁ insecure ▁ algorithm ▁ that ▁ you ▁ should ▁ * never * ▁ use ; ▁ store ▁ SHA1 ▁ hashes STRNEWLINE ▁ with ▁ an ▁ empty ▁ salt . STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ is ▁ implemented ▁ because ▁ Django ▁ used ▁ to ▁ accept ▁ such ▁ password STRNEWLINE ▁ hashes . ▁ Some ▁ older ▁ Django ▁ installs ▁ still ▁ have ▁ these ▁ values ▁ lingering STRNEWLINE ▁ around ▁ so ▁ we ▁ need ▁ to ▁ handle ▁ and ▁ upgrade ▁ them ▁ properly . STRNEWLINE ▁ """ NEW_LINE algorithm = " unsalted _ sha1" NEW_LINE def salt ( self ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT def encode ( self , password , salt ) : NEW_LINE INDENT assert salt == ' ' NEW_LINE hash = hashlib . sha1 ( force_bytes ( password ) ) . hexdigest ( ) NEW_LINE return ' sha1 $ $ % s ' % hash NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT encoded_2 = self . encode ( password , ' ' ) NEW_LINE return constant_time_compare ( encoded , encoded_2 ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT assert encoded . startswith ( ' sha1 $ $ ' ) NEW_LINE hash = encoded [ 6 : ] NEW_LINE return OrderedDict ( [ ( _ ( ' algorithm ' ) , self . algorithm ) , ( _ ( ' hash ' ) , mask_hash ( hash ) ) , ] ) NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT class UnsaltedMD5PasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Incredibly ▁ insecure ▁ algorithm ▁ that ▁ you ▁ should ▁ * never * ▁ use ; ▁ stores ▁ unsalted STRNEWLINE ▁ MD5 ▁ hashes ▁ without ▁ the ▁ algorithm ▁ prefix , ▁ also ▁ accepts ▁ MD5 ▁ hashes ▁ with ▁ an STRNEWLINE ▁ empty ▁ salt . STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ is ▁ implemented ▁ because ▁ Django ▁ used ▁ to ▁ store ▁ passwords ▁ this ▁ way STRNEWLINE ▁ and ▁ to ▁ accept ▁ such ▁ password ▁ hashes . ▁ Some ▁ older ▁ Django ▁ installs ▁ still ▁ have STRNEWLINE ▁ these ▁ values ▁ lingering ▁ around ▁ so ▁ we ▁ need ▁ to ▁ handle ▁ and ▁ upgrade ▁ them STRNEWLINE ▁ properly . STRNEWLINE ▁ """ NEW_LINE algorithm = " unsalted _ md5" NEW_LINE def salt ( self ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT def encode ( self , password , salt ) : NEW_LINE INDENT assert salt == ' ' NEW_LINE return hashlib . md5 ( force_bytes ( password ) ) . hexdigest ( ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT if len ( encoded ) == 37 and encoded . startswith ( ' md5 $ $ ' ) : NEW_LINE INDENT encoded = encoded [ 5 : ] NEW_LINE DEDENT encoded_2 = self . encode ( password , ' ' ) NEW_LINE return constant_time_compare ( encoded , encoded_2 ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT return OrderedDict ( [ ( _ ( ' algorithm ' ) , self . algorithm ) , ( _ ( ' hash ' ) , mask_hash ( encoded , show = 3 ) ) , ] ) NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT class CryptPasswordHasher ( BasePasswordHasher ) : NEW_LINE INDENT """ STRNEWLINE ▁ Password ▁ hashing ▁ using ▁ UNIX ▁ crypt ▁ ( not ▁ recommended ) STRNEWLINE STRNEWLINE ▁ The ▁ crypt ▁ module ▁ is ▁ not ▁ supported ▁ on ▁ all ▁ platforms . STRNEWLINE ▁ """ NEW_LINE algorithm = " crypt " NEW_LINE library = " crypt " NEW_LINE def salt ( self ) : NEW_LINE INDENT return get_random_string ( 2 ) NEW_LINE DEDENT def encode ( self , password , salt ) : NEW_LINE INDENT crypt = self . _load_library ( ) NEW_LINE assert len ( salt ) == 2 NEW_LINE data = crypt . crypt ( password , salt ) NEW_LINE assert data is not None # ▁ A ▁ platform ▁ like ▁ OpenBSD ▁ with ▁ a ▁ dummy ▁ crypt ▁ module . ENDCOM NEW_LINE # ▁ we ▁ don ' t ▁ need ▁ to ▁ store ▁ the ▁ salt , ▁ but ▁ Django ▁ used ▁ to ▁ do ▁ this ENDCOM return " % s $ % s $ % s " % ( self . algorithm , ' ' , data ) NEW_LINE DEDENT def verify ( self , password , encoded ) : NEW_LINE INDENT crypt = self . _load_library ( ) NEW_LINE algorithm , salt , data = encoded . split ( ' $ ' , 2 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE return constant_time_compare ( data , crypt . crypt ( password , data ) ) NEW_LINE DEDENT def safe_summary ( self , encoded ) : NEW_LINE INDENT algorithm , salt , data = encoded . split ( ' $ ' , 2 ) NEW_LINE assert algorithm == self . algorithm NEW_LINE return OrderedDict ( [ ( _ ( ' algorithm ' ) , algorithm ) , ( _ ( ' salt ' ) , salt ) , ( _ ( ' hash ' ) , mask_hash ( data , show = 3 ) ) , ] ) NEW_LINE DEDENT def harden_runtime ( self , password , encoded ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="octacoin-project/beta/tree/master/share/qt/extract_strings_qt.py"> # ! / usr / bin / python ENDCOM ''' STRNEWLINE Extract ▁ _ ( " . . . " ) ▁ strings ▁ for ▁ translation ▁ and ▁ convert ▁ to ▁ Qt4 ▁ stringdefs ▁ so ▁ that STRNEWLINE they ▁ can ▁ be ▁ picked ▁ up ▁ by ▁ Qt ▁ linguist . STRNEWLINE ''' NEW_LINE from subprocess import Popen , PIPE NEW_LINE import glob NEW_LINE import operator NEW_LINE import os NEW_LINE import sys NEW_LINE OUT_CPP = " qt / bitcoinstrings . cpp " NEW_LINE EMPTY = [ ' " " ' ] NEW_LINE def parse_po ( text ) : NEW_LINE INDENT """ STRNEWLINE ▁ Parse ▁ ' po ' ▁ format ▁ produced ▁ by ▁ xgettext . STRNEWLINE ▁ Return ▁ a ▁ list ▁ of ▁ ( msgid , msgstr ) ▁ tuples . STRNEWLINE ▁ """ NEW_LINE messages = [ ] NEW_LINE msgid = [ ] NEW_LINE msgstr = [ ] NEW_LINE in_msgid = False NEW_LINE in_msgstr = False NEW_LINE for line in text . split ( ' \n ' ) : NEW_LINE INDENT line = line . rstrip ( ' ' ) NEW_LINE if line . startswith ( ' msgid ▁ ' ) : NEW_LINE INDENT if in_msgstr : NEW_LINE INDENT messages . append ( ( msgid , msgstr ) ) NEW_LINE in_msgstr = False NEW_LINE # ▁ message ▁ start ENDCOM DEDENT in_msgid = True NEW_LINE msgid = [ line [ 6 : ] ] NEW_LINE DEDENT elif line . startswith ( ' msgstr ▁ ' ) : NEW_LINE INDENT in_msgid = False NEW_LINE in_msgstr = True NEW_LINE msgstr = [ line [ 7 : ] ] NEW_LINE DEDENT elif line . startswith ( ' " ' ) : NEW_LINE INDENT if in_msgid : NEW_LINE INDENT msgid . append ( line ) NEW_LINE DEDENT if in_msgstr : NEW_LINE INDENT msgstr . append ( line ) NEW_LINE DEDENT DEDENT DEDENT if in_msgstr : NEW_LINE INDENT messages . append ( ( msgid , msgstr ) ) NEW_LINE DEDENT return messages NEW_LINE DEDENT files = sys . argv [ 1 : ] NEW_LINE # ▁ xgettext ▁ - n ▁ - - keyword = _ ▁ $ FILES ENDCOM XGETTEXT = os . getenv ( ' XGETTEXT ' , ' xgettext ' ) NEW_LINE child = Popen ( [ XGETTEXT , ' - - output = - ' , ' - n ' , ' - - keyword = _ ' ] + files , stdout = PIPE ) NEW_LINE ( out , err ) = child . communicate ( ) NEW_LINE messages = parse_po ( out ) NEW_LINE f = open ( OUT_CPP , ' w ' ) NEW_LINE f . write ( """ STRNEWLINE STRNEWLINE # include ▁ < QtGlobal > STRNEWLINE STRNEWLINE / / ▁ Automatically ▁ generated ▁ by ▁ extract _ strings . py STRNEWLINE # ifdef ▁ _ _ GNUC _ _ STRNEWLINE # define ▁ UNUSED ▁ _ _ attribute _ _ ( ( unused ) ) STRNEWLINE # else STRNEWLINE # define ▁ UNUSED STRNEWLINE # endif STRNEWLINE """ ) NEW_LINE f . write ( ' static ▁ const ▁ char ▁ UNUSED ▁ * bitcoin _ strings [ ] ▁ = ▁ { \n ' ) NEW_LINE messages . sort ( key = operator . itemgetter ( 0 ) ) NEW_LINE for ( msgid , msgstr ) in messages : NEW_LINE INDENT if msgid != EMPTY : NEW_LINE INDENT f . write ( ' QT _ TRANSLATE _ NOOP ( " bitcoin - core " , ▁ % s ) , \n ' % ( ' \n ' . join ( msgid ) ) ) NEW_LINE DEDENT DEDENT f . write ( ' } ; \n ' ) NEW_LINE f . close ( ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="codeboy/projectile/tree/master/lib/treebeard/tests.py"> " Unit / Functional ▁ tests " NEW_LINE import functools NEW_LINE import os NEW_LINE from django . contrib . admin . options import ModelAdmin NEW_LINE from django . contrib . admin . sites import AdminSite NEW_LINE from django . test import TestCase NEW_LINE from django . db import models , transaction NEW_LINE from django . contrib . auth . models import User NEW_LINE from django . db . models import Q NEW_LINE from django . conf import settings NEW_LINE from django import VERSION as DJANGO_VERSION NEW_LINE from treebeard import numconv NEW_LINE from treebeard . exceptions import InvalidPosition , InvalidMoveToDescendant , PathOverflow , MissingNodeOrderBy NEW_LINE from treebeard . mp_tree import MP_Node NEW_LINE from treebeard . al_tree import AL_Node NEW_LINE from treebeard . ns_tree import NS_Node NEW_LINE from treebeard . forms import MoveNodeForm NEW_LINE # ▁ ghetto ▁ app ▁ detection , ▁ there ▁ is ▁ probably ▁ some ▁ introspection ▁ method , ENDCOM # ▁ but ▁ meh , ▁ this ▁ works ENDCOM HAS_DJANGO_AUTH = ' django . contrib . auth ' in settings . INSTALLED_APPS NEW_LINE BASE_DATA = [ { ' data ' : { ' desc ' : '1' } } , { ' data ' : { ' desc ' : '2' } , ' children ' : [ { ' data ' : { ' desc ' : '21' } } , { ' data ' : { ' desc ' : '22' } } , { ' data ' : { ' desc ' : '23' } , ' children ' : [ { ' data ' : { ' desc ' : '231' } } , ] } , { ' data ' : { ' desc ' : '24' } } , ] } , { ' data ' : { ' desc ' : '3' } } , { ' data ' : { ' desc ' : '4' } , ' children ' : [ { ' data ' : { ' desc ' : '41' } } , ] } , ] NEW_LINE class MP_TestNode ( MP_Node ) : NEW_LINE INDENT steplen = 3 NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSomeDep ( models . Model ) : NEW_LINE INDENT node = models . ForeignKey ( MP_TestNode ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class NS_TestNode ( NS_Node ) : NEW_LINE INDENT desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class NS_TestNodeSomeDep ( models . Model ) : NEW_LINE INDENT node = models . ForeignKey ( NS_TestNode ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class AL_TestNode ( AL_Node ) : NEW_LINE INDENT parent = models . ForeignKey ( ' self ' , related_name = ' children _ set ' , null = True , db_index = True ) NEW_LINE sib_order = models . PositiveIntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class AL_TestNodeSomeDep ( models . Model ) : NEW_LINE INDENT node = models . ForeignKey ( AL_TestNode ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSorted ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE node_order_by = [ ' val1' , ' val2' , ' desc ' ] NEW_LINE val1 = models . IntegerField ( ) NEW_LINE val2 = models . IntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class NS_TestNodeSorted ( NS_Node ) : NEW_LINE INDENT node_order_by = [ ' val1' , ' val2' , ' desc ' ] NEW_LINE val1 = models . IntegerField ( ) NEW_LINE val2 = models . IntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class AL_TestNodeSorted ( AL_Node ) : NEW_LINE INDENT parent = models . ForeignKey ( ' self ' , related_name = ' children _ set ' , null = True , db_index = True ) NEW_LINE node_order_by = [ ' val1' , ' val2' , ' desc ' ] NEW_LINE val1 = models . IntegerField ( ) NEW_LINE val2 = models . IntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeAlphabet ( MP_Node ) : NEW_LINE INDENT steplen = 2 NEW_LINE numval = models . IntegerField ( ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSmallStep ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE alphabet = '0123456789' NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSortedAutoNow ( MP_Node ) : NEW_LINE INDENT desc = models . CharField ( max_length = 255 ) NEW_LINE created = models . DateTimeField ( auto_now_add = True ) NEW_LINE node_order_by = [ ' created ' ] NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeShortPath ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE alphabet = '01234' NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE # ▁ This ▁ is ▁ how ▁ you ▁ change ▁ the ▁ default ▁ fields ▁ defined ▁ in ▁ a ▁ Django ▁ abstract ▁ class ENDCOM # ▁ ( in ▁ this ▁ case , ▁ MP _ Node ) , ▁ since ▁ Django ▁ doesn ' t ▁ allow ▁ overriding ▁ fields , ▁ only ENDCOM # ▁ mehods ▁ and ▁ attributes ENDCOM DEDENT DEDENT MP_TestNodeShortPath . _meta . get_field ( ' path ' ) . max_length = 4 NEW_LINE if DJANGO_VERSION >= ( 1 , 1 ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT class MP_TestNode_Proxy ( MP_TestNode ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT proxy = True NEW_LINE DEDENT DEDENT class NS_TestNode_Proxy ( NS_TestNode ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT proxy = True NEW_LINE DEDENT DEDENT class AL_TestNode_Proxy ( AL_TestNode ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT proxy = True NEW_LINE DEDENT DEDENT DEDENT class MP_TestSortedNodeShortPath ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE alphabet = '01234' NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE node_order_by = [ ' desc ' ] NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT MP_TestSortedNodeShortPath . _meta . get_field ( ' path ' ) . max_length = 4 NEW_LINE if HAS_DJANGO_AUTH : NEW_LINE INDENT class MP_TestIssue14 ( MP_Node ) : NEW_LINE INDENT name = models . CharField ( max_length = 255 ) NEW_LINE users = models . ManyToManyField ( User ) NEW_LINE DEDENT DEDENT def testtype ( treetype , proxy ) : NEW_LINE INDENT def decorator ( f ) : NEW_LINE INDENT @ functools . wraps ( f ) NEW_LINE def _testtype ( self ) : NEW_LINE INDENT { ' MP ' : self . set_MP , ' AL ' : self . set_AL , ' NS ' : self . set_NS } [ treetype ] ( proxy ) NEW_LINE try : NEW_LINE INDENT f ( self ) NEW_LINE DEDENT finally : NEW_LINE INDENT transaction . rollback ( ) NEW_LINE self . model = None NEW_LINE self . sorted_model = None NEW_LINE self . dep_model = None NEW_LINE DEDENT DEDENT return _testtype NEW_LINE DEDENT return decorator NEW_LINE DEDENT def _load_test_methods ( cls , proxy = True ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT proxyopts = ( False , True ) NEW_LINE DEDENT else : NEW_LINE INDENT proxyopts = ( False , ) NEW_LINE DEDENT for m in dir ( cls ) : NEW_LINE INDENT if not m . startswith ( ' _ multi _ ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for t in ( ' MP ' , ' AL ' , ' NS ' ) : NEW_LINE INDENT for p in proxyopts : NEW_LINE INDENT deco = testtype ( t , p ) NEW_LINE name = ' test _ % s % s _ % s ' % ( t . lower ( ) , ' _ proxy ' if p else ' ' , m . split ( ' _ ' , 2 ) [ 2 ] ) NEW_LINE setattr ( cls , name , deco ( getattr ( cls , m ) ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class TestTreeBase ( TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT self . set_MP ( ) NEW_LINE self . unchanged = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE DEDENT def set_MP ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = MP_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = MP_TestNode NEW_LINE DEDENT self . sorted_model = MP_TestNodeSorted NEW_LINE self . dep_model = MP_TestNodeSomeDep NEW_LINE DEDENT def set_NS ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = NS_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = NS_TestNode NEW_LINE DEDENT self . sorted_model = NS_TestNodeSorted NEW_LINE self . dep_model = NS_TestNodeSomeDep NEW_LINE DEDENT def set_AL ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = AL_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = AL_TestNode NEW_LINE DEDENT self . sorted_model = AL_TestNodeSorted NEW_LINE self . dep_model = AL_TestNodeSomeDep NEW_LINE DEDENT def got ( self ) : NEW_LINE INDENT nsmodels = [ NS_TestNode ] NEW_LINE if DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT nsmodels . append ( NS_TestNode_Proxy ) NEW_LINE DEDENT if self . model in nsmodels : NEW_LINE # ▁ this ▁ slows ▁ down ▁ nested ▁ sets ▁ tests ▁ quite ▁ a ▁ bit , ▁ but ▁ it ▁ has ▁ the ENDCOM # ▁ advantage ▁ that ▁ we ' ll ▁ check ▁ the ▁ node ▁ edges ▁ are ▁ correct ENDCOM INDENT d = { } NEW_LINE for tree_id , lft , rgt in self . model . objects . values_list ( ' tree _ id ' , ' lft ' , ' rgt ' ) : NEW_LINE INDENT d . setdefault ( tree_id , [ ] ) . extend ( [ lft , rgt ] ) NEW_LINE DEDENT for tree_id , got_edges in d . items ( ) : NEW_LINE INDENT self . assertEqual ( len ( got_edges ) , max ( got_edges ) ) NEW_LINE good_edges = range ( 1 , len ( got_edges ) + 1 ) NEW_LINE self . assertEqual ( sorted ( got_edges ) , good_edges ) NEW_LINE DEDENT DEDENT return [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE DEDENT def _assert_get_annotated_list ( self , expected , parent = None ) : NEW_LINE INDENT got = [ ( obj [ 0 ] . desc , obj [ 1 ] [ ' open ' ] , obj [ 1 ] [ ' close ' ] , obj [ 1 ] [ ' level ' ] ) for obj in self . model . get_annotated_list ( parent ) ] NEW_LINE self . assertEqual ( expected , got ) NEW_LINE DEDENT DEDENT class TestEmptyTree ( TestTreeBase ) : NEW_LINE INDENT def _multi_load_bulk_empty ( self ) : NEW_LINE INDENT ids = self . model . load_bulk ( BASE_DATA ) NEW_LINE got_descs = [ obj . desc for obj in self . model . objects . filter ( id__in = ids ) ] NEW_LINE expected_descs = [ x [ 0 ] for x in self . unchanged ] NEW_LINE self . assertEqual ( sorted ( got_descs ) , sorted ( expected_descs ) ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_dump_bulk_empty ( self ) : NEW_LINE INDENT self . assertEqual ( self . model . dump_bulk ( ) , [ ] ) NEW_LINE DEDENT def _multi_add_root_empty ( self ) : NEW_LINE INDENT self . model . add_root ( desc = '1' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_get_root_nodes_empty ( self ) : NEW_LINE INDENT got = self . model . get_root_nodes ( ) NEW_LINE expected = [ ] NEW_LINE self . assertEqual ( [ node . desc for node in got ] , expected ) NEW_LINE DEDENT def _multi_get_first_root_node_empty ( self ) : NEW_LINE INDENT got = self . model . get_first_root_node ( ) NEW_LINE self . assertEqual ( got , None ) NEW_LINE DEDENT def _multi_get_last_root_node_empty ( self ) : NEW_LINE INDENT got = self . model . get_last_root_node ( ) NEW_LINE self . assertEqual ( got , None ) NEW_LINE DEDENT def _multi_get_tree ( self ) : NEW_LINE INDENT got = list ( self . model . get_tree ( ) ) NEW_LINE self . assertEqual ( got , [ ] ) NEW_LINE DEDENT def _multi_get_annotated_list ( self ) : NEW_LINE INDENT expected = [ ] NEW_LINE self . _assert_get_annotated_list ( expected ) NEW_LINE DEDENT DEDENT class TestNonEmptyTree ( TestTreeBase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestNonEmptyTree , self ) . setUp ( ) NEW_LINE MP_TestNode . load_bulk ( BASE_DATA ) NEW_LINE AL_TestNode . load_bulk ( BASE_DATA ) NEW_LINE NS_TestNode . load_bulk ( BASE_DATA ) NEW_LINE DEDENT DEDENT class TestClassMethods ( TestNonEmptyTree ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestClassMethods , self ) . setUp ( ) NEW_LINE DEDENT def _multi_load_bulk_existing ( self ) : NEW_LINE # ▁ inserting ▁ on ▁ an ▁ existing ▁ node ENDCOM INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE ids = self . model . load_bulk ( BASE_DATA , node ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 4 ) , ( u ' 1' , 4 , 0 ) , ( u ' 2' , 4 , 4 ) , ( u ' 21' , 5 , 0 ) , ( u ' 22' , 5 , 0 ) , ( u ' 23' , 5 , 1 ) , ( u ' 231' , 6 , 0 ) , ( u ' 24' , 5 , 0 ) , ( u ' 3' , 4 , 0 ) , ( u ' 4' , 4 , 1 ) , ( u ' 41' , 5 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE expected_descs = [ u ' 1' , u ' 2' , u ' 21' , u ' 22' , u ' 23' , u ' 231' , u ' 24' , u ' 3' , u ' 4' , u ' 41' ] NEW_LINE got_descs = [ obj . desc for obj in self . model . objects . filter ( id__in = ids ) ] NEW_LINE self . assertEqual ( sorted ( got_descs ) , sorted ( expected_descs ) ) NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_get_tree_all ( self ) : NEW_LINE INDENT got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE self . assertEqual ( got , self . unchanged ) NEW_LINE DEDENT def _multi_dump_bulk_all ( self ) : NEW_LINE INDENT self . assertEqual ( self . model . dump_bulk ( keep_ids = False ) , BASE_DATA ) NEW_LINE DEDENT def _multi_get_tree_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . model . load_bulk ( BASE_DATA , node ) NEW_LINE # ▁ the ▁ tree ▁ was ▁ modified ▁ by ▁ load _ bulk , ▁ so ▁ we ▁ reload ▁ our ▁ node ▁ object ENDCOM node = self . model . objects . get ( pk = node . id ) NEW_LINE got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( node ) ] NEW_LINE expected = [ ( u ' 231' , 3 , 4 ) , ( u ' 1' , 4 , 0 ) , ( u ' 2' , 4 , 4 ) , ( u ' 21' , 5 , 0 ) , ( u ' 22' , 5 , 0 ) , ( u ' 23' , 5 , 1 ) , ( u ' 231' , 6 , 0 ) , ( u ' 24' , 5 , 0 ) , ( u ' 3' , 4 , 0 ) , ( u ' 4' , 4 , 1 ) , ( u ' 41' , 5 , 0 ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_get_tree_leaf ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE self . assertEqual ( 0 , node . get_children_count ( ) ) NEW_LINE got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( node ) ] NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_get_annotated_list_all ( self ) : NEW_LINE INDENT expected = [ ( u ' 1' , True , [ ] , 0 ) , ( u ' 2' , False , [ ] , 0 ) , ( u ' 21' , True , [ ] , 1 ) , ( u ' 22' , False , [ ] , 1 ) , ( u ' 23' , False , [ ] , 1 ) , ( u ' 231' , True , [ 0 ] , 2 ) , ( u ' 24' , False , [ 0 ] , 1 ) , ( u ' 3' , False , [ ] , 0 ) , ( u ' 4' , False , [ ] , 0 ) , ( u ' 41' , True , [ 0 , 1 ] , 1 ) ] NEW_LINE self . _assert_get_annotated_list ( expected ) NEW_LINE DEDENT def _multi_get_annotated_list_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 2' ) NEW_LINE expected = [ ( u ' 2' , True , [ ] , 0 ) , ( u ' 21' , True , [ ] , 1 ) , ( u ' 22' , False , [ ] , 1 ) , ( u ' 23' , False , [ ] , 1 ) , ( u ' 231' , True , [ 0 ] , 2 ) , ( u ' 24' , False , [ 0 , 1 ] , 1 ) ] NEW_LINE self . _assert_get_annotated_list ( expected , node ) NEW_LINE DEDENT def _multi_get_annotated_list_leaf ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE expected = [ ( u ' 1' , True , [ 0 ] , 0 ) ] NEW_LINE self . _assert_get_annotated_list ( expected , node ) NEW_LINE DEDENT def _multi_dump_bulk_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . model . load_bulk ( BASE_DATA , node ) NEW_LINE # ▁ the ▁ tree ▁ was ▁ modified ▁ by ▁ load _ bulk , ▁ so ▁ we ▁ reload ▁ our ▁ node ▁ object ENDCOM node = self . model . objects . get ( pk = node . id ) NEW_LINE got = self . model . dump_bulk ( node , False ) NEW_LINE expected = [ { ' data ' : { ' desc ' : u ' 231' } , ' children ' : BASE_DATA } ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_load_and_dump_bulk_keeping_ids ( self ) : NEW_LINE INDENT exp = self . model . dump_bulk ( keep_ids = True ) NEW_LINE self . model . objects . all ( ) . delete ( ) NEW_LINE self . model . load_bulk ( exp , None , True ) NEW_LINE got = self . model . dump_bulk ( keep_ids = True ) NEW_LINE self . assertEqual ( got , exp ) NEW_LINE # ▁ do ▁ we ▁ really ▁ have ▁ an ▁ unchaged ▁ tree ▁ after ▁ the ▁ dump / delete / load ? ENDCOM got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE self . assertEqual ( got , self . unchanged ) NEW_LINE DEDENT def _multi_get_root_nodes ( self ) : NEW_LINE INDENT got = self . model . get_root_nodes ( ) NEW_LINE expected = [ '1' , '2' , '3' , '4' ] NEW_LINE self . assertEqual ( [ node . desc for node in got ] , expected ) NEW_LINE DEDENT def _multi_get_first_root_node ( self ) : NEW_LINE INDENT got = self . model . get_first_root_node ( ) NEW_LINE self . assertEqual ( got . desc , '1' ) NEW_LINE DEDENT def _multi_get_last_root_node ( self ) : NEW_LINE INDENT got = self . model . get_last_root_node ( ) NEW_LINE self . assertEqual ( got . desc , '4' ) NEW_LINE DEDENT def _multi_add_root ( self ) : NEW_LINE INDENT obj = self . model . add_root ( desc = '5' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE self . assertEqual ( self . model . get_last_root_node ( ) . desc , '5' ) NEW_LINE DEDENT DEDENT class TestSimpleNodeMethods ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_is_root ( self ) : NEW_LINE INDENT data = [ ( '2' , True ) , ( '1' , True ) , ( '4' , True ) , ( '21' , False ) , ( '24' , False ) , ( '22' , False ) , ( '231' , False ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . is_root ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_is_leaf ( self ) : NEW_LINE INDENT data = [ ( '2' , False ) , ( '23' , False ) , ( '231' , True ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . is_leaf ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_get_root ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' ) , ( '1' , '1' ) , ( '4' , '4' ) , ( '21' , '2' ) , ( '24' , '2' ) , ( '22' , '2' ) , ( '231' , '2' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_root ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT def _multi_get_parent ( self ) : NEW_LINE INDENT data = [ ( '2' , None ) , ( '1' , None ) , ( '4' , None ) , ( '21' , '2' ) , ( '24' , '2' ) , ( '22' , '2' ) , ( '231' , '23' ) , ] NEW_LINE data = dict ( data ) NEW_LINE objs = { } NEW_LINE for desc , expected in data . items ( ) : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) NEW_LINE parent = node . get_parent ( ) NEW_LINE if expected : NEW_LINE INDENT self . assertEqual ( parent . desc , expected ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( parent , None ) NEW_LINE DEDENT objs [ desc ] = node NEW_LINE # ▁ corrupt ▁ the ▁ objects ' ▁ parent ▁ cache ENDCOM node . _parent_obj = ' CORRUPTED ! ! ! ' NEW_LINE DEDENT for desc , expected in data . items ( ) : NEW_LINE INDENT node = objs [ desc ] NEW_LINE # ▁ asking ▁ get _ parent ▁ to ▁ not ▁ use ▁ the ▁ parent ▁ cache ▁ ( since ▁ we ENDCOM # ▁ corrupted ▁ it ▁ in ▁ the ▁ previous ▁ loop ) ENDCOM parent = node . get_parent ( True ) NEW_LINE if expected : NEW_LINE INDENT self . assertEqual ( parent . desc , expected ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( parent , None ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_children ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '21' , '22' , '23' , '24' ] ) , ( '23' , [ '231' ] ) , ( '231' , [ ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT children = self . model . objects . get ( desc = desc ) . get_children ( ) NEW_LINE self . assertEqual ( [ node . desc for node in children ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_children_count ( self ) : NEW_LINE INDENT data = [ ( '2' , 4 ) , ( '23' , 1 ) , ( '231' , 0 ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . get_children_count ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_get_siblings ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '1' , '2' , '3' , '4' ] ) , ( '21' , [ '21' , '22' , '23' , '24' ] ) , ( '231' , [ '231' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT siblings = self . model . objects . get ( desc = desc ) . get_siblings ( ) NEW_LINE self . assertEqual ( [ node . desc for node in siblings ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_first_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '1' ) , ( '1' , '1' ) , ( '4' , '1' ) , ( '21' , '21' ) , ( '24' , '21' ) , ( '22' , '21' ) , ( '231' , '231' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_first_sibling ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT def _multi_get_prev_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '1' ) , ( '1' , None ) , ( '4' , '3' ) , ( '21' , None ) , ( '24' , '23' ) , ( '22' , '21' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_prev_sibling ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_next_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '3' ) , ( '1' , '2' ) , ( '4' , None ) , ( '21' , '22' ) , ( '24' , None ) , ( '22' , '23' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_next_sibling ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_last_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '4' ) , ( '1' , '4' ) , ( '4' , '4' ) , ( '21' , '24' ) , ( '24' , '24' ) , ( '22' , '24' ) , ( '231' , '231' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_last_sibling ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT def _multi_get_first_child ( self ) : NEW_LINE INDENT data = [ ( '2' , '21' ) , ( '21' , None ) , ( '23' , '231' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_first_child ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_last_child ( self ) : NEW_LINE INDENT data = [ ( '2' , '24' ) , ( '21' , None ) , ( '23' , '231' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_last_child ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_ancestors ( self ) : NEW_LINE INDENT data = [ ( '2' , [ ] ) , ( '21' , [ '2' ] ) , ( '231' , [ '2' , '23' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT nodes = self . model . objects . get ( desc = desc ) . get_ancestors ( ) NEW_LINE self . assertEqual ( [ node . desc for node in nodes ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_descendants ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '21' , '22' , '23' , '231' , '24' ] ) , ( '23' , [ '231' ] ) , ( '231' , [ ] ) , ( '1' , [ ] ) , ( '4' , [ '41' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT nodes = self . model . objects . get ( desc = desc ) . get_descendants ( ) NEW_LINE self . assertEqual ( [ node . desc for node in nodes ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_descendant_count ( self ) : NEW_LINE INDENT data = [ ( '2' , 5 ) , ( '23' , 1 ) , ( '231' , 0 ) , ( '1' , 0 ) , ( '4' , 1 ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . get_descendant_count ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_is_sibling_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , True ) , ( '2' , '1' , True ) , ( '21' , '2' , False ) , ( '231' , '2' , False ) , ( '22' , '23' , True ) , ( '231' , '23' , False ) , ( '231' , '231' , True ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_sibling_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT def _multi_is_child_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , False ) , ( '2' , '1' , False ) , ( '21' , '2' , True ) , ( '231' , '2' , False ) , ( '231' , '23' , True ) , ( '231' , '231' , False ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_child_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT def _multi_is_descendant_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , False ) , ( '2' , '1' , False ) , ( '21' , '2' , True ) , ( '231' , '2' , True ) , ( '231' , '23' , True ) , ( '231' , '231' , False ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_descendant_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT DEDENT class TestAddChild ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_add_child_to_leaf ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . add_child ( desc = '2311' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 1 ) , ( u ' 2311' , 4 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_child_to_node ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 2' ) . add_child ( desc = '25' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 25' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestAddSibling ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_add_sibling_invalid_pos ( self ) : NEW_LINE INDENT method = self . model . objects . get ( desc = u ' 231' ) . add_sibling NEW_LINE self . assertRaises ( InvalidPosition , method , ' invalid _ pos ' ) NEW_LINE DEDENT def _multi_add_sibling_missing_nodeorderby ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE method = node_wchildren . add_sibling NEW_LINE self . assertRaises ( MissingNodeOrderBy , method , ' sorted - sibling ' , desc = ' aaa ' ) NEW_LINE DEDENT def _multi_add_sibling_last_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' last - sibling ' , desc = '5' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE self . assertEqual ( node_wchildren . get_last_sibling ( ) . desc , u ' 5' ) NEW_LINE DEDENT def _multi_add_sibling_last ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' last - sibling ' , desc = '232' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE self . assertEqual ( node . get_last_sibling ( ) . desc , u ' 232' ) NEW_LINE DEDENT def _multi_add_sibling_first_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' first - sibling ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' new ' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_first ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' first - sibling ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' new ' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' new ' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' new ' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left_noleft_root ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE obj = node . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' new ' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left_noleft ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' new ' , 3 , 0 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' new ' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' new ' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right_noright_root ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 4' ) NEW_LINE obj = node . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' new ' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right_noright ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 231' , 3 , 0 ) , ( u ' new ' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestDelete ( TestNonEmptyTree ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestDelete , self ) . setUp ( ) NEW_LINE for node in self . model . objects . all ( ) : NEW_LINE INDENT self . dep_model ( node = node ) . save ( ) NEW_LINE DEDENT DEDENT def _multi_delete_leaf ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_node ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 23' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 3 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 2' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_filter_root_nodes ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '3' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_filter_children ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '23' , '231' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_nonexistant_nodes ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( ' ZZZ ' , ' XXX ' ) ) . delete ( ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_delete_same_node_twice ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '2' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_all_root_nodes ( self ) : NEW_LINE INDENT self . model . get_root_nodes ( ) . delete ( ) NEW_LINE count = self . model . objects . count ( ) NEW_LINE self . assertEqual ( count , 0 ) NEW_LINE DEDENT def _multi_delete_all_nodes ( self ) : NEW_LINE INDENT self . model . objects . all ( ) . delete ( ) NEW_LINE count = self . model . objects . count ( ) NEW_LINE self . assertEqual ( count , 0 ) NEW_LINE DEDENT DEDENT class TestMoveErrors ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_invalid_pos ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( InvalidPosition , node . move , node , ' invalid _ pos ' ) NEW_LINE DEDENT def _multi_move_to_descendant ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 2' ) NEW_LINE target = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( InvalidMoveToDescendant , node . move , target , ' first - sibling ' ) NEW_LINE DEDENT def _multi_move_missing_nodeorderby ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( MissingNodeOrderBy , node . move , node , ' sorted - child ' ) NEW_LINE self . assertRaises ( MissingNodeOrderBy , node . move , node , ' sorted - sibling ' ) NEW_LINE DEDENT DEDENT class TestMoveSortedErrors ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_nonsorted_move_in_sorted ( self ) : NEW_LINE INDENT node = self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . assertRaises ( InvalidPosition , node . move , node , ' left ' ) NEW_LINE DEDENT DEDENT class TestMoveLeafRoot ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_leaf_last_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 231' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 231' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_left_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 231' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_right_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_last_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 231' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMoveLeaf ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_leaf_last_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 231' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_left_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_right_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_left_sibling_itself ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 231' ) , ' left ' ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_move_leaf_last_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMoveBranchRoot ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_branch_first_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_noleft_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) . get_first_sibling ( ) , ' left ' ) NEW_LINE expected = [ ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_noright_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) . get_last_sibling ( ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_first_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMoveBranch ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_branch_first_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_noleft_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) . get_first_sibling ( ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_noright_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) . get_last_sibling ( ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_itself_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '4' ) , ' left ' ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_move_branch_first_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 4' , 3 , 1 ) , ( u ' 41' , 4 , 0 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 231' , 3 , 0 ) , ( u ' 4' , 3 , 1 ) , ( u ' 41' , 4 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestTreeSorted ( TestTreeBase ) : NEW_LINE INDENT def got ( self ) : NEW_LINE INDENT return [ ( o . val1 , o . val2 , o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . sorted_model . get_tree ( ) ] NEW_LINE DEDENT def _multi_add_root_sorted ( self ) : NEW_LINE INDENT self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE expected = [ ( 1 , 4 , u ' bcd ' , 1 , 0 ) , ( 2 , 2 , u ' qwe ' , 1 , 0 ) , ( 2 , 5 , u ' zxy ' , 1 , 0 ) , ( 3 , 2 , u ' vcx ' , 1 , 0 ) , ( 3 , 3 , u ' abc ' , 1 , 0 ) , ( 3 , 3 , u ' abc ' , 1 , 0 ) , ( 3 , 3 , u ' zxy ' , 1 , 0 ) , ( 4 , 1 , u ' fgh ' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_child_root_sorted ( self ) : NEW_LINE INDENT root = self . sorted_model . add_root ( val1 = 0 , val2 = 0 , desc = ' aaa ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE root . add_child ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE root . add_child ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE root . add_child ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE root . add_child ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE expected = [ ( 0 , 0 , u ' aaa ' , 1 , 8 ) , ( 1 , 4 , u ' bcd ' , 2 , 0 ) , ( 2 , 2 , u ' qwe ' , 2 , 0 ) , ( 2 , 5 , u ' zxy ' , 2 , 0 ) , ( 3 , 2 , u ' vcx ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' zxy ' , 2 , 0 ) , ( 4 , 1 , u ' fgh ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_child_nonroot_sorted ( self ) : NEW_LINE INDENT get_node = lambda node_id : self . sorted_model . objects . get ( pk = node_id ) NEW_LINE root_id = self . sorted_model . add_root ( val1 = 0 , val2 = 0 , desc = ' a ' ) . id NEW_LINE node_id = get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' ac ' ) . id NEW_LINE get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' aa ' ) NEW_LINE get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' av ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' aca ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' acc ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' acb ' ) NEW_LINE expected = [ ( 0 , 0 , u ' a ' , 1 , 3 ) , ( 0 , 0 , u ' aa ' , 2 , 0 ) , ( 0 , 0 , u ' ac ' , 2 , 3 ) , ( 0 , 0 , u ' aca ' , 3 , 0 ) , ( 0 , 0 , u ' acb ' , 3 , 0 ) , ( 0 , 0 , u ' acc ' , 3 , 0 ) , ( 0 , 0 , u ' av ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_sorted ( self ) : NEW_LINE INDENT self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE root_nodes = self . sorted_model . get_root_nodes ( ) NEW_LINE target = root_nodes [ 0 ] NEW_LINE for node in root_nodes [ 1 : ] : NEW_LINE # ▁ because ▁ raw ▁ queries ▁ don ' t ▁ update ▁ django ▁ objects ENDCOM INDENT node = self . sorted_model . objects . get ( pk = node . id ) NEW_LINE target = self . sorted_model . objects . get ( pk = target . id ) NEW_LINE node . move ( target , ' sorted - child ' ) NEW_LINE DEDENT expected = [ ( 1 , 4 , u ' bcd ' , 1 , 7 ) , ( 2 , 2 , u ' qwe ' , 2 , 0 ) , ( 2 , 5 , u ' zxy ' , 2 , 0 ) , ( 3 , 2 , u ' vcx ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' zxy ' , 2 , 0 ) , ( 4 , 1 , u ' fgh ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMP_TreeAlphabet ( TestCase ) : NEW_LINE INDENT def test_alphabet ( self ) : NEW_LINE INDENT if not os . getenv ( ' TREEBEARD _ TEST _ ALPHABET ' , False ) : NEW_LINE # ▁ run ▁ this ▁ test ▁ only ▁ if ▁ the ▁ enviroment ▁ variable ▁ is ▁ set ENDCOM INDENT return NEW_LINE DEDENT basealpha = numconv . BASE85 NEW_LINE got_err = False NEW_LINE last_good = None NEW_LINE for alphabetlen in range ( 35 , len ( basealpha ) + 1 ) : NEW_LINE INDENT alphabet = basealpha [ 0 : alphabetlen ] NEW_LINE expected = [ alphabet [ 0 ] + char for char in alphabet [ 1 : ] ] NEW_LINE expected . extend ( [ alphabet [ 1 ] + char for char in alphabet ] ) NEW_LINE expected . append ( alphabet [ 2 ] + alphabet [ 0 ] ) NEW_LINE # ▁ remove ▁ all ▁ nodes ENDCOM MP_TestNodeAlphabet . objects . all ( ) . delete ( ) NEW_LINE # ▁ change ▁ the ▁ model ' s ▁ alphabet ENDCOM MP_TestNodeAlphabet . alphabet = alphabet NEW_LINE # ▁ insert ▁ root ▁ nodes ENDCOM for pos in range ( len ( alphabet ) * 2 ) : NEW_LINE INDENT try : NEW_LINE INDENT MP_TestNodeAlphabet . add_root ( numval = pos ) NEW_LINE DEDENT except : NEW_LINE INDENT got_err = True NEW_LINE break NEW_LINE DEDENT DEDENT if got_err : NEW_LINE INDENT break NEW_LINE DEDENT got = [ obj . path for obj in MP_TestNodeAlphabet . objects . all ( ) ] NEW_LINE if got != expected : NEW_LINE INDENT got_err = True NEW_LINE DEDENT last_good = alphabet NEW_LINE DEDENT print ' \n The ▁ best ▁ BASE85 ▁ based ▁ alphabet ▁ for ▁ your ▁ setup ▁ is : ▁ % s ' % ( last_good , ) NEW_LINE DEDENT DEDENT class TestHelpers ( TestTreeBase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT for model in ( MP_TestNode , AL_TestNode , NS_TestNode ) : NEW_LINE INDENT model . load_bulk ( BASE_DATA ) NEW_LINE for node in model . get_root_nodes ( ) : NEW_LINE INDENT model . load_bulk ( BASE_DATA , node ) NEW_LINE DEDENT model . add_root ( desc = '5' ) NEW_LINE DEDENT DEDENT def _multi_descendants_group_count_root ( self ) : NEW_LINE INDENT expected = [ ( o . desc , o . get_descendant_count ( ) ) for o in self . model . get_root_nodes ( ) ] NEW_LINE got = [ ( o . desc , o . descendants_count ) for o in self . model . get_descendants_group_count ( ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_descendants_group_count_node ( self ) : NEW_LINE INDENT parent = self . model . get_root_nodes ( ) . get ( desc = '2' ) NEW_LINE expected = [ ( o . desc , o . get_descendant_count ( ) ) for o in parent . get_children ( ) ] NEW_LINE got = [ ( o . desc , o . descendants_count ) for o in self . model . get_descendants_group_count ( parent ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT class TestMP_TreeSortedAutoNow ( TestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ sorting ▁ mechanism ▁ used ▁ by ▁ treebeard ▁ when ▁ adding ▁ a ▁ node ▁ can ▁ fail ▁ if ▁ the STRNEWLINE ▁ ordering ▁ is ▁ using ▁ an ▁ " auto _ now " ▁ field STRNEWLINE ▁ """ NEW_LINE def test_sorted_by_autonow_workaround ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ workaround STRNEWLINE ▁ """ NEW_LINE import datetime NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT MP_TestNodeSortedAutoNow . add_root ( desc = ' node % d ' % ( i , ) , created = datetime . datetime . now ( ) ) NEW_LINE DEDENT DEDENT def test_sorted_by_autonow_FAIL ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ test ▁ asserts ▁ that ▁ we ▁ have ▁ a ▁ problem . STRNEWLINE ▁ fix ▁ this , ▁ somehow STRNEWLINE ▁ """ NEW_LINE MP_TestNodeSortedAutoNow . add_root ( desc = ' node1' ) NEW_LINE self . assertRaises ( ValueError , MP_TestNodeSortedAutoNow . add_root , desc = ' node2' ) NEW_LINE DEDENT DEDENT class TestMP_TreeStepOverflow ( TestCase ) : NEW_LINE INDENT def test_add_root ( self ) : NEW_LINE INDENT method = MP_TestNodeSmallStep . add_root NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT method ( ) NEW_LINE DEDENT self . assertRaises ( PathOverflow , method ) NEW_LINE DEDENT def test_add_child ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE method = root . add_child NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT method ( ) NEW_LINE DEDENT self . assertRaises ( PathOverflow , method ) NEW_LINE DEDENT def test_add_sibling ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT root . add_child ( ) NEW_LINE DEDENT method = root . get_last_child ( ) . add_sibling NEW_LINE positions = ( ' first - sibling ' , ' left ' , ' right ' , ' last - sibling ' ) NEW_LINE for pos in positions : NEW_LINE INDENT self . assertRaises ( PathOverflow , method , pos ) NEW_LINE DEDENT DEDENT def test_move ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT root . add_child ( ) NEW_LINE DEDENT newroot = MP_TestNodeSmallStep . add_root ( ) NEW_LINE targets = [ ( root , [ ' first - child ' , ' last - child ' ] ) , ( root . get_first_child ( ) , [ ' first - sibling ' , ' left ' , ' right ' , ' last - sibling ' ] ) ] NEW_LINE for target , positions in targets : NEW_LINE INDENT for pos in positions : NEW_LINE INDENT self . assertRaises ( PathOverflow , newroot . move , target , pos ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class TestMP_TreeShortPath ( TestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Here ▁ we ▁ test ▁ a ▁ tree ▁ with ▁ a ▁ very ▁ small ▁ path ▁ field ▁ ( max _ length = 4 ) ▁ and ▁ a STRNEWLINE ▁ steplen ▁ of ▁ 1 STRNEWLINE ▁ """ NEW_LINE def test_short_path ( self ) : NEW_LINE INDENT obj = MP_TestNodeShortPath . add_root ( ) NEW_LINE obj = obj . add_child ( ) . add_child ( ) . add_child ( ) NEW_LINE self . assertRaises ( PathOverflow , obj . add_child ) NEW_LINE DEDENT DEDENT class TestMP_TreeFindProblems ( TestTreeBase ) : NEW_LINE INDENT def test_find_problems ( self ) : NEW_LINE INDENT model = MP_TestNodeAlphabet NEW_LINE model . alphabet = '01234' NEW_LINE model ( path = '01' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '1' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '111' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = ' abcd ' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = ' qa # $ % ! ' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0201' , depth = 2 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '020201' , depth = 3 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '03' , depth = 1 , numchild = 2 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0301' , depth = 2 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '030102' , depth = 3 , numchild = 10 , numval = 0 ) . save ( ) NEW_LINE model ( path = '04' , depth = 10 , numchild = 1 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0401' , depth = 20 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE evil_chars , bad_steplen , orphans , wrong_depth , wrong_numchild = model . find_problems ( ) NEW_LINE self . assertEqual ( [ ' abcd ' , ' qa # $ % ! ' ] , [ o . path for o in model . objects . filter ( id__in = evil_chars ) ] ) NEW_LINE self . assertEqual ( [ '1' , '111' ] , [ o . path for o in model . objects . filter ( id__in = bad_steplen ) ] ) NEW_LINE self . assertEqual ( [ '0201' , '020201' ] , [ o . path for o in model . objects . filter ( id__in = orphans ) ] ) NEW_LINE self . assertEqual ( [ '03' , '0301' , '030102' ] , [ o . path for o in model . objects . filter ( id__in = wrong_numchild ) ] ) NEW_LINE self . assertEqual ( [ '04' , '0401' ] , [ o . path for o in model . objects . filter ( id__in = wrong_depth ) ] ) NEW_LINE DEDENT DEDENT class TestMP_TreeFix ( TestTreeBase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestMP_TreeFix , self ) . setUp ( ) NEW_LINE self . expected_no_holes = { MP_TestNodeShortPath : [ ( u ' 1' , u ' b ' , 1 , 2 ) , ( u ' 11' , u ' u ' , 2 , 1 ) , ( u ' 111' , u ' i ' , 3 , 1 ) , ( u ' 1111' , u ' e ' , 4 , 0 ) , ( u ' 12' , u ' o ' , 2 , 0 ) , ( u ' 2' , u ' d ' , 1 , 0 ) , ( u ' 3' , u ' g ' , 1 , 0 ) , ( u ' 4' , u ' a ' , 1 , 4 ) , ( u ' 41' , u ' a ' , 2 , 0 ) , ( u ' 42' , u ' a ' , 2 , 0 ) , ( u ' 43' , u ' u ' , 2 , 1 ) , ( u ' 431' , u ' i ' , 3 , 1 ) , ( u ' 4311' , u ' e ' , 4 , 0 ) , ( u ' 44' , u ' o ' , 2 , 0 ) ] , MP_TestSortedNodeShortPath : [ ( u ' 1' , u ' a ' , 1 , 4 ) , ( u ' 11' , u ' a ' , 2 , 0 ) , ( u ' 12' , u ' a ' , 2 , 0 ) , ( u ' 13' , u ' o ' , 2 , 0 ) , ( u ' 14' , u ' u ' , 2 , 1 ) , ( u ' 141' , u ' i ' , 3 , 1 ) , ( u ' 1411' , u ' e ' , 4 , 0 ) , ( u ' 2' , u ' b ' , 1 , 2 ) , ( u ' 21' , u ' o ' , 2 , 0 ) , ( u ' 22' , u ' u ' , 2 , 1 ) , ( u ' 221' , u ' i ' , 3 , 1 ) , ( u ' 2211' , u ' e ' , 4 , 0 ) , ( u ' 3' , u ' d ' , 1 , 0 ) , ( u ' 4' , u ' g ' , 1 , 0 ) ] } NEW_LINE self . expected_with_holes = { MP_TestNodeShortPath : [ ( u ' 1' , u ' b ' , 1 L , 2 L ) , ( u ' 13' , u ' u ' , 2 L , 1 L ) , ( u ' 134' , u ' i ' , 3 L , 1 L ) , ( u ' 1343' , u ' e ' , 4 L , 0 L ) , ( u ' 14' , u ' o ' , 2 L , 0 L ) , ( u ' 2' , u ' d ' , 1 L , 0 L ) , ( u ' 3' , u ' g ' , 1 L , 0 L ) , ( u ' 4' , u ' a ' , 1 L , 4 L ) , ( u ' 41' , u ' a ' , 2 L , 0 L ) , ( u ' 42' , u ' a ' , 2 L , 0 L ) , ( u ' 43' , u ' u ' , 2 L , 1 L ) , ( u ' 434' , u ' i ' , 3 L , 1 L ) , ( u ' 4343' , u ' e ' , 4 L , 0 L ) , ( u ' 44' , u ' o ' , 2 L , 0 L ) ] , MP_TestSortedNodeShortPath : [ ( u ' 1' , u ' b ' , 1 L , 2 L ) , ( u ' 13' , u ' u ' , 2 L , 1 L ) , ( u ' 134' , u ' i ' , 3 L , 1 L ) , ( u ' 1343' , u ' e ' , 4 L , 0 L ) , ( u ' 14' , u ' o ' , 2 L , 0 L ) , ( u ' 2' , u ' d ' , 1 L , 0 L ) , ( u ' 3' , u ' g ' , 1 L , 0 L ) , ( u ' 4' , u ' a ' , 1 L , 4 L ) , ( u ' 41' , u ' a ' , 2 L , 0 L ) , ( u ' 42' , u ' a ' , 2 L , 0 L ) , ( u ' 43' , u ' u ' , 2 L , 1 L ) , ( u ' 434' , u ' i ' , 3 L , 1 L ) , ( u ' 4343' , u ' e ' , 4 L , 0 L ) , ( u ' 44' , u ' o ' , 2 L , 0 L ) ] } NEW_LINE DEDENT def got ( self , model ) : NEW_LINE INDENT return [ ( o . path , o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in model . get_tree ( ) ] NEW_LINE DEDENT def add_broken_test_data ( self , model ) : NEW_LINE INDENT model ( path = '4' , depth = 2 , numchild = 2 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '13' , depth = 1000 , numchild = 0 , desc = ' u ' ) . save ( ) NEW_LINE model ( path = '14' , depth = 4 , numchild = 500 , desc = ' o ' ) . save ( ) NEW_LINE model ( path = '134' , depth = 321 , numchild = 543 , desc = ' i ' ) . save ( ) NEW_LINE model ( path = '1343' , depth = 321 , numchild = 543 , desc = ' e ' ) . save ( ) NEW_LINE model ( path = '42' , depth = 1 , numchild = 1 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '43' , depth = 1000 , numchild = 0 , desc = ' u ' ) . save ( ) NEW_LINE model ( path = '44' , depth = 4 , numchild = 500 , desc = ' o ' ) . save ( ) NEW_LINE model ( path = '434' , depth = 321 , numchild = 543 , desc = ' i ' ) . save ( ) NEW_LINE model ( path = '4343' , depth = 321 , numchild = 543 , desc = ' e ' ) . save ( ) NEW_LINE model ( path = '41' , depth = 1 , numchild = 1 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '3' , depth = 221 , numchild = 322 , desc = ' g ' ) . save ( ) NEW_LINE model ( path = '1' , depth = 10 , numchild = 3 , desc = ' b ' ) . save ( ) NEW_LINE model ( path = '2' , depth = 10 , numchild = 3 , desc = ' d ' ) . save ( ) NEW_LINE DEDENT def test_fix_tree_non_destructive ( self ) : NEW_LINE INDENT for model in ( MP_TestNodeShortPath , MP_TestSortedNodeShortPath ) : NEW_LINE INDENT self . add_broken_test_data ( model ) NEW_LINE model . fix_tree ( destructive = False ) NEW_LINE self . assertEqual ( self . got ( model ) , self . expected_with_holes [ model ] ) NEW_LINE model . find_problems ( ) NEW_LINE DEDENT DEDENT def test_fix_tree_destructive ( self ) : NEW_LINE INDENT for model in ( MP_TestNodeShortPath , MP_TestSortedNodeShortPath ) : NEW_LINE INDENT self . add_broken_test_data ( model ) NEW_LINE model . fix_tree ( destructive = True ) NEW_LINE self . assertEqual ( self . got ( model ) , self . expected_no_holes [ model ] ) NEW_LINE model . find_problems ( ) NEW_LINE DEDENT DEDENT DEDENT class TestIssues ( TestCase ) : NEW_LINE INDENT " test ▁ for ▁ http : / / code . google . com / p / django - treebeard / issues / detail ? id = 14" NEW_LINE def test_many_to_many_django_user_anonymous ( self ) : NEW_LINE INDENT if not HAS_DJANGO_AUTH : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT self . fail ( ' this ▁ test ▁ needs ▁ django . contrib . auth ▁ in ▁ INSTALLED _ APPS ' ) NEW_LINE # ▁ Using ▁ AnonymousUser ( ) ▁ in ▁ the ▁ querysets ▁ will ▁ expose ▁ non - treebeard ENDCOM # ▁ related ▁ problems ▁ in ▁ Django ▁ 1.0 ENDCOM # ▁ Postgres : ENDCOM # ▁ ProgrammingError : ▁ can ' t ▁ adapt ENDCOM # ▁ SQLite : ENDCOM # ▁ InterfaceError : ▁ Error ▁ binding ▁ parameter ▁ 4 ▁ - ▁ probably ▁ unsupported ENDCOM # ▁ type . ENDCOM # ▁ MySQL ▁ compared ▁ a ▁ string ▁ to ▁ an ▁ integer ▁ field : ENDCOM # ▁ ` treebeard _ mp _ testissue14 _ users ` . ` user _ id ` ▁ = ▁ ' AnonymousUser ' ENDCOM # ▁ Using ▁ a ▁ None ▁ field ▁ instead ▁ works ▁ ( will ▁ be ▁ translated ▁ to ▁ IS ▁ NULL ) . ENDCOM # ▁ anonuserobj ▁ = ▁ AnonymousUser ( ) ENDCOM DEDENT anonuserobj = None NEW_LINE def qs_check ( qs , expected ) : NEW_LINE INDENT self . assertEqual ( [ o . name for o in qs ] , expected ) NEW_LINE DEDENT user = User . objects . create_user ( ' test _ user ' , ' test @ example . com ' , ' testpasswd ' ) NEW_LINE user . save ( ) NEW_LINE root = MP_TestIssue14 . add_root ( name = " the ▁ root ▁ node " ) NEW_LINE root . add_child ( name = " first " ) NEW_LINE second = root . add_child ( name = " second " ) NEW_LINE qs_check ( root . get_children ( ) , [ ' first ' , ' second ' ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) ) , [ ' first ' ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( users = user ) ) , [ ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' ] ) NEW_LINE user = anonuserobj NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' , ' second ' ] ) NEW_LINE user = User . objects . get ( username = " test _ user " ) NEW_LINE second . users . add ( user ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' , ' second ' ] ) NEW_LINE user = anonuserobj NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' ] ) NEW_LINE DEDENT DEDENT class TestModelAdmin ( ModelAdmin ) : NEW_LINE INDENT form = MoveNodeForm NEW_LINE DEDENT class TestMoveNodeForm ( TestTreeBase ) : NEW_LINE INDENT tpl = ( u ' < tr > < th > < label ▁ for = " id _ _ position " > Position : < / label > < / th > ' ' < td > < select ▁ name = " _ position " ▁ id = " id _ _ position " > \n ' ' < option ▁ value = " first - child " > First ▁ child ▁ of < / option > \n ' ' < option ▁ value = " left " > Before < / option > \n ' ' < option ▁ value = " right " > After < / option > \n ' ' < / select > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ ref _ node _ id " > Relative ▁ to : < / label > ' ' < / th > < td > < select ▁ name = " _ ref _ node _ id " ▁ id = " id _ _ ref _ node _ id " > \n ' ' < option ▁ value = " 0 " > - - ▁ root ▁ - - < / option > \n ' ) NEW_LINE def _multi_form_html_root_node ( self ) : NEW_LINE INDENT self . model . load_bulk ( BASE_DATA ) NEW_LINE node = self . model . get_tree ( ) [ 0 ] NEW_LINE form = MoveNodeForm ( instance = node ) NEW_LINE rtpl = self . tpl NEW_LINE self . assertEqual ( [ ' _ position ' , ' _ ref _ node _ id ' ] , form . base_fields . keys ( ) ) NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT if node != obj or obj . is_descendant_of ( node ) : NEW_LINE INDENT rtpl += ' < option ▁ value = " % d " > % sNode ▁ % d < / option > \n ' % ( obj . id , ' . ▁ . ▁ ' * ( obj . get_depth ( ) - 1 ) , obj . id ) NEW_LINE DEDENT DEDENT rtpl += ' < / select > < / td > < / tr > ' NEW_LINE formstr = unicode ( form ) . replace ( u ' ▁ selected = " selected " ' , u ' ' ) NEW_LINE self . assertEqual ( rtpl , formstr ) NEW_LINE DEDENT def _multi_form_html_leaf_node ( self ) : NEW_LINE INDENT self . model . load_bulk ( BASE_DATA ) NEW_LINE nodes = list ( self . model . get_tree ( ) ) NEW_LINE node = nodes [ - 1 ] NEW_LINE form = MoveNodeForm ( instance = node ) NEW_LINE rtpl = self . tpl NEW_LINE self . assertEqual ( [ ' _ position ' , ' _ ref _ node _ id ' ] , form . base_fields . keys ( ) ) NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT if node != obj or obj . is_descendant_of ( node ) : NEW_LINE INDENT rtpl += ' < option ▁ value = " % d " > % sNode ▁ % d < / option > \n ' % ( obj . id , ' . ▁ . ▁ ' * ( obj . get_depth ( ) - 1 ) , obj . id ) NEW_LINE DEDENT DEDENT rtpl += ' < / select > < / td > < / tr > ' NEW_LINE formstr = unicode ( form ) . replace ( u ' ▁ selected = " selected " ' , u ' ' ) NEW_LINE self . assertEqual ( rtpl , formstr ) NEW_LINE DEDENT def _multi_admin_html ( self ) : NEW_LINE INDENT tpl = ( ' < tr > < th > < label ▁ for = " id _ desc " > Desc : < / label > ' ' < / th > < td > < input ▁ id = " id _ desc " ▁ type = " text " ▁ class = " vTextField " ▁ ' ' name = " desc " ▁ maxlength = " 255 " ▁ / > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ position " > Position : < / label > < / th > ' ' < td > < select ▁ name = " _ position " ▁ id = " id _ _ position " > \n ' ' < option ▁ value = " first - child " > First ▁ child ▁ of < / option > \n ' ' < option ▁ value = " left " > Before < / option > \n ' ' < option ▁ value = " right " > After < / option > \n ' ' < / select > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ ref _ node _ id " > Relative ▁ to : < / label > ' ' < / th > < td > < select ▁ name = " _ ref _ node _ id " ▁ id = " id _ _ ref _ node _ id " > \n ' ' < option ▁ value = " 0 " > - - ▁ root ▁ - - < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < / select > < / td > < / tr > ' ) NEW_LINE request = None NEW_LINE self . model . load_bulk ( BASE_DATA ) NEW_LINE for node in self . model . objects . all ( ) : NEW_LINE INDENT site = AdminSite ( ) NEW_LINE ma = TestModelAdmin ( self . model , site ) NEW_LINE self . assertEqual ( [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] , ma . get_form ( request ) . base_fields . keys ( ) ) NEW_LINE self . assertEqual ( [ ( None , { ' fields ' : [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] } ) ] , ma . get_fieldsets ( request ) ) NEW_LINE self . assertEqual ( [ ( None , { ' fields ' : [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] } ) ] , ma . get_fieldsets ( request , node ) ) NEW_LINE form = ma . get_form ( request ) ( ) NEW_LINE ids = [ ] NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT ids . extend ( [ obj . id ] * 2 ) NEW_LINE DEDENT self . assertEqual ( tpl % tuple ( ids ) , unicode ( form ) ) NEW_LINE DEDENT DEDENT DEDENT _load_test_methods ( TestMoveNodeForm ) NEW_LINE _load_test_methods ( TestEmptyTree ) NEW_LINE _load_test_methods ( TestClassMethods ) NEW_LINE _load_test_methods ( TestSimpleNodeMethods ) NEW_LINE _load_test_methods ( TestAddChild ) NEW_LINE _load_test_methods ( TestAddSibling ) NEW_LINE _load_test_methods ( TestDelete ) NEW_LINE _load_test_methods ( TestMoveErrors ) NEW_LINE _load_test_methods ( TestMoveLeafRoot ) NEW_LINE _load_test_methods ( TestMoveLeaf ) NEW_LINE _load_test_methods ( TestMoveBranchRoot ) NEW_LINE _load_test_methods ( TestMoveBranch ) NEW_LINE _load_test_methods ( TestHelpers ) NEW_LINE # ▁ we ▁ didn ' t ▁ create ▁ extra ▁ sorted - proxy ▁ models ENDCOM _load_test_methods ( TestMoveSortedErrors , proxy = False ) NEW_LINE _load_test_methods ( TestTreeSorted , proxy = False ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="bdupharm/sqlalchemy/tree/master/lib/sqlalchemy/ext/declarative/api.py"> # ▁ ext / declarative / api . py ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2005-2016 ▁ the ▁ SQLAlchemy ▁ authors ▁ and ▁ contributors ENDCOM # ▁ < see ▁ AUTHORS ▁ file > ENDCOM # ▁ This ▁ module ▁ is ▁ part ▁ of ▁ SQLAlchemy ▁ and ▁ is ▁ released ▁ under ENDCOM # ▁ the ▁ MIT ▁ License : ▁ http : / / www . opensource . org / licenses / mit - license . php ENDCOM """ Public ▁ API ▁ functions ▁ and ▁ helpers ▁ for ▁ declarative . """ NEW_LINE from ... schema import Table , MetaData , Column NEW_LINE from ... orm import synonym as _orm_synonym , comparable_property , interfaces , properties , attributes NEW_LINE from ... orm . util import polymorphic_union NEW_LINE from ... orm . base import _mapper_or_none NEW_LINE from ... util import OrderedDict , hybridmethod , hybridproperty NEW_LINE from ... import util NEW_LINE from ... import exc NEW_LINE import weakref NEW_LINE from . base import _as_declarative , _declarative_constructor , _DeferredMapperConfig , _add_attribute NEW_LINE from . clsregistry import _class_resolver NEW_LINE def instrument_declarative ( cls , registry , metadata ) : NEW_LINE INDENT """ Given ▁ a ▁ class , ▁ configure ▁ the ▁ class ▁ declaratively , STRNEWLINE ▁ using ▁ the ▁ given ▁ registry , ▁ which ▁ can ▁ be ▁ any ▁ dictionary , ▁ and STRNEWLINE ▁ MetaData ▁ object . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if ' _ decl _ class _ registry ' in cls . __dict__ : NEW_LINE INDENT raise exc . InvalidRequestError ( " Class ▁ % r ▁ already ▁ has ▁ been ▁ " " instrumented ▁ declaratively " % cls ) NEW_LINE DEDENT cls . _decl_class_registry = registry NEW_LINE cls . metadata = metadata NEW_LINE _as_declarative ( cls , cls . __name__ , cls . __dict__ ) NEW_LINE DEDENT def has_inherited_table ( cls ) : NEW_LINE INDENT """ Given ▁ a ▁ class , ▁ return ▁ True ▁ if ▁ any ▁ of ▁ the ▁ classes ▁ it ▁ inherits ▁ from ▁ has ▁ a STRNEWLINE ▁ mapped ▁ table , ▁ otherwise ▁ return ▁ False . STRNEWLINE ▁ """ NEW_LINE for class_ in cls . __mro__ [ 1 : ] : NEW_LINE INDENT if getattr ( class_ , ' _ _ table _ _ ' , None ) is not None : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT class DeclarativeMeta ( type ) : NEW_LINE INDENT def __init__ ( cls , classname , bases , dict_ ) : NEW_LINE INDENT if ' _ decl _ class _ registry ' not in cls . __dict__ : NEW_LINE INDENT _as_declarative ( cls , classname , cls . __dict__ ) NEW_LINE DEDENT type . __init__ ( cls , classname , bases , dict_ ) NEW_LINE DEDENT def __setattr__ ( cls , key , value ) : NEW_LINE INDENT _add_attribute ( cls , key , value ) NEW_LINE DEDENT DEDENT def synonym_for ( name , map_column = False ) : NEW_LINE INDENT """ Decorator , ▁ make ▁ a ▁ Python ▁ @ property ▁ a ▁ query ▁ synonym ▁ for ▁ a ▁ column . STRNEWLINE STRNEWLINE ▁ A ▁ decorator ▁ version ▁ of ▁ : func : ` ~ sqlalchemy . orm . synonym ` . ▁ The ▁ function ▁ being STRNEWLINE ▁ decorated ▁ is ▁ the ▁ ' descriptor ' , ▁ otherwise ▁ passes ▁ its ▁ arguments ▁ through ▁ to STRNEWLINE ▁ synonym ( ) : : STRNEWLINE STRNEWLINE ▁ @ synonym _ for ( ' col ' ) STRNEWLINE ▁ @ property STRNEWLINE ▁ def ▁ prop ( self ) : STRNEWLINE ▁ return ▁ ' special ▁ sauce ' STRNEWLINE STRNEWLINE ▁ The ▁ regular ▁ ` ` synonym ( ) ` ` ▁ is ▁ also ▁ usable ▁ directly ▁ in ▁ a ▁ declarative ▁ setting STRNEWLINE ▁ and ▁ may ▁ be ▁ convenient ▁ for ▁ read / write ▁ properties : : STRNEWLINE STRNEWLINE ▁ prop ▁ = ▁ synonym ( ' col ' , ▁ descriptor = property ( _ read _ prop , ▁ _ write _ prop ) ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( fn ) : NEW_LINE INDENT return _orm_synonym ( name , map_column = map_column , descriptor = fn ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT def comparable_using ( comparator_factory ) : NEW_LINE INDENT """ Decorator , ▁ allow ▁ a ▁ Python ▁ @ property ▁ to ▁ be ▁ used ▁ in ▁ query ▁ criteria . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ a ▁ decorator ▁ front ▁ end ▁ to STRNEWLINE ▁ : func : ` ~ sqlalchemy . orm . comparable _ property ` ▁ that ▁ passes STRNEWLINE ▁ through ▁ the ▁ comparator _ factory ▁ and ▁ the ▁ function ▁ being ▁ decorated : : STRNEWLINE STRNEWLINE ▁ @ comparable _ using ( MyComparatorType ) STRNEWLINE ▁ @ property STRNEWLINE ▁ def ▁ prop ( self ) : STRNEWLINE ▁ return ▁ ' special ▁ sauce ' STRNEWLINE STRNEWLINE ▁ The ▁ regular ▁ ` ` comparable _ property ( ) ` ` ▁ is ▁ also ▁ usable ▁ directly ▁ in ▁ a STRNEWLINE ▁ declarative ▁ setting ▁ and ▁ may ▁ be ▁ convenient ▁ for ▁ read / write ▁ properties : : STRNEWLINE STRNEWLINE ▁ prop ▁ = ▁ comparable _ property ( MyComparatorType ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( fn ) : NEW_LINE INDENT return comparable_property ( comparator_factory , fn ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT class declared_attr ( interfaces . _MappedAttribute , property ) : NEW_LINE INDENT """ Mark ▁ a ▁ class - level ▁ method ▁ as ▁ representing ▁ the ▁ definition ▁ of STRNEWLINE ▁ a ▁ mapped ▁ property ▁ or ▁ special ▁ declarative ▁ member ▁ name . STRNEWLINE STRNEWLINE ▁ @ declared _ attr ▁ turns ▁ the ▁ attribute ▁ into ▁ a ▁ scalar - like STRNEWLINE ▁ property ▁ that ▁ can ▁ be ▁ invoked ▁ from ▁ the ▁ uninstantiated ▁ class . STRNEWLINE ▁ Declarative ▁ treats ▁ attributes ▁ specifically ▁ marked ▁ with STRNEWLINE ▁ @ declared _ attr ▁ as ▁ returning ▁ a ▁ construct ▁ that ▁ is ▁ specific STRNEWLINE ▁ to ▁ mapping ▁ or ▁ declarative ▁ table ▁ configuration . ▁ The ▁ name STRNEWLINE ▁ of ▁ the ▁ attribute ▁ is ▁ that ▁ of ▁ what ▁ the ▁ non - dynamic ▁ version STRNEWLINE ▁ of ▁ the ▁ attribute ▁ would ▁ be . STRNEWLINE STRNEWLINE ▁ @ declared _ attr ▁ is ▁ more ▁ often ▁ than ▁ not ▁ applicable ▁ to ▁ mixins , STRNEWLINE ▁ to ▁ define ▁ relationships ▁ that ▁ are ▁ to ▁ be ▁ applied ▁ to ▁ different STRNEWLINE ▁ implementors ▁ of ▁ the ▁ class : : STRNEWLINE STRNEWLINE ▁ class ▁ ProvidesUser ( object ) : STRNEWLINE ▁ " A ▁ mixin ▁ that ▁ adds ▁ a ▁ ' user ' ▁ relationship ▁ to ▁ classes . " STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ user ( self ) : STRNEWLINE ▁ return ▁ relationship ( " User " ) STRNEWLINE STRNEWLINE ▁ It ▁ also ▁ can ▁ be ▁ applied ▁ to ▁ mapped ▁ classes , ▁ such ▁ as ▁ to ▁ provide STRNEWLINE ▁ a ▁ " polymorphic " ▁ scheme ▁ for ▁ inheritance : : STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( Base ) : STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ type ▁ = ▁ Column ( String ( 50 ) , ▁ nullable = False ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ tablename _ _ ( cls ) : STRNEWLINE ▁ return ▁ cls . _ _ name _ _ . lower ( ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ mapper _ args _ _ ( cls ) : STRNEWLINE ▁ if ▁ cls . _ _ name _ _ ▁ = = ▁ ' Employee ' : STRNEWLINE ▁ return ▁ { STRNEWLINE ▁ " polymorphic _ on " : cls . type , STRNEWLINE ▁ " polymorphic _ identity " : " Employee " STRNEWLINE ▁ } STRNEWLINE ▁ else : STRNEWLINE ▁ return ▁ { " polymorphic _ identity " : cls . _ _ name _ _ } STRNEWLINE STRNEWLINE ▁ . . ▁ versionchanged : : ▁ 0.8 ▁ : class : ` . declared _ attr ` ▁ can ▁ be ▁ used ▁ with STRNEWLINE ▁ non - ORM ▁ or ▁ extension ▁ attributes , ▁ such ▁ as ▁ user - defined ▁ attributes STRNEWLINE ▁ or ▁ : func : ` . association _ proxy ` ▁ objects , ▁ which ▁ will ▁ be ▁ assigned STRNEWLINE ▁ to ▁ the ▁ class ▁ at ▁ class ▁ construction ▁ time . STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , fget , cascading = False ) : NEW_LINE INDENT super ( declared_attr , self ) . __init__ ( fget ) NEW_LINE self . __doc__ = fget . __doc__ NEW_LINE self . _cascading = cascading NEW_LINE DEDENT def __get__ ( desc , self , cls ) : NEW_LINE INDENT reg = cls . __dict__ . get ( ' _ sa _ declared _ attr _ reg ' , None ) NEW_LINE if reg is None : NEW_LINE INDENT manager = attributes . manager_of_class ( cls ) NEW_LINE if manager is None : NEW_LINE INDENT util . warn ( " Unmanaged ▁ access ▁ of ▁ declarative ▁ attribute ▁ % s ▁ from ▁ " " non - mapped ▁ class ▁ % s " % ( desc . fget . __name__ , cls . __name__ ) ) NEW_LINE DEDENT return desc . fget ( cls ) NEW_LINE DEDENT if reg is None : NEW_LINE INDENT return desc . fget ( cls ) NEW_LINE DEDENT elif desc in reg : NEW_LINE INDENT return reg [ desc ] NEW_LINE DEDENT else : NEW_LINE INDENT reg [ desc ] = obj = desc . fget ( cls ) NEW_LINE return obj NEW_LINE DEDENT DEDENT @ hybridmethod NEW_LINE def _stateful ( cls , ** kw ) : NEW_LINE INDENT return _stateful_declared_attr ( ** kw ) NEW_LINE DEDENT @ hybridproperty NEW_LINE def cascading ( cls ) : NEW_LINE INDENT """ Mark ▁ a ▁ : class : ` . declared _ attr ` ▁ as ▁ cascading . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ a ▁ special - use ▁ modifier ▁ which ▁ indicates ▁ that ▁ a ▁ column STRNEWLINE ▁ or ▁ MapperProperty - based ▁ declared ▁ attribute ▁ should ▁ be ▁ configured STRNEWLINE ▁ distinctly ▁ per ▁ mapped ▁ subclass , ▁ within ▁ a ▁ mapped - inheritance ▁ scenario . STRNEWLINE STRNEWLINE ▁ Below , ▁ both ▁ MyClass ▁ as ▁ well ▁ as ▁ MySubClass ▁ will ▁ have ▁ a ▁ distinct STRNEWLINE ▁ ` ` id ` ` ▁ Column ▁ object ▁ established : : STRNEWLINE STRNEWLINE ▁ class ▁ HasSomeAttribute ( object ) : STRNEWLINE ▁ @ declared _ attr . cascading STRNEWLINE ▁ def ▁ some _ id ( cls ) : STRNEWLINE ▁ if ▁ has _ inherited _ table ( cls ) : STRNEWLINE ▁ return ▁ Column ( STRNEWLINE ▁ ForeignKey ( ' myclass . id ' ) , ▁ primary _ key = True ) STRNEWLINE ▁ else : STRNEWLINE ▁ return ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ return ▁ Column ( ' id ' , ▁ Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ MyClass ( HasSomeAttribute , ▁ Base ) : STRNEWLINE ▁ " " STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ class ▁ MySubClass ( MyClass ) : STRNEWLINE ▁ " " STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ The ▁ behavior ▁ of ▁ the ▁ above ▁ configuration ▁ is ▁ that ▁ ` ` MySubClass ` ` STRNEWLINE ▁ will ▁ refer ▁ to ▁ both ▁ its ▁ own ▁ ` ` id ` ` ▁ column ▁ as ▁ well ▁ as ▁ that ▁ of STRNEWLINE ▁ ` ` MyClass ` ` ▁ underneath ▁ the ▁ attribute ▁ named ▁ ` ` some _ id ` ` . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : ref : ` declarative _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` mixin _ inheritance _ columns ` STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE return cls . _stateful ( cascading = True ) NEW_LINE DEDENT DEDENT class _stateful_declared_attr ( declared_attr ) : NEW_LINE INDENT def __init__ ( self , ** kw ) : NEW_LINE INDENT self . kw = kw NEW_LINE DEDENT def _stateful ( self , ** kw ) : NEW_LINE INDENT new_kw = self . kw . copy ( ) NEW_LINE new_kw . update ( kw ) NEW_LINE return _stateful_declared_attr ( ** new_kw ) NEW_LINE DEDENT def __call__ ( self , fn ) : NEW_LINE INDENT return declared_attr ( fn , ** self . kw ) NEW_LINE DEDENT DEDENT def declarative_base ( bind = None , metadata = None , mapper = None , cls = object , name = ' Base ' , constructor = _declarative_constructor , class_registry = None , metaclass = DeclarativeMeta ) : NEW_LINE INDENT """ Construct ▁ a ▁ base ▁ class ▁ for ▁ declarative ▁ class ▁ definitions . STRNEWLINE STRNEWLINE ▁ The ▁ new ▁ base ▁ class ▁ will ▁ be ▁ given ▁ a ▁ metaclass ▁ that ▁ produces STRNEWLINE ▁ appropriate ▁ : class : ` ~ sqlalchemy . schema . Table ` ▁ objects ▁ and ▁ makes STRNEWLINE ▁ the ▁ appropriate ▁ : func : ` ~ sqlalchemy . orm . mapper ` ▁ calls ▁ based ▁ on ▁ the STRNEWLINE ▁ information ▁ provided ▁ declaratively ▁ in ▁ the ▁ class ▁ and ▁ any ▁ subclasses STRNEWLINE ▁ of ▁ the ▁ class . STRNEWLINE STRNEWLINE ▁ : param ▁ bind : ▁ An ▁ optional STRNEWLINE ▁ : class : ` ~ sqlalchemy . engine . Connectable ` , ▁ will ▁ be ▁ assigned STRNEWLINE ▁ the ▁ ` ` bind ` ` ▁ attribute ▁ on ▁ the ▁ : class : ` ~ sqlalchemy . schema . MetaData ` STRNEWLINE ▁ instance . STRNEWLINE STRNEWLINE ▁ : param ▁ metadata : STRNEWLINE ▁ An ▁ optional ▁ : class : ` ~ sqlalchemy . schema . MetaData ` ▁ instance . ▁ All STRNEWLINE ▁ : class : ` ~ sqlalchemy . schema . Table ` ▁ objects ▁ implicitly ▁ declared ▁ by STRNEWLINE ▁ subclasses ▁ of ▁ the ▁ base ▁ will ▁ share ▁ this ▁ MetaData . ▁ A ▁ MetaData ▁ instance STRNEWLINE ▁ will ▁ be ▁ created ▁ if ▁ none ▁ is ▁ provided . ▁ The STRNEWLINE ▁ : class : ` ~ sqlalchemy . schema . MetaData ` ▁ instance ▁ will ▁ be ▁ available ▁ via ▁ the STRNEWLINE ▁ ` metadata ` ▁ attribute ▁ of ▁ the ▁ generated ▁ declarative ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ : param ▁ mapper : STRNEWLINE ▁ An ▁ optional ▁ callable , ▁ defaults ▁ to ▁ : func : ` ~ sqlalchemy . orm . mapper ` . ▁ Will STRNEWLINE ▁ be ▁ used ▁ to ▁ map ▁ subclasses ▁ to ▁ their ▁ Tables . STRNEWLINE STRNEWLINE ▁ : param ▁ cls : STRNEWLINE ▁ Defaults ▁ to ▁ : class : ` object ` . ▁ A ▁ type ▁ to ▁ use ▁ as ▁ the ▁ base ▁ for ▁ the ▁ generated STRNEWLINE ▁ declarative ▁ base ▁ class . ▁ May ▁ be ▁ a ▁ class ▁ or ▁ tuple ▁ of ▁ classes . STRNEWLINE STRNEWLINE ▁ : param ▁ name : STRNEWLINE ▁ Defaults ▁ to ▁ ` ` Base ` ` . ▁ The ▁ display ▁ name ▁ for ▁ the ▁ generated STRNEWLINE ▁ class . ▁ Customizing ▁ this ▁ is ▁ not ▁ required , ▁ but ▁ can ▁ improve ▁ clarity ▁ in STRNEWLINE ▁ tracebacks ▁ and ▁ debugging . STRNEWLINE STRNEWLINE ▁ : param ▁ constructor : STRNEWLINE ▁ Defaults ▁ to STRNEWLINE ▁ : func : ` ~ sqlalchemy . ext . declarative . _ declarative _ constructor ` , ▁ an STRNEWLINE ▁ _ _ init _ _ ▁ implementation ▁ that ▁ assigns ▁ \ * * kwargs ▁ for ▁ declared STRNEWLINE ▁ fields ▁ and ▁ relationships ▁ to ▁ an ▁ instance . ▁ If ▁ ` ` None ` ` ▁ is ▁ supplied , STRNEWLINE ▁ no ▁ _ _ init _ _ ▁ will ▁ be ▁ provided ▁ and ▁ construction ▁ will ▁ fall ▁ back ▁ to STRNEWLINE ▁ cls . _ _ init _ _ ▁ by ▁ way ▁ of ▁ the ▁ normal ▁ Python ▁ semantics . STRNEWLINE STRNEWLINE ▁ : param ▁ class _ registry : ▁ optional ▁ dictionary ▁ that ▁ will ▁ serve ▁ as ▁ the STRNEWLINE ▁ registry ▁ of ▁ class ▁ names - > ▁ mapped ▁ classes ▁ when ▁ string ▁ names STRNEWLINE ▁ are ▁ used ▁ to ▁ identify ▁ classes ▁ inside ▁ of ▁ : func : ` . relationship ` STRNEWLINE ▁ and ▁ others . ▁ Allows ▁ two ▁ or ▁ more ▁ declarative ▁ base ▁ classes STRNEWLINE ▁ to ▁ share ▁ the ▁ same ▁ registry ▁ of ▁ class ▁ names ▁ for ▁ simplified STRNEWLINE ▁ inter - base ▁ relationships . STRNEWLINE STRNEWLINE ▁ : param ▁ metaclass : STRNEWLINE ▁ Defaults ▁ to ▁ : class : ` . DeclarativeMeta ` . ▁ A ▁ metaclass ▁ or ▁ _ _ metaclass _ _ STRNEWLINE ▁ compatible ▁ callable ▁ to ▁ use ▁ as ▁ the ▁ meta ▁ type ▁ of ▁ the ▁ generated STRNEWLINE ▁ declarative ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : func : ` . as _ declarative ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE lcl_metadata = metadata or MetaData ( ) NEW_LINE if bind : NEW_LINE INDENT lcl_metadata . bind = bind NEW_LINE DEDENT if class_registry is None : NEW_LINE INDENT class_registry = weakref . WeakValueDictionary ( ) NEW_LINE DEDENT bases = not isinstance ( cls , tuple ) and ( cls , ) or cls NEW_LINE class_dict = dict ( _decl_class_registry = class_registry , metadata = lcl_metadata ) NEW_LINE if constructor : NEW_LINE INDENT class_dict [ ' _ _ init _ _ ' ] = constructor NEW_LINE DEDENT if mapper : NEW_LINE INDENT class_dict [ ' _ _ mapper _ cls _ _ ' ] = mapper NEW_LINE DEDENT return metaclass ( name , bases , class_dict ) NEW_LINE DEDENT def as_declarative ( ** kw ) : NEW_LINE INDENT """ STRNEWLINE ▁ Class ▁ decorator ▁ for ▁ : func : ` . declarative _ base ` . STRNEWLINE STRNEWLINE ▁ Provides ▁ a ▁ syntactical ▁ shortcut ▁ to ▁ the ▁ ` ` cls ` ` ▁ argument STRNEWLINE ▁ sent ▁ to ▁ : func : ` . declarative _ base ` , ▁ allowing ▁ the ▁ base ▁ class STRNEWLINE ▁ to ▁ be ▁ converted ▁ in - place ▁ to ▁ a ▁ " declarative " ▁ base : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ as _ declarative STRNEWLINE STRNEWLINE ▁ @ as _ declarative ( ) STRNEWLINE ▁ class ▁ Base ( object ) : STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ tablename _ _ ( cls ) : STRNEWLINE ▁ return ▁ cls . _ _ name _ _ . lower ( ) STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ MyMappedClass ( Base ) : STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ All ▁ keyword ▁ arguments ▁ passed ▁ to ▁ : func : ` . as _ declarative ` ▁ are ▁ passed STRNEWLINE ▁ along ▁ to ▁ : func : ` . declarative _ base ` . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 0.8.3 STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : func : ` . declarative _ base ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( cls ) : NEW_LINE INDENT kw [ ' cls ' ] = cls NEW_LINE kw [ ' name ' ] = cls . __name__ NEW_LINE return declarative_base ( ** kw ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT class ConcreteBase ( object ) : NEW_LINE INDENT """ A ▁ helper ▁ class ▁ for ▁ ' concrete ' ▁ declarative ▁ mappings . STRNEWLINE STRNEWLINE ▁ : class : ` . ConcreteBase ` ▁ will ▁ use ▁ the ▁ : func : ` . polymorphic _ union ` STRNEWLINE ▁ function ▁ automatically , ▁ against ▁ all ▁ tables ▁ mapped ▁ as ▁ a ▁ subclass STRNEWLINE ▁ to ▁ this ▁ class . ▁ The ▁ function ▁ is ▁ called ▁ via ▁ the STRNEWLINE ▁ ` ` _ _ declare _ last _ _ ( ) ` ` ▁ function , ▁ which ▁ is ▁ essentially STRNEWLINE ▁ a ▁ hook ▁ for ▁ the ▁ : meth : ` . after _ configured ` ▁ event . STRNEWLINE STRNEWLINE ▁ : class : ` . ConcreteBase ` ▁ produces ▁ a ▁ mapped STRNEWLINE ▁ table ▁ for ▁ the ▁ class ▁ itself . ▁ Compare ▁ to ▁ : class : ` . AbstractConcreteBase ` , STRNEWLINE ▁ which ▁ does ▁ not . STRNEWLINE STRNEWLINE ▁ Example : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ ConcreteBase STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( ConcreteBase , ▁ Base ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' employee ' STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' employee ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ class ▁ Manager ( Employee ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' manager ' STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ manager _ data ▁ = ▁ Column ( String ( 40 ) ) STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' manager ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : class : ` . AbstractConcreteBase ` STRNEWLINE STRNEWLINE ▁ : ref : ` concrete _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` inheritance _ concrete _ helpers ` STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def _create_polymorphic_union ( cls , mappers ) : NEW_LINE INDENT return polymorphic_union ( OrderedDict ( ( mp . polymorphic_identity , mp . local_table ) for mp in mappers ) , ' type ' , ' pjoin ' ) NEW_LINE DEDENT @ classmethod NEW_LINE def __declare_first__ ( cls ) : NEW_LINE INDENT m = cls . __mapper__ NEW_LINE if m . with_polymorphic : NEW_LINE INDENT return NEW_LINE DEDENT mappers = list ( m . self_and_descendants ) NEW_LINE pjoin = cls . _create_polymorphic_union ( mappers ) NEW_LINE m . _set_with_polymorphic ( ( " * " , pjoin ) ) NEW_LINE m . _set_polymorphic_on ( pjoin . c . type ) NEW_LINE DEDENT DEDENT class AbstractConcreteBase ( ConcreteBase ) : NEW_LINE INDENT """ A ▁ helper ▁ class ▁ for ▁ ' concrete ' ▁ declarative ▁ mappings . STRNEWLINE STRNEWLINE ▁ : class : ` . AbstractConcreteBase ` ▁ will ▁ use ▁ the ▁ : func : ` . polymorphic _ union ` STRNEWLINE ▁ function ▁ automatically , ▁ against ▁ all ▁ tables ▁ mapped ▁ as ▁ a ▁ subclass STRNEWLINE ▁ to ▁ this ▁ class . ▁ The ▁ function ▁ is ▁ called ▁ via ▁ the STRNEWLINE ▁ ` ` _ _ declare _ last _ _ ( ) ` ` ▁ function , ▁ which ▁ is ▁ essentially STRNEWLINE ▁ a ▁ hook ▁ for ▁ the ▁ : meth : ` . after _ configured ` ▁ event . STRNEWLINE STRNEWLINE ▁ : class : ` . AbstractConcreteBase ` ▁ does ▁ produce ▁ a ▁ mapped ▁ class STRNEWLINE ▁ for ▁ the ▁ base ▁ class , ▁ however ▁ it ▁ is ▁ not ▁ persisted ▁ to ▁ any ▁ table ; ▁ it STRNEWLINE ▁ is ▁ instead ▁ mapped ▁ directly ▁ to ▁ the ▁ " polymorphic " ▁ selectable ▁ directly STRNEWLINE ▁ and ▁ is ▁ only ▁ used ▁ for ▁ selecting . ▁ Compare ▁ to ▁ : class : ` . ConcreteBase ` , STRNEWLINE ▁ which ▁ does ▁ create ▁ a ▁ persisted ▁ table ▁ for ▁ the ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ Example : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ AbstractConcreteBase STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( AbstractConcreteBase , ▁ Base ) : STRNEWLINE ▁ pass STRNEWLINE STRNEWLINE ▁ class ▁ Manager ( Employee ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' manager ' STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ manager _ data ▁ = ▁ Column ( String ( 40 ) ) STRNEWLINE STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' manager ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ The ▁ abstract ▁ base ▁ class ▁ is ▁ handled ▁ by ▁ declarative ▁ in ▁ a ▁ special ▁ way ; STRNEWLINE ▁ at ▁ class ▁ configuration ▁ time , ▁ it ▁ behaves ▁ like ▁ a ▁ declarative ▁ mixin STRNEWLINE ▁ or ▁ an ▁ ` ` _ _ abstract _ _ ` ` ▁ base ▁ class . ▁ Once ▁ classes ▁ are ▁ configured STRNEWLINE ▁ and ▁ mappings ▁ are ▁ produced , ▁ it ▁ then ▁ gets ▁ mapped ▁ itself , ▁ but STRNEWLINE ▁ after ▁ all ▁ of ▁ its ▁ decscendants . ▁ This ▁ is ▁ a ▁ very ▁ unique ▁ system ▁ of ▁ mapping STRNEWLINE ▁ not ▁ found ▁ in ▁ any ▁ other ▁ SQLAlchemy ▁ system . STRNEWLINE STRNEWLINE ▁ Using ▁ this ▁ approach , ▁ we ▁ can ▁ specify ▁ columns ▁ and ▁ properties STRNEWLINE ▁ that ▁ will ▁ take ▁ place ▁ on ▁ mapped ▁ subclasses , ▁ in ▁ the ▁ way ▁ that STRNEWLINE ▁ we ▁ normally ▁ do ▁ as ▁ in ▁ : ref : ` declarative _ mixins ` : : STRNEWLINE STRNEWLINE ▁ class ▁ Company ( Base ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' company ' STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( AbstractConcreteBase , ▁ Base ) : STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ company _ id ( cls ) : STRNEWLINE ▁ return ▁ Column ( ForeignKey ( ' company . id ' ) ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ company ( cls ) : STRNEWLINE ▁ return ▁ relationship ( " Company " ) STRNEWLINE STRNEWLINE ▁ class ▁ Manager ( Employee ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' manager ' STRNEWLINE STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ manager _ data ▁ = ▁ Column ( String ( 40 ) ) STRNEWLINE STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' manager ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ When ▁ we ▁ make ▁ use ▁ of ▁ our ▁ mappings ▁ however , ▁ both ▁ ` ` Manager ` ` ▁ and STRNEWLINE ▁ ` ` Employee ` ` ▁ will ▁ have ▁ an ▁ independently ▁ usable ▁ ` ` . company ` ` ▁ attribute : : STRNEWLINE STRNEWLINE ▁ session . query ( Employee ) . filter ( Employee . company . has ( id = 5 ) ) STRNEWLINE STRNEWLINE ▁ . . ▁ versionchanged : : ▁ 1.0.0 ▁ - ▁ The ▁ mechanics ▁ of ▁ : class : ` . AbstractConcreteBase ` STRNEWLINE ▁ have ▁ been ▁ reworked ▁ to ▁ support ▁ relationships ▁ established ▁ directly STRNEWLINE ▁ on ▁ the ▁ abstract ▁ base , ▁ without ▁ any ▁ special ▁ configurational ▁ steps . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : class : ` . ConcreteBase ` STRNEWLINE STRNEWLINE ▁ : ref : ` concrete _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` inheritance _ concrete _ helpers ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE __no_table__ = True NEW_LINE @ classmethod NEW_LINE def __declare_first__ ( cls ) : NEW_LINE INDENT cls . _sa_decl_prepare_nocascade ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def _sa_decl_prepare_nocascade ( cls ) : NEW_LINE INDENT if getattr ( cls , ' _ _ mapper _ _ ' , None ) : NEW_LINE INDENT return NEW_LINE DEDENT to_map = _DeferredMapperConfig . config_for_cls ( cls ) NEW_LINE # ▁ can ' t ▁ rely ▁ on ▁ ' self _ and _ descendants ' ▁ here ENDCOM # ▁ since ▁ technically ▁ an ▁ immediate ▁ subclass ENDCOM # ▁ might ▁ not ▁ be ▁ mapped , ▁ but ▁ a ▁ subclass ENDCOM # ▁ may ▁ be . ENDCOM mappers = [ ] NEW_LINE stack = list ( cls . __subclasses__ ( ) ) NEW_LINE while stack : NEW_LINE INDENT klass = stack . pop ( ) NEW_LINE stack . extend ( klass . __subclasses__ ( ) ) NEW_LINE mn = _mapper_or_none ( klass ) NEW_LINE if mn is not None : NEW_LINE INDENT mappers . append ( mn ) NEW_LINE DEDENT DEDENT pjoin = cls . _create_polymorphic_union ( mappers ) NEW_LINE # ▁ For ▁ columns ▁ that ▁ were ▁ declared ▁ on ▁ the ▁ class , ▁ these ENDCOM # ▁ are ▁ normally ▁ ignored ▁ with ▁ the ▁ " _ _ no _ table _ _ " ▁ mapping , ENDCOM # ▁ unless ▁ they ▁ have ▁ a ▁ different ▁ attribute ▁ key ▁ vs . ▁ col ▁ name ENDCOM # ▁ and ▁ are ▁ in ▁ the ▁ properties ▁ argument . ENDCOM # ▁ In ▁ that ▁ case , ▁ ensure ▁ we ▁ update ▁ the ▁ properties ▁ entry ENDCOM # ▁ to ▁ the ▁ correct ▁ column ▁ from ▁ the ▁ pjoin ▁ target ▁ table . ENDCOM declared_cols = set ( to_map . declared_columns ) NEW_LINE for k , v in list ( to_map . properties . items ( ) ) : NEW_LINE INDENT if v in declared_cols : NEW_LINE INDENT to_map . properties [ k ] = pjoin . c [ v . key ] NEW_LINE DEDENT DEDENT to_map . local_table = pjoin NEW_LINE m_args = to_map . mapper_args_fn or dict NEW_LINE def mapper_args ( ) : NEW_LINE INDENT args = m_args ( ) NEW_LINE args [ ' polymorphic _ on ' ] = pjoin . c . type NEW_LINE return args NEW_LINE DEDENT to_map . mapper_args_fn = mapper_args NEW_LINE m = to_map . map ( ) NEW_LINE for scls in cls . __subclasses__ ( ) : NEW_LINE INDENT sm = _mapper_or_none ( scls ) NEW_LINE if sm and sm . concrete and cls in scls . __bases__ : NEW_LINE INDENT sm . _set_concrete_base ( m ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class DeferredReflection ( object ) : NEW_LINE INDENT """ A ▁ helper ▁ class ▁ for ▁ construction ▁ of ▁ mappings ▁ based ▁ on STRNEWLINE ▁ a ▁ deferred ▁ reflection ▁ step . STRNEWLINE STRNEWLINE ▁ Normally , ▁ declarative ▁ can ▁ be ▁ used ▁ with ▁ reflection ▁ by STRNEWLINE ▁ setting ▁ a ▁ : class : ` . Table ` ▁ object ▁ using ▁ autoload = True STRNEWLINE ▁ as ▁ the ▁ ` ` _ _ table _ _ ` ` ▁ attribute ▁ on ▁ a ▁ declarative ▁ class . STRNEWLINE ▁ The ▁ caveat ▁ is ▁ that ▁ the ▁ : class : ` . Table ` ▁ must ▁ be ▁ fully STRNEWLINE ▁ reflected , ▁ or ▁ at ▁ the ▁ very ▁ least ▁ have ▁ a ▁ primary ▁ key ▁ column , STRNEWLINE ▁ at ▁ the ▁ point ▁ at ▁ which ▁ a ▁ normal ▁ declarative ▁ mapping ▁ is STRNEWLINE ▁ constructed , ▁ meaning ▁ the ▁ : class : ` . Engine ` ▁ must ▁ be ▁ available STRNEWLINE ▁ at ▁ class ▁ declaration ▁ time . STRNEWLINE STRNEWLINE ▁ The ▁ : class : ` . DeferredReflection ` ▁ mixin ▁ moves ▁ the ▁ construction STRNEWLINE ▁ of ▁ mappers ▁ to ▁ be ▁ at ▁ a ▁ later ▁ point , ▁ after ▁ a ▁ specific STRNEWLINE ▁ method ▁ is ▁ called ▁ which ▁ first ▁ reflects ▁ all ▁ : class : ` . Table ` STRNEWLINE ▁ objects ▁ created ▁ so ▁ far . ▁ Classes ▁ can ▁ define ▁ it ▁ as ▁ such : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ declarative _ base STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ DeferredReflection STRNEWLINE ▁ Base ▁ = ▁ declarative _ base ( ) STRNEWLINE STRNEWLINE ▁ class ▁ MyClass ( DeferredReflection , ▁ Base ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' mytable ' STRNEWLINE STRNEWLINE ▁ Above , ▁ ` ` MyClass ` ` ▁ is ▁ not ▁ yet ▁ mapped . ▁ After ▁ a ▁ series ▁ of STRNEWLINE ▁ classes ▁ have ▁ been ▁ defined ▁ in ▁ the ▁ above ▁ fashion , ▁ all ▁ tables STRNEWLINE ▁ can ▁ be ▁ reflected ▁ and ▁ mappings ▁ created ▁ using STRNEWLINE ▁ : meth : ` . prepare ` : : STRNEWLINE STRNEWLINE ▁ engine ▁ = ▁ create _ engine ( " someengine : / / . . . " ) STRNEWLINE ▁ DeferredReflection . prepare ( engine ) STRNEWLINE STRNEWLINE ▁ The ▁ : class : ` . DeferredReflection ` ▁ mixin ▁ can ▁ be ▁ applied ▁ to ▁ individual STRNEWLINE ▁ classes , ▁ used ▁ as ▁ the ▁ base ▁ for ▁ the ▁ declarative ▁ base ▁ itself , STRNEWLINE ▁ or ▁ used ▁ in ▁ a ▁ custom ▁ abstract ▁ class . ▁ Using ▁ an ▁ abstract ▁ base STRNEWLINE ▁ allows ▁ that ▁ only ▁ a ▁ subset ▁ of ▁ classes ▁ to ▁ be ▁ prepared ▁ for ▁ a STRNEWLINE ▁ particular ▁ prepare ▁ step , ▁ which ▁ is ▁ necessary ▁ for ▁ applications STRNEWLINE ▁ that ▁ use ▁ more ▁ than ▁ one ▁ engine . ▁ For ▁ example , ▁ if ▁ an ▁ application STRNEWLINE ▁ has ▁ two ▁ engines , ▁ you ▁ might ▁ use ▁ two ▁ bases , ▁ and ▁ prepare ▁ each STRNEWLINE ▁ separately , ▁ e . g . : : STRNEWLINE STRNEWLINE ▁ class ▁ ReflectedOne ( DeferredReflection , ▁ Base ) : STRNEWLINE ▁ _ _ abstract _ _ ▁ = ▁ True STRNEWLINE STRNEWLINE ▁ class ▁ ReflectedTwo ( DeferredReflection , ▁ Base ) : STRNEWLINE ▁ _ _ abstract _ _ ▁ = ▁ True STRNEWLINE STRNEWLINE ▁ class ▁ MyClass ( ReflectedOne ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' mytable ' STRNEWLINE STRNEWLINE ▁ class ▁ MyOtherClass ( ReflectedOne ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' myothertable ' STRNEWLINE STRNEWLINE ▁ class ▁ YetAnotherClass ( ReflectedTwo ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' yetanothertable ' STRNEWLINE STRNEWLINE ▁ # ▁ . . . ▁ etc . STRNEWLINE STRNEWLINE ▁ Above , ▁ the ▁ class ▁ hierarchies ▁ for ▁ ` ` ReflectedOne ` ` ▁ and STRNEWLINE ▁ ` ` ReflectedTwo ` ` ▁ can ▁ be ▁ configured ▁ separately : : STRNEWLINE STRNEWLINE ▁ ReflectedOne . prepare ( engine _ one ) STRNEWLINE ▁ ReflectedTwo . prepare ( engine _ two ) STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 0.8 STRNEWLINE STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def prepare ( cls , engine ) : NEW_LINE INDENT """ Reflect ▁ all ▁ : class : ` . Table ` ▁ objects ▁ for ▁ all ▁ current STRNEWLINE ▁ : class : ` . DeferredReflection ` ▁ subclasses """ NEW_LINE to_map = _DeferredMapperConfig . classes_for_base ( cls ) NEW_LINE for thingy in to_map : NEW_LINE INDENT cls . _sa_decl_prepare ( thingy . local_table , engine ) NEW_LINE thingy . map ( ) NEW_LINE mapper = thingy . cls . __mapper__ NEW_LINE metadata = mapper . class_ . metadata NEW_LINE for rel in mapper . _props . values ( ) : NEW_LINE INDENT if isinstance ( rel , properties . RelationshipProperty ) and rel . secondary is not None : NEW_LINE INDENT if isinstance ( rel . secondary , Table ) : NEW_LINE INDENT cls . _reflect_table ( rel . secondary , engine ) NEW_LINE DEDENT elif isinstance ( rel . secondary , _class_resolver ) : NEW_LINE INDENT rel . secondary . _resolvers += ( cls . _sa_deferred_table_resolver ( engine , metadata ) , ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT @ classmethod NEW_LINE def _sa_deferred_table_resolver ( cls , engine , metadata ) : NEW_LINE INDENT def _resolve ( key ) : NEW_LINE INDENT t1 = Table ( key , metadata ) NEW_LINE cls . _reflect_table ( t1 , engine ) NEW_LINE return t1 NEW_LINE DEDENT return _resolve NEW_LINE DEDENT @ classmethod NEW_LINE def _sa_decl_prepare ( cls , local_table , engine ) : NEW_LINE # ▁ autoload ▁ Table , ▁ which ▁ is ▁ already ENDCOM # ▁ present ▁ in ▁ the ▁ metadata . ▁ This ENDCOM # ▁ will ▁ fill ▁ in ▁ db - loaded ▁ columns ENDCOM # ▁ into ▁ the ▁ existing ▁ Table ▁ object . ENDCOM INDENT if local_table is not None : NEW_LINE INDENT cls . _reflect_table ( local_table , engine ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def _reflect_table ( cls , table , engine ) : NEW_LINE INDENT Table ( table . name , table . metadata , extend_existing = True , autoload_replace = False , autoload = True , autoload_with = engine , schema = table . schema ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="dvliman/jaikuengine/tree/master/.google_appengine/lib/django-1.5/django/contrib/comments/views/moderation.py"> from __future__ import absolute_import NEW_LINE from django import template NEW_LINE from django . conf import settings NEW_LINE from django . contrib import comments NEW_LINE from django . contrib . auth . decorators import login_required , permission_required NEW_LINE from django . contrib . comments import signals NEW_LINE from django . contrib . comments . views . utils import next_redirect , confirmation_view NEW_LINE from django . shortcuts import get_object_or_404 , render_to_response NEW_LINE from django . views . decorators . csrf import csrf_protect NEW_LINE @ csrf_protect NEW_LINE @ login_required NEW_LINE def flag ( request , comment_id , next = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Flags ▁ a ▁ comment . ▁ Confirmation ▁ on ▁ GET , ▁ action ▁ on ▁ POST . STRNEWLINE STRNEWLINE ▁ Templates : ▁ : template : ` comments / flag . html ` , STRNEWLINE ▁ Context : STRNEWLINE ▁ comment STRNEWLINE ▁ the ▁ flagged ▁ ` comments . comment ` ▁ object STRNEWLINE ▁ """ NEW_LINE comment = get_object_or_404 ( comments . get_model ( ) , pk = comment_id , site__pk = settings . SITE_ID ) NEW_LINE # ▁ Flag ▁ on ▁ POST ENDCOM if request . method == ' POST ' : NEW_LINE INDENT perform_flag ( request , comment ) NEW_LINE return next_redirect ( request , fallback = next or ' comments - flag - done ' , c = comment . pk ) NEW_LINE # ▁ Render ▁ a ▁ form ▁ on ▁ GET ENDCOM DEDENT else : NEW_LINE INDENT return render_to_response ( ' comments / flag . html ' , { ' comment ' : comment , " next " : next } , template . RequestContext ( request ) ) NEW_LINE DEDENT DEDENT @ csrf_protect NEW_LINE @ permission_required ( " comments . can _ moderate " ) NEW_LINE def delete ( request , comment_id , next = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Deletes ▁ a ▁ comment . ▁ Confirmation ▁ on ▁ GET , ▁ action ▁ on ▁ POST . ▁ Requires ▁ the ▁ " can STRNEWLINE ▁ moderate ▁ comments " ▁ permission . STRNEWLINE STRNEWLINE ▁ Templates : ▁ : template : ` comments / delete . html ` , STRNEWLINE ▁ Context : STRNEWLINE ▁ comment STRNEWLINE ▁ the ▁ flagged ▁ ` comments . comment ` ▁ object STRNEWLINE ▁ """ NEW_LINE comment = get_object_or_404 ( comments . get_model ( ) , pk = comment_id , site__pk = settings . SITE_ID ) NEW_LINE # ▁ Delete ▁ on ▁ POST ENDCOM if request . method == ' POST ' : NEW_LINE # ▁ Flag ▁ the ▁ comment ▁ as ▁ deleted ▁ instead ▁ of ▁ actually ▁ deleting ▁ it . ENDCOM INDENT perform_delete ( request , comment ) NEW_LINE return next_redirect ( request , fallback = next or ' comments - delete - done ' , c = comment . pk ) NEW_LINE # ▁ Render ▁ a ▁ form ▁ on ▁ GET ENDCOM DEDENT else : NEW_LINE INDENT return render_to_response ( ' comments / delete . html ' , { ' comment ' : comment , " next " : next } , template . RequestContext ( request ) ) NEW_LINE DEDENT DEDENT @ csrf_protect NEW_LINE @ permission_required ( " comments . can _ moderate " ) NEW_LINE def approve ( request , comment_id , next = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Approve ▁ a ▁ comment ▁ ( that ▁ is , ▁ mark ▁ it ▁ as ▁ public ▁ and ▁ non - removed ) . ▁ Confirmation STRNEWLINE ▁ on ▁ GET , ▁ action ▁ on ▁ POST . ▁ Requires ▁ the ▁ " can ▁ moderate ▁ comments " ▁ permission . STRNEWLINE STRNEWLINE ▁ Templates : ▁ : template : ` comments / approve . html ` , STRNEWLINE ▁ Context : STRNEWLINE ▁ comment STRNEWLINE ▁ the ▁ ` comments . comment ` ▁ object ▁ for ▁ approval STRNEWLINE ▁ """ NEW_LINE comment = get_object_or_404 ( comments . get_model ( ) , pk = comment_id , site__pk = settings . SITE_ID ) NEW_LINE # ▁ Delete ▁ on ▁ POST ENDCOM if request . method == ' POST ' : NEW_LINE # ▁ Flag ▁ the ▁ comment ▁ as ▁ approved . ENDCOM INDENT perform_approve ( request , comment ) NEW_LINE return next_redirect ( request , fallback = next or ' comments - approve - done ' , c = comment . pk ) NEW_LINE # ▁ Render ▁ a ▁ form ▁ on ▁ GET ENDCOM DEDENT else : NEW_LINE INDENT return render_to_response ( ' comments / approve . html ' , { ' comment ' : comment , " next " : next } , template . RequestContext ( request ) ) NEW_LINE # ▁ The ▁ following ▁ functions ▁ actually ▁ perform ▁ the ▁ various ▁ flag / aprove / delete ENDCOM # ▁ actions . ▁ They ' ve ▁ been ▁ broken ▁ out ▁ into ▁ separate ▁ functions ▁ to ▁ that ▁ they ENDCOM # ▁ may ▁ be ▁ called ▁ from ▁ admin ▁ actions . ENDCOM DEDENT DEDENT def perform_flag ( request , comment ) : NEW_LINE INDENT """ STRNEWLINE ▁ Actually ▁ perform ▁ the ▁ flagging ▁ of ▁ a ▁ comment ▁ from ▁ a ▁ request . STRNEWLINE ▁ """ NEW_LINE flag , created = comments . models . CommentFlag . objects . get_or_create ( comment = comment , user = request . user , flag = comments . models . CommentFlag . SUGGEST_REMOVAL ) NEW_LINE signals . comment_was_flagged . send ( sender = comment . __class__ , comment = comment , flag = flag , created = created , request = request , ) NEW_LINE DEDENT def perform_delete ( request , comment ) : NEW_LINE INDENT flag , created = comments . models . CommentFlag . objects . get_or_create ( comment = comment , user = request . user , flag = comments . models . CommentFlag . MODERATOR_DELETION ) NEW_LINE comment . is_removed = True NEW_LINE comment . save ( ) NEW_LINE signals . comment_was_flagged . send ( sender = comment . __class__ , comment = comment , flag = flag , created = created , request = request , ) NEW_LINE DEDENT def perform_approve ( request , comment ) : NEW_LINE INDENT flag , created = comments . models . CommentFlag . objects . get_or_create ( comment = comment , user = request . user , flag = comments . models . CommentFlag . MODERATOR_APPROVAL , ) NEW_LINE comment . is_removed = False NEW_LINE comment . is_public = True NEW_LINE comment . save ( ) NEW_LINE signals . comment_was_flagged . send ( sender = comment . __class__ , comment = comment , flag = flag , created = created , request = request , ) NEW_LINE # ▁ Confirmation ▁ views . ENDCOM DEDENT flag_done = confirmation_view ( template = " comments / flagged . html " , doc = ' Displays ▁ a ▁ " comment ▁ was ▁ flagged " ▁ success ▁ page . ' ) NEW_LINE delete_done = confirmation_view ( template = " comments / deleted . html " , doc = ' Displays ▁ a ▁ " comment ▁ was ▁ deleted " ▁ success ▁ page . ' ) NEW_LINE approve_done = confirmation_view ( template = " comments / approved . html " , doc = ' Displays ▁ a ▁ " comment ▁ was ▁ approved " ▁ success ▁ page . ' ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="travisdesell/csg_boinc/tree/master/test/cgiserver.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ $ Id $ ENDCOM # ▁ cgi / php ▁ web ▁ server ENDCOM import BaseHTTPServer , CGIHTTPServer NEW_LINE import sys , os , urllib , select NEW_LINE import random , time # ▁ XXX ENDCOM NEW_LINE php_path = None NEW_LINE possible_php_paths = [ ' / usr / lib / cgi - bin / php4' , ' PROGRAM _ PATH / fake _ php . py ' ] NEW_LINE def setup_php ( program_path ) : NEW_LINE INDENT global php_path NEW_LINE for p in possible_php_paths : NEW_LINE INDENT p = p . replace ( ' PROGRAM _ PATH ' , program_path ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT php_path = p NEW_LINE return NEW_LINE DEDENT DEDENT raise Exception ( " No ▁ php ▁ binary ▁ found ▁ - ▁ not ▁ even ▁ fake _ php . py ▁ ( program _ path = % s ) ▁ ! " % program_path ) NEW_LINE DEDENT class PHPHTTPRequestHandler ( CGIHTTPServer . CGIHTTPRequestHandler ) : NEW_LINE INDENT def is_cgi ( self ) : NEW_LINE INDENT if os . path . split ( self . path ) [ 1 ] == ' ' : NEW_LINE INDENT index_php = os . path . join ( self . path , ' index . php ' ) NEW_LINE if os . path . exists ( self . translate_path ( index_php ) ) : NEW_LINE INDENT self . path = index_php NEW_LINE DEDENT DEDENT if self . path . find ( ' . php ' ) != - 1 : NEW_LINE INDENT self . cgi_info = os . path . split ( self . path ) NEW_LINE return True NEW_LINE DEDENT for p in self . cgi_directories : NEW_LINE INDENT p = os . path . join ( p , ' ' ) NEW_LINE if self . path . startswith ( p ) : NEW_LINE INDENT self . cgi_info = os . path . split ( self . path ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def run_cgi ( self ) : NEW_LINE INDENT """ Execute ▁ a ▁ CGI ▁ script . """ NEW_LINE dir , rest = self . cgi_info NEW_LINE i = rest . rfind ( ' ? ' ) NEW_LINE if i >= 0 : NEW_LINE INDENT rest , query = rest [ : i ] , rest [ i + 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT query = ' ' NEW_LINE DEDENT i = rest . find ( ' / ' ) NEW_LINE if i >= 0 : NEW_LINE INDENT script , rest = rest [ : i ] , rest [ i : ] NEW_LINE DEDENT else : NEW_LINE INDENT script , rest = rest , ' ' NEW_LINE DEDENT scriptname = dir + ' / ' + script NEW_LINE is_php = script . endswith ( ' . php ' ) NEW_LINE # ▁ print ▁ " # # # # ▁ cgi _ info = % s , dir = % s , rest = % s , script = % s , scriptname = % s , is _ php = % s " % ( self . cgi _ info , dir , rest , script , scriptname , is _ php ) ENDCOM if is_php : NEW_LINE INDENT if not php_path : raise Exception ( ' php _ path ▁ not ▁ set ' ) NEW_LINE scriptfile = php_path NEW_LINE sourcefile = self . translate_path ( scriptname ) NEW_LINE DEDENT else : NEW_LINE INDENT scriptfile = self . translate_path ( scriptname ) NEW_LINE DEDENT if not os . path . exists ( scriptfile ) : NEW_LINE INDENT self . send_error ( 404 , " No ▁ such ▁ CGI ▁ script ▁ ( % s ) " %   ` scriptname ` ) NEW_LINE return NEW_LINE DEDENT if not os . path . isfile ( scriptfile ) : NEW_LINE INDENT self . send_error ( 403 , " CGI ▁ script ▁ is ▁ not ▁ a ▁ plain ▁ file ▁ ( % s ) " %                                                         ` scriptname ` ) NEW_LINE return NEW_LINE DEDENT ispy = self . is_python ( scriptname ) NEW_LINE if not ispy : NEW_LINE INDENT if not ( self . have_fork or self . have_popen2 or self . have_popen3 ) : NEW_LINE INDENT self . send_error ( 403 , " CGI ▁ script ▁ is ▁ not ▁ a ▁ Python ▁ script ▁ ( % s ) " %                                                                 ` scriptname ` ) NEW_LINE return NEW_LINE DEDENT if not self . is_executable ( scriptfile ) : NEW_LINE INDENT self . send_error ( 403 , " CGI ▁ script ▁ is ▁ not ▁ executable ▁ ( % s ) " %                                                                 ` scriptname ` ) NEW_LINE return NEW_LINE # ▁ Reference : ▁ http : / / hoohoo . ncsa . uiuc . edu / cgi / env . html ENDCOM # ▁ XXX ▁ Much ▁ of ▁ the ▁ following ▁ could ▁ be ▁ prepared ▁ ahead ▁ of ▁ time ! ENDCOM DEDENT DEDENT env = { } NEW_LINE env [ ' DOCUMENT _ ROOT ' ] = os . getcwd ( ) NEW_LINE env [ ' SERVER _ SOFTWARE ' ] = self . version_string ( ) NEW_LINE env [ ' SERVER _ NAME ' ] = self . server . server_name NEW_LINE env [ ' GATEWAY _ INTERFACE ' ] = ' CGI / 1.1' NEW_LINE env [ ' SERVER _ PROTOCOL ' ] = self . protocol_version NEW_LINE env [ ' SERVER _ PORT ' ] = str ( self . server . server_port ) NEW_LINE env [ ' REQUEST _ METHOD ' ] = self . command NEW_LINE uqrest = urllib . unquote ( self . cgi_info [ 1 ] ) NEW_LINE env [ ' REQUEST _ URI ' ] = self . path NEW_LINE # ▁ env [ ' PATH _ INFO ' ] ▁ = ▁ uqrest ENDCOM # ▁ env [ ' PATH _ TRANSLATED ' ] ▁ = ▁ self . translate _ path ( uqrest ) ENDCOM env [ ' SCRIPT _ NAME ' ] = scriptname NEW_LINE env [ ' SCRIPT _ FILENAME ' ] = self . translate_path ( scriptname ) NEW_LINE if query : NEW_LINE INDENT env [ ' QUERY _ STRING ' ] = query NEW_LINE DEDENT host = self . address_string ( ) NEW_LINE if host != self . client_address [ 0 ] : NEW_LINE INDENT env [ ' REMOTE _ HOST ' ] = host NEW_LINE DEDENT env [ ' REMOTE _ ADDR ' ] = self . client_address [ 0 ] NEW_LINE env [ ' REDIRECT _ STATUS ' ] = '1' # ▁ for ▁ php ENDCOM NEW_LINE # ▁ XXX ▁ AUTH _ TYPE ENDCOM # ▁ XXX ▁ REMOTE _ USER ENDCOM # ▁ XXX ▁ REMOTE _ IDENT ENDCOM if self . headers . typeheader is None : NEW_LINE INDENT env [ ' CONTENT _ TYPE ' ] = self . headers . type NEW_LINE DEDENT else : NEW_LINE INDENT env [ ' CONTENT _ TYPE ' ] = self . headers . typeheader NEW_LINE DEDENT length = self . headers . getheader ( ' content - length ' ) NEW_LINE if length : NEW_LINE INDENT env [ ' CONTENT _ LENGTH ' ] = length NEW_LINE DEDENT accept = [ ] NEW_LINE for line in self . headers . getallmatchingheaders ( ' accept ' ) : NEW_LINE INDENT if line [ : 1 ] in " \t \n ▁ " : NEW_LINE INDENT accept . append ( line . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT accept = accept + line [ 7 : ] . split ( ' , ' ) NEW_LINE DEDENT DEDENT env [ ' HTTP _ ACCEPT ' ] = ' , ' . join ( accept ) NEW_LINE ua = self . headers . getheader ( ' user - agent ' ) NEW_LINE if ua : NEW_LINE INDENT env [ ' HTTP _ USER _ AGENT ' ] = ua NEW_LINE DEDENT co = filter ( None , self . headers . getheaders ( ' cookie ' ) ) NEW_LINE if co : NEW_LINE INDENT env [ ' HTTP _ COOKIE ' ] = ' , ▁ ' . join ( co ) NEW_LINE # ▁ XXX ▁ Other ▁ HTTP _ * ▁ headers ENDCOM DEDENT if not self . have_fork : NEW_LINE # ▁ Since ▁ we ' re ▁ setting ▁ the ▁ env ▁ in ▁ the ▁ parent , ▁ provide ▁ empty ENDCOM # ▁ values ▁ to ▁ override ▁ previously ▁ set ▁ values ENDCOM INDENT for k in ( ' QUERY _ STRING ' , ' REMOTE _ HOST ' , ' CONTENT _ LENGTH ' , ' HTTP _ USER _ AGENT ' , ' HTTP _ COOKIE ' ) : NEW_LINE INDENT env . setdefault ( k , " " ) NEW_LINE DEDENT DEDENT os . environ . update ( env ) NEW_LINE self . send_response ( 200 , " Script ▁ output ▁ follows " ) NEW_LINE decoded_query = query . replace ( ' + ' , ' ▁ ' ) NEW_LINE if self . have_fork : NEW_LINE # ▁ Unix ▁ - - ▁ fork ▁ as ▁ we ▁ should ENDCOM INDENT if is_php : NEW_LINE INDENT args = [ php_path , sourcefile ] NEW_LINE DEDENT else : NEW_LINE INDENT args = [ script ] NEW_LINE DEDENT if ' = ' not in decoded_query : NEW_LINE INDENT args . append ( decoded_query ) NEW_LINE DEDENT self . wfile . flush ( ) # ▁ Always ▁ flush ▁ before ▁ forking ENDCOM NEW_LINE pid = os . fork ( ) NEW_LINE if pid != 0 : NEW_LINE # ▁ Parent ENDCOM INDENT pid , sts = os . waitpid ( pid , 0 ) NEW_LINE # ▁ throw ▁ away ▁ additional ▁ data ▁ [ see ▁ bug ▁ # 427345 ] ENDCOM while select . select ( [ self . rfile ] , [ ] , [ ] , 0 ) [ 0 ] : NEW_LINE INDENT try : NEW_LINE INDENT if not self . rfile . read ( 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if sts : NEW_LINE INDENT self . log_error ( " CGI ▁ script ▁ exit ▁ status ▁ % # x " , sts ) NEW_LINE DEDENT return NEW_LINE # ▁ Child ENDCOM DEDENT try : NEW_LINE INDENT if 0 : NEW_LINE INDENT time . sleep ( .1 ) NEW_LINE fn = ' / tmp / a % d ' % random . randint ( 1000 , 10000 ) NEW_LINE f = open ( fn , ' w ' ) NEW_LINE s = ' ' NEW_LINE while select . select ( [ self . rfile ] , [ ] , [ ] , 0 ) [ 0 ] : NEW_LINE INDENT try : NEW_LINE INDENT c = self . rfile . read ( 1 ) NEW_LINE if not c : NEW_LINE INDENT break NEW_LINE DEDENT s += c NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ' # # # ▁ input : ' , repr ( s ) NEW_LINE print >> f , s NEW_LINE f . close ( ) NEW_LINE self . rfile = open ( fn , ' r ' ) NEW_LINE DEDENT os . dup2 ( self . rfile . fileno ( ) , 0 ) NEW_LINE os . dup2 ( self . wfile . fileno ( ) , 1 ) NEW_LINE os . chdir ( self . translate_path ( dir ) ) # ▁ KC ENDCOM NEW_LINE os . execve ( scriptfile , args , os . environ ) NEW_LINE DEDENT except : NEW_LINE INDENT self . server . handle_error ( self . request , self . client_address ) NEW_LINE os . _exit ( 127 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT raise SystemExit ( ' need ▁ fork ( ) ' ) NEW_LINE DEDENT DEDENT DEDENT def serve ( bind = ' localhost ' , port = 8000 , handler = PHPHTTPRequestHandler ) : NEW_LINE INDENT httpd = BaseHTTPServer . HTTPServer ( ( bind , port ) , handler ) NEW_LINE httpd . serve_forever ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT setup_php ( os . path . realpath ( os . path . dirname ( sys . argv [ 0 ] ) ) ) NEW_LINE serve ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="ftomassetti/intellij-community/tree/master/python/lib/Lib/site-packages/django/contrib/gis/geos/tests/test_geos.py"> import ctypes , random , unittest , sys NEW_LINE from django . contrib . gis . geos import * NEW_LINE from django . contrib . gis . geos . base import gdal , numpy , GEOSBase NEW_LINE from django . contrib . gis . geos . libgeos import GEOS_PREPARE NEW_LINE from django . contrib . gis . geometry . test_data import TestDataMixin NEW_LINE class GEOSTest ( unittest . TestCase , TestDataMixin ) : NEW_LINE INDENT @ property NEW_LINE def null_srid ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ the ▁ proper ▁ null ▁ SRID ▁ depending ▁ on ▁ the ▁ GEOS ▁ version . STRNEWLINE ▁ See ▁ the ▁ comments ▁ in ▁ ` test15 _ srid ` ▁ for ▁ more ▁ details . STRNEWLINE ▁ """ NEW_LINE info = geos_version_info ( ) NEW_LINE if info [ ' version ' ] == '3.0.0' and info [ ' release _ candidate ' ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT def test00_base ( self ) : NEW_LINE INDENT " Tests ▁ out ▁ the ▁ GEOSBase ▁ class . " NEW_LINE # ▁ Testing ▁ out ▁ GEOSBase ▁ class , ▁ which ▁ provides ▁ a ▁ ` ptr ` ▁ property ENDCOM # ▁ that ▁ abstracts ▁ out ▁ access ▁ to ▁ underlying ▁ C ▁ pointers . ENDCOM class FakeGeom1 ( GEOSBase ) : NEW_LINE INDENT pass NEW_LINE # ▁ This ▁ one ▁ only ▁ accepts ▁ pointers ▁ to ▁ floats ENDCOM DEDENT c_float_p = ctypes . POINTER ( ctypes . c_float ) NEW_LINE class FakeGeom2 ( GEOSBase ) : NEW_LINE INDENT ptr_type = c_float_p NEW_LINE # ▁ Default ▁ ptr _ type ▁ is ▁ ` c _ void _ p ` . ENDCOM DEDENT fg1 = FakeGeom1 ( ) NEW_LINE # ▁ Default ▁ ptr _ type ▁ is ▁ C ▁ float ▁ pointer ENDCOM fg2 = FakeGeom2 ( ) NEW_LINE # ▁ These ▁ assignments ▁ are ▁ OK ▁ - - ▁ None ▁ is ▁ allowed ▁ because ENDCOM # ▁ it ' s ▁ equivalent ▁ to ▁ the ▁ NULL ▁ pointer . ENDCOM fg1 . ptr = ctypes . c_void_p ( ) NEW_LINE fg1 . ptr = None NEW_LINE fg2 . ptr = c_float_p ( ctypes . c_float ( 5.23 ) ) NEW_LINE fg2 . ptr = None NEW_LINE # ▁ Because ▁ pointers ▁ have ▁ been ▁ set ▁ to ▁ NULL , ▁ an ▁ exception ▁ should ▁ be ENDCOM # ▁ raised ▁ when ▁ we ▁ try ▁ to ▁ access ▁ it . ▁ Raising ▁ an ▁ exception ▁ is ENDCOM # ▁ preferrable ▁ to ▁ a ▁ segmentation ▁ fault ▁ that ▁ commonly ▁ occurs ▁ when ENDCOM # ▁ a ▁ C ▁ method ▁ is ▁ given ▁ a ▁ NULL ▁ memory ▁ reference . ENDCOM for fg in ( fg1 , fg2 ) : NEW_LINE # ▁ Equivalent ▁ to ▁ ` fg . ptr ` ENDCOM INDENT self . assertRaises ( GEOSException , fg . _get_ptr ) NEW_LINE # ▁ Anything ▁ that ▁ is ▁ either ▁ not ▁ None ▁ or ▁ the ▁ acceptable ▁ pointer ▁ type ▁ will ENDCOM # ▁ result ▁ in ▁ a ▁ TypeError ▁ when ▁ trying ▁ to ▁ assign ▁ it ▁ to ▁ the ▁ ` ptr ` ▁ property . ENDCOM # ▁ Thus , ▁ memmory ▁ addresses ▁ ( integers ) ▁ and ▁ pointers ▁ of ▁ the ▁ incorrect ▁ type ENDCOM # ▁ ( in ▁ ` bad _ ptrs ` ) ▁ will ▁ not ▁ be ▁ allowed . ENDCOM DEDENT bad_ptrs = ( 5 , ctypes . c_char_p ( ' foobar ' ) ) NEW_LINE for bad_ptr in bad_ptrs : NEW_LINE # ▁ Equivalent ▁ to ▁ ` fg . ptr ▁ = ▁ bad _ ptr ` ENDCOM INDENT self . assertRaises ( TypeError , fg1 . _set_ptr , bad_ptr ) NEW_LINE self . assertRaises ( TypeError , fg2 . _set_ptr , bad_ptr ) NEW_LINE DEDENT DEDENT def test01a_wkt ( self ) : NEW_LINE INDENT " Testing ▁ WKT ▁ output . " NEW_LINE for g in self . geometries . wkt_out : NEW_LINE INDENT geom = fromstr ( g . wkt ) NEW_LINE self . assertEqual ( g . ewkt , geom . wkt ) NEW_LINE DEDENT DEDENT def test01b_hex ( self ) : NEW_LINE INDENT " Testing ▁ HEX ▁ output . " NEW_LINE for g in self . geometries . hex_wkt : NEW_LINE INDENT geom = fromstr ( g . wkt ) NEW_LINE self . assertEqual ( g . hex , geom . hex ) NEW_LINE DEDENT DEDENT def test01b_hexewkb ( self ) : NEW_LINE INDENT " Testing ▁ ( HEX ) EWKB ▁ output . " NEW_LINE from binascii import a2b_hex NEW_LINE # ▁ For ▁ testing ▁ HEX ( EWKB ) . ENDCOM ogc_hex = '01010000000000000000000000000000000000F03F ' NEW_LINE # ▁ ` SELECT ▁ ST _ AsHEXEWKB ( ST _ GeomFromText ( ' POINT ( 0 ▁ 1 ) ' , ▁ 4326 ) ) ; ` ENDCOM hexewkb_2d = '0101000020E61000000000000000000000000000000000F03F ' NEW_LINE # ▁ ` SELECT ▁ ST _ AsHEXEWKB ( ST _ GeomFromEWKT ( ' SRID = 4326 ; POINT ( 0 ▁ 1 ▁ 2 ) ' ) ) ; ` ENDCOM hexewkb_3d = '01010000A0E61000000000000000000000000000000000F03F0000000000000040' NEW_LINE pnt_2d = Point ( 0 , 1 , srid = 4326 ) NEW_LINE pnt_3d = Point ( 0 , 1 , 2 , srid = 4326 ) NEW_LINE # ▁ OGC - compliant ▁ HEX ▁ will ▁ not ▁ have ▁ SRID ▁ nor ▁ Z ▁ value . ENDCOM self . assertEqual ( ogc_hex , pnt_2d . hex ) NEW_LINE self . assertEqual ( ogc_hex , pnt_3d . hex ) NEW_LINE # ▁ HEXEWKB ▁ should ▁ be ▁ appropriate ▁ for ▁ its ▁ dimension ▁ - - ▁ have ▁ to ▁ use ▁ an ENDCOM # ▁ a ▁ WKBWriter ▁ w / dimension ▁ set ▁ accordingly , ▁ else ▁ GEOS ▁ will ▁ insert ENDCOM # ▁ garbage ▁ into ▁ 3D ▁ coordinate ▁ if ▁ there ▁ is ▁ none . ▁ Also , ▁ GEOS ▁ has ▁ a ENDCOM # ▁ a ▁ bug ▁ in ▁ versions ▁ prior ▁ to ▁ 3.1 ▁ that ▁ puts ▁ the ▁ X ▁ coordinate ▁ in ENDCOM # ▁ place ▁ of ▁ Z ; ▁ an ▁ exception ▁ should ▁ be ▁ raised ▁ on ▁ those ▁ versions . ENDCOM self . assertEqual ( hexewkb_2d , pnt_2d . hexewkb ) NEW_LINE if GEOS_PREPARE : NEW_LINE INDENT self . assertEqual ( hexewkb_3d , pnt_3d . hexewkb ) NEW_LINE self . assertEqual ( True , GEOSGeometry ( hexewkb_3d ) . hasz ) NEW_LINE DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT hexewkb = pnt_3d . hexewkb NEW_LINE DEDENT except GEOSException : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Should ▁ have ▁ raised ▁ GEOSException . ' ) NEW_LINE # ▁ Same ▁ for ▁ EWKB . ENDCOM DEDENT DEDENT self . assertEqual ( buffer ( a2b_hex ( hexewkb_2d ) ) , pnt_2d . ewkb ) NEW_LINE if GEOS_PREPARE : NEW_LINE INDENT self . assertEqual ( buffer ( a2b_hex ( hexewkb_3d ) ) , pnt_3d . ewkb ) NEW_LINE DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT ewkb = pnt_3d . ewkb NEW_LINE DEDENT except GEOSException : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Should ▁ have ▁ raised ▁ GEOSException ' ) NEW_LINE # ▁ Redundant ▁ sanity ▁ check . ENDCOM DEDENT DEDENT self . assertEqual ( 4326 , GEOSGeometry ( hexewkb_2d ) . srid ) NEW_LINE DEDENT def test01c_kml ( self ) : NEW_LINE INDENT " Testing ▁ KML ▁ output . " NEW_LINE for tg in self . geometries . wkt_out : NEW_LINE INDENT geom = fromstr ( tg . wkt ) NEW_LINE kml = getattr ( tg , ' kml ' , False ) NEW_LINE if kml : self . assertEqual ( kml , geom . kml ) NEW_LINE DEDENT DEDENT def test01d_errors ( self ) : NEW_LINE INDENT " Testing ▁ the ▁ Error ▁ handlers . " NEW_LINE # ▁ string - based ENDCOM print " \n BEGIN ▁ - ▁ expecting ▁ GEOS _ ERROR ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE for err in self . geometries . errors : NEW_LINE INDENT try : NEW_LINE INDENT g = fromstr ( err . wkt ) NEW_LINE DEDENT except ( GEOSException , ValueError ) : NEW_LINE INDENT pass NEW_LINE # ▁ Bad ▁ WKB ENDCOM DEDENT DEDENT self . assertRaises ( GEOSException , GEOSGeometry , buffer ( '0' ) ) NEW_LINE print " \n END ▁ - ▁ expecting ▁ GEOS _ ERROR ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE class NotAGeometry ( object ) : NEW_LINE INDENT pass NEW_LINE # ▁ Some ▁ other ▁ object ENDCOM DEDENT self . assertRaises ( TypeError , GEOSGeometry , NotAGeometry ( ) ) NEW_LINE # ▁ None ENDCOM self . assertRaises ( TypeError , GEOSGeometry , None ) NEW_LINE DEDENT def test01e_wkb ( self ) : NEW_LINE INDENT " Testing ▁ WKB ▁ output . " NEW_LINE from binascii import b2a_hex NEW_LINE for g in self . geometries . hex_wkt : NEW_LINE INDENT geom = fromstr ( g . wkt ) NEW_LINE wkb = geom . wkb NEW_LINE self . assertEqual ( b2a_hex ( wkb ) . upper ( ) , g . hex ) NEW_LINE DEDENT DEDENT def test01f_create_hex ( self ) : NEW_LINE INDENT " Testing ▁ creation ▁ from ▁ HEX . " NEW_LINE for g in self . geometries . hex_wkt : NEW_LINE INDENT geom_h = GEOSGeometry ( g . hex ) NEW_LINE # ▁ we ▁ need ▁ to ▁ do ▁ this ▁ so ▁ decimal ▁ places ▁ get ▁ normalised ENDCOM geom_t = fromstr ( g . wkt ) NEW_LINE self . assertEqual ( geom_t . wkt , geom_h . wkt ) NEW_LINE DEDENT DEDENT def test01g_create_wkb ( self ) : NEW_LINE INDENT " Testing ▁ creation ▁ from ▁ WKB . " NEW_LINE from binascii import a2b_hex NEW_LINE for g in self . geometries . hex_wkt : NEW_LINE INDENT wkb = buffer ( a2b_hex ( g . hex ) ) NEW_LINE geom_h = GEOSGeometry ( wkb ) NEW_LINE # ▁ we ▁ need ▁ to ▁ do ▁ this ▁ so ▁ decimal ▁ places ▁ get ▁ normalised ENDCOM geom_t = fromstr ( g . wkt ) NEW_LINE self . assertEqual ( geom_t . wkt , geom_h . wkt ) NEW_LINE DEDENT DEDENT def test01h_ewkt ( self ) : NEW_LINE INDENT " Testing ▁ EWKT . " NEW_LINE srid = 32140 NEW_LINE for p in self . geometries . polygons : NEW_LINE INDENT ewkt = ' SRID = % d ; % s ' % ( srid , p . wkt ) NEW_LINE poly = fromstr ( ewkt ) NEW_LINE self . assertEqual ( srid , poly . srid ) NEW_LINE self . assertEqual ( srid , poly . shell . srid ) NEW_LINE self . assertEqual ( srid , fromstr ( poly . ewkt ) . srid ) # ▁ Checking ▁ export ENDCOM NEW_LINE DEDENT DEDENT def test01i_json ( self ) : NEW_LINE INDENT " Testing ▁ GeoJSON ▁ input / output ▁ ( via ▁ GDAL ) . " NEW_LINE if not gdal or not gdal . GEOJSON : return NEW_LINE for g in self . geometries . json_geoms : NEW_LINE INDENT geom = GEOSGeometry ( g . wkt ) NEW_LINE if not hasattr ( g , ' not _ equal ' ) : NEW_LINE INDENT self . assertEqual ( g . json , geom . json ) NEW_LINE self . assertEqual ( g . json , geom . geojson ) NEW_LINE DEDENT self . assertEqual ( GEOSGeometry ( g . wkt ) , GEOSGeometry ( geom . json ) ) NEW_LINE DEDENT DEDENT def test01k_fromfile ( self ) : NEW_LINE INDENT " Testing ▁ the ▁ fromfile ( ) ▁ factory . " NEW_LINE from StringIO import StringIO NEW_LINE ref_pnt = GEOSGeometry ( ' POINT ( 5 ▁ 23 ) ' ) NEW_LINE wkt_f = StringIO ( ) NEW_LINE wkt_f . write ( ref_pnt . wkt ) NEW_LINE wkb_f = StringIO ( ) NEW_LINE wkb_f . write ( str ( ref_pnt . wkb ) ) NEW_LINE # ▁ Other ▁ tests ▁ use ▁ ` fromfile ( ) ` ▁ on ▁ string ▁ filenames ▁ so ▁ those ENDCOM # ▁ aren ' t ▁ tested ▁ here . ENDCOM for fh in ( wkt_f , wkb_f ) : NEW_LINE INDENT fh . seek ( 0 ) NEW_LINE pnt = fromfile ( fh ) NEW_LINE self . assertEqual ( ref_pnt , pnt ) NEW_LINE DEDENT DEDENT def test01k_eq ( self ) : NEW_LINE INDENT " Testing ▁ equivalence . " NEW_LINE p = fromstr ( ' POINT ( 5 ▁ 23 ) ' ) NEW_LINE self . assertEqual ( p , p . wkt ) NEW_LINE self . assertNotEqual ( p , ' foo ' ) NEW_LINE ls = fromstr ( ' LINESTRING ( 0 ▁ 0 , ▁ 1 ▁ 1 , ▁ 5 ▁ 5 ) ' ) NEW_LINE self . assertEqual ( ls , ls . wkt ) NEW_LINE self . assertNotEqual ( p , ' bar ' ) NEW_LINE # ▁ Error ▁ shouldn ' t ▁ be ▁ raise ▁ on ▁ equivalence ▁ testing ▁ with ENDCOM # ▁ an ▁ invalid ▁ type . ENDCOM for g in ( p , ls ) : NEW_LINE INDENT self . assertNotEqual ( g , None ) NEW_LINE self . assertNotEqual ( g , { ' foo ' : ' bar ' } ) NEW_LINE self . assertNotEqual ( g , False ) NEW_LINE DEDENT DEDENT def test02a_points ( self ) : NEW_LINE INDENT " Testing ▁ Point ▁ objects . " NEW_LINE prev = fromstr ( ' POINT ( 0 ▁ 0 ) ' ) NEW_LINE for p in self . geometries . points : NEW_LINE # ▁ Creating ▁ the ▁ point ▁ from ▁ the ▁ WKT ENDCOM INDENT pnt = fromstr ( p . wkt ) NEW_LINE self . assertEqual ( pnt . geom_type , ' Point ' ) NEW_LINE self . assertEqual ( pnt . geom_typeid , 0 ) NEW_LINE self . assertEqual ( p . x , pnt . x ) NEW_LINE self . assertEqual ( p . y , pnt . y ) NEW_LINE self . assertEqual ( True , pnt == fromstr ( p . wkt ) ) NEW_LINE self . assertEqual ( False , pnt == prev ) NEW_LINE # ▁ Making ▁ sure ▁ that ▁ the ▁ point ' s ▁ X , ▁ Y ▁ components ▁ are ▁ what ▁ we ▁ expect ENDCOM self . assertAlmostEqual ( p . x , pnt . tuple [ 0 ] , 9 ) NEW_LINE self . assertAlmostEqual ( p . y , pnt . tuple [ 1 ] , 9 ) NEW_LINE # ▁ Testing ▁ the ▁ third ▁ dimension , ▁ and ▁ getting ▁ the ▁ tuple ▁ arguments ENDCOM if hasattr ( p , ' z ' ) : NEW_LINE INDENT self . assertEqual ( True , pnt . hasz ) NEW_LINE self . assertEqual ( p . z , pnt . z ) NEW_LINE self . assertEqual ( p . z , pnt . tuple [ 2 ] , 9 ) NEW_LINE tup_args = ( p . x , p . y , p . z ) NEW_LINE set_tup1 = ( 2.71 , 3.14 , 5.23 ) NEW_LINE set_tup2 = ( 5.23 , 2.71 , 3.14 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( False , pnt . hasz ) NEW_LINE self . assertEqual ( None , pnt . z ) NEW_LINE tup_args = ( p . x , p . y ) NEW_LINE set_tup1 = ( 2.71 , 3.14 ) NEW_LINE set_tup2 = ( 3.14 , 2.71 ) NEW_LINE # ▁ Centroid ▁ operation ▁ on ▁ point ▁ should ▁ be ▁ point ▁ itself ENDCOM DEDENT self . assertEqual ( p . centroid , pnt . centroid . tuple ) NEW_LINE # ▁ Now ▁ testing ▁ the ▁ different ▁ constructors ENDCOM pnt2 = Point ( tup_args ) # ▁ e . g . , ▁ Point ( (1 , ▁ 2 ) ) ENDCOM NEW_LINE pnt3 = Point ( * tup_args ) # ▁ e . g . , ▁ Point ( 1 , ▁ 2 ) ENDCOM NEW_LINE self . assertEqual ( True , pnt == pnt2 ) NEW_LINE self . assertEqual ( True , pnt == pnt3 ) NEW_LINE # ▁ Now ▁ testing ▁ setting ▁ the ▁ x ▁ and ▁ y ENDCOM pnt . y = 3.14 NEW_LINE pnt . x = 2.71 NEW_LINE self . assertEqual ( 3.14 , pnt . y ) NEW_LINE self . assertEqual ( 2.71 , pnt . x ) NEW_LINE # ▁ Setting ▁ via ▁ the ▁ tuple / coords ▁ property ENDCOM pnt . tuple = set_tup1 NEW_LINE self . assertEqual ( set_tup1 , pnt . tuple ) NEW_LINE pnt . coords = set_tup2 NEW_LINE self . assertEqual ( set_tup2 , pnt . coords ) NEW_LINE prev = pnt # ▁ setting ▁ the ▁ previous ▁ geometry ENDCOM NEW_LINE DEDENT DEDENT def test02b_multipoints ( self ) : NEW_LINE INDENT " Testing ▁ MultiPoint ▁ objects . " NEW_LINE for mp in self . geometries . multipoints : NEW_LINE INDENT mpnt = fromstr ( mp . wkt ) NEW_LINE self . assertEqual ( mpnt . geom_type , ' MultiPoint ' ) NEW_LINE self . assertEqual ( mpnt . geom_typeid , 4 ) NEW_LINE self . assertAlmostEqual ( mp . centroid [ 0 ] , mpnt . centroid . tuple [ 0 ] , 9 ) NEW_LINE self . assertAlmostEqual ( mp . centroid [ 1 ] , mpnt . centroid . tuple [ 1 ] , 9 ) NEW_LINE self . assertRaises ( GEOSIndexError , mpnt . __getitem__ , len ( mpnt ) ) NEW_LINE self . assertEqual ( mp . centroid , mpnt . centroid . tuple ) NEW_LINE self . assertEqual ( mp . coords , tuple ( m . tuple for m in mpnt ) ) NEW_LINE for p in mpnt : NEW_LINE INDENT self . assertEqual ( p . geom_type , ' Point ' ) NEW_LINE self . assertEqual ( p . geom_typeid , 0 ) NEW_LINE self . assertEqual ( p . empty , False ) NEW_LINE self . assertEqual ( p . valid , True ) NEW_LINE DEDENT DEDENT DEDENT def test03a_linestring ( self ) : NEW_LINE INDENT " Testing ▁ LineString ▁ objects . " NEW_LINE prev = fromstr ( ' POINT ( 0 ▁ 0 ) ' ) NEW_LINE for l in self . geometries . linestrings : NEW_LINE INDENT ls = fromstr ( l . wkt ) NEW_LINE self . assertEqual ( ls . geom_type , ' LineString ' ) NEW_LINE self . assertEqual ( ls . geom_typeid , 1 ) NEW_LINE self . assertEqual ( ls . empty , False ) NEW_LINE self . assertEqual ( ls . ring , False ) NEW_LINE if hasattr ( l , ' centroid ' ) : NEW_LINE INDENT self . assertEqual ( l . centroid , ls . centroid . tuple ) NEW_LINE DEDENT if hasattr ( l , ' tup ' ) : NEW_LINE INDENT self . assertEqual ( l . tup , ls . tuple ) NEW_LINE DEDENT self . assertEqual ( True , ls == fromstr ( l . wkt ) ) NEW_LINE self . assertEqual ( False , ls == prev ) NEW_LINE self . assertRaises ( GEOSIndexError , ls . __getitem__ , len ( ls ) ) NEW_LINE prev = ls NEW_LINE # ▁ Creating ▁ a ▁ LineString ▁ from ▁ a ▁ tuple , ▁ list , ▁ and ▁ numpy ▁ array ENDCOM self . assertEqual ( ls , LineString ( ls . tuple ) ) # ▁ tuple ENDCOM NEW_LINE self . assertEqual ( ls , LineString ( * ls . tuple ) ) # ▁ as ▁ individual ▁ arguments ENDCOM NEW_LINE self . assertEqual ( ls , LineString ( [ list ( tup ) for tup in ls . tuple ] ) ) # ▁ as ▁ list ENDCOM NEW_LINE self . assertEqual ( ls . wkt , LineString ( * tuple ( Point ( tup ) for tup in ls . tuple ) ) . wkt ) # ▁ Point ▁ individual ▁ arguments ENDCOM NEW_LINE if numpy : self . assertEqual ( ls , LineString ( numpy . array ( ls . tuple ) ) ) # ▁ as ▁ numpy ▁ array ENDCOM NEW_LINE DEDENT DEDENT def test03b_multilinestring ( self ) : NEW_LINE INDENT " Testing ▁ MultiLineString ▁ objects . " NEW_LINE prev = fromstr ( ' POINT ( 0 ▁ 0 ) ' ) NEW_LINE for l in self . geometries . multilinestrings : NEW_LINE INDENT ml = fromstr ( l . wkt ) NEW_LINE self . assertEqual ( ml . geom_type , ' MultiLineString ' ) NEW_LINE self . assertEqual ( ml . geom_typeid , 5 ) NEW_LINE self . assertAlmostEqual ( l . centroid [ 0 ] , ml . centroid . x , 9 ) NEW_LINE self . assertAlmostEqual ( l . centroid [ 1 ] , ml . centroid . y , 9 ) NEW_LINE self . assertEqual ( True , ml == fromstr ( l . wkt ) ) NEW_LINE self . assertEqual ( False , ml == prev ) NEW_LINE prev = ml NEW_LINE for ls in ml : NEW_LINE INDENT self . assertEqual ( ls . geom_type , ' LineString ' ) NEW_LINE self . assertEqual ( ls . geom_typeid , 1 ) NEW_LINE self . assertEqual ( ls . empty , False ) NEW_LINE DEDENT self . assertRaises ( GEOSIndexError , ml . __getitem__ , len ( ml ) ) NEW_LINE self . assertEqual ( ml . wkt , MultiLineString ( * tuple ( s . clone ( ) for s in ml ) ) . wkt ) NEW_LINE self . assertEqual ( ml , MultiLineString ( * tuple ( LineString ( s . tuple ) for s in ml ) ) ) NEW_LINE DEDENT DEDENT def test04_linearring ( self ) : NEW_LINE INDENT " Testing ▁ LinearRing ▁ objects . " NEW_LINE for rr in self . geometries . linearrings : NEW_LINE INDENT lr = fromstr ( rr . wkt ) NEW_LINE self . assertEqual ( lr . geom_type , ' LinearRing ' ) NEW_LINE self . assertEqual ( lr . geom_typeid , 2 ) NEW_LINE self . assertEqual ( rr . n_p , len ( lr ) ) NEW_LINE self . assertEqual ( True , lr . valid ) NEW_LINE self . assertEqual ( False , lr . empty ) NEW_LINE # ▁ Creating ▁ a ▁ LinearRing ▁ from ▁ a ▁ tuple , ▁ list , ▁ and ▁ numpy ▁ array ENDCOM self . assertEqual ( lr , LinearRing ( lr . tuple ) ) NEW_LINE self . assertEqual ( lr , LinearRing ( * lr . tuple ) ) NEW_LINE self . assertEqual ( lr , LinearRing ( [ list ( tup ) for tup in lr . tuple ] ) ) NEW_LINE if numpy : self . assertEqual ( lr , LinearRing ( numpy . array ( lr . tuple ) ) ) NEW_LINE DEDENT DEDENT def test05a_polygons ( self ) : NEW_LINE INDENT " Testing ▁ Polygon ▁ objects . " NEW_LINE # ▁ Testing ▁ ` from _ bbox ` ▁ class ▁ method ENDCOM bbox = ( - 180 , - 90 , 180 , 90 ) NEW_LINE p = Polygon . from_bbox ( bbox ) NEW_LINE self . assertEqual ( bbox , p . extent ) NEW_LINE prev = fromstr ( ' POINT ( 0 ▁ 0 ) ' ) NEW_LINE for p in self . geometries . polygons : NEW_LINE # ▁ Creating ▁ the ▁ Polygon , ▁ testing ▁ its ▁ properties . ENDCOM INDENT poly = fromstr ( p . wkt ) NEW_LINE self . assertEqual ( poly . geom_type , ' Polygon ' ) NEW_LINE self . assertEqual ( poly . geom_typeid , 3 ) NEW_LINE self . assertEqual ( poly . empty , False ) NEW_LINE self . assertEqual ( poly . ring , False ) NEW_LINE self . assertEqual ( p . n_i , poly . num_interior_rings ) NEW_LINE self . assertEqual ( p . n_i + 1 , len ( poly ) ) # ▁ Testing ▁ _ _ len _ _ ENDCOM NEW_LINE self . assertEqual ( p . n_p , poly . num_points ) NEW_LINE # ▁ Area ▁ & ▁ Centroid ENDCOM self . assertAlmostEqual ( p . area , poly . area , 9 ) NEW_LINE self . assertAlmostEqual ( p . centroid [ 0 ] , poly . centroid . tuple [ 0 ] , 9 ) NEW_LINE self . assertAlmostEqual ( p . centroid [ 1 ] , poly . centroid . tuple [ 1 ] , 9 ) NEW_LINE # ▁ Testing ▁ the ▁ geometry ▁ equivalence ENDCOM self . assertEqual ( True , poly == fromstr ( p . wkt ) ) NEW_LINE self . assertEqual ( False , poly == prev ) # ▁ Should ▁ not ▁ be ▁ equal ▁ to ▁ previous ▁ geometry ENDCOM NEW_LINE self . assertEqual ( True , poly != prev ) NEW_LINE # ▁ Testing ▁ the ▁ exterior ▁ ring ENDCOM ring = poly . exterior_ring NEW_LINE self . assertEqual ( ring . geom_type , ' LinearRing ' ) NEW_LINE self . assertEqual ( ring . geom_typeid , 2 ) NEW_LINE if p . ext_ring_cs : NEW_LINE INDENT self . assertEqual ( p . ext_ring_cs , ring . tuple ) NEW_LINE self . assertEqual ( p . ext_ring_cs , poly [ 0 ] . tuple ) # ▁ Testing ▁ _ _ getitem _ _ ENDCOM NEW_LINE # ▁ Testing ▁ _ _ getitem _ _ ▁ and ▁ _ _ setitem _ _ ▁ on ▁ invalid ▁ indices ENDCOM DEDENT self . assertRaises ( GEOSIndexError , poly . __getitem__ , len ( poly ) ) NEW_LINE self . assertRaises ( GEOSIndexError , poly . __setitem__ , len ( poly ) , False ) NEW_LINE self . assertRaises ( GEOSIndexError , poly . __getitem__ , - 1 * len ( poly ) - 1 ) NEW_LINE # ▁ Testing ▁ _ _ iter _ _ ENDCOM for r in poly : NEW_LINE INDENT self . assertEqual ( r . geom_type , ' LinearRing ' ) NEW_LINE self . assertEqual ( r . geom_typeid , 2 ) NEW_LINE # ▁ Testing ▁ polygon ▁ construction . ENDCOM DEDENT self . assertRaises ( TypeError , Polygon . __init__ , 0 , [ 1 , 2 , 3 ] ) NEW_LINE self . assertRaises ( TypeError , Polygon . __init__ , ' foo ' ) NEW_LINE # ▁ Polygon ( shell , ▁ ( hole1 , ▁ . . . ▁ holeN ) ) ENDCOM rings = tuple ( r for r in poly ) NEW_LINE self . assertEqual ( poly , Polygon ( rings [ 0 ] , rings [ 1 : ] ) ) NEW_LINE # ▁ Polygon ( shell _ tuple , ▁ hole _ tuple1 , ▁ . . . ▁ , ▁ hole _ tupleN ) ENDCOM ring_tuples = tuple ( r . tuple for r in poly ) NEW_LINE self . assertEqual ( poly , Polygon ( * ring_tuples ) ) NEW_LINE # ▁ Constructing ▁ with ▁ tuples ▁ of ▁ LinearRings . ENDCOM self . assertEqual ( poly . wkt , Polygon ( * tuple ( r for r in poly ) ) . wkt ) NEW_LINE self . assertEqual ( poly . wkt , Polygon ( * tuple ( LinearRing ( r . tuple ) for r in poly ) ) . wkt ) NEW_LINE DEDENT DEDENT def test05b_multipolygons ( self ) : NEW_LINE INDENT " Testing ▁ MultiPolygon ▁ objects . " NEW_LINE print " \n BEGIN ▁ - ▁ expecting ▁ GEOS _ NOTICE ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE prev = fromstr ( ' POINT ▁ ( 0 ▁ 0 ) ' ) NEW_LINE for mp in self . geometries . multipolygons : NEW_LINE INDENT mpoly = fromstr ( mp . wkt ) NEW_LINE self . assertEqual ( mpoly . geom_type , ' MultiPolygon ' ) NEW_LINE self . assertEqual ( mpoly . geom_typeid , 6 ) NEW_LINE self . assertEqual ( mp . valid , mpoly . valid ) NEW_LINE if mp . valid : NEW_LINE INDENT self . assertEqual ( mp . num_geom , mpoly . num_geom ) NEW_LINE self . assertEqual ( mp . n_p , mpoly . num_coords ) NEW_LINE self . assertEqual ( mp . num_geom , len ( mpoly ) ) NEW_LINE self . assertRaises ( GEOSIndexError , mpoly . __getitem__ , len ( mpoly ) ) NEW_LINE for p in mpoly : NEW_LINE INDENT self . assertEqual ( p . geom_type , ' Polygon ' ) NEW_LINE self . assertEqual ( p . geom_typeid , 3 ) NEW_LINE self . assertEqual ( p . valid , True ) NEW_LINE DEDENT self . assertEqual ( mpoly . wkt , MultiPolygon ( * tuple ( poly . clone ( ) for poly in mpoly ) ) . wkt ) NEW_LINE DEDENT DEDENT print " \n END ▁ - ▁ expecting ▁ GEOS _ NOTICE ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE DEDENT def test06a_memory_hijinks ( self ) : NEW_LINE INDENT " Testing ▁ Geometry ▁ _ _ del _ _ ( ) ▁ on ▁ rings ▁ and ▁ polygons . " NEW_LINE # # # # ▁ Memory ▁ issues ▁ with ▁ rings ▁ and ▁ polygons ENDCOM # ▁ These ▁ tests ▁ are ▁ needed ▁ to ▁ ensure ▁ sanity ▁ with ▁ writable ▁ geometries . ENDCOM # ▁ Getting ▁ a ▁ polygon ▁ with ▁ interior ▁ rings , ▁ and ▁ pulling ▁ out ▁ the ▁ interior ▁ rings ENDCOM poly = fromstr ( self . geometries . polygons [ 1 ] . wkt ) NEW_LINE ring1 = poly [ 0 ] NEW_LINE ring2 = poly [ 1 ] NEW_LINE # ▁ These ▁ deletes ▁ should ▁ be ▁ ' harmless ' ▁ since ▁ they ▁ are ▁ done ▁ on ▁ child ▁ geometries ENDCOM del ring1 NEW_LINE del ring2 NEW_LINE ring1 = poly [ 0 ] NEW_LINE ring2 = poly [ 1 ] NEW_LINE # ▁ Deleting ▁ the ▁ polygon ENDCOM del poly NEW_LINE # ▁ Access ▁ to ▁ these ▁ rings ▁ is ▁ OK ▁ since ▁ they ▁ are ▁ clones . ENDCOM s1 , s2 = str ( ring1 ) , str ( ring2 ) NEW_LINE DEDENT def test08_coord_seq ( self ) : NEW_LINE INDENT " Testing ▁ Coordinate ▁ Sequence ▁ objects . " NEW_LINE for p in self . geometries . polygons : NEW_LINE INDENT if p . ext_ring_cs : NEW_LINE # ▁ Constructing ▁ the ▁ polygon ▁ and ▁ getting ▁ the ▁ coordinate ▁ sequence ENDCOM INDENT poly = fromstr ( p . wkt ) NEW_LINE cs = poly . exterior_ring . coord_seq NEW_LINE self . assertEqual ( p . ext_ring_cs , cs . tuple ) # ▁ done ▁ in ▁ the ▁ Polygon ▁ test ▁ too . ENDCOM NEW_LINE self . assertEqual ( len ( p . ext_ring_cs ) , len ( cs ) ) # ▁ Making ▁ sure ▁ _ _ len _ _ ▁ works ENDCOM NEW_LINE # ▁ Checks ▁ _ _ getitem _ _ ▁ and ▁ _ _ setitem _ _ ENDCOM for i in xrange ( len ( p . ext_ring_cs ) ) : NEW_LINE INDENT c1 = p . ext_ring_cs [ i ] # ▁ Expected ▁ value ENDCOM NEW_LINE c2 = cs [ i ] # ▁ Value ▁ from ▁ coordseq ENDCOM NEW_LINE self . assertEqual ( c1 , c2 ) NEW_LINE # ▁ Constructing ▁ the ▁ test ▁ value ▁ to ▁ set ▁ the ▁ coordinate ▁ sequence ▁ with ENDCOM if len ( c1 ) == 2 : tset = ( 5 , 23 ) NEW_LINE else : tset = ( 5 , 23 , 8 ) NEW_LINE cs [ i ] = tset NEW_LINE # ▁ Making ▁ sure ▁ every ▁ set ▁ point ▁ matches ▁ what ▁ we ▁ expect ENDCOM for j in range ( len ( tset ) ) : NEW_LINE INDENT cs [ i ] = tset NEW_LINE self . assertEqual ( tset [ j ] , cs [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def test09_relate_pattern ( self ) : NEW_LINE INDENT " Testing ▁ relate ( ) ▁ and ▁ relate _ pattern ( ) . " NEW_LINE g = fromstr ( ' POINT ▁ ( 0 ▁ 0 ) ' ) NEW_LINE self . assertRaises ( GEOSException , g . relate_pattern , 0 , ' invalid ▁ pattern , ▁ yo ' ) NEW_LINE for rg in self . geometries . relate_geoms : NEW_LINE INDENT a = fromstr ( rg . wkt_a ) NEW_LINE b = fromstr ( rg . wkt_b ) NEW_LINE self . assertEqual ( rg . result , a . relate_pattern ( b , rg . pattern ) ) NEW_LINE self . assertEqual ( rg . pattern , a . relate ( b ) ) NEW_LINE DEDENT DEDENT def test10_intersection ( self ) : NEW_LINE INDENT " Testing ▁ intersects ( ) ▁ and ▁ intersection ( ) . " NEW_LINE for i in xrange ( len ( self . geometries . topology_geoms ) ) : NEW_LINE INDENT a = fromstr ( self . geometries . topology_geoms [ i ] . wkt_a ) NEW_LINE b = fromstr ( self . geometries . topology_geoms [ i ] . wkt_b ) NEW_LINE i1 = fromstr ( self . geometries . intersect_geoms [ i ] . wkt ) NEW_LINE self . assertEqual ( True , a . intersects ( b ) ) NEW_LINE i2 = a . intersection ( b ) NEW_LINE self . assertEqual ( i1 , i2 ) NEW_LINE self . assertEqual ( i1 , a & b ) # ▁ _ _ and _ _ ▁ is ▁ intersection ▁ operator ENDCOM NEW_LINE a &= b # ▁ testing ▁ _ _ iand _ _ ENDCOM NEW_LINE self . assertEqual ( i1 , a ) NEW_LINE DEDENT DEDENT def test11_union ( self ) : NEW_LINE INDENT " Testing ▁ union ( ) . " NEW_LINE for i in xrange ( len ( self . geometries . topology_geoms ) ) : NEW_LINE INDENT a = fromstr ( self . geometries . topology_geoms [ i ] . wkt_a ) NEW_LINE b = fromstr ( self . geometries . topology_geoms [ i ] . wkt_b ) NEW_LINE u1 = fromstr ( self . geometries . union_geoms [ i ] . wkt ) NEW_LINE u2 = a . union ( b ) NEW_LINE self . assertEqual ( u1 , u2 ) NEW_LINE self . assertEqual ( u1 , a | b ) # ▁ _ _ or _ _ ▁ is ▁ union ▁ operator ENDCOM NEW_LINE a |= b # ▁ testing ▁ _ _ ior _ _ ENDCOM NEW_LINE self . assertEqual ( u1 , a ) NEW_LINE DEDENT DEDENT def test12_difference ( self ) : NEW_LINE INDENT " Testing ▁ difference ( ) . " NEW_LINE for i in xrange ( len ( self . geometries . topology_geoms ) ) : NEW_LINE INDENT a = fromstr ( self . geometries . topology_geoms [ i ] . wkt_a ) NEW_LINE b = fromstr ( self . geometries . topology_geoms [ i ] . wkt_b ) NEW_LINE d1 = fromstr ( self . geometries . diff_geoms [ i ] . wkt ) NEW_LINE d2 = a . difference ( b ) NEW_LINE self . assertEqual ( d1 , d2 ) NEW_LINE self . assertEqual ( d1 , a - b ) # ▁ _ _ sub _ _ ▁ is ▁ difference ▁ operator ENDCOM NEW_LINE a -= b # ▁ testing ▁ _ _ isub _ _ ENDCOM NEW_LINE self . assertEqual ( d1 , a ) NEW_LINE DEDENT DEDENT def test13_symdifference ( self ) : NEW_LINE INDENT " Testing ▁ sym _ difference ( ) . " NEW_LINE for i in xrange ( len ( self . geometries . topology_geoms ) ) : NEW_LINE INDENT a = fromstr ( self . geometries . topology_geoms [ i ] . wkt_a ) NEW_LINE b = fromstr ( self . geometries . topology_geoms [ i ] . wkt_b ) NEW_LINE d1 = fromstr ( self . geometries . sdiff_geoms [ i ] . wkt ) NEW_LINE d2 = a . sym_difference ( b ) NEW_LINE self . assertEqual ( d1 , d2 ) NEW_LINE self . assertEqual ( d1 , a ^ b ) # ▁ _ _ xor _ _ ▁ is ▁ symmetric ▁ difference ▁ operator ENDCOM NEW_LINE a ^= b # ▁ testing ▁ _ _ ixor _ _ ENDCOM NEW_LINE self . assertEqual ( d1 , a ) NEW_LINE DEDENT DEDENT def test14_buffer ( self ) : NEW_LINE INDENT " Testing ▁ buffer ( ) . " NEW_LINE for bg in self . geometries . buffer_geoms : NEW_LINE INDENT g = fromstr ( bg . wkt ) NEW_LINE # ▁ The ▁ buffer ▁ we ▁ expect ENDCOM exp_buf = fromstr ( bg . buffer_wkt ) NEW_LINE quadsegs = bg . quadsegs NEW_LINE width = bg . width NEW_LINE # ▁ Can ' t ▁ use ▁ a ▁ floating - point ▁ for ▁ the ▁ number ▁ of ▁ quadsegs . ENDCOM self . assertRaises ( ctypes . ArgumentError , g . buffer , width , float ( quadsegs ) ) NEW_LINE # ▁ Constructing ▁ our ▁ buffer ENDCOM buf = g . buffer ( width , quadsegs ) NEW_LINE self . assertEqual ( exp_buf . num_coords , buf . num_coords ) NEW_LINE self . assertEqual ( len ( exp_buf ) , len ( buf ) ) NEW_LINE # ▁ Now ▁ assuring ▁ that ▁ each ▁ point ▁ in ▁ the ▁ buffer ▁ is ▁ almost ▁ equal ENDCOM for j in xrange ( len ( exp_buf ) ) : NEW_LINE INDENT exp_ring = exp_buf [ j ] NEW_LINE buf_ring = buf [ j ] NEW_LINE self . assertEqual ( len ( exp_ring ) , len ( buf_ring ) ) NEW_LINE for k in xrange ( len ( exp_ring ) ) : NEW_LINE # ▁ Asserting ▁ the ▁ X , ▁ Y ▁ of ▁ each ▁ point ▁ are ▁ almost ▁ equal ▁ ( due ▁ to ▁ floating ▁ point ▁ imprecision ) ENDCOM INDENT self . assertAlmostEqual ( exp_ring [ k ] [ 0 ] , buf_ring [ k ] [ 0 ] , 9 ) NEW_LINE self . assertAlmostEqual ( exp_ring [ k ] [ 1 ] , buf_ring [ k ] [ 1 ] , 9 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def test15_srid ( self ) : NEW_LINE INDENT " Testing ▁ the ▁ SRID ▁ property ▁ and ▁ keyword . " NEW_LINE # ▁ Testing ▁ SRID ▁ keyword ▁ on ▁ Point ENDCOM pnt = Point ( 5 , 23 , srid = 4326 ) NEW_LINE self . assertEqual ( 4326 , pnt . srid ) NEW_LINE pnt . srid = 3084 NEW_LINE self . assertEqual ( 3084 , pnt . srid ) NEW_LINE self . assertRaises ( ctypes . ArgumentError , pnt . set_srid , '4326' ) NEW_LINE # ▁ Testing ▁ SRID ▁ keyword ▁ on ▁ fromstr ( ) , ▁ and ▁ on ▁ Polygon ▁ rings . ENDCOM poly = fromstr ( self . geometries . polygons [ 1 ] . wkt , srid = 4269 ) NEW_LINE self . assertEqual ( 4269 , poly . srid ) NEW_LINE for ring in poly : self . assertEqual ( 4269 , ring . srid ) NEW_LINE poly . srid = 4326 NEW_LINE self . assertEqual ( 4326 , poly . shell . srid ) NEW_LINE # ▁ Testing ▁ SRID ▁ keyword ▁ on ▁ GeometryCollection ENDCOM gc = GeometryCollection ( Point ( 5 , 23 ) , LineString ( ( 0 , 0 ) , ( 1.5 , 1.5 ) , ( 3 , 3 ) ) , srid = 32021 ) NEW_LINE self . assertEqual ( 32021 , gc . srid ) NEW_LINE for i in range ( len ( gc ) ) : self . assertEqual ( 32021 , gc [ i ] . srid ) NEW_LINE # ▁ GEOS ▁ may ▁ get ▁ the ▁ SRID ▁ from ▁ HEXEWKB ENDCOM # ▁ ' POINT ( 5 ▁ 23 ) ' ▁ at ▁ SRID = 4326 ▁ in ▁ hex ▁ form ▁ - - ▁ obtained ▁ from ▁ PostGIS ENDCOM # ▁ using ▁ ` SELECT ▁ GeomFromText ( ' POINT ▁ ( 5 ▁ 23 ) ' , ▁ 4326 ) ; ` . ENDCOM hex = '0101000020E610000000000000000014400000000000003740' NEW_LINE p1 = fromstr ( hex ) NEW_LINE self . assertEqual ( 4326 , p1 . srid ) NEW_LINE # ▁ In ▁ GEOS ▁ 3.0.0rc1-4 ▁ when ▁ the ▁ EWKB ▁ and / or ▁ HEXEWKB ▁ is ▁ exported , ENDCOM # ▁ the ▁ SRID ▁ information ▁ is ▁ lost ▁ and ▁ set ▁ to ▁ - 1 ▁ - - ▁ this ▁ is ▁ not ▁ a ENDCOM # ▁ problem ▁ on ▁ the ▁ 3.0.0 ▁ version ▁ ( another ▁ reason ▁ to ▁ upgrade ) . ENDCOM exp_srid = self . null_srid NEW_LINE p2 = fromstr ( p1 . hex ) NEW_LINE self . assertEqual ( exp_srid , p2 . srid ) NEW_LINE p3 = fromstr ( p1 . hex , srid = - 1 ) # ▁ - 1 ▁ is ▁ intended . ENDCOM NEW_LINE self . assertEqual ( - 1 , p3 . srid ) NEW_LINE DEDENT def test16_mutable_geometries ( self ) : NEW_LINE INDENT " Testing ▁ the ▁ mutability ▁ of ▁ Polygons ▁ and ▁ Geometry ▁ Collections . " NEW_LINE # # # ▁ Testing ▁ the ▁ mutability ▁ of ▁ Polygons ▁ # # # ENDCOM for p in self . geometries . polygons : NEW_LINE INDENT poly = fromstr ( p . wkt ) NEW_LINE # ▁ Should ▁ only ▁ be ▁ able ▁ to ▁ use ▁ _ _ setitem _ _ ▁ with ▁ LinearRing ▁ geometries . ENDCOM self . assertRaises ( TypeError , poly . __setitem__ , 0 , LineString ( ( 1 , 1 ) , ( 2 , 2 ) ) ) NEW_LINE # ▁ Constructing ▁ the ▁ new ▁ shell ▁ by ▁ adding ▁ 500 ▁ to ▁ every ▁ point ▁ in ▁ the ▁ old ▁ shell . ENDCOM shell_tup = poly . shell . tuple NEW_LINE new_coords = [ ] NEW_LINE for point in shell_tup : new_coords . append ( ( point [ 0 ] + 500. , point [ 1 ] + 500. ) ) NEW_LINE new_shell = LinearRing ( * tuple ( new_coords ) ) NEW_LINE # ▁ Assigning ▁ polygon ' s ▁ exterior ▁ ring ▁ w / the ▁ new ▁ shell ENDCOM poly . exterior_ring = new_shell NEW_LINE s = str ( new_shell ) # ▁ new ▁ shell ▁ is ▁ still ▁ accessible ENDCOM NEW_LINE self . assertEqual ( poly . exterior_ring , new_shell ) NEW_LINE self . assertEqual ( poly [ 0 ] , new_shell ) NEW_LINE # # # ▁ Testing ▁ the ▁ mutability ▁ of ▁ Geometry ▁ Collections ENDCOM DEDENT for tg in self . geometries . multipoints : NEW_LINE INDENT mp = fromstr ( tg . wkt ) NEW_LINE for i in range ( len ( mp ) ) : NEW_LINE # ▁ Creating ▁ a ▁ random ▁ point . ENDCOM INDENT pnt = mp [ i ] NEW_LINE new = Point ( random . randint ( 1 , 100 ) , random . randint ( 1 , 100 ) ) NEW_LINE # ▁ Testing ▁ the ▁ assignment ENDCOM mp [ i ] = new NEW_LINE s = str ( new ) # ▁ what ▁ was ▁ used ▁ for ▁ the ▁ assignment ▁ is ▁ still ▁ accessible ENDCOM NEW_LINE self . assertEqual ( mp [ i ] , new ) NEW_LINE self . assertEqual ( mp [ i ] . wkt , new . wkt ) NEW_LINE self . assertNotEqual ( pnt , mp [ i ] ) NEW_LINE # ▁ MultiPolygons ▁ involve ▁ much ▁ more ▁ memory ▁ management ▁ because ▁ each ENDCOM # ▁ Polygon ▁ w / in ▁ the ▁ collection ▁ has ▁ its ▁ own ▁ rings . ENDCOM DEDENT DEDENT for tg in self . geometries . multipolygons : NEW_LINE INDENT mpoly = fromstr ( tg . wkt ) NEW_LINE for i in xrange ( len ( mpoly ) ) : NEW_LINE INDENT poly = mpoly [ i ] NEW_LINE old_poly = mpoly [ i ] NEW_LINE # ▁ Offsetting ▁ the ▁ each ▁ ring ▁ in ▁ the ▁ polygon ▁ by ▁ 500 . ENDCOM for j in xrange ( len ( poly ) ) : NEW_LINE INDENT r = poly [ j ] NEW_LINE for k in xrange ( len ( r ) ) : r [ k ] = ( r [ k ] [ 0 ] + 500. , r [ k ] [ 1 ] + 500. ) NEW_LINE poly [ j ] = r NEW_LINE DEDENT self . assertNotEqual ( mpoly [ i ] , poly ) NEW_LINE # ▁ Testing ▁ the ▁ assignment ENDCOM mpoly [ i ] = poly NEW_LINE s = str ( poly ) # ▁ Still ▁ accessible ENDCOM NEW_LINE self . assertEqual ( mpoly [ i ] , poly ) NEW_LINE self . assertNotEqual ( mpoly [ i ] , old_poly ) NEW_LINE # ▁ Extreme ▁ ( ! ! ) ▁ _ _ setitem _ _ ▁ - - ▁ no ▁ longer ▁ works , ▁ have ▁ to ▁ detect ENDCOM # ▁ in ▁ the ▁ first ▁ object ▁ that ▁ _ _ setitem _ _ ▁ is ▁ called ▁ in ▁ the ▁ subsequent ENDCOM # ▁ objects ▁ - - ▁ maybe ▁ mpoly [ 0 , ▁ 0 , ▁ 0 ] ▁ = ▁ ( 3.14 , ▁ 2.71 ) ? ENDCOM # mpoly [ 0 ] [ 0 ] [ 0 ] ▁ = ▁ ( 3.14 , ▁ 2.71 ) ENDCOM # self . assertEqual ( (3.14 , ▁ 2.71 ) , ▁ mpoly [ 0 ] [ 0 ] [ 0 ] ) ENDCOM # ▁ Doing ▁ it ▁ more ▁ slowly . . ENDCOM # self . assertEqual ( (3.14 , ▁ 2.71 ) , ▁ mpoly [ 0 ] . shell [ 0 ] ) ENDCOM # del ▁ mpoly ENDCOM DEDENT DEDENT DEDENT def test17_threed ( self ) : NEW_LINE INDENT " Testing ▁ three - dimensional ▁ geometries . " NEW_LINE # ▁ Testing ▁ a ▁ 3D ▁ Point ENDCOM pnt = Point ( 2 , 3 , 8 ) NEW_LINE self . assertEqual ( ( 2. , 3. , 8. ) , pnt . coords ) NEW_LINE self . assertRaises ( TypeError , pnt . set_coords , ( 1. , 2. ) ) NEW_LINE pnt . coords = ( 1. , 2. , 3. ) NEW_LINE self . assertEqual ( ( 1. , 2. , 3. ) , pnt . coords ) NEW_LINE # ▁ Testing ▁ a ▁ 3D ▁ LineString ENDCOM ls = LineString ( ( 2. , 3. , 8. ) , ( 50. , 250. , - 117. ) ) NEW_LINE self . assertEqual ( ( ( 2. , 3. , 8. ) , ( 50. , 250. , - 117. ) ) , ls . tuple ) NEW_LINE self . assertRaises ( TypeError , ls . __setitem__ , 0 , ( 1. , 2. ) ) NEW_LINE ls [ 0 ] = ( 1. , 2. , 3. ) NEW_LINE self . assertEqual ( ( 1. , 2. , 3. ) , ls [ 0 ] ) NEW_LINE DEDENT def test18_distance ( self ) : NEW_LINE INDENT " Testing ▁ the ▁ distance ( ) ▁ function . " NEW_LINE # ▁ Distance ▁ to ▁ self ▁ should ▁ be ▁ 0 . ENDCOM pnt = Point ( 0 , 0 ) NEW_LINE self . assertEqual ( 0.0 , pnt . distance ( Point ( 0 , 0 ) ) ) NEW_LINE # ▁ Distance ▁ should ▁ be ▁ 1 ENDCOM self . assertEqual ( 1.0 , pnt . distance ( Point ( 0 , 1 ) ) ) NEW_LINE # ▁ Distance ▁ should ▁ be ▁ ~ ▁ sqrt ( 2 ) ENDCOM self . assertAlmostEqual ( 1.41421356237 , pnt . distance ( Point ( 1 , 1 ) ) , 11 ) NEW_LINE # ▁ Distances ▁ are ▁ from ▁ the ▁ closest ▁ vertex ▁ in ▁ each ▁ geometry ▁ - - ENDCOM # ▁ should ▁ be ▁ 3 ▁ ( distance ▁ from ▁ ( 2 , ▁ 2 ) ▁ to ▁ ( 5 , ▁ 2 ) ) . ENDCOM ls1 = LineString ( ( 0 , 0 ) , ( 1 , 1 ) , ( 2 , 2 ) ) NEW_LINE ls2 = LineString ( ( 5 , 2 ) , ( 6 , 1 ) , ( 7 , 0 ) ) NEW_LINE self . assertEqual ( 3 , ls1 . distance ( ls2 ) ) NEW_LINE DEDENT def test19_length ( self ) : NEW_LINE INDENT " Testing ▁ the ▁ length ▁ property . " NEW_LINE # ▁ Points ▁ have ▁ 0 ▁ length . ENDCOM pnt = Point ( 0 , 0 ) NEW_LINE self . assertEqual ( 0.0 , pnt . length ) NEW_LINE # ▁ Should ▁ be ▁ ~ ▁ sqrt ( 2 ) ENDCOM ls = LineString ( ( 0 , 0 ) , ( 1 , 1 ) ) NEW_LINE self . assertAlmostEqual ( 1.41421356237 , ls . length , 11 ) NEW_LINE # ▁ Should ▁ be ▁ circumfrence ▁ of ▁ Polygon ENDCOM poly = Polygon ( LinearRing ( ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 0 , 0 ) ) ) NEW_LINE self . assertEqual ( 4.0 , poly . length ) NEW_LINE # ▁ Should ▁ be ▁ sum ▁ of ▁ each ▁ element ' s ▁ length ▁ in ▁ collection . ENDCOM mpoly = MultiPolygon ( poly . clone ( ) , poly ) NEW_LINE self . assertEqual ( 8.0 , mpoly . length ) NEW_LINE DEDENT def test20a_emptyCollections ( self ) : NEW_LINE INDENT " Testing ▁ empty ▁ geometries ▁ and ▁ collections . " NEW_LINE gc1 = GeometryCollection ( [ ] ) NEW_LINE gc2 = fromstr ( ' GEOMETRYCOLLECTION ▁ EMPTY ' ) NEW_LINE pnt = fromstr ( ' POINT ▁ EMPTY ' ) NEW_LINE ls = fromstr ( ' LINESTRING ▁ EMPTY ' ) NEW_LINE poly = fromstr ( ' POLYGON ▁ EMPTY ' ) NEW_LINE mls = fromstr ( ' MULTILINESTRING ▁ EMPTY ' ) NEW_LINE mpoly1 = fromstr ( ' MULTIPOLYGON ▁ EMPTY ' ) NEW_LINE mpoly2 = MultiPolygon ( ( ) ) NEW_LINE for g in [ gc1 , gc2 , pnt , ls , poly , mls , mpoly1 , mpoly2 ] : NEW_LINE INDENT self . assertEqual ( True , g . empty ) NEW_LINE # ▁ Testing ▁ len ( ) ▁ and ▁ num _ geom . ENDCOM if isinstance ( g , Polygon ) : NEW_LINE INDENT self . assertEqual ( 1 , len ( g ) ) # ▁ Has ▁ one ▁ empty ▁ linear ▁ ring ENDCOM NEW_LINE self . assertEqual ( 1 , g . num_geom ) NEW_LINE self . assertEqual ( 0 , len ( g [ 0 ] ) ) NEW_LINE DEDENT elif isinstance ( g , ( Point , LineString ) ) : NEW_LINE INDENT self . assertEqual ( 1 , g . num_geom ) NEW_LINE self . assertEqual ( 0 , len ( g ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( 0 , g . num_geom ) NEW_LINE self . assertEqual ( 0 , len ( g ) ) NEW_LINE # ▁ Testing ▁ _ _ getitem _ _ ▁ ( doesn ' t ▁ work ▁ on ▁ Point ▁ or ▁ Polygon ) ENDCOM DEDENT if isinstance ( g , Point ) : NEW_LINE INDENT self . assertRaises ( GEOSIndexError , g . get_x ) NEW_LINE DEDENT elif isinstance ( g , Polygon ) : NEW_LINE INDENT lr = g . shell NEW_LINE self . assertEqual ( ' LINEARRING ▁ EMPTY ' , lr . wkt ) NEW_LINE self . assertEqual ( 0 , len ( lr ) ) NEW_LINE self . assertEqual ( True , lr . empty ) NEW_LINE self . assertRaises ( GEOSIndexError , lr . __getitem__ , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertRaises ( GEOSIndexError , g . __getitem__ , 0 ) NEW_LINE DEDENT DEDENT DEDENT def test20b_collections_of_collections ( self ) : NEW_LINE INDENT " Testing ▁ GeometryCollection ▁ handling ▁ of ▁ other ▁ collections . " NEW_LINE # ▁ Creating ▁ a ▁ GeometryCollection ▁ WKT ▁ string ▁ composed ▁ of ▁ other ENDCOM # ▁ collections ▁ and ▁ polygons . ENDCOM coll = [ mp . wkt for mp in self . geometries . multipolygons if mp . valid ] NEW_LINE coll . extend ( [ mls . wkt for mls in self . geometries . multilinestrings ] ) NEW_LINE coll . extend ( [ p . wkt for p in self . geometries . polygons ] ) NEW_LINE coll . extend ( [ mp . wkt for mp in self . geometries . multipoints ] ) NEW_LINE gc_wkt = ' GEOMETRYCOLLECTION ( % s ) ' % ' , ' . join ( coll ) NEW_LINE # ▁ Should ▁ construct ▁ ok ▁ from ▁ WKT ENDCOM gc1 = GEOSGeometry ( gc_wkt ) NEW_LINE # ▁ Should ▁ also ▁ construct ▁ ok ▁ from ▁ individual ▁ geometry ▁ arguments . ENDCOM gc2 = GeometryCollection ( * tuple ( g for g in gc1 ) ) NEW_LINE # ▁ And , ▁ they ▁ should ▁ be ▁ equal . ENDCOM self . assertEqual ( gc1 , gc2 ) NEW_LINE DEDENT def test21_test_gdal ( self ) : NEW_LINE INDENT " Testing ▁ ` ogr ` ▁ and ▁ ` srs ` ▁ properties . " NEW_LINE if not gdal . HAS_GDAL : return NEW_LINE g1 = fromstr ( ' POINT ( 5 ▁ 23 ) ' ) NEW_LINE self . assertEqual ( True , isinstance ( g1 . ogr , gdal . OGRGeometry ) ) NEW_LINE self . assertEqual ( g1 . srs , None ) NEW_LINE g2 = fromstr ( ' LINESTRING ( 0 ▁ 0 , ▁ 5 ▁ 5 , ▁ 23 ▁ 23 ) ' , srid = 4326 ) NEW_LINE self . assertEqual ( True , isinstance ( g2 . ogr , gdal . OGRGeometry ) ) NEW_LINE self . assertEqual ( True , isinstance ( g2 . srs , gdal . SpatialReference ) ) NEW_LINE self . assertEqual ( g2 . hex , g2 . ogr . hex ) NEW_LINE self . assertEqual ( ' WGS ▁ 84' , g2 . srs . name ) NEW_LINE DEDENT def test22_copy ( self ) : NEW_LINE INDENT " Testing ▁ use ▁ with ▁ the ▁ Python ▁ ` copy ` ▁ module . " NEW_LINE import django . utils . copycompat as copy NEW_LINE poly = GEOSGeometry ( ' POLYGON ( (0 ▁ 0 , ▁ 0 ▁ 23 , ▁ 23 ▁ 23 , ▁ 23 ▁ 0 , ▁ 0 ▁ 0 ) , ▁ ( 5 ▁ 5 , ▁ 5 ▁ 10 , ▁ 10 ▁ 10 , ▁ 10 ▁ 5 , ▁ 5 ▁ 5 ) ) ' ) NEW_LINE cpy1 = copy . copy ( poly ) NEW_LINE cpy2 = copy . deepcopy ( poly ) NEW_LINE self . assertNotEqual ( poly . _ptr , cpy1 . _ptr ) NEW_LINE self . assertNotEqual ( poly . _ptr , cpy2 . _ptr ) NEW_LINE DEDENT def test23_transform ( self ) : NEW_LINE INDENT " Testing ▁ ` transform ` ▁ method . " NEW_LINE if not gdal . HAS_GDAL : return NEW_LINE orig = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , 4326 ) NEW_LINE trans = GEOSGeometry ( ' POINT ▁ ( 992385.4472045 ▁ 481455.4944650 ) ' , 2774 ) NEW_LINE # ▁ Using ▁ a ▁ srid , ▁ a ▁ SpatialReference ▁ object , ▁ and ▁ a ▁ CoordTransform ▁ object ENDCOM # ▁ for ▁ transformations . ENDCOM t1 , t2 , t3 = orig . clone ( ) , orig . clone ( ) , orig . clone ( ) NEW_LINE t1 . transform ( trans . srid ) NEW_LINE t2 . transform ( gdal . SpatialReference ( ' EPSG : 2774' ) ) NEW_LINE ct = gdal . CoordTransform ( gdal . SpatialReference ( ' WGS84' ) , gdal . SpatialReference ( 2774 ) ) NEW_LINE t3 . transform ( ct ) NEW_LINE # ▁ Testing ▁ use ▁ of ▁ the ▁ ` clone ` ▁ keyword . ENDCOM k1 = orig . clone ( ) NEW_LINE k2 = k1 . transform ( trans . srid , clone = True ) NEW_LINE self . assertEqual ( k1 , orig ) NEW_LINE self . assertNotEqual ( k1 , k2 ) NEW_LINE prec = 3 NEW_LINE for p in ( t1 , t2 , t3 , k2 ) : NEW_LINE INDENT self . assertAlmostEqual ( trans . x , p . x , prec ) NEW_LINE self . assertAlmostEqual ( trans . y , p . y , prec ) NEW_LINE DEDENT DEDENT def test23_transform_noop ( self ) : NEW_LINE INDENT """ ▁ Testing ▁ ` transform ` ▁ method ▁ ( SRID ▁ match ) ▁ """ NEW_LINE # ▁ transform ( ) ▁ should ▁ no - op ▁ if ▁ source ▁ & ▁ dest ▁ SRIDs ▁ match , ENDCOM # ▁ regardless ▁ of ▁ whether ▁ GDAL ▁ is ▁ available . ENDCOM if gdal . HAS_GDAL : NEW_LINE INDENT g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , 4326 ) NEW_LINE gt = g . tuple NEW_LINE g . transform ( 4326 ) NEW_LINE self . assertEqual ( g . tuple , gt ) NEW_LINE self . assertEqual ( g . srid , 4326 ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , 4326 ) NEW_LINE g1 = g . transform ( 4326 , clone = True ) NEW_LINE self . assertEqual ( g1 . tuple , g . tuple ) NEW_LINE self . assertEqual ( g1 . srid , 4326 ) NEW_LINE self . assert_ ( g1 is not g , " Clone ▁ didn ' t ▁ happen " ) NEW_LINE DEDENT old_has_gdal = gdal . HAS_GDAL NEW_LINE try : NEW_LINE INDENT gdal . HAS_GDAL = False NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , 4326 ) NEW_LINE gt = g . tuple NEW_LINE g . transform ( 4326 ) NEW_LINE self . assertEqual ( g . tuple , gt ) NEW_LINE self . assertEqual ( g . srid , 4326 ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , 4326 ) NEW_LINE g1 = g . transform ( 4326 , clone = True ) NEW_LINE self . assertEqual ( g1 . tuple , g . tuple ) NEW_LINE self . assertEqual ( g1 . srid , 4326 ) NEW_LINE self . assert_ ( g1 is not g , " Clone ▁ didn ' t ▁ happen " ) NEW_LINE DEDENT finally : NEW_LINE INDENT gdal . HAS_GDAL = old_has_gdal NEW_LINE DEDENT DEDENT def test23_transform_nosrid ( self ) : NEW_LINE INDENT """ ▁ Testing ▁ ` transform ` ▁ method ▁ ( no ▁ SRID ) ▁ """ NEW_LINE # ▁ raise ▁ a ▁ warning ▁ if ▁ SRID ▁ < 0 / None ENDCOM import warnings NEW_LINE print " \n BEGIN ▁ - ▁ expecting ▁ Warnings ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE # ▁ test ▁ for ▁ do - nothing ▁ behaviour . ENDCOM try : NEW_LINE # ▁ Keeping ▁ line - noise ▁ down ▁ by ▁ only ▁ printing ▁ the ▁ relevant ENDCOM # ▁ warnings ▁ once . ENDCOM INDENT warnings . simplefilter ( ' once ' , UserWarning ) NEW_LINE warnings . simplefilter ( ' once ' , FutureWarning ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = None ) NEW_LINE g . transform ( 2774 ) NEW_LINE self . assertEqual ( g . tuple , ( - 104.609 , 38.255 ) ) NEW_LINE self . assertEqual ( g . srid , None ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = None ) NEW_LINE g1 = g . transform ( 2774 , clone = True ) NEW_LINE self . assert_ ( g1 is None ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = - 1 ) NEW_LINE g . transform ( 2774 ) NEW_LINE self . assertEqual ( g . tuple , ( - 104.609 , 38.255 ) ) NEW_LINE self . assertEqual ( g . srid , - 1 ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = - 1 ) NEW_LINE g1 = g . transform ( 2774 , clone = True ) NEW_LINE self . assert_ ( g1 is None ) NEW_LINE DEDENT finally : NEW_LINE INDENT warnings . simplefilter ( ' default ' , UserWarning ) NEW_LINE warnings . simplefilter ( ' default ' , FutureWarning ) NEW_LINE DEDENT print " \n END ▁ - ▁ expecting ▁ Warnings ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE # ▁ test ▁ warning ▁ is ▁ raised ENDCOM try : NEW_LINE INDENT warnings . simplefilter ( ' error ' , FutureWarning ) NEW_LINE warnings . simplefilter ( ' ignore ' , UserWarning ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = None ) NEW_LINE self . assertRaises ( FutureWarning , g . transform , 2774 ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = None ) NEW_LINE self . assertRaises ( FutureWarning , g . transform , 2774 , clone = True ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = - 1 ) NEW_LINE self . assertRaises ( FutureWarning , g . transform , 2774 ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , srid = - 1 ) NEW_LINE self . assertRaises ( FutureWarning , g . transform , 2774 , clone = True ) NEW_LINE DEDENT finally : NEW_LINE INDENT warnings . simplefilter ( ' default ' , FutureWarning ) NEW_LINE warnings . simplefilter ( ' default ' , UserWarning ) NEW_LINE DEDENT DEDENT def test23_transform_nogdal ( self ) : NEW_LINE INDENT """ ▁ Testing ▁ ` transform ` ▁ method ▁ ( GDAL ▁ not ▁ available ) ▁ """ NEW_LINE old_has_gdal = gdal . HAS_GDAL NEW_LINE try : NEW_LINE INDENT gdal . HAS_GDAL = False NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , 4326 ) NEW_LINE self . assertRaises ( GEOSException , g . transform , 2774 ) NEW_LINE g = GEOSGeometry ( ' POINT ▁ ( -104.609 ▁ 38.255 ) ' , 4326 ) NEW_LINE self . assertRaises ( GEOSException , g . transform , 2774 , clone = True ) NEW_LINE DEDENT finally : NEW_LINE INDENT gdal . HAS_GDAL = old_has_gdal NEW_LINE DEDENT DEDENT def test24_extent ( self ) : NEW_LINE INDENT " Testing ▁ ` extent ` ▁ method . " NEW_LINE # ▁ The ▁ xmin , ▁ ymin , ▁ xmax , ▁ ymax ▁ of ▁ the ▁ MultiPoint ▁ should ▁ be ▁ returned . ENDCOM mp = MultiPoint ( Point ( 5 , 23 ) , Point ( 0 , 0 ) , Point ( 10 , 50 ) ) NEW_LINE self . assertEqual ( ( 0.0 , 0.0 , 10.0 , 50.0 ) , mp . extent ) NEW_LINE pnt = Point ( 5.23 , 17.8 ) NEW_LINE # ▁ Extent ▁ of ▁ points ▁ is ▁ just ▁ the ▁ point ▁ itself ▁ repeated . ENDCOM self . assertEqual ( ( 5.23 , 17.8 , 5.23 , 17.8 ) , pnt . extent ) NEW_LINE # ▁ Testing ▁ on ▁ the ▁ ' real ▁ world ' ▁ Polygon . ENDCOM poly = fromstr ( self . geometries . polygons [ 3 ] . wkt ) NEW_LINE ring = poly . shell NEW_LINE x , y = ring . x , ring . y NEW_LINE xmin , ymin = min ( x ) , min ( y ) NEW_LINE xmax , ymax = max ( x ) , max ( y ) NEW_LINE self . assertEqual ( ( xmin , ymin , xmax , ymax ) , poly . extent ) NEW_LINE DEDENT def test25_pickle ( self ) : NEW_LINE INDENT " Testing ▁ pickling ▁ and ▁ unpickling ▁ support . " NEW_LINE # ▁ Using ▁ both ▁ pickle ▁ and ▁ cPickle ▁ - - ▁ just ▁ ' cause . ENDCOM import pickle , cPickle NEW_LINE # ▁ Creating ▁ a ▁ list ▁ of ▁ test ▁ geometries ▁ for ▁ pickling , ENDCOM # ▁ and ▁ setting ▁ the ▁ SRID ▁ on ▁ some ▁ of ▁ them . ENDCOM def get_geoms ( lst , srid = None ) : NEW_LINE INDENT return [ GEOSGeometry ( tg . wkt , srid ) for tg in lst ] NEW_LINE DEDENT tgeoms = get_geoms ( self . geometries . points ) NEW_LINE tgeoms . extend ( get_geoms ( self . geometries . multilinestrings , 4326 ) ) NEW_LINE tgeoms . extend ( get_geoms ( self . geometries . polygons , 3084 ) ) NEW_LINE tgeoms . extend ( get_geoms ( self . geometries . multipolygons , 900913 ) ) NEW_LINE # ▁ The ▁ SRID ▁ won ' t ▁ be ▁ exported ▁ in ▁ GEOS ▁ 3.0 ▁ release ▁ candidates . ENDCOM no_srid = self . null_srid == - 1 NEW_LINE for geom in tgeoms : NEW_LINE INDENT s1 , s2 = cPickle . dumps ( geom ) , pickle . dumps ( geom ) NEW_LINE g1 , g2 = cPickle . loads ( s1 ) , pickle . loads ( s2 ) NEW_LINE for tmpg in ( g1 , g2 ) : NEW_LINE INDENT self . assertEqual ( geom , tmpg ) NEW_LINE if not no_srid : self . assertEqual ( geom . srid , tmpg . srid ) NEW_LINE DEDENT DEDENT DEDENT def test26_prepared ( self ) : NEW_LINE INDENT " Testing ▁ PreparedGeometry ▁ support . " NEW_LINE if not GEOS_PREPARE : return NEW_LINE # ▁ Creating ▁ a ▁ simple ▁ multipolygon ▁ and ▁ getting ▁ a ▁ prepared ▁ version . ENDCOM mpoly = GEOSGeometry ( ' MULTIPOLYGON ( ( ( 0 ▁ 0,0 ▁ 5,5 ▁ 5,5 ▁ 0,0 ▁ 0 ) ) , ( (5 ▁ 5,5 ▁ 10,10 ▁ 10,10 ▁ 5,5 ▁ 5 ) ) ) ' ) NEW_LINE prep = mpoly . prepared NEW_LINE # ▁ A ▁ set ▁ of ▁ test ▁ points . ENDCOM pnts = [ Point ( 5 , 5 ) , Point ( 7.5 , 7.5 ) , Point ( 2.5 , 7.5 ) ] NEW_LINE covers = [ True , True , False ] # ▁ No ▁ ` covers ` ▁ op ▁ for ▁ regular ▁ GEOS ▁ geoms . ENDCOM NEW_LINE for pnt , c in zip ( pnts , covers ) : NEW_LINE # ▁ Results ▁ should ▁ be ▁ the ▁ same ▁ ( but ▁ faster ) ENDCOM INDENT self . assertEqual ( mpoly . contains ( pnt ) , prep . contains ( pnt ) ) NEW_LINE self . assertEqual ( mpoly . intersects ( pnt ) , prep . intersects ( pnt ) ) NEW_LINE self . assertEqual ( c , prep . covers ( pnt ) ) NEW_LINE DEDENT DEDENT def test26_line_merge ( self ) : NEW_LINE INDENT " Testing ▁ line ▁ merge ▁ support " NEW_LINE ref_geoms = ( fromstr ( ' LINESTRING ( 1 ▁ 1 , ▁ 1 ▁ 1 , ▁ 3 ▁ 3 ) ' ) , fromstr ( ' MULTILINESTRING ( (1 ▁ 1 , ▁ 3 ▁ 3 ) , ▁ ( 3 ▁ 3 , ▁ 4 ▁ 2 ) ) ' ) , ) NEW_LINE ref_merged = ( fromstr ( ' LINESTRING ( 1 ▁ 1 , ▁ 3 ▁ 3 ) ' ) , fromstr ( ' LINESTRING ▁ ( 1 ▁ 1 , ▁ 3 ▁ 3 , ▁ 4 ▁ 2 ) ' ) , ) NEW_LINE for geom , merged in zip ( ref_geoms , ref_merged ) : NEW_LINE INDENT self . assertEqual ( merged , geom . merged ) NEW_LINE DEDENT DEDENT def test27_valid_reason ( self ) : NEW_LINE INDENT " Testing ▁ IsValidReason ▁ support " NEW_LINE # ▁ Skipping ▁ tests ▁ if ▁ GEOS ▁ < ▁ v3.1 . ENDCOM if not GEOS_PREPARE : return NEW_LINE g = GEOSGeometry ( " POINT ( 0 ▁ 0 ) " ) NEW_LINE self . assert_ ( g . valid ) NEW_LINE self . assert_ ( isinstance ( g . valid_reason , basestring ) ) NEW_LINE self . assertEqual ( g . valid_reason , " Valid ▁ Geometry " ) NEW_LINE print " \n BEGIN ▁ - ▁ expecting ▁ GEOS _ NOTICE ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE g = GEOSGeometry ( " LINESTRING ( 0 ▁ 0 , ▁ 0 ▁ 0 ) " ) NEW_LINE self . assert_ ( not g . valid ) NEW_LINE self . assert_ ( isinstance ( g . valid_reason , basestring ) ) NEW_LINE self . assert_ ( g . valid_reason . startswith ( " Too ▁ few ▁ points ▁ in ▁ geometry ▁ component " ) ) NEW_LINE print " \n END ▁ - ▁ expecting ▁ GEOS _ NOTICE ; ▁ safe ▁ to ▁ ignore . \n " NEW_LINE DEDENT DEDENT def suite ( ) : NEW_LINE INDENT s = unittest . TestSuite ( ) NEW_LINE s . addTest ( unittest . makeSuite ( GEOSTest ) ) NEW_LINE return s NEW_LINE DEDENT def run ( verbosity = 2 ) : NEW_LINE INDENT unittest . TextTestRunner ( verbosity = verbosity ) . run ( suite ( ) ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="doublebits/osf.io/tree/master/admin_tests/factories.py"> import factory NEW_LINE from admin . common_auth . models import MyUser NEW_LINE class UserFactory ( factory . Factory ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT model = MyUser NEW_LINE DEDENT id = 123 NEW_LINE email = ' cello @ email . org ' NEW_LINE first_name = ' Yo - yo ' NEW_LINE last_name = ' Ma ' NEW_LINE osf_id = ' abc12' NEW_LINE @ classmethod NEW_LINE def is_in_group ( cls , value ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="tacaswell/datamuxer/tree/master/datamuxer.py"> # ▁ Copyright ▁ ( c ) ▁ 2014 , ▁ Brookhaven ▁ Science ▁ Associates , ▁ Brookhaven ▁ # ENDCOM # ▁ National ▁ Laboratory . ▁ All ▁ rights ▁ reserved . ▁ # ENDCOM # ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without ▁ # ENDCOM # ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ # ENDCOM # ▁ are ▁ met : ▁ # ENDCOM # ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright ▁ # ENDCOM # ▁ notice , ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . ▁ # ENDCOM # ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright ▁ # ENDCOM # ▁ notice ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ # ENDCOM # ▁ the ▁ documentation ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ # ENDCOM # ▁ distribution . ▁ # ENDCOM # ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ the ▁ Brookhaven ▁ Science ▁ Associates , ▁ Brookhaven ▁ # ENDCOM # ▁ National ▁ Laboratory ▁ nor ▁ the ▁ names ▁ of ▁ its ▁ contributors ▁ may ▁ be ▁ used ▁ # ENDCOM # ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from ▁ this ▁ software ▁ without ▁ # ENDCOM # ▁ specific ▁ prior ▁ written ▁ permission . ▁ # ENDCOM # ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS ▁ # ENDCOM # ▁ " AS ▁ IS " ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ # ENDCOM # ▁ LIMITED ▁ TO , ▁ THE ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ # ENDCOM # ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ # ENDCOM # ▁ COPYRIGHT ▁ HOLDER ▁ OR ▁ CONTRIBUTORS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ # ENDCOM # ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ▁ CONSEQUENTIAL ▁ DAMAGES ▁ # ENDCOM # ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ # ENDCOM # ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ▁ INTERRUPTION ) ▁ # ENDCOM # ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ CONTRACT , ▁ # ENDCOM # ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OTHERWISE ) ▁ ARISING ▁ # ENDCOM # ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ▁ # ENDCOM # ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ▁ # ENDCOM from __future__ import ( absolute_import , division , print_function , unicode_literals ) NEW_LINE import six NEW_LINE from collections import namedtuple , deque NEW_LINE import logging NEW_LINE import pandas as pd NEW_LINE import tzlocal NEW_LINE import numpy as np NEW_LINE from scipy . interpolate import interp1d NEW_LINE import pandas . core . groupby # ▁ to ▁ get ▁ custom ▁ exception ENDCOM NEW_LINE logger = logging . getLogger ( __name__ ) NEW_LINE __all__ = [ ' DataMuxer ' , ' dataframe _ to _ dict ' ] NEW_LINE TZ = str ( tzlocal . get_localzone ( ) ) NEW_LINE class BinningError ( Exception ) : NEW_LINE INDENT """ STRNEWLINE ▁ An ▁ exception ▁ to ▁ raise ▁ if ▁ there ▁ are ▁ insufficient ▁ sampling ▁ rules ▁ to STRNEWLINE ▁ upsampling ▁ or ▁ downsample ▁ a ▁ data ▁ column ▁ into ▁ specified ▁ bins . STRNEWLINE ▁ """ NEW_LINE pass NEW_LINE DEDENT class BadDownsamplerError ( Exception ) : NEW_LINE INDENT """ STRNEWLINE ▁ An ▁ exception ▁ to ▁ raise ▁ if ▁ a ▁ downsampler ▁ produces ▁ unexpected ▁ output . STRNEWLINE ▁ """ NEW_LINE pass NEW_LINE DEDENT class ColSpec ( namedtuple ( ' ColSpec ' , [ ' name ' , ' ndim ' , ' shape ' , ' upsample ' , ' downsample ' ] ) ) : NEW_LINE INDENT """ STRNEWLINE ▁ Named - tuple ▁ sub - class ▁ to ▁ validate ▁ the ▁ column ▁ specifications ▁ for ▁ the STRNEWLINE ▁ DataMuxer STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ name ▁ : ▁ hashable STRNEWLINE ▁ ndim ▁ : ▁ uint STRNEWLINE ▁ Dimensionality ▁ of ▁ the ▁ data ▁ stored ▁ in ▁ the ▁ column STRNEWLINE ▁ shape ▁ : ▁ tuple ▁ or ▁ None STRNEWLINE ▁ like ▁ ndarray . shape , ▁ where ▁ 0 ▁ or ▁ None ▁ are ▁ scalar STRNEWLINE ▁ upsample ▁ : ▁ { None , ▁ ' linear ' , ▁ ' nearest ' , ▁ ' zero ' , ▁ ' slinear ' , ▁ ' quadratic ' , ▁ ' cubic ' , ▁ ' ffill ' , ▁ ' bfill ' } STRNEWLINE ▁ None ▁ means ▁ that ▁ each ▁ time ▁ bin ▁ must ▁ have ▁ at ▁ least ▁ one ▁ value . STRNEWLINE ▁ The ▁ names ▁ refer ▁ to ▁ kinds ▁ of ▁ scipy . interpolator . ▁ See ▁ documentation STRNEWLINE ▁ link ▁ below . STRNEWLINE ▁ downsample ▁ : ▁ None ▁ or ▁ a ▁ function STRNEWLINE ▁ None ▁ if ▁ the ▁ data ▁ cannot ▁ be ▁ downsampled ▁ ( reduced ) . ▁ Otherwise , STRNEWLINE ▁ any ▁ callable ▁ that ▁ reduces ▁ multiple ▁ data ▁ points ▁ ( of ▁ whatever ▁ dimension ) STRNEWLINE ▁ to ▁ a ▁ single ▁ data ▁ point . STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ http : / / docs . scipy . org / doc / scipy / reference / generated / scipy . interpolate . interp1d . html STRNEWLINE ▁ """ NEW_LINE # ▁ These ▁ reflect ▁ the ▁ ' method ' ▁ argument ▁ of ▁ pandas . DataFrame . fillna ENDCOM upsampling_methods = { ' None ' , ' linear ' , ' nearest ' , ' zero ' , ' slinear ' , ' quadratic ' , ' cubic ' , ' ffill ' , ' bfill ' } NEW_LINE downsampling_methods = { ' None ' , ' last ' , ' first ' , ' median ' , ' mean ' , ' sum ' , ' min ' , ' max ' } NEW_LINE _downsample_mapping = { ' last ' : lambda x : x [ - 1 ] , ' first ' : lambda x : x [ 0 ] , # ▁ new ▁ in ▁ np ▁ 1.9 ENDCOM ' median ' : lambda x : np . median ( x , 0 ) , ' mean ' : lambda x : np . mean ( x , 0 ) , ' sum ' : lambda x : np . sum ( x , 0 ) , ' min ' : lambda x : np . min ( x , 0 ) , ' max ' : lambda x : np . max ( x , 0 ) } NEW_LINE __slots__ = ( ) NEW_LINE def __new__ ( cls , name , ndim , shape , upsample , downsample ) : NEW_LINE # ▁ Validations ENDCOM INDENT upsample = _validate_upsample ( upsample ) NEW_LINE downsample = _validate_downsample ( downsample ) NEW_LINE if int ( ndim ) < 0 : NEW_LINE INDENT raise ValueError ( " ndim ▁ must ▁ be ▁ positive ▁ not ▁ { } " . format ( ndim ) ) NEW_LINE DEDENT if shape is not None : NEW_LINE INDENT shape = tuple ( shape ) NEW_LINE DEDENT return super ( ColSpec , cls ) . __new__ ( cls , name , int ( ndim ) , shape , upsample , downsample ) NEW_LINE DEDENT DEDENT def _validate_upsample ( input ) : NEW_LINE # ▁ TODO ▁ The ▁ upsampling ▁ method ▁ could ▁ be ▁ any ▁ callable . ENDCOM INDENT if input is None or input == ' None ' : NEW_LINE INDENT return ' None ' NEW_LINE DEDENT if not ( input in ColSpec . upsampling_methods ) : NEW_LINE INDENT raise ValueError ( " { } ▁ is ▁ not ▁ a ▁ valid ▁ upsampling ▁ method . ▁ It ▁ " " must ▁ be ▁ one ▁ of ▁ { } " . format ( input , ColSpec . upsampling_methods ) ) NEW_LINE DEDENT return input . lower ( ) NEW_LINE DEDENT def _validate_downsample ( input ) : NEW_LINE # ▁ TODO ▁ The ▁ downsampling ▁ methods ▁ could ▁ have ▁ string ▁ aliases ▁ like ▁ ' mean ' . ENDCOM INDENT if ( input is not None ) and ( not ( callable ( input ) or input in ColSpec . downsampling_methods ) ) : NEW_LINE INDENT raise ValueError ( " The ▁ downsampling ▁ method ▁ must ▁ be ▁ a ▁ callable , ▁ None , ▁ " " or ▁ one ▁ of ▁ { } . " . format ( ColSpec . downsampling_methods ) ) NEW_LINE DEDENT if input is None : NEW_LINE INDENT return ' None ' NEW_LINE DEDENT return input NEW_LINE DEDENT class DataMuxer ( object ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ class ▁ provides ▁ a ▁ wrapper ▁ layer ▁ of ▁ signals ▁ and ▁ slots STRNEWLINE ▁ around ▁ a ▁ pandas ▁ DataFrame ▁ to ▁ make ▁ plugging ▁ stuff ▁ in ▁ for ▁ live STRNEWLINE ▁ view ▁ easier . STRNEWLINE STRNEWLINE ▁ The ▁ data ▁ collection / event ▁ model ▁ being ▁ used ▁ is ▁ all ▁ measurements STRNEWLINE ▁ ( that ▁ is ▁ values ▁ that ▁ come ▁ off ▁ of ▁ the ▁ hardware ) ▁ are ▁ time ▁ stamped STRNEWLINE ▁ to ▁ ring ▁ time . STRNEWLINE STRNEWLINE ▁ The ▁ language ▁ being ▁ used ▁ through ▁ out ▁ is ▁ that ▁ of ▁ pandas ▁ data ▁ frames . STRNEWLINE STRNEWLINE ▁ The ▁ data ▁ model ▁ is ▁ that ▁ of ▁ a ▁ sparse ▁ table ▁ keyed ▁ on ▁ time ▁ stamps ▁ which STRNEWLINE ▁ is ▁ ' densified ' ▁ on ▁ demand ▁ by ▁ propagating ▁ measurements ▁ forwards . ▁ Not STRNEWLINE ▁ all ▁ measurements ▁ ( ex ▁ images ) ▁ can ▁ be ▁ filled . ▁ This ▁ behavior ▁ is ▁ controlled STRNEWLINE ▁ by ▁ the ▁ ` col _ info ` ▁ tuple . STRNEWLINE STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ events ▁ : ▁ list STRNEWLINE ▁ list ▁ of ▁ Events ▁ ( any ▁ object ▁ with ▁ the ▁ expected ▁ attributes ▁ will ▁ do ) STRNEWLINE ▁ """ NEW_LINE class Planner ( object ) : NEW_LINE INDENT def __init__ ( self , dm ) : NEW_LINE INDENT self . dm = dm NEW_LINE DEDENT def determine_upsample ( self , interpolation = None , use_cols = None ) : NEW_LINE INDENT " Resolve ▁ ( and ▁ if ▁ necessary ▁ validate ) ▁ upsampling ▁ rules . " NEW_LINE if interpolation is None : NEW_LINE INDENT interpolation = dict ( ) NEW_LINE DEDENT if use_cols is None : NEW_LINE INDENT use_cols = self . dm . columns NEW_LINE DEDENT rules = dict ( ) NEW_LINE for name in use_cols : NEW_LINE INDENT col_info = self . dm . col_info [ name ] NEW_LINE rule = _validate_upsample ( interpolation . get ( name , col_info . upsample ) ) NEW_LINE rule = _normalize_string_none ( rule ) NEW_LINE if ( rule is not None ) and ( col_info . ndim > 0 ) : NEW_LINE INDENT raise NotImplementedError ( " Only ▁ scalar ▁ data ▁ can ▁ be ▁ upsampled . ▁ " " The ▁ { 0 } - dimensional ▁ source ▁ { 1 } ▁ was ▁ given ▁ the ▁ " " upsampling ▁ rule ▁ { 2 } . " . format ( col_info . ndim , name , rule ) ) NEW_LINE DEDENT rules [ name ] = rule NEW_LINE DEDENT return rules NEW_LINE DEDENT def determine_downsample ( self , agg = None , use_cols = None ) : NEW_LINE INDENT " Resolve ▁ ( and ▁ if ▁ necessary ▁ validate ) ▁ sampling ▁ rules . " NEW_LINE if agg is None : NEW_LINE INDENT agg = dict ( ) NEW_LINE DEDENT if use_cols is None : NEW_LINE INDENT use_cols = self . dm . columns NEW_LINE DEDENT rules = dict ( ) NEW_LINE for name in use_cols : NEW_LINE INDENT col_info = self . dm . col_info [ name ] NEW_LINE rule = _validate_downsample ( agg . get ( name , col_info . downsample ) ) NEW_LINE rule = _normalize_string_none ( rule ) NEW_LINE rules [ name ] = rule NEW_LINE DEDENT return rules NEW_LINE DEDENT def bin_by_edges ( self , bin_edges , bin_anchors , interpolation = None , agg = None , use_cols = None ) : NEW_LINE INDENT """ Explain ▁ operation ▁ of ▁ DataMuxer . bin _ by _ edges STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ bin _ edges ▁ : ▁ list STRNEWLINE ▁ list ▁ of ▁ two - element ▁ items ▁ like ▁ [ ( t1 , ▁ t2 ) , ▁ ( t3 , ▁ t4 ) , ▁ . . . ] STRNEWLINE ▁ bin _ anchors ▁ : ▁ list STRNEWLINE ▁ These ▁ are ▁ time ▁ points ▁ where ▁ interpolated ▁ values ▁ will ▁ be STRNEWLINE ▁ evaluated . ▁ Bin ▁ centers ▁ are ▁ usually ▁ a ▁ good ▁ choice . STRNEWLINE ▁ interpolation ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ interpolation ▁ ( upsampling ) ▁ behavior ▁ of ▁ any STRNEWLINE ▁ data ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto STRNEWLINE ▁ one ▁ of ▁ the ▁ following ▁ interpolation ▁ methods . STRNEWLINE STRNEWLINE ▁ { None , ▁ ' linear ' , ▁ ' nearest ' , ▁ ' zero ' , ▁ ' slinear ' , ▁ ' quadratic ' , STRNEWLINE ▁ ' cubic ' , ▁ ' ffill ' , ▁ ' bfill ' } STRNEWLINE STRNEWLINE ▁ None ▁ means ▁ that ▁ each ▁ time ▁ bin ▁ must ▁ have ▁ at ▁ least ▁ one ▁ value . STRNEWLINE ▁ See ▁ scipy . interpolator ▁ for ▁ more ▁ on ▁ the ▁ other ▁ methods . STRNEWLINE ▁ agg ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ reduction ▁ ( downsampling ) ▁ behavior ▁ of ▁ any STRNEWLINE ▁ data ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto STRNEWLINE ▁ any ▁ callable ▁ that ▁ reduces ▁ multiple ▁ data ▁ points ▁ ( of ▁ whatever STRNEWLINE ▁ dimension ) ▁ to ▁ a ▁ single ▁ data ▁ point . STRNEWLINE ▁ use _ cols ▁ : ▁ list , ▁ optional STRNEWLINE ▁ List ▁ of ▁ columns ▁ to ▁ include ▁ in ▁ binning ; ▁ use ▁ all ▁ columns ▁ by STRNEWLINE ▁ default . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ df ▁ : ▁ pandas . DataFrame STRNEWLINE ▁ table ▁ giving ▁ upsample ▁ and ▁ downsample ▁ rules ▁ for ▁ each ▁ data ▁ column STRNEWLINE ▁ and ▁ indicating ▁ whether ▁ those ▁ rules ▁ are ▁ applicable STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ http : / / docs . scipy . org / doc / scipy / reference / generated / scipy . interpolate . interp1d . html STRNEWLINE ▁ """ NEW_LINE bin_anchors , binning = self . dm . _bin_by_edges ( bin_anchors , bin_edges ) NEW_LINE # ▁ TODO ▁ Cache ▁ the ▁ grouping ▁ for ▁ reuse ▁ by ▁ resample . ENDCOM grouped = self . dm . _dataframe . groupby ( binning ) NEW_LINE counts = grouped . count ( ) NEW_LINE df = pd . DataFrame . from_dict ( _is_resampling_applicable ( counts ) ) NEW_LINE df [ ' upsample ' ] = self . determine_upsample ( interpolation , use_cols ) NEW_LINE df [ ' downsample ' ] = self . determine_downsample ( agg , use_cols ) NEW_LINE return df NEW_LINE DEDENT def bin_on ( self , source_name , interpolation = None , agg = None , use_cols = None ) : NEW_LINE INDENT """ Explain ▁ operation ▁ of ▁ DataMuxer . bin _ on . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ source _ name ▁ : ▁ string STRNEWLINE ▁ interpolation ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ interpolation ▁ ( upsampling ) ▁ behavior ▁ of ▁ any STRNEWLINE ▁ data ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto STRNEWLINE ▁ one ▁ of ▁ the ▁ following ▁ interpolation ▁ methods . STRNEWLINE STRNEWLINE ▁ { None , ▁ ' linear ' , ▁ ' nearest ' , ▁ ' zero ' , ▁ ' slinear ' , ▁ ' quadratic ' , STRNEWLINE ▁ ' cubic ' } STRNEWLINE STRNEWLINE ▁ None ▁ means ▁ that ▁ each ▁ time ▁ bin ▁ must ▁ have ▁ at ▁ least ▁ one ▁ value . STRNEWLINE ▁ See ▁ scipy . interpolator ▁ for ▁ more ▁ on ▁ the ▁ other ▁ methods . STRNEWLINE ▁ agg ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ reduction ▁ ( downsampling ) ▁ behavior ▁ of ▁ any STRNEWLINE ▁ data ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto STRNEWLINE ▁ any ▁ callable ▁ that ▁ reduces ▁ multiple ▁ data ▁ points ▁ ( of ▁ whatever STRNEWLINE ▁ dimension ) ▁ to ▁ a ▁ single ▁ data ▁ point . STRNEWLINE ▁ use _ cols ▁ : ▁ list , ▁ optional STRNEWLINE ▁ List ▁ of ▁ columns ▁ to ▁ include ▁ in ▁ binning ; ▁ use ▁ all ▁ columns ▁ by STRNEWLINE ▁ default . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ df ▁ : ▁ pandas . DataFrame STRNEWLINE ▁ table ▁ giving ▁ upsample ▁ and ▁ downsample ▁ rules ▁ for ▁ each ▁ data ▁ column STRNEWLINE ▁ and ▁ indicating ▁ whether ▁ those ▁ rules ▁ are ▁ applicable STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ http : / / docs . scipy . org / doc / scipy / reference / generated / scipy . interpolate . interp1d . html STRNEWLINE ▁ """ NEW_LINE centers , bin_edges = self . dm . _bin_on ( source_name ) NEW_LINE bin_anchors , binning = self . dm . _bin_by_edges ( centers , bin_edges ) NEW_LINE # ▁ TODO ▁ Cache ▁ the ▁ grouping ▁ for ▁ reuse ▁ by ▁ resample . ENDCOM grouped = self . dm . _dataframe . groupby ( binning ) NEW_LINE counts = grouped . count ( ) NEW_LINE df = pd . DataFrame . from_dict ( _is_resampling_applicable ( counts ) ) NEW_LINE df [ ' upsample ' ] = self . determine_upsample ( interpolation , use_cols ) NEW_LINE df [ ' downsample ' ] = self . determine_downsample ( agg , use_cols ) NEW_LINE return df NEW_LINE DEDENT DEDENT default_upsample = None NEW_LINE default_downsample = None NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . sources = { } NEW_LINE self . col_info = { } NEW_LINE self . col_info [ ' time ' ] = ColSpec ( ' time ' , 0 , [ ] , ' linear ' , ' mean ' ) NEW_LINE self . _data = deque ( ) NEW_LINE self . _time = deque ( ) NEW_LINE self . _timestamps = deque ( ) NEW_LINE self . _timestamps_as_data = set ( ) NEW_LINE self . _known_events = set ( ) NEW_LINE self . _known_descriptors = set ( ) NEW_LINE self . _stale = True NEW_LINE self . plan = self . Planner ( self ) NEW_LINE self . convert_times = True NEW_LINE self . _reference_time = None NEW_LINE DEDENT @ property NEW_LINE def reference_time ( self ) : NEW_LINE INDENT return self . _reference_time NEW_LINE DEDENT @ reference_time . setter NEW_LINE def reference_time ( self , val ) : NEW_LINE INDENT self . _reference_time = pd . Timestamp ( val , unit = ' s ' ) NEW_LINE DEDENT @ property NEW_LINE def columns ( self ) : NEW_LINE INDENT " The ▁ columns ▁ of ▁ DataFrames ▁ returned ▁ by ▁ methods ▁ that ▁ return ▁ DataFrames . " NEW_LINE return set ( self . sources ) | self . _time_columns NEW_LINE DEDENT @ property NEW_LINE def _time_columns ( self ) : NEW_LINE INDENT ts_names = [ name + ' _ timestamp ' for name in self . _timestamps_as_data ] NEW_LINE return { ' time ' } | set ( ts_names ) NEW_LINE DEDENT @ classmethod NEW_LINE def from_events ( cls , events , verbose = False ) : NEW_LINE INDENT """ STRNEWLINE ▁ Create ▁ a ▁ DataMuxer ▁ from ▁ a ▁ list ▁ of ▁ Events . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ events ▁ : ▁ list STRNEWLINE ▁ list ▁ of ▁ Events ▁ ( any ▁ objects ▁ with ▁ the ▁ expected ▁ attributes ▁ will ▁ do ) STRNEWLINE ▁ """ NEW_LINE instance = cls ( ) NEW_LINE instance . append_events ( events , verbose ) NEW_LINE return instance NEW_LINE DEDENT def append_events ( self , events , verbose = False ) : NEW_LINE INDENT """ Add ▁ a ▁ list ▁ of ▁ events ▁ to ▁ the ▁ DataMuxer . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ events ▁ : ▁ list STRNEWLINE ▁ list ▁ of ▁ Events ▁ ( any ▁ objects ▁ with ▁ the ▁ expected ▁ attributes ▁ will ▁ do ) STRNEWLINE ▁ """ NEW_LINE for idx , event in enumerate ( events ) : NEW_LINE INDENT if verbose and idx % 25 == 0 : NEW_LINE INDENT print ( ' loading ▁ event ▁ % s ' % idx ) , NEW_LINE DEDENT self . append_event ( event ) NEW_LINE DEDENT DEDENT def append_event ( self , event ) : NEW_LINE INDENT """ Add ▁ an ▁ event ▁ to ▁ the ▁ DataMuxer . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ event ▁ : ▁ Event STRNEWLINE ▁ Event ▁ Document ▁ or ▁ any ▁ object ▁ with ▁ the ▁ expected ▁ attributes STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ is _ new ▁ : ▁ bool STRNEWLINE ▁ True ▁ if ▁ event ▁ was ▁ added , ▁ False ▁ is ▁ it ▁ has ▁ already ▁ been ▁ added STRNEWLINE ▁ """ NEW_LINE if event . uid in self . _known_events : NEW_LINE INDENT return False NEW_LINE DEDENT self . _known_events . add ( event . uid ) NEW_LINE self . _stale = True NEW_LINE if event . descriptor . uid not in self . _known_descriptors : NEW_LINE INDENT self . _process_new_descriptor ( event . descriptor ) NEW_LINE # ▁ Both ▁ scalar ▁ and ▁ nonscalar ▁ data ▁ will ▁ get ▁ stored ▁ in ▁ the ▁ DataFrame . ENDCOM # ▁ This ▁ may ▁ be ▁ optimized ▁ later , ▁ but ▁ it ▁ might ▁ not ▁ actually ▁ help ▁ much . ENDCOM DEDENT self . _data . append ( { name : data for name , data in six . iteritems ( event . data ) } ) NEW_LINE self . _timestamps . append ( { name : ts for name , ts in six . iteritems ( event . timestamps ) } ) NEW_LINE self . _time . append ( event . time ) NEW_LINE return True NEW_LINE DEDENT def _process_new_descriptor ( self , descriptor ) : NEW_LINE INDENT " Build ▁ a ▁ ColSpec ▁ and ▁ update ▁ state . " NEW_LINE for name , description in six . iteritems ( descriptor . data_keys ) : NEW_LINE # ▁ If ▁ we ▁ already ▁ have ▁ this ▁ source ▁ name , ▁ the ▁ unique ▁ source ENDCOM # ▁ identifiers ▁ must ▁ match . ▁ Ambiguous ▁ names ▁ are ▁ not ▁ allowed . ENDCOM INDENT if name in self . sources : NEW_LINE INDENT if self . sources [ name ] != description [ ' source ' ] : NEW_LINE INDENT raise ValueError ( " In ▁ a ▁ previously ▁ loaded ▁ descriptor , ▁ " " ' {0 } ' ▁ refers ▁ to ▁ { 1 } ▁ but ▁ in ▁ Event ▁ " " Descriptor ▁ { 2 } ▁ it ▁ refers ▁ to ▁ { 3 } . " . format ( name , self . sources [ name ] , descriptor . uid , description [ ' source ' ] ) ) NEW_LINE DEDENT if name == ' time ' : NEW_LINE # ▁ We ▁ can ▁ argue ▁ later ▁ about ▁ how ▁ best ▁ to ▁ handle ▁ this ▁ corner ENDCOM # ▁ case , ▁ but ▁ anything ▁ is ▁ better ▁ than ▁ silently ▁ mislabeling ENDCOM # ▁ data . ENDCOM INDENT raise ValueError ( " The ▁ name ▁ ' time ' ▁ is ▁ reserved ▁ and ▁ cannot ▁ " " be ▁ used ▁ as ▁ an ▁ alias . " ) NEW_LINE # ▁ If ▁ it ▁ is ▁ a ▁ new ▁ name , ▁ determine ▁ a ▁ ColSpec . ENDCOM DEDENT DEDENT else : NEW_LINE INDENT self . sources [ name ] = description [ ' source ' ] NEW_LINE if ' external ' in description and ' shape ' in description : NEW_LINE INDENT shape = description [ ' shape ' ] NEW_LINE ndim = len ( shape ) NEW_LINE DEDENT else : NEW_LINE # ▁ External ▁ data ▁ can ▁ be ▁ scalar . ▁ Nonscalar ▁ data ▁ must ENDCOM # ▁ have ▁ a ▁ specified ▁ shape . ▁ Thus , ▁ if ▁ no ▁ shape ▁ is ▁ given , ENDCOM # ▁ assume ▁ scalar . ENDCOM INDENT shape = None NEW_LINE ndim = 0 NEW_LINE DEDENT upsample = self . default_upsample NEW_LINE if ndim > 0 : NEW_LINE INDENT upsample = None NEW_LINE DEDENT col_info = ColSpec ( name , ndim , shape , upsample , self . default_downsample ) # ▁ defaults ENDCOM NEW_LINE # ▁ TODO ▁ Look ▁ up ▁ source - specific ▁ default ▁ in ▁ a ▁ config ▁ file ENDCOM # ▁ or ▁ some ▁ other ▁ source ▁ of ▁ reference ▁ data . ENDCOM self . col_info [ name ] = col_info NEW_LINE DEDENT DEDENT self . _known_descriptors . add ( descriptor . uid ) NEW_LINE DEDENT @ property NEW_LINE def _dataframe ( self ) : NEW_LINE INDENT " See ▁ also ▁ to _ sparse _ dataframe , ▁ the ▁ public ▁ version ▁ of ▁ this . " NEW_LINE # ▁ Rebuild ▁ the ▁ DataFrame ▁ if ▁ more ▁ data ▁ has ▁ been ▁ added . ENDCOM if self . _stale : NEW_LINE INDENT df = pd . DataFrame ( list ( self . _data ) ) NEW_LINE df [ ' time ' ] = list ( self . _time ) NEW_LINE if self . _timestamps_as_data : NEW_LINE # ▁ Only ▁ build ▁ this ▁ if ▁ we ▁ need ▁ it . ENDCOM # ▁ TODO : ▁ We ▁ shouldn ' t ▁ have ▁ to ▁ build ENDCOM # ▁ the ▁ whole ▁ thing , ▁ but ▁ there ▁ is ▁ already ▁ a ▁ lot ▁ of ▁ trickiness ENDCOM # ▁ here ▁ so ▁ we ' ll ▁ worry ▁ about ▁ optimization ▁ later . ENDCOM INDENT timestamps = pd . DataFrame ( list ( self . _timestamps ) ) NEW_LINE DEDENT for source_name in self . _timestamps_as_data : NEW_LINE INDENT col_name = _timestamp_col_name ( source_name ) NEW_LINE df [ col_name ] = timestamps [ source_name ] NEW_LINE logger . debug ( " Including ▁ % s ▁ timestamps ▁ as ▁ data " , source_name ) NEW_LINE DEDENT self . _df = df . sort ( ' time ' ) . reset_index ( drop = True ) NEW_LINE self . _stale = False NEW_LINE DEDENT return self . _df NEW_LINE DEDENT def to_sparse_dataframe ( self , include_all_timestamps = False ) : NEW_LINE INDENT """ Obtain ▁ all ▁ measurements ▁ in ▁ a ▁ DataFrame , ▁ one ▁ row ▁ per ▁ Event ▁ time . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ include _ all _ timestamps ▁ : ▁ bool STRNEWLINE ▁ The ▁ result ▁ will ▁ always ▁ contain ▁ a ▁ ' time ' ▁ column ▁ but , ▁ by ▁ default , STRNEWLINE ▁ not ▁ timestamps ▁ for ▁ individual ▁ data ▁ sources ▁ like ▁ ' motor _ timestamp ' . STRNEWLINE ▁ Set ▁ this ▁ to ▁ True ▁ to ▁ export ▁ timestamp ▁ columns ▁ for ▁ each ▁ data ▁ column STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ df ▁ : ▁ pandas . DataFrame STRNEWLINE ▁ """ NEW_LINE if include_all_timestamps : NEW_LINE INDENT raise NotImplementedError ( " TODO " ) NEW_LINE DEDENT result = self . _dataframe . copy ( ) NEW_LINE for col_name in self . _time_columns : NEW_LINE INDENT result [ col_name ] = self . _maybe_convert_times ( result [ col_name ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT def _maybe_convert_times ( self , data ) : NEW_LINE INDENT if self . convert_times : NEW_LINE INDENT t = pd . to_datetime ( data , unit = ' s ' , utc = True ) . dt . tz_localize ( TZ ) NEW_LINE if self . reference_time is None : NEW_LINE INDENT return t NEW_LINE DEDENT else : NEW_LINE INDENT return t - self . reference_time NEW_LINE DEDENT DEDENT return data # ▁ no - op ENDCOM NEW_LINE DEDENT def include_timestamp_data ( self , source_name ) : NEW_LINE INDENT """ Add ▁ the ▁ exact ▁ timing ▁ of ▁ a ▁ data ▁ source ▁ as ▁ a ▁ data ▁ column . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ source _ name ▁ : ▁ string STRNEWLINE ▁ one ▁ of ▁ the ▁ source ▁ names ▁ in ▁ DataMuxer . sources STRNEWLINE ▁ """ NEW_LINE # ▁ self . _ timestamps _ as _ data ▁ is ▁ a ▁ set ▁ of ▁ sources ▁ who ▁ timestamps ENDCOM # ▁ should ▁ be ▁ treated ▁ as ▁ data ▁ in ▁ the ▁ _ dataframe ▁ method ▁ above . ENDCOM self . _timestamps_as_data . add ( source_name ) NEW_LINE name = _timestamp_col_name ( source_name ) NEW_LINE self . col_info [ name ] = ColSpec ( name , 0 , None , None , np . mean ) NEW_LINE self . _stale = True NEW_LINE DEDENT def remove_timestamp_data ( self , source_name ) : NEW_LINE INDENT """ Remove ▁ the ▁ exact ▁ timing ▁ of ▁ a ▁ data ▁ source ▁ from ▁ the ▁ data ▁ columns . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ source _ name ▁ : ▁ string STRNEWLINE ▁ one ▁ of ▁ the ▁ source ▁ names ▁ in ▁ DataMuxer . sources STRNEWLINE ▁ """ NEW_LINE self . _timestamps_as_data . remove ( source_name ) NEW_LINE # ▁ Do ▁ not ▁ force ▁ a ▁ rebuilt ▁ ( i . e . , ▁ self . _ stale ) . ▁ Just ▁ remove ▁ it ▁ here . ENDCOM del self . _df [ _timestamp_col_name ( source_name ) ] NEW_LINE DEDENT def bin_on ( self , source_name , interpolation = None , agg = None , use_cols = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ data ▁ resampled ▁ to ▁ align ▁ with ▁ the ▁ data ▁ from ▁ a ▁ particular ▁ source . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ source _ name ▁ : ▁ string STRNEWLINE ▁ interpolation ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ interpolation ▁ ( upsampling ) ▁ behavior ▁ of ▁ any STRNEWLINE ▁ data ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto STRNEWLINE ▁ one ▁ of ▁ the ▁ following ▁ interpolation ▁ methods . STRNEWLINE STRNEWLINE ▁ { None , ▁ ' linear ' , ▁ ' nearest ' , ▁ ' zero ' , ▁ ' slinear ' , ▁ ' quadratic ' , STRNEWLINE ▁ ' cubic ' } STRNEWLINE STRNEWLINE ▁ None ▁ means ▁ that ▁ each ▁ time ▁ bin ▁ must ▁ have ▁ at ▁ least ▁ one ▁ value . STRNEWLINE ▁ See ▁ scipy . interpolator ▁ for ▁ more ▁ on ▁ the ▁ other ▁ methods . STRNEWLINE ▁ agg ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ reduction ▁ ( downsampling ) ▁ behavior ▁ of ▁ any ▁ data STRNEWLINE ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto ▁ any STRNEWLINE ▁ callable ▁ that ▁ reduces ▁ multiple ▁ data ▁ points ▁ ( of ▁ whatever ▁ dimension ) STRNEWLINE ▁ to ▁ a ▁ single ▁ data ▁ point . STRNEWLINE ▁ use _ cols ▁ : ▁ list , ▁ optional STRNEWLINE ▁ List ▁ of ▁ columns ▁ to ▁ include ▁ in ▁ binning ; ▁ use ▁ all ▁ columns ▁ by ▁ default . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ resampled _ df ▁ : ▁ pandas . DataFrame STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ http : / / docs . scipy . org / doc / scipy / reference / generated / scipy . interpolate . interp1d . html STRNEWLINE ▁ """ NEW_LINE centers , bin_edges = self . _bin_on ( source_name ) NEW_LINE return self . bin_by_edges ( bin_edges , bin_anchors = centers , interpolation = interpolation , agg = agg , use_cols = use_cols ) NEW_LINE DEDENT def _bin_on ( self , source_name ) : NEW_LINE INDENT " Compute ▁ bin ▁ edges ▁ spaced ▁ around ▁ centers ▁ defined ▁ by ▁ source _ name ▁ points . " NEW_LINE col = self . _dataframe [ source_name ] NEW_LINE centers = self . _dataframe [ ' time ' ] . reindex_like ( col . dropna ( ) ) . values NEW_LINE # ▁ [ 2 , ▁ 4 , ▁ 6 ] ▁ - > ▁ [ - inf , ▁ 3 , ▁ 5 , ▁ inf ] ENDCOM bin_edges = np . mean ( [ centers [ 1 : ] , centers [ : - 1 ] ] , 0 ) NEW_LINE # ▁ [ - inf , ▁ 3 , ▁ 5 , ▁ inf ] ▁ - > ▁ [ ( - inf , ▁ 3 ) , ▁ ( 3 , ▁ 5 ) , ▁ ( 5 , ▁ inf ) ] ENDCOM bin_edges = [ - np . inf ] + list ( np . repeat ( bin_edges , 2 ) ) + [ np . inf ] NEW_LINE bin_edges = np . reshape ( bin_edges , ( - 1 , 2 ) ) NEW_LINE return centers , bin_edges NEW_LINE DEDENT def bin_by_edges ( self , bin_edges , bin_anchors , interpolation = None , agg = None , use_cols = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ data ▁ resampled ▁ into ▁ bins ▁ with ▁ the ▁ specified ▁ edges . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ bin _ edges ▁ : ▁ list STRNEWLINE ▁ list ▁ of ▁ two - element ▁ items ▁ like ▁ [ ( t1 , ▁ t2 ) , ▁ ( t3 , ▁ t4 ) , ▁ . . . ] STRNEWLINE ▁ bin _ anchors ▁ : ▁ list STRNEWLINE ▁ These ▁ are ▁ time ▁ points ▁ where ▁ interpolated ▁ values ▁ will ▁ be ▁ evaluated . STRNEWLINE ▁ Bin ▁ centers ▁ are ▁ usually ▁ a ▁ good ▁ choice . STRNEWLINE ▁ interpolation ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ interpolation ▁ ( upsampling ) ▁ behavior ▁ of ▁ any STRNEWLINE ▁ data ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto STRNEWLINE ▁ one ▁ of ▁ the ▁ following ▁ interpolation ▁ methods . STRNEWLINE STRNEWLINE ▁ { None , ▁ ' linear ' , ▁ ' nearest ' , ▁ ' zero ' , ▁ ' slinear ' , ▁ ' quadratic ' , STRNEWLINE ▁ ' cubic ' } STRNEWLINE STRNEWLINE ▁ None ▁ means ▁ that ▁ each ▁ time ▁ bin ▁ must ▁ have ▁ at ▁ least ▁ one ▁ value . STRNEWLINE ▁ See ▁ scipy . interpolator ▁ for ▁ more ▁ on ▁ the ▁ other ▁ methods . STRNEWLINE ▁ agg ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ reduction ▁ ( downsampling ) ▁ behavior ▁ of ▁ any ▁ data STRNEWLINE ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto ▁ any STRNEWLINE ▁ callable ▁ that ▁ reduces ▁ multiple ▁ data ▁ points ▁ ( of ▁ whatever ▁ dimension ) STRNEWLINE ▁ to ▁ a ▁ single ▁ data ▁ point . STRNEWLINE ▁ use _ cols ▁ : ▁ list , ▁ optional STRNEWLINE ▁ List ▁ of ▁ columns ▁ to ▁ include ▁ in ▁ binning ; ▁ use ▁ all ▁ columns ▁ by ▁ default . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ resampled _ df ▁ : ▁ pandas . DataFrame STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ http : / / docs . scipy . org / doc / scipy / reference / generated / scipy . interpolate . interp1d . html STRNEWLINE ▁ """ NEW_LINE bin_anchors , binning = self . _bin_by_edges ( bin_anchors , bin_edges ) NEW_LINE return self . resample ( bin_anchors , binning , interpolation , agg , use_cols = use_cols ) NEW_LINE DEDENT def _bin_by_edges ( self , bin_anchors , bin_edges ) : NEW_LINE INDENT " Compute ▁ bin ▁ assignment ▁ and , ▁ if ▁ needed , ▁ bin _ anchors . " NEW_LINE time = self . _dataframe [ ' time ' ] . values NEW_LINE # ▁ Get ▁ edges ▁ into ▁ 1D ▁ array [ L , ▁ R , ▁ L , ▁ R , ▁ . . . ] ENDCOM edges_as_pairs = np . reshape ( bin_edges , ( - 1 , 2 ) ) NEW_LINE all_edges = np . ravel ( edges_as_pairs ) NEW_LINE if not np . all ( np . diff ( all_edges ) >= 0 ) : NEW_LINE INDENT raise ValueError ( " Illegal ▁ binning : ▁ the ▁ left ▁ edge ▁ must ▁ be ▁ less ▁ " " than ▁ the ▁ right ▁ edge . " ) NEW_LINE # ▁ Sort ▁ out ▁ where ▁ the ▁ array ▁ each ▁ time ▁ would ▁ be ▁ inserted . ENDCOM DEDENT binning = np . searchsorted ( all_edges , time ) . astype ( float ) NEW_LINE # ▁ Times ▁ that ▁ would ▁ get ▁ inserted ▁ at ▁ even ▁ positions ▁ are ▁ between ▁ bins . ENDCOM # ▁ Mark ▁ them ENDCOM binning [ binning % 2 == 0 ] = np . nan NEW_LINE binning //= 2 # ▁ Make ▁ bin ▁ number ▁ sequential , ▁ not ▁ odds ▁ only . ENDCOM NEW_LINE if bin_anchors is None : NEW_LINE INDENT bin_anchors = np . mean ( edges_as_pairs , axis = 1 ) # ▁ bin ▁ centers ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT if len ( bin_anchors ) != len ( bin_edges ) : NEW_LINE INDENT raise ValueError ( " There ▁ are ▁ { 0 } ▁ bin _ anchors ▁ but ▁ { 1 } ▁ pairs ▁ of ▁ " " bin _ edges . ▁ These ▁ must ▁ match . " . format ( len ( bin_anchors ) , len ( bin_edges ) ) ) NEW_LINE DEDENT DEDENT return bin_anchors , binning NEW_LINE DEDENT def resample ( self , bin_anchors , binning , interpolation = None , agg = None , verify_integrity = True , use_cols = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ data ▁ resampled ▁ into ▁ bins ▁ with ▁ the ▁ specified ▁ edges . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ bin _ anchors ▁ : ▁ list STRNEWLINE ▁ These ▁ are ▁ time ▁ points ▁ where ▁ interpolated ▁ values ▁ will ▁ be ▁ evaluated . STRNEWLINE ▁ Bin ▁ centers ▁ are ▁ usually ▁ a ▁ good ▁ choice . STRNEWLINE ▁ bin _ anchors ▁ : ▁ list STRNEWLINE ▁ Bin ▁ assignment . ▁ Example : ▁ [ 1 , ▁ 1 , ▁ 2 , ▁ 2 , ▁ 3 , ▁ 3 ] ▁ puts ▁ six ▁ data ▁ points STRNEWLINE ▁ into ▁ three ▁ bins ▁ with ▁ two ▁ points ▁ each . STRNEWLINE ▁ interpolation ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ interpolation ▁ ( upsampling ) ▁ behavior ▁ of ▁ any STRNEWLINE ▁ data ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto STRNEWLINE ▁ one ▁ of ▁ the ▁ following ▁ interpolation ▁ methods . STRNEWLINE STRNEWLINE ▁ { None , ▁ ' linear ' , ▁ ' nearest ' , ▁ ' zero ' , ▁ ' slinear ' , ▁ ' quadratic ' , STRNEWLINE ▁ ' cubic ' } STRNEWLINE STRNEWLINE ▁ None ▁ means ▁ that ▁ each ▁ time ▁ bin ▁ must ▁ have ▁ at ▁ least ▁ one ▁ value . STRNEWLINE ▁ See ▁ scipy . interpolator ▁ for ▁ more ▁ on ▁ the ▁ other ▁ methods . STRNEWLINE ▁ agg ▁ : ▁ dict , ▁ optional STRNEWLINE ▁ Override ▁ the ▁ default ▁ reduction ▁ ( downsampling ) ▁ behavior ▁ of ▁ any ▁ data STRNEWLINE ▁ source ▁ by ▁ passing ▁ a ▁ dictionary ▁ of ▁ source ▁ names ▁ mapped ▁ onto ▁ any STRNEWLINE ▁ callable ▁ that ▁ reduces ▁ multiple ▁ data ▁ points ▁ ( of ▁ whatever ▁ dimension ) STRNEWLINE ▁ to ▁ a ▁ single ▁ data ▁ point . STRNEWLINE ▁ verify _ integrity ▁ : ▁ bool , ▁ optional STRNEWLINE ▁ For ▁ a ▁ cost ▁ in ▁ performance , ▁ verify ▁ that ▁ the ▁ downsampling ▁ function STRNEWLINE ▁ produces ▁ data ▁ of ▁ the ▁ expected ▁ shape . ▁ True ▁ by ▁ default . STRNEWLINE ▁ use _ cols ▁ : ▁ list , ▁ optional STRNEWLINE ▁ List ▁ of ▁ columns ▁ to ▁ include ▁ in ▁ binning ; ▁ use ▁ all ▁ columns ▁ by ▁ default . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ resampled _ df ▁ : ▁ pandas . DataFrame STRNEWLINE STRNEWLINE ▁ References STRNEWLINE ▁ - - - - - STRNEWLINE ▁ http : / / docs . scipy . org / doc / scipy / reference / generated / scipy . interpolate . interp1d . html STRNEWLINE ▁ """ NEW_LINE if use_cols is None : NEW_LINE INDENT use_cols = self . columns NEW_LINE DEDENT plan = self . Planner ( self ) NEW_LINE upsampling_rules = plan . determine_upsample ( interpolation , use_cols ) NEW_LINE downsampling_rules = plan . determine_downsample ( agg , use_cols ) NEW_LINE grouped = self . _dataframe . groupby ( binning ) NEW_LINE first_point = grouped . first ( ) NEW_LINE counts = grouped . count ( ) NEW_LINE resampling_requirements = _is_resampling_applicable ( counts ) NEW_LINE index = np . arange ( len ( bin_anchors ) ) NEW_LINE result = { } # ▁ dict ▁ of ▁ DataFrames , ▁ to ▁ become ▁ one ▁ MultiIndexed ▁ DataFrame ENDCOM NEW_LINE for name in use_cols : NEW_LINE INDENT upsample = upsampling_rules [ name ] NEW_LINE downsample = downsampling_rules [ name ] NEW_LINE upsampling_possible = resampling_requirements [ ' upsampling _ possible ' ] [ name ] NEW_LINE downsampling_needed = resampling_requirements [ ' downsampling _ needed ' ] [ name ] NEW_LINE result [ name ] = pd . DataFrame ( index = index ) NEW_LINE # ▁ Put ▁ the ▁ first ▁ ( maybe ▁ only ) ▁ value ▁ into ▁ a ▁ Series . ENDCOM # ▁ We ▁ will ▁ overwrite ▁ as ▁ needed ▁ below . ENDCOM result [ name ] [ ' val ' ] = pd . Series ( data = first_point [ name ] ) NEW_LINE # ▁ Short - circuit ▁ if ▁ we ▁ are ▁ done . ENDCOM if not ( upsampling_possible or downsampling_needed ) : NEW_LINE INDENT logger . debug ( " % s ▁ has ▁ exactly ▁ one ▁ data ▁ point ▁ per ▁ bin " , name ) NEW_LINE continue NEW_LINE DEDENT result [ name ] [ ' count ' ] = counts [ name ] NEW_LINE # ▁ If ▁ any ▁ bin ▁ has ▁ no ▁ data , ▁ use ▁ the ▁ upsampling ▁ rule ▁ to ▁ interpolate ENDCOM # ▁ at ▁ the ▁ center ▁ of ▁ the ▁ empty ▁ bins . ▁ If ▁ there ▁ is ▁ no ▁ rule , ▁ simply ENDCOM # ▁ leave ▁ some ▁ bins ▁ empty . ▁ Do ▁ not ▁ raise ▁ an ▁ error . ENDCOM if upsampling_possible and ( upsample is not None ) : NEW_LINE INDENT if upsample in ( ' ffill ' , ' bfill ' ) : NEW_LINE INDENT result [ name ] [ ' val ' ] . fillna ( method = upsample , inplace = True ) NEW_LINE DEDENT else : NEW_LINE INDENT dense_col = self . _dataframe [ name ] . dropna ( ) NEW_LINE y = dense_col . values NEW_LINE x = self . _dataframe [ ' time ' ] . reindex_like ( dense_col ) . values NEW_LINE interpolator = interp1d ( x , y , kind = upsample ) NEW_LINE # ▁ Outside ▁ the ▁ limits ▁ of ▁ the ▁ data , ▁ the ▁ interpolator ▁ will ENDCOM # ▁ fail . ▁ Leave ▁ any ▁ such ▁ entires ▁ empty . ENDCOM is_safe = ( ( bin_anchors > np . min ( x ) ) & ( bin_anchors < np . max ( x ) ) ) NEW_LINE safe_times = bin_anchors [ is_safe ] NEW_LINE safe_bins = index [ is_safe ] NEW_LINE interp_points = pd . Series ( interpolator ( safe_times ) , index = safe_bins ) NEW_LINE logger . debug ( " Interpolating ▁ to ▁ fill ▁ % d ▁ of ▁ % d ▁ " " empty ▁ bins ▁ in ▁ % s " , len ( safe_bins ) , ( counts [ name ] == 0 ) . sum ( ) , name ) NEW_LINE result [ name ] [ ' val ' ] . fillna ( interp_points , inplace = True ) NEW_LINE # ▁ Short - circuit ▁ if ▁ we ▁ are ▁ done . ENDCOM DEDENT DEDENT if not downsampling_needed : NEW_LINE INDENT logger . debug ( " % s ▁ has ▁ at ▁ most ▁ one ▁ data ▁ point ▁ per ▁ bin " , name ) NEW_LINE continue NEW_LINE # ▁ Multi - valued ▁ bins ▁ must ▁ be ▁ downsampled ▁ ( reduced ) . ▁ If ▁ there ▁ is ▁ no ENDCOM # ▁ rule ▁ for ▁ downsampling , ▁ we ▁ have ▁ no ▁ recourse : ▁ we ▁ must ▁ raise . ENDCOM DEDENT if ( downsample is None ) : NEW_LINE INDENT raise BinningError ( " The ▁ specified ▁ binning ▁ puts ▁ multiple ▁ " " ' {0 } ' ▁ measurements ▁ in ▁ at ▁ least ▁ one ▁ bin , ▁ " " and ▁ there ▁ is ▁ no ▁ rule ▁ for ▁ downsampling ▁ " " ( i . e . , ▁ reducing ) ▁ it . " . format ( name ) ) NEW_LINE DEDENT if verify_integrity and callable ( downsample ) : NEW_LINE INDENT downsample = _build_verified_downsample ( downsample , self . col_info [ name ] . shape ) NEW_LINE DEDENT g = grouped [ name ] # ▁ for ▁ brevity ENDCOM NEW_LINE if self . col_info [ name ] . ndim == 0 : NEW_LINE INDENT logger . debug ( " The ▁ scalar ▁ column ▁ % s ▁ must ▁ be ▁ downsampled . " , name ) NEW_LINE # ▁ For ▁ scalars , ▁ pandas ▁ knows ▁ what ▁ to ▁ do . ENDCOM downsampled = g . agg ( downsample ) NEW_LINE std_series = g . std ( ) NEW_LINE max_series = g . max ( ) NEW_LINE min_series = g . min ( ) NEW_LINE DEDENT else : NEW_LINE # ▁ For ▁ nonscalars , ▁ we ▁ are ▁ abusing ▁ groupby ▁ and ▁ must ▁ go ▁ to ▁ a ENDCOM # ▁ a ▁ little ▁ more ▁ trouble ▁ to ▁ guarantee ▁ success . ENDCOM INDENT logger . debug ( " The ▁ nonscalar ▁ column ▁ % s ▁ must ▁ be ▁ downsampled . " , name ) NEW_LINE if not callable ( downsample ) : NEW_LINE # ▁ Do ▁ this ▁ lookup ▁ here ▁ so ▁ that ▁ strings ▁ can ▁ be ▁ passed ENDCOM # ▁ in ▁ the ▁ call ▁ to ▁ resample . ENDCOM INDENT downsample = ColSpec . _downsample_mapping [ downsample ] NEW_LINE DEDENT downsampled = g . apply ( lambda x : downsample ( np . asarray ( x . dropna ( ) ) ) ) NEW_LINE std_series = g . apply ( lambda x : np . std ( np . asarray ( x . dropna ( ) ) , 0 ) ) NEW_LINE max_series = g . apply ( lambda x : np . max ( np . asarray ( x . dropna ( ) ) , 0 ) ) NEW_LINE min_series = g . apply ( lambda x : np . min ( np . asarray ( x . dropna ( ) ) , 0 ) ) NEW_LINE # ▁ This ▁ ( counts [ name ] ▁ > ▁ 1 ) ▁ is ▁ redundant , ▁ but ▁ there ▁ is ▁ no ▁ clean ▁ way ▁ to ENDCOM # ▁ pass ▁ it ▁ here ▁ without ▁ refactoring . ▁ Not ▁ a ▁ huge ▁ cost . ENDCOM DEDENT result [ name ] [ ' val ' ] . where ( ~ ( counts [ name ] > 1 ) , downsampled , inplace = True ) NEW_LINE result [ name ] [ ' std ' ] = std_series NEW_LINE result [ name ] [ ' max ' ] = max_series NEW_LINE result [ name ] [ ' min ' ] = min_series NEW_LINE DEDENT result = pd . concat ( result , axis = 1 ) # ▁ one ▁ MultiIndexed ▁ DataFrame ENDCOM NEW_LINE result . index . name = ' bin ' NEW_LINE # ▁ Convert ▁ time ▁ timestamp ▁ or ▁ timedelta , ▁ depending ▁ on ▁ the ▁ state ▁ of ENDCOM # ▁ self . convert _ times ▁ and ▁ self . reference _ time . ENDCOM for col_name in self . _time_columns : NEW_LINE INDENT if isinstance ( result [ col_name ] , pd . DataFrame ) : NEW_LINE INDENT subcols = result [ col_name ] . columns NEW_LINE for subcol in subcols & { ' max ' , ' min ' , ' val ' } : NEW_LINE INDENT result [ ( col_name , subcol ) ] = self . _maybe_convert_times ( result [ ( col_name , subcol ) ] ) NEW_LINE DEDENT for subcol in subcols & { ' std ' } : NEW_LINE INDENT result [ ( col_name , subcol ) ] = pd . to_timedelta ( result [ ( col_name , subcol ) ] , unit = ' s ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT result [ col_name ] = self . _maybe_convert_times ( result [ col_name ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def __getitem__ ( self , source_name ) : NEW_LINE INDENT if source_name not in list ( self . col_info . keys ( ) ) + [ ' time ' ] : NEW_LINE INDENT raise KeyError ( " No ▁ data ▁ from ▁ a ▁ source ▁ called ▁ ' {0 } ' ▁ has ▁ been ▁ " " added . " . format ( source_name ) ) NEW_LINE # ▁ Unlike ▁ output ▁ from ▁ binning ▁ functions , ▁ this ▁ is ▁ indexed ENDCOM # ▁ on ▁ time . ENDCOM DEDENT result = self . _dataframe [ source_name ] . dropna ( ) NEW_LINE result . index = self . _dataframe [ ' time ' ] . reindex_like ( result ) NEW_LINE return result NEW_LINE DEDENT def __getattr__ ( self , attr ) : NEW_LINE # ▁ Developer ▁ beware : ▁ if ▁ any ▁ properties ▁ raise ▁ an ▁ AttributeError , ENDCOM # ▁ this ▁ will ▁ mask ▁ it . ▁ Comment ▁ this ▁ magic ▁ method ▁ to ▁ debug ▁ properties . ENDCOM INDENT if attr in self . col_info . keys ( ) : NEW_LINE INDENT return self [ attr ] NEW_LINE DEDENT else : NEW_LINE INDENT raise AttributeError ( " DataMuxer ▁ has ▁ no ▁ attribute ▁ { 0 } ▁ and ▁ no ▁ " " data ▁ source ▁ named ▁ ' {0 } ' " . format ( attr ) ) NEW_LINE DEDENT DEDENT @ property NEW_LINE def ncols ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ number ▁ of ▁ columns ▁ that ▁ the ▁ DataMuxer ▁ contains STRNEWLINE ▁ """ NEW_LINE return len ( self . col_info ) NEW_LINE DEDENT @ property NEW_LINE def col_info_by_ndim ( self ) : NEW_LINE INDENT """ Dictionary ▁ mapping ▁ dimensionality ▁ ( ndim ) ▁ onto ▁ a ▁ list ▁ of ▁ ColSpecs """ NEW_LINE result = { } NEW_LINE for name , col_spec in six . iteritems ( self . col_info ) : NEW_LINE INDENT try : NEW_LINE INDENT result [ col_spec . ndim ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT result [ col_spec . ndim ] = [ ] NEW_LINE DEDENT result [ col_spec . ndim ] . append ( col_spec ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT def dataframe_to_dict ( df ) : NEW_LINE INDENT """ STRNEWLINE ▁ Turn ▁ a ▁ DataFrame ▁ into ▁ a ▁ dict ▁ of ▁ lists . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ df ▁ : ▁ DataFrame STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ index ▁ : ▁ ndarray STRNEWLINE ▁ The ▁ index ▁ of ▁ the ▁ data ▁ frame STRNEWLINE ▁ data ▁ : ▁ dict STRNEWLINE ▁ Dictionary ▁ keyed ▁ on ▁ column ▁ name ▁ of ▁ the ▁ column . ▁ The ▁ value ▁ is STRNEWLINE ▁ one ▁ of ▁ ( ndarray , ▁ list , ▁ pd . Series ) STRNEWLINE ▁ """ NEW_LINE dict_of_lists = { col : df [ col ] . to_list ( ) for col in df . columns } NEW_LINE return df . index . values , dict_of_lists NEW_LINE DEDENT def _build_verified_downsample ( downsample , expected_shape ) : NEW_LINE # ▁ Ensure ▁ two ▁ things : ENDCOM # ▁ 1 . ▁ The ▁ downsampling ▁ function ▁ shouldn ' t ▁ touch ▁ bins ▁ with ▁ only ▁ one ▁ point . ENDCOM # ▁ 2 . ▁ The ▁ result ▁ of ▁ downsample ▁ should ▁ have ▁ the ▁ right ▁ shape . ENDCOM INDENT def _downsample ( data ) : NEW_LINE INDENT if len ( data ) == 1 : NEW_LINE INDENT return data NEW_LINE DEDENT downsampled = downsample ( data ) NEW_LINE if ( expected_shape is None or expected_shape == 0 ) : NEW_LINE INDENT if not np . isscalar ( downsampled ) : NEW_LINE INDENT raise BadDownsamplerError ( " The ▁ ' agg ' ▁ ( downsampling ) ▁ function ▁ " " for ▁ { 0 } ▁ is ▁ expected ▁ to ▁ produce ▁ " " a ▁ scalar ▁ from ▁ the ▁ data ▁ in ▁ each ▁ " " bin . " . format ( downsampled ) ) NEW_LINE DEDENT DEDENT elif downsampled . shape != expected_shape : NEW_LINE INDENT raise BadDownsamplerError ( " An ▁ ' agg ' ▁ ( downsampling ) ▁ function ▁ " " returns ▁ data ▁ shaped ▁ { 0 } ▁ but ▁ the ▁ " " shape ▁ { 1 } ▁ is ▁ expected . " . format ( downsampled . shape , expected_shape ) ) NEW_LINE DEDENT return downsampled NEW_LINE DEDENT return _downsample NEW_LINE DEDENT def _timestamp_col_name ( source_name ) : NEW_LINE INDENT return ' { 0 } _ timestamp ' . format ( source_name ) NEW_LINE DEDENT def _normalize_string_none ( val ) : NEW_LINE INDENT " Replay ▁ passes ▁ ' None ' ▁ to ▁ mean ▁ None . " NEW_LINE try : NEW_LINE INDENT lowercase_val = val . lower ( ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT return val NEW_LINE DEDENT if lowercase_val == ' none ' : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT def _is_resampling_applicable ( counts ) : NEW_LINE INDENT has_no_points = counts == 0 NEW_LINE has_multiple_points = counts > 1 NEW_LINE upsampling_possible = has_no_points . any ( ) NEW_LINE downsampling_needed = has_multiple_points . any ( ) NEW_LINE result = { } NEW_LINE result [ ' upsampling _ possible ' ] = upsampling_possible . to_dict ( ) NEW_LINE result [ ' downsampling _ needed ' ] = downsampling_needed . to_dict ( ) NEW_LINE return result NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="sysadmind/ansible-modules-extras/tree/master/monitoring/pagerduty.py"> # ! / usr / bin / python ENDCOM # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Ansible ENDCOM # ▁ Ansible ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ Ansible ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ Ansible . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM DOCUMENTATION = ''' STRNEWLINE STRNEWLINE module : ▁ pagerduty STRNEWLINE short _ description : ▁ Create ▁ PagerDuty ▁ maintenance ▁ windows STRNEWLINE description : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ This ▁ module ▁ will ▁ let ▁ you ▁ create ▁ PagerDuty ▁ maintenance ▁ windows STRNEWLINE version _ added : ▁ " 1.2 " STRNEWLINE author : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Andrew ▁ Newdigate ▁ ( @ suprememoocow ) " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Dylan ▁ Silva ▁ ( @ thaumos ) " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Justin ▁ Johns " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Bruce ▁ Pennypacker " STRNEWLINE requirements : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ API ▁ access STRNEWLINE options : STRNEWLINE ▁ ▁ ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Create ▁ a ▁ maintenance ▁ window ▁ or ▁ get ▁ a ▁ list ▁ of ▁ ongoing ▁ windows . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ▁ " running " , ▁ " started " , ▁ " ongoing " , ▁ " absent " ▁ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ unique ▁ subdomain . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ user : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ user ▁ ID . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ passwd : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ user ▁ password . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ token : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ A ▁ pagerduty ▁ token , ▁ generated ▁ on ▁ the ▁ pagerduty ▁ site . ▁ Can ▁ be ▁ used ▁ instead ▁ of STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user / passwd ▁ combination . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ ' 1.8 ' STRNEWLINE ▁ ▁ ▁ ▁ requester _ id : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ID ▁ of ▁ user ▁ making ▁ the ▁ request . ▁ Only ▁ needed ▁ when ▁ using ▁ a ▁ token ▁ and ▁ creating ▁ a ▁ maintenance _ window . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ ' 1.8 ' STRNEWLINE ▁ ▁ ▁ ▁ service : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ A ▁ comma ▁ separated ▁ list ▁ of ▁ PagerDuty ▁ service ▁ IDs . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ▁ services ▁ ] STRNEWLINE ▁ ▁ ▁ ▁ hours : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Length ▁ of ▁ maintenance ▁ window ▁ in ▁ hours . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ 1 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ minutes : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Maintenance ▁ window ▁ in ▁ minutes ▁ ( this ▁ is ▁ added ▁ to ▁ the ▁ hours ) . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ 0 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ ' 1.8 ' STRNEWLINE ▁ ▁ ▁ ▁ desc : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Short ▁ description ▁ of ▁ maintenance ▁ window . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ Created ▁ by ▁ Ansible STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ validate _ certs : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ If ▁ C ( no ) , ▁ SSL ▁ certificates ▁ will ▁ not ▁ be ▁ validated . ▁ This ▁ should ▁ only ▁ be ▁ used STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ on ▁ personally ▁ controlled ▁ sites ▁ using ▁ self - signed ▁ certificates . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' yes ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ' yes ' , ▁ ' no ' ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ 1.5.1 STRNEWLINE ''' NEW_LINE EXAMPLES = ''' STRNEWLINE # ▁ List ▁ ongoing ▁ maintenance ▁ windows ▁ using ▁ a ▁ user / passwd STRNEWLINE - ▁ pagerduty : ▁ name = companyabc ▁ user = example @ example . com ▁ passwd = password123 ▁ state = ongoing STRNEWLINE STRNEWLINE # ▁ List ▁ ongoing ▁ maintenance ▁ windows ▁ using ▁ a ▁ token STRNEWLINE - ▁ pagerduty : ▁ name = companyabc ▁ token = xxxxxxxxxxxxxx ▁ state = ongoing STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ 1 ▁ hour ▁ maintenance ▁ window ▁ for ▁ service ▁ FOO123 , ▁ using ▁ a ▁ user / passwd STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user = example @ example . com STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ passwd = password123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = running STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = FOO123 STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ 5 ▁ minute ▁ maintenance ▁ window ▁ for ▁ service ▁ FOO123 , ▁ using ▁ a ▁ token STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ token = xxxxxxxxxxxxxx STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ hours = 0 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ minutes = 5 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = running STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = FOO123 STRNEWLINE STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ 4 ▁ hour ▁ maintenance ▁ window ▁ for ▁ service ▁ FOO123 ▁ with ▁ the ▁ description ▁ " deployment " . STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user = example @ example . com STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ passwd = password123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = running STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = FOO123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ hours = 4 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ desc = deployment STRNEWLINE ▁ ▁ register : ▁ pd _ window STRNEWLINE STRNEWLINE # ▁ Delete ▁ the ▁ previous ▁ maintenance ▁ window STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user = example @ example . com STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ passwd = password123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = absent STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = { { ▁ pd _ window . result . maintenance _ window . id ▁ } } STRNEWLINE ''' NEW_LINE import datetime NEW_LINE import base64 NEW_LINE def auth_header ( user , passwd , token ) : NEW_LINE INDENT if token : NEW_LINE INDENT return " Token ▁ token = % s " % token NEW_LINE DEDENT auth = base64 . encodestring ( ' % s : % s ' % ( user , passwd ) ) . replace ( ' \n ' , ' ' ) NEW_LINE return " Basic ▁ % s " % auth NEW_LINE DEDENT def ongoing ( module , name , user , passwd , token ) : NEW_LINE INDENT url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows / ongoing " NEW_LINE headers = { " Authorization " : auth_header ( user , passwd , token ) } NEW_LINE response , info = fetch_url ( module , url , headers = headers ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ lookup ▁ the ▁ ongoing ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , False NEW_LINE DEDENT def create ( module , name , user , passwd , token , requester_id , service , hours , minutes , desc ) : NEW_LINE INDENT now = datetime . datetime . utcnow ( ) NEW_LINE later = now + datetime . timedelta ( hours = int ( hours ) , minutes = int ( minutes ) ) NEW_LINE start = now . strftime ( " % Y - % m - % dT % H : % M : % SZ " ) NEW_LINE end = later . strftime ( " % Y - % m - % dT % H : % M : % SZ " ) NEW_LINE url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows " NEW_LINE headers = { ' Authorization ' : auth_header ( user , passwd , token ) , ' Content - Type ' : ' application / json ' , } NEW_LINE request_data = { ' maintenance _ window ' : { ' start _ time ' : start , ' end _ time ' : end , ' description ' : desc , ' service _ ids ' : service } } NEW_LINE if requester_id : NEW_LINE INDENT request_data [ ' requester _ id ' ] = requester_id NEW_LINE DEDENT else : NEW_LINE INDENT if token : NEW_LINE INDENT module . fail_json ( msg = " requester _ id ▁ is ▁ required ▁ when ▁ using ▁ a ▁ token " ) NEW_LINE DEDENT DEDENT data = json . dumps ( request_data ) NEW_LINE response , info = fetch_url ( module , url , data = data , headers = headers , method = ' POST ' ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ create ▁ the ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , True NEW_LINE DEDENT def absent ( module , name , user , passwd , token , requester_id , service ) : NEW_LINE INDENT url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows / " + service [ 0 ] NEW_LINE headers = { ' Authorization ' : auth_header ( user , passwd , token ) , ' Content - Type ' : ' application / json ' , } NEW_LINE request_data = { } NEW_LINE if requester_id : NEW_LINE INDENT request_data [ ' requester _ id ' ] = requester_id NEW_LINE DEDENT else : NEW_LINE INDENT if token : NEW_LINE INDENT module . fail_json ( msg = " requester _ id ▁ is ▁ required ▁ when ▁ using ▁ a ▁ token " ) NEW_LINE DEDENT DEDENT data = json . dumps ( request_data ) NEW_LINE response , info = fetch_url ( module , url , data = data , headers = headers , method = ' DELETE ' ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ delete ▁ the ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT module = AnsibleModule ( argument_spec = dict ( state = dict ( required = True , choices = [ ' running ' , ' started ' , ' ongoing ' , ' absent ' ] ) , name = dict ( required = True ) , user = dict ( required = False ) , passwd = dict ( required = False ) , token = dict ( required = False ) , service = dict ( required = False , type = ' list ' , aliases = [ " services " ] ) , requester_id = dict ( required = False ) , hours = dict ( default = '1' , required = False ) , minutes = dict ( default = '0' , required = False ) , desc = dict ( default = ' Created ▁ by ▁ Ansible ' , required = False ) , validate_certs = dict ( default = ' yes ' , type = ' bool ' ) , ) ) NEW_LINE state = module . params [ ' state ' ] NEW_LINE name = module . params [ ' name ' ] NEW_LINE user = module . params [ ' user ' ] NEW_LINE passwd = module . params [ ' passwd ' ] NEW_LINE token = module . params [ ' token ' ] NEW_LINE service = module . params [ ' service ' ] NEW_LINE hours = module . params [ ' hours ' ] NEW_LINE minutes = module . params [ ' minutes ' ] NEW_LINE token = module . params [ ' token ' ] NEW_LINE desc = module . params [ ' desc ' ] NEW_LINE requester_id = module . params [ ' requester _ id ' ] NEW_LINE if not token and not ( user or passwd ) : NEW_LINE INDENT module . fail_json ( msg = " neither ▁ user ▁ and ▁ passwd ▁ nor ▁ token ▁ specified " ) NEW_LINE DEDENT if state == " running " or state == " started " : NEW_LINE INDENT if not service : NEW_LINE INDENT module . fail_json ( msg = " service ▁ not ▁ specified " ) NEW_LINE DEDENT ( rc , out , changed ) = create ( module , name , user , passwd , token , requester_id , service , hours , minutes , desc ) NEW_LINE if rc == 0 : NEW_LINE INDENT changed = True NEW_LINE DEDENT DEDENT if state == " ongoing " : NEW_LINE INDENT ( rc , out , changed ) = ongoing ( module , name , user , passwd , token ) NEW_LINE DEDENT if state == " absent " : NEW_LINE INDENT ( rc , out , changed ) = absent ( module , name , user , passwd , token , requester_id , service ) NEW_LINE DEDENT if rc != 0 : NEW_LINE INDENT module . fail_json ( msg = " failed " , result = out ) NEW_LINE DEDENT module . exit_json ( msg = " success " , result = out , changed = changed ) NEW_LINE # ▁ import ▁ module ▁ snippets ENDCOM DEDENT from ansible . module_utils . basic import * NEW_LINE from ansible . module_utils . urls import * NEW_LINE main ( ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="factorybuild/stbgui/tree/master/lib/python/Screens/ChannelSelection.py"> from Tools . Profile import profile NEW_LINE from Screen import Screen NEW_LINE import Screens . InfoBar NEW_LINE import Components . ParentalControl NEW_LINE from Components . Button import Button NEW_LINE from Components . ServiceList import ServiceList , refreshServiceList NEW_LINE from Components . ActionMap import NumberActionMap , ActionMap , HelpableActionMap NEW_LINE from Components . MenuList import MenuList NEW_LINE from Components . ServiceEventTracker import ServiceEventTracker , InfoBarBase NEW_LINE profile ( " ChannelSelection . py ▁ 1" ) NEW_LINE from EpgSelection import EPGSelection NEW_LINE from enigma import eServiceReference , eEPGCache , eServiceCenter , eRCInput , eTimer , eDVBDB , iPlayableService , iServiceInformation , getPrevAsciiCode , eEnv NEW_LINE from Components . config import config , configfile , ConfigSubsection , ConfigText , ConfigYesNo NEW_LINE from Tools . NumericalTextInput import NumericalTextInput NEW_LINE profile ( " ChannelSelection . py ▁ 2" ) NEW_LINE from Components . NimManager import nimmanager NEW_LINE profile ( " ChannelSelection . py ▁ 2.1" ) NEW_LINE from Components . Sources . RdsDecoder import RdsDecoder NEW_LINE profile ( " ChannelSelection . py ▁ 2.2" ) NEW_LINE from Components . Sources . ServiceEvent import ServiceEvent NEW_LINE from Components . Sources . Event import Event NEW_LINE profile ( " ChannelSelection . py ▁ 2.3" ) NEW_LINE from Components . Input import Input NEW_LINE profile ( " ChannelSelection . py ▁ 3" ) NEW_LINE from Components . ChoiceList import ChoiceList , ChoiceEntryComponent NEW_LINE from Components . SystemInfo import SystemInfo NEW_LINE from Screens . InputBox import PinInput NEW_LINE from Screens . VirtualKeyBoard import VirtualKeyBoard NEW_LINE from Screens . MessageBox import MessageBox NEW_LINE from Screens . ServiceInfo import ServiceInfo NEW_LINE from Screens . Hotkey import InfoBarHotkey , hotkeyActionMap , getHotkeyFunctions NEW_LINE profile ( " ChannelSelection . py ▁ 4" ) NEW_LINE from Screens . PictureInPicture import PictureInPicture NEW_LINE from Screens . RdsDisplay import RassInteractive NEW_LINE from ServiceReference import ServiceReference NEW_LINE from Tools . BoundFunction import boundFunction NEW_LINE from Tools import Notifications NEW_LINE from Tools . Alternatives import CompareWithAlternatives , GetWithAlternative NEW_LINE from Tools . Directories import fileExists NEW_LINE from Plugins . Plugin import PluginDescriptor NEW_LINE from Components . PluginComponent import plugins NEW_LINE from Screens . ChoiceBox import ChoiceBox NEW_LINE from Screens . EventView import EventViewEPGSelect NEW_LINE import os , unicodedata NEW_LINE profile ( " ChannelSelection . py ▁ after ▁ imports " ) NEW_LINE FLAG_SERVICE_NEW_FOUND = 64 NEW_LINE FLAG_IS_DEDICATED_3D = 128 NEW_LINE FLAG_HIDE_VBI = 512 # define ▁ in ▁ lib / dvb / idvb . h ▁ as ▁ dxNewFound ▁ = ▁ 64 ▁ and ▁ dxIsDedicated3D ▁ = ▁ 128 ENDCOM NEW_LINE class BouquetSelector ( Screen ) : NEW_LINE INDENT def __init__ ( self , session , bouquets , selectedFunc , enableWrapAround = True ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . setTitle ( _ ( " Choose ▁ bouquet " ) ) NEW_LINE self . selectedFunc = selectedFunc NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " ] , { " ok " : self . okbuttonClick , " cancel " : self . cancelClick } ) NEW_LINE entrys = [ ( x [ 0 ] , x [ 1 ] ) for x in bouquets ] NEW_LINE self [ " menu " ] = MenuList ( entrys , enableWrapAround ) NEW_LINE DEDENT def getCurrent ( self ) : NEW_LINE INDENT cur = self [ " menu " ] . getCurrent ( ) NEW_LINE return cur and cur [ 1 ] NEW_LINE DEDENT def okbuttonClick ( self ) : NEW_LINE INDENT self . selectedFunc ( self . getCurrent ( ) ) NEW_LINE DEDENT def up ( self ) : NEW_LINE INDENT self [ " menu " ] . up ( ) NEW_LINE DEDENT def down ( self ) : NEW_LINE INDENT self [ " menu " ] . down ( ) NEW_LINE DEDENT def cancelClick ( self ) : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT DEDENT class SilentBouquetSelector : NEW_LINE INDENT def __init__ ( self , bouquets , enableWrapAround = False , current = 0 ) : NEW_LINE INDENT self . bouquets = [ b [ 1 ] for b in bouquets ] NEW_LINE self . pos = current NEW_LINE self . count = len ( bouquets ) NEW_LINE self . enableWrapAround = enableWrapAround NEW_LINE DEDENT def up ( self ) : NEW_LINE INDENT if self . pos > 0 or self . enableWrapAround : NEW_LINE INDENT self . pos = ( self . pos - 1 ) % self . count NEW_LINE DEDENT DEDENT def down ( self ) : NEW_LINE INDENT if self . pos < ( self . count - 1 ) or self . enableWrapAround : NEW_LINE INDENT self . pos = ( self . pos + 1 ) % self . count NEW_LINE DEDENT DEDENT def getCurrent ( self ) : NEW_LINE INDENT return self . bouquets [ self . pos ] NEW_LINE # ▁ csel . bouquet _ mark _ edit ▁ values ENDCOM DEDENT DEDENT OFF = 0 NEW_LINE EDIT_BOUQUET = 1 NEW_LINE EDIT_ALTERNATIVES = 2 NEW_LINE def append_when_current_valid ( current , menu , args , level = 0 , key = " " ) : NEW_LINE INDENT if current and current . valid ( ) and level <= config . usage . setup_level . index : NEW_LINE INDENT menu . append ( ChoiceEntryComponent ( key , args ) ) NEW_LINE DEDENT DEDENT def removed_userbouquets_available ( ) : NEW_LINE INDENT for file in os . listdir ( " / etc / enigma2 / " ) : NEW_LINE INDENT if file . startswith ( " userbouquet " ) and file . endswith ( " . del " ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT class ChannelContextMenu ( Screen ) : NEW_LINE INDENT def __init__ ( self , session , csel ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . csel = csel NEW_LINE self . bsel = None NEW_LINE if self . isProtected ( ) : NEW_LINE INDENT self . onFirstExecBegin . append ( boundFunction ( self . session . openWithCallback , self . protectResult , PinInput , pinList = [ x . value for x in config . ParentalControl . servicepin ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Please ▁ enter ▁ the ▁ correct ▁ pin ▁ code " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) ) NEW_LINE DEDENT self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " ColorActions " , " NumberActions " , " MenuActions " ] , { " ok " : self . okbuttonClick , " cancel " : self . cancelClick , " blue " : self . showServiceInPiP , " red " : self . playMain , " menu " : self . openSetup , "2" : self . renameEntry , "3" : self . findCurrentlyPlayed , "5" : self . addServiceToBouquetOrAlternative , "6" : self . toggleMoveModeSelect , "8" : self . removeEntry } ) NEW_LINE menu = [ ] NEW_LINE self . removeFunction = False NEW_LINE self . addFunction = False NEW_LINE current = csel . getCurrentSelection ( ) NEW_LINE current_root = csel . getRoot ( ) NEW_LINE current_sel_path = current . getPath ( ) NEW_LINE current_sel_flags = current . flags NEW_LINE inBouquetRootList = current_root and ' FROM ▁ BOUQUET ▁ " bouquets . ' in current_root . getPath ( ) # FIXME ▁ HACK ENDCOM NEW_LINE inAlternativeList = current_root and ' FROM ▁ BOUQUET ▁ " alternatives ' in current_root . getPath ( ) NEW_LINE self . inBouquet = csel . getMutableList ( ) is not None NEW_LINE haveBouquets = config . usage . multibouquet . value NEW_LINE from Components . ParentalControl import parentalControl NEW_LINE self . parentalControl = parentalControl NEW_LINE self . parentalControlEnabled = config . ParentalControl . servicepin [ 0 ] . value and config . ParentalControl . servicepinactive . value NEW_LINE if not ( current_sel_path or current_sel_flags & ( eServiceReference . isDirectory | eServiceReference . isMarker ) ) or current_sel_flags & eServiceReference . isGroup : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " show ▁ transponder ▁ info " ) , self . showServiceInformations ) , level = 2 ) NEW_LINE DEDENT if csel . bouquet_mark_edit == OFF and not csel . entry_marked : NEW_LINE INDENT if not inBouquetRootList : NEW_LINE INDENT isPlayable = not ( current_sel_flags & ( eServiceReference . isMarker | eServiceReference . isDirectory ) ) NEW_LINE if isPlayable : NEW_LINE INDENT for p in plugins . getPlugins ( PluginDescriptor . WHERE_CHANNEL_CONTEXT_MENU ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( p . name , boundFunction ( self . runPlugin , p ) ) , key = " bullet " ) NEW_LINE DEDENT if config . servicelist . startupservice . value == current . toString ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " stop ▁ using ▁ as ▁ startup ▁ service " ) , self . unsetStartupService ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " set ▁ as ▁ startup ▁ service " ) , self . setStartupService ) , level = 0 ) NEW_LINE DEDENT if self . parentalControlEnabled : NEW_LINE INDENT if self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ to ▁ parental ▁ protection " ) , boundFunction ( self . addParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if self . parentalControl . isServiceProtectionBouquet ( current . toCompareString ( ) ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " service ▁ is ▁ in ▁ bouquet ▁ parental ▁ protection " ) , self . cancelClick ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ from ▁ parental ▁ protection " ) , boundFunction ( self . removeParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT DEDENT if config . ParentalControl . hideBlacklist . value and not parentalControl . sessionPinCached and config . ParentalControl . storeservicepin . value != " never " : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Unhide ▁ parental ▁ control ▁ services " ) , self . unhideParentalServices ) , level = 0 , key = "1" ) NEW_LINE DEDENT DEDENT if SystemInfo [ "3DMode " ] and fileExists ( " / usr / lib / enigma2 / python / Plugins / SystemPlugins / OSD3DSetup / plugin . py " ) : NEW_LINE INDENT if eDVBDB . getInstance ( ) . getFlag ( eServiceReference ( current . toString ( ) ) ) & FLAG_IS_DEDICATED_3D : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Unmark ▁ service ▁ as ▁ dedicated ▁ 3D ▁ service " ) , self . removeDedicated3DFlag ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Mark ▁ service ▁ as ▁ dedicated ▁ 3D ▁ service " ) , self . addDedicated3DFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT if not ( current_sel_path ) : NEW_LINE INDENT if eDVBDB . getInstance ( ) . getFlag ( eServiceReference ( current . toString ( ) ) ) & FLAG_HIDE_VBI : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Uncover ▁ dashed ▁ flickering ▁ line ▁ for ▁ this ▁ service " ) , self . removeHideVBIFlag ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Cover ▁ dashed ▁ flickering ▁ line ▁ for ▁ this ▁ service " ) , self . addHideVBIFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT if haveBouquets : NEW_LINE INDENT bouquets = self . csel . getBouquetList ( ) NEW_LINE if bouquets is None : NEW_LINE INDENT bouquetCnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT bouquetCnt = len ( bouquets ) NEW_LINE DEDENT if not self . inBouquet or bouquetCnt > 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ service ▁ to ▁ bouquet " ) , self . addServiceToBouquetSelected ) , level = 0 , key = "5" ) NEW_LINE self . addFunction = self . addServiceToBouquetSelected NEW_LINE DEDENT if not self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeSatelliteService NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ service ▁ to ▁ favourites " ) , self . addServiceToBouquetSelected ) , level = 0 , key = "5" ) NEW_LINE self . addFunction = self . addServiceToBouquetSelected NEW_LINE DEDENT DEDENT if SystemInfo [ " PIPAvailable " ] : NEW_LINE INDENT if not self . parentalControlEnabled or self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT if self . csel . dopipzap : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " play ▁ in ▁ mainwindow " ) , self . playMain ) , level = 0 , key = " red " ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " play ▁ as ▁ picture ▁ in ▁ picture " ) , self . showServiceInPiP ) , level = 0 , key = " blue " ) NEW_LINE DEDENT DEDENT DEDENT append_when_current_valid ( current , menu , ( _ ( " find ▁ currently ▁ played ▁ service " ) , self . findCurrentlyPlayed ) , level = 0 , key = "3" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ' FROM ▁ SATELLITES ' in current_root . getPath ( ) and current and _ ( " Services " ) in eServiceCenter . getInstance ( ) . info ( current ) . getName ( current ) : NEW_LINE INDENT unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ cable ▁ services " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ terrestrial ▁ services " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ selected ▁ satellite " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT DEDENT if haveBouquets : NEW_LINE INDENT if not self . inBouquet and not " PROVIDERS " in current_sel_path : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " copy ▁ to ▁ bouquets " ) , self . copyCurrentToBouquetList ) , level = 0 ) NEW_LINE DEDENT DEDENT if ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in current_sel_path : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ all ▁ new ▁ found ▁ flags " ) , self . removeAllNewFoundFlags ) , level = 0 ) NEW_LINE DEDENT DEDENT if self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE if not inAlternativeList : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeCurrentService NEW_LINE DEDENT DEDENT if current_root and ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in current_root . getPath ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ new ▁ found ▁ flag " ) , self . removeNewFoundFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . parentalControlEnabled : NEW_LINE INDENT if self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ bouquet ▁ to ▁ parental ▁ protection " ) , boundFunction ( self . addParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ bouquet ▁ from ▁ parental ▁ protection " ) , boundFunction ( self . removeParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT DEDENT menu . append ( ChoiceEntryComponent ( text = ( _ ( " add ▁ bouquet " ) , self . showBouquetInputBox ) ) ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeBouquet NEW_LINE if removed_userbouquets_available ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " purge ▁ deleted ▁ userbouquets " ) , self . purgeDeletedBouquets ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " restore ▁ deleted ▁ userbouquets " ) , self . restoreDeletedBouquets ) , level = 0 ) NEW_LINE DEDENT DEDENT DEDENT if self . inBouquet : # ▁ current ▁ list ▁ is ▁ editable ? ENDCOM NEW_LINE INDENT if csel . bouquet_mark_edit == OFF : NEW_LINE INDENT if csel . movemode : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " disable ▁ move ▁ mode " ) , self . toggleMoveMode ) , level = 0 , key = "6" ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ move ▁ mode " ) , self . toggleMoveMode ) , level = 1 , key = "6" ) NEW_LINE DEDENT if not csel . entry_marked and not inBouquetRootList and current_root and not ( current_root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT if current . type != - 1 : NEW_LINE INDENT menu . append ( ChoiceEntryComponent ( text = ( _ ( " add ▁ marker " ) , self . showMarkerInputBox ) ) ) NEW_LINE DEDENT if not csel . movemode : NEW_LINE INDENT if haveBouquets : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ bouquet ▁ edit " ) , self . bouquetMarkStart ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ favourite ▁ edit " ) , self . bouquetMarkStart ) , level = 0 ) NEW_LINE DEDENT DEDENT if current_sel_flags & eServiceReference . isGroup : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " edit ▁ alternatives " ) , self . editAlternativeServices ) , level = 2 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " show ▁ alternatives " ) , self . showAlternativeServices ) , level = 2 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ all ▁ alternatives " ) , self . removeAlternativeServices ) , level = 2 ) NEW_LINE DEDENT elif not current_sel_flags & eServiceReference . isMarker : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ alternatives " ) , self . addAlternativeServices ) , level = 2 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if csel . bouquet_mark_edit == EDIT_BOUQUET : NEW_LINE INDENT if haveBouquets : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ bouquet ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ bouquet ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ favourites ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ favourites ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT if current_sel_flags & eServiceReference . isMarker : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeCurrentService NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ alternatives ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ alternatives ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT DEDENT DEDENT menu . append ( ChoiceEntryComponent ( " menu " , ( _ ( " Configuration . . . " ) , self . openSetup ) ) ) NEW_LINE self [ " menu " ] = ChoiceList ( menu ) NEW_LINE DEDENT def set3DMode ( self , value ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE if config . plugins . OSD3DSetup . mode . value == " auto " and ( playingref and playingref == self . csel . getCurrentSelection ( ) ) : NEW_LINE INDENT from Plugins . SystemPlugins . OSD3DSetup . plugin import applySettings NEW_LINE applySettings ( value and " sidebyside " or config . plugins . OSD3DSetup . mode . value ) NEW_LINE DEDENT DEDENT def addDedicated3DFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . addFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_IS_DEDICATED_3D ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . set3DMode ( True ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeDedicated3DFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_IS_DEDICATED_3D ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . set3DMode ( False ) NEW_LINE self . close ( ) NEW_LINE DEDENT def addHideVBIFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . addFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_HIDE_VBI ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE Screens . InfoBar . InfoBar . instance . showHideVBI ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeHideVBIFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_HIDE_VBI ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE Screens . InfoBar . InfoBar . instance . showHideVBI ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def isProtected ( self ) : NEW_LINE INDENT return self . csel . protectContextMenu and config . ParentalControl . setuppinactive . value and config . ParentalControl . config_sections . context_menus . value NEW_LINE DEDENT def protectResult ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . csel . protectContextMenu = False NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def addServiceToBouquetOrAlternative ( self ) : NEW_LINE INDENT if self . addFunction : NEW_LINE INDENT self . addFunction ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def getCurrentSelectionName ( self ) : NEW_LINE INDENT cur = self . csel . getCurrentSelection ( ) NEW_LINE if cur and cur . valid ( ) : NEW_LINE INDENT name = eServiceCenter . getInstance ( ) . info ( cur ) . getName ( cur ) or ServiceReference ( cur ) . getServiceName ( ) or " " NEW_LINE name = name . replace ( ' \xc2\x86' , ' ' ) . replace ( ' \xc2\x87' , ' ' ) NEW_LINE return name NEW_LINE DEDENT return " " NEW_LINE DEDENT def removeEntry ( self ) : NEW_LINE INDENT if self . removeFunction and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT if self . csel . confirmRemove : NEW_LINE INDENT list = [ ( _ ( " yes " ) , True ) , ( _ ( " no " ) , False ) , ( _ ( " yes " ) + " ▁ " + _ ( " and ▁ never ▁ ask ▁ again ▁ this ▁ session ▁ again " ) , " never " ) ] NEW_LINE self . session . openWithCallback ( self . removeFunction , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ this ▁ entry ? " ) + " \n % s " % self . getCurrentSelectionName ( ) , list = list ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeFunction ( True ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def removeCurrentService ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . csel . confirmRemove = False NEW_LINE DEDENT self . csel . removeCurrentService ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def removeSatelliteService ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . csel . confirmRemove = False NEW_LINE DEDENT self . csel . removeSatelliteService ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def removeBouquet ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . csel . removeBouquet ( ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def purgeDeletedBouquets ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . purgeDeletedBouquetsCallback , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ purge ▁ all ▁ deleted ▁ userbouquets ? " ) ) NEW_LINE DEDENT def purgeDeletedBouquetsCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT for file in os . listdir ( " / etc / enigma2 / " ) : NEW_LINE INDENT if file . startswith ( " userbouquet " ) and file . endswith ( " . del " ) : NEW_LINE INDENT file = " / etc / enigma2 / " + file NEW_LINE print " permantly ▁ remove ▁ file ▁ " , file NEW_LINE os . remove ( file ) NEW_LINE DEDENT DEDENT self . close ( ) NEW_LINE DEDENT DEDENT def restoreDeletedBouquets ( self ) : NEW_LINE INDENT for file in os . listdir ( " / etc / enigma2 / " ) : NEW_LINE INDENT if file . startswith ( " userbouquet " ) and file . endswith ( " . del " ) : NEW_LINE INDENT file = " / etc / enigma2 / " + file NEW_LINE print " restore ▁ file ▁ " , file [ : - 4 ] NEW_LINE os . rename ( file , file [ : - 4 ] ) NEW_LINE DEDENT DEDENT eDVBDBInstance = eDVBDB . getInstance ( ) NEW_LINE eDVBDBInstance . setLoadUnlinkedUserbouquets ( True ) NEW_LINE eDVBDBInstance . reloadBouquets ( ) NEW_LINE eDVBDBInstance . setLoadUnlinkedUserbouquets ( config . misc . load_unlinked_userbouquets . value ) NEW_LINE refreshServiceList ( ) NEW_LINE self . csel . showFavourites ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def playMain ( self ) : NEW_LINE INDENT sel = self . csel . getCurrentSelection ( ) NEW_LINE if sel and sel . valid ( ) and self . csel . dopipzap and ( not self . parentalControlEnabled or self . parentalControl . getProtectionLevel ( self . csel . getCurrentSelection ( ) . toCompareString ( ) ) == - 1 ) : NEW_LINE INDENT self . csel . zap ( ) NEW_LINE self . csel . setCurrentSelection ( sel ) NEW_LINE self . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def okbuttonClick ( self ) : NEW_LINE INDENT self [ " menu " ] . getCurrent ( ) [ 0 ] [ 1 ] ( ) NEW_LINE DEDENT def openSetup ( self ) : NEW_LINE INDENT from Screens . Setup import Setup NEW_LINE self . session . openWithCallback ( self . cancelClick , Setup , " userinterface " ) NEW_LINE DEDENT def cancelClick ( self , dummy = False ) : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT def showServiceInformations ( self ) : NEW_LINE INDENT current = self . csel . getCurrentSelection ( ) NEW_LINE if current . flags & eServiceReference . isGroup : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref and playingref == current : NEW_LINE INDENT current = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current = eServiceReference ( GetWithAlternative ( current . toString ( ) ) ) NEW_LINE DEDENT DEDENT self . session . open ( ServiceInfo , current ) NEW_LINE self . close ( ) NEW_LINE DEDENT def setStartupService ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . setStartupServiceCallback , MessageBox , _ ( " Set ▁ startup ▁ service " ) , list = [ ( _ ( " Only ▁ on ▁ startup " ) , " startup " ) , ( _ ( " Also ▁ on ▁ standby " ) , " standby " ) ] ) NEW_LINE DEDENT def setStartupServiceCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT config . servicelist . startupservice . value = self . csel . getCurrentSelection ( ) . toString ( ) NEW_LINE path = ' ; ' . join ( [ i . toString ( ) for i in self . csel . servicePath ] ) NEW_LINE config . servicelist . startuproot . value = path NEW_LINE config . servicelist . startupmode . value = config . servicelist . lastmode . value NEW_LINE config . servicelist . startupservice_onstandby . value = answer == " standby " NEW_LINE config . servicelist . save ( ) NEW_LINE configfile . save ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def unsetStartupService ( self ) : NEW_LINE INDENT config . servicelist . startupservice . value = ' ' NEW_LINE config . servicelist . startupservice_onstandby . value = False NEW_LINE config . servicelist . save ( ) NEW_LINE configfile . save ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def showBouquetInputBox ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . bouquetInputCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ a ▁ name ▁ for ▁ the ▁ new ▁ bouquet " ) , text = " bouquetname " , maxSize = False , visible_width = 56 , type = Input . TEXT ) NEW_LINE DEDENT def bouquetInputCallback ( self , bouquet ) : NEW_LINE INDENT if bouquet is not None : NEW_LINE INDENT self . csel . addBouquet ( bouquet , None ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT def addParentalProtection ( self , service ) : NEW_LINE INDENT self . parentalControl . protectService ( service . toCompareString ( ) ) NEW_LINE if config . ParentalControl . hideBlacklist . value and not self . parentalControl . sessionPinCached : NEW_LINE INDENT self . csel . servicelist . resetRoot ( ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT def removeParentalProtection ( self , service ) : NEW_LINE INDENT self . session . openWithCallback ( boundFunction ( self . pinEntered , service . toCompareString ( ) ) , PinInput , pinList = [ config . ParentalControl . servicepin [ 0 ] . value ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Enter ▁ the ▁ service ▁ pin " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) NEW_LINE DEDENT def pinEntered ( self , service , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . parentalControl . unProtectService ( service ) NEW_LINE self . close ( ) NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def unhideParentalServices ( self ) : NEW_LINE INDENT if self . csel . protectContextMenu : NEW_LINE INDENT self . session . openWithCallback ( self . unhideParentalServicesCallback , PinInput , pinList = [ config . ParentalControl . servicepin [ 0 ] . value ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Enter ▁ the ▁ service ▁ pin " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . unhideParentalServicesCallback ( True ) NEW_LINE DEDENT DEDENT def unhideParentalServicesCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT service = self . csel . servicelist . getCurrent ( ) NEW_LINE self . parentalControl . setSessionPinCached ( ) NEW_LINE self . parentalControl . hideBlacklist ( ) NEW_LINE self . csel . servicelist . resetRoot ( ) NEW_LINE self . csel . servicelist . setCurrent ( service ) NEW_LINE self . close ( ) NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def showServiceInPiP ( self ) : NEW_LINE INDENT if self . csel . dopipzap or ( self . parentalControlEnabled and not self . parentalControl . getProtectionLevel ( self . csel . getCurrentSelection ( ) . toCompareString ( ) ) == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if self . session . pipshown : NEW_LINE INDENT del self . session . pip NEW_LINE DEDENT self . session . pip = self . session . instantiateDialog ( PictureInPicture ) NEW_LINE self . session . pip . show ( ) NEW_LINE newservice = self . csel . servicelist . getCurrent ( ) NEW_LINE currentBouquet = self . csel . servicelist and self . csel . servicelist . getRoot ( ) NEW_LINE if newservice and newservice . valid ( ) : NEW_LINE INDENT if self . session . pip . playService ( newservice ) : NEW_LINE INDENT self . session . pipshown = True NEW_LINE self . session . pip . servicePath = self . csel . getCurrentServicePath ( ) NEW_LINE self . session . pip . servicePath [ 1 ] = currentBouquet NEW_LINE self . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . session . pipshown = False NEW_LINE del self . session . pip NEW_LINE self . session . openWithCallback ( self . close , MessageBox , _ ( " Could ▁ not ▁ open ▁ Picture ▁ in ▁ Picture " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def addServiceToBouquetSelected ( self ) : NEW_LINE INDENT bouquets = self . csel . getBouquetList ( ) NEW_LINE if bouquets is None : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = len ( bouquets ) NEW_LINE DEDENT if cnt > 1 : # ▁ show ▁ bouquet ▁ list ENDCOM NEW_LINE INDENT self . bsel = self . session . openWithCallback ( self . bouquetSelClosed , BouquetSelector , bouquets , self . addCurrentServiceToBouquet ) NEW_LINE DEDENT elif cnt == 1 : # ▁ add ▁ to ▁ only ▁ one ▁ existing ▁ bouquet ENDCOM NEW_LINE INDENT self . addCurrentServiceToBouquet ( bouquets [ 0 ] [ 1 ] , closeBouquetSelection = False ) NEW_LINE DEDENT DEDENT def bouquetSelClosed ( self , recursive ) : NEW_LINE INDENT self . bsel = None NEW_LINE if recursive : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT DEDENT def removeSatelliteServices ( self ) : NEW_LINE INDENT self . csel . removeSatelliteServices ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def copyCurrentToBouquetList ( self ) : NEW_LINE INDENT self . csel . copyCurrentToBouquetList ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def showMarkerInputBox ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . markerInputCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ a ▁ name ▁ for ▁ the ▁ new ▁ marker " ) , text = " markername " , maxSize = False , visible_width = 56 , type = Input . TEXT ) NEW_LINE DEDENT def markerInputCallback ( self , marker ) : NEW_LINE INDENT if marker is not None : NEW_LINE INDENT self . csel . addMarker ( marker ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT def addCurrentServiceToBouquet ( self , dest , closeBouquetSelection = True ) : NEW_LINE INDENT self . csel . addServiceToBouquet ( dest ) NEW_LINE if self . bsel is not None : NEW_LINE INDENT self . bsel . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( closeBouquetSelection ) # ▁ close ▁ bouquet ▁ selection ENDCOM NEW_LINE DEDENT DEDENT def renameEntry ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) and not self . csel . entry_marked : NEW_LINE INDENT self . csel . renameEntry ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def toggleMoveMode ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT self . csel . toggleMoveMode ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def toggleMoveModeSelect ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT self . csel . toggleMoveMode ( True ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def bouquetMarkStart ( self ) : NEW_LINE INDENT self . csel . startMarkedEdit ( EDIT_BOUQUET ) NEW_LINE self . close ( ) NEW_LINE DEDENT def bouquetMarkEnd ( self ) : NEW_LINE INDENT self . csel . endMarkedEdit ( abort = False ) NEW_LINE self . close ( ) NEW_LINE DEDENT def bouquetMarkAbort ( self ) : NEW_LINE INDENT self . csel . endMarkedEdit ( abort = True ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeNewFoundFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( self . csel . getCurrentSelection ( ) , FLAG_SERVICE_NEW_FOUND ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeAllNewFoundFlags ( self ) : NEW_LINE INDENT curpath = self . csel . getCurrentSelection ( ) . getPath ( ) NEW_LINE idx = curpath . find ( " satellitePosition ▁ = = ▁ " ) NEW_LINE if idx != - 1 : NEW_LINE INDENT tmp = curpath [ idx + 21 : ] NEW_LINE idx = tmp . find ( ' ) ' ) NEW_LINE if idx != - 1 : NEW_LINE INDENT satpos = int ( tmp [ : idx ] ) NEW_LINE eDVBDB . getInstance ( ) . removeFlags ( FLAG_SERVICE_NEW_FOUND , - 1 , - 1 , - 1 , satpos ) NEW_LINE DEDENT DEDENT self . close ( ) NEW_LINE DEDENT def editAlternativeServices ( self ) : NEW_LINE INDENT self . csel . startMarkedEdit ( EDIT_ALTERNATIVES ) NEW_LINE self . close ( ) NEW_LINE DEDENT def showAlternativeServices ( self ) : NEW_LINE INDENT self . csel [ " Service " ] . editmode = True NEW_LINE self . csel . enterPath ( self . csel . getCurrentSelection ( ) ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeAlternativeServices ( self ) : NEW_LINE INDENT self . csel . removeAlternativeServices ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def addAlternativeServices ( self ) : NEW_LINE INDENT self . csel . addAlternativeServices ( ) NEW_LINE self . csel . startMarkedEdit ( EDIT_ALTERNATIVES ) NEW_LINE self . close ( ) NEW_LINE DEDENT def findCurrentlyPlayed ( self ) : NEW_LINE INDENT sel = self . csel . getCurrentSelection ( ) NEW_LINE if sel and sel . valid ( ) and not self . csel . entry_marked : NEW_LINE INDENT currentPlayingService = ( hasattr ( self . csel , " dopipzap " ) and self . csel . dopipzap ) and self . session . pip . getCurrentService ( ) or self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE self . csel . servicelist . setCurrent ( currentPlayingService , adjust = False ) NEW_LINE if self . csel . getCurrentSelection ( ) != currentPlayingService : NEW_LINE INDENT self . csel . setCurrentSelection ( sel ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def runPlugin ( self , plugin ) : NEW_LINE INDENT plugin ( session = self . session , service = self . csel . getCurrentSelection ( ) ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT class SelectionEventInfo : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self [ " Service " ] = self [ " ServiceEvent " ] = ServiceEvent ( ) NEW_LINE self [ " Event " ] = Event ( ) NEW_LINE self . servicelist . connectSelChanged ( self . __selectionChanged ) NEW_LINE self . timer = eTimer ( ) NEW_LINE self . timer . callback . append ( self . updateEventInfo ) NEW_LINE self . onShown . append ( self . __selectionChanged ) NEW_LINE DEDENT def __selectionChanged ( self ) : NEW_LINE INDENT if self . execing : NEW_LINE INDENT self . timer . start ( 100 , True ) NEW_LINE DEDENT DEDENT def updateEventInfo ( self ) : NEW_LINE INDENT cur = self . getCurrentSelection ( ) NEW_LINE service = self [ " Service " ] NEW_LINE service . newService ( cur ) NEW_LINE self [ " Event " ] . newEvent ( service . event ) NEW_LINE DEDENT DEDENT class ChannelSelectionEPG ( InfoBarHotkey ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . hotkeys = [ ( " Info ▁ ( EPG ) " , " info " , " Infobar / openEventView " ) , ( " Info ▁ ( EPG ) " + " ▁ " + _ ( " long " ) , " info _ long " , " Infobar / showEventInfoPlugins " ) , ( " Epg / Guide " , " epg " , " Plugins / Extensions / GraphMultiEPG / 1" ) , ( " Epg / Guide " + " ▁ " + _ ( " long " ) , " epg _ long " , " Infobar / showEventInfoPlugins " ) ] NEW_LINE self [ " ChannelSelectEPGActions " ] = hotkeyActionMap ( [ " ChannelSelectEPGActions " ] , dict ( ( x [ 1 ] , self . hotkeyGlobal ) for x in self . hotkeys ) ) NEW_LINE self . eventViewEPG = self . start_bouquet = self . epg_bouquet = None NEW_LINE self . currentSavedPath = [ ] NEW_LINE DEDENT def getKeyFunctions ( self , key ) : NEW_LINE INDENT selection = eval ( " config . misc . hotkey . " + key + " . value . split ( ' , ' ) " ) NEW_LINE selected = [ ] NEW_LINE for x in selection : NEW_LINE INDENT function = list ( function for function in getHotkeyFunctions ( ) if function [ 1 ] == x and function [ 2 ] == " EPG " ) NEW_LINE if function : NEW_LINE INDENT selected . append ( function [ 0 ] ) NEW_LINE DEDENT DEDENT return selected NEW_LINE DEDENT def runPlugin ( self , plugin ) : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . runPlugin ( plugin ) NEW_LINE DEDENT def getEPGPluginList ( self , getAll = False ) : NEW_LINE INDENT pluginlist = [ ( p . name , boundFunction ( self . runPlugin , p ) , p . path ) for p in plugins . getPlugins ( where = PluginDescriptor . WHERE_EVENTINFO ) if ' selectedevent ' not in p . __call__ . func_code . co_varnames ] or [ ] NEW_LINE from Components . ServiceEventTracker import InfoBarCount NEW_LINE if getAll or InfoBarCount == 1 : NEW_LINE INDENT pluginlist . append ( ( _ ( " Show ▁ EPG ▁ for ▁ current ▁ channel . . . " ) , self . openSingleServiceEPG , " current _ channel " ) ) NEW_LINE DEDENT pluginlist . append ( ( _ ( " Multi ▁ EPG " ) , self . openMultiServiceEPG , " multi _ epg " ) ) NEW_LINE pluginlist . append ( ( _ ( " Current ▁ event ▁ EPG " ) , self . openEventView , " event _ epg " ) ) NEW_LINE return pluginlist NEW_LINE DEDENT def showEventInfoPlugins ( self ) : NEW_LINE INDENT pluginlist = self . getEPGPluginList ( ) NEW_LINE if pluginlist : NEW_LINE INDENT self . session . openWithCallback ( self . EventInfoPluginChosen , ChoiceBox , title = _ ( " Please ▁ choose ▁ an ▁ extension . . . " ) , list = pluginlist , skin_name = " EPGExtensionsList " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . openSingleServiceEPG ( ) NEW_LINE DEDENT DEDENT def EventInfoPluginChosen ( self , answer ) : NEW_LINE INDENT if answer is not None : NEW_LINE INDENT answer [ 1 ] ( ) NEW_LINE DEDENT DEDENT def openEventView ( self ) : NEW_LINE INDENT epglist = [ ] NEW_LINE self . epglist = epglist NEW_LINE ref = self . getCurrentSelection ( ) NEW_LINE epg = eEPGCache . getInstance ( ) NEW_LINE now_event = epg . lookupEventTime ( ref , - 1 , 0 ) NEW_LINE if now_event : NEW_LINE INDENT epglist . append ( now_event ) NEW_LINE next_event = epg . lookupEventTime ( ref , - 1 , 1 ) NEW_LINE if next_event : NEW_LINE INDENT epglist . append ( next_event ) NEW_LINE DEDENT DEDENT if epglist : NEW_LINE INDENT self . eventViewEPG = self . session . openWithCallback ( self . eventViewEPGClosed , EventViewEPGSelect , epglist [ 0 ] , ServiceReference ( ref ) , self . eventViewEPGCallback , self . openSingleServiceEPG , self . openMultiServiceEPG , self . openSimilarList ) NEW_LINE DEDENT DEDENT def eventViewEPGCallback ( self , setEvent , setService , val ) : NEW_LINE INDENT epglist = self . epglist NEW_LINE if len ( epglist ) > 1 : NEW_LINE INDENT tmp = epglist [ 0 ] NEW_LINE epglist [ 0 ] = epglist [ 1 ] NEW_LINE epglist [ 1 ] = tmp NEW_LINE setEvent ( epglist [ 0 ] ) NEW_LINE DEDENT DEDENT def eventViewEPGClosed ( self , ret = False ) : NEW_LINE INDENT self . eventViewEPG = None NEW_LINE if ret : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def openMultiServiceEPG ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref : NEW_LINE INDENT self . start_bouquet = self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE self . savedService = ref NEW_LINE self . currentSavedPath = self . servicePath [ : ] NEW_LINE services = self . getServicesList ( self . servicelist . getRoot ( ) ) NEW_LINE self . session . openWithCallback ( self . SingleMultiEPGClosed , EPGSelection , services , self . zapToService , None , bouquetChangeCB = self . changeBouquetForMultiEPG ) NEW_LINE DEDENT DEDENT def openSingleServiceEPG ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref : NEW_LINE INDENT self . start_bouquet = self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE self . savedService = ref NEW_LINE self . currentSavedPath = self . servicePath [ : ] NEW_LINE self . session . openWithCallback ( self . SingleMultiEPGClosed , EPGSelection , ref , self . zapToService , serviceChangeCB = self . changeServiceCB , bouquetChangeCB = self . changeBouquetForSingleEPG ) NEW_LINE DEDENT DEDENT def openSimilarList ( self , eventid , refstr ) : NEW_LINE INDENT self . session . open ( EPGSelection , refstr , None , eventid ) NEW_LINE DEDENT def getServicesList ( self , root ) : NEW_LINE INDENT services = [ ] NEW_LINE servicelist = root and eServiceCenter . getInstance ( ) . list ( root ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT service = servicelist . getNext ( ) NEW_LINE if not service . valid ( ) : NEW_LINE INDENT break NEW_LINE DEDENT if service . flags & ( eServiceReference . isDirectory | eServiceReference . isMarker ) : NEW_LINE INDENT continue NEW_LINE DEDENT services . append ( ServiceReference ( service ) ) NEW_LINE DEDENT DEDENT return services NEW_LINE DEDENT def SingleMultiEPGClosed ( self , ret = False ) : NEW_LINE INDENT if ret : NEW_LINE INDENT service = self . getCurrentSelection ( ) NEW_LINE if self . eventViewEPG : NEW_LINE INDENT self . eventViewEPG . close ( service ) NEW_LINE DEDENT elif service is not None : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . start_bouquet != self . epg_bouquet and len ( self . currentSavedPath ) > 0 : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( self . bouquet_root ) NEW_LINE self . epg_bouquet = self . start_bouquet NEW_LINE self . enterPath ( self . epg_bouquet ) NEW_LINE DEDENT self . setCurrentSelection ( self . savedService ) NEW_LINE DEDENT DEDENT def changeBouquetForSingleEPG ( self , direction , epg ) : NEW_LINE INDENT if config . usage . multibouquet . value : NEW_LINE INDENT inBouquet = self . getMutableList ( ) is not None NEW_LINE if inBouquet and len ( self . servicePath ) > 1 : NEW_LINE INDENT self . pathUp ( ) NEW_LINE if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( cur ) NEW_LINE self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE epg . setService ( ServiceReference ( self . getCurrentSelection ( ) ) ) NEW_LINE DEDENT DEDENT DEDENT def changeBouquetForMultiEPG ( self , direction , epg ) : NEW_LINE INDENT if config . usage . multibouquet . value : NEW_LINE INDENT inBouquet = self . getMutableList ( ) is not None NEW_LINE if inBouquet and len ( self . servicePath ) > 1 : NEW_LINE INDENT self . pathUp ( ) NEW_LINE if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( cur ) NEW_LINE self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE services = self . getServicesList ( self . epg_bouquet ) NEW_LINE epg . setServices ( services ) NEW_LINE DEDENT DEDENT DEDENT def changeServiceCB ( self , direction , epg ) : NEW_LINE INDENT beg = self . getCurrentSelection ( ) NEW_LINE while True : NEW_LINE INDENT if direction > 0 : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE if cur == beg or not ( cur . flags & eServiceReference . isMarker ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT epg . setService ( ServiceReference ( self . getCurrentSelection ( ) ) ) NEW_LINE DEDENT def zapToService ( self , service , preview = False , zapback = False ) : NEW_LINE INDENT if self . startServiceRef is None : NEW_LINE INDENT self . startServiceRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE DEDENT if service is not None : NEW_LINE INDENT if self . servicelist . getRoot ( ) != self . epg_bouquet : NEW_LINE INDENT self . servicelist . clearPath ( ) NEW_LINE if self . servicelist . bouquet_root != self . epg_bouquet : NEW_LINE INDENT self . servicelist . enterPath ( self . servicelist . bouquet_root ) NEW_LINE DEDENT self . servicelist . enterPath ( self . epg_bouquet ) NEW_LINE DEDENT self . servicelist . setCurrent ( service ) NEW_LINE DEDENT if not zapback or preview : NEW_LINE INDENT self . zap ( enable_pipzap = True ) NEW_LINE DEDENT if ( self . dopipzap or zapback ) and not preview : NEW_LINE INDENT self . zapBack ( ) NEW_LINE DEDENT if not preview : NEW_LINE INDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT DEDENT class ChannelSelectionEdit : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . entry_marked = False NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE self . mutableList = None NEW_LINE self . __marked = [ ] NEW_LINE self . saved_title = None NEW_LINE self . saved_root = None NEW_LINE self . current_ref = None NEW_LINE self . editMode = False NEW_LINE self . confirmRemove = True NEW_LINE class ChannelSelectionEditActionMap ( ActionMap ) : NEW_LINE INDENT def __init__ ( self , csel , contexts = [ ] , actions = { } , prio = 0 ) : NEW_LINE INDENT ActionMap . __init__ ( self , contexts , actions , prio ) NEW_LINE self . csel = csel NEW_LINE DEDENT def action ( self , contexts , action ) : NEW_LINE INDENT if action == " cancel " : NEW_LINE INDENT self . csel . handleEditCancel ( ) NEW_LINE return 0 # ▁ fall - trough ENDCOM NEW_LINE DEDENT elif action == " ok " : NEW_LINE INDENT return 0 # ▁ fall - trough ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT return ActionMap . action ( self , contexts , action ) NEW_LINE DEDENT DEDENT DEDENT self [ " ChannelSelectEditActions " ] = ChannelSelectionEditActionMap ( self , [ " ChannelSelectEditActions " , " OkCancelActions " ] , { " contextMenu " : self . doContext , } ) NEW_LINE DEDENT def getMutableList ( self , root = eServiceReference ( ) ) : NEW_LINE INDENT if not self . mutableList is None : NEW_LINE INDENT return self . mutableList NEW_LINE DEDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE if not root . valid ( ) : NEW_LINE INDENT root = self . getRoot ( ) NEW_LINE DEDENT list = root and serviceHandler . list ( root ) NEW_LINE if list is not None : NEW_LINE INDENT return list . startEdit ( ) NEW_LINE DEDENT return None NEW_LINE DEDENT def buildBouquetID ( self , name ) : NEW_LINE INDENT name = unicodedata . normalize ( ' NFKD ' , unicode ( name , ' utf _ 8' , errors = ' ignore ' ) ) . encode ( ' ASCII ' , ' ignore ' ) . translate ( None , ' < > : " / \ | ? * ( ) ▁ ' ) NEW_LINE while os . path . isfile ( ( self . mode == MODE_TV and " / etc / enigma2 / userbouquet . % s . tv " or " / etc / enigma2 / userbouquet . % s . radio " ) % name ) : NEW_LINE INDENT name = name . rsplit ( " _ " , 1 ) NEW_LINE name = " _ " . join ( ( name [ 0 ] , len ( name ) == 2 and name [ 1 ] . isdigit ( ) and str ( int ( name [ 1 ] ) + 1 ) or "1" ) ) NEW_LINE DEDENT return name NEW_LINE DEDENT def renameEntry ( self ) : NEW_LINE INDENT self . editMode = True NEW_LINE cur = self . getCurrentSelection ( ) NEW_LINE if cur and cur . valid ( ) : NEW_LINE INDENT name = eServiceCenter . getInstance ( ) . info ( cur ) . getName ( cur ) or ServiceReference ( cur ) . getServiceName ( ) or " " NEW_LINE name = name . replace ( ' \xc2\x86' , ' ' ) . replace ( ' \xc2\x87' , ' ' ) NEW_LINE if name : NEW_LINE INDENT self . session . openWithCallback ( self . renameEntryCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ new ▁ name : " ) , text = name ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def renameEntryCallback ( self , name ) : NEW_LINE INDENT if name : NEW_LINE INDENT mutableList = self . getMutableList ( ) NEW_LINE if mutableList : NEW_LINE INDENT current = self . servicelist . getCurrent ( ) NEW_LINE current . setName ( name ) NEW_LINE index = self . servicelist . getCurrentIndex ( ) NEW_LINE mutableList . removeService ( current , False ) NEW_LINE mutableList . addService ( current ) NEW_LINE mutableList . moveService ( current , index ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE self . servicelist . addService ( current , True ) NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE if not self . servicelist . atEnd ( ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def addMarker ( self , name ) : NEW_LINE INDENT current = self . servicelist . getCurrent ( ) NEW_LINE mutableList = self . getMutableList ( ) NEW_LINE cnt = 0 NEW_LINE while mutableList : NEW_LINE INDENT str = '1:64 : % d : 0:0:0:0:0:0:0 : : % s ' % ( cnt , name ) NEW_LINE ref = eServiceReference ( str ) NEW_LINE if current and current . valid ( ) : NEW_LINE INDENT if not mutableList . addService ( ref , current ) : NEW_LINE INDENT self . servicelist . addService ( ref , True ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE break NEW_LINE DEDENT DEDENT elif not mutableList . addService ( ref ) : NEW_LINE INDENT self . servicelist . addService ( ref , True ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE break NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT DEDENT def addAlternativeServices ( self ) : NEW_LINE INDENT cur_service = ServiceReference ( self . getCurrentSelection ( ) ) NEW_LINE end = self . atEnd ( ) NEW_LINE root = self . getRoot ( ) NEW_LINE cur_root = root and ServiceReference ( root ) NEW_LINE mutableBouquet = cur_root . list ( ) . startEdit ( ) NEW_LINE if mutableBouquet : NEW_LINE INDENT name = cur_service . getServiceName ( ) NEW_LINE refstr = ' _ ' . join ( cur_service . ref . toString ( ) . split ( ' : ' ) ) NEW_LINE if self . mode == MODE_TV : NEW_LINE INDENT str = '1:134:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ \ " alternatives . % s . tv\ " ▁ ORDER ▁ BY ▁ bouquet ' % ( refstr ) NEW_LINE DEDENT else : NEW_LINE INDENT str = '1:134:2:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ \ " alternatives . % s . radio\ " ▁ ORDER ▁ BY ▁ bouquet ' % ( refstr ) NEW_LINE DEDENT new_ref = ServiceReference ( str ) NEW_LINE if not mutableBouquet . addService ( new_ref . ref , cur_service . ref ) : NEW_LINE INDENT mutableBouquet . removeService ( cur_service . ref ) NEW_LINE mutableBouquet . flushChanges ( ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE mutableAlternatives = new_ref . list ( ) . startEdit ( ) NEW_LINE if mutableAlternatives : NEW_LINE INDENT mutableAlternatives . setListName ( name ) NEW_LINE if mutableAlternatives . addService ( cur_service . ref ) : NEW_LINE INDENT print " add " , cur_service . ref . toString ( ) , " to ▁ new ▁ alternatives ▁ failed " NEW_LINE DEDENT mutableAlternatives . flushChanges ( ) NEW_LINE self . servicelist . addService ( new_ref . ref , True ) NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE if not end : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT if cur_service . ref . toString ( ) == self . lastservice . value : NEW_LINE INDENT self . saveChannel ( new_ref . ref ) NEW_LINE DEDENT if self . startServiceRef and cur_service . ref == self . startServiceRef : NEW_LINE INDENT self . startServiceRef = new_ref . ref NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " get ▁ mutable ▁ list ▁ for ▁ new ▁ created ▁ alternatives ▁ failed " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " add " , str , " to " , cur_root . getServiceName ( ) , " failed " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " bouquetlist ▁ is ▁ not ▁ editable " NEW_LINE DEDENT DEDENT def addBouquet ( self , bName , services ) : NEW_LINE INDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE mutableBouquetList = serviceHandler . list ( self . bouquet_root ) . startEdit ( ) NEW_LINE if mutableBouquetList : NEW_LINE INDENT bName = self . buildBouquetID ( bName ) NEW_LINE new_bouquet_ref = eServiceReference ( ( self . mode == MODE_TV and '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " userbouquet . % s . tv " ▁ ORDER ▁ BY ▁ bouquet ' or '1:7:2:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " userbouquet . % s . radio " ▁ ORDER ▁ BY ▁ bouquet ' ) % bName ) NEW_LINE if not mutableBouquetList . addService ( new_bouquet_ref ) : NEW_LINE INDENT mutableBouquetList . flushChanges ( ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE mutableBouquet = serviceHandler . list ( new_bouquet_ref ) . startEdit ( ) NEW_LINE if mutableBouquet : NEW_LINE INDENT mutableBouquet . setListName ( bName ) NEW_LINE if services is not None : NEW_LINE INDENT for service in services : NEW_LINE INDENT if mutableBouquet . addService ( service ) : NEW_LINE INDENT print " add " , service . toString ( ) , " to ▁ new ▁ bouquet ▁ failed " NEW_LINE DEDENT DEDENT DEDENT mutableBouquet . flushChanges ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print " get ▁ mutable ▁ list ▁ for ▁ new ▁ created ▁ bouquet ▁ failed " NEW_LINE # ▁ do ▁ some ▁ voodoo ▁ to ▁ check ▁ if ▁ current _ root ▁ is ▁ equal ▁ to ▁ bouquet _ root ENDCOM DEDENT cur_root = self . getRoot ( ) ; NEW_LINE str1 = cur_root and cur_root . toString ( ) NEW_LINE pos1 = str1 and str1 . find ( " FROM ▁ BOUQUET " ) or - 1 NEW_LINE pos2 = self . bouquet_rootstr . find ( " FROM ▁ BOUQUET " ) NEW_LINE if pos1 != - 1 and pos2 != - 1 and str1 [ pos1 : ] == self . bouquet_rootstr [ pos2 : ] : NEW_LINE INDENT self . servicelist . addService ( new_bouquet_ref ) NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " add " , str , " to ▁ bouquets ▁ failed " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " bouquetlist ▁ is ▁ not ▁ editable " NEW_LINE DEDENT DEDENT def copyCurrentToBouquetList ( self ) : NEW_LINE INDENT provider = ServiceReference ( self . getCurrentSelection ( ) ) NEW_LINE providerName = provider . getServiceName ( ) NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE services = serviceHandler . list ( provider . ref ) NEW_LINE self . addBouquet ( providerName , services and services . getContent ( ' R ' , True ) ) NEW_LINE DEDENT def removeAlternativeServices ( self ) : NEW_LINE INDENT cur_service = ServiceReference ( self . getCurrentSelection ( ) ) NEW_LINE end = self . atEnd ( ) NEW_LINE root = self . getRoot ( ) NEW_LINE cur_root = root and ServiceReference ( root ) NEW_LINE list = cur_service . list ( ) NEW_LINE first_in_alternative = list and list . getNext ( ) NEW_LINE if first_in_alternative : NEW_LINE INDENT edit_root = cur_root and cur_root . list ( ) . startEdit ( ) NEW_LINE if edit_root : NEW_LINE INDENT if not edit_root . addService ( first_in_alternative , cur_service . ref ) : NEW_LINE INDENT self . servicelist . addService ( first_in_alternative , True ) NEW_LINE if cur_service . ref . toString ( ) == self . lastservice . value : NEW_LINE INDENT self . saveChannel ( first_in_alternative ) NEW_LINE DEDENT if self . startServiceRef and cur_service . ref == self . startServiceRef : NEW_LINE INDENT self . startServiceRef = first_in_alternative NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " couldn ' t ▁ add ▁ first ▁ alternative ▁ service ▁ to ▁ current ▁ root " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " couldn ' t ▁ edit ▁ current ▁ root ! ! " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " remove ▁ empty ▁ alternative ▁ list ▁ ! ! " NEW_LINE DEDENT self . removeBouquet ( ) NEW_LINE if not end : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT def removeBouquet ( self ) : NEW_LINE INDENT refstr = self . getCurrentSelection ( ) . toString ( ) NEW_LINE print " removeBouquet " , refstr NEW_LINE pos = refstr . find ( ' FROM ▁ BOUQUET ▁ " ' ) NEW_LINE filename = None NEW_LINE self . removeCurrentService ( bouquet = True ) NEW_LINE DEDENT def removeSatelliteService ( self ) : NEW_LINE INDENT current = self . getCurrentSelection ( ) NEW_LINE eDVBDB . getInstance ( ) . removeService ( current ) NEW_LINE refreshServiceList ( ) NEW_LINE if not self . atEnd ( ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT def removeSatelliteServices ( self ) : NEW_LINE INDENT current = self . getCurrentSelection ( ) NEW_LINE unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ cable ▁ services ? " ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ terrestrial ▁ services ? " ) NEW_LINE DEDENT else : NEW_LINE INDENT if unsigned_orbpos > 1800 : NEW_LINE INDENT unsigned_orbpos = 3600 - unsigned_orbpos NEW_LINE direction = _ ( " W " ) NEW_LINE DEDENT else : NEW_LINE INDENT direction = _ ( " E " ) NEW_LINE DEDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ % d . % d % s % s ▁ services ? " ) % ( unsigned_orbpos / 10 , unsigned_orbpos % 10 , " \xc2\xb0" , direction ) NEW_LINE DEDENT self . session . openWithCallback ( self . removeSatelliteServicesCallback , MessageBox , messageText ) NEW_LINE DEDENT def removeSatelliteServicesCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT currentIndex = self . servicelist . getCurrentIndex ( ) NEW_LINE current = self . getCurrentSelection ( ) NEW_LINE unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeServices ( int ( "0xFFFF0000" , 16 ) - 0x100000000 ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeServices ( int ( "0xEEEE0000" , 16 ) - 0x100000000 ) NEW_LINE DEDENT else : NEW_LINE INDENT curpath = current . getPath ( ) NEW_LINE idx = curpath . find ( " satellitePosition ▁ = = ▁ " ) NEW_LINE if idx != - 1 : NEW_LINE INDENT tmp = curpath [ idx + 21 : ] NEW_LINE idx = tmp . find ( ' ) ' ) NEW_LINE if idx != - 1 : NEW_LINE INDENT satpos = int ( tmp [ : idx ] ) NEW_LINE eDVBDB . getInstance ( ) . removeServices ( - 1 , - 1 , - 1 , satpos ) NEW_LINE DEDENT DEDENT DEDENT refreshServiceList ( ) NEW_LINE if hasattr ( self , ' showSatellites ' ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE self . servicelist . moveToIndex ( currentIndex ) NEW_LINE if currentIndex != self . servicelist . getCurrentIndex ( ) : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . moveEnd ) NEW_LINE # ▁ multiple ▁ marked ▁ entry ▁ stuff ▁ ( ▁ edit ▁ mode , ▁ later ▁ multiepg ▁ selection ▁ ) ENDCOM DEDENT DEDENT DEDENT DEDENT def startMarkedEdit ( self , type ) : NEW_LINE INDENT self . savedPath = self . servicePath [ : ] NEW_LINE if type == EDIT_ALTERNATIVES : NEW_LINE INDENT self . current_ref = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( self . current_ref ) NEW_LINE DEDENT self . mutableList = self . getMutableList ( ) NEW_LINE # ▁ add ▁ all ▁ services ▁ from ▁ the ▁ current ▁ list ▁ to ▁ internal ▁ marked ▁ set ▁ in ▁ listboxservicecontent ENDCOM self . clearMarks ( ) # ▁ this ▁ clears ▁ the ▁ internal ▁ marked ▁ set ▁ in ▁ the ▁ listboxservicecontent ENDCOM NEW_LINE self . saved_title = self . getTitle ( ) NEW_LINE pos = self . saved_title . find ( ' ) ' ) NEW_LINE new_title = self . saved_title [ : pos + 1 ] NEW_LINE if type == EDIT_ALTERNATIVES : NEW_LINE INDENT self . bouquet_mark_edit = EDIT_ALTERNATIVES NEW_LINE new_title += ' ▁ ' + _ ( " [ alternative ▁ edit ] " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_mark_edit = EDIT_BOUQUET NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT new_title += ' ▁ ' + _ ( " [ bouquet ▁ edit ] " ) NEW_LINE DEDENT else : NEW_LINE INDENT new_title += ' ▁ ' + _ ( " [ favourite ▁ edit ] " ) NEW_LINE DEDENT DEDENT self . setTitle ( new_title ) NEW_LINE self . __marked = self . servicelist . getRootServices ( ) NEW_LINE for x in self . __marked : NEW_LINE INDENT self . servicelist . addMarked ( eServiceReference ( x ) ) NEW_LINE DEDENT self [ " Service " ] . editmode = True NEW_LINE DEDENT def endMarkedEdit ( self , abort ) : NEW_LINE INDENT if not abort and self . mutableList is not None : NEW_LINE INDENT new_marked = set ( self . servicelist . getMarked ( ) ) NEW_LINE old_marked = set ( self . __marked ) NEW_LINE removed = old_marked - new_marked NEW_LINE added = new_marked - old_marked NEW_LINE changed = False NEW_LINE for x in removed : NEW_LINE INDENT changed = True NEW_LINE self . mutableList . removeService ( eServiceReference ( x ) ) NEW_LINE DEDENT for x in added : NEW_LINE INDENT changed = True NEW_LINE self . mutableList . addService ( eServiceReference ( x ) ) NEW_LINE DEDENT if changed : NEW_LINE INDENT if self . bouquet_mark_edit == EDIT_ALTERNATIVES and not new_marked and self . __marked : NEW_LINE INDENT self . mutableList . addService ( eServiceReference ( self . __marked [ 0 ] ) ) NEW_LINE DEDENT self . mutableList . flushChanges ( ) NEW_LINE DEDENT DEDENT self . __marked = [ ] NEW_LINE self . clearMarks ( ) NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE self . mutableList = None NEW_LINE self . setTitle ( self . saved_title ) NEW_LINE self . saved_title = None NEW_LINE # ▁ self . servicePath ▁ is ▁ just ▁ a ▁ reference ▁ to ▁ servicePathTv ▁ or ▁ Radio . . . ENDCOM # ▁ so ▁ we ▁ never ▁ ever ▁ do ▁ use ▁ the ▁ asignment ▁ operator ▁ in ▁ self . servicePath ENDCOM del self . servicePath [ : ] # ▁ remove ▁ all ▁ elements ENDCOM NEW_LINE self . servicePath += self . savedPath # ▁ add ▁ saved ▁ elements ENDCOM NEW_LINE del self . savedPath NEW_LINE self . setRoot ( self . servicePath [ - 1 ] ) NEW_LINE if self . current_ref : NEW_LINE INDENT self . setCurrentSelection ( self . current_ref ) NEW_LINE self . current_ref = None NEW_LINE DEDENT DEDENT def clearMarks ( self ) : NEW_LINE INDENT self . servicelist . clearMarks ( ) NEW_LINE DEDENT def doMark ( self ) : NEW_LINE INDENT ref = self . servicelist . getCurrent ( ) NEW_LINE if self . servicelist . isMarked ( ref ) : NEW_LINE INDENT self . servicelist . removeMarked ( ref ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . addMarked ( ref ) NEW_LINE DEDENT DEDENT def removeCurrentEntry ( self , bouquet = False ) : NEW_LINE INDENT if self . confirmRemove : NEW_LINE INDENT list = [ ( _ ( " yes " ) , True ) , ( _ ( " no " ) , False ) , ( _ ( " yes " ) + " ▁ " + _ ( " and ▁ never ▁ ask ▁ again ▁ this ▁ session ▁ again " ) , " never " ) ] NEW_LINE self . session . openWithCallback ( boundFunction ( self . removeCurrentEntryCallback , bouquet ) , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ this ▁ entry ? " ) , list = list ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeCurrentEntryCallback ( bouquet , True ) NEW_LINE DEDENT DEDENT def removeCurrentEntryCallback ( self , bouquet , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . confirmRemove = False NEW_LINE DEDENT if bouquet : NEW_LINE INDENT self . removeBouquet ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeCurrentService ( ) NEW_LINE DEDENT DEDENT DEDENT def removeCurrentService ( self , bouquet = False ) : NEW_LINE INDENT self . editMode = True NEW_LINE ref = self . servicelist . getCurrent ( ) NEW_LINE mutableList = self . getMutableList ( ) NEW_LINE if ref . valid ( ) and mutableList is not None : NEW_LINE INDENT if not mutableList . removeService ( ref ) : NEW_LINE INDENT mutableList . flushChanges ( ) # FIXME ▁ dont ▁ flush ▁ on ▁ each ▁ single ▁ removed ▁ service ENDCOM NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if not bouquet and playingref and ref == playingref : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def addServiceToBouquet ( self , dest , service = None ) : NEW_LINE INDENT mutableList = self . getMutableList ( dest ) NEW_LINE if not mutableList is None : NEW_LINE INDENT if service is None : # use ▁ current ▁ selected ▁ service ENDCOM NEW_LINE INDENT service = self . servicelist . getCurrent ( ) NEW_LINE DEDENT if not mutableList . addService ( service ) : NEW_LINE INDENT mutableList . flushChanges ( ) NEW_LINE # ▁ do ▁ some ▁ voodoo ▁ to ▁ check ▁ if ▁ current _ root ▁ is ▁ equal ▁ to ▁ dest ENDCOM cur_root = self . getRoot ( ) ; NEW_LINE str1 = cur_root and cur_root . toString ( ) or - 1 NEW_LINE str2 = dest . toString ( ) NEW_LINE pos1 = str1 . find ( " FROM ▁ BOUQUET " ) NEW_LINE pos2 = str2 . find ( " FROM ▁ BOUQUET " ) NEW_LINE if pos1 != - 1 and pos2 != - 1 and str1 [ pos1 : ] == str2 [ pos2 : ] : NEW_LINE INDENT self . servicelist . addService ( service ) NEW_LINE DEDENT self . servicelist . resetRoot ( ) NEW_LINE DEDENT DEDENT DEDENT def toggleMoveMode ( self , select = False ) : NEW_LINE INDENT self . editMode = True NEW_LINE if self . movemode : NEW_LINE INDENT if self . entry_marked : NEW_LINE INDENT self . toggleMoveMarked ( ) # ▁ unmark ▁ current ▁ entry ENDCOM NEW_LINE DEDENT self . movemode = False NEW_LINE self . mutableList . flushChanges ( ) # ▁ FIXME ▁ add ▁ check ▁ if ▁ changes ▁ was ▁ made ENDCOM NEW_LINE self . mutableList = None NEW_LINE self . setTitle ( self . saved_title ) NEW_LINE self . saved_title = None NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE self . servicelist . l . setHideNumberMarker ( config . usage . hide_number_markers . value ) NEW_LINE self . setCurrentSelection ( self . servicelist . getCurrent ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . mutableList = self . getMutableList ( ) NEW_LINE self . movemode = True NEW_LINE select and self . toggleMoveMarked ( ) NEW_LINE self . saved_title = self . getTitle ( ) NEW_LINE pos = self . saved_title . find ( ' ) ' ) NEW_LINE self . setTitle ( self . saved_title [ : pos + 1 ] + ' ▁ ' + _ ( " [ move ▁ mode ] " ) + self . saved_title [ pos + 1 : ] ) ; NEW_LINE self . servicelist . l . setHideNumberMarker ( False ) NEW_LINE self . setCurrentSelection ( self . servicelist . getCurrent ( ) ) NEW_LINE DEDENT self [ " Service " ] . editmode = True NEW_LINE DEDENT def handleEditCancel ( self ) : NEW_LINE INDENT if self . movemode : # movemode ▁ active ? ENDCOM NEW_LINE INDENT self . toggleMoveMode ( ) # ▁ disable ▁ move ▁ mode ENDCOM NEW_LINE DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT self . endMarkedEdit ( True ) # ▁ abort ▁ edit ▁ mode ENDCOM NEW_LINE DEDENT DEDENT def toggleMoveMarked ( self ) : NEW_LINE INDENT if self . entry_marked : NEW_LINE INDENT self . servicelist . setCurrentMarked ( False ) NEW_LINE self . entry_marked = False NEW_LINE self . pathChangeDisabled = False # ▁ re - enable ▁ path ▁ change ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . setCurrentMarked ( True ) NEW_LINE self . entry_marked = True NEW_LINE self . pathChangeDisabled = True # ▁ no ▁ path ▁ change ▁ allowed ▁ in ▁ movemod ENDCOM NEW_LINE DEDENT DEDENT def doContext ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . exitContext , ChannelContextMenu , self ) NEW_LINE DEDENT def exitContext ( self , close = False ) : NEW_LINE INDENT if close : NEW_LINE INDENT self . cancel ( ) NEW_LINE DEDENT DEDENT DEDENT MODE_TV = 0 NEW_LINE MODE_RADIO = 1 NEW_LINE # ▁ type ▁ 1 ▁ = ▁ digital ▁ television ▁ service ENDCOM # ▁ type ▁ 4 ▁ = ▁ nvod ▁ reference ▁ service ▁ ( NYI ) ENDCOM # ▁ type ▁ 17 ▁ = ▁ MPEG - 2 ▁ HD ▁ digital ▁ television ▁ service ENDCOM # ▁ type ▁ 22 ▁ = ▁ advanced ▁ codec ▁ SD ▁ digital ▁ television ENDCOM # ▁ type ▁ 24 ▁ = ▁ advanced ▁ codec ▁ SD ▁ NVOD ▁ reference ▁ service ▁ ( NYI ) ENDCOM # ▁ type ▁ 25 ▁ = ▁ advanced ▁ codec ▁ HD ▁ digital ▁ television ENDCOM # ▁ type ▁ 27 ▁ = ▁ advanced ▁ codec ▁ HD ▁ NVOD ▁ reference ▁ service ▁ ( NYI ) ENDCOM # ▁ type ▁ 2 ▁ = ▁ digital ▁ radio ▁ sound ▁ service ENDCOM # ▁ type ▁ 10 ▁ = ▁ advanced ▁ codec ▁ digital ▁ radio ▁ sound ▁ service ENDCOM # ▁ type ▁ 31 ▁ = ▁ High ▁ Efficiency ▁ Video ▁ Coing ▁ digital ▁ television ENDCOM service_types_tv = '1:7:1:0:0:0:0:0:0:0 : ( type ▁ = = ▁ 1 ) ▁ | | ▁ ( type ▁ = = ▁ 17 ) ▁ | | ▁ ( type ▁ = = ▁ 22 ) ▁ | | ▁ ( type ▁ = = ▁ 25 ) ▁ | | ▁ ( type ▁ = = ▁ 31 ) ▁ | | ▁ ( type ▁ = = ▁ 134 ) ▁ | | ▁ ( type ▁ = = ▁ 195 ) ' NEW_LINE service_types_radio = '1:7:2:0:0:0:0:0:0:0 : ( type ▁ = = ▁ 2 ) ▁ | | ▁ ( type ▁ = = ▁ 10 ) ' NEW_LINE class ChannelSelectionBase ( Screen ) : NEW_LINE INDENT def __init__ ( self , session ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . setScreenPathMode ( None ) NEW_LINE self [ " key _ red " ] = Button ( _ ( " All " ) ) NEW_LINE self [ " key _ green " ] = Button ( _ ( " Satellites " ) ) NEW_LINE self [ " key _ yellow " ] = Button ( _ ( " Provider " ) ) NEW_LINE self [ " key _ blue " ] = Button ( _ ( " Favourites " ) ) NEW_LINE self [ " list " ] = ServiceList ( self ) NEW_LINE self . servicelist = self [ " list " ] NEW_LINE self . numericalTextInput = NumericalTextInput ( handleTimeout = False ) NEW_LINE self . numericalTextInput . setUseableChars ( u ' 1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ ' ) NEW_LINE self . servicePathTV = [ ] NEW_LINE self . servicePathRadio = [ ] NEW_LINE self . servicePath = [ ] NEW_LINE self . history = [ ] NEW_LINE self . rootChanged = False NEW_LINE self . startRoot = None NEW_LINE self . selectionNumber = " " NEW_LINE self . clearNumberSelectionNumberTimer = eTimer ( ) NEW_LINE self . clearNumberSelectionNumberTimer . callback . append ( self . clearNumberSelectionNumber ) NEW_LINE self . protectContextMenu = True NEW_LINE self . mode = MODE_TV NEW_LINE self . dopipzap = False NEW_LINE self . pathChangeDisabled = False NEW_LINE self . movemode = False NEW_LINE self . showSatDetails = False NEW_LINE self [ " ChannelSelectBaseActions " ] = NumberActionMap ( [ " ChannelSelectBaseActions " , " NumberActions " , " InputAsciiActions " ] , { " showFavourites " : self . showFavourites , " showAllServices " : self . showAllServices , " showProviders " : self . showProviders , " showSatellites " : boundFunction ( self . showSatellites , changeMode = True ) , " nextBouquet " : self . nextBouquet , " prevBouquet " : self . prevBouquet , " nextMarker " : self . nextMarker , " prevMarker " : self . prevMarker , " gotAsciiCode " : self . keyAsciiCode , " keyLeft " : self . keyLeft , " keyRight " : self . keyRight , " keyRecord " : self . keyRecord , "1" : self . keyNumberGlobal , "2" : self . keyNumberGlobal , "3" : self . keyNumberGlobal , "4" : self . keyNumberGlobal , "5" : self . keyNumberGlobal , "6" : self . keyNumberGlobal , "7" : self . keyNumberGlobal , "8" : self . keyNumberGlobal , "9" : self . keyNumberGlobal , "0" : self . keyNumber0 } , - 2 ) NEW_LINE self . maintitle = _ ( " Channel ▁ selection " ) NEW_LINE self . recallBouquetMode ( ) NEW_LINE DEDENT def getBouquetNumOffset ( self , bouquet ) : NEW_LINE INDENT if not config . usage . multibouquet . value : NEW_LINE INDENT return 0 NEW_LINE DEDENT str = bouquet . toString ( ) NEW_LINE offset = 0 NEW_LINE if ' userbouquet . ' in bouquet . toCompareString ( ) : NEW_LINE INDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE servicelist = serviceHandler . list ( bouquet ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT serviceIterator = servicelist . getNext ( ) NEW_LINE if not serviceIterator . valid ( ) : # check ▁ if ▁ end ▁ of ▁ list ENDCOM NEW_LINE INDENT break NEW_LINE DEDENT number = serviceIterator . getChannelNum ( ) NEW_LINE if number > 0 : NEW_LINE INDENT offset = number - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return offset NEW_LINE DEDENT def recallBouquetMode ( self ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT self . service_types = service_types_tv NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT self . bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " bouquets . tv " ▁ ORDER ▁ BY ▁ bouquet ' NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_rootstr = ' % s ▁ FROM ▁ BOUQUET ▁ " userbouquet . favourites . tv " ▁ ORDER ▁ BY ▁ bouquet ' % ( self . service_types ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . service_types = service_types_radio NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT self . bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " bouquets . radio " ▁ ORDER ▁ BY ▁ bouquet ' NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_rootstr = ' % s ▁ FROM ▁ BOUQUET ▁ " userbouquet . favourites . radio " ▁ ORDER ▁ BY ▁ bouquet ' % ( self . service_types ) NEW_LINE DEDENT DEDENT self . bouquet_root = eServiceReference ( self . bouquet_rootstr ) NEW_LINE DEDENT def setTvMode ( self ) : NEW_LINE INDENT self . mode = MODE_TV NEW_LINE self . servicePath = self . servicePathTV NEW_LINE self . recallBouquetMode ( ) NEW_LINE title = self . maintitle NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT title += _ ( " ▁ ( TV ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE DEDENT def setRadioMode ( self ) : NEW_LINE INDENT self . mode = MODE_RADIO NEW_LINE self . servicePath = self . servicePathRadio NEW_LINE self . recallBouquetMode ( ) NEW_LINE title = self . maintitle NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT title += _ ( " ▁ ( Radio ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE DEDENT def setRoot ( self , root , justSet = False ) : NEW_LINE INDENT if self . startRoot is None : NEW_LINE INDENT self . startRoot = self . getRoot ( ) NEW_LINE DEDENT path = root . getPath ( ) NEW_LINE isBouquet = ' FROM ▁ BOUQUET ' in path and ( root . flags & eServiceReference . isDirectory ) NEW_LINE inBouquetRootList = ' FROM ▁ BOUQUET ▁ " bouquets . ' in path # FIXME ▁ HACK ENDCOM NEW_LINE if not inBouquetRootList and isBouquet : NEW_LINE INDENT self . servicelist . setMode ( ServiceList . MODE_FAVOURITES ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . setMode ( ServiceList . MODE_NORMAL ) NEW_LINE DEDENT self . servicelist . setRoot ( root , justSet ) NEW_LINE self . rootChanged = True NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT def removeModeStr ( self , str ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT pos = str . find ( _ ( " ▁ ( TV ) " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = str . find ( _ ( " ▁ ( Radio ) " ) ) NEW_LINE DEDENT if pos != - 1 : NEW_LINE INDENT return str [ : pos ] NEW_LINE DEDENT return str NEW_LINE DEDENT def getServiceName ( self , ref ) : NEW_LINE INDENT str = self . removeModeStr ( ServiceReference ( ref ) . getServiceName ( ) ) NEW_LINE if ' bouquets ' in str . lower ( ) : NEW_LINE INDENT return _ ( " User ▁ - ▁ bouquets " ) NEW_LINE DEDENT if not str : NEW_LINE INDENT pathstr = ref . getPath ( ) NEW_LINE if ' FROM ▁ PROVIDERS ' in pathstr : NEW_LINE INDENT return _ ( " Provider " ) NEW_LINE DEDENT if ' FROM ▁ SATELLITES ' in pathstr : NEW_LINE INDENT return _ ( " Satellites " ) NEW_LINE DEDENT if ' ) ▁ ORDER ▁ BY ▁ name ' in pathstr : NEW_LINE INDENT return _ ( " All " ) NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT def buildTitleString ( self ) : NEW_LINE INDENT titleStr = self . getTitle ( ) NEW_LINE pos = titleStr . find ( ' ] ' ) NEW_LINE if pos == - 1 : NEW_LINE INDENT pos = titleStr . find ( ' ) ' ) NEW_LINE DEDENT if pos != - 1 : NEW_LINE INDENT titleStr = titleStr [ : pos + 1 ] NEW_LINE Len = len ( self . servicePath ) NEW_LINE if Len > 0 : NEW_LINE INDENT base_ref = self . servicePath [ 0 ] NEW_LINE if Len > 1 : NEW_LINE INDENT end_ref = self . servicePath [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT end_ref = None NEW_LINE DEDENT nameStr = self . getServiceName ( base_ref ) NEW_LINE titleStr += ' ▁ - ▁ ' + nameStr NEW_LINE if end_ref is not None : NEW_LINE INDENT if Len > 2 : NEW_LINE INDENT titleStr += ' / . . / ' NEW_LINE DEDENT else : NEW_LINE INDENT titleStr += ' / ' NEW_LINE DEDENT nameStr = self . getServiceName ( end_ref ) NEW_LINE titleStr += nameStr NEW_LINE DEDENT self . setTitle ( titleStr ) NEW_LINE DEDENT DEDENT DEDENT def moveUp ( self ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT def moveDown ( self ) : NEW_LINE INDENT self . servicelist . moveDown ( ) NEW_LINE DEDENT def clearPath ( self ) : NEW_LINE INDENT del self . servicePath [ : ] NEW_LINE DEDENT def enterPath ( self , ref , justSet = False ) : NEW_LINE INDENT self . servicePath . append ( ref ) NEW_LINE self . setRoot ( ref , justSet ) NEW_LINE DEDENT def enterUserbouquet ( self , root , save_root = True ) : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . recallBouquetMode ( ) NEW_LINE if self . bouquet_root : NEW_LINE INDENT self . enterPath ( self . bouquet_root ) NEW_LINE DEDENT self . enterPath ( root ) NEW_LINE self . startRoot = None NEW_LINE if save_root : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE DEDENT DEDENT def pathUp ( self , justSet = False ) : NEW_LINE INDENT prev = self . servicePath . pop ( ) NEW_LINE if self . servicePath : NEW_LINE INDENT current = self . servicePath [ - 1 ] NEW_LINE self . setRoot ( current , justSet ) NEW_LINE if not justSet : NEW_LINE INDENT self . setCurrentSelection ( prev ) NEW_LINE DEDENT DEDENT return prev NEW_LINE DEDENT def isBasePathEqual ( self , ref ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 and self . servicePath [ 0 ] == ref : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isPrevPathEqual ( self , ref ) : NEW_LINE INDENT length = len ( self . servicePath ) NEW_LINE if length > 1 and self . servicePath [ length - 2 ] == ref : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def preEnterPath ( self , refstr ) : NEW_LINE INDENT return False NEW_LINE DEDENT def showAllServices ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE playingref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE if playingref : NEW_LINE INDENT self . setCurrentSelectionAlternative ( playingref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def showSatellites ( self , changeMode = False ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE justSet = False NEW_LINE prev = None NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT if self . isPrevPathEqual ( ref ) : NEW_LINE INDENT justSet = True NEW_LINE DEDENT prev = self . pathUp ( justSet ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT justSet = True NEW_LINE self . clearPath ( ) NEW_LINE self . enterPath ( ref , True ) NEW_LINE DEDENT if changeMode and currentRoot and currentRoot == ref : NEW_LINE INDENT self . showSatDetails = not self . showSatDetails NEW_LINE justSet = True NEW_LINE self . clearPath ( ) NEW_LINE self . enterPath ( ref , True ) NEW_LINE DEDENT DEDENT if justSet : NEW_LINE INDENT addCableAndTerrestrialLater = [ ] NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE servicelist = serviceHandler . list ( ref ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT service = servicelist . getNext ( ) NEW_LINE if not service . valid ( ) : # check ▁ if ▁ end ▁ of ▁ list ENDCOM NEW_LINE INDENT break NEW_LINE DEDENT unsigned_orbpos = service . getUnsignedData ( 4 ) >> 16 NEW_LINE orbpos = service . getData ( 4 ) >> 16 NEW_LINE if orbpos < 0 : NEW_LINE INDENT orbpos += 3600 NEW_LINE DEDENT if " FROM ▁ PROVIDER " in service . getPath ( ) : NEW_LINE INDENT service_type = self . showSatDetails and _ ( " Providers " ) NEW_LINE DEDENT elif ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in service . getPath ( ) : NEW_LINE INDENT service_type = self . showSatDetails and _ ( " New " ) NEW_LINE DEDENT else : NEW_LINE INDENT service_type = _ ( " Services " ) NEW_LINE DEDENT if service_type : NEW_LINE INDENT if unsigned_orbpos == 0xFFFF : # Cable ENDCOM NEW_LINE INDENT service_name = _ ( " Cable " ) NEW_LINE addCableAndTerrestrialLater . append ( ( " % s ▁ - ▁ % s " % ( service_name , service_type ) , service . toString ( ) ) ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : # Terrestrial ENDCOM NEW_LINE INDENT service_name = _ ( " Terrestrial " ) NEW_LINE addCableAndTerrestrialLater . append ( ( " % s ▁ - ▁ % s " % ( service_name , service_type ) , service . toString ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT service_name = str ( nimmanager . getSatDescription ( orbpos ) ) NEW_LINE DEDENT except : NEW_LINE INDENT if orbpos > 1800 : # ▁ west ENDCOM NEW_LINE INDENT orbpos = 3600 - orbpos NEW_LINE h = _ ( " W " ) NEW_LINE DEDENT else : NEW_LINE INDENT h = _ ( " E " ) NEW_LINE DEDENT service_name = ( " % d . % d " + h ) % ( orbpos / 10 , orbpos % 10 ) NEW_LINE DEDENT service . setName ( " % s ▁ - ▁ % s " % ( service_name , service_type ) ) NEW_LINE self . servicelist . addService ( service ) NEW_LINE DEDENT DEDENT DEDENT cur_ref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE self . servicelist . l . sort ( ) NEW_LINE if cur_ref : NEW_LINE INDENT pos = self . service_types . rfind ( ' : ' ) NEW_LINE refstr = ' % s ▁ ( channelID ▁ = = ▁ % 08x % 04x % 04x ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name ' % ( self . service_types [ : pos + 1 ] , cur_ref . getUnsignedData ( 4 ) , # ▁ NAMESPACE ENDCOM cur_ref . getUnsignedData ( 2 ) , # ▁ TSID ENDCOM cur_ref . getUnsignedData ( 3 ) , # ▁ ONID ENDCOM self . service_types [ pos + 1 : ] ) NEW_LINE ref = eServiceReference ( refstr ) NEW_LINE ref . setName ( _ ( " Current ▁ transponder " ) ) NEW_LINE self . servicelist . addService ( ref , beforeCurrent = True ) NEW_LINE DEDENT for ( service_name , service_ref ) in addCableAndTerrestrialLater : NEW_LINE INDENT ref = eServiceReference ( service_ref ) NEW_LINE ref . setName ( service_name ) NEW_LINE self . servicelist . addService ( ref , beforeCurrent = True ) NEW_LINE DEDENT self . servicelist . l . FillFinished ( ) NEW_LINE if prev is not None : NEW_LINE INDENT self . setCurrentSelection ( prev ) NEW_LINE DEDENT elif cur_ref : NEW_LINE INDENT refstr = cur_ref . toString ( ) NEW_LINE op = " " . join ( refstr . split ( ' : ' , 10 ) [ 6 : 7 ] ) NEW_LINE if len ( op ) >= 4 : NEW_LINE INDENT hop = int ( op [ : - 4 ] , 16 ) NEW_LINE if len ( op ) >= 7 and not op . endswith ( '0000' ) : NEW_LINE INDENT op = op [ : - 4 ] + '0000' NEW_LINE DEDENT refstr = '1:7:0:0:0:0 : % s : 0:0:0 : ( satellitePosition ▁ = = ▁ % s ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name ' % ( op , hop , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] ) NEW_LINE self . setCurrentSelectionAlternative ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def showProviders ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ FROM ▁ PROVIDERS ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT provider = info . getInfoString ( iServiceInformation . sProvider ) NEW_LINE refstr = '1:7:0:0:0:0:0:0:0:0 : ( provider ▁ = = ▁ \ " % s\ " ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name : % s ' % ( provider , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] , provider ) NEW_LINE self . setCurrentSelectionAlternative ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def changeBouquet ( self , direction ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT if len ( self . servicePath ) > 1 : NEW_LINE # when ▁ enter ▁ satellite ▁ root ▁ list ▁ we ▁ must ▁ do ▁ some ▁ magic ▁ stuff . . ENDCOM INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT ref = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE DEDENT DEDENT DEDENT def inBouquet ( self ) : NEW_LINE INDENT if self . servicePath and self . servicePath [ 0 ] == self . bouquet_root : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def atBegin ( self ) : NEW_LINE INDENT return self . servicelist . atBegin ( ) NEW_LINE DEDENT def atEnd ( self ) : NEW_LINE INDENT return self . servicelist . atEnd ( ) NEW_LINE DEDENT def nextBouquet ( self ) : NEW_LINE INDENT if self . shown and config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageUp ) NEW_LINE DEDENT elif " reverseB " in config . usage . servicelist_cursor_behavior . value : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT DEDENT def prevBouquet ( self ) : NEW_LINE INDENT if self . shown and config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageDown ) NEW_LINE DEDENT elif " reverseB " in config . usage . servicelist_cursor_behavior . value : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT DEDENT def keyLeft ( self ) : NEW_LINE INDENT if config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageUp ) NEW_LINE DEDENT DEDENT def keyRight ( self ) : NEW_LINE INDENT if config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageDown ) NEW_LINE DEDENT DEDENT def keyRecord ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref and not ( ref . flags & ( eServiceReference . isMarker | eServiceReference . isDirectory ) ) : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . instantRecord ( serviceRef = ref ) NEW_LINE DEDENT DEDENT def showFavourites ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT if not self . preEnterPath ( self . bouquet_rootstr ) : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != self . bouquet_root : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( self . bouquet_root ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def keyNumber0 ( self , number ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 and not self . selectionNumber : NEW_LINE INDENT self . keyGoUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . keyNumberGlobal ( number ) NEW_LINE DEDENT DEDENT def keyNumberGlobal ( self , number ) : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT if hasattr ( self , " editMode " ) and self . editMode : NEW_LINE INDENT if number == 2 : NEW_LINE INDENT self . renameEntry ( ) NEW_LINE DEDENT if number == 6 : NEW_LINE INDENT self . toggleMoveMode ( select = True ) NEW_LINE DEDENT if number == 8 : NEW_LINE INDENT self . removeCurrentEntry ( bouquet = False ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . numberSelectionActions ( number ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current_root = self . getRoot ( ) NEW_LINE if current_root and ' FROM ▁ BOUQUET ▁ " bouquets . ' in current_root . getPath ( ) : NEW_LINE INDENT if hasattr ( self , " editMode " ) and self . editMode : NEW_LINE INDENT if number == 2 : NEW_LINE INDENT self . renameEntry ( ) NEW_LINE DEDENT if number == 6 : NEW_LINE INDENT self . toggleMoveMode ( select = True ) NEW_LINE DEDENT if number == 8 : NEW_LINE INDENT self . removeCurrentEntry ( bouquet = True ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . numberSelectionActions ( number ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT unichar = self . numericalTextInput . getKey ( number ) NEW_LINE charstr = unichar . encode ( " utf - 8" ) NEW_LINE if len ( charstr ) == 1 : NEW_LINE INDENT self . servicelist . moveToChar ( charstr [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def numberSelectionActions ( self , number ) : NEW_LINE INDENT if not ( hasattr ( self , " movemode " ) and self . movemode ) : NEW_LINE INDENT if len ( self . selectionNumber ) > 4 : NEW_LINE INDENT self . clearNumberSelectionNumber ( ) NEW_LINE DEDENT self . selectionNumber = self . selectionNumber + str ( number ) NEW_LINE ref , bouquet = Screens . InfoBar . InfoBar . instance . searchNumber ( int ( self . selectionNumber ) , bouquet = self . getRoot ( ) ) NEW_LINE if ref : NEW_LINE INDENT if not ref . flags & eServiceReference . isMarker : NEW_LINE INDENT self . enterUserbouquet ( bouquet , save_root = False ) NEW_LINE self . setCurrentSelection ( ref ) NEW_LINE DEDENT self . clearNumberSelectionNumberTimer . start ( 1000 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . clearNumberSelectionNumber ( ) NEW_LINE DEDENT DEDENT DEDENT def clearNumberSelectionNumber ( self ) : NEW_LINE INDENT self . clearNumberSelectionNumberTimer . stop ( ) NEW_LINE self . selectionNumber = " " NEW_LINE DEDENT def keyAsciiCode ( self ) : NEW_LINE INDENT unichar = unichr ( getPrevAsciiCode ( ) ) NEW_LINE charstr = unichar . encode ( " utf - 8" ) NEW_LINE if len ( charstr ) == 1 : NEW_LINE INDENT self . servicelist . moveToChar ( charstr [ 0 ] ) NEW_LINE DEDENT DEDENT def getRoot ( self ) : NEW_LINE INDENT return self . servicelist . getRoot ( ) NEW_LINE DEDENT def getCurrentSelection ( self ) : NEW_LINE INDENT return self . servicelist . getCurrent ( ) NEW_LINE DEDENT def setCurrentSelection ( self , service ) : NEW_LINE INDENT if service : NEW_LINE INDENT self . servicelist . setCurrent ( service , adjust = False ) NEW_LINE DEDENT DEDENT def setCurrentSelectionAlternative ( self , ref ) : NEW_LINE INDENT if self . bouquet_mark_edit == EDIT_ALTERNATIVES and not ( ref . flags & eServiceReference . isDirectory ) : NEW_LINE INDENT for markedService in self . servicelist . getMarked ( ) : NEW_LINE INDENT markedService = eServiceReference ( markedService ) NEW_LINE self . setCurrentSelection ( markedService ) NEW_LINE if markedService == self . getCurrentSelection ( ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT self . setCurrentSelection ( ref ) NEW_LINE DEDENT def getBouquetList ( self ) : NEW_LINE INDENT bouquets = [ ] NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT list = serviceHandler . list ( self . bouquet_root ) NEW_LINE if list : NEW_LINE INDENT while True : NEW_LINE INDENT s = list . getNext ( ) NEW_LINE if not s . valid ( ) : NEW_LINE INDENT break NEW_LINE DEDENT if s . flags & eServiceReference . isDirectory and not s . flags & eServiceReference . isInvisible : NEW_LINE INDENT info = serviceHandler . info ( s ) NEW_LINE if info : NEW_LINE INDENT bouquets . append ( ( info . getName ( s ) , s ) ) NEW_LINE DEDENT DEDENT DEDENT return bouquets NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT info = serviceHandler . info ( self . bouquet_root ) NEW_LINE if info : NEW_LINE INDENT bouquets . append ( ( info . getName ( self . bouquet_root ) , self . bouquet_root ) ) NEW_LINE DEDENT return bouquets NEW_LINE DEDENT return None NEW_LINE DEDENT def keyGoUp ( self ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ PROVIDERS ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showProviders ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showAllServices ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def nextMarker ( self ) : NEW_LINE INDENT self . servicelist . moveToNextMarker ( ) NEW_LINE DEDENT def prevMarker ( self ) : NEW_LINE INDENT self . servicelist . moveToPrevMarker ( ) NEW_LINE DEDENT def gotoCurrentServiceOrProvider ( self , ref ) : NEW_LINE INDENT str = ref . toString ( ) NEW_LINE if _ ( " Providers " ) in str : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT provider = info . getInfoString ( iServiceInformation . sProvider ) NEW_LINE op = int ( self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) . toString ( ) . split ( ' : ' ) [ 6 ] [ : - 4 ] or "0" , 16 ) NEW_LINE refstr = '1:7:0:0:0:0:0:0:0:0 : ( provider ▁ = = ▁ \ " % s\ " ) ▁ & & ▁ ( satellitePosition ▁ = = ▁ % s ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name : % s ' % ( provider , op , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] , provider ) NEW_LINE self . setCurrentSelection ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT elif not self . isBasePathEqual ( self . bouquet_root ) or self . bouquet_mark_edit == EDIT_ALTERNATIVES : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref : NEW_LINE INDENT self . setCurrentSelectionAlternative ( playingref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT HISTORYSIZE = 20 NEW_LINE # config ▁ for ▁ lastservice ENDCOM config . tv = ConfigSubsection ( ) NEW_LINE config . tv . lastservice = ConfigText ( ) NEW_LINE config . tv . lastroot = ConfigText ( ) NEW_LINE config . radio = ConfigSubsection ( ) NEW_LINE config . radio . lastservice = ConfigText ( ) NEW_LINE config . radio . lastroot = ConfigText ( ) NEW_LINE config . servicelist = ConfigSubsection ( ) NEW_LINE config . servicelist . lastmode = ConfigText ( default = " tv " ) NEW_LINE config . servicelist . startupservice = ConfigText ( ) NEW_LINE config . servicelist . startupservice_onstandby = ConfigYesNo ( default = False ) NEW_LINE config . servicelist . startuproot = ConfigText ( ) NEW_LINE config . servicelist . startupmode = ConfigText ( default = " tv " ) NEW_LINE class ChannelSelection ( ChannelSelectionBase , ChannelSelectionEdit , ChannelSelectionEPG , SelectionEventInfo ) : NEW_LINE INDENT def __init__ ( self , session ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE ChannelSelectionEdit . __init__ ( self ) NEW_LINE ChannelSelectionEPG . __init__ ( self ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " cancel " : self . cancel , " ok " : self . channelSelected , " keyRadio " : self . doRadioButton , " keyTV " : self . doTVButton , } ) NEW_LINE self . __event_tracker = ServiceEventTracker ( screen = self , eventmap = { iPlayableService . evStart : self . __evServiceStart , iPlayableService . evEnd : self . __evServiceEnd } ) NEW_LINE self . startServiceRef = None NEW_LINE self . history = [ ] NEW_LINE self . history_pos = 0 NEW_LINE if config . servicelist . startupservice . value and config . servicelist . startuproot . value : NEW_LINE INDENT config . servicelist . lastmode . value = config . servicelist . startupmode . value NEW_LINE if config . servicelist . lastmode . value == " tv " : NEW_LINE INDENT config . tv . lastservice . value = config . servicelist . startupservice . value NEW_LINE config . tv . lastroot . value = config . servicelist . startuproot . value NEW_LINE DEDENT elif config . servicelist . lastmode . value == " radio " : NEW_LINE INDENT config . radio . lastservice . value = config . servicelist . startupservice . value NEW_LINE config . radio . lastroot . value = config . servicelist . startuproot . value NEW_LINE DEDENT DEDENT self . lastservice = config . tv . lastservice NEW_LINE self . lastroot = config . tv . lastroot NEW_LINE self . revertMode = None NEW_LINE config . usage . multibouquet . addNotifier ( self . multibouquet_config_changed ) NEW_LINE self . new_service_played = False NEW_LINE self . dopipzap = False NEW_LINE self . onExecBegin . append ( self . asciiOn ) NEW_LINE self . mainScreenMode = None NEW_LINE self . mainScreenRoot = None NEW_LINE self . lastChannelRootTimer = eTimer ( ) NEW_LINE self . lastChannelRootTimer . callback . append ( self . __onCreate ) NEW_LINE self . lastChannelRootTimer . start ( 100 , True ) NEW_LINE self . pipzaptimer = eTimer ( ) NEW_LINE DEDENT def asciiOn ( self ) : NEW_LINE INDENT rcinput = eRCInput . getInstance ( ) NEW_LINE rcinput . setKeyboardMode ( rcinput . kmAscii ) NEW_LINE DEDENT def asciiOff ( self ) : NEW_LINE INDENT rcinput = eRCInput . getInstance ( ) NEW_LINE rcinput . setKeyboardMode ( rcinput . kmNone ) NEW_LINE DEDENT def multibouquet_config_changed ( self , val ) : NEW_LINE INDENT self . recallBouquetMode ( ) NEW_LINE DEDENT def __evServiceStart ( self ) : NEW_LINE INDENT if self . dopipzap and hasattr ( self . session , ' pip ' ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( self . session . pip . getCurrentServiceReference ( ) or eServiceReference ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT refstr = info . getInfoString ( iServiceInformation . sServiceref ) NEW_LINE self . servicelist . setPlayableIgnoreService ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def __evServiceEnd ( self ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( eServiceReference ( ) ) NEW_LINE DEDENT def setMode ( self ) : NEW_LINE INDENT self . rootChanged = True NEW_LINE self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT DEDENT def doTVButton ( self ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT DEDENT def setModeTv ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . revertMode = self . mode NEW_LINE DEDENT self . lastservice = config . tv . lastservice NEW_LINE self . lastroot = config . tv . lastroot NEW_LINE config . servicelist . lastmode . value = " tv " NEW_LINE self . setTvMode ( ) NEW_LINE self . setMode ( ) NEW_LINE DEDENT def doRadioButton ( self ) : NEW_LINE INDENT if self . mode == MODE_RADIO : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT DEDENT def setModeRadio ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . revertMode = self . mode NEW_LINE DEDENT if config . usage . e1like_radio_mode . value : NEW_LINE INDENT self . lastservice = config . radio . lastservice NEW_LINE self . lastroot = config . radio . lastroot NEW_LINE config . servicelist . lastmode . value = " radio " NEW_LINE self . setRadioMode ( ) NEW_LINE self . setMode ( ) NEW_LINE DEDENT DEDENT def __onCreate ( self ) : NEW_LINE INDENT if config . usage . e1like_radio_mode . value : NEW_LINE INDENT if config . servicelist . lastmode . value == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . zap ( ) NEW_LINE DEDENT DEDENT def channelSelected ( self , doClose = True ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if config . usage . channelselection_preview . value and ( playingref is None or self . getCurrentSelection ( ) and self . getCurrentSelection ( ) != playingref ) : NEW_LINE INDENT doClose = False NEW_LINE DEDENT if not self . startServiceRef and not doClose : NEW_LINE INDENT self . startServiceRef = playingref NEW_LINE DEDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . movemode and ( self . isBasePathEqual ( self . bouquet_root ) or " userbouquet . " in ref . toString ( ) ) : NEW_LINE INDENT self . toggleMoveMarked ( ) NEW_LINE DEDENT elif ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT if Components . ParentalControl . parentalControl . isServicePlayable ( ref , self . bouquetParentalControlCallback , self . session ) : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT if not ( self . bouquet_mark_edit == EDIT_ALTERNATIVES and ref . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . doMark ( ) NEW_LINE DEDENT DEDENT elif not ( ref . flags & eServiceReference . isMarker or ref . type == - 1 ) : NEW_LINE INDENT root = self . getRoot ( ) NEW_LINE if not root or not ( root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . zap ( enable_pipzap = doClose , preview_zap = not doClose ) NEW_LINE self . asciiOff ( ) NEW_LINE if doClose : NEW_LINE INDENT if self . dopipzap : NEW_LINE INDENT self . zapBack ( ) NEW_LINE DEDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE self . correctChannelNumber ( ) NEW_LINE self . movemode and self . toggleMoveMode ( ) NEW_LINE self . editMode = False NEW_LINE self . protectContextMenu = True NEW_LINE self . close ( ref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def bouquetParentalControlCallback ( self , ref ) : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE self . revertMode = None NEW_LINE DEDENT def togglePipzap ( self ) : NEW_LINE INDENT assert ( self . session . pip ) NEW_LINE title = self . instance . getTitle ( ) NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT if self . dopipzap : NEW_LINE # ▁ Mark ▁ PiP ▁ as ▁ inactive ▁ and ▁ effectively ▁ deactivate ▁ pipzap ENDCOM INDENT self . hidePipzapMessage ( ) NEW_LINE self . dopipzap = False NEW_LINE # ▁ Disable ▁ PiP ▁ if ▁ not ▁ playing ▁ a ▁ service ENDCOM if self . session . pip . pipservice is None : NEW_LINE INDENT self . session . pipshown = False NEW_LINE del self . session . pip NEW_LINE DEDENT self . __evServiceStart ( ) NEW_LINE # ▁ Move ▁ to ▁ playing ▁ service ENDCOM lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE if self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . servicelist . setCurrent ( lastservice ) NEW_LINE DEDENT DEDENT title += _ ( " ▁ ( TV ) " ) NEW_LINE DEDENT else : NEW_LINE # ▁ Mark ▁ PiP ▁ as ▁ active ▁ and ▁ effectively ▁ active ▁ pipzap ENDCOM INDENT self . showPipzapMessage ( ) NEW_LINE self . dopipzap = True NEW_LINE self . __evServiceStart ( ) NEW_LINE # ▁ Move ▁ to ▁ service ▁ playing ▁ in ▁ pip ▁ ( will ▁ not ▁ work ▁ with ▁ subservices ) ENDCOM self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE title += _ ( " ▁ ( PiP ) " ) NEW_LINE DEDENT self . setTitle ( title ) NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT def showPipzapMessage ( self ) : NEW_LINE INDENT time = config . usage . infobar_timeout . index NEW_LINE if time : NEW_LINE INDENT self . pipzaptimer . callback . append ( self . hidePipzapMessage ) NEW_LINE self . pipzaptimer . startLongTimer ( time ) NEW_LINE DEDENT self . session . pip . active ( ) NEW_LINE DEDENT def hidePipzapMessage ( self ) : NEW_LINE INDENT if self . pipzaptimer . isActive ( ) : NEW_LINE INDENT self . pipzaptimer . callback . remove ( self . hidePipzapMessage ) NEW_LINE self . pipzaptimer . stop ( ) NEW_LINE DEDENT self . session . pip . inactive ( ) NEW_LINE # called ▁ from ▁ infoBar ▁ and ▁ channelSelected ENDCOM DEDENT def zap ( self , enable_pipzap = False , preview_zap = False , checkParentalControl = True , ref = None ) : NEW_LINE INDENT self . curRoot = self . startRoot NEW_LINE nref = ref or self . getCurrentSelection ( ) NEW_LINE ref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if enable_pipzap and self . dopipzap : NEW_LINE INDENT ref = self . session . pip . getCurrentService ( ) NEW_LINE if ref is None or ref != nref : NEW_LINE INDENT nref = self . session . pip . resolveAlternatePipService ( nref ) NEW_LINE if nref and ( not checkParentalControl or Components . ParentalControl . parentalControl . isServicePlayable ( nref , boundFunction ( self . zap , enable_pipzap = True , checkParentalControl = False ) ) ) : NEW_LINE INDENT self . session . pip . playService ( nref ) NEW_LINE self . __evServiceStart ( ) NEW_LINE self . showPipzapMessage ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setStartRoot ( self . curRoot ) NEW_LINE self . setCurrentSelection ( ref ) NEW_LINE DEDENT DEDENT DEDENT elif ref is None or ref != nref : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . checkTimeshiftRunning ( boundFunction ( self . zapCheckTimeshiftCallback , enable_pipzap , preview_zap , nref ) ) NEW_LINE DEDENT elif not preview_zap : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE self . saveChannel ( nref ) NEW_LINE config . servicelist . lastmode . save ( ) NEW_LINE self . setCurrentSelection ( nref ) NEW_LINE if self . startServiceRef is None or nref != self . startServiceRef : NEW_LINE INDENT self . addToHistory ( nref ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT def zapCheckTimeshiftCallback ( self , enable_pipzap , preview_zap , nref , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . new_service_played = True NEW_LINE self . session . nav . playService ( nref ) NEW_LINE if not preview_zap : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE self . saveChannel ( nref ) NEW_LINE config . servicelist . lastmode . save ( ) NEW_LINE if self . startServiceRef is None or nref != self . startServiceRef : NEW_LINE INDENT self . addToHistory ( nref ) NEW_LINE DEDENT if self . dopipzap : NEW_LINE INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . mainScreenMode = config . servicelist . lastmode . value NEW_LINE self . mainScreenRoot = self . getRoot ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT else : NEW_LINE INDENT Notifications . RemovePopup ( " Parental ▁ control " ) NEW_LINE self . setCurrentSelection ( nref ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . setStartRoot ( self . curRoot ) NEW_LINE self . setCurrentSelection ( self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) ) NEW_LINE DEDENT if not preview_zap : NEW_LINE INDENT self . hide ( ) NEW_LINE DEDENT DEDENT def newServicePlayed ( self ) : NEW_LINE INDENT ret = self . new_service_played NEW_LINE self . new_service_played = False NEW_LINE return ret NEW_LINE DEDENT def addToHistory ( self , ref ) : NEW_LINE INDENT if self . servicePath is not None : NEW_LINE INDENT tmp = self . servicePath [ : ] NEW_LINE tmp . append ( ref ) NEW_LINE try : NEW_LINE INDENT del self . history [ self . history_pos + 1 : ] NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT self . history . append ( tmp ) NEW_LINE hlen = len ( self . history ) NEW_LINE if hlen > HISTORYSIZE : NEW_LINE INDENT del self . history [ 0 ] NEW_LINE hlen -= 1 NEW_LINE DEDENT self . history_pos = hlen - 1 NEW_LINE DEDENT DEDENT def historyBack ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE currentPlayedRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if hlen > 0 and currentPlayedRef and self . history [ self . history_pos ] [ - 1 ] != currentPlayedRef : NEW_LINE INDENT self . addToHistory ( currentPlayedRef ) NEW_LINE hlen = len ( self . history ) NEW_LINE DEDENT if hlen > 1 and self . history_pos > 0 : NEW_LINE INDENT self . history_pos -= 1 NEW_LINE self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT def historyNext ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE if hlen > 1 and self . history_pos < ( hlen - 1 ) : NEW_LINE INDENT self . history_pos += 1 NEW_LINE self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT def setHistoryPath ( self , doZap = True ) : NEW_LINE INDENT path = self . history [ self . history_pos ] [ : ] NEW_LINE ref = path . pop ( ) NEW_LINE del self . servicePath [ : ] NEW_LINE self . servicePath += path NEW_LINE self . saveRoot ( ) NEW_LINE root = path [ - 1 ] NEW_LINE cur_root = self . getRoot ( ) NEW_LINE if cur_root and cur_root != root : NEW_LINE INDENT self . setRoot ( root ) NEW_LINE DEDENT if doZap : NEW_LINE INDENT self . session . nav . playService ( ref , adjust = False ) NEW_LINE DEDENT if self . dopipzap : NEW_LINE INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setCurrentSelection ( ref ) NEW_LINE DEDENT self . saveChannel ( ref ) NEW_LINE DEDENT def saveRoot ( self ) : NEW_LINE INDENT path = ' ' NEW_LINE for i in self . servicePath : NEW_LINE INDENT path += i . toString ( ) NEW_LINE path += ' ; ' NEW_LINE DEDENT if path and path != self . lastroot . value : NEW_LINE INDENT if self . mode == MODE_RADIO and ' FROM ▁ BOUQUET ▁ " bouquets . tv " ' in path : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . mode == MODE_TV and ' FROM ▁ BOUQUET ▁ " bouquets . radio " ' in path : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . lastroot . value = path NEW_LINE self . lastroot . save ( ) NEW_LINE DEDENT DEDENT def restoreRoot ( self ) : NEW_LINE INDENT tmp = [ x for x in self . lastroot . value . split ( ' ; ' ) if x != ' ' ] NEW_LINE current = [ x . toString ( ) for x in self . servicePath ] NEW_LINE if tmp != current or self . rootChanged : NEW_LINE INDENT self . clearPath ( ) NEW_LINE cnt = 0 NEW_LINE for i in tmp : NEW_LINE INDENT self . servicePath . append ( eServiceReference ( i ) ) NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt : NEW_LINE INDENT path = self . servicePath . pop ( ) NEW_LINE self . enterPath ( path ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE self . saveRoot ( ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE DEDENT DEDENT def preEnterPath ( self , refstr ) : NEW_LINE INDENT if self . servicePath and self . servicePath [ 0 ] != eServiceReference ( refstr ) : NEW_LINE INDENT pathstr = self . lastroot . value NEW_LINE if pathstr is not None and refstr in pathstr : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def saveChannel ( self , ref ) : NEW_LINE INDENT if ref is not None : NEW_LINE INDENT refstr = ref . toString ( ) NEW_LINE DEDENT else : NEW_LINE INDENT refstr = " " NEW_LINE DEDENT if refstr != self . lastservice . value and not Components . ParentalControl . parentalControl . isProtected ( ref ) : NEW_LINE INDENT self . lastservice . value = refstr NEW_LINE self . lastservice . save ( ) NEW_LINE DEDENT DEDENT def setCurrentServicePath ( self , path , doZap = True ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE if not hlen : NEW_LINE INDENT self . history . append ( path ) NEW_LINE self . history_pos = 0 NEW_LINE DEDENT if hlen == 1 : NEW_LINE INDENT self . history [ self . history_pos ] = path NEW_LINE DEDENT else : NEW_LINE INDENT if path in self . history : NEW_LINE INDENT self . history . remove ( path ) NEW_LINE self . history_pos -= 1 NEW_LINE DEDENT tmp = self . history [ self . history_pos ] [ : ] NEW_LINE self . history . append ( tmp ) NEW_LINE self . history_pos += 1 NEW_LINE self . history [ self . history_pos ] = path NEW_LINE DEDENT self . setHistoryPath ( doZap ) NEW_LINE DEDENT def getCurrentServicePath ( self ) : NEW_LINE INDENT if self . history : NEW_LINE INDENT return self . history [ self . history_pos ] NEW_LINE DEDENT return None NEW_LINE DEDENT def recallPrevService ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE currentPlayedRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if hlen > 0 and currentPlayedRef and self . history [ self . history_pos ] [ - 1 ] != currentPlayedRef : NEW_LINE INDENT self . addToHistory ( currentPlayedRef ) NEW_LINE hlen = len ( self . history ) NEW_LINE DEDENT if hlen > 1 : NEW_LINE INDENT if self . history_pos == hlen - 1 : NEW_LINE INDENT tmp = self . history [ self . history_pos ] NEW_LINE self . history [ self . history_pos ] = self . history [ self . history_pos - 1 ] NEW_LINE self . history [ self . history_pos - 1 ] = tmp NEW_LINE DEDENT else : NEW_LINE INDENT tmp = self . history [ self . history_pos + 1 ] NEW_LINE self . history [ self . history_pos + 1 ] = self . history [ self . history_pos ] NEW_LINE self . history [ self . history_pos ] = tmp NEW_LINE DEDENT self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT def cancel ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE if self . dopipzap : NEW_LINE # ▁ This ▁ unfortunately ▁ won ' t ▁ work ▁ with ▁ subservices ENDCOM INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT DEDENT DEDENT self . asciiOff ( ) NEW_LINE self . zapBack ( ) NEW_LINE self . correctChannelNumber ( ) NEW_LINE self . editMode = False NEW_LINE self . protectContextMenu = True NEW_LINE self . close ( None ) NEW_LINE DEDENT def zapBack ( self ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if self . startServiceRef and ( playingref is None or playingref != self . startServiceRef ) : NEW_LINE INDENT self . setStartRoot ( self . startRoot ) NEW_LINE self . new_service_played = True NEW_LINE self . session . nav . playService ( self . startServiceRef ) NEW_LINE self . saveChannel ( self . startServiceRef ) NEW_LINE DEDENT else : NEW_LINE INDENT self . restoreMode ( ) NEW_LINE DEDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE if self . dopipzap : NEW_LINE # ▁ This ▁ unfortunately ▁ won ' t ▁ work ▁ with ▁ subservices ENDCOM INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) == lastservice : NEW_LINE INDENT pass # ▁ keep ▁ current ▁ selection ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT self . setCurrentSelection ( playingref ) NEW_LINE DEDENT DEDENT DEDENT def setStartRoot ( self , root ) : NEW_LINE INDENT if root : NEW_LINE INDENT if self . revertMode == MODE_TV : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . revertMode == MODE_RADIO : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE self . enterUserbouquet ( root ) NEW_LINE DEDENT DEDENT def restoreMode ( self ) : NEW_LINE INDENT if self . revertMode == MODE_TV : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . revertMode == MODE_RADIO : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT def correctChannelNumber ( self ) : NEW_LINE INDENT current_ref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if self . dopipzap : NEW_LINE INDENT tmp_mode = config . servicelist . lastmode . value NEW_LINE tmp_root = self . getRoot ( ) NEW_LINE tmp_ref = self . getCurrentSelection ( ) NEW_LINE pip_ref = self . session . pip . getCurrentService ( ) NEW_LINE if tmp_ref and pip_ref and tmp_ref != pip_ref : NEW_LINE INDENT self . revertMode = None NEW_LINE return NEW_LINE DEDENT if self . mainScreenMode == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . mainScreenMode == " radio " : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT if self . mainScreenRoot : NEW_LINE INDENT self . setRoot ( self . mainScreenRoot ) NEW_LINE self . setCurrentSelection ( current_ref ) NEW_LINE DEDENT DEDENT selected_ref = self . getCurrentSelection ( ) NEW_LINE if selected_ref and current_ref and selected_ref . getChannelNum ( ) != current_ref . getChannelNum ( ) : NEW_LINE INDENT oldref = self . session . nav . currentlyPlayingServiceReference NEW_LINE if oldref and selected_ref == oldref or ( oldref != current_ref and selected_ref == current_ref ) : NEW_LINE INDENT self . session . nav . currentlyPlayingServiceOrGroup = selected_ref NEW_LINE self . session . nav . pnav . navEvent ( iPlayableService . evStart ) NEW_LINE DEDENT DEDENT if self . dopipzap : NEW_LINE INDENT if tmp_mode == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif tmp_mode == " radio " : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . enterUserbouquet ( tmp_root ) NEW_LINE title = self . instance . getTitle ( ) NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE title += _ ( " ▁ ( PiP ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT if tmp_ref and pip_ref and tmp_ref . getChannelNum ( ) != pip_ref . getChannelNum ( ) : NEW_LINE INDENT self . session . pip . currentService = tmp_ref NEW_LINE DEDENT self . setCurrentSelection ( tmp_ref ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT DEDENT class RadioInfoBar ( Screen ) : NEW_LINE INDENT def __init__ ( self , session ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self [ " RdsDecoder " ] = RdsDecoder ( self . session . nav ) NEW_LINE DEDENT DEDENT class ChannelSelectionRadio ( ChannelSelectionBase , ChannelSelectionEdit , ChannelSelectionEPG , InfoBarBase , SelectionEventInfo ) : NEW_LINE INDENT ALLOW_SUSPEND = True NEW_LINE def __init__ ( self , session , infobar ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE ChannelSelectionEdit . __init__ ( self ) NEW_LINE ChannelSelectionEPG . __init__ ( self ) NEW_LINE InfoBarBase . __init__ ( self ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self . infobar = infobar NEW_LINE self . startServiceRef = None NEW_LINE self . onLayoutFinish . append ( self . onCreate ) NEW_LINE self . info = session . instantiateDialog ( RadioInfoBar ) # ▁ our ▁ simple ▁ infobar ENDCOM NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " keyTV " : self . cancel , " keyRadio " : self . cancel , " cancel " : self . cancel , " ok " : self . channelSelected , } ) NEW_LINE self . __event_tracker = ServiceEventTracker ( screen = self , eventmap = { iPlayableService . evStart : self . __evServiceStart , iPlayableService . evEnd : self . __evServiceEnd } ) NEW_LINE # # # # # ▁ RDS ▁ Radiotext ▁ / ▁ Rass ▁ Support ▁ BEGIN ENDCOM self . infobar = infobar # ▁ reference ▁ to ▁ real ▁ infobar ▁ ( the ▁ one ▁ and ▁ only ) ENDCOM NEW_LINE self [ " RdsDecoder " ] = self . info [ " RdsDecoder " ] NEW_LINE self [ " RdsActions " ] = HelpableActionMap ( self , " InfobarRdsActions " , { " startRassInteractive " : ( self . startRassInteractive , _ ( " View ▁ Rass ▁ interactive . . . " ) ) } , - 1 ) NEW_LINE self [ " RdsActions " ] . setEnabled ( False ) NEW_LINE infobar . rds_display . onRassInteractivePossibilityChanged . append ( self . RassInteractivePossibilityChanged ) NEW_LINE self . onClose . append ( self . __onClose ) NEW_LINE self . onExecBegin . append ( self . __onExecBegin ) NEW_LINE self . onExecEnd . append ( self . __onExecEnd ) NEW_LINE DEDENT def __onClose ( self ) : NEW_LINE INDENT lastservice = eServiceReference ( config . tv . lastservice . value ) NEW_LINE self . session . nav . playService ( lastservice ) NEW_LINE DEDENT def startRassInteractive ( self ) : NEW_LINE INDENT self . info . hide ( ) ; NEW_LINE self . infobar . rass_interactive = self . session . openWithCallback ( self . RassInteractiveClosed , RassInteractive ) NEW_LINE DEDENT def RassInteractiveClosed ( self ) : NEW_LINE INDENT self . info . show ( ) NEW_LINE self . infobar . rass_interactive = None NEW_LINE self . infobar . RassSlidePicChanged ( ) NEW_LINE DEDENT def RassInteractivePossibilityChanged ( self , state ) : NEW_LINE INDENT self [ " RdsActions " ] . setEnabled ( state ) NEW_LINE # # # # # ▁ RDS ▁ Radiotext ▁ / ▁ Rass ▁ Support ▁ END ENDCOM DEDENT def __onExecBegin ( self ) : NEW_LINE INDENT self . info . show ( ) NEW_LINE DEDENT def __onExecEnd ( self ) : NEW_LINE INDENT self . info . hide ( ) NEW_LINE DEDENT def cancel ( self ) : NEW_LINE INDENT self . infobar . rds_display . onRassInteractivePossibilityChanged . remove ( self . RassInteractivePossibilityChanged ) NEW_LINE self . info . hide ( ) NEW_LINE # set ▁ previous ▁ tv ▁ service ENDCOM self . close ( None ) NEW_LINE DEDENT def __evServiceStart ( self ) : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT refstr = info . getInfoString ( iServiceInformation . sServiceref ) NEW_LINE self . servicelist . setPlayableIgnoreService ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT def __evServiceEnd ( self ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( eServiceReference ( ) ) NEW_LINE DEDENT def saveRoot ( self ) : NEW_LINE INDENT path = ' ' NEW_LINE for i in self . servicePathRadio : NEW_LINE INDENT path += i . toString ( ) NEW_LINE path += ' ; ' NEW_LINE DEDENT if path and path != config . radio . lastroot . value : NEW_LINE INDENT config . radio . lastroot . value = path NEW_LINE config . radio . lastroot . save ( ) NEW_LINE DEDENT DEDENT def restoreRoot ( self ) : NEW_LINE INDENT tmp = [ x for x in config . radio . lastroot . value . split ( ' ; ' ) if x != ' ' ] NEW_LINE current = [ x . toString ( ) for x in self . servicePath ] NEW_LINE if tmp != current or self . rootChanged : NEW_LINE INDENT cnt = 0 NEW_LINE for i in tmp : NEW_LINE INDENT self . servicePathRadio . append ( eServiceReference ( i ) ) NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt : NEW_LINE INDENT path = self . servicePathRadio . pop ( ) NEW_LINE self . enterPath ( path ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE self . saveRoot ( ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE DEDENT DEDENT def preEnterPath ( self , refstr ) : NEW_LINE INDENT if self . servicePathRadio and self . servicePathRadio [ 0 ] != eServiceReference ( refstr ) : NEW_LINE INDENT pathstr = config . radio . lastroot . value NEW_LINE if pathstr is not None and refstr in pathstr : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( config . radio . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def onCreate ( self ) : NEW_LINE INDENT self . setRadioMode ( ) NEW_LINE self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( config . radio . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . servicelist . setCurrent ( lastservice ) NEW_LINE self . session . nav . playService ( lastservice ) NEW_LINE DEDENT else : NEW_LINE INDENT self . session . nav . stopService ( ) NEW_LINE DEDENT self . info . show ( ) NEW_LINE DEDENT def channelSelected ( self , doClose = False ) : # ▁ just ▁ return ▁ selected ▁ service ENDCOM NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . movemode : NEW_LINE INDENT self . toggleMoveMarked ( ) NEW_LINE DEDENT elif ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT if not ( self . bouquet_mark_edit == EDIT_ALTERNATIVES and ref . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . doMark ( ) NEW_LINE DEDENT DEDENT elif not ( ref . flags & eServiceReference . isMarker ) : # ▁ no ▁ marker ENDCOM NEW_LINE INDENT cur_root = self . getRoot ( ) NEW_LINE if not cur_root or not ( cur_root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref is None or playingref != ref : NEW_LINE INDENT self . session . nav . playService ( ref ) NEW_LINE config . radio . lastservice . value = ref . toString ( ) NEW_LINE config . radio . lastservice . save ( ) NEW_LINE DEDENT self . saveRoot ( ) NEW_LINE DEDENT DEDENT DEDENT def zapBack ( self ) : NEW_LINE INDENT self . channelSelected ( ) NEW_LINE DEDENT DEDENT class SimpleChannelSelection ( ChannelSelectionBase , SelectionEventInfo ) : NEW_LINE INDENT def __init__ ( self , session , title , currentBouquet = False , returnBouquet = False , setService = None , setBouquet = None ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " cancel " : self . close , " ok " : self . channelSelected , " keyRadio " : self . setModeRadio , " keyTV " : self . setModeTv , } ) NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE if isinstance ( title , str ) : NEW_LINE INDENT self . maintitle = title NEW_LINE DEDENT self . currentBouquet = currentBouquet NEW_LINE self . returnBouquet = returnBouquet NEW_LINE self . setService = setService NEW_LINE self . setBouquet = setBouquet NEW_LINE self . onLayoutFinish . append ( self . layoutFinished ) NEW_LINE DEDENT def layoutFinished ( self ) : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE if self . currentBouquet or self . setBouquet : NEW_LINE INDENT ref = self . setBouquet or Screens . InfoBar . InfoBar . instance . servicelist . getRoot ( ) NEW_LINE if ref : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT DEDENT if self . setService : NEW_LINE INDENT self . setCurrentSelection ( self . setService ) NEW_LINE DEDENT DEDENT def saveRoot ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def keyRecord ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT def channelSelected ( self ) : # ▁ just ▁ return ▁ selected ▁ service ENDCOM NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT elif not ( ref . flags & eServiceReference . isMarker ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . returnBouquet and len ( self . servicePath ) : NEW_LINE INDENT self . close ( ref , self . servicePath [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ref ) NEW_LINE DEDENT DEDENT DEDENT def setModeTv ( self ) : NEW_LINE INDENT self . setTvMode ( ) NEW_LINE self . showFavourites ( ) NEW_LINE DEDENT def setModeRadio ( self ) : NEW_LINE INDENT self . setRadioMode ( ) NEW_LINE self . showFavourites ( ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="mjtamlyn/django/tree/master/tests/mail/tests.py"> import asyncore NEW_LINE import base64 NEW_LINE import mimetypes NEW_LINE import os NEW_LINE import shutil NEW_LINE import smtpd NEW_LINE import socket NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import threading NEW_LINE from email import message_from_binary_file , message_from_bytes NEW_LINE from email . header import Header NEW_LINE from email . mime . text import MIMEText NEW_LINE from email . utils import parseaddr NEW_LINE from io import StringIO NEW_LINE from smtplib import SMTP , SMTPAuthenticationError , SMTPException NEW_LINE from ssl import SSLError NEW_LINE from django . core import mail NEW_LINE from django . core . mail import ( EmailMessage , EmailMultiAlternatives , mail_admins , mail_managers , send_mail , send_mass_mail , ) NEW_LINE from django . core . mail . backends import console , dummy , filebased , locmem , smtp NEW_LINE from django . core . mail . message import BadHeaderError , sanitize_address NEW_LINE from django . test import SimpleTestCase , override_settings NEW_LINE from django . test . utils import requires_tz_support NEW_LINE from django . utils . encoding import force_bytes , force_text NEW_LINE from django . utils . translation import gettext_lazy NEW_LINE class HeadersCheckMixin : NEW_LINE INDENT def assertMessageHasHeaders ( self , message , headers ) : NEW_LINE INDENT """ STRNEWLINE ▁ Asserts ▁ that ▁ the ▁ ` message ` ▁ has ▁ all ▁ ` headers ` . STRNEWLINE STRNEWLINE ▁ message : ▁ can ▁ be ▁ an ▁ instance ▁ of ▁ an ▁ email . Message ▁ subclass ▁ or ▁ a ▁ string STRNEWLINE ▁ with ▁ the ▁ contents ▁ of ▁ an ▁ email ▁ message . STRNEWLINE ▁ headers : ▁ should ▁ be ▁ a ▁ set ▁ of ▁ ( header - name , ▁ header - value ) ▁ tuples . STRNEWLINE ▁ """ NEW_LINE if isinstance ( message , bytes ) : NEW_LINE INDENT message = message_from_bytes ( message ) NEW_LINE DEDENT msg_headers = set ( message . items ( ) ) NEW_LINE self . assertTrue ( headers . issubset ( msg_headers ) , msg = ' Message ▁ is ▁ missing ▁ ' ' the ▁ following ▁ headers : ▁ % s ' % ( headers - msg_headers ) , ) NEW_LINE DEDENT DEDENT class MailTests ( HeadersCheckMixin , SimpleTestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Non - backend ▁ specific ▁ tests . STRNEWLINE ▁ """ NEW_LINE def get_decoded_attachments ( self , django_message ) : NEW_LINE INDENT """ STRNEWLINE ▁ Encode ▁ the ▁ specified ▁ django . core . mail . message . EmailMessage , ▁ then ▁ decode STRNEWLINE ▁ it ▁ using ▁ Python ' s ▁ email . parser ▁ module ▁ and , ▁ for ▁ each ▁ attachment ▁ of ▁ the STRNEWLINE ▁ message , ▁ return ▁ a ▁ list ▁ of ▁ tuples ▁ with ▁ ( filename , ▁ content , ▁ mimetype ) . STRNEWLINE ▁ """ NEW_LINE msg_bytes = django_message . message ( ) . as_bytes ( ) NEW_LINE email_message = message_from_bytes ( msg_bytes ) NEW_LINE def iter_attachments ( ) : NEW_LINE INDENT for i in email_message . walk ( ) : NEW_LINE # ▁ Once ▁ support ▁ for ▁ Python < 3.5 ▁ has ▁ been ▁ dropped , ▁ we ▁ can ▁ use ENDCOM # ▁ i . get _ content _ disposition ( ) ▁ here ▁ instead . ENDCOM INDENT content_disposition = i . get ( ' content - disposition ' , ' ' ) . split ( ' ; ' ) [ 0 ] . lower ( ) NEW_LINE if content_disposition == ' attachment ' : NEW_LINE INDENT filename = i . get_filename ( ) NEW_LINE content = i . get_payload ( decode = True ) NEW_LINE mimetype = i . get_content_type ( ) NEW_LINE yield filename , content , mimetype NEW_LINE DEDENT DEDENT DEDENT return list ( iter_attachments ( ) ) NEW_LINE DEDENT def test_ascii ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' to @ example . com ' ) NEW_LINE DEDENT def test_multiple_recipients ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' to @ example . com , ▁ other @ example . com ' ) NEW_LINE DEDENT def test_recipients_with_empty_strings ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Empty ▁ strings ▁ in ▁ various ▁ recipient ▁ arguments ▁ are ▁ always ▁ stripped STRNEWLINE ▁ off ▁ the ▁ final ▁ recipient ▁ list . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' ' ] , cc = [ ' cc @ example . com ' , ' ' ] , bcc = [ ' ' , ' bcc @ example . com ' ] , reply_to = [ ' ' , None ] , ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' cc @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT def test_cc ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 7722 """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , cc = [ ' cc @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' cc @ example . com ' ] ) NEW_LINE # ▁ Test ▁ multiple ▁ CC ▁ with ▁ multiple ▁ To ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] , cc = [ ' cc @ example . com ' , ' cc . other @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' ] ) NEW_LINE # ▁ Testing ▁ with ▁ Bcc ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] , cc = [ ' cc @ example . com ' , ' cc . other @ example . com ' ] , bcc = [ ' bcc @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT def test_reply_to ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' reply _ to @ example . com ' ] , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' reply _ to @ example . com ' ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' reply _ to1 @ example . com ' , ' reply _ to2 @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' reply _ to1 @ example . com , ▁ reply _ to2 @ example . com ' ) NEW_LINE DEDENT def test_recipients_as_tuple ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , ( ' to @ example . com ' , ' other @ example . com ' ) , cc = ( ' cc @ example . com ' , ' cc . other @ example . com ' ) , bcc = ( ' bcc @ example . com ' , ) ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT def test_recipients_as_string ( self ) : NEW_LINE INDENT with self . assertRaisesMessage ( TypeError , ' " to " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( to = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " cc " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( cc = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " bcc " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( bcc = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " reply _ to " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( reply_to = ' reply _ to @ example . com ' ) NEW_LINE DEDENT DEDENT def test_header_injection ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject \n Injection ▁ Test ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT email . message ( ) NEW_LINE DEDENT email = EmailMessage ( gettext_lazy ( ' Subject \n Injection ▁ Test ' ) , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT email . message ( ) NEW_LINE DEDENT DEDENT def test_space_continuation ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ for ▁ space ▁ continuation ▁ character ▁ in ▁ long ▁ ( ASCII ) ▁ subject ▁ headers ▁ ( # 7747 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Long ▁ subject ▁ lines ▁ that ▁ get ▁ wrapped ▁ should ▁ contain ▁ a ▁ space ▁ ' ' continuation ▁ character ▁ to ▁ get ▁ expected ▁ behavior ▁ in ▁ Outlook ▁ and ▁ Thunderbird ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] . encode ( ) , b ' Long ▁ subject ▁ lines ▁ that ▁ get ▁ wrapped ▁ should ▁ contain ▁ a ▁ space ▁ continuation \n ' b ' ▁ character ▁ to ▁ get ▁ expected ▁ behavior ▁ in ▁ Outlook ▁ and ▁ Thunderbird ' ) NEW_LINE DEDENT def test_message_header_overrides ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Specifying ▁ dates ▁ or ▁ message - ids ▁ in ▁ the ▁ extra ▁ headers ▁ overrides ▁ the STRNEWLINE ▁ default ▁ values ▁ ( # 9233 ) STRNEWLINE ▁ """ NEW_LINE headers = { " date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE email = EmailMessage ( ' subject ' , ' content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , headers = headers ) NEW_LINE self . assertMessageHasHeaders ( email . message ( ) , { ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' MIME - Version ' , '1.0' ) , ( ' Message - ID ' , ' foo ' ) , ( ' Subject ' , ' subject ' ) , ( ' To ' , ' to @ example . com ' ) , ( ' date ' , ' Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000' ) , } ) NEW_LINE DEDENT def test_from_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ we ▁ can ▁ manually ▁ set ▁ the ▁ From ▁ header ▁ ( # 9214 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE DEDENT def test_to_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ we ▁ can ▁ manually ▁ set ▁ the ▁ To ▁ header ▁ ( # 17444 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] , headers = { ' To ' : ' mailing - list @ example . com ' } ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' mailing - list @ example . com ' ) NEW_LINE self . assertEqual ( email . to , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE # ▁ If ▁ we ▁ don ' t ▁ set ▁ the ▁ To ▁ header ▁ manually , ▁ it ▁ should ▁ default ▁ to ▁ the ▁ ` to ` ▁ argument ▁ to ▁ the ▁ constructor ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' list - subscriber @ example . com , ▁ list - subscriber2 @ example . com ' ) NEW_LINE self . assertEqual ( email . to , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE DEDENT def test_reply_to_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Specifying ▁ ' Reply - To ' ▁ in ▁ headers ▁ should ▁ override ▁ reply _ to . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' foo @ example . com ' ] , headers = { ' Reply - To ' : ' override @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' override @ example . com ' ) NEW_LINE DEDENT def test_multiple_message_call ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 13259 ▁ - ▁ Make ▁ sure ▁ that ▁ headers ▁ are ▁ not ▁ changed ▁ when STRNEWLINE ▁ calling ▁ EmailMessage . message ( ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE DEDENT def test_unicode_address_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 11144 ▁ - ▁ When ▁ a ▁ to / from / cc ▁ header ▁ contains ▁ unicode , STRNEWLINE ▁ make ▁ sure ▁ the ▁ email ▁ addresses ▁ are ▁ parsed ▁ correctly ▁ ( especially ▁ with STRNEWLINE ▁ regards ▁ to ▁ commas ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' " Firstname ▁ Sürname " ▁ < to @ example . com > ' , ' other @ example . com ' ] , ) NEW_LINE self . assertEqual ( email . message ( ) [ ' To ' ] , ' = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < to @ example . com > , ▁ other @ example . com ' ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' " Sürname , ▁ Firstname " ▁ < to @ example . com > ' , ' other @ example . com ' ] , ) NEW_LINE self . assertEqual ( email . message ( ) [ ' To ' ] , ' = ? utf - 8 ? q ? S = C3 = BCrname = 2C _ Firstname ? = ▁ < to @ example . com > , ▁ other @ example . com ' ) NEW_LINE DEDENT def test_unicode_headers ( self ) : NEW_LINE INDENT email = EmailMessage ( " Gżegżółka " , " Content " , " from @ example . com " , [ " to @ example . com " ] , headers = { " Sender " : ' " Firstname ▁ Sürname " ▁ < sender @ example . com > ' , " Comments " : ' My ▁ Sürname ▁ is ▁ non - ASCII ' } ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' = ? utf - 8 ? b ? R8W8ZWfFvMOzxYJrYQ = = ? = ' ) NEW_LINE self . assertEqual ( message [ ' Sender ' ] , ' = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < sender @ example . com > ' ) NEW_LINE self . assertEqual ( message [ ' Comments ' ] , ' = ? utf - 8 ? q ? My _ S = C3 = BCrname _ is _ non - ASCII ? = ' ) NEW_LINE DEDENT def test_safe_mime_multipart ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ headers ▁ can ▁ be ▁ set ▁ with ▁ a ▁ different ▁ encoding ▁ than ▁ utf - 8 ▁ in STRNEWLINE ▁ SafeMIMEMultipart ▁ as ▁ well STRNEWLINE ▁ """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE from_email , to = ' from @ example . com ' , ' " Sürname , ▁ Firstname " ▁ < to @ example . com > ' NEW_LINE text_content = ' This ▁ is ▁ an ▁ important ▁ message . ' NEW_LINE html_content = ' < p > This ▁ is ▁ an ▁ < strong > important < / strong > ▁ message . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( ' Message ▁ from ▁ Firstname ▁ Sürname ' , text_content , from_email , [ to ] , headers = headers ) NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE msg . encoding = ' iso - 8859-1' NEW_LINE self . assertEqual ( msg . message ( ) [ ' To ' ] , ' = ? iso - 8859-1 ? q ? S = FCrname = 2C _ Firstname ? = ▁ < to @ example . com > ' ) NEW_LINE self . assertEqual ( msg . message ( ) [ ' Subject ' ] , ' = ? iso - 8859-1 ? q ? Message _ from _ Firstname _ S = FCrname ? = ' ) NEW_LINE DEDENT def test_encoding ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 12791 ▁ - ▁ Encode ▁ body ▁ correctly ▁ with ▁ other ▁ encodings STRNEWLINE ▁ than ▁ utf - 8 STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Firstname ▁ Sürname ▁ is ▁ a ▁ great ▁ guy . ' , ' from @ example . com ' , [ ' other @ example . com ' ] ) NEW_LINE email . encoding = ' iso - 8859-1' NEW_LINE message = email . message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' other @ example . com ' ) } ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Firstname ▁ S = FCrname ▁ is ▁ a ▁ great ▁ guy . ' ) NEW_LINE # ▁ Make ▁ sure ▁ MIME ▁ attachments ▁ also ▁ works ▁ correctly ▁ with ▁ other ▁ encodings ▁ than ▁ utf - 8 ENDCOM text_content = ' Firstname ▁ Sürname ▁ is ▁ a ▁ great ▁ guy . ' NEW_LINE html_content = ' < p > Firstname ▁ Sürname ▁ is ▁ a ▁ < strong > great < / strong > ▁ guy . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( ' Subject ' , text_content , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . encoding = ' iso - 8859-1' NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE payload0 = msg . message ( ) . get_payload ( 0 ) NEW_LINE self . assertMessageHasHeaders ( payload0 , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) } ) NEW_LINE self . assertTrue ( payload0 . as_bytes ( ) . endswith ( b ' \n \n Firstname ▁ S = FCrname ▁ is ▁ a ▁ great ▁ guy . ' ) ) NEW_LINE payload1 = msg . message ( ) . get_payload ( 1 ) NEW_LINE self . assertMessageHasHeaders ( payload1 , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / html ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) } ) NEW_LINE self . assertTrue ( payload1 . as_bytes ( ) . endswith ( b ' \n \n < p > Firstname ▁ S = FCrname ▁ is ▁ a ▁ < strong > great < / strong > ▁ guy . < / p > ' ) ) NEW_LINE DEDENT def test_attachments ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 9367 """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE subject , from_email , to = ' hello ' , ' from @ example . com ' , ' to @ example . com ' NEW_LINE text_content = ' This ▁ is ▁ an ▁ important ▁ message . ' NEW_LINE html_content = ' < p > This ▁ is ▁ an ▁ < strong > important < / strong > ▁ message . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( subject , text_content , from_email , [ to ] , headers = headers ) NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE msg . attach ( " an ▁ attachment . pdf " , b " % PDF - 1.4 . % . . . " , mimetype = " application / pdf " ) NEW_LINE msg_bytes = msg . message ( ) . as_bytes ( ) NEW_LINE message = message_from_bytes ( msg_bytes ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( message . get_content_type ( ) , ' multipart / mixed ' ) NEW_LINE self . assertEqual ( message . get_default_type ( ) , ' text / plain ' ) NEW_LINE payload = message . get_payload ( ) NEW_LINE self . assertEqual ( payload [ 0 ] . get_content_type ( ) , ' multipart / alternative ' ) NEW_LINE self . assertEqual ( payload [ 1 ] . get_content_type ( ) , ' application / pdf ' ) NEW_LINE DEDENT def test_non_ascii_attachment_filename ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 14964 """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE subject , from_email , to = ' hello ' , ' from @ example . com ' , ' to @ example . com ' NEW_LINE content = ' This ▁ is ▁ the ▁ message . ' NEW_LINE msg = EmailMessage ( subject , content , from_email , [ to ] , headers = headers ) NEW_LINE # ▁ Unicode ▁ in ▁ file ▁ name ENDCOM msg . attach ( " une ▁ pièce ▁ jointe . pdf " , b " % PDF - 1.4 . % . . . " , mimetype = " application / pdf " ) NEW_LINE msg_bytes = msg . message ( ) . as_bytes ( ) NEW_LINE message = message_from_bytes ( msg_bytes ) NEW_LINE payload = message . get_payload ( ) NEW_LINE self . assertEqual ( payload [ 1 ] . get_filename ( ) , ' une ▁ pièce ▁ jointe . pdf ' ) NEW_LINE DEDENT def test_attach_file ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ attaching ▁ a ▁ file ▁ against ▁ different ▁ mimetypes ▁ and ▁ make ▁ sure ▁ that STRNEWLINE ▁ a ▁ file ▁ will ▁ be ▁ attached ▁ and ▁ sent ▁ properly ▁ even ▁ if ▁ an ▁ invalid ▁ mimetype STRNEWLINE ▁ is ▁ specified . STRNEWLINE ▁ """ NEW_LINE files = ( # ▁ filename , ▁ actual ▁ mimetype ENDCOM ( ' file . txt ' , ' text / plain ' ) , ( ' file . png ' , ' image / png ' ) , ( ' file _ txt ' , None ) , ( ' file _ png ' , None ) , ( ' file _ txt . png ' , ' image / png ' ) , ( ' file _ png . txt ' , ' text / plain ' ) , ( ' file . eml ' , ' message / rfc822' ) , ) NEW_LINE test_mimetypes = [ ' text / plain ' , ' image / png ' , None ] NEW_LINE for basename , real_mimetype in files : NEW_LINE INDENT for mimetype in test_mimetypes : NEW_LINE INDENT email = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertEqual ( mimetypes . guess_type ( basename ) [ 0 ] , real_mimetype ) NEW_LINE self . assertEqual ( email . attachments , [ ] ) NEW_LINE file_path = os . path . join ( os . path . dirname ( __file__ ) , ' attachments ' , basename ) NEW_LINE email . attach_file ( file_path , mimetype = mimetype ) NEW_LINE self . assertEqual ( len ( email . attachments ) , 1 ) NEW_LINE self . assertIn ( basename , email . attachments [ 0 ] ) NEW_LINE msgs_sent_num = email . send ( ) NEW_LINE self . assertEqual ( msgs_sent_num , 1 ) NEW_LINE DEDENT DEDENT DEDENT def test_attach_text_as_bytes ( self ) : NEW_LINE INDENT msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' file ▁ content ' ) NEW_LINE sent_num = msg . send ( ) NEW_LINE self . assertEqual ( sent_num , 1 ) NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE self . assertEqual ( content , b ' file ▁ content ' ) NEW_LINE self . assertEqual ( mimetype , ' text / plain ' ) NEW_LINE DEDENT def test_attach_utf8_text_as_bytes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Non - ASCII ▁ characters ▁ encoded ▁ as ▁ valid ▁ UTF - 8 ▁ are ▁ correctly ▁ transported STRNEWLINE ▁ and ▁ decoded . STRNEWLINE ▁ """ NEW_LINE msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' \xc3\xa4' ) # ▁ UTF - 8 ▁ encoded ▁ a ▁ umlaut . ENDCOM NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE self . assertEqual ( content , b ' \xc3\xa4' ) NEW_LINE self . assertEqual ( mimetype , ' text / plain ' ) NEW_LINE DEDENT def test_attach_non_utf8_text_as_bytes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Binary ▁ data ▁ that ▁ can ' t ▁ be ▁ decoded ▁ as ▁ UTF - 8 ▁ overrides ▁ the ▁ MIME ▁ type STRNEWLINE ▁ instead ▁ of ▁ decoding ▁ the ▁ data . STRNEWLINE ▁ """ NEW_LINE msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' \xff ' ) # ▁ Invalid ▁ UTF - 8 . ENDCOM NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE # ▁ Content ▁ should ▁ be ▁ passed ▁ through ▁ unmodified . ENDCOM self . assertEqual ( content , b ' \xff ' ) NEW_LINE self . assertEqual ( mimetype , ' application / octet - stream ' ) NEW_LINE DEDENT def test_dummy_backend ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ dummy ▁ backends ▁ returns ▁ correct ▁ number ▁ of ▁ sent ▁ messages STRNEWLINE ▁ """ NEW_LINE connection = dummy . EmailBackend ( ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertEqual ( connection . send_messages ( [ email , email , email ] ) , 3 ) NEW_LINE DEDENT def test_arbitrary_keyword ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ get _ connection ( ) ▁ accepts ▁ arbitrary ▁ keyword ▁ that ▁ might ▁ be STRNEWLINE ▁ used ▁ with ▁ custom ▁ backends . STRNEWLINE ▁ """ NEW_LINE c = mail . get_connection ( fail_silently = True , foo = ' bar ' ) NEW_LINE self . assertTrue ( c . fail_silently ) NEW_LINE DEDENT def test_custom_backend ( self ) : NEW_LINE INDENT """ Test ▁ custom ▁ backend ▁ defined ▁ in ▁ this ▁ suite . """ NEW_LINE conn = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE self . assertTrue ( hasattr ( conn , ' test _ outbox ' ) ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE conn . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( len ( conn . test_outbox ) , 1 ) NEW_LINE DEDENT def test_backend_arg ( self ) : NEW_LINE INDENT """ Test ▁ backend ▁ argument ▁ of ▁ mail . get _ connection ( ) """ NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . smtp . EmailBackend ' ) , smtp . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . locmem . EmailBackend ' ) , locmem . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . dummy . EmailBackend ' ) , dummy . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . console . EmailBackend ' ) , console . EmailBackend ) NEW_LINE with tempfile . TemporaryDirectory ( ) as tmp_dir : NEW_LINE INDENT self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . filebased . EmailBackend ' , file_path = tmp_dir ) , filebased . EmailBackend ) NEW_LINE DEDENT self . assertIsInstance ( mail . get_connection ( ) , locmem . EmailBackend ) NEW_LINE DEDENT @ override_settings ( EMAIL_BACKEND = ' django . core . mail . backends . locmem . EmailBackend ' , ADMINS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] , MANAGERS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] ) NEW_LINE def test_connection_arg ( self ) : NEW_LINE INDENT """ Test ▁ connection ▁ argument ▁ to ▁ send _ mail ( ) , ▁ et . ▁ al . """ NEW_LINE mail . outbox = [ ] NEW_LINE # ▁ Send ▁ using ▁ non - default ▁ connection ENDCOM connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' Subject ' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE send_mass_mail ( [ ( ' Subject1' , ' Content1' , ' from1 @ example . com ' , [ ' to1 @ example . com ' ] ) , ( ' Subject2' , ' Content2' , ' from2 @ example . com ' , [ ' to2 @ example . com ' ] ) , ] , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 2 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' Subject1' ) NEW_LINE self . assertEqual ( connection . test_outbox [ 1 ] . subject , ' Subject2' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE mail_admins ( ' Admin ▁ message ' , ' Content ' , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' [ Django ] ▁ Admin ▁ message ' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE mail_managers ( ' Manager ▁ message ' , ' Content ' , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' [ Django ] ▁ Manager ▁ message ' ) NEW_LINE DEDENT def test_dont_mangle_from_in_body ( self ) : NEW_LINE # ▁ Regression ▁ for ▁ # 13433 ▁ - ▁ Make ▁ sure ▁ that ▁ EmailMessage ▁ doesn ' t ▁ mangle ENDCOM # ▁ ' From ▁ ' ▁ in ▁ message ▁ body . ENDCOM INDENT email = EmailMessage ( ' Subject ' , ' From ▁ the ▁ future ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertNotIn ( b ' > From ▁ the ▁ future ' , email . message ( ) . as_bytes ( ) ) NEW_LINE DEDENT def test_dont_base64_encode ( self ) : NEW_LINE # ▁ Ticket ▁ # 3472 ENDCOM # ▁ Shouldn ' t ▁ use ▁ Base64 ▁ encoding ▁ at ▁ all ENDCOM INDENT msg = EmailMessage ( ' Subject ' , ' UTF - 8 ▁ encoded ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 7bit ' , msg . message ( ) . as_bytes ( ) ) NEW_LINE # ▁ Ticket ▁ # 11212 ENDCOM # ▁ Shouldn ' t ▁ use ▁ quoted ▁ printable , ▁ should ▁ detect ▁ it ▁ can ▁ represent ▁ content ▁ with ▁ 7 ▁ bit ▁ data ENDCOM msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ only ▁ ASCII ▁ characters . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 7bit ' , s ) NEW_LINE # ▁ Shouldn ' t ▁ use ▁ quoted ▁ printable , ▁ should ▁ detect ▁ it ▁ can ▁ represent ▁ content ▁ with ▁ 8 ▁ bit ▁ data ENDCOM msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ latin ▁ characters : ▁ àáä . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE s = msg . message ( ) . as_string ( ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ non ▁ latin ▁ characters : ▁ А ▁ Б ▁ В ▁ Г ▁ Д ▁ Е ▁ Ж ▁ Ѕ ▁ З ▁ И ▁ І ▁ К ▁ Л ▁ М ▁ Н ▁ О ▁ П . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE s = msg . message ( ) . as_string ( ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE DEDENT def test_dont_base64_encode_message_rfc822 ( self ) : NEW_LINE # ▁ Ticket ▁ # 18967 ENDCOM # ▁ Shouldn ' t ▁ use ▁ base64 ▁ encoding ▁ for ▁ a ▁ child ▁ EmailMessage ▁ attachment . ENDCOM # ▁ Create ▁ a ▁ child ▁ message ▁ first ENDCOM INDENT child_msg = EmailMessage ( ' Child ▁ Subject ' , ' Some ▁ body ▁ of ▁ child ▁ message ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE child_s = child_msg . message ( ) . as_string ( ) NEW_LINE # ▁ Now ▁ create ▁ a ▁ parent ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE # ▁ Attach ▁ to ▁ parent ▁ as ▁ a ▁ string ENDCOM parent_msg . attach ( content = child_s , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE # ▁ Feature ▁ test : ▁ try ▁ attaching ▁ email . Message ▁ object ▁ directly ▁ to ▁ the ▁ mail . ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE parent_msg . attach ( content = child_msg . message ( ) , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE # ▁ Feature ▁ test : ▁ try ▁ attaching ▁ Django ' s ▁ EmailMessage ▁ object ▁ directly ▁ to ▁ the ▁ mail . ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE parent_msg . attach ( content = child_msg , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE DEDENT def test_sanitize_address ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ addresses ▁ are ▁ properly ▁ sanitized . STRNEWLINE ▁ """ NEW_LINE # ▁ Simple ▁ ASCII ▁ address ▁ - ▁ string ▁ form ENDCOM self . assertEqual ( sanitize_address ( ' to @ example . com ' , ' ascii ' ) , ' to @ example . com ' ) NEW_LINE self . assertEqual ( sanitize_address ( ' to @ example . com ' , ' utf - 8' ) , ' to @ example . com ' ) NEW_LINE # ▁ Simple ▁ ASCII ▁ address ▁ - ▁ tuple ▁ form ENDCOM self . assertEqual ( sanitize_address ( ( ' A ▁ name ' , ' to @ example . com ' ) , ' ascii ' ) , ' A ▁ name ▁ < to @ example . com > ' ) NEW_LINE self . assertEqual ( sanitize_address ( ( ' A ▁ name ' , ' to @ example . com ' ) , ' utf - 8' ) , ' = ? utf - 8 ? q ? A _ name ? = ▁ < to @ example . com > ' ) NEW_LINE # ▁ Unicode ▁ characters ▁ are ▁ are ▁ supported ▁ in ▁ RFC - 6532 . ENDCOM self . assertEqual ( sanitize_address ( ' tó @ example . com ' , ' utf - 8' ) , ' = ? utf - 8 ? b ? dMOz ? = @ example . com ' ) NEW_LINE self . assertEqual ( sanitize_address ( ( ' Tó ▁ Example ' , ' tó @ example . com ' ) , ' utf - 8' ) , ' = ? utf - 8 ? q ? T = C3 = B3 _ Example ? = ▁ < = ? utf - 8 ? b ? dMOz ? = @ example . com > ' ) NEW_LINE DEDENT DEDENT @ requires_tz_support NEW_LINE class MailTimeZoneTests ( SimpleTestCase ) : NEW_LINE INDENT @ override_settings ( EMAIL_USE_LOCALTIME = False , USE_TZ = True , TIME_ZONE = ' Africa / Algiers ' ) NEW_LINE def test_date_header_utc ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ EMAIL _ USE _ LOCALTIME = False ▁ creates ▁ a ▁ datetime ▁ in ▁ UTC . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertTrue ( email . message ( ) [ ' Date ' ] . endswith ( ' - 0000' ) ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_LOCALTIME = True , USE_TZ = True , TIME_ZONE = ' Africa / Algiers ' ) NEW_LINE def test_date_header_localtime ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ EMAIL _ USE _ LOCALTIME = True ▁ creates ▁ a ▁ datetime ▁ in ▁ the ▁ local ▁ time ▁ zone . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertTrue ( email . message ( ) [ ' Date ' ] . endswith ( ' + 0100' ) ) # ▁ Africa / Algiers ▁ is ▁ UTC + 1 ENDCOM NEW_LINE DEDENT DEDENT class PythonGlobalState ( SimpleTestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Tests ▁ for ▁ # 12422 ▁ - - ▁ Django ▁ smarts ▁ ( # 2472 / # 11212 ) ▁ with ▁ charset ▁ of ▁ utf - 8 ▁ text STRNEWLINE ▁ parts ▁ shouldn ' t ▁ pollute ▁ global ▁ email ▁ Python ▁ package ▁ charset ▁ registry ▁ when STRNEWLINE ▁ django . mail . message ▁ is ▁ imported . STRNEWLINE ▁ """ NEW_LINE def test_utf8 ( self ) : NEW_LINE INDENT txt = MIMEText ( ' UTF - 8 ▁ encoded ▁ body ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT def test_7bit ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ only ▁ ASCII ▁ characters . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT def test_8bit_latin ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ latin ▁ characters : ▁ àáä . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT def test_8bit_non_latin ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ non ▁ latin ▁ characters : ▁ А ▁ Б ▁ В ▁ Г ▁ Д ▁ Е ▁ Ж ▁ Ѕ ▁ З ▁ И ▁ І ▁ К ▁ Л ▁ М ▁ Н ▁ О ▁ П . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT DEDENT class BaseEmailBackendTests ( HeadersCheckMixin ) : NEW_LINE INDENT email_backend = None NEW_LINE def setUp ( self ) : NEW_LINE INDENT self . settings_override = override_settings ( EMAIL_BACKEND = self . email_backend ) NEW_LINE self . settings_override . enable ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT self . settings_override . disable ( ) NEW_LINE DEDENT def assertStartsWith ( self , first , second ) : NEW_LINE INDENT if not first . startswith ( second ) : NEW_LINE INDENT self . longMessage = True NEW_LINE self . assertEqual ( first [ : len ( second ) ] , second , " First ▁ string ▁ doesn ' t ▁ start ▁ with ▁ the ▁ second . " ) NEW_LINE DEDENT DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT raise NotImplementedError ( ' subclasses ▁ of ▁ BaseEmailBackendTests ▁ must ▁ provide ▁ a ▁ get _ mailbox _ content ( ) ▁ method ' ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT raise NotImplementedError ( ' subclasses ▁ of ▁ BaseEmailBackendTests ▁ may ▁ require ▁ a ▁ flush _ mailbox ( ) ▁ method ' ) NEW_LINE DEDENT def get_the_message ( self ) : NEW_LINE INDENT mailbox = self . get_mailbox_content ( ) NEW_LINE self . assertEqual ( len ( mailbox ) , 1 , " Expected ▁ exactly ▁ one ▁ message , ▁ got ▁ % d . \n % r " % ( len ( mailbox ) , [ m . as_string ( ) for m in mailbox ] ) ) NEW_LINE return mailbox [ 0 ] NEW_LINE DEDENT def test_send ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE num_sent = mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( num_sent , 1 ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , " Subject " ) NEW_LINE self . assertEqual ( message . get_payload ( ) , " Content " ) NEW_LINE self . assertEqual ( message [ " from " ] , " from @ example . com " ) NEW_LINE self . assertEqual ( message . get_all ( " to " ) , [ " to @ example . com " ] ) NEW_LINE DEDENT def test_send_unicode ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Chère ▁ maman ' , ' Je ▁ t\ ' aime ▁ très ▁ fort ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE num_sent = mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( num_sent , 1 ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , ' = ? utf - 8 ? q ? Ch = C3 = A8re _ maman ? = ' ) NEW_LINE self . assertEqual ( force_text ( message . get_payload ( decode = True ) ) , ' Je ▁ t\ ' aime ▁ très ▁ fort ' ) NEW_LINE DEDENT def test_send_long_lines ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ line ▁ length ▁ is ▁ limited ▁ to ▁ 998 ▁ chars ▁ by ▁ the ▁ RFC : STRNEWLINE ▁ https : / / tools . ietf . org / html / rfc5322 # section - 2.1.1 STRNEWLINE ▁ Message ▁ body ▁ containing ▁ longer ▁ lines ▁ are ▁ converted ▁ to ▁ Quoted - Printable STRNEWLINE ▁ to ▁ avoid ▁ having ▁ to ▁ insert ▁ newlines , ▁ which ▁ could ▁ be ▁ hairy ▁ to ▁ do ▁ properly . STRNEWLINE ▁ """ NEW_LINE # ▁ Unencoded ▁ body ▁ length ▁ is ▁ < ▁ 998 ▁ ( 840 ) ▁ but ▁ > ▁ 998 ▁ when ▁ utf - 8 ▁ encoded . ENDCOM email = EmailMessage ( ' Subject ' , ' В ▁ южных ▁ морях ▁ ' * 60 , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE email . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) , } ) NEW_LINE DEDENT def test_send_many ( self ) : NEW_LINE INDENT email1 = EmailMessage ( ' Subject ' , ' Content1' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE email2 = EmailMessage ( ' Subject ' , ' Content2' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE # ▁ send _ messages ( ) ▁ may ▁ take ▁ a ▁ list ▁ or ▁ a ▁ generator . ENDCOM emails_lists = ( [ email1 , email2 ] , ( email for email in [ email1 , email2 ] ) ) NEW_LINE for emails_list in emails_lists : NEW_LINE INDENT num_sent = mail . get_connection ( ) . send_messages ( emails_list ) NEW_LINE self . assertEqual ( num_sent , 2 ) NEW_LINE messages = self . get_mailbox_content ( ) NEW_LINE self . assertEqual ( len ( messages ) , 2 ) NEW_LINE self . assertEqual ( messages [ 0 ] . get_payload ( ) , ' Content1' ) NEW_LINE self . assertEqual ( messages [ 1 ] . get_payload ( ) , ' Content2' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE DEDENT DEDENT def test_send_verbose_name ( self ) : NEW_LINE INDENT email = EmailMessage ( " Subject " , " Content " , ' " Firstname ▁ Sürname " ▁ < from @ example . com > ' , [ " to @ example . com " ] ) NEW_LINE email . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , " Subject " ) NEW_LINE self . assertEqual ( message . get_payload ( ) , " Content " ) NEW_LINE self . assertEqual ( message [ " from " ] , " = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < from @ example . com > " ) NEW_LINE DEDENT def test_plaintext_send_mail ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ send _ mail ▁ without ▁ the ▁ html _ message STRNEWLINE ▁ regression ▁ test ▁ for ▁ adding ▁ html _ message ▁ parameter ▁ to ▁ send _ mail ( ) STRNEWLINE ▁ """ NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' sender @ example . com ' , [ ' nobody @ example . com ' ] ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertFalse ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_content_type ( ) , ' text / plain ' ) NEW_LINE DEDENT def test_html_send_mail ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ send _ mail """ NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' sender @ example . com ' , [ ' nobody @ example . com ' ] , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT @ override_settings ( MANAGERS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] ) NEW_LINE def test_html_mail_managers ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ mail _ managers """ NEW_LINE mail_managers ( ' Subject ' , ' Content ' , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT @ override_settings ( ADMINS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] ) NEW_LINE def test_html_mail_admins ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ mail _ admins ▁ """ NEW_LINE mail_admins ( ' Subject ' , ' Content ' , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT @ override_settings ( ADMINS = [ ( ' nobody ' , ' nobody + admin @ example . com ' ) ] , MANAGERS = [ ( ' nobody ' , ' nobody + manager @ example . com ' ) ] ) NEW_LINE def test_manager_and_admin_mail_prefix ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ String ▁ prefix ▁ + ▁ lazy ▁ translated ▁ subject ▁ = ▁ bad ▁ output STRNEWLINE ▁ Regression ▁ for ▁ # 13494 STRNEWLINE ▁ """ NEW_LINE mail_managers ( gettext_lazy ( ' Subject ' ) , ' Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE mail_admins ( gettext_lazy ( ' Subject ' ) , ' Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE DEDENT @ override_settings ( ADMINS = [ ] , MANAGERS = [ ] ) NEW_LINE def test_empty_admins ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ mail _ admins / mail _ managers ▁ doesn ' t ▁ connect ▁ to ▁ the ▁ mail ▁ server STRNEWLINE ▁ if ▁ there ▁ are ▁ no ▁ recipients ▁ ( # 9383 ) STRNEWLINE ▁ """ NEW_LINE mail_admins ( ' hi ' , ' there ' ) NEW_LINE self . assertEqual ( self . get_mailbox_content ( ) , [ ] ) NEW_LINE mail_managers ( ' hi ' , ' there ' ) NEW_LINE self . assertEqual ( self . get_mailbox_content ( ) , [ ] ) NEW_LINE DEDENT def test_message_cc_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 7722 STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , cc = [ ' cc @ example . com ' ] ) NEW_LINE mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' to @ example . com ' ) , ( ' Cc ' , ' cc @ example . com ' ) } ) NEW_LINE self . assertIn ( ' \n Date : ▁ ' , message . as_string ( ) ) NEW_LINE DEDENT def test_idn_send ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 14301 STRNEWLINE ▁ """ NEW_LINE self . assertTrue ( send_mail ( ' Subject ' , ' Content ' , ' from @ öäü . com ' , [ ' to @ öäü . com ' ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ xn - -4ca9at . com ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE m = EmailMessage ( ' Subject ' , ' Content ' , ' from @ öäü . com ' , [ ' to @ öäü . com ' ] , cc = [ ' cc @ öäü . com ' ] ) NEW_LINE m . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' cc ' ) , ' cc @ xn - -4ca9at . com ' ) NEW_LINE DEDENT def test_recipient_without_domain ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 15042 STRNEWLINE ▁ """ NEW_LINE self . assertTrue ( send_mail ( " Subject " , " Content " , " tester " , [ " django " ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , " tester " ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , " django " ) NEW_LINE DEDENT def test_lazy_addresses ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ sending ▁ should ▁ support ▁ lazy ▁ email ▁ addresses ▁ ( # 24416 ) . STRNEWLINE ▁ """ NEW_LINE _ = gettext_lazy NEW_LINE self . assertTrue ( send_mail ( ' Subject ' , ' Content ' , _ ( ' tester ' ) , [ _ ( ' django ' ) ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' tester ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' django ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE m = EmailMessage ( ' Subject ' , ' Content ' , _ ( ' tester ' ) , [ _ ( ' to1' ) , _ ( ' to2' ) ] , cc = [ _ ( ' cc1' ) , _ ( ' cc2' ) ] , bcc = [ _ ( ' bcc ' ) ] , reply_to = [ _ ( ' reply ' ) ] , ) NEW_LINE self . assertEqual ( m . recipients ( ) , [ ' to1' , ' to2' , ' cc1' , ' cc2' , ' bcc ' ] ) NEW_LINE m . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' tester ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to1 , ▁ to2' ) NEW_LINE self . assertEqual ( message . get ( ' cc ' ) , ' cc1 , ▁ cc2' ) NEW_LINE self . assertEqual ( message . get ( ' Reply - To ' ) , ' reply ' ) NEW_LINE DEDENT def test_close_connection ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Connection ▁ can ▁ be ▁ closed ▁ ( even ▁ when ▁ not ▁ explicitly ▁ opened ) STRNEWLINE ▁ """ NEW_LINE conn = mail . get_connection ( username = ' ' , password = ' ' ) NEW_LINE conn . close ( ) NEW_LINE DEDENT def test_use_as_contextmanager ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ connection ▁ can ▁ be ▁ used ▁ as ▁ a ▁ contextmanager . STRNEWLINE ▁ """ NEW_LINE opened = [ False ] NEW_LINE closed = [ False ] NEW_LINE conn = mail . get_connection ( username = ' ' , password = ' ' ) NEW_LINE def open ( ) : NEW_LINE INDENT opened [ 0 ] = True NEW_LINE DEDENT conn . open = open NEW_LINE def close ( ) : NEW_LINE INDENT closed [ 0 ] = True NEW_LINE DEDENT conn . close = close NEW_LINE with conn as same_conn : NEW_LINE INDENT self . assertTrue ( opened [ 0 ] ) NEW_LINE self . assertIs ( same_conn , conn ) NEW_LINE self . assertFalse ( closed [ 0 ] ) NEW_LINE DEDENT self . assertTrue ( closed [ 0 ] ) NEW_LINE DEDENT DEDENT class LocmemBackendTests ( BaseEmailBackendTests , SimpleTestCase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . locmem . EmailBackend ' NEW_LINE def get_mailbox_content ( self ) : NEW_LINE INDENT return [ m . message ( ) for m in mail . outbox ] NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT mail . outbox = [ ] NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT super ( ) . tearDown ( ) NEW_LINE mail . outbox = [ ] NEW_LINE DEDENT def test_locmem_shared_messages ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ the ▁ locmen ▁ backend ▁ populates ▁ the ▁ outbox . STRNEWLINE ▁ """ NEW_LINE connection = locmem . EmailBackend ( ) NEW_LINE connection2 = locmem . EmailBackend ( ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE connection . send_messages ( [ email ] ) NEW_LINE connection2 . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( len ( mail . outbox ) , 2 ) NEW_LINE DEDENT def test_validate_multiline_headers ( self ) : NEW_LINE # ▁ Ticket ▁ # 18861 ▁ - ▁ Validate ▁ emails ▁ when ▁ using ▁ the ▁ locmem ▁ backend ENDCOM INDENT with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT send_mail ( ' Subject \n Multiline ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE DEDENT DEDENT DEDENT class FileBackendTests ( BaseEmailBackendTests , SimpleTestCase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . filebased . EmailBackend ' NEW_LINE def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . tmp_dir = tempfile . mkdtemp ( ) NEW_LINE self . addCleanup ( shutil . rmtree , self . tmp_dir ) NEW_LINE self . _settings_override = override_settings ( EMAIL_FILE_PATH = self . tmp_dir ) NEW_LINE self . _settings_override . enable ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT self . _settings_override . disable ( ) NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT for filename in os . listdir ( self . tmp_dir ) : NEW_LINE INDENT os . unlink ( os . path . join ( self . tmp_dir , filename ) ) NEW_LINE DEDENT DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT messages = [ ] NEW_LINE for filename in os . listdir ( self . tmp_dir ) : NEW_LINE INDENT with open ( os . path . join ( self . tmp_dir , filename ) , ' rb ' ) as fp : NEW_LINE INDENT session = fp . read ( ) . split ( force_bytes ( ' \n ' + ( ' - ' * 79 ) + ' \n ' , encoding = ' ascii ' ) ) NEW_LINE DEDENT messages . extend ( message_from_bytes ( m ) for m in session if m ) NEW_LINE DEDENT return messages NEW_LINE DEDENT def test_file_sessions ( self ) : NEW_LINE INDENT """ Make ▁ sure ▁ opening ▁ a ▁ connection ▁ creates ▁ a ▁ new ▁ file """ NEW_LINE msg = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE connection = mail . get_connection ( ) NEW_LINE connection . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 1 ) NEW_LINE with open ( os . path . join ( self . tmp_dir , os . listdir ( self . tmp_dir ) [ 0 ] ) , ' rb ' ) as fp : NEW_LINE INDENT message = message_from_binary_file ( fp ) NEW_LINE DEDENT self . assertEqual ( message . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ example . com ' ) NEW_LINE connection2 = mail . get_connection ( ) NEW_LINE connection2 . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 2 ) NEW_LINE connection . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 2 ) NEW_LINE msg . connection = mail . get_connection ( ) NEW_LINE self . assertTrue ( connection . open ( ) ) NEW_LINE msg . send ( ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 3 ) NEW_LINE msg . send ( ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 3 ) NEW_LINE connection . close ( ) NEW_LINE DEDENT DEDENT class ConsoleBackendTests ( BaseEmailBackendTests , SimpleTestCase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . console . EmailBackend ' NEW_LINE def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . __stdout = sys . stdout NEW_LINE self . stream = sys . stdout = StringIO ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT del self . stream NEW_LINE sys . stdout = self . __stdout NEW_LINE del self . __stdout NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT self . stream = sys . stdout = StringIO ( ) NEW_LINE DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT messages = self . stream . getvalue ( ) . split ( ' \n ' + ( ' - ' * 79 ) + ' \n ' ) NEW_LINE return [ message_from_bytes ( force_bytes ( m ) ) for m in messages if m ] NEW_LINE DEDENT def test_console_stream_kwarg ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ console ▁ backend ▁ can ▁ be ▁ pointed ▁ at ▁ an ▁ arbitrary ▁ stream . STRNEWLINE ▁ """ NEW_LINE s = StringIO ( ) NEW_LINE connection = mail . get_connection ( ' django . core . mail . backends . console . EmailBackend ' , stream = s ) NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , connection = connection ) NEW_LINE message = force_bytes ( s . getvalue ( ) . split ( ' \n ' + ( ' - ' * 79 ) + ' \n ' ) [ 0 ] ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' to @ example . com ' ) } ) NEW_LINE self . assertIn ( b ' \n Date : ▁ ' , message ) NEW_LINE DEDENT DEDENT class FakeSMTPChannel ( smtpd . SMTPChannel ) : NEW_LINE INDENT def collect_incoming_data ( self , data ) : NEW_LINE INDENT try : NEW_LINE INDENT smtpd . SMTPChannel . collect_incoming_data ( self , data ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE # ▁ ignore ▁ decode ▁ error ▁ in ▁ SSL / TLS ▁ connection ▁ tests ▁ as ▁ we ▁ only ▁ care ENDCOM # ▁ whether ▁ the ▁ connection ▁ attempt ▁ was ▁ made ENDCOM INDENT pass NEW_LINE DEDENT DEDENT def smtp_AUTH ( self , arg ) : NEW_LINE INDENT if arg == ' CRAM - MD5' : NEW_LINE # ▁ This ▁ is ▁ only ▁ the ▁ first ▁ part ▁ of ▁ the ▁ login ▁ process . ▁ But ▁ it ' s ▁ enough ENDCOM # ▁ for ▁ our ▁ tests . ENDCOM INDENT challenge = base64 . b64encode ( b ' somerandomstring13579' ) NEW_LINE self . push ( '334 ▁ % s ' % challenge . decode ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . push ( '502 ▁ Error : ▁ login ▁ " % s " ▁ not ▁ implemented ' % arg ) NEW_LINE DEDENT DEDENT DEDENT class FakeSMTPServer ( smtpd . SMTPServer , threading . Thread ) : NEW_LINE INDENT """ STRNEWLINE ▁ Asyncore ▁ SMTP ▁ server ▁ wrapped ▁ into ▁ a ▁ thread . ▁ Based ▁ on ▁ DummyFTPServer ▁ from : STRNEWLINE ▁ http : / / svn . python . org / view / python / branches / py3k / Lib / test / test _ ftplib . py ? revision = 86061 & view = markup STRNEWLINE ▁ """ NEW_LINE channel_class = FakeSMTPChannel NEW_LINE def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT threading . Thread . __init__ ( self ) NEW_LINE # ▁ New ▁ kwarg ▁ added ▁ in ▁ Python ▁ 3.5 ; ▁ default ▁ switching ▁ to ▁ False ▁ in ▁ 3.6 . ENDCOM if sys . version_info >= ( 3 , 5 ) : NEW_LINE INDENT kwargs [ ' decode _ data ' ] = True NEW_LINE DEDENT smtpd . SMTPServer . __init__ ( self , * args , ** kwargs ) NEW_LINE self . _sink = [ ] NEW_LINE self . active = False NEW_LINE self . active_lock = threading . Lock ( ) NEW_LINE self . sink_lock = threading . Lock ( ) NEW_LINE DEDENT def process_message ( self , peer , mailfrom , rcpttos , data ) : NEW_LINE INDENT data = data . encode ( ) NEW_LINE m = message_from_bytes ( data ) NEW_LINE maddr = parseaddr ( m . get ( ' from ' ) ) [ 1 ] NEW_LINE if mailfrom != maddr : NEW_LINE # ▁ According ▁ to ▁ the ▁ spec , ▁ mailfrom ▁ does ▁ not ▁ necessarily ▁ match ▁ the ENDCOM # ▁ From ▁ header ▁ - ▁ this ▁ is ▁ the ▁ case ▁ where ▁ the ▁ local ▁ part ▁ isn ' t ENDCOM # ▁ encoded , ▁ so ▁ try ▁ to ▁ correct ▁ that . ENDCOM INDENT lp , domain = mailfrom . split ( ' @ ' , 1 ) NEW_LINE lp = Header ( lp , ' utf - 8' ) . encode ( ) NEW_LINE mailfrom = ' @ ' . join ( [ lp , domain ] ) NEW_LINE DEDENT if mailfrom != maddr : NEW_LINE INDENT return "553 ▁ ' % s ' ▁ ! = ▁ ' % s ' " % ( mailfrom , maddr ) NEW_LINE DEDENT with self . sink_lock : NEW_LINE INDENT self . _sink . append ( m ) NEW_LINE DEDENT DEDENT def get_sink ( self ) : NEW_LINE INDENT with self . sink_lock : NEW_LINE INDENT return self . _sink [ : ] NEW_LINE DEDENT DEDENT def flush_sink ( self ) : NEW_LINE INDENT with self . sink_lock : NEW_LINE INDENT self . _sink [ : ] = [ ] NEW_LINE DEDENT DEDENT def start ( self ) : NEW_LINE INDENT assert not self . active NEW_LINE self . __flag = threading . Event ( ) NEW_LINE threading . Thread . start ( self ) NEW_LINE self . __flag . wait ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . active = True NEW_LINE self . __flag . set ( ) NEW_LINE while self . active and asyncore . socket_map : NEW_LINE INDENT with self . active_lock : NEW_LINE INDENT asyncore . loop ( timeout = 0.1 , count = 1 ) NEW_LINE DEDENT DEDENT asyncore . close_all ( ) NEW_LINE DEDENT def stop ( self ) : NEW_LINE INDENT if self . active : NEW_LINE INDENT self . active = False NEW_LINE self . join ( ) NEW_LINE DEDENT DEDENT DEDENT class FakeAUTHSMTPConnection ( SMTP ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ SMTP ▁ connection ▁ pretending ▁ support ▁ for ▁ the ▁ AUTH ▁ command . ▁ It ▁ does ▁ not , ▁ but STRNEWLINE ▁ at ▁ least ▁ this ▁ can ▁ allow ▁ testing ▁ the ▁ first ▁ part ▁ of ▁ the ▁ AUTH ▁ process . STRNEWLINE ▁ """ NEW_LINE def ehlo ( self , name = ' ' ) : NEW_LINE INDENT response = SMTP . ehlo ( self , name = name ) NEW_LINE self . esmtp_features . update ( { ' auth ' : ' CRAM - MD5 ▁ PLAIN ▁ LOGIN ' , } ) NEW_LINE return response NEW_LINE DEDENT DEDENT class SMTPBackendTestsBase ( SimpleTestCase ) : NEW_LINE INDENT @ classmethod NEW_LINE def setUpClass ( cls ) : NEW_LINE INDENT super ( ) . setUpClass ( ) NEW_LINE cls . server = FakeSMTPServer ( ( '127.0.0.1' , 0 ) , None ) NEW_LINE cls . _settings_override = override_settings ( EMAIL_HOST = "127.0.0.1" , EMAIL_PORT = cls . server . socket . getsockname ( ) [ 1 ] ) NEW_LINE cls . _settings_override . enable ( ) NEW_LINE cls . server . start ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def tearDownClass ( cls ) : NEW_LINE INDENT cls . _settings_override . disable ( ) NEW_LINE cls . server . stop ( ) NEW_LINE super ( ) . tearDownClass ( ) NEW_LINE DEDENT DEDENT class SMTPBackendTests ( BaseEmailBackendTests , SMTPBackendTestsBase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . smtp . EmailBackend ' NEW_LINE def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . server . flush_sink ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT self . server . flush_sink ( ) NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT self . server . flush_sink ( ) NEW_LINE DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT return self . server . get_sink ( ) NEW_LINE DEDENT @ override_settings ( EMAIL_HOST_USER = " not ▁ empty ▁ username " , EMAIL_HOST_PASSWORD = " not ▁ empty ▁ password " ) NEW_LINE def test_email_authentication_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . username , ' not ▁ empty ▁ username ' ) NEW_LINE self . assertEqual ( backend . password , ' not ▁ empty ▁ password ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_HOST_USER = " not ▁ empty ▁ username " , EMAIL_HOST_PASSWORD = " not ▁ empty ▁ password " ) NEW_LINE def test_email_authentication_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( username = ' username ' , password = ' password ' ) NEW_LINE self . assertEqual ( backend . username , ' username ' ) NEW_LINE self . assertEqual ( backend . password , ' password ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_HOST_USER = " not ▁ empty ▁ username " , EMAIL_HOST_PASSWORD = " not ▁ empty ▁ password " ) NEW_LINE def test_email_disabled_authentication ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE self . assertEqual ( backend . username , ' ' ) NEW_LINE self . assertEqual ( backend . password , ' ' ) NEW_LINE DEDENT def test_auth_attempted ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Opening ▁ the ▁ backend ▁ with ▁ non ▁ empty ▁ username / password ▁ tries STRNEWLINE ▁ to ▁ authenticate ▁ against ▁ the ▁ SMTP ▁ server . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( username = ' not ▁ empty ▁ username ' , password = ' not ▁ empty ▁ password ' ) NEW_LINE with self . assertRaisesMessage ( SMTPException , ' SMTP ▁ AUTH ▁ extension ▁ not ▁ supported ▁ by ▁ server . ' ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT def test_server_open ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ open ( ) ▁ returns ▁ whether ▁ it ▁ opened ▁ a ▁ connection . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE self . assertFalse ( backend . connection ) NEW_LINE opened = backend . open ( ) NEW_LINE backend . close ( ) NEW_LINE self . assertTrue ( opened ) NEW_LINE DEDENT def test_server_login ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Even ▁ if ▁ the ▁ Python ▁ SMTP ▁ server ▁ doesn ' t ▁ support ▁ authentication , ▁ the STRNEWLINE ▁ login ▁ process ▁ starts ▁ and ▁ the ▁ appropriate ▁ exception ▁ is ▁ raised . STRNEWLINE ▁ """ NEW_LINE class CustomEmailBackend ( smtp . EmailBackend ) : NEW_LINE INDENT connection_class = FakeAUTHSMTPConnection NEW_LINE DEDENT backend = CustomEmailBackend ( username = ' username ' , password = ' password ' ) NEW_LINE with self . assertRaises ( SMTPAuthenticationError ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT @ override_settings ( EMAIL_USE_TLS = True ) NEW_LINE def test_email_tls_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_tls ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_TLS = True ) NEW_LINE def test_email_tls_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( use_tls = False ) NEW_LINE self . assertFalse ( backend . use_tls ) NEW_LINE DEDENT def test_email_tls_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertFalse ( backend . use_tls ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_SSL = True ) NEW_LINE def test_email_ssl_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_ssl ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_SSL = True ) NEW_LINE def test_email_ssl_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( use_ssl = False ) NEW_LINE self . assertFalse ( backend . use_ssl ) NEW_LINE DEDENT def test_email_ssl_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertFalse ( backend . use_ssl ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_CERTFILE = ' foo ' ) NEW_LINE def test_email_ssl_certfile_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . ssl_certfile , ' foo ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_CERTFILE = ' foo ' ) NEW_LINE def test_email_ssl_certfile_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ssl_certfile = ' bar ' ) NEW_LINE self . assertEqual ( backend . ssl_certfile , ' bar ' ) NEW_LINE DEDENT def test_email_ssl_certfile_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertIsNone ( backend . ssl_certfile ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_KEYFILE = ' foo ' ) NEW_LINE def test_email_ssl_keyfile_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . ssl_keyfile , ' foo ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_KEYFILE = ' foo ' ) NEW_LINE def test_email_ssl_keyfile_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ssl_keyfile = ' bar ' ) NEW_LINE self . assertEqual ( backend . ssl_keyfile , ' bar ' ) NEW_LINE DEDENT def test_email_ssl_keyfile_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertIsNone ( backend . ssl_keyfile ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_TLS = True ) NEW_LINE def test_email_tls_attempts_starttls ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_tls ) NEW_LINE with self . assertRaisesMessage ( SMTPException , ' STARTTLS ▁ extension ▁ not ▁ supported ▁ by ▁ server . ' ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT @ override_settings ( EMAIL_USE_SSL = True ) NEW_LINE def test_email_ssl_attempts_ssl_connection ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_ssl ) NEW_LINE with self . assertRaises ( SSLError ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT def test_connection_timeout_default ( self ) : NEW_LINE INDENT """ The ▁ connection ' s ▁ timeout ▁ value ▁ is ▁ None ▁ by ▁ default . """ NEW_LINE connection = mail . get_connection ( ' django . core . mail . backends . smtp . EmailBackend ' ) NEW_LINE self . assertIsNone ( connection . timeout ) NEW_LINE DEDENT def test_connection_timeout_custom ( self ) : NEW_LINE INDENT """ The ▁ timeout ▁ parameter ▁ can ▁ be ▁ customized . """ NEW_LINE class MyEmailBackend ( smtp . EmailBackend ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT kwargs . setdefault ( ' timeout ' , 42 ) NEW_LINE super ( ) . __init__ ( * args , ** kwargs ) NEW_LINE DEDENT DEDENT myemailbackend = MyEmailBackend ( ) NEW_LINE myemailbackend . open ( ) NEW_LINE self . assertEqual ( myemailbackend . timeout , 42 ) NEW_LINE self . assertEqual ( myemailbackend . connection . timeout , 42 ) NEW_LINE myemailbackend . close ( ) NEW_LINE DEDENT @ override_settings ( EMAIL_TIMEOUT = 10 ) NEW_LINE def test_email_timeout_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . timeout , 10 ) NEW_LINE DEDENT def test_email_msg_uses_crlf ( self ) : NEW_LINE INDENT """ # 23063 ▁ - - ▁ RFC - compliant ▁ messages ▁ are ▁ sent ▁ over ▁ SMTP . """ NEW_LINE send = SMTP . send NEW_LINE try : NEW_LINE INDENT smtp_messages = [ ] NEW_LINE def mock_send ( self , s ) : NEW_LINE INDENT smtp_messages . append ( s ) NEW_LINE return send ( self , s ) NEW_LINE DEDENT SMTP . send = mock_send NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE # ▁ Find ▁ the ▁ actual ▁ message ENDCOM msg = None NEW_LINE for i , m in enumerate ( smtp_messages ) : NEW_LINE INDENT if m [ : 4 ] == ' data ' : NEW_LINE INDENT msg = smtp_messages [ i + 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT self . assertTrue ( msg ) NEW_LINE msg = msg . decode ( ) NEW_LINE # ▁ The ▁ message ▁ only ▁ contains ▁ CRLF ▁ and ▁ not ▁ combinations ▁ of ▁ CRLF , ▁ LF , ▁ and ▁ CR . ENDCOM msg = msg . replace ( ' \n ' , ' ' ) NEW_LINE self . assertNotIn ( ' ' , msg ) NEW_LINE self . assertNotIn ( ' \n ' , msg ) NEW_LINE DEDENT finally : NEW_LINE INDENT SMTP . send = send NEW_LINE DEDENT DEDENT def test_send_messages_after_open_failed ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ send _ messages ( ) ▁ shouldn ' t ▁ try ▁ to ▁ send ▁ messages ▁ if ▁ open ( ) ▁ raises ▁ an STRNEWLINE ▁ exception ▁ after ▁ initializing ▁ the ▁ connection . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( ) NEW_LINE # ▁ Simulate ▁ connection ▁ initialization ▁ success ▁ and ▁ a ▁ subsequent ENDCOM # ▁ connection ▁ exception . ENDCOM backend . connection = True NEW_LINE backend . open = lambda : None NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertEqual ( backend . send_messages ( [ email ] ) , None ) NEW_LINE DEDENT DEDENT class SMTPBackendStoppedServerTests ( SMTPBackendTestsBase ) : NEW_LINE INDENT """ STRNEWLINE ▁ These ▁ tests ▁ require ▁ a ▁ separate ▁ class , ▁ because ▁ the ▁ FakeSMTPServer ▁ is ▁ shut STRNEWLINE ▁ down ▁ in ▁ setUpClass ( ) , ▁ and ▁ it ▁ cannot ▁ be ▁ restarted ▁ ( " RuntimeError : ▁ threads STRNEWLINE ▁ can ▁ only ▁ be ▁ started ▁ once " ) . STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def setUpClass ( cls ) : NEW_LINE INDENT super ( ) . setUpClass ( ) NEW_LINE cls . backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE cls . server . stop ( ) NEW_LINE DEDENT def test_server_stopped ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Closing ▁ the ▁ backend ▁ while ▁ the ▁ SMTP ▁ server ▁ is ▁ stopped ▁ doesn ' t ▁ raise ▁ an STRNEWLINE ▁ exception . STRNEWLINE ▁ """ NEW_LINE self . backend . close ( ) NEW_LINE DEDENT def test_fail_silently_on_connection_error ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ socket ▁ connection ▁ error ▁ is ▁ silenced ▁ with ▁ fail _ silently = True . STRNEWLINE ▁ """ NEW_LINE with self . assertRaises ( socket . error ) : NEW_LINE INDENT self . backend . open ( ) NEW_LINE DEDENT self . backend . fail_silently = True NEW_LINE self . backend . open ( ) NEW_LINE DEDENT DEDENT </DOCUMENT>
