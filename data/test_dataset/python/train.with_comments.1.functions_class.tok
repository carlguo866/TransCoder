def forwards ( self , orm ) : NEW_LINE # ▁ Dummy ▁ migration ENDCOM INDENT pass NEW_LINE DEDENT
def backwards ( self , orm ) : NEW_LINE # ▁ Dummy ▁ migration ENDCOM INDENT pass NEW_LINE DEDENT
def __init__ ( self , target_schema_version = None ) : NEW_LINE INDENT self . target_schema_version = target_schema_version NEW_LINE DEDENT
def __init__ ( self , ** kwargs ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def build_analyzer ( self ) : NEW_LINE INDENT analyzer = super ( StemmedCountVectorizer , self ) . build_analyzer ( ) NEW_LINE return lambda doc : ( english_stemmer . stem ( w ) for w in analyzer ( doc ) ) NEW_LINE # ▁ vectorizer ▁ = ▁ CountVectorizer ( min _ df = 1 , ▁ stop _ words = ' english ' , ENDCOM # ▁ preprocessor = stemmer ) ENDCOM DEDENT
def build_analyzer ( self ) : NEW_LINE INDENT analyzer = super ( StemmedTfidfVectorizer , self ) . build_analyzer ( ) NEW_LINE return lambda doc : ( english_stemmer . stem ( w ) for w in analyzer ( doc ) ) NEW_LINE DEDENT
def __init__ ( self , external_file = None ) : NEW_LINE INDENT """ Initialize ▁ the ▁ error ▁ fixer . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ external _ file : ▁ If ▁ included , ▁ all ▁ output ▁ will ▁ be ▁ directed ▁ to ▁ this ▁ file STRNEWLINE ▁ instead ▁ of ▁ overwriting ▁ the ▁ files ▁ the ▁ errors ▁ are ▁ found ▁ in . STRNEWLINE ▁ """ NEW_LINE errorhandler . ErrorHandler . __init__ ( self ) NEW_LINE self . _file_name = None NEW_LINE self . _file_token = None NEW_LINE self . _external_file = external_file NEW_LINE DEDENT
def HandleFile ( self , filename , first_token ) : NEW_LINE INDENT """ Notifies ▁ this ▁ ErrorPrinter ▁ that ▁ subsequent ▁ errors ▁ are ▁ in ▁ filename . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ filename : ▁ The ▁ name ▁ of ▁ the ▁ file ▁ about ▁ to ▁ be ▁ checked . STRNEWLINE ▁ first _ token : ▁ The ▁ first ▁ token ▁ in ▁ the ▁ file . STRNEWLINE ▁ """ NEW_LINE self . _file_name = filename NEW_LINE self . _file_token = first_token NEW_LINE self . _file_fix_count = 0 NEW_LINE self . _file_changed_lines = set ( ) NEW_LINE DEDENT
def _AddFix ( self , tokens ) : NEW_LINE INDENT """ Adds ▁ the ▁ fix ▁ to ▁ the ▁ internal ▁ count . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ tokens : ▁ The ▁ token ▁ or ▁ sequence ▁ of ▁ tokens ▁ changed ▁ to ▁ fix ▁ an ▁ error . STRNEWLINE ▁ """ NEW_LINE self . _file_fix_count += 1 NEW_LINE if hasattr ( tokens , ' line _ number ' ) : NEW_LINE INDENT self . _file_changed_lines . add ( tokens . line_number ) NEW_LINE DEDENT else : NEW_LINE INDENT for token in tokens : NEW_LINE INDENT self . _file_changed_lines . add ( token . line_number ) NEW_LINE DEDENT DEDENT DEDENT
def _GetNewRequireOrProvideTokens ( self , is_provide , namespace , line_number ) : NEW_LINE INDENT """ Returns ▁ a ▁ list ▁ of ▁ tokens ▁ to ▁ create ▁ a ▁ goog . require / provide ▁ statement . STRNEWLINE STRNEWLINE ▁ Args : STRNEWLINE ▁ is _ provide : ▁ True ▁ if ▁ getting ▁ tokens ▁ for ▁ a ▁ provide , ▁ False ▁ for ▁ require . STRNEWLINE ▁ namespace : ▁ The ▁ required ▁ or ▁ provided ▁ namespaces ▁ to ▁ get ▁ tokens ▁ for . STRNEWLINE ▁ line _ number : ▁ The ▁ line ▁ number ▁ the ▁ new ▁ require ▁ or ▁ provide ▁ statement ▁ will ▁ be STRNEWLINE ▁ on . STRNEWLINE STRNEWLINE ▁ Returns : STRNEWLINE ▁ Tokens ▁ to ▁ create ▁ a ▁ new ▁ goog . require ▁ or ▁ goog . provide ▁ statement . STRNEWLINE ▁ """ NEW_LINE string = ' goog . require ' NEW_LINE if is_provide : NEW_LINE INDENT string = ' goog . provide ' NEW_LINE DEDENT line_text = string + ' ( \ ' ' + namespace + ' \ ' ) ; \n ' NEW_LINE return [ Token ( string , Type . IDENTIFIER , line_text , line_number ) , Token ( ' ( ' , Type . START_PAREN , line_text , line_number ) , Token ( ' \ ' ' , Type . SINGLE_QUOTE_STRING_START , line_text , line_number ) , Token ( namespace , Type . STRING_TEXT , line_text , line_number ) , Token ( ' \ ' ' , Type . SINGLE_QUOTE_STRING_END , line_text , line_number ) , Token ( ' ) ' , Type . END_PAREN , line_text , line_number ) , Token ( ' ; ' , Type . SEMICOLON , line_text , line_number ) ] NEW_LINE DEDENT
def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT self . index = 0 NEW_LINE self . start_ts = time ( ) NEW_LINE self . _ts = self . start_ts NEW_LINE self . _dt = deque ( maxlen = self . sma_window ) NEW_LINE for key , val in kwargs . items ( ) : NEW_LINE INDENT setattr ( self , key , val ) NEW_LINE DEDENT DEDENT
def __getitem__ ( self , key ) : NEW_LINE INDENT if key . startswith ( ' _ ' ) : NEW_LINE INDENT return None NEW_LINE DEDENT return getattr ( self , key , None ) NEW_LINE DEDENT
def avg ( self ) : NEW_LINE INDENT return sum ( self . _dt ) / len ( self . _dt ) if self . _dt else 0 NEW_LINE DEDENT
def elapsed ( self ) : NEW_LINE INDENT return int ( time ( ) - self . start_ts ) NEW_LINE DEDENT
def elapsed_td ( self ) : NEW_LINE INDENT return timedelta ( seconds = self . elapsed ) NEW_LINE DEDENT
def update ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def start ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def finish ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def next ( self , n = 1 ) : NEW_LINE INDENT if n > 0 : NEW_LINE INDENT now = time ( ) NEW_LINE dt = ( now - self . _ts ) / n NEW_LINE self . _dt . append ( dt ) NEW_LINE self . _ts = now NEW_LINE DEDENT self . index = self . index + n NEW_LINE self . update ( ) NEW_LINE DEDENT
def iter ( self , it ) : NEW_LINE INDENT for x in it : NEW_LINE INDENT yield x NEW_LINE self . next ( ) NEW_LINE DEDENT self . finish ( ) NEW_LINE DEDENT
def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT super ( Progress , self ) . __init__ ( * args , ** kwargs ) NEW_LINE self . max = kwargs . get ( ' max ' , 100 ) NEW_LINE DEDENT
def eta ( self ) : NEW_LINE INDENT return int ( ceil ( self . avg * self . remaining ) ) NEW_LINE DEDENT
def eta_td ( self ) : NEW_LINE INDENT return timedelta ( seconds = self . eta ) NEW_LINE DEDENT
def percent ( self ) : NEW_LINE INDENT return self . progress * 100 NEW_LINE DEDENT
def progress ( self ) : NEW_LINE INDENT return min ( 1 , self . index / self . max ) NEW_LINE DEDENT
def remaining ( self ) : NEW_LINE INDENT return max ( self . max - self . index , 0 ) NEW_LINE DEDENT
def start ( self ) : NEW_LINE INDENT self . update ( ) NEW_LINE DEDENT
def goto ( self , index ) : NEW_LINE INDENT incr = index - self . index NEW_LINE self . next ( incr ) NEW_LINE DEDENT
def iter ( self , it ) : NEW_LINE INDENT try : NEW_LINE INDENT self . max = len ( it ) NEW_LINE DEDENT except TypeError : NEW_LINE INDENT pass NEW_LINE DEDENT for x in it : NEW_LINE INDENT yield x NEW_LINE self . next ( ) NEW_LINE DEDENT self . finish ( ) NEW_LINE DEDENT
def __init__ ( self , module ) : NEW_LINE INDENT """ Management ▁ of ▁ LXC ▁ containers ▁ via ▁ Ansible . STRNEWLINE STRNEWLINE ▁ : param ▁ module : ▁ Processed ▁ Ansible ▁ Module . STRNEWLINE ▁ : type ▁ module : ▁ ` ` object ` ` STRNEWLINE ▁ """ NEW_LINE self . module = module NEW_LINE self . name = self . module . params [ ' name ' ] NEW_LINE self . _build_config ( ) NEW_LINE self . state = self . module . params [ ' state ' ] NEW_LINE self . new_name = self . module . params . get ( ' new _ name ' , None ) NEW_LINE self . url = self . module . params [ ' url ' ] NEW_LINE self . key_file = self . module . params . get ( ' key _ file ' , None ) NEW_LINE self . cert_file = self . module . params . get ( ' cert _ file ' , None ) NEW_LINE self . debug = self . module . _verbosity >= 4 NEW_LINE try : NEW_LINE INDENT self . client = LXDClient ( self . url , key_file = self . key_file , cert_file = self . cert_file , debug = self . debug ) NEW_LINE DEDENT except LXDClientException as e : NEW_LINE INDENT self . module . fail_json ( msg = e . msg ) NEW_LINE DEDENT self . trust_password = self . module . params . get ( ' trust _ password ' , None ) NEW_LINE self . actions = [ ] NEW_LINE DEDENT
def _build_config ( self ) : NEW_LINE INDENT self . config = { } NEW_LINE for attr in CONFIG_PARAMS : NEW_LINE INDENT param_val = self . module . params . get ( attr , None ) NEW_LINE if param_val is not None : NEW_LINE INDENT self . config [ attr ] = param_val NEW_LINE DEDENT DEDENT DEDENT
def _get_profile_json ( self ) : NEW_LINE INDENT return self . client . do ( ' GET ' , ' / 1.0 / profiles / {0 } ' . format ( self . name ) , ok_error_codes = [ 404 ] ) NEW_LINE DEDENT
def _update_profile ( self ) : NEW_LINE INDENT if self . state == ' present ' : NEW_LINE INDENT if self . old_state == ' absent ' : NEW_LINE INDENT if self . new_name is None : NEW_LINE INDENT self . _create_profile ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . module . fail_json ( msg = ' new _ name ▁ must ▁ not ▁ be ▁ set ▁ when ▁ the ▁ profile ▁ does ▁ not ▁ exist ▁ and ▁ the ▁ specified ▁ state ▁ is ▁ present ' , changed = False ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . new_name is not None and self . new_name != self . name : NEW_LINE INDENT self . _rename_profile ( ) NEW_LINE DEDENT if self . _needs_to_apply_profile_configs ( ) : NEW_LINE INDENT self . _apply_profile_configs ( ) NEW_LINE DEDENT DEDENT DEDENT elif self . state == ' absent ' : NEW_LINE INDENT if self . old_state == ' present ' : NEW_LINE INDENT if self . new_name is None : NEW_LINE INDENT self . _delete_profile ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . module . fail_json ( msg = ' new _ name ▁ must ▁ not ▁ be ▁ set ▁ when ▁ the ▁ profile ▁ exists ▁ and ▁ the ▁ specified ▁ state ▁ is ▁ absent ' , changed = False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def _create_profile ( self ) : NEW_LINE INDENT config = self . config . copy ( ) NEW_LINE config [ ' name ' ] = self . name NEW_LINE self . client . do ( ' POST ' , ' / 1.0 / profiles ' , config ) NEW_LINE self . actions . append ( ' create ' ) NEW_LINE DEDENT
def _rename_profile ( self ) : NEW_LINE INDENT config = { ' name ' : self . new_name } NEW_LINE self . client . do ( ' POST ' , ' / 1.0 / profiles / { } ' . format ( self . name ) , config ) NEW_LINE self . actions . append ( ' rename ' ) NEW_LINE self . name = self . new_name NEW_LINE DEDENT
def _needs_to_change_profile_config ( self , key ) : NEW_LINE INDENT if key not in self . config : NEW_LINE INDENT return False NEW_LINE DEDENT old_configs = self . old_profile_json [ ' metadata ' ] . get ( key , None ) NEW_LINE return self . config [ key ] != old_configs NEW_LINE DEDENT
def _needs_to_apply_profile_configs ( self ) : NEW_LINE INDENT return ( self . _needs_to_change_profile_config ( ' config ' ) or self . _needs_to_change_profile_config ( ' description ' ) or self . _needs_to_change_profile_config ( ' devices ' ) ) NEW_LINE DEDENT
def _apply_profile_configs ( self ) : NEW_LINE INDENT config = self . old_profile_json . copy ( ) NEW_LINE for k , v in self . config . items ( ) : NEW_LINE INDENT config [ k ] = v NEW_LINE DEDENT self . client . do ( ' PUT ' , ' / 1.0 / profiles / { } ' . format ( self . name ) , config ) NEW_LINE self . actions . append ( ' apply _ profile _ configs ' ) NEW_LINE DEDENT
def _delete_profile ( self ) : NEW_LINE INDENT self . client . do ( ' DELETE ' , ' / 1.0 / profiles / { } ' . format ( self . name ) ) NEW_LINE self . actions . append ( ' delete ' ) NEW_LINE DEDENT
def run ( self ) : NEW_LINE INDENT """ Run ▁ the ▁ main ▁ method . """ NEW_LINE try : NEW_LINE INDENT if self . trust_password is not None : NEW_LINE INDENT self . client . authenticate ( self . trust_password ) NEW_LINE DEDENT self . old_profile_json = self . _get_profile_json ( ) NEW_LINE self . old_state = self . _profile_json_to_module_state ( self . old_profile_json ) NEW_LINE self . _update_profile ( ) NEW_LINE state_changed = len ( self . actions ) > 0 NEW_LINE result_json = { ' changed ' : state_changed , ' old _ state ' : self . old_state , ' actions ' : self . actions } NEW_LINE if self . client . debug : NEW_LINE INDENT result_json [ ' logs ' ] = self . client . logs NEW_LINE DEDENT self . module . exit_json ( ** result_json ) NEW_LINE DEDENT except LXDClientException as e : NEW_LINE INDENT state_changed = len ( self . actions ) > 0 NEW_LINE fail_params = { ' msg ' : e . msg , ' changed ' : state_changed , ' actions ' : self . actions } NEW_LINE if self . client . debug : NEW_LINE INDENT fail_params [ ' logs ' ] = e . kwargs [ ' logs ' ] NEW_LINE DEDENT self . module . fail_json ( ** fail_params ) NEW_LINE DEDENT DEDENT
