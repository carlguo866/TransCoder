<DOCUMENT_ID="astronaut1712/taiga-back/tree/master/taiga/projects/wiki/models.py"> # ▁ Copyright ▁ ( C ) ▁ 2014 ▁ Andrey ▁ Antukh ▁ < niwi @ niwi . be > ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2014 ▁ Jesús ▁ Espino ▁ < jespinog @ gmail . com > ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2014 ▁ David ▁ Barragán ▁ < bameda @ dbarragan . com > ENDCOM # ▁ This ▁ program ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ as ENDCOM # ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ENDCOM # ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ This ▁ program ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Affero ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ this ▁ program . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM from django . db import models NEW_LINE from django . contrib . contenttypes import generic NEW_LINE from django . conf import settings NEW_LINE from django . utils . translation import ugettext_lazy as _ NEW_LINE from django . utils import timezone NEW_LINE from taiga . projects . notifications . mixins import WatchedModelMixin NEW_LINE from taiga . projects . occ import OCCModelMixin NEW_LINE class WikiPage ( OCCModelMixin , WatchedModelMixin , models . Model ) : NEW_LINE INDENT project = models . ForeignKey ( " projects . Project " , null = False , blank = False , related_name = " wiki _ pages " , verbose_name = _ ( " project " ) ) NEW_LINE slug = models . SlugField ( max_length = 500 , db_index = True , null = False , blank = False , verbose_name = _ ( " slug " ) ) NEW_LINE content = models . TextField ( null = False , blank = True , verbose_name = _ ( " content " ) ) NEW_LINE owner = models . ForeignKey ( settings . AUTH_USER_MODEL , null = True , blank = True , related_name = " owned _ wiki _ pages " , verbose_name = _ ( " owner " ) ) NEW_LINE last_modifier = models . ForeignKey ( settings . AUTH_USER_MODEL , null = True , blank = True , related_name = " last _ modified _ wiki _ pages " , verbose_name = _ ( " last ▁ modifier " ) ) NEW_LINE created_date = models . DateTimeField ( null = False , blank = False , verbose_name = _ ( " created ▁ date " ) , default = timezone . now ) NEW_LINE modified_date = models . DateTimeField ( null = False , blank = False , verbose_name = _ ( " modified ▁ date " ) ) NEW_LINE attachments = generic . GenericRelation ( " attachments . Attachment " ) NEW_LINE _importing = None NEW_LINE class Meta : NEW_LINE INDENT verbose_name = " wiki ▁ page " NEW_LINE verbose_name_plural = " wiki ▁ pages " NEW_LINE ordering = [ " project " , " slug " ] NEW_LINE unique_together = ( " project " , " slug " , ) NEW_LINE permissions = ( ( " view _ wikipage " , " Can ▁ view ▁ wiki ▁ page " ) , ) NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return " project ▁ { 0 } ▁ - ▁ { 1 } " . format ( self . project_id , self . slug ) NEW_LINE DEDENT def save ( self , * args , ** kwargs ) : NEW_LINE INDENT if not self . _importing or not self . modified_date : NEW_LINE INDENT self . modified_date = timezone . now ( ) NEW_LINE DEDENT return super ( ) . save ( * args , ** kwargs ) NEW_LINE DEDENT DEDENT class WikiLink ( models . Model ) : NEW_LINE INDENT project = models . ForeignKey ( " projects . Project " , null = False , blank = False , related_name = " wiki _ links " , verbose_name = _ ( " project " ) ) NEW_LINE title = models . CharField ( max_length = 500 , null = False , blank = False ) NEW_LINE href = models . SlugField ( max_length = 500 , db_index = True , null = False , blank = False , verbose_name = _ ( " href " ) ) NEW_LINE order = models . PositiveSmallIntegerField ( default = 1 , null = False , blank = False , verbose_name = _ ( " order " ) ) NEW_LINE class Meta : NEW_LINE INDENT verbose_name = " wiki ▁ link " NEW_LINE verbose_name_plural = " wiki ▁ links " NEW_LINE ordering = [ " project " , " order " ] NEW_LINE unique_together = ( " project " , " href " ) NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return self . title NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="factorybuild/stbgui/tree/master/lib/python/Screens/ChannelSelection.py"> from Tools . Profile import profile NEW_LINE from Screen import Screen NEW_LINE import Screens . InfoBar NEW_LINE import Components . ParentalControl NEW_LINE from Components . Button import Button NEW_LINE from Components . ServiceList import ServiceList , refreshServiceList NEW_LINE from Components . ActionMap import NumberActionMap , ActionMap , HelpableActionMap NEW_LINE from Components . MenuList import MenuList NEW_LINE from Components . ServiceEventTracker import ServiceEventTracker , InfoBarBase NEW_LINE profile ( " ChannelSelection . py ▁ 1" ) NEW_LINE from EpgSelection import EPGSelection NEW_LINE from enigma import eServiceReference , eEPGCache , eServiceCenter , eRCInput , eTimer , eDVBDB , iPlayableService , iServiceInformation , getPrevAsciiCode , eEnv NEW_LINE from Components . config import config , configfile , ConfigSubsection , ConfigText , ConfigYesNo NEW_LINE from Tools . NumericalTextInput import NumericalTextInput NEW_LINE profile ( " ChannelSelection . py ▁ 2" ) NEW_LINE from Components . NimManager import nimmanager NEW_LINE profile ( " ChannelSelection . py ▁ 2.1" ) NEW_LINE from Components . Sources . RdsDecoder import RdsDecoder NEW_LINE profile ( " ChannelSelection . py ▁ 2.2" ) NEW_LINE from Components . Sources . ServiceEvent import ServiceEvent NEW_LINE from Components . Sources . Event import Event NEW_LINE profile ( " ChannelSelection . py ▁ 2.3" ) NEW_LINE from Components . Input import Input NEW_LINE profile ( " ChannelSelection . py ▁ 3" ) NEW_LINE from Components . ChoiceList import ChoiceList , ChoiceEntryComponent NEW_LINE from Components . SystemInfo import SystemInfo NEW_LINE from Screens . InputBox import PinInput NEW_LINE from Screens . VirtualKeyBoard import VirtualKeyBoard NEW_LINE from Screens . MessageBox import MessageBox NEW_LINE from Screens . ServiceInfo import ServiceInfo NEW_LINE from Screens . Hotkey import InfoBarHotkey , hotkeyActionMap , getHotkeyFunctions NEW_LINE profile ( " ChannelSelection . py ▁ 4" ) NEW_LINE from Screens . PictureInPicture import PictureInPicture NEW_LINE from Screens . RdsDisplay import RassInteractive NEW_LINE from ServiceReference import ServiceReference NEW_LINE from Tools . BoundFunction import boundFunction NEW_LINE from Tools import Notifications NEW_LINE from Tools . Alternatives import CompareWithAlternatives , GetWithAlternative NEW_LINE from Tools . Directories import fileExists NEW_LINE from Plugins . Plugin import PluginDescriptor NEW_LINE from Components . PluginComponent import plugins NEW_LINE from Screens . ChoiceBox import ChoiceBox NEW_LINE from Screens . EventView import EventViewEPGSelect NEW_LINE import os , unicodedata NEW_LINE profile ( " ChannelSelection . py ▁ after ▁ imports " ) NEW_LINE FLAG_SERVICE_NEW_FOUND = 64 NEW_LINE FLAG_IS_DEDICATED_3D = 128 NEW_LINE FLAG_HIDE_VBI = 512 # define ▁ in ▁ lib / dvb / idvb . h ▁ as ▁ dxNewFound ▁ = ▁ 64 ▁ and ▁ dxIsDedicated3D ▁ = ▁ 128 ENDCOM NEW_LINE class BouquetSelector ( Screen ) : NEW_LINE INDENT def __init__ ( self , session , bouquets , selectedFunc , enableWrapAround = True ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . setTitle ( _ ( " Choose ▁ bouquet " ) ) NEW_LINE self . selectedFunc = selectedFunc NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " ] , { " ok " : self . okbuttonClick , " cancel " : self . cancelClick } ) NEW_LINE entrys = [ ( x [ 0 ] , x [ 1 ] ) for x in bouquets ] NEW_LINE self [ " menu " ] = MenuList ( entrys , enableWrapAround ) NEW_LINE DEDENT def getCurrent ( self ) : NEW_LINE INDENT cur = self [ " menu " ] . getCurrent ( ) NEW_LINE return cur and cur [ 1 ] NEW_LINE DEDENT def okbuttonClick ( self ) : NEW_LINE INDENT self . selectedFunc ( self . getCurrent ( ) ) NEW_LINE DEDENT def up ( self ) : NEW_LINE INDENT self [ " menu " ] . up ( ) NEW_LINE DEDENT def down ( self ) : NEW_LINE INDENT self [ " menu " ] . down ( ) NEW_LINE DEDENT def cancelClick ( self ) : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT DEDENT class SilentBouquetSelector : NEW_LINE INDENT def __init__ ( self , bouquets , enableWrapAround = False , current = 0 ) : NEW_LINE INDENT self . bouquets = [ b [ 1 ] for b in bouquets ] NEW_LINE self . pos = current NEW_LINE self . count = len ( bouquets ) NEW_LINE self . enableWrapAround = enableWrapAround NEW_LINE DEDENT def up ( self ) : NEW_LINE INDENT if self . pos > 0 or self . enableWrapAround : NEW_LINE INDENT self . pos = ( self . pos - 1 ) % self . count NEW_LINE DEDENT DEDENT def down ( self ) : NEW_LINE INDENT if self . pos < ( self . count - 1 ) or self . enableWrapAround : NEW_LINE INDENT self . pos = ( self . pos + 1 ) % self . count NEW_LINE DEDENT DEDENT def getCurrent ( self ) : NEW_LINE INDENT return self . bouquets [ self . pos ] NEW_LINE # ▁ csel . bouquet _ mark _ edit ▁ values ENDCOM DEDENT DEDENT OFF = 0 NEW_LINE EDIT_BOUQUET = 1 NEW_LINE EDIT_ALTERNATIVES = 2 NEW_LINE def append_when_current_valid ( current , menu , args , level = 0 , key = " " ) : NEW_LINE INDENT if current and current . valid ( ) and level <= config . usage . setup_level . index : NEW_LINE INDENT menu . append ( ChoiceEntryComponent ( key , args ) ) NEW_LINE DEDENT DEDENT def removed_userbouquets_available ( ) : NEW_LINE INDENT for file in os . listdir ( " / etc / enigma2 / " ) : NEW_LINE INDENT if file . startswith ( " userbouquet " ) and file . endswith ( " . del " ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT class ChannelContextMenu ( Screen ) : NEW_LINE INDENT def __init__ ( self , session , csel ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . csel = csel NEW_LINE self . bsel = None NEW_LINE if self . isProtected ( ) : NEW_LINE INDENT self . onFirstExecBegin . append ( boundFunction ( self . session . openWithCallback , self . protectResult , PinInput , pinList = [ x . value for x in config . ParentalControl . servicepin ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Please ▁ enter ▁ the ▁ correct ▁ pin ▁ code " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) ) NEW_LINE DEDENT self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " ColorActions " , " NumberActions " , " MenuActions " ] , { " ok " : self . okbuttonClick , " cancel " : self . cancelClick , " blue " : self . showServiceInPiP , " red " : self . playMain , " menu " : self . openSetup , "2" : self . renameEntry , "3" : self . findCurrentlyPlayed , "5" : self . addServiceToBouquetOrAlternative , "6" : self . toggleMoveModeSelect , "8" : self . removeEntry } ) NEW_LINE menu = [ ] NEW_LINE self . removeFunction = False NEW_LINE self . addFunction = False NEW_LINE current = csel . getCurrentSelection ( ) NEW_LINE current_root = csel . getRoot ( ) NEW_LINE current_sel_path = current . getPath ( ) NEW_LINE current_sel_flags = current . flags NEW_LINE inBouquetRootList = current_root and ' FROM ▁ BOUQUET ▁ " bouquets . ' in current_root . getPath ( ) # FIXME ▁ HACK ENDCOM NEW_LINE inAlternativeList = current_root and ' FROM ▁ BOUQUET ▁ " alternatives ' in current_root . getPath ( ) NEW_LINE self . inBouquet = csel . getMutableList ( ) is not None NEW_LINE haveBouquets = config . usage . multibouquet . value NEW_LINE from Components . ParentalControl import parentalControl NEW_LINE self . parentalControl = parentalControl NEW_LINE self . parentalControlEnabled = config . ParentalControl . servicepin [ 0 ] . value and config . ParentalControl . servicepinactive . value NEW_LINE if not ( current_sel_path or current_sel_flags & ( eServiceReference . isDirectory | eServiceReference . isMarker ) ) or current_sel_flags & eServiceReference . isGroup : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " show ▁ transponder ▁ info " ) , self . showServiceInformations ) , level = 2 ) NEW_LINE DEDENT if csel . bouquet_mark_edit == OFF and not csel . entry_marked : NEW_LINE INDENT if not inBouquetRootList : NEW_LINE INDENT isPlayable = not ( current_sel_flags & ( eServiceReference . isMarker | eServiceReference . isDirectory ) ) NEW_LINE if isPlayable : NEW_LINE INDENT for p in plugins . getPlugins ( PluginDescriptor . WHERE_CHANNEL_CONTEXT_MENU ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( p . name , boundFunction ( self . runPlugin , p ) ) , key = " bullet " ) NEW_LINE DEDENT if config . servicelist . startupservice . value == current . toString ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " stop ▁ using ▁ as ▁ startup ▁ service " ) , self . unsetStartupService ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " set ▁ as ▁ startup ▁ service " ) , self . setStartupService ) , level = 0 ) NEW_LINE DEDENT if self . parentalControlEnabled : NEW_LINE INDENT if self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ to ▁ parental ▁ protection " ) , boundFunction ( self . addParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if self . parentalControl . isServiceProtectionBouquet ( current . toCompareString ( ) ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " service ▁ is ▁ in ▁ bouquet ▁ parental ▁ protection " ) , self . cancelClick ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ from ▁ parental ▁ protection " ) , boundFunction ( self . removeParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT DEDENT if config . ParentalControl . hideBlacklist . value and not parentalControl . sessionPinCached and config . ParentalControl . storeservicepin . value != " never " : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Unhide ▁ parental ▁ control ▁ services " ) , self . unhideParentalServices ) , level = 0 , key = "1" ) NEW_LINE DEDENT DEDENT if SystemInfo [ "3DMode " ] and fileExists ( " / usr / lib / enigma2 / python / Plugins / SystemPlugins / OSD3DSetup / plugin . py " ) : NEW_LINE INDENT if eDVBDB . getInstance ( ) . getFlag ( eServiceReference ( current . toString ( ) ) ) & FLAG_IS_DEDICATED_3D : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Unmark ▁ service ▁ as ▁ dedicated ▁ 3D ▁ service " ) , self . removeDedicated3DFlag ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Mark ▁ service ▁ as ▁ dedicated ▁ 3D ▁ service " ) , self . addDedicated3DFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT if not ( current_sel_path ) : NEW_LINE INDENT if eDVBDB . getInstance ( ) . getFlag ( eServiceReference ( current . toString ( ) ) ) & FLAG_HIDE_VBI : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Uncover ▁ dashed ▁ flickering ▁ line ▁ for ▁ this ▁ service " ) , self . removeHideVBIFlag ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Cover ▁ dashed ▁ flickering ▁ line ▁ for ▁ this ▁ service " ) , self . addHideVBIFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT if haveBouquets : NEW_LINE INDENT bouquets = self . csel . getBouquetList ( ) NEW_LINE if bouquets is None : NEW_LINE INDENT bouquetCnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT bouquetCnt = len ( bouquets ) NEW_LINE DEDENT if not self . inBouquet or bouquetCnt > 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ service ▁ to ▁ bouquet " ) , self . addServiceToBouquetSelected ) , level = 0 , key = "5" ) NEW_LINE self . addFunction = self . addServiceToBouquetSelected NEW_LINE DEDENT if not self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeSatelliteService NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ service ▁ to ▁ favourites " ) , self . addServiceToBouquetSelected ) , level = 0 , key = "5" ) NEW_LINE self . addFunction = self . addServiceToBouquetSelected NEW_LINE DEDENT DEDENT if SystemInfo [ " PIPAvailable " ] : NEW_LINE INDENT if not self . parentalControlEnabled or self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT if self . csel . dopipzap : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " play ▁ in ▁ mainwindow " ) , self . playMain ) , level = 0 , key = " red " ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " play ▁ as ▁ picture ▁ in ▁ picture " ) , self . showServiceInPiP ) , level = 0 , key = " blue " ) NEW_LINE DEDENT DEDENT DEDENT append_when_current_valid ( current , menu , ( _ ( " find ▁ currently ▁ played ▁ service " ) , self . findCurrentlyPlayed ) , level = 0 , key = "3" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ' FROM ▁ SATELLITES ' in current_root . getPath ( ) and current and _ ( " Services " ) in eServiceCenter . getInstance ( ) . info ( current ) . getName ( current ) : NEW_LINE INDENT unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ cable ▁ services " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ terrestrial ▁ services " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ selected ▁ satellite " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT DEDENT if haveBouquets : NEW_LINE INDENT if not self . inBouquet and not " PROVIDERS " in current_sel_path : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " copy ▁ to ▁ bouquets " ) , self . copyCurrentToBouquetList ) , level = 0 ) NEW_LINE DEDENT DEDENT if ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in current_sel_path : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ all ▁ new ▁ found ▁ flags " ) , self . removeAllNewFoundFlags ) , level = 0 ) NEW_LINE DEDENT DEDENT if self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE if not inAlternativeList : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeCurrentService NEW_LINE DEDENT DEDENT if current_root and ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in current_root . getPath ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ new ▁ found ▁ flag " ) , self . removeNewFoundFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . parentalControlEnabled : NEW_LINE INDENT if self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ bouquet ▁ to ▁ parental ▁ protection " ) , boundFunction ( self . addParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ bouquet ▁ from ▁ parental ▁ protection " ) , boundFunction ( self . removeParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT DEDENT menu . append ( ChoiceEntryComponent ( text = ( _ ( " add ▁ bouquet " ) , self . showBouquetInputBox ) ) ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeBouquet NEW_LINE if removed_userbouquets_available ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " purge ▁ deleted ▁ userbouquets " ) , self . purgeDeletedBouquets ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " restore ▁ deleted ▁ userbouquets " ) , self . restoreDeletedBouquets ) , level = 0 ) NEW_LINE DEDENT DEDENT DEDENT if self . inBouquet : # ▁ current ▁ list ▁ is ▁ editable ? ENDCOM NEW_LINE INDENT if csel . bouquet_mark_edit == OFF : NEW_LINE INDENT if csel . movemode : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " disable ▁ move ▁ mode " ) , self . toggleMoveMode ) , level = 0 , key = "6" ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ move ▁ mode " ) , self . toggleMoveMode ) , level = 1 , key = "6" ) NEW_LINE DEDENT if not csel . entry_marked and not inBouquetRootList and current_root and not ( current_root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT if current . type != - 1 : NEW_LINE INDENT menu . append ( ChoiceEntryComponent ( text = ( _ ( " add ▁ marker " ) , self . showMarkerInputBox ) ) ) NEW_LINE DEDENT if not csel . movemode : NEW_LINE INDENT if haveBouquets : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ bouquet ▁ edit " ) , self . bouquetMarkStart ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ favourite ▁ edit " ) , self . bouquetMarkStart ) , level = 0 ) NEW_LINE DEDENT DEDENT if current_sel_flags & eServiceReference . isGroup : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " edit ▁ alternatives " ) , self . editAlternativeServices ) , level = 2 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " show ▁ alternatives " ) , self . showAlternativeServices ) , level = 2 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ all ▁ alternatives " ) , self . removeAlternativeServices ) , level = 2 ) NEW_LINE DEDENT elif not current_sel_flags & eServiceReference . isMarker : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ alternatives " ) , self . addAlternativeServices ) , level = 2 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if csel . bouquet_mark_edit == EDIT_BOUQUET : NEW_LINE INDENT if haveBouquets : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ bouquet ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ bouquet ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ favourites ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ favourites ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT if current_sel_flags & eServiceReference . isMarker : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeCurrentService NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ alternatives ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ alternatives ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT DEDENT DEDENT menu . append ( ChoiceEntryComponent ( " menu " , ( _ ( " Configuration . . . " ) , self . openSetup ) ) ) NEW_LINE self [ " menu " ] = ChoiceList ( menu ) NEW_LINE DEDENT def set3DMode ( self , value ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE if config . plugins . OSD3DSetup . mode . value == " auto " and ( playingref and playingref == self . csel . getCurrentSelection ( ) ) : NEW_LINE INDENT from Plugins . SystemPlugins . OSD3DSetup . plugin import applySettings NEW_LINE applySettings ( value and " sidebyside " or config . plugins . OSD3DSetup . mode . value ) NEW_LINE DEDENT DEDENT def addDedicated3DFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . addFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_IS_DEDICATED_3D ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . set3DMode ( True ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeDedicated3DFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_IS_DEDICATED_3D ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . set3DMode ( False ) NEW_LINE self . close ( ) NEW_LINE DEDENT def addHideVBIFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . addFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_HIDE_VBI ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE Screens . InfoBar . InfoBar . instance . showHideVBI ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeHideVBIFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_HIDE_VBI ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE Screens . InfoBar . InfoBar . instance . showHideVBI ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def isProtected ( self ) : NEW_LINE INDENT return self . csel . protectContextMenu and config . ParentalControl . setuppinactive . value and config . ParentalControl . config_sections . context_menus . value NEW_LINE DEDENT def protectResult ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . csel . protectContextMenu = False NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def addServiceToBouquetOrAlternative ( self ) : NEW_LINE INDENT if self . addFunction : NEW_LINE INDENT self . addFunction ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def getCurrentSelectionName ( self ) : NEW_LINE INDENT cur = self . csel . getCurrentSelection ( ) NEW_LINE if cur and cur . valid ( ) : NEW_LINE INDENT name = eServiceCenter . getInstance ( ) . info ( cur ) . getName ( cur ) or ServiceReference ( cur ) . getServiceName ( ) or " " NEW_LINE name = name . replace ( ' \xc2\x86' , ' ' ) . replace ( ' \xc2\x87' , ' ' ) NEW_LINE return name NEW_LINE DEDENT return " " NEW_LINE DEDENT def removeEntry ( self ) : NEW_LINE INDENT if self . removeFunction and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT if self . csel . confirmRemove : NEW_LINE INDENT list = [ ( _ ( " yes " ) , True ) , ( _ ( " no " ) , False ) , ( _ ( " yes " ) + " ▁ " + _ ( " and ▁ never ▁ ask ▁ again ▁ this ▁ session ▁ again " ) , " never " ) ] NEW_LINE self . session . openWithCallback ( self . removeFunction , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ this ▁ entry ? " ) + " \n % s " % self . getCurrentSelectionName ( ) , list = list ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeFunction ( True ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def removeCurrentService ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . csel . confirmRemove = False NEW_LINE DEDENT self . csel . removeCurrentService ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def removeSatelliteService ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . csel . confirmRemove = False NEW_LINE DEDENT self . csel . removeSatelliteService ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def removeBouquet ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . csel . removeBouquet ( ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def purgeDeletedBouquets ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . purgeDeletedBouquetsCallback , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ purge ▁ all ▁ deleted ▁ userbouquets ? " ) ) NEW_LINE DEDENT def purgeDeletedBouquetsCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT for file in os . listdir ( " / etc / enigma2 / " ) : NEW_LINE INDENT if file . startswith ( " userbouquet " ) and file . endswith ( " . del " ) : NEW_LINE INDENT file = " / etc / enigma2 / " + file NEW_LINE print " permantly ▁ remove ▁ file ▁ " , file NEW_LINE os . remove ( file ) NEW_LINE DEDENT DEDENT self . close ( ) NEW_LINE DEDENT DEDENT def restoreDeletedBouquets ( self ) : NEW_LINE INDENT for file in os . listdir ( " / etc / enigma2 / " ) : NEW_LINE INDENT if file . startswith ( " userbouquet " ) and file . endswith ( " . del " ) : NEW_LINE INDENT file = " / etc / enigma2 / " + file NEW_LINE print " restore ▁ file ▁ " , file [ : - 4 ] NEW_LINE os . rename ( file , file [ : - 4 ] ) NEW_LINE DEDENT DEDENT eDVBDBInstance = eDVBDB . getInstance ( ) NEW_LINE eDVBDBInstance . setLoadUnlinkedUserbouquets ( True ) NEW_LINE eDVBDBInstance . reloadBouquets ( ) NEW_LINE eDVBDBInstance . setLoadUnlinkedUserbouquets ( config . misc . load_unlinked_userbouquets . value ) NEW_LINE refreshServiceList ( ) NEW_LINE self . csel . showFavourites ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def playMain ( self ) : NEW_LINE INDENT sel = self . csel . getCurrentSelection ( ) NEW_LINE if sel and sel . valid ( ) and self . csel . dopipzap and ( not self . parentalControlEnabled or self . parentalControl . getProtectionLevel ( self . csel . getCurrentSelection ( ) . toCompareString ( ) ) == - 1 ) : NEW_LINE INDENT self . csel . zap ( ) NEW_LINE self . csel . setCurrentSelection ( sel ) NEW_LINE self . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def okbuttonClick ( self ) : NEW_LINE INDENT self [ " menu " ] . getCurrent ( ) [ 0 ] [ 1 ] ( ) NEW_LINE DEDENT def openSetup ( self ) : NEW_LINE INDENT from Screens . Setup import Setup NEW_LINE self . session . openWithCallback ( self . cancelClick , Setup , " userinterface " ) NEW_LINE DEDENT def cancelClick ( self , dummy = False ) : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT def showServiceInformations ( self ) : NEW_LINE INDENT current = self . csel . getCurrentSelection ( ) NEW_LINE if current . flags & eServiceReference . isGroup : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref and playingref == current : NEW_LINE INDENT current = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current = eServiceReference ( GetWithAlternative ( current . toString ( ) ) ) NEW_LINE DEDENT DEDENT self . session . open ( ServiceInfo , current ) NEW_LINE self . close ( ) NEW_LINE DEDENT def setStartupService ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . setStartupServiceCallback , MessageBox , _ ( " Set ▁ startup ▁ service " ) , list = [ ( _ ( " Only ▁ on ▁ startup " ) , " startup " ) , ( _ ( " Also ▁ on ▁ standby " ) , " standby " ) ] ) NEW_LINE DEDENT def setStartupServiceCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT config . servicelist . startupservice . value = self . csel . getCurrentSelection ( ) . toString ( ) NEW_LINE path = ' ; ' . join ( [ i . toString ( ) for i in self . csel . servicePath ] ) NEW_LINE config . servicelist . startuproot . value = path NEW_LINE config . servicelist . startupmode . value = config . servicelist . lastmode . value NEW_LINE config . servicelist . startupservice_onstandby . value = answer == " standby " NEW_LINE config . servicelist . save ( ) NEW_LINE configfile . save ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT def unsetStartupService ( self ) : NEW_LINE INDENT config . servicelist . startupservice . value = ' ' NEW_LINE config . servicelist . startupservice_onstandby . value = False NEW_LINE config . servicelist . save ( ) NEW_LINE configfile . save ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def showBouquetInputBox ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . bouquetInputCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ a ▁ name ▁ for ▁ the ▁ new ▁ bouquet " ) , text = " bouquetname " , maxSize = False , visible_width = 56 , type = Input . TEXT ) NEW_LINE DEDENT def bouquetInputCallback ( self , bouquet ) : NEW_LINE INDENT if bouquet is not None : NEW_LINE INDENT self . csel . addBouquet ( bouquet , None ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT def addParentalProtection ( self , service ) : NEW_LINE INDENT self . parentalControl . protectService ( service . toCompareString ( ) ) NEW_LINE if config . ParentalControl . hideBlacklist . value and not self . parentalControl . sessionPinCached : NEW_LINE INDENT self . csel . servicelist . resetRoot ( ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT def removeParentalProtection ( self , service ) : NEW_LINE INDENT self . session . openWithCallback ( boundFunction ( self . pinEntered , service . toCompareString ( ) ) , PinInput , pinList = [ config . ParentalControl . servicepin [ 0 ] . value ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Enter ▁ the ▁ service ▁ pin " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) NEW_LINE DEDENT def pinEntered ( self , service , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . parentalControl . unProtectService ( service ) NEW_LINE self . close ( ) NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def unhideParentalServices ( self ) : NEW_LINE INDENT if self . csel . protectContextMenu : NEW_LINE INDENT self . session . openWithCallback ( self . unhideParentalServicesCallback , PinInput , pinList = [ config . ParentalControl . servicepin [ 0 ] . value ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Enter ▁ the ▁ service ▁ pin " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . unhideParentalServicesCallback ( True ) NEW_LINE DEDENT DEDENT def unhideParentalServicesCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT service = self . csel . servicelist . getCurrent ( ) NEW_LINE self . parentalControl . setSessionPinCached ( ) NEW_LINE self . parentalControl . hideBlacklist ( ) NEW_LINE self . csel . servicelist . resetRoot ( ) NEW_LINE self . csel . servicelist . setCurrent ( service ) NEW_LINE self . close ( ) NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def showServiceInPiP ( self ) : NEW_LINE INDENT if self . csel . dopipzap or ( self . parentalControlEnabled and not self . parentalControl . getProtectionLevel ( self . csel . getCurrentSelection ( ) . toCompareString ( ) ) == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if self . session . pipshown : NEW_LINE INDENT del self . session . pip NEW_LINE DEDENT self . session . pip = self . session . instantiateDialog ( PictureInPicture ) NEW_LINE self . session . pip . show ( ) NEW_LINE newservice = self . csel . servicelist . getCurrent ( ) NEW_LINE currentBouquet = self . csel . servicelist and self . csel . servicelist . getRoot ( ) NEW_LINE if newservice and newservice . valid ( ) : NEW_LINE INDENT if self . session . pip . playService ( newservice ) : NEW_LINE INDENT self . session . pipshown = True NEW_LINE self . session . pip . servicePath = self . csel . getCurrentServicePath ( ) NEW_LINE self . session . pip . servicePath [ 1 ] = currentBouquet NEW_LINE self . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . session . pipshown = False NEW_LINE del self . session . pip NEW_LINE self . session . openWithCallback ( self . close , MessageBox , _ ( " Could ▁ not ▁ open ▁ Picture ▁ in ▁ Picture " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def addServiceToBouquetSelected ( self ) : NEW_LINE INDENT bouquets = self . csel . getBouquetList ( ) NEW_LINE if bouquets is None : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = len ( bouquets ) NEW_LINE DEDENT if cnt > 1 : # ▁ show ▁ bouquet ▁ list ENDCOM NEW_LINE INDENT self . bsel = self . session . openWithCallback ( self . bouquetSelClosed , BouquetSelector , bouquets , self . addCurrentServiceToBouquet ) NEW_LINE DEDENT elif cnt == 1 : # ▁ add ▁ to ▁ only ▁ one ▁ existing ▁ bouquet ENDCOM NEW_LINE INDENT self . addCurrentServiceToBouquet ( bouquets [ 0 ] [ 1 ] , closeBouquetSelection = False ) NEW_LINE DEDENT DEDENT def bouquetSelClosed ( self , recursive ) : NEW_LINE INDENT self . bsel = None NEW_LINE if recursive : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT DEDENT def removeSatelliteServices ( self ) : NEW_LINE INDENT self . csel . removeSatelliteServices ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def copyCurrentToBouquetList ( self ) : NEW_LINE INDENT self . csel . copyCurrentToBouquetList ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def showMarkerInputBox ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . markerInputCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ a ▁ name ▁ for ▁ the ▁ new ▁ marker " ) , text = " markername " , maxSize = False , visible_width = 56 , type = Input . TEXT ) NEW_LINE DEDENT def markerInputCallback ( self , marker ) : NEW_LINE INDENT if marker is not None : NEW_LINE INDENT self . csel . addMarker ( marker ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT def addCurrentServiceToBouquet ( self , dest , closeBouquetSelection = True ) : NEW_LINE INDENT self . csel . addServiceToBouquet ( dest ) NEW_LINE if self . bsel is not None : NEW_LINE INDENT self . bsel . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( closeBouquetSelection ) # ▁ close ▁ bouquet ▁ selection ENDCOM NEW_LINE DEDENT DEDENT def renameEntry ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) and not self . csel . entry_marked : NEW_LINE INDENT self . csel . renameEntry ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def toggleMoveMode ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT self . csel . toggleMoveMode ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def toggleMoveModeSelect ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT self . csel . toggleMoveMode ( True ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def bouquetMarkStart ( self ) : NEW_LINE INDENT self . csel . startMarkedEdit ( EDIT_BOUQUET ) NEW_LINE self . close ( ) NEW_LINE DEDENT def bouquetMarkEnd ( self ) : NEW_LINE INDENT self . csel . endMarkedEdit ( abort = False ) NEW_LINE self . close ( ) NEW_LINE DEDENT def bouquetMarkAbort ( self ) : NEW_LINE INDENT self . csel . endMarkedEdit ( abort = True ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeNewFoundFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( self . csel . getCurrentSelection ( ) , FLAG_SERVICE_NEW_FOUND ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeAllNewFoundFlags ( self ) : NEW_LINE INDENT curpath = self . csel . getCurrentSelection ( ) . getPath ( ) NEW_LINE idx = curpath . find ( " satellitePosition ▁ = = ▁ " ) NEW_LINE if idx != - 1 : NEW_LINE INDENT tmp = curpath [ idx + 21 : ] NEW_LINE idx = tmp . find ( ' ) ' ) NEW_LINE if idx != - 1 : NEW_LINE INDENT satpos = int ( tmp [ : idx ] ) NEW_LINE eDVBDB . getInstance ( ) . removeFlags ( FLAG_SERVICE_NEW_FOUND , - 1 , - 1 , - 1 , satpos ) NEW_LINE DEDENT DEDENT self . close ( ) NEW_LINE DEDENT def editAlternativeServices ( self ) : NEW_LINE INDENT self . csel . startMarkedEdit ( EDIT_ALTERNATIVES ) NEW_LINE self . close ( ) NEW_LINE DEDENT def showAlternativeServices ( self ) : NEW_LINE INDENT self . csel [ " Service " ] . editmode = True NEW_LINE self . csel . enterPath ( self . csel . getCurrentSelection ( ) ) NEW_LINE self . close ( ) NEW_LINE DEDENT def removeAlternativeServices ( self ) : NEW_LINE INDENT self . csel . removeAlternativeServices ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT def addAlternativeServices ( self ) : NEW_LINE INDENT self . csel . addAlternativeServices ( ) NEW_LINE self . csel . startMarkedEdit ( EDIT_ALTERNATIVES ) NEW_LINE self . close ( ) NEW_LINE DEDENT def findCurrentlyPlayed ( self ) : NEW_LINE INDENT sel = self . csel . getCurrentSelection ( ) NEW_LINE if sel and sel . valid ( ) and not self . csel . entry_marked : NEW_LINE INDENT currentPlayingService = ( hasattr ( self . csel , " dopipzap " ) and self . csel . dopipzap ) and self . session . pip . getCurrentService ( ) or self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE self . csel . servicelist . setCurrent ( currentPlayingService , adjust = False ) NEW_LINE if self . csel . getCurrentSelection ( ) != currentPlayingService : NEW_LINE INDENT self . csel . setCurrentSelection ( sel ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def runPlugin ( self , plugin ) : NEW_LINE INDENT plugin ( session = self . session , service = self . csel . getCurrentSelection ( ) ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT class SelectionEventInfo : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self [ " Service " ] = self [ " ServiceEvent " ] = ServiceEvent ( ) NEW_LINE self [ " Event " ] = Event ( ) NEW_LINE self . servicelist . connectSelChanged ( self . __selectionChanged ) NEW_LINE self . timer = eTimer ( ) NEW_LINE self . timer . callback . append ( self . updateEventInfo ) NEW_LINE self . onShown . append ( self . __selectionChanged ) NEW_LINE DEDENT def __selectionChanged ( self ) : NEW_LINE INDENT if self . execing : NEW_LINE INDENT self . timer . start ( 100 , True ) NEW_LINE DEDENT DEDENT def updateEventInfo ( self ) : NEW_LINE INDENT cur = self . getCurrentSelection ( ) NEW_LINE service = self [ " Service " ] NEW_LINE service . newService ( cur ) NEW_LINE self [ " Event " ] . newEvent ( service . event ) NEW_LINE DEDENT DEDENT class ChannelSelectionEPG ( InfoBarHotkey ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . hotkeys = [ ( " Info ▁ ( EPG ) " , " info " , " Infobar / openEventView " ) , ( " Info ▁ ( EPG ) " + " ▁ " + _ ( " long " ) , " info _ long " , " Infobar / showEventInfoPlugins " ) , ( " Epg / Guide " , " epg " , " Plugins / Extensions / GraphMultiEPG / 1" ) , ( " Epg / Guide " + " ▁ " + _ ( " long " ) , " epg _ long " , " Infobar / showEventInfoPlugins " ) ] NEW_LINE self [ " ChannelSelectEPGActions " ] = hotkeyActionMap ( [ " ChannelSelectEPGActions " ] , dict ( ( x [ 1 ] , self . hotkeyGlobal ) for x in self . hotkeys ) ) NEW_LINE self . eventViewEPG = self . start_bouquet = self . epg_bouquet = None NEW_LINE self . currentSavedPath = [ ] NEW_LINE DEDENT def getKeyFunctions ( self , key ) : NEW_LINE INDENT selection = eval ( " config . misc . hotkey . " + key + " . value . split ( ' , ' ) " ) NEW_LINE selected = [ ] NEW_LINE for x in selection : NEW_LINE INDENT function = list ( function for function in getHotkeyFunctions ( ) if function [ 1 ] == x and function [ 2 ] == " EPG " ) NEW_LINE if function : NEW_LINE INDENT selected . append ( function [ 0 ] ) NEW_LINE DEDENT DEDENT return selected NEW_LINE DEDENT def runPlugin ( self , plugin ) : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . runPlugin ( plugin ) NEW_LINE DEDENT def getEPGPluginList ( self , getAll = False ) : NEW_LINE INDENT pluginlist = [ ( p . name , boundFunction ( self . runPlugin , p ) , p . path ) for p in plugins . getPlugins ( where = PluginDescriptor . WHERE_EVENTINFO ) if ' selectedevent ' not in p . __call__ . func_code . co_varnames ] or [ ] NEW_LINE from Components . ServiceEventTracker import InfoBarCount NEW_LINE if getAll or InfoBarCount == 1 : NEW_LINE INDENT pluginlist . append ( ( _ ( " Show ▁ EPG ▁ for ▁ current ▁ channel . . . " ) , self . openSingleServiceEPG , " current _ channel " ) ) NEW_LINE DEDENT pluginlist . append ( ( _ ( " Multi ▁ EPG " ) , self . openMultiServiceEPG , " multi _ epg " ) ) NEW_LINE pluginlist . append ( ( _ ( " Current ▁ event ▁ EPG " ) , self . openEventView , " event _ epg " ) ) NEW_LINE return pluginlist NEW_LINE DEDENT def showEventInfoPlugins ( self ) : NEW_LINE INDENT pluginlist = self . getEPGPluginList ( ) NEW_LINE if pluginlist : NEW_LINE INDENT self . session . openWithCallback ( self . EventInfoPluginChosen , ChoiceBox , title = _ ( " Please ▁ choose ▁ an ▁ extension . . . " ) , list = pluginlist , skin_name = " EPGExtensionsList " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . openSingleServiceEPG ( ) NEW_LINE DEDENT DEDENT def EventInfoPluginChosen ( self , answer ) : NEW_LINE INDENT if answer is not None : NEW_LINE INDENT answer [ 1 ] ( ) NEW_LINE DEDENT DEDENT def openEventView ( self ) : NEW_LINE INDENT epglist = [ ] NEW_LINE self . epglist = epglist NEW_LINE ref = self . getCurrentSelection ( ) NEW_LINE epg = eEPGCache . getInstance ( ) NEW_LINE now_event = epg . lookupEventTime ( ref , - 1 , 0 ) NEW_LINE if now_event : NEW_LINE INDENT epglist . append ( now_event ) NEW_LINE next_event = epg . lookupEventTime ( ref , - 1 , 1 ) NEW_LINE if next_event : NEW_LINE INDENT epglist . append ( next_event ) NEW_LINE DEDENT DEDENT if epglist : NEW_LINE INDENT self . eventViewEPG = self . session . openWithCallback ( self . eventViewEPGClosed , EventViewEPGSelect , epglist [ 0 ] , ServiceReference ( ref ) , self . eventViewEPGCallback , self . openSingleServiceEPG , self . openMultiServiceEPG , self . openSimilarList ) NEW_LINE DEDENT DEDENT def eventViewEPGCallback ( self , setEvent , setService , val ) : NEW_LINE INDENT epglist = self . epglist NEW_LINE if len ( epglist ) > 1 : NEW_LINE INDENT tmp = epglist [ 0 ] NEW_LINE epglist [ 0 ] = epglist [ 1 ] NEW_LINE epglist [ 1 ] = tmp NEW_LINE setEvent ( epglist [ 0 ] ) NEW_LINE DEDENT DEDENT def eventViewEPGClosed ( self , ret = False ) : NEW_LINE INDENT self . eventViewEPG = None NEW_LINE if ret : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT def openMultiServiceEPG ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref : NEW_LINE INDENT self . start_bouquet = self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE self . savedService = ref NEW_LINE self . currentSavedPath = self . servicePath [ : ] NEW_LINE services = self . getServicesList ( self . servicelist . getRoot ( ) ) NEW_LINE self . session . openWithCallback ( self . SingleMultiEPGClosed , EPGSelection , services , self . zapToService , None , bouquetChangeCB = self . changeBouquetForMultiEPG ) NEW_LINE DEDENT DEDENT def openSingleServiceEPG ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref : NEW_LINE INDENT self . start_bouquet = self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE self . savedService = ref NEW_LINE self . currentSavedPath = self . servicePath [ : ] NEW_LINE self . session . openWithCallback ( self . SingleMultiEPGClosed , EPGSelection , ref , self . zapToService , serviceChangeCB = self . changeServiceCB , bouquetChangeCB = self . changeBouquetForSingleEPG ) NEW_LINE DEDENT DEDENT def openSimilarList ( self , eventid , refstr ) : NEW_LINE INDENT self . session . open ( EPGSelection , refstr , None , eventid ) NEW_LINE DEDENT def getServicesList ( self , root ) : NEW_LINE INDENT services = [ ] NEW_LINE servicelist = root and eServiceCenter . getInstance ( ) . list ( root ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT service = servicelist . getNext ( ) NEW_LINE if not service . valid ( ) : NEW_LINE INDENT break NEW_LINE DEDENT if service . flags & ( eServiceReference . isDirectory | eServiceReference . isMarker ) : NEW_LINE INDENT continue NEW_LINE DEDENT services . append ( ServiceReference ( service ) ) NEW_LINE DEDENT DEDENT return services NEW_LINE DEDENT def SingleMultiEPGClosed ( self , ret = False ) : NEW_LINE INDENT if ret : NEW_LINE INDENT service = self . getCurrentSelection ( ) NEW_LINE if self . eventViewEPG : NEW_LINE INDENT self . eventViewEPG . close ( service ) NEW_LINE DEDENT elif service is not None : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . start_bouquet != self . epg_bouquet and len ( self . currentSavedPath ) > 0 : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( self . bouquet_root ) NEW_LINE self . epg_bouquet = self . start_bouquet NEW_LINE self . enterPath ( self . epg_bouquet ) NEW_LINE DEDENT self . setCurrentSelection ( self . savedService ) NEW_LINE DEDENT DEDENT def changeBouquetForSingleEPG ( self , direction , epg ) : NEW_LINE INDENT if config . usage . multibouquet . value : NEW_LINE INDENT inBouquet = self . getMutableList ( ) is not None NEW_LINE if inBouquet and len ( self . servicePath ) > 1 : NEW_LINE INDENT self . pathUp ( ) NEW_LINE if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( cur ) NEW_LINE self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE epg . setService ( ServiceReference ( self . getCurrentSelection ( ) ) ) NEW_LINE DEDENT DEDENT DEDENT def changeBouquetForMultiEPG ( self , direction , epg ) : NEW_LINE INDENT if config . usage . multibouquet . value : NEW_LINE INDENT inBouquet = self . getMutableList ( ) is not None NEW_LINE if inBouquet and len ( self . servicePath ) > 1 : NEW_LINE INDENT self . pathUp ( ) NEW_LINE if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( cur ) NEW_LINE self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE services = self . getServicesList ( self . epg_bouquet ) NEW_LINE epg . setServices ( services ) NEW_LINE DEDENT DEDENT DEDENT def changeServiceCB ( self , direction , epg ) : NEW_LINE INDENT beg = self . getCurrentSelection ( ) NEW_LINE while True : NEW_LINE INDENT if direction > 0 : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE if cur == beg or not ( cur . flags & eServiceReference . isMarker ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT epg . setService ( ServiceReference ( self . getCurrentSelection ( ) ) ) NEW_LINE DEDENT def zapToService ( self , service , preview = False , zapback = False ) : NEW_LINE INDENT if self . startServiceRef is None : NEW_LINE INDENT self . startServiceRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE DEDENT if service is not None : NEW_LINE INDENT if self . servicelist . getRoot ( ) != self . epg_bouquet : NEW_LINE INDENT self . servicelist . clearPath ( ) NEW_LINE if self . servicelist . bouquet_root != self . epg_bouquet : NEW_LINE INDENT self . servicelist . enterPath ( self . servicelist . bouquet_root ) NEW_LINE DEDENT self . servicelist . enterPath ( self . epg_bouquet ) NEW_LINE DEDENT self . servicelist . setCurrent ( service ) NEW_LINE DEDENT if not zapback or preview : NEW_LINE INDENT self . zap ( enable_pipzap = True ) NEW_LINE DEDENT if ( self . dopipzap or zapback ) and not preview : NEW_LINE INDENT self . zapBack ( ) NEW_LINE DEDENT if not preview : NEW_LINE INDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT DEDENT class ChannelSelectionEdit : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . entry_marked = False NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE self . mutableList = None NEW_LINE self . __marked = [ ] NEW_LINE self . saved_title = None NEW_LINE self . saved_root = None NEW_LINE self . current_ref = None NEW_LINE self . editMode = False NEW_LINE self . confirmRemove = True NEW_LINE class ChannelSelectionEditActionMap ( ActionMap ) : NEW_LINE INDENT def __init__ ( self , csel , contexts = [ ] , actions = { } , prio = 0 ) : NEW_LINE INDENT ActionMap . __init__ ( self , contexts , actions , prio ) NEW_LINE self . csel = csel NEW_LINE DEDENT def action ( self , contexts , action ) : NEW_LINE INDENT if action == " cancel " : NEW_LINE INDENT self . csel . handleEditCancel ( ) NEW_LINE return 0 # ▁ fall - trough ENDCOM NEW_LINE DEDENT elif action == " ok " : NEW_LINE INDENT return 0 # ▁ fall - trough ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT return ActionMap . action ( self , contexts , action ) NEW_LINE DEDENT DEDENT DEDENT self [ " ChannelSelectEditActions " ] = ChannelSelectionEditActionMap ( self , [ " ChannelSelectEditActions " , " OkCancelActions " ] , { " contextMenu " : self . doContext , } ) NEW_LINE DEDENT def getMutableList ( self , root = eServiceReference ( ) ) : NEW_LINE INDENT if not self . mutableList is None : NEW_LINE INDENT return self . mutableList NEW_LINE DEDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE if not root . valid ( ) : NEW_LINE INDENT root = self . getRoot ( ) NEW_LINE DEDENT list = root and serviceHandler . list ( root ) NEW_LINE if list is not None : NEW_LINE INDENT return list . startEdit ( ) NEW_LINE DEDENT return None NEW_LINE DEDENT def buildBouquetID ( self , name ) : NEW_LINE INDENT name = unicodedata . normalize ( ' NFKD ' , unicode ( name , ' utf _ 8' , errors = ' ignore ' ) ) . encode ( ' ASCII ' , ' ignore ' ) . translate ( None , ' < > : " / \ | ? * ( ) ▁ ' ) NEW_LINE while os . path . isfile ( ( self . mode == MODE_TV and " / etc / enigma2 / userbouquet . % s . tv " or " / etc / enigma2 / userbouquet . % s . radio " ) % name ) : NEW_LINE INDENT name = name . rsplit ( " _ " , 1 ) NEW_LINE name = " _ " . join ( ( name [ 0 ] , len ( name ) == 2 and name [ 1 ] . isdigit ( ) and str ( int ( name [ 1 ] ) + 1 ) or "1" ) ) NEW_LINE DEDENT return name NEW_LINE DEDENT def renameEntry ( self ) : NEW_LINE INDENT self . editMode = True NEW_LINE cur = self . getCurrentSelection ( ) NEW_LINE if cur and cur . valid ( ) : NEW_LINE INDENT name = eServiceCenter . getInstance ( ) . info ( cur ) . getName ( cur ) or ServiceReference ( cur ) . getServiceName ( ) or " " NEW_LINE name = name . replace ( ' \xc2\x86' , ' ' ) . replace ( ' \xc2\x87' , ' ' ) NEW_LINE if name : NEW_LINE INDENT self . session . openWithCallback ( self . renameEntryCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ new ▁ name : " ) , text = name ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def renameEntryCallback ( self , name ) : NEW_LINE INDENT if name : NEW_LINE INDENT mutableList = self . getMutableList ( ) NEW_LINE if mutableList : NEW_LINE INDENT current = self . servicelist . getCurrent ( ) NEW_LINE current . setName ( name ) NEW_LINE index = self . servicelist . getCurrentIndex ( ) NEW_LINE mutableList . removeService ( current , False ) NEW_LINE mutableList . addService ( current ) NEW_LINE mutableList . moveService ( current , index ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE self . servicelist . addService ( current , True ) NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE if not self . servicelist . atEnd ( ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def addMarker ( self , name ) : NEW_LINE INDENT current = self . servicelist . getCurrent ( ) NEW_LINE mutableList = self . getMutableList ( ) NEW_LINE cnt = 0 NEW_LINE while mutableList : NEW_LINE INDENT str = '1:64 : % d : 0:0:0:0:0:0:0 : : % s ' % ( cnt , name ) NEW_LINE ref = eServiceReference ( str ) NEW_LINE if current and current . valid ( ) : NEW_LINE INDENT if not mutableList . addService ( ref , current ) : NEW_LINE INDENT self . servicelist . addService ( ref , True ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE break NEW_LINE DEDENT DEDENT elif not mutableList . addService ( ref ) : NEW_LINE INDENT self . servicelist . addService ( ref , True ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE break NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT DEDENT def addAlternativeServices ( self ) : NEW_LINE INDENT cur_service = ServiceReference ( self . getCurrentSelection ( ) ) NEW_LINE end = self . atEnd ( ) NEW_LINE root = self . getRoot ( ) NEW_LINE cur_root = root and ServiceReference ( root ) NEW_LINE mutableBouquet = cur_root . list ( ) . startEdit ( ) NEW_LINE if mutableBouquet : NEW_LINE INDENT name = cur_service . getServiceName ( ) NEW_LINE refstr = ' _ ' . join ( cur_service . ref . toString ( ) . split ( ' : ' ) ) NEW_LINE if self . mode == MODE_TV : NEW_LINE INDENT str = '1:134:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ \ " alternatives . % s . tv\ " ▁ ORDER ▁ BY ▁ bouquet ' % ( refstr ) NEW_LINE DEDENT else : NEW_LINE INDENT str = '1:134:2:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ \ " alternatives . % s . radio\ " ▁ ORDER ▁ BY ▁ bouquet ' % ( refstr ) NEW_LINE DEDENT new_ref = ServiceReference ( str ) NEW_LINE if not mutableBouquet . addService ( new_ref . ref , cur_service . ref ) : NEW_LINE INDENT mutableBouquet . removeService ( cur_service . ref ) NEW_LINE mutableBouquet . flushChanges ( ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE mutableAlternatives = new_ref . list ( ) . startEdit ( ) NEW_LINE if mutableAlternatives : NEW_LINE INDENT mutableAlternatives . setListName ( name ) NEW_LINE if mutableAlternatives . addService ( cur_service . ref ) : NEW_LINE INDENT print " add " , cur_service . ref . toString ( ) , " to ▁ new ▁ alternatives ▁ failed " NEW_LINE DEDENT mutableAlternatives . flushChanges ( ) NEW_LINE self . servicelist . addService ( new_ref . ref , True ) NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE if not end : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT if cur_service . ref . toString ( ) == self . lastservice . value : NEW_LINE INDENT self . saveChannel ( new_ref . ref ) NEW_LINE DEDENT if self . startServiceRef and cur_service . ref == self . startServiceRef : NEW_LINE INDENT self . startServiceRef = new_ref . ref NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " get ▁ mutable ▁ list ▁ for ▁ new ▁ created ▁ alternatives ▁ failed " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " add " , str , " to " , cur_root . getServiceName ( ) , " failed " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " bouquetlist ▁ is ▁ not ▁ editable " NEW_LINE DEDENT DEDENT def addBouquet ( self , bName , services ) : NEW_LINE INDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE mutableBouquetList = serviceHandler . list ( self . bouquet_root ) . startEdit ( ) NEW_LINE if mutableBouquetList : NEW_LINE INDENT bName = self . buildBouquetID ( bName ) NEW_LINE new_bouquet_ref = eServiceReference ( ( self . mode == MODE_TV and '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " userbouquet . % s . tv " ▁ ORDER ▁ BY ▁ bouquet ' or '1:7:2:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " userbouquet . % s . radio " ▁ ORDER ▁ BY ▁ bouquet ' ) % bName ) NEW_LINE if not mutableBouquetList . addService ( new_bouquet_ref ) : NEW_LINE INDENT mutableBouquetList . flushChanges ( ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE mutableBouquet = serviceHandler . list ( new_bouquet_ref ) . startEdit ( ) NEW_LINE if mutableBouquet : NEW_LINE INDENT mutableBouquet . setListName ( bName ) NEW_LINE if services is not None : NEW_LINE INDENT for service in services : NEW_LINE INDENT if mutableBouquet . addService ( service ) : NEW_LINE INDENT print " add " , service . toString ( ) , " to ▁ new ▁ bouquet ▁ failed " NEW_LINE DEDENT DEDENT DEDENT mutableBouquet . flushChanges ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print " get ▁ mutable ▁ list ▁ for ▁ new ▁ created ▁ bouquet ▁ failed " NEW_LINE # ▁ do ▁ some ▁ voodoo ▁ to ▁ check ▁ if ▁ current _ root ▁ is ▁ equal ▁ to ▁ bouquet _ root ENDCOM DEDENT cur_root = self . getRoot ( ) ; NEW_LINE str1 = cur_root and cur_root . toString ( ) NEW_LINE pos1 = str1 and str1 . find ( " FROM ▁ BOUQUET " ) or - 1 NEW_LINE pos2 = self . bouquet_rootstr . find ( " FROM ▁ BOUQUET " ) NEW_LINE if pos1 != - 1 and pos2 != - 1 and str1 [ pos1 : ] == self . bouquet_rootstr [ pos2 : ] : NEW_LINE INDENT self . servicelist . addService ( new_bouquet_ref ) NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " add " , str , " to ▁ bouquets ▁ failed " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " bouquetlist ▁ is ▁ not ▁ editable " NEW_LINE DEDENT DEDENT def copyCurrentToBouquetList ( self ) : NEW_LINE INDENT provider = ServiceReference ( self . getCurrentSelection ( ) ) NEW_LINE providerName = provider . getServiceName ( ) NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE services = serviceHandler . list ( provider . ref ) NEW_LINE self . addBouquet ( providerName , services and services . getContent ( ' R ' , True ) ) NEW_LINE DEDENT def removeAlternativeServices ( self ) : NEW_LINE INDENT cur_service = ServiceReference ( self . getCurrentSelection ( ) ) NEW_LINE end = self . atEnd ( ) NEW_LINE root = self . getRoot ( ) NEW_LINE cur_root = root and ServiceReference ( root ) NEW_LINE list = cur_service . list ( ) NEW_LINE first_in_alternative = list and list . getNext ( ) NEW_LINE if first_in_alternative : NEW_LINE INDENT edit_root = cur_root and cur_root . list ( ) . startEdit ( ) NEW_LINE if edit_root : NEW_LINE INDENT if not edit_root . addService ( first_in_alternative , cur_service . ref ) : NEW_LINE INDENT self . servicelist . addService ( first_in_alternative , True ) NEW_LINE if cur_service . ref . toString ( ) == self . lastservice . value : NEW_LINE INDENT self . saveChannel ( first_in_alternative ) NEW_LINE DEDENT if self . startServiceRef and cur_service . ref == self . startServiceRef : NEW_LINE INDENT self . startServiceRef = first_in_alternative NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " couldn ' t ▁ add ▁ first ▁ alternative ▁ service ▁ to ▁ current ▁ root " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " couldn ' t ▁ edit ▁ current ▁ root ! ! " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " remove ▁ empty ▁ alternative ▁ list ▁ ! ! " NEW_LINE DEDENT self . removeBouquet ( ) NEW_LINE if not end : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT def removeBouquet ( self ) : NEW_LINE INDENT refstr = self . getCurrentSelection ( ) . toString ( ) NEW_LINE print " removeBouquet " , refstr NEW_LINE pos = refstr . find ( ' FROM ▁ BOUQUET ▁ " ' ) NEW_LINE filename = None NEW_LINE self . removeCurrentService ( bouquet = True ) NEW_LINE DEDENT def removeSatelliteService ( self ) : NEW_LINE INDENT current = self . getCurrentSelection ( ) NEW_LINE eDVBDB . getInstance ( ) . removeService ( current ) NEW_LINE refreshServiceList ( ) NEW_LINE if not self . atEnd ( ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT def removeSatelliteServices ( self ) : NEW_LINE INDENT current = self . getCurrentSelection ( ) NEW_LINE unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ cable ▁ services ? " ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ terrestrial ▁ services ? " ) NEW_LINE DEDENT else : NEW_LINE INDENT if unsigned_orbpos > 1800 : NEW_LINE INDENT unsigned_orbpos = 3600 - unsigned_orbpos NEW_LINE direction = _ ( " W " ) NEW_LINE DEDENT else : NEW_LINE INDENT direction = _ ( " E " ) NEW_LINE DEDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ % d . % d % s % s ▁ services ? " ) % ( unsigned_orbpos / 10 , unsigned_orbpos % 10 , " \xc2\xb0" , direction ) NEW_LINE DEDENT self . session . openWithCallback ( self . removeSatelliteServicesCallback , MessageBox , messageText ) NEW_LINE DEDENT def removeSatelliteServicesCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT currentIndex = self . servicelist . getCurrentIndex ( ) NEW_LINE current = self . getCurrentSelection ( ) NEW_LINE unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeServices ( int ( "0xFFFF0000" , 16 ) - 0x100000000 ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeServices ( int ( "0xEEEE0000" , 16 ) - 0x100000000 ) NEW_LINE DEDENT else : NEW_LINE INDENT curpath = current . getPath ( ) NEW_LINE idx = curpath . find ( " satellitePosition ▁ = = ▁ " ) NEW_LINE if idx != - 1 : NEW_LINE INDENT tmp = curpath [ idx + 21 : ] NEW_LINE idx = tmp . find ( ' ) ' ) NEW_LINE if idx != - 1 : NEW_LINE INDENT satpos = int ( tmp [ : idx ] ) NEW_LINE eDVBDB . getInstance ( ) . removeServices ( - 1 , - 1 , - 1 , satpos ) NEW_LINE DEDENT DEDENT DEDENT refreshServiceList ( ) NEW_LINE if hasattr ( self , ' showSatellites ' ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE self . servicelist . moveToIndex ( currentIndex ) NEW_LINE if currentIndex != self . servicelist . getCurrentIndex ( ) : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . moveEnd ) NEW_LINE # ▁ multiple ▁ marked ▁ entry ▁ stuff ▁ ( ▁ edit ▁ mode , ▁ later ▁ multiepg ▁ selection ▁ ) ENDCOM DEDENT DEDENT DEDENT DEDENT def startMarkedEdit ( self , type ) : NEW_LINE INDENT self . savedPath = self . servicePath [ : ] NEW_LINE if type == EDIT_ALTERNATIVES : NEW_LINE INDENT self . current_ref = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( self . current_ref ) NEW_LINE DEDENT self . mutableList = self . getMutableList ( ) NEW_LINE # ▁ add ▁ all ▁ services ▁ from ▁ the ▁ current ▁ list ▁ to ▁ internal ▁ marked ▁ set ▁ in ▁ listboxservicecontent ENDCOM self . clearMarks ( ) # ▁ this ▁ clears ▁ the ▁ internal ▁ marked ▁ set ▁ in ▁ the ▁ listboxservicecontent ENDCOM NEW_LINE self . saved_title = self . getTitle ( ) NEW_LINE pos = self . saved_title . find ( ' ) ' ) NEW_LINE new_title = self . saved_title [ : pos + 1 ] NEW_LINE if type == EDIT_ALTERNATIVES : NEW_LINE INDENT self . bouquet_mark_edit = EDIT_ALTERNATIVES NEW_LINE new_title += ' ▁ ' + _ ( " [ alternative ▁ edit ] " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_mark_edit = EDIT_BOUQUET NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT new_title += ' ▁ ' + _ ( " [ bouquet ▁ edit ] " ) NEW_LINE DEDENT else : NEW_LINE INDENT new_title += ' ▁ ' + _ ( " [ favourite ▁ edit ] " ) NEW_LINE DEDENT DEDENT self . setTitle ( new_title ) NEW_LINE self . __marked = self . servicelist . getRootServices ( ) NEW_LINE for x in self . __marked : NEW_LINE INDENT self . servicelist . addMarked ( eServiceReference ( x ) ) NEW_LINE DEDENT self [ " Service " ] . editmode = True NEW_LINE DEDENT def endMarkedEdit ( self , abort ) : NEW_LINE INDENT if not abort and self . mutableList is not None : NEW_LINE INDENT new_marked = set ( self . servicelist . getMarked ( ) ) NEW_LINE old_marked = set ( self . __marked ) NEW_LINE removed = old_marked - new_marked NEW_LINE added = new_marked - old_marked NEW_LINE changed = False NEW_LINE for x in removed : NEW_LINE INDENT changed = True NEW_LINE self . mutableList . removeService ( eServiceReference ( x ) ) NEW_LINE DEDENT for x in added : NEW_LINE INDENT changed = True NEW_LINE self . mutableList . addService ( eServiceReference ( x ) ) NEW_LINE DEDENT if changed : NEW_LINE INDENT if self . bouquet_mark_edit == EDIT_ALTERNATIVES and not new_marked and self . __marked : NEW_LINE INDENT self . mutableList . addService ( eServiceReference ( self . __marked [ 0 ] ) ) NEW_LINE DEDENT self . mutableList . flushChanges ( ) NEW_LINE DEDENT DEDENT self . __marked = [ ] NEW_LINE self . clearMarks ( ) NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE self . mutableList = None NEW_LINE self . setTitle ( self . saved_title ) NEW_LINE self . saved_title = None NEW_LINE # ▁ self . servicePath ▁ is ▁ just ▁ a ▁ reference ▁ to ▁ servicePathTv ▁ or ▁ Radio . . . ENDCOM # ▁ so ▁ we ▁ never ▁ ever ▁ do ▁ use ▁ the ▁ asignment ▁ operator ▁ in ▁ self . servicePath ENDCOM del self . servicePath [ : ] # ▁ remove ▁ all ▁ elements ENDCOM NEW_LINE self . servicePath += self . savedPath # ▁ add ▁ saved ▁ elements ENDCOM NEW_LINE del self . savedPath NEW_LINE self . setRoot ( self . servicePath [ - 1 ] ) NEW_LINE if self . current_ref : NEW_LINE INDENT self . setCurrentSelection ( self . current_ref ) NEW_LINE self . current_ref = None NEW_LINE DEDENT DEDENT def clearMarks ( self ) : NEW_LINE INDENT self . servicelist . clearMarks ( ) NEW_LINE DEDENT def doMark ( self ) : NEW_LINE INDENT ref = self . servicelist . getCurrent ( ) NEW_LINE if self . servicelist . isMarked ( ref ) : NEW_LINE INDENT self . servicelist . removeMarked ( ref ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . addMarked ( ref ) NEW_LINE DEDENT DEDENT def removeCurrentEntry ( self , bouquet = False ) : NEW_LINE INDENT if self . confirmRemove : NEW_LINE INDENT list = [ ( _ ( " yes " ) , True ) , ( _ ( " no " ) , False ) , ( _ ( " yes " ) + " ▁ " + _ ( " and ▁ never ▁ ask ▁ again ▁ this ▁ session ▁ again " ) , " never " ) ] NEW_LINE self . session . openWithCallback ( boundFunction ( self . removeCurrentEntryCallback , bouquet ) , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ this ▁ entry ? " ) , list = list ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeCurrentEntryCallback ( bouquet , True ) NEW_LINE DEDENT DEDENT def removeCurrentEntryCallback ( self , bouquet , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . confirmRemove = False NEW_LINE DEDENT if bouquet : NEW_LINE INDENT self . removeBouquet ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeCurrentService ( ) NEW_LINE DEDENT DEDENT DEDENT def removeCurrentService ( self , bouquet = False ) : NEW_LINE INDENT self . editMode = True NEW_LINE ref = self . servicelist . getCurrent ( ) NEW_LINE mutableList = self . getMutableList ( ) NEW_LINE if ref . valid ( ) and mutableList is not None : NEW_LINE INDENT if not mutableList . removeService ( ref ) : NEW_LINE INDENT mutableList . flushChanges ( ) # FIXME ▁ dont ▁ flush ▁ on ▁ each ▁ single ▁ removed ▁ service ENDCOM NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if not bouquet and playingref and ref == playingref : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def addServiceToBouquet ( self , dest , service = None ) : NEW_LINE INDENT mutableList = self . getMutableList ( dest ) NEW_LINE if not mutableList is None : NEW_LINE INDENT if service is None : # use ▁ current ▁ selected ▁ service ENDCOM NEW_LINE INDENT service = self . servicelist . getCurrent ( ) NEW_LINE DEDENT if not mutableList . addService ( service ) : NEW_LINE INDENT mutableList . flushChanges ( ) NEW_LINE # ▁ do ▁ some ▁ voodoo ▁ to ▁ check ▁ if ▁ current _ root ▁ is ▁ equal ▁ to ▁ dest ENDCOM cur_root = self . getRoot ( ) ; NEW_LINE str1 = cur_root and cur_root . toString ( ) or - 1 NEW_LINE str2 = dest . toString ( ) NEW_LINE pos1 = str1 . find ( " FROM ▁ BOUQUET " ) NEW_LINE pos2 = str2 . find ( " FROM ▁ BOUQUET " ) NEW_LINE if pos1 != - 1 and pos2 != - 1 and str1 [ pos1 : ] == str2 [ pos2 : ] : NEW_LINE INDENT self . servicelist . addService ( service ) NEW_LINE DEDENT self . servicelist . resetRoot ( ) NEW_LINE DEDENT DEDENT DEDENT def toggleMoveMode ( self , select = False ) : NEW_LINE INDENT self . editMode = True NEW_LINE if self . movemode : NEW_LINE INDENT if self . entry_marked : NEW_LINE INDENT self . toggleMoveMarked ( ) # ▁ unmark ▁ current ▁ entry ENDCOM NEW_LINE DEDENT self . movemode = False NEW_LINE self . mutableList . flushChanges ( ) # ▁ FIXME ▁ add ▁ check ▁ if ▁ changes ▁ was ▁ made ENDCOM NEW_LINE self . mutableList = None NEW_LINE self . setTitle ( self . saved_title ) NEW_LINE self . saved_title = None NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE self . servicelist . l . setHideNumberMarker ( config . usage . hide_number_markers . value ) NEW_LINE self . setCurrentSelection ( self . servicelist . getCurrent ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . mutableList = self . getMutableList ( ) NEW_LINE self . movemode = True NEW_LINE select and self . toggleMoveMarked ( ) NEW_LINE self . saved_title = self . getTitle ( ) NEW_LINE pos = self . saved_title . find ( ' ) ' ) NEW_LINE self . setTitle ( self . saved_title [ : pos + 1 ] + ' ▁ ' + _ ( " [ move ▁ mode ] " ) + self . saved_title [ pos + 1 : ] ) ; NEW_LINE self . servicelist . l . setHideNumberMarker ( False ) NEW_LINE self . setCurrentSelection ( self . servicelist . getCurrent ( ) ) NEW_LINE DEDENT self [ " Service " ] . editmode = True NEW_LINE DEDENT def handleEditCancel ( self ) : NEW_LINE INDENT if self . movemode : # movemode ▁ active ? ENDCOM NEW_LINE INDENT self . toggleMoveMode ( ) # ▁ disable ▁ move ▁ mode ENDCOM NEW_LINE DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT self . endMarkedEdit ( True ) # ▁ abort ▁ edit ▁ mode ENDCOM NEW_LINE DEDENT DEDENT def toggleMoveMarked ( self ) : NEW_LINE INDENT if self . entry_marked : NEW_LINE INDENT self . servicelist . setCurrentMarked ( False ) NEW_LINE self . entry_marked = False NEW_LINE self . pathChangeDisabled = False # ▁ re - enable ▁ path ▁ change ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . setCurrentMarked ( True ) NEW_LINE self . entry_marked = True NEW_LINE self . pathChangeDisabled = True # ▁ no ▁ path ▁ change ▁ allowed ▁ in ▁ movemod ENDCOM NEW_LINE DEDENT DEDENT def doContext ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . exitContext , ChannelContextMenu , self ) NEW_LINE DEDENT def exitContext ( self , close = False ) : NEW_LINE INDENT if close : NEW_LINE INDENT self . cancel ( ) NEW_LINE DEDENT DEDENT DEDENT MODE_TV = 0 NEW_LINE MODE_RADIO = 1 NEW_LINE # ▁ type ▁ 1 ▁ = ▁ digital ▁ television ▁ service ENDCOM # ▁ type ▁ 4 ▁ = ▁ nvod ▁ reference ▁ service ▁ ( NYI ) ENDCOM # ▁ type ▁ 17 ▁ = ▁ MPEG - 2 ▁ HD ▁ digital ▁ television ▁ service ENDCOM # ▁ type ▁ 22 ▁ = ▁ advanced ▁ codec ▁ SD ▁ digital ▁ television ENDCOM # ▁ type ▁ 24 ▁ = ▁ advanced ▁ codec ▁ SD ▁ NVOD ▁ reference ▁ service ▁ ( NYI ) ENDCOM # ▁ type ▁ 25 ▁ = ▁ advanced ▁ codec ▁ HD ▁ digital ▁ television ENDCOM # ▁ type ▁ 27 ▁ = ▁ advanced ▁ codec ▁ HD ▁ NVOD ▁ reference ▁ service ▁ ( NYI ) ENDCOM # ▁ type ▁ 2 ▁ = ▁ digital ▁ radio ▁ sound ▁ service ENDCOM # ▁ type ▁ 10 ▁ = ▁ advanced ▁ codec ▁ digital ▁ radio ▁ sound ▁ service ENDCOM # ▁ type ▁ 31 ▁ = ▁ High ▁ Efficiency ▁ Video ▁ Coing ▁ digital ▁ television ENDCOM service_types_tv = '1:7:1:0:0:0:0:0:0:0 : ( type ▁ = = ▁ 1 ) ▁ | | ▁ ( type ▁ = = ▁ 17 ) ▁ | | ▁ ( type ▁ = = ▁ 22 ) ▁ | | ▁ ( type ▁ = = ▁ 25 ) ▁ | | ▁ ( type ▁ = = ▁ 31 ) ▁ | | ▁ ( type ▁ = = ▁ 134 ) ▁ | | ▁ ( type ▁ = = ▁ 195 ) ' NEW_LINE service_types_radio = '1:7:2:0:0:0:0:0:0:0 : ( type ▁ = = ▁ 2 ) ▁ | | ▁ ( type ▁ = = ▁ 10 ) ' NEW_LINE class ChannelSelectionBase ( Screen ) : NEW_LINE INDENT def __init__ ( self , session ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . setScreenPathMode ( None ) NEW_LINE self [ " key _ red " ] = Button ( _ ( " All " ) ) NEW_LINE self [ " key _ green " ] = Button ( _ ( " Satellites " ) ) NEW_LINE self [ " key _ yellow " ] = Button ( _ ( " Provider " ) ) NEW_LINE self [ " key _ blue " ] = Button ( _ ( " Favourites " ) ) NEW_LINE self [ " list " ] = ServiceList ( self ) NEW_LINE self . servicelist = self [ " list " ] NEW_LINE self . numericalTextInput = NumericalTextInput ( handleTimeout = False ) NEW_LINE self . numericalTextInput . setUseableChars ( u ' 1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ ' ) NEW_LINE self . servicePathTV = [ ] NEW_LINE self . servicePathRadio = [ ] NEW_LINE self . servicePath = [ ] NEW_LINE self . history = [ ] NEW_LINE self . rootChanged = False NEW_LINE self . startRoot = None NEW_LINE self . selectionNumber = " " NEW_LINE self . clearNumberSelectionNumberTimer = eTimer ( ) NEW_LINE self . clearNumberSelectionNumberTimer . callback . append ( self . clearNumberSelectionNumber ) NEW_LINE self . protectContextMenu = True NEW_LINE self . mode = MODE_TV NEW_LINE self . dopipzap = False NEW_LINE self . pathChangeDisabled = False NEW_LINE self . movemode = False NEW_LINE self . showSatDetails = False NEW_LINE self [ " ChannelSelectBaseActions " ] = NumberActionMap ( [ " ChannelSelectBaseActions " , " NumberActions " , " InputAsciiActions " ] , { " showFavourites " : self . showFavourites , " showAllServices " : self . showAllServices , " showProviders " : self . showProviders , " showSatellites " : boundFunction ( self . showSatellites , changeMode = True ) , " nextBouquet " : self . nextBouquet , " prevBouquet " : self . prevBouquet , " nextMarker " : self . nextMarker , " prevMarker " : self . prevMarker , " gotAsciiCode " : self . keyAsciiCode , " keyLeft " : self . keyLeft , " keyRight " : self . keyRight , " keyRecord " : self . keyRecord , "1" : self . keyNumberGlobal , "2" : self . keyNumberGlobal , "3" : self . keyNumberGlobal , "4" : self . keyNumberGlobal , "5" : self . keyNumberGlobal , "6" : self . keyNumberGlobal , "7" : self . keyNumberGlobal , "8" : self . keyNumberGlobal , "9" : self . keyNumberGlobal , "0" : self . keyNumber0 } , - 2 ) NEW_LINE self . maintitle = _ ( " Channel ▁ selection " ) NEW_LINE self . recallBouquetMode ( ) NEW_LINE DEDENT def getBouquetNumOffset ( self , bouquet ) : NEW_LINE INDENT if not config . usage . multibouquet . value : NEW_LINE INDENT return 0 NEW_LINE DEDENT str = bouquet . toString ( ) NEW_LINE offset = 0 NEW_LINE if ' userbouquet . ' in bouquet . toCompareString ( ) : NEW_LINE INDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE servicelist = serviceHandler . list ( bouquet ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT serviceIterator = servicelist . getNext ( ) NEW_LINE if not serviceIterator . valid ( ) : # check ▁ if ▁ end ▁ of ▁ list ENDCOM NEW_LINE INDENT break NEW_LINE DEDENT number = serviceIterator . getChannelNum ( ) NEW_LINE if number > 0 : NEW_LINE INDENT offset = number - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return offset NEW_LINE DEDENT def recallBouquetMode ( self ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT self . service_types = service_types_tv NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT self . bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " bouquets . tv " ▁ ORDER ▁ BY ▁ bouquet ' NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_rootstr = ' % s ▁ FROM ▁ BOUQUET ▁ " userbouquet . favourites . tv " ▁ ORDER ▁ BY ▁ bouquet ' % ( self . service_types ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . service_types = service_types_radio NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT self . bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " bouquets . radio " ▁ ORDER ▁ BY ▁ bouquet ' NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_rootstr = ' % s ▁ FROM ▁ BOUQUET ▁ " userbouquet . favourites . radio " ▁ ORDER ▁ BY ▁ bouquet ' % ( self . service_types ) NEW_LINE DEDENT DEDENT self . bouquet_root = eServiceReference ( self . bouquet_rootstr ) NEW_LINE DEDENT def setTvMode ( self ) : NEW_LINE INDENT self . mode = MODE_TV NEW_LINE self . servicePath = self . servicePathTV NEW_LINE self . recallBouquetMode ( ) NEW_LINE title = self . maintitle NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT title += _ ( " ▁ ( TV ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE DEDENT def setRadioMode ( self ) : NEW_LINE INDENT self . mode = MODE_RADIO NEW_LINE self . servicePath = self . servicePathRadio NEW_LINE self . recallBouquetMode ( ) NEW_LINE title = self . maintitle NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT title += _ ( " ▁ ( Radio ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE DEDENT def setRoot ( self , root , justSet = False ) : NEW_LINE INDENT if self . startRoot is None : NEW_LINE INDENT self . startRoot = self . getRoot ( ) NEW_LINE DEDENT path = root . getPath ( ) NEW_LINE isBouquet = ' FROM ▁ BOUQUET ' in path and ( root . flags & eServiceReference . isDirectory ) NEW_LINE inBouquetRootList = ' FROM ▁ BOUQUET ▁ " bouquets . ' in path # FIXME ▁ HACK ENDCOM NEW_LINE if not inBouquetRootList and isBouquet : NEW_LINE INDENT self . servicelist . setMode ( ServiceList . MODE_FAVOURITES ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . setMode ( ServiceList . MODE_NORMAL ) NEW_LINE DEDENT self . servicelist . setRoot ( root , justSet ) NEW_LINE self . rootChanged = True NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT def removeModeStr ( self , str ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT pos = str . find ( _ ( " ▁ ( TV ) " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = str . find ( _ ( " ▁ ( Radio ) " ) ) NEW_LINE DEDENT if pos != - 1 : NEW_LINE INDENT return str [ : pos ] NEW_LINE DEDENT return str NEW_LINE DEDENT def getServiceName ( self , ref ) : NEW_LINE INDENT str = self . removeModeStr ( ServiceReference ( ref ) . getServiceName ( ) ) NEW_LINE if ' bouquets ' in str . lower ( ) : NEW_LINE INDENT return _ ( " User ▁ - ▁ bouquets " ) NEW_LINE DEDENT if not str : NEW_LINE INDENT pathstr = ref . getPath ( ) NEW_LINE if ' FROM ▁ PROVIDERS ' in pathstr : NEW_LINE INDENT return _ ( " Provider " ) NEW_LINE DEDENT if ' FROM ▁ SATELLITES ' in pathstr : NEW_LINE INDENT return _ ( " Satellites " ) NEW_LINE DEDENT if ' ) ▁ ORDER ▁ BY ▁ name ' in pathstr : NEW_LINE INDENT return _ ( " All " ) NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT def buildTitleString ( self ) : NEW_LINE INDENT titleStr = self . getTitle ( ) NEW_LINE pos = titleStr . find ( ' ] ' ) NEW_LINE if pos == - 1 : NEW_LINE INDENT pos = titleStr . find ( ' ) ' ) NEW_LINE DEDENT if pos != - 1 : NEW_LINE INDENT titleStr = titleStr [ : pos + 1 ] NEW_LINE Len = len ( self . servicePath ) NEW_LINE if Len > 0 : NEW_LINE INDENT base_ref = self . servicePath [ 0 ] NEW_LINE if Len > 1 : NEW_LINE INDENT end_ref = self . servicePath [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT end_ref = None NEW_LINE DEDENT nameStr = self . getServiceName ( base_ref ) NEW_LINE titleStr += ' ▁ - ▁ ' + nameStr NEW_LINE if end_ref is not None : NEW_LINE INDENT if Len > 2 : NEW_LINE INDENT titleStr += ' / . . / ' NEW_LINE DEDENT else : NEW_LINE INDENT titleStr += ' / ' NEW_LINE DEDENT nameStr = self . getServiceName ( end_ref ) NEW_LINE titleStr += nameStr NEW_LINE DEDENT self . setTitle ( titleStr ) NEW_LINE DEDENT DEDENT DEDENT def moveUp ( self ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT def moveDown ( self ) : NEW_LINE INDENT self . servicelist . moveDown ( ) NEW_LINE DEDENT def clearPath ( self ) : NEW_LINE INDENT del self . servicePath [ : ] NEW_LINE DEDENT def enterPath ( self , ref , justSet = False ) : NEW_LINE INDENT self . servicePath . append ( ref ) NEW_LINE self . setRoot ( ref , justSet ) NEW_LINE DEDENT def enterUserbouquet ( self , root , save_root = True ) : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . recallBouquetMode ( ) NEW_LINE if self . bouquet_root : NEW_LINE INDENT self . enterPath ( self . bouquet_root ) NEW_LINE DEDENT self . enterPath ( root ) NEW_LINE self . startRoot = None NEW_LINE if save_root : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE DEDENT DEDENT def pathUp ( self , justSet = False ) : NEW_LINE INDENT prev = self . servicePath . pop ( ) NEW_LINE if self . servicePath : NEW_LINE INDENT current = self . servicePath [ - 1 ] NEW_LINE self . setRoot ( current , justSet ) NEW_LINE if not justSet : NEW_LINE INDENT self . setCurrentSelection ( prev ) NEW_LINE DEDENT DEDENT return prev NEW_LINE DEDENT def isBasePathEqual ( self , ref ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 and self . servicePath [ 0 ] == ref : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isPrevPathEqual ( self , ref ) : NEW_LINE INDENT length = len ( self . servicePath ) NEW_LINE if length > 1 and self . servicePath [ length - 2 ] == ref : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def preEnterPath ( self , refstr ) : NEW_LINE INDENT return False NEW_LINE DEDENT def showAllServices ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE playingref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE if playingref : NEW_LINE INDENT self . setCurrentSelectionAlternative ( playingref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def showSatellites ( self , changeMode = False ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE justSet = False NEW_LINE prev = None NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT if self . isPrevPathEqual ( ref ) : NEW_LINE INDENT justSet = True NEW_LINE DEDENT prev = self . pathUp ( justSet ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT justSet = True NEW_LINE self . clearPath ( ) NEW_LINE self . enterPath ( ref , True ) NEW_LINE DEDENT if changeMode and currentRoot and currentRoot == ref : NEW_LINE INDENT self . showSatDetails = not self . showSatDetails NEW_LINE justSet = True NEW_LINE self . clearPath ( ) NEW_LINE self . enterPath ( ref , True ) NEW_LINE DEDENT DEDENT if justSet : NEW_LINE INDENT addCableAndTerrestrialLater = [ ] NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE servicelist = serviceHandler . list ( ref ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT service = servicelist . getNext ( ) NEW_LINE if not service . valid ( ) : # check ▁ if ▁ end ▁ of ▁ list ENDCOM NEW_LINE INDENT break NEW_LINE DEDENT unsigned_orbpos = service . getUnsignedData ( 4 ) >> 16 NEW_LINE orbpos = service . getData ( 4 ) >> 16 NEW_LINE if orbpos < 0 : NEW_LINE INDENT orbpos += 3600 NEW_LINE DEDENT if " FROM ▁ PROVIDER " in service . getPath ( ) : NEW_LINE INDENT service_type = self . showSatDetails and _ ( " Providers " ) NEW_LINE DEDENT elif ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in service . getPath ( ) : NEW_LINE INDENT service_type = self . showSatDetails and _ ( " New " ) NEW_LINE DEDENT else : NEW_LINE INDENT service_type = _ ( " Services " ) NEW_LINE DEDENT if service_type : NEW_LINE INDENT if unsigned_orbpos == 0xFFFF : # Cable ENDCOM NEW_LINE INDENT service_name = _ ( " Cable " ) NEW_LINE addCableAndTerrestrialLater . append ( ( " % s ▁ - ▁ % s " % ( service_name , service_type ) , service . toString ( ) ) ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : # Terrestrial ENDCOM NEW_LINE INDENT service_name = _ ( " Terrestrial " ) NEW_LINE addCableAndTerrestrialLater . append ( ( " % s ▁ - ▁ % s " % ( service_name , service_type ) , service . toString ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT service_name = str ( nimmanager . getSatDescription ( orbpos ) ) NEW_LINE DEDENT except : NEW_LINE INDENT if orbpos > 1800 : # ▁ west ENDCOM NEW_LINE INDENT orbpos = 3600 - orbpos NEW_LINE h = _ ( " W " ) NEW_LINE DEDENT else : NEW_LINE INDENT h = _ ( " E " ) NEW_LINE DEDENT service_name = ( " % d . % d " + h ) % ( orbpos / 10 , orbpos % 10 ) NEW_LINE DEDENT service . setName ( " % s ▁ - ▁ % s " % ( service_name , service_type ) ) NEW_LINE self . servicelist . addService ( service ) NEW_LINE DEDENT DEDENT DEDENT cur_ref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE self . servicelist . l . sort ( ) NEW_LINE if cur_ref : NEW_LINE INDENT pos = self . service_types . rfind ( ' : ' ) NEW_LINE refstr = ' % s ▁ ( channelID ▁ = = ▁ % 08x % 04x % 04x ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name ' % ( self . service_types [ : pos + 1 ] , cur_ref . getUnsignedData ( 4 ) , # ▁ NAMESPACE ENDCOM cur_ref . getUnsignedData ( 2 ) , # ▁ TSID ENDCOM cur_ref . getUnsignedData ( 3 ) , # ▁ ONID ENDCOM self . service_types [ pos + 1 : ] ) NEW_LINE ref = eServiceReference ( refstr ) NEW_LINE ref . setName ( _ ( " Current ▁ transponder " ) ) NEW_LINE self . servicelist . addService ( ref , beforeCurrent = True ) NEW_LINE DEDENT for ( service_name , service_ref ) in addCableAndTerrestrialLater : NEW_LINE INDENT ref = eServiceReference ( service_ref ) NEW_LINE ref . setName ( service_name ) NEW_LINE self . servicelist . addService ( ref , beforeCurrent = True ) NEW_LINE DEDENT self . servicelist . l . FillFinished ( ) NEW_LINE if prev is not None : NEW_LINE INDENT self . setCurrentSelection ( prev ) NEW_LINE DEDENT elif cur_ref : NEW_LINE INDENT refstr = cur_ref . toString ( ) NEW_LINE op = " " . join ( refstr . split ( ' : ' , 10 ) [ 6 : 7 ] ) NEW_LINE if len ( op ) >= 4 : NEW_LINE INDENT hop = int ( op [ : - 4 ] , 16 ) NEW_LINE if len ( op ) >= 7 and not op . endswith ( '0000' ) : NEW_LINE INDENT op = op [ : - 4 ] + '0000' NEW_LINE DEDENT refstr = '1:7:0:0:0:0 : % s : 0:0:0 : ( satellitePosition ▁ = = ▁ % s ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name ' % ( op , hop , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] ) NEW_LINE self . setCurrentSelectionAlternative ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def showProviders ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ FROM ▁ PROVIDERS ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT provider = info . getInfoString ( iServiceInformation . sProvider ) NEW_LINE refstr = '1:7:0:0:0:0:0:0:0:0 : ( provider ▁ = = ▁ \ " % s\ " ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name : % s ' % ( provider , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] , provider ) NEW_LINE self . setCurrentSelectionAlternative ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT def changeBouquet ( self , direction ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT if len ( self . servicePath ) > 1 : NEW_LINE # when ▁ enter ▁ satellite ▁ root ▁ list ▁ we ▁ must ▁ do ▁ some ▁ magic ▁ stuff . . ENDCOM INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT ref = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE DEDENT DEDENT DEDENT def inBouquet ( self ) : NEW_LINE INDENT if self . servicePath and self . servicePath [ 0 ] == self . bouquet_root : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def atBegin ( self ) : NEW_LINE INDENT return self . servicelist . atBegin ( ) NEW_LINE DEDENT def atEnd ( self ) : NEW_LINE INDENT return self . servicelist . atEnd ( ) NEW_LINE DEDENT def nextBouquet ( self ) : NEW_LINE INDENT if self . shown and config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageUp ) NEW_LINE DEDENT elif " reverseB " in config . usage . servicelist_cursor_behavior . value : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT DEDENT def prevBouquet ( self ) : NEW_LINE INDENT if self . shown and config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageDown ) NEW_LINE DEDENT elif " reverseB " in config . usage . servicelist_cursor_behavior . value : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT DEDENT def keyLeft ( self ) : NEW_LINE INDENT if config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageUp ) NEW_LINE DEDENT DEDENT def keyRight ( self ) : NEW_LINE INDENT if config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageDown ) NEW_LINE DEDENT DEDENT def keyRecord ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref and not ( ref . flags & ( eServiceReference . isMarker | eServiceReference . isDirectory ) ) : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . instantRecord ( serviceRef = ref ) NEW_LINE DEDENT DEDENT def showFavourites ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT if not self . preEnterPath ( self . bouquet_rootstr ) : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != self . bouquet_root : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( self . bouquet_root ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def keyNumber0 ( self , number ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 and not self . selectionNumber : NEW_LINE INDENT self . keyGoUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . keyNumberGlobal ( number ) NEW_LINE DEDENT DEDENT def keyNumberGlobal ( self , number ) : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT if hasattr ( self , " editMode " ) and self . editMode : NEW_LINE INDENT if number == 2 : NEW_LINE INDENT self . renameEntry ( ) NEW_LINE DEDENT if number == 6 : NEW_LINE INDENT self . toggleMoveMode ( select = True ) NEW_LINE DEDENT if number == 8 : NEW_LINE INDENT self . removeCurrentEntry ( bouquet = False ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . numberSelectionActions ( number ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current_root = self . getRoot ( ) NEW_LINE if current_root and ' FROM ▁ BOUQUET ▁ " bouquets . ' in current_root . getPath ( ) : NEW_LINE INDENT if hasattr ( self , " editMode " ) and self . editMode : NEW_LINE INDENT if number == 2 : NEW_LINE INDENT self . renameEntry ( ) NEW_LINE DEDENT if number == 6 : NEW_LINE INDENT self . toggleMoveMode ( select = True ) NEW_LINE DEDENT if number == 8 : NEW_LINE INDENT self . removeCurrentEntry ( bouquet = True ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . numberSelectionActions ( number ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT unichar = self . numericalTextInput . getKey ( number ) NEW_LINE charstr = unichar . encode ( " utf - 8" ) NEW_LINE if len ( charstr ) == 1 : NEW_LINE INDENT self . servicelist . moveToChar ( charstr [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def numberSelectionActions ( self , number ) : NEW_LINE INDENT if not ( hasattr ( self , " movemode " ) and self . movemode ) : NEW_LINE INDENT if len ( self . selectionNumber ) > 4 : NEW_LINE INDENT self . clearNumberSelectionNumber ( ) NEW_LINE DEDENT self . selectionNumber = self . selectionNumber + str ( number ) NEW_LINE ref , bouquet = Screens . InfoBar . InfoBar . instance . searchNumber ( int ( self . selectionNumber ) , bouquet = self . getRoot ( ) ) NEW_LINE if ref : NEW_LINE INDENT if not ref . flags & eServiceReference . isMarker : NEW_LINE INDENT self . enterUserbouquet ( bouquet , save_root = False ) NEW_LINE self . setCurrentSelection ( ref ) NEW_LINE DEDENT self . clearNumberSelectionNumberTimer . start ( 1000 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . clearNumberSelectionNumber ( ) NEW_LINE DEDENT DEDENT DEDENT def clearNumberSelectionNumber ( self ) : NEW_LINE INDENT self . clearNumberSelectionNumberTimer . stop ( ) NEW_LINE self . selectionNumber = " " NEW_LINE DEDENT def keyAsciiCode ( self ) : NEW_LINE INDENT unichar = unichr ( getPrevAsciiCode ( ) ) NEW_LINE charstr = unichar . encode ( " utf - 8" ) NEW_LINE if len ( charstr ) == 1 : NEW_LINE INDENT self . servicelist . moveToChar ( charstr [ 0 ] ) NEW_LINE DEDENT DEDENT def getRoot ( self ) : NEW_LINE INDENT return self . servicelist . getRoot ( ) NEW_LINE DEDENT def getCurrentSelection ( self ) : NEW_LINE INDENT return self . servicelist . getCurrent ( ) NEW_LINE DEDENT def setCurrentSelection ( self , service ) : NEW_LINE INDENT if service : NEW_LINE INDENT self . servicelist . setCurrent ( service , adjust = False ) NEW_LINE DEDENT DEDENT def setCurrentSelectionAlternative ( self , ref ) : NEW_LINE INDENT if self . bouquet_mark_edit == EDIT_ALTERNATIVES and not ( ref . flags & eServiceReference . isDirectory ) : NEW_LINE INDENT for markedService in self . servicelist . getMarked ( ) : NEW_LINE INDENT markedService = eServiceReference ( markedService ) NEW_LINE self . setCurrentSelection ( markedService ) NEW_LINE if markedService == self . getCurrentSelection ( ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT self . setCurrentSelection ( ref ) NEW_LINE DEDENT def getBouquetList ( self ) : NEW_LINE INDENT bouquets = [ ] NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT list = serviceHandler . list ( self . bouquet_root ) NEW_LINE if list : NEW_LINE INDENT while True : NEW_LINE INDENT s = list . getNext ( ) NEW_LINE if not s . valid ( ) : NEW_LINE INDENT break NEW_LINE DEDENT if s . flags & eServiceReference . isDirectory and not s . flags & eServiceReference . isInvisible : NEW_LINE INDENT info = serviceHandler . info ( s ) NEW_LINE if info : NEW_LINE INDENT bouquets . append ( ( info . getName ( s ) , s ) ) NEW_LINE DEDENT DEDENT DEDENT return bouquets NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT info = serviceHandler . info ( self . bouquet_root ) NEW_LINE if info : NEW_LINE INDENT bouquets . append ( ( info . getName ( self . bouquet_root ) , self . bouquet_root ) ) NEW_LINE DEDENT return bouquets NEW_LINE DEDENT return None NEW_LINE DEDENT def keyGoUp ( self ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ PROVIDERS ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showProviders ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showAllServices ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def nextMarker ( self ) : NEW_LINE INDENT self . servicelist . moveToNextMarker ( ) NEW_LINE DEDENT def prevMarker ( self ) : NEW_LINE INDENT self . servicelist . moveToPrevMarker ( ) NEW_LINE DEDENT def gotoCurrentServiceOrProvider ( self , ref ) : NEW_LINE INDENT str = ref . toString ( ) NEW_LINE if _ ( " Providers " ) in str : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT provider = info . getInfoString ( iServiceInformation . sProvider ) NEW_LINE op = int ( self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) . toString ( ) . split ( ' : ' ) [ 6 ] [ : - 4 ] or "0" , 16 ) NEW_LINE refstr = '1:7:0:0:0:0:0:0:0:0 : ( provider ▁ = = ▁ \ " % s\ " ) ▁ & & ▁ ( satellitePosition ▁ = = ▁ % s ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name : % s ' % ( provider , op , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] , provider ) NEW_LINE self . setCurrentSelection ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT elif not self . isBasePathEqual ( self . bouquet_root ) or self . bouquet_mark_edit == EDIT_ALTERNATIVES : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref : NEW_LINE INDENT self . setCurrentSelectionAlternative ( playingref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT HISTORYSIZE = 20 NEW_LINE # config ▁ for ▁ lastservice ENDCOM config . tv = ConfigSubsection ( ) NEW_LINE config . tv . lastservice = ConfigText ( ) NEW_LINE config . tv . lastroot = ConfigText ( ) NEW_LINE config . radio = ConfigSubsection ( ) NEW_LINE config . radio . lastservice = ConfigText ( ) NEW_LINE config . radio . lastroot = ConfigText ( ) NEW_LINE config . servicelist = ConfigSubsection ( ) NEW_LINE config . servicelist . lastmode = ConfigText ( default = " tv " ) NEW_LINE config . servicelist . startupservice = ConfigText ( ) NEW_LINE config . servicelist . startupservice_onstandby = ConfigYesNo ( default = False ) NEW_LINE config . servicelist . startuproot = ConfigText ( ) NEW_LINE config . servicelist . startupmode = ConfigText ( default = " tv " ) NEW_LINE class ChannelSelection ( ChannelSelectionBase , ChannelSelectionEdit , ChannelSelectionEPG , SelectionEventInfo ) : NEW_LINE INDENT def __init__ ( self , session ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE ChannelSelectionEdit . __init__ ( self ) NEW_LINE ChannelSelectionEPG . __init__ ( self ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " cancel " : self . cancel , " ok " : self . channelSelected , " keyRadio " : self . doRadioButton , " keyTV " : self . doTVButton , } ) NEW_LINE self . __event_tracker = ServiceEventTracker ( screen = self , eventmap = { iPlayableService . evStart : self . __evServiceStart , iPlayableService . evEnd : self . __evServiceEnd } ) NEW_LINE self . startServiceRef = None NEW_LINE self . history = [ ] NEW_LINE self . history_pos = 0 NEW_LINE if config . servicelist . startupservice . value and config . servicelist . startuproot . value : NEW_LINE INDENT config . servicelist . lastmode . value = config . servicelist . startupmode . value NEW_LINE if config . servicelist . lastmode . value == " tv " : NEW_LINE INDENT config . tv . lastservice . value = config . servicelist . startupservice . value NEW_LINE config . tv . lastroot . value = config . servicelist . startuproot . value NEW_LINE DEDENT elif config . servicelist . lastmode . value == " radio " : NEW_LINE INDENT config . radio . lastservice . value = config . servicelist . startupservice . value NEW_LINE config . radio . lastroot . value = config . servicelist . startuproot . value NEW_LINE DEDENT DEDENT self . lastservice = config . tv . lastservice NEW_LINE self . lastroot = config . tv . lastroot NEW_LINE self . revertMode = None NEW_LINE config . usage . multibouquet . addNotifier ( self . multibouquet_config_changed ) NEW_LINE self . new_service_played = False NEW_LINE self . dopipzap = False NEW_LINE self . onExecBegin . append ( self . asciiOn ) NEW_LINE self . mainScreenMode = None NEW_LINE self . mainScreenRoot = None NEW_LINE self . lastChannelRootTimer = eTimer ( ) NEW_LINE self . lastChannelRootTimer . callback . append ( self . __onCreate ) NEW_LINE self . lastChannelRootTimer . start ( 100 , True ) NEW_LINE self . pipzaptimer = eTimer ( ) NEW_LINE DEDENT def asciiOn ( self ) : NEW_LINE INDENT rcinput = eRCInput . getInstance ( ) NEW_LINE rcinput . setKeyboardMode ( rcinput . kmAscii ) NEW_LINE DEDENT def asciiOff ( self ) : NEW_LINE INDENT rcinput = eRCInput . getInstance ( ) NEW_LINE rcinput . setKeyboardMode ( rcinput . kmNone ) NEW_LINE DEDENT def multibouquet_config_changed ( self , val ) : NEW_LINE INDENT self . recallBouquetMode ( ) NEW_LINE DEDENT def __evServiceStart ( self ) : NEW_LINE INDENT if self . dopipzap and hasattr ( self . session , ' pip ' ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( self . session . pip . getCurrentServiceReference ( ) or eServiceReference ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT refstr = info . getInfoString ( iServiceInformation . sServiceref ) NEW_LINE self . servicelist . setPlayableIgnoreService ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def __evServiceEnd ( self ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( eServiceReference ( ) ) NEW_LINE DEDENT def setMode ( self ) : NEW_LINE INDENT self . rootChanged = True NEW_LINE self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT DEDENT def doTVButton ( self ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT DEDENT def setModeTv ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . revertMode = self . mode NEW_LINE DEDENT self . lastservice = config . tv . lastservice NEW_LINE self . lastroot = config . tv . lastroot NEW_LINE config . servicelist . lastmode . value = " tv " NEW_LINE self . setTvMode ( ) NEW_LINE self . setMode ( ) NEW_LINE DEDENT def doRadioButton ( self ) : NEW_LINE INDENT if self . mode == MODE_RADIO : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT DEDENT def setModeRadio ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . revertMode = self . mode NEW_LINE DEDENT if config . usage . e1like_radio_mode . value : NEW_LINE INDENT self . lastservice = config . radio . lastservice NEW_LINE self . lastroot = config . radio . lastroot NEW_LINE config . servicelist . lastmode . value = " radio " NEW_LINE self . setRadioMode ( ) NEW_LINE self . setMode ( ) NEW_LINE DEDENT DEDENT def __onCreate ( self ) : NEW_LINE INDENT if config . usage . e1like_radio_mode . value : NEW_LINE INDENT if config . servicelist . lastmode . value == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . zap ( ) NEW_LINE DEDENT DEDENT def channelSelected ( self , doClose = True ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if config . usage . channelselection_preview . value and ( playingref is None or self . getCurrentSelection ( ) and self . getCurrentSelection ( ) != playingref ) : NEW_LINE INDENT doClose = False NEW_LINE DEDENT if not self . startServiceRef and not doClose : NEW_LINE INDENT self . startServiceRef = playingref NEW_LINE DEDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . movemode and ( self . isBasePathEqual ( self . bouquet_root ) or " userbouquet . " in ref . toString ( ) ) : NEW_LINE INDENT self . toggleMoveMarked ( ) NEW_LINE DEDENT elif ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT if Components . ParentalControl . parentalControl . isServicePlayable ( ref , self . bouquetParentalControlCallback , self . session ) : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT if not ( self . bouquet_mark_edit == EDIT_ALTERNATIVES and ref . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . doMark ( ) NEW_LINE DEDENT DEDENT elif not ( ref . flags & eServiceReference . isMarker or ref . type == - 1 ) : NEW_LINE INDENT root = self . getRoot ( ) NEW_LINE if not root or not ( root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . zap ( enable_pipzap = doClose , preview_zap = not doClose ) NEW_LINE self . asciiOff ( ) NEW_LINE if doClose : NEW_LINE INDENT if self . dopipzap : NEW_LINE INDENT self . zapBack ( ) NEW_LINE DEDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE self . correctChannelNumber ( ) NEW_LINE self . movemode and self . toggleMoveMode ( ) NEW_LINE self . editMode = False NEW_LINE self . protectContextMenu = True NEW_LINE self . close ( ref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def bouquetParentalControlCallback ( self , ref ) : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE self . revertMode = None NEW_LINE DEDENT def togglePipzap ( self ) : NEW_LINE INDENT assert ( self . session . pip ) NEW_LINE title = self . instance . getTitle ( ) NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT if self . dopipzap : NEW_LINE # ▁ Mark ▁ PiP ▁ as ▁ inactive ▁ and ▁ effectively ▁ deactivate ▁ pipzap ENDCOM INDENT self . hidePipzapMessage ( ) NEW_LINE self . dopipzap = False NEW_LINE # ▁ Disable ▁ PiP ▁ if ▁ not ▁ playing ▁ a ▁ service ENDCOM if self . session . pip . pipservice is None : NEW_LINE INDENT self . session . pipshown = False NEW_LINE del self . session . pip NEW_LINE DEDENT self . __evServiceStart ( ) NEW_LINE # ▁ Move ▁ to ▁ playing ▁ service ENDCOM lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE if self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . servicelist . setCurrent ( lastservice ) NEW_LINE DEDENT DEDENT title += _ ( " ▁ ( TV ) " ) NEW_LINE DEDENT else : NEW_LINE # ▁ Mark ▁ PiP ▁ as ▁ active ▁ and ▁ effectively ▁ active ▁ pipzap ENDCOM INDENT self . showPipzapMessage ( ) NEW_LINE self . dopipzap = True NEW_LINE self . __evServiceStart ( ) NEW_LINE # ▁ Move ▁ to ▁ service ▁ playing ▁ in ▁ pip ▁ ( will ▁ not ▁ work ▁ with ▁ subservices ) ENDCOM self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE title += _ ( " ▁ ( PiP ) " ) NEW_LINE DEDENT self . setTitle ( title ) NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT def showPipzapMessage ( self ) : NEW_LINE INDENT time = config . usage . infobar_timeout . index NEW_LINE if time : NEW_LINE INDENT self . pipzaptimer . callback . append ( self . hidePipzapMessage ) NEW_LINE self . pipzaptimer . startLongTimer ( time ) NEW_LINE DEDENT self . session . pip . active ( ) NEW_LINE DEDENT def hidePipzapMessage ( self ) : NEW_LINE INDENT if self . pipzaptimer . isActive ( ) : NEW_LINE INDENT self . pipzaptimer . callback . remove ( self . hidePipzapMessage ) NEW_LINE self . pipzaptimer . stop ( ) NEW_LINE DEDENT self . session . pip . inactive ( ) NEW_LINE # called ▁ from ▁ infoBar ▁ and ▁ channelSelected ENDCOM DEDENT def zap ( self , enable_pipzap = False , preview_zap = False , checkParentalControl = True , ref = None ) : NEW_LINE INDENT self . curRoot = self . startRoot NEW_LINE nref = ref or self . getCurrentSelection ( ) NEW_LINE ref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if enable_pipzap and self . dopipzap : NEW_LINE INDENT ref = self . session . pip . getCurrentService ( ) NEW_LINE if ref is None or ref != nref : NEW_LINE INDENT nref = self . session . pip . resolveAlternatePipService ( nref ) NEW_LINE if nref and ( not checkParentalControl or Components . ParentalControl . parentalControl . isServicePlayable ( nref , boundFunction ( self . zap , enable_pipzap = True , checkParentalControl = False ) ) ) : NEW_LINE INDENT self . session . pip . playService ( nref ) NEW_LINE self . __evServiceStart ( ) NEW_LINE self . showPipzapMessage ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setStartRoot ( self . curRoot ) NEW_LINE self . setCurrentSelection ( ref ) NEW_LINE DEDENT DEDENT DEDENT elif ref is None or ref != nref : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . checkTimeshiftRunning ( boundFunction ( self . zapCheckTimeshiftCallback , enable_pipzap , preview_zap , nref ) ) NEW_LINE DEDENT elif not preview_zap : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE self . saveChannel ( nref ) NEW_LINE config . servicelist . lastmode . save ( ) NEW_LINE self . setCurrentSelection ( nref ) NEW_LINE if self . startServiceRef is None or nref != self . startServiceRef : NEW_LINE INDENT self . addToHistory ( nref ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT def zapCheckTimeshiftCallback ( self , enable_pipzap , preview_zap , nref , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . new_service_played = True NEW_LINE self . session . nav . playService ( nref ) NEW_LINE if not preview_zap : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE self . saveChannel ( nref ) NEW_LINE config . servicelist . lastmode . save ( ) NEW_LINE if self . startServiceRef is None or nref != self . startServiceRef : NEW_LINE INDENT self . addToHistory ( nref ) NEW_LINE DEDENT if self . dopipzap : NEW_LINE INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . mainScreenMode = config . servicelist . lastmode . value NEW_LINE self . mainScreenRoot = self . getRoot ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT else : NEW_LINE INDENT Notifications . RemovePopup ( " Parental ▁ control " ) NEW_LINE self . setCurrentSelection ( nref ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . setStartRoot ( self . curRoot ) NEW_LINE self . setCurrentSelection ( self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) ) NEW_LINE DEDENT if not preview_zap : NEW_LINE INDENT self . hide ( ) NEW_LINE DEDENT DEDENT def newServicePlayed ( self ) : NEW_LINE INDENT ret = self . new_service_played NEW_LINE self . new_service_played = False NEW_LINE return ret NEW_LINE DEDENT def addToHistory ( self , ref ) : NEW_LINE INDENT if self . servicePath is not None : NEW_LINE INDENT tmp = self . servicePath [ : ] NEW_LINE tmp . append ( ref ) NEW_LINE try : NEW_LINE INDENT del self . history [ self . history_pos + 1 : ] NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT self . history . append ( tmp ) NEW_LINE hlen = len ( self . history ) NEW_LINE if hlen > HISTORYSIZE : NEW_LINE INDENT del self . history [ 0 ] NEW_LINE hlen -= 1 NEW_LINE DEDENT self . history_pos = hlen - 1 NEW_LINE DEDENT DEDENT def historyBack ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE currentPlayedRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if hlen > 0 and currentPlayedRef and self . history [ self . history_pos ] [ - 1 ] != currentPlayedRef : NEW_LINE INDENT self . addToHistory ( currentPlayedRef ) NEW_LINE hlen = len ( self . history ) NEW_LINE DEDENT if hlen > 1 and self . history_pos > 0 : NEW_LINE INDENT self . history_pos -= 1 NEW_LINE self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT def historyNext ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE if hlen > 1 and self . history_pos < ( hlen - 1 ) : NEW_LINE INDENT self . history_pos += 1 NEW_LINE self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT def setHistoryPath ( self , doZap = True ) : NEW_LINE INDENT path = self . history [ self . history_pos ] [ : ] NEW_LINE ref = path . pop ( ) NEW_LINE del self . servicePath [ : ] NEW_LINE self . servicePath += path NEW_LINE self . saveRoot ( ) NEW_LINE root = path [ - 1 ] NEW_LINE cur_root = self . getRoot ( ) NEW_LINE if cur_root and cur_root != root : NEW_LINE INDENT self . setRoot ( root ) NEW_LINE DEDENT if doZap : NEW_LINE INDENT self . session . nav . playService ( ref , adjust = False ) NEW_LINE DEDENT if self . dopipzap : NEW_LINE INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setCurrentSelection ( ref ) NEW_LINE DEDENT self . saveChannel ( ref ) NEW_LINE DEDENT def saveRoot ( self ) : NEW_LINE INDENT path = ' ' NEW_LINE for i in self . servicePath : NEW_LINE INDENT path += i . toString ( ) NEW_LINE path += ' ; ' NEW_LINE DEDENT if path and path != self . lastroot . value : NEW_LINE INDENT if self . mode == MODE_RADIO and ' FROM ▁ BOUQUET ▁ " bouquets . tv " ' in path : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . mode == MODE_TV and ' FROM ▁ BOUQUET ▁ " bouquets . radio " ' in path : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . lastroot . value = path NEW_LINE self . lastroot . save ( ) NEW_LINE DEDENT DEDENT def restoreRoot ( self ) : NEW_LINE INDENT tmp = [ x for x in self . lastroot . value . split ( ' ; ' ) if x != ' ' ] NEW_LINE current = [ x . toString ( ) for x in self . servicePath ] NEW_LINE if tmp != current or self . rootChanged : NEW_LINE INDENT self . clearPath ( ) NEW_LINE cnt = 0 NEW_LINE for i in tmp : NEW_LINE INDENT self . servicePath . append ( eServiceReference ( i ) ) NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt : NEW_LINE INDENT path = self . servicePath . pop ( ) NEW_LINE self . enterPath ( path ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE self . saveRoot ( ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE DEDENT DEDENT def preEnterPath ( self , refstr ) : NEW_LINE INDENT if self . servicePath and self . servicePath [ 0 ] != eServiceReference ( refstr ) : NEW_LINE INDENT pathstr = self . lastroot . value NEW_LINE if pathstr is not None and refstr in pathstr : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def saveChannel ( self , ref ) : NEW_LINE INDENT if ref is not None : NEW_LINE INDENT refstr = ref . toString ( ) NEW_LINE DEDENT else : NEW_LINE INDENT refstr = " " NEW_LINE DEDENT if refstr != self . lastservice . value and not Components . ParentalControl . parentalControl . isProtected ( ref ) : NEW_LINE INDENT self . lastservice . value = refstr NEW_LINE self . lastservice . save ( ) NEW_LINE DEDENT DEDENT def setCurrentServicePath ( self , path , doZap = True ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE if not hlen : NEW_LINE INDENT self . history . append ( path ) NEW_LINE self . history_pos = 0 NEW_LINE DEDENT if hlen == 1 : NEW_LINE INDENT self . history [ self . history_pos ] = path NEW_LINE DEDENT else : NEW_LINE INDENT if path in self . history : NEW_LINE INDENT self . history . remove ( path ) NEW_LINE self . history_pos -= 1 NEW_LINE DEDENT tmp = self . history [ self . history_pos ] [ : ] NEW_LINE self . history . append ( tmp ) NEW_LINE self . history_pos += 1 NEW_LINE self . history [ self . history_pos ] = path NEW_LINE DEDENT self . setHistoryPath ( doZap ) NEW_LINE DEDENT def getCurrentServicePath ( self ) : NEW_LINE INDENT if self . history : NEW_LINE INDENT return self . history [ self . history_pos ] NEW_LINE DEDENT return None NEW_LINE DEDENT def recallPrevService ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE currentPlayedRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if hlen > 0 and currentPlayedRef and self . history [ self . history_pos ] [ - 1 ] != currentPlayedRef : NEW_LINE INDENT self . addToHistory ( currentPlayedRef ) NEW_LINE hlen = len ( self . history ) NEW_LINE DEDENT if hlen > 1 : NEW_LINE INDENT if self . history_pos == hlen - 1 : NEW_LINE INDENT tmp = self . history [ self . history_pos ] NEW_LINE self . history [ self . history_pos ] = self . history [ self . history_pos - 1 ] NEW_LINE self . history [ self . history_pos - 1 ] = tmp NEW_LINE DEDENT else : NEW_LINE INDENT tmp = self . history [ self . history_pos + 1 ] NEW_LINE self . history [ self . history_pos + 1 ] = self . history [ self . history_pos ] NEW_LINE self . history [ self . history_pos ] = tmp NEW_LINE DEDENT self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT def cancel ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE if self . dopipzap : NEW_LINE # ▁ This ▁ unfortunately ▁ won ' t ▁ work ▁ with ▁ subservices ENDCOM INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT DEDENT DEDENT self . asciiOff ( ) NEW_LINE self . zapBack ( ) NEW_LINE self . correctChannelNumber ( ) NEW_LINE self . editMode = False NEW_LINE self . protectContextMenu = True NEW_LINE self . close ( None ) NEW_LINE DEDENT def zapBack ( self ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if self . startServiceRef and ( playingref is None or playingref != self . startServiceRef ) : NEW_LINE INDENT self . setStartRoot ( self . startRoot ) NEW_LINE self . new_service_played = True NEW_LINE self . session . nav . playService ( self . startServiceRef ) NEW_LINE self . saveChannel ( self . startServiceRef ) NEW_LINE DEDENT else : NEW_LINE INDENT self . restoreMode ( ) NEW_LINE DEDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE if self . dopipzap : NEW_LINE # ▁ This ▁ unfortunately ▁ won ' t ▁ work ▁ with ▁ subservices ENDCOM INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) == lastservice : NEW_LINE INDENT pass # ▁ keep ▁ current ▁ selection ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT self . setCurrentSelection ( playingref ) NEW_LINE DEDENT DEDENT DEDENT def setStartRoot ( self , root ) : NEW_LINE INDENT if root : NEW_LINE INDENT if self . revertMode == MODE_TV : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . revertMode == MODE_RADIO : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE self . enterUserbouquet ( root ) NEW_LINE DEDENT DEDENT def restoreMode ( self ) : NEW_LINE INDENT if self . revertMode == MODE_TV : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . revertMode == MODE_RADIO : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT def correctChannelNumber ( self ) : NEW_LINE INDENT current_ref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if self . dopipzap : NEW_LINE INDENT tmp_mode = config . servicelist . lastmode . value NEW_LINE tmp_root = self . getRoot ( ) NEW_LINE tmp_ref = self . getCurrentSelection ( ) NEW_LINE pip_ref = self . session . pip . getCurrentService ( ) NEW_LINE if tmp_ref and pip_ref and tmp_ref != pip_ref : NEW_LINE INDENT self . revertMode = None NEW_LINE return NEW_LINE DEDENT if self . mainScreenMode == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . mainScreenMode == " radio " : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT if self . mainScreenRoot : NEW_LINE INDENT self . setRoot ( self . mainScreenRoot ) NEW_LINE self . setCurrentSelection ( current_ref ) NEW_LINE DEDENT DEDENT selected_ref = self . getCurrentSelection ( ) NEW_LINE if selected_ref and current_ref and selected_ref . getChannelNum ( ) != current_ref . getChannelNum ( ) : NEW_LINE INDENT oldref = self . session . nav . currentlyPlayingServiceReference NEW_LINE if oldref and selected_ref == oldref or ( oldref != current_ref and selected_ref == current_ref ) : NEW_LINE INDENT self . session . nav . currentlyPlayingServiceOrGroup = selected_ref NEW_LINE self . session . nav . pnav . navEvent ( iPlayableService . evStart ) NEW_LINE DEDENT DEDENT if self . dopipzap : NEW_LINE INDENT if tmp_mode == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif tmp_mode == " radio " : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . enterUserbouquet ( tmp_root ) NEW_LINE title = self . instance . getTitle ( ) NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE title += _ ( " ▁ ( PiP ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT if tmp_ref and pip_ref and tmp_ref . getChannelNum ( ) != pip_ref . getChannelNum ( ) : NEW_LINE INDENT self . session . pip . currentService = tmp_ref NEW_LINE DEDENT self . setCurrentSelection ( tmp_ref ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT DEDENT class RadioInfoBar ( Screen ) : NEW_LINE INDENT def __init__ ( self , session ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self [ " RdsDecoder " ] = RdsDecoder ( self . session . nav ) NEW_LINE DEDENT DEDENT class ChannelSelectionRadio ( ChannelSelectionBase , ChannelSelectionEdit , ChannelSelectionEPG , InfoBarBase , SelectionEventInfo ) : NEW_LINE INDENT ALLOW_SUSPEND = True NEW_LINE def __init__ ( self , session , infobar ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE ChannelSelectionEdit . __init__ ( self ) NEW_LINE ChannelSelectionEPG . __init__ ( self ) NEW_LINE InfoBarBase . __init__ ( self ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self . infobar = infobar NEW_LINE self . startServiceRef = None NEW_LINE self . onLayoutFinish . append ( self . onCreate ) NEW_LINE self . info = session . instantiateDialog ( RadioInfoBar ) # ▁ our ▁ simple ▁ infobar ENDCOM NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " keyTV " : self . cancel , " keyRadio " : self . cancel , " cancel " : self . cancel , " ok " : self . channelSelected , } ) NEW_LINE self . __event_tracker = ServiceEventTracker ( screen = self , eventmap = { iPlayableService . evStart : self . __evServiceStart , iPlayableService . evEnd : self . __evServiceEnd } ) NEW_LINE # # # # # ▁ RDS ▁ Radiotext ▁ / ▁ Rass ▁ Support ▁ BEGIN ENDCOM self . infobar = infobar # ▁ reference ▁ to ▁ real ▁ infobar ▁ ( the ▁ one ▁ and ▁ only ) ENDCOM NEW_LINE self [ " RdsDecoder " ] = self . info [ " RdsDecoder " ] NEW_LINE self [ " RdsActions " ] = HelpableActionMap ( self , " InfobarRdsActions " , { " startRassInteractive " : ( self . startRassInteractive , _ ( " View ▁ Rass ▁ interactive . . . " ) ) } , - 1 ) NEW_LINE self [ " RdsActions " ] . setEnabled ( False ) NEW_LINE infobar . rds_display . onRassInteractivePossibilityChanged . append ( self . RassInteractivePossibilityChanged ) NEW_LINE self . onClose . append ( self . __onClose ) NEW_LINE self . onExecBegin . append ( self . __onExecBegin ) NEW_LINE self . onExecEnd . append ( self . __onExecEnd ) NEW_LINE DEDENT def __onClose ( self ) : NEW_LINE INDENT lastservice = eServiceReference ( config . tv . lastservice . value ) NEW_LINE self . session . nav . playService ( lastservice ) NEW_LINE DEDENT def startRassInteractive ( self ) : NEW_LINE INDENT self . info . hide ( ) ; NEW_LINE self . infobar . rass_interactive = self . session . openWithCallback ( self . RassInteractiveClosed , RassInteractive ) NEW_LINE DEDENT def RassInteractiveClosed ( self ) : NEW_LINE INDENT self . info . show ( ) NEW_LINE self . infobar . rass_interactive = None NEW_LINE self . infobar . RassSlidePicChanged ( ) NEW_LINE DEDENT def RassInteractivePossibilityChanged ( self , state ) : NEW_LINE INDENT self [ " RdsActions " ] . setEnabled ( state ) NEW_LINE # # # # # ▁ RDS ▁ Radiotext ▁ / ▁ Rass ▁ Support ▁ END ENDCOM DEDENT def __onExecBegin ( self ) : NEW_LINE INDENT self . info . show ( ) NEW_LINE DEDENT def __onExecEnd ( self ) : NEW_LINE INDENT self . info . hide ( ) NEW_LINE DEDENT def cancel ( self ) : NEW_LINE INDENT self . infobar . rds_display . onRassInteractivePossibilityChanged . remove ( self . RassInteractivePossibilityChanged ) NEW_LINE self . info . hide ( ) NEW_LINE # set ▁ previous ▁ tv ▁ service ENDCOM self . close ( None ) NEW_LINE DEDENT def __evServiceStart ( self ) : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT refstr = info . getInfoString ( iServiceInformation . sServiceref ) NEW_LINE self . servicelist . setPlayableIgnoreService ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT def __evServiceEnd ( self ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( eServiceReference ( ) ) NEW_LINE DEDENT def saveRoot ( self ) : NEW_LINE INDENT path = ' ' NEW_LINE for i in self . servicePathRadio : NEW_LINE INDENT path += i . toString ( ) NEW_LINE path += ' ; ' NEW_LINE DEDENT if path and path != config . radio . lastroot . value : NEW_LINE INDENT config . radio . lastroot . value = path NEW_LINE config . radio . lastroot . save ( ) NEW_LINE DEDENT DEDENT def restoreRoot ( self ) : NEW_LINE INDENT tmp = [ x for x in config . radio . lastroot . value . split ( ' ; ' ) if x != ' ' ] NEW_LINE current = [ x . toString ( ) for x in self . servicePath ] NEW_LINE if tmp != current or self . rootChanged : NEW_LINE INDENT cnt = 0 NEW_LINE for i in tmp : NEW_LINE INDENT self . servicePathRadio . append ( eServiceReference ( i ) ) NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt : NEW_LINE INDENT path = self . servicePathRadio . pop ( ) NEW_LINE self . enterPath ( path ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE self . saveRoot ( ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE DEDENT DEDENT def preEnterPath ( self , refstr ) : NEW_LINE INDENT if self . servicePathRadio and self . servicePathRadio [ 0 ] != eServiceReference ( refstr ) : NEW_LINE INDENT pathstr = config . radio . lastroot . value NEW_LINE if pathstr is not None and refstr in pathstr : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( config . radio . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def onCreate ( self ) : NEW_LINE INDENT self . setRadioMode ( ) NEW_LINE self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( config . radio . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . servicelist . setCurrent ( lastservice ) NEW_LINE self . session . nav . playService ( lastservice ) NEW_LINE DEDENT else : NEW_LINE INDENT self . session . nav . stopService ( ) NEW_LINE DEDENT self . info . show ( ) NEW_LINE DEDENT def channelSelected ( self , doClose = False ) : # ▁ just ▁ return ▁ selected ▁ service ENDCOM NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . movemode : NEW_LINE INDENT self . toggleMoveMarked ( ) NEW_LINE DEDENT elif ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT if not ( self . bouquet_mark_edit == EDIT_ALTERNATIVES and ref . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . doMark ( ) NEW_LINE DEDENT DEDENT elif not ( ref . flags & eServiceReference . isMarker ) : # ▁ no ▁ marker ENDCOM NEW_LINE INDENT cur_root = self . getRoot ( ) NEW_LINE if not cur_root or not ( cur_root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref is None or playingref != ref : NEW_LINE INDENT self . session . nav . playService ( ref ) NEW_LINE config . radio . lastservice . value = ref . toString ( ) NEW_LINE config . radio . lastservice . save ( ) NEW_LINE DEDENT self . saveRoot ( ) NEW_LINE DEDENT DEDENT DEDENT def zapBack ( self ) : NEW_LINE INDENT self . channelSelected ( ) NEW_LINE DEDENT DEDENT class SimpleChannelSelection ( ChannelSelectionBase , SelectionEventInfo ) : NEW_LINE INDENT def __init__ ( self , session , title , currentBouquet = False , returnBouquet = False , setService = None , setBouquet = None ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " cancel " : self . close , " ok " : self . channelSelected , " keyRadio " : self . setModeRadio , " keyTV " : self . setModeTv , } ) NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE if isinstance ( title , str ) : NEW_LINE INDENT self . maintitle = title NEW_LINE DEDENT self . currentBouquet = currentBouquet NEW_LINE self . returnBouquet = returnBouquet NEW_LINE self . setService = setService NEW_LINE self . setBouquet = setBouquet NEW_LINE self . onLayoutFinish . append ( self . layoutFinished ) NEW_LINE DEDENT def layoutFinished ( self ) : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE if self . currentBouquet or self . setBouquet : NEW_LINE INDENT ref = self . setBouquet or Screens . InfoBar . InfoBar . instance . servicelist . getRoot ( ) NEW_LINE if ref : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT DEDENT if self . setService : NEW_LINE INDENT self . setCurrentSelection ( self . setService ) NEW_LINE DEDENT DEDENT def saveRoot ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def keyRecord ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT def channelSelected ( self ) : # ▁ just ▁ return ▁ selected ▁ service ENDCOM NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT elif not ( ref . flags & eServiceReference . isMarker ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . returnBouquet and len ( self . servicePath ) : NEW_LINE INDENT self . close ( ref , self . servicePath [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ref ) NEW_LINE DEDENT DEDENT DEDENT def setModeTv ( self ) : NEW_LINE INDENT self . setTvMode ( ) NEW_LINE self . showFavourites ( ) NEW_LINE DEDENT def setModeRadio ( self ) : NEW_LINE INDENT self . setRadioMode ( ) NEW_LINE self . showFavourites ( ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="RPi-Distro/python-gpiozero/tree/master/gpiozerocli/pinout.py"> # ▁ GPIO ▁ Zero : ▁ a ▁ library ▁ for ▁ controlling ▁ the ▁ Raspberry ▁ Pi ' s ▁ GPIO ▁ pins ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2017-2019 ▁ Dave ▁ Jones ▁ < dave @ waveform . org . uk > ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2017 ▁ Ben ▁ Nuttall ▁ < ben @ bennuttall . com > ENDCOM # ▁ Redistribution ▁ and ▁ use ▁ in ▁ source ▁ and ▁ binary ▁ forms , ▁ with ▁ or ▁ without ENDCOM # ▁ modification , ▁ are ▁ permitted ▁ provided ▁ that ▁ the ▁ following ▁ conditions ▁ are ▁ met : ENDCOM # ▁ * ▁ Redistributions ▁ of ▁ source ▁ code ▁ must ▁ retain ▁ the ▁ above ▁ copyright ▁ notice , ENDCOM # ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer . ENDCOM # ▁ * ▁ Redistributions ▁ in ▁ binary ▁ form ▁ must ▁ reproduce ▁ the ▁ above ▁ copyright ▁ notice , ENDCOM # ▁ this ▁ list ▁ of ▁ conditions ▁ and ▁ the ▁ following ▁ disclaimer ▁ in ▁ the ▁ documentation ENDCOM # ▁ and / or ▁ other ▁ materials ▁ provided ▁ with ▁ the ▁ distribution . ENDCOM # ▁ * ▁ Neither ▁ the ▁ name ▁ of ▁ the ▁ copyright ▁ holder ▁ nor ▁ the ▁ names ▁ of ▁ its ▁ contributors ENDCOM # ▁ may ▁ be ▁ used ▁ to ▁ endorse ▁ or ▁ promote ▁ products ▁ derived ▁ from ▁ this ▁ software ENDCOM # ▁ without ▁ specific ▁ prior ▁ written ▁ permission . ENDCOM # ▁ THIS ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ BY ▁ THE ▁ COPYRIGHT ▁ HOLDERS ▁ AND ▁ CONTRIBUTORS ▁ " AS ▁ IS " ENDCOM # ▁ AND ▁ ANY ▁ EXPRESS ▁ OR ▁ IMPLIED ▁ WARRANTIES , ▁ INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ THE ENDCOM # ▁ IMPLIED ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY ▁ AND ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ENDCOM # ▁ ARE ▁ DISCLAIMED . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ▁ COPYRIGHT ▁ HOLDER ▁ OR ▁ CONTRIBUTORS ▁ BE ENDCOM # ▁ LIABLE ▁ FOR ▁ ANY ▁ DIRECT , ▁ INDIRECT , ▁ INCIDENTAL , ▁ SPECIAL , ▁ EXEMPLARY , ▁ OR ENDCOM # ▁ CONSEQUENTIAL ▁ DAMAGES ▁ ( INCLUDING , ▁ BUT ▁ NOT ▁ LIMITED ▁ TO , ▁ PROCUREMENT ▁ OF ENDCOM # ▁ SUBSTITUTE ▁ GOODS ▁ OR ▁ SERVICES ; ▁ LOSS ▁ OF ▁ USE , ▁ DATA , ▁ OR ▁ PROFITS ; ▁ OR ▁ BUSINESS ENDCOM # ▁ INTERRUPTION ) ▁ HOWEVER ▁ CAUSED ▁ AND ▁ ON ▁ ANY ▁ THEORY ▁ OF ▁ LIABILITY , ▁ WHETHER ▁ IN ENDCOM # ▁ CONTRACT , ▁ STRICT ▁ LIABILITY , ▁ OR ▁ TORT ▁ ( INCLUDING ▁ NEGLIGENCE ▁ OR ▁ OTHERWISE ) ENDCOM # ▁ ARISING ▁ IN ▁ ANY ▁ WAY ▁ OUT ▁ OF ▁ THE ▁ USE ▁ OF ▁ THIS ▁ SOFTWARE , ▁ EVEN ▁ IF ▁ ADVISED ▁ OF ▁ THE ENDCOM # ▁ POSSIBILITY ▁ OF ▁ SUCH ▁ DAMAGE . ENDCOM """ STRNEWLINE A ▁ utility ▁ for ▁ querying ▁ Raspberry ▁ Pi ▁ GPIO ▁ pin - out ▁ information . STRNEWLINE """ NEW_LINE from __future__ import ( unicode_literals , absolute_import , print_function , division , ) NEW_LINE import argparse NEW_LINE import sys NEW_LINE import textwrap NEW_LINE import warnings NEW_LINE import webbrowser NEW_LINE from gpiozero import pi_info NEW_LINE class PinoutTool ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . parser = argparse . ArgumentParser ( description = __doc__ ) NEW_LINE self . parser . add_argument ( ' - r ' , ' - - revision ' , dest = ' revision ' , default = ' ' , help = ' RPi ▁ revision . ▁ Default ▁ is ▁ to ▁ autodetect ▁ revision ▁ of ▁ current ▁ device ' ) NEW_LINE self . parser . add_argument ( ' - c ' , ' - - color ' , action = " store _ true " , default = None , help = ' Force ▁ colored ▁ output ▁ ( by ▁ default , ▁ the ▁ output ▁ will ▁ include ▁ ANSI ' ' color ▁ codes ▁ if ▁ run ▁ in ▁ a ▁ color - capable ▁ terminal ) . ▁ See ▁ also ▁ - - monochrome ' ) NEW_LINE self . parser . add_argument ( ' - m ' , ' - - monochrome ' , dest = ' color ' , action = ' store _ false ' , help = ' Force ▁ monochrome ▁ output . ▁ See ▁ also ▁ - - color ' ) NEW_LINE self . parser . add_argument ( ' - x ' , ' - - xyz ' , dest = ' xyz ' , action = ' store _ true ' , help = ' Open ▁ pinout . xyz ▁ in ▁ the ▁ default ▁ web ▁ browser ' ) NEW_LINE DEDENT def __call__ ( self , args = None ) : NEW_LINE INDENT if args is None : NEW_LINE INDENT args = sys . argv [ 1 : ] NEW_LINE DEDENT try : NEW_LINE INDENT return self . main ( self . parser . parse_args ( args ) ) or 0 NEW_LINE DEDENT except argparse . ArgumentError as e : NEW_LINE # ▁ argparse ▁ errors ▁ are ▁ already ▁ nicely ▁ formatted , ▁ print ▁ to ▁ stderr ▁ and ENDCOM # ▁ exit ▁ with ▁ code ▁ 2 ENDCOM INDENT raise e NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT raise NEW_LINE # ▁ Output ▁ anything ▁ else ▁ nicely ▁ formatted ▁ on ▁ stderr ▁ and ▁ exit ▁ code ▁ 1 ENDCOM self . parser . exit ( 1 , ' { prog } : ▁ error : ▁ { message } \n ' . format ( prog = self . parser . prog , message = e ) ) NEW_LINE DEDENT DEDENT def main ( self , args ) : NEW_LINE INDENT warnings . simplefilter ( ' ignore ' ) NEW_LINE if args . xyz : NEW_LINE INDENT webbrowser . open ( ' https : / / pinout . xyz ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if args . revision == ' ' : NEW_LINE INDENT try : NEW_LINE INDENT pi_info ( ) . pprint ( color = args . color ) NEW_LINE DEDENT except ImportError : NEW_LINE INDENT formatter = self . parser . _get_formatter ( ) NEW_LINE formatter . add_text ( " Unable ▁ to ▁ initialize ▁ GPIO ▁ Zero . ▁ This ▁ usually ▁ means ▁ " " that ▁ you ▁ are ▁ not ▁ running ▁ % ( prog ) s ▁ on ▁ a ▁ Raspberry ▁ Pi . ▁ " " If ▁ you ▁ still ▁ wish ▁ to ▁ run ▁ % ( prog ) s , ▁ set ▁ the ▁ " " GPIOZERO _ PIN _ FACTORY ▁ environment ▁ variable ▁ to ▁ ' mock ' ▁ " " and ▁ retry , ▁ or ▁ refer ▁ to ▁ the ▁ Remote ▁ GPIO ▁ section ▁ of ▁ " " the ▁ manual * ▁ to ▁ configure ▁ your ▁ environment ▁ to ▁ " " remotely ▁ access ▁ your ▁ Pi . " ) NEW_LINE formatter . add_text ( " * ▁ https : / / gpiozero . readthedocs . io / en / stable / " " remote _ gpio . html " ) NEW_LINE sys . stderr . write ( formatter . format_help ( ) ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT raise IOError ( ' This ▁ device ▁ is ▁ not ▁ a ▁ Raspberry ▁ Pi ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pi_info ( args . revision ) . pprint ( color = args . color ) NEW_LINE DEDENT formatter = self . parser . _get_formatter ( ) NEW_LINE formatter . add_text ( " For ▁ further ▁ information , ▁ please ▁ refer ▁ to ▁ " " https : / / pinout . xyz / " ) NEW_LINE sys . stdout . write ( ' \n ' ) NEW_LINE sys . stdout . write ( formatter . format_help ( ) ) NEW_LINE DEDENT DEDENT DEDENT main = PinoutTool ( ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="mcrowson/django/tree/master/tests/choices/tests.py"> from django . test import TestCase NEW_LINE from . models import Person NEW_LINE class ChoicesTests ( TestCase ) : NEW_LINE INDENT def test_display ( self ) : NEW_LINE INDENT a = Person . objects . create ( name = ' Adrian ' , gender = ' M ' ) NEW_LINE s = Person . objects . create ( name = ' Sara ' , gender = ' F ' ) NEW_LINE self . assertEqual ( a . gender , ' M ' ) NEW_LINE self . assertEqual ( s . gender , ' F ' ) NEW_LINE self . assertEqual ( a . get_gender_display ( ) , ' Male ' ) NEW_LINE self . assertEqual ( s . get_gender_display ( ) , ' Female ' ) NEW_LINE # ▁ If ▁ the ▁ value ▁ for ▁ the ▁ field ▁ doesn ' t ▁ correspond ▁ to ▁ a ▁ valid ▁ choice , ENDCOM # ▁ the ▁ value ▁ itself ▁ is ▁ provided ▁ as ▁ a ▁ display ▁ value . ENDCOM a . gender = ' ' NEW_LINE self . assertEqual ( a . get_gender_display ( ) , ' ' ) NEW_LINE a . gender = ' U ' NEW_LINE self . assertEqual ( a . get_gender_display ( ) , ' U ' ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="mbrukman/libcloud/tree/master/libcloud/test/compute/test_gogrid.py"> # ▁ Licensed ▁ to ▁ the ▁ Apache ▁ Software ▁ Foundation ▁ ( ASF ) ▁ under ▁ one ▁ or ▁ more ENDCOM # ▁ contributor ▁ license ▁ agreements . ▁ See ▁ the ▁ NOTICE ▁ file ▁ distributed ▁ with ENDCOM # ▁ this ▁ work ▁ for ▁ additional ▁ information ▁ regarding ▁ copyright ▁ ownership . ENDCOM # ▁ The ▁ ASF ▁ licenses ▁ this ▁ file ▁ to ▁ You ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ENDCOM # ▁ ( the ▁ " License " ) ; ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ENDCOM # ▁ the ▁ License . ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM # ▁ limitations ▁ under ▁ the ▁ License . ENDCOM import sys NEW_LINE import unittest NEW_LINE from libcloud . utils . py3 import httplib NEW_LINE from libcloud . utils . py3 import urlparse NEW_LINE from libcloud . utils . py3 import parse_qs NEW_LINE from libcloud . compute . base import NodeState , NodeLocation NEW_LINE from libcloud . common . types import LibcloudError , InvalidCredsError NEW_LINE from libcloud . common . gogrid import GoGridIpAddress NEW_LINE from libcloud . compute . drivers . gogrid import GoGridNodeDriver NEW_LINE from libcloud . compute . base import Node , NodeImage , NodeSize NEW_LINE from libcloud . test import MockHttp # ▁ pylint : ▁ disable - msg = E0611 ENDCOM NEW_LINE from libcloud . test . compute import TestCaseMixin # ▁ pylint : ▁ disable - msg = E0611 ENDCOM NEW_LINE from libcloud . test . file_fixtures import ComputeFileFixtures # ▁ pylint : ▁ disable - msg = E0611 ENDCOM NEW_LINE class GoGridTests ( unittest . TestCase , TestCaseMixin ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT GoGridNodeDriver . connectionCls . conn_classes = ( None , GoGridMockHttp ) NEW_LINE GoGridMockHttp . type = None NEW_LINE self . driver = GoGridNodeDriver ( " foo " , " bar " ) NEW_LINE DEDENT def _get_test_512Mb_node_size ( self ) : NEW_LINE INDENT return NodeSize ( id = '512Mb ' , name = None , ram = None , disk = None , bandwidth = None , price = None , driver = self . driver ) NEW_LINE DEDENT def test_create_node ( self ) : NEW_LINE INDENT image = NodeImage ( 1531 , None , self . driver ) NEW_LINE node = self . driver . create_node ( name = ' test1' , image = image , size = self . _get_test_512Mb_node_size ( ) ) NEW_LINE self . assertEqual ( node . name , ' test1' ) NEW_LINE self . assertTrue ( node . id is not None ) NEW_LINE self . assertEqual ( node . extra [ ' password ' ] , ' bebebe ' ) NEW_LINE DEDENT def test_list_nodes ( self ) : NEW_LINE INDENT node = self . driver . list_nodes ( ) [ 0 ] NEW_LINE self . assertEqual ( node . id , '90967' ) NEW_LINE self . assertEqual ( node . extra [ ' password ' ] , ' bebebe ' ) NEW_LINE self . assertEqual ( node . extra [ ' description ' ] , ' test ▁ server ' ) NEW_LINE DEDENT def test_reboot_node ( self ) : NEW_LINE INDENT node = Node ( 90967 , None , None , None , None , self . driver ) NEW_LINE ret = self . driver . reboot_node ( node ) NEW_LINE self . assertTrue ( ret ) NEW_LINE DEDENT def test_reboot_node_not_successful ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' FAIL ' NEW_LINE node = Node ( 90967 , None , None , None , None , self . driver ) NEW_LINE try : NEW_LINE INDENT self . driver . reboot_node ( node ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Exception ▁ was ▁ not ▁ thrown ' ) NEW_LINE DEDENT DEDENT def test_destroy_node ( self ) : NEW_LINE INDENT node = Node ( 90967 , None , None , None , None , self . driver ) NEW_LINE ret = self . driver . destroy_node ( node ) NEW_LINE self . assertTrue ( ret ) NEW_LINE DEDENT def test_list_images ( self ) : NEW_LINE INDENT images = self . driver . list_images ( ) NEW_LINE image = images [ 0 ] NEW_LINE self . assertEqual ( len ( images ) , 4 ) NEW_LINE self . assertEqual ( image . name , ' CentOS ▁ 5.3 ▁ ( 32 - bit ) ▁ w / ▁ None ' ) NEW_LINE self . assertEqual ( image . id , '1531' ) NEW_LINE location = NodeLocation ( id = ' gogrid / GSI - 939ef909-84b8-4a2f - ad56-02ccd7da05ff . img ' , name = ' test ▁ location ' , country = ' Slovenia ' , driver = self . driver ) NEW_LINE images = self . driver . list_images ( location = location ) NEW_LINE image = images [ 0 ] NEW_LINE self . assertEqual ( len ( images ) , 4 ) NEW_LINE self . assertEqual ( image . name , ' CentOS ▁ 5.3 ▁ ( 32 - bit ) ▁ w / ▁ None ' ) NEW_LINE self . assertEqual ( image . id , '1531' ) NEW_LINE DEDENT def test_malformed_reply ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' FAIL ' NEW_LINE try : NEW_LINE INDENT self . driver . list_images ( ) NEW_LINE DEDENT except LibcloudError : NEW_LINE INDENT e = sys . exc_info ( ) [ 1 ] NEW_LINE self . assertTrue ( isinstance ( e , LibcloudError ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( " test ▁ should ▁ have ▁ thrown " ) NEW_LINE DEDENT DEDENT def test_invalid_creds ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' FAIL ' NEW_LINE try : NEW_LINE INDENT self . driver . list_nodes ( ) NEW_LINE DEDENT except InvalidCredsError : NEW_LINE INDENT e = sys . exc_info ( ) [ 1 ] NEW_LINE self . assertTrue ( e . driver is not None ) NEW_LINE self . assertEqual ( e . driver . name , self . driver . name ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( " test ▁ should ▁ have ▁ thrown " ) NEW_LINE DEDENT DEDENT def test_node_creation_without_free_public_ips ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' NOPUBIPS ' NEW_LINE try : NEW_LINE INDENT image = NodeImage ( 1531 , None , self . driver ) NEW_LINE self . driver . create_node ( name = ' test1' , image = image , size = self . _get_test_512Mb_node_size ( ) ) NEW_LINE DEDENT except LibcloudError : NEW_LINE INDENT e = sys . exc_info ( ) [ 1 ] NEW_LINE self . assertTrue ( isinstance ( e , LibcloudError ) ) NEW_LINE self . assertTrue ( e . driver is not None ) NEW_LINE self . assertEqual ( e . driver . name , self . driver . name ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( " test ▁ should ▁ have ▁ thrown " ) NEW_LINE DEDENT DEDENT def test_list_locations ( self ) : NEW_LINE INDENT locations = self . driver . list_locations ( ) NEW_LINE location_names = [ location . name for location in locations ] NEW_LINE self . assertEqual ( len ( locations ) , 2 ) NEW_LINE for i in 0 , 1 : NEW_LINE INDENT self . assertTrue ( isinstance ( locations [ i ] , NodeLocation ) ) NEW_LINE DEDENT self . assertTrue ( " US - West - 1" in location_names ) NEW_LINE self . assertTrue ( " US - East - 1" in location_names ) NEW_LINE DEDENT def test_ex_save_image ( self ) : NEW_LINE INDENT node = self . driver . list_nodes ( ) [ 0 ] NEW_LINE image = self . driver . ex_save_image ( node , " testimage " ) NEW_LINE self . assertEqual ( image . name , " testimage " ) NEW_LINE DEDENT def test_ex_edit_image ( self ) : NEW_LINE INDENT image = self . driver . list_images ( ) [ 0 ] NEW_LINE ret = self . driver . ex_edit_image ( image = image , public = False , ex_description = " test " , name = " testname " ) NEW_LINE self . assertTrue ( isinstance ( ret , NodeImage ) ) NEW_LINE DEDENT def test_ex_edit_node ( self ) : NEW_LINE INDENT node = Node ( id = 90967 , name = None , state = None , public_ips = None , private_ips = None , driver = self . driver ) NEW_LINE ret = self . driver . ex_edit_node ( node = node , size = self . _get_test_512Mb_node_size ( ) ) NEW_LINE self . assertTrue ( isinstance ( ret , Node ) ) NEW_LINE DEDENT def test_ex_list_ips ( self ) : NEW_LINE INDENT ips = self . driver . ex_list_ips ( ) NEW_LINE expected_ips = { "192.168.75.66" : GoGridIpAddress ( id = "5348099" , ip = "192.168.75.66" , public = True , state = " Unassigned " , subnet = "192.168.75.64/255.255.255.240" ) , "192.168.75.67" : GoGridIpAddress ( id = "5348100" , ip = "192.168.75.67" , public = True , state = " Assigned " , subnet = "192.168.75.64/255.255.255.240" ) , "192.168.75.68" : GoGridIpAddress ( id = "5348101" , ip = "192.168.75.68" , public = False , state = " Unassigned " , subnet = "192.168.75.64/255.255.255.240" ) } NEW_LINE self . assertEqual ( len ( expected_ips ) , 3 ) NEW_LINE for ip in ips : NEW_LINE INDENT self . assertTrue ( ip . ip in expected_ips ) NEW_LINE self . assertEqual ( ip . public , expected_ips [ ip . ip ] . public ) NEW_LINE self . assertEqual ( ip . state , expected_ips [ ip . ip ] . state ) NEW_LINE self . assertEqual ( ip . subnet , expected_ips [ ip . ip ] . subnet ) NEW_LINE del expected_ips [ ip . ip ] NEW_LINE DEDENT self . assertEqual ( len ( expected_ips ) , 0 ) NEW_LINE DEDENT def test_get_state_invalid ( self ) : NEW_LINE INDENT state = self . driver . _get_state ( ' invalid ' ) NEW_LINE self . assertEqual ( state , NodeState . UNKNOWN ) NEW_LINE DEDENT DEDENT class GoGridMockHttp ( MockHttp ) : NEW_LINE INDENT fixtures = ComputeFileFixtures ( ' gogrid ' ) NEW_LINE def _api_grid_image_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' image _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_grid_image_list_FAIL ( self , method , url , body , headers ) : NEW_LINE INDENT body = " < h3 > some ▁ non ▁ valid ▁ json ▁ here < / h3 > " NEW_LINE return ( httplib . SERVICE_UNAVAILABLE , body , { } , httplib . responses [ httplib . SERVICE_UNAVAILABLE ] ) NEW_LINE DEDENT def _api_grid_server_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT _api_grid_server_list_NOPUBIPS = _api_grid_server_list NEW_LINE def _api_grid_server_list_FAIL ( self , method , url , body , headers ) : NEW_LINE INDENT return ( httplib . FORBIDDEN , "123" , { } , httplib . responses [ httplib . FORBIDDEN ] ) NEW_LINE DEDENT def _api_grid_ip_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' ip _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_grid_ip_list_NOPUBIPS ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' ip _ list _ empty . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_grid_server_power ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ power . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_grid_server_power_FAIL ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ power _ fail . json ' ) NEW_LINE return ( httplib . NOT_FOUND , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_grid_server_add ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ add . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT _api_grid_server_add_NOPUBIPS = _api_grid_server_add NEW_LINE def _api_grid_server_delete ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ delete . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_grid_server_edit ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ edit . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_support_password_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' password _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT _api_support_password_list_NOPUBIPS = _api_support_password_list NEW_LINE def _api_grid_image_save ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' image _ save . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_grid_image_edit ( self , method , url , body , headers ) : NEW_LINE # ▁ edit ▁ method ▁ is ▁ quite ▁ similar ▁ to ▁ save ▁ method ▁ from ▁ the ▁ response ENDCOM # ▁ perspective ENDCOM INDENT body = self . fixtures . load ( ' image _ save . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT def _api_common_lookup_list ( self , method , url , body , headers ) : NEW_LINE INDENT _valid_lookups = ( " ip . datacenter " , ) NEW_LINE lookup = parse_qs ( urlparse . urlparse ( url ) . query ) [ " lookup " ] [ 0 ] NEW_LINE if lookup in _valid_lookups : NEW_LINE INDENT fixture_path = " lookup _ list _ % s . json " % ( lookup . replace ( " . " , " _ " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT raise NotImplementedError NEW_LINE DEDENT body = self . fixtures . load ( fixture_path ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sys . exit ( unittest . main ( ) ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="eaglexmw/seascope/tree/master/src/view/filecontext/plugins/ctags_view/CtagsManager.py"> # ▁ Copyright ▁ ( c ) ▁ 2010 ▁ Anil ▁ Kumar ENDCOM # ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ License : ▁ BSD ▁ ENDCOM import subprocess NEW_LINE import re , os NEW_LINE def _eintr_retry_call ( func , * args ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT return func ( * args ) NEW_LINE DEDENT except OSError , e : NEW_LINE INDENT if e . errno == errno . EINTR : NEW_LINE INDENT continue NEW_LINE DEDENT raise NEW_LINE DEDENT DEDENT DEDENT def cmdForFile ( f ) : NEW_LINE INDENT suffix_cmd_map = [ ] NEW_LINE custom_map = os . getenv ( ' SEASCOPE _ CTAGS _ SUFFIX _ CMD _ MAP ' ) NEW_LINE if custom_map : NEW_LINE INDENT custom_map = eval ( custom_map ) NEW_LINE suffix_cmd_map += custom_map NEW_LINE # args ▁ = ▁ ' ctags ▁ - n ▁ - u ▁ - - fields = + K ▁ - f ▁ - ▁ - - extra = + q ' ENDCOM # args ▁ = ▁ ' ctags ▁ - n ▁ - u ▁ - - fields = + Ki ▁ - f ▁ - ' ENDCOM DEDENT args = ' ctags ▁ - n ▁ - u ▁ - - fields = + K ▁ - f ▁ - ' NEW_LINE suffix_cmd_map . append ( [ ' ' , args ] ) NEW_LINE for ( suffix , cmd ) in suffix_cmd_map : NEW_LINE INDENT if f . endswith ( suffix ) : NEW_LINE INDENT return cmd NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def ct_query ( filename ) : NEW_LINE INDENT args = cmdForFile ( filename ) NEW_LINE args = args . split ( ) NEW_LINE args . append ( filename ) NEW_LINE try : NEW_LINE INDENT proc = subprocess . Popen ( args , stdout = subprocess . PIPE ) NEW_LINE ( out_data , err_data ) = _eintr_retry_call ( proc . communicate ) NEW_LINE out_data = out_data . split ( ' \n ' ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT out_data = [ ' Failed ▁ to ▁ run ▁ ctags ▁ cmd\tignore\t0 ; \t ▁ ' , ' cmd : ▁ % s\tignore\t0 ; \t ▁ ' % ' ▁ ' . join ( args ) , ' error : ▁ % s\tignore\t0 ; \t ▁ ' % str ( e ) , ' ctags ▁ not ▁ installed ▁ ? \tignore\t0 ; \t ▁ ' , ] NEW_LINE DEDENT res = [ ] NEW_LINE for line in out_data : NEW_LINE INDENT if ( line == ' ' ) : NEW_LINE INDENT break NEW_LINE DEDENT line = line . split ( ' \t ' ) NEW_LINE num = line [ 2 ] . split ( ' ; ' , 1 ) [ 0 ] NEW_LINE line = [ line [ 0 ] , num , line [ 3 ] ] NEW_LINE res . append ( line ) NEW_LINE DEDENT return res NEW_LINE DEDENT is_OrderedDict_available = False NEW_LINE try : NEW_LINE # ▁ OrderedDict ▁ available ▁ only ▁ in ▁ python ▁ > = ▁ 2.7 ENDCOM INDENT from collections import OrderedDict NEW_LINE is_OrderedDict_available = True NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT def emptyOrderedDict ( ) : NEW_LINE INDENT if is_OrderedDict_available : NEW_LINE INDENT return OrderedDict ( { } ) NEW_LINE DEDENT return { } NEW_LINE DEDENT class CtagsTreeBuilder : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . symTree = emptyOrderedDict ( ) NEW_LINE DEDENT def cmdForFile ( self , f ) : NEW_LINE INDENT suffix_cmd_map = [ ] NEW_LINE custom_map = os . getenv ( ' SEASCOPE _ CTAGS _ SUFFIX _ CMD _ MAP ' ) NEW_LINE if custom_map : NEW_LINE INDENT custom_map = eval ( custom_map ) NEW_LINE suffix_cmd_map += custom_map NEW_LINE # args ▁ = ▁ ' ctags ▁ - n ▁ - u ▁ - - fields = + K ▁ - f ▁ - ▁ - - extra = + q ' ENDCOM # args ▁ = ▁ ' ctags ▁ - n ▁ - u ▁ - - fields = + Ki ▁ - f ▁ - ' ENDCOM DEDENT args = ' ctags ▁ - n ▁ - u ▁ - - fields = + K - f - t ▁ - f ▁ - ' NEW_LINE suffix_cmd_map . append ( [ ' ' , args ] ) NEW_LINE for ( suffix , cmd ) in suffix_cmd_map : NEW_LINE INDENT if f . endswith ( suffix ) : NEW_LINE INDENT return cmd NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def runCtags ( self , f ) : NEW_LINE INDENT args = self . cmdForFile ( f ) NEW_LINE args = args . split ( ) NEW_LINE args . append ( f ) NEW_LINE # ▁ In ▁ python ▁ > = ▁ 2.7 ▁ can ▁ use ▁ subprocess . check _ output ENDCOM # ▁ output ▁ = ▁ subprocess . check _ output ( args ) ENDCOM # ▁ return ▁ output ENDCOM proc = subprocess . Popen ( args , stdout = subprocess . PIPE ) NEW_LINE ( out_data , err_data ) = proc . communicate ( ) NEW_LINE return out_data NEW_LINE DEDENT def parseCtagsOutput ( self , data ) : NEW_LINE INDENT data = re . split ( ' ? \n ' , data ) NEW_LINE res = [ ] NEW_LINE for line in data : NEW_LINE INDENT if line == ' ' : NEW_LINE INDENT continue NEW_LINE DEDENT try : NEW_LINE INDENT line = line . split ( ' \t ' , 4 ) NEW_LINE res . append ( line ) NEW_LINE DEDENT except : NEW_LINE INDENT print ' bad ▁ line : ' , line NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def addToSymLayout ( self , sc ) : NEW_LINE INDENT t = self . symTree NEW_LINE if sc and sc != ' ' : NEW_LINE INDENT for s in re . split ( ' : : | \ . ' , sc ) : NEW_LINE INDENT if s not in t : NEW_LINE INDENT t [ s ] = emptyOrderedDict ( ) NEW_LINE DEDENT t = t [ s ] NEW_LINE DEDENT DEDENT DEDENT def addToSymTree ( self , sc , line ) : NEW_LINE INDENT t = self . symTree NEW_LINE if sc and sc != ' ' : NEW_LINE INDENT for s in re . split ( ' : : | \ . ' , sc ) : NEW_LINE INDENT assert s in t NEW_LINE t = t [ s ] NEW_LINE DEDENT DEDENT cline = [ line [ 0 ] , line [ 2 ] . split ( ' ; ' ) [ 0 ] , line [ 3 ] ] NEW_LINE if line [ 0 ] in t : NEW_LINE # print ▁ line [ 0 ] , ▁ ' in ' , ▁ t ENDCOM INDENT x = t [ line [ 0 ] ] NEW_LINE if ' + ' not in x : NEW_LINE INDENT x [ ' + ' ] = cline NEW_LINE return NEW_LINE DEDENT DEDENT if ' * ' not in t : NEW_LINE INDENT t [ ' * ' ] = [ ] NEW_LINE DEDENT t [ ' * ' ] . append ( cline ) NEW_LINE # print ▁ ' . . . ' , ▁ t , ▁ line ENDCOM DEDENT def buildTree ( self , data ) : NEW_LINE INDENT type_list = [ ' namespace ' , ' class ' , ' interface ' , ' struct ' , ' union ' , ' enum ' , ' function ' ] NEW_LINE # ▁ build ▁ layout ▁ using ▁ 5th ▁ field ENDCOM for line in data : NEW_LINE INDENT if len ( line ) == 4 : NEW_LINE INDENT continue NEW_LINE DEDENT try : NEW_LINE INDENT sd = dict ( [ x . split ( ' : ' , 1 ) for x in line [ 4 ] . split ( ' \t ' ) ] ) NEW_LINE DEDENT except : NEW_LINE INDENT print ' bad ▁ line ' , line NEW_LINE continue NEW_LINE DEDENT line [ 4 ] = sd NEW_LINE count = 0 NEW_LINE for t in type_list : NEW_LINE INDENT if t in sd : NEW_LINE INDENT self . addToSymLayout ( sd [ t ] ) NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if count != 1 : NEW_LINE INDENT print ' * * * * * * * * ▁ count ▁ = = ▁ 1 ▁ * * * * * * * * * ' NEW_LINE print data NEW_LINE print line NEW_LINE # assert ▁ count ▁ = = ▁ 1 ENDCOM DEDENT DEDENT if len ( self . symTree ) == 0 : NEW_LINE INDENT return ( data , False ) NEW_LINE DEDENT for line in data : NEW_LINE INDENT if len ( line ) == 4 : NEW_LINE INDENT self . addToSymTree ( None , line ) NEW_LINE continue NEW_LINE DEDENT sd = line [ 4 ] NEW_LINE count = 0 NEW_LINE for t in type_list : NEW_LINE INDENT if t in sd : NEW_LINE INDENT self . addToSymTree ( sd [ t ] , line ) NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT if count != 1 : NEW_LINE INDENT print ' * * * * * * * * ▁ count ▁ = = ▁ 1 ▁ * * * * * * * * * ' NEW_LINE print data NEW_LINE print line NEW_LINE # assert ▁ count ▁ = = ▁ 1 ENDCOM DEDENT DEDENT return ( self . symTree , True ) NEW_LINE DEDENT def doQuery ( self , filename ) : NEW_LINE INDENT try : NEW_LINE INDENT output = self . runCtags ( filename ) NEW_LINE output = self . parseCtagsOutput ( output ) NEW_LINE output = self . buildTree ( output ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT print str ( e ) NEW_LINE output = [ None , False ] NEW_LINE DEDENT return output NEW_LINE DEDENT DEDENT def ct_tree_query ( filename ) : NEW_LINE INDENT ct = CtagsTreeBuilder ( ) NEW_LINE output = ct . doQuery ( filename ) NEW_LINE return output NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import optparse NEW_LINE import sys NEW_LINE depth = 0 NEW_LINE def recursePrint ( t ) : NEW_LINE INDENT global depth NEW_LINE for k , v in t . items ( ) : NEW_LINE INDENT if k == ' * ' : NEW_LINE INDENT for line in v : NEW_LINE INDENT print ' % s % s ' % ( ' ▁ ' * depth , line ) NEW_LINE DEDENT continue NEW_LINE DEDENT if k == ' + ' : NEW_LINE INDENT continue NEW_LINE DEDENT if ' + ' in v : NEW_LINE INDENT k = v [ ' + ' ] NEW_LINE DEDENT print ' % s % s ' % ( ' ▁ ' * depth , k ) NEW_LINE depth = depth + 4 NEW_LINE recursePrint ( v ) NEW_LINE depth = depth - 4 NEW_LINE DEDENT DEDENT op = optparse . OptionParser ( ) NEW_LINE ( options , args ) = op . parse_args ( ) NEW_LINE if len ( args ) != 1 : NEW_LINE INDENT print ' Please ▁ specify ▁ a ▁ file ' NEW_LINE sys . exit ( - 1 ) NEW_LINE DEDENT ( output , isTree ) = ct_tree_query ( args [ 0 ] ) NEW_LINE if isTree : NEW_LINE INDENT recursePrint ( output ) NEW_LINE DEDENT else : NEW_LINE INDENT for line in output : NEW_LINE INDENT print line NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="patrickstocklin/chattR/tree/master/lib/python2.7/site-packages/pip/index.py"> """ Routines ▁ related ▁ to ▁ PyPI , ▁ indexes """ NEW_LINE from __future__ import absolute_import NEW_LINE import logging NEW_LINE import cgi NEW_LINE from collections import namedtuple NEW_LINE import itertools NEW_LINE import sys NEW_LINE import os NEW_LINE import re NEW_LINE import mimetypes NEW_LINE import posixpath NEW_LINE import warnings NEW_LINE from pip . _vendor . six . moves . urllib import parse as urllib_parse NEW_LINE from pip . _vendor . six . moves . urllib import request as urllib_request NEW_LINE from pip . compat import ipaddress NEW_LINE from pip . utils import ( Inf , cached_property , normalize_name , splitext , normalize_path , ARCHIVE_EXTENSIONS , SUPPORTED_EXTENSIONS ) NEW_LINE from pip . utils . deprecation import RemovedInPip8Warning NEW_LINE from pip . utils . logging import indent_log NEW_LINE from pip . exceptions import ( DistributionNotFound , BestVersionAlreadyInstalled , InvalidWheelFilename , UnsupportedWheel , ) NEW_LINE from pip . download import HAS_TLS , url_to_path , path_to_url NEW_LINE from pip . models import PyPI NEW_LINE from pip . wheel import Wheel , wheel_ext NEW_LINE from pip . pep425tags import supported_tags , supported_tags_noarch , get_platform NEW_LINE from pip . _vendor import html5lib , requests , pkg_resources , six NEW_LINE from pip . _vendor . packaging . version import parse as parse_version NEW_LINE from pip . _vendor . requests . exceptions import SSLError NEW_LINE __all__ = [ ' FormatControl ' , ' fmt _ ctl _ handle _ mutual _ exclude ' , ' PackageFinder ' ] NEW_LINE # ▁ Taken ▁ from ▁ Chrome ' s ▁ list ▁ of ▁ secure ▁ origins ▁ ( See : ▁ http : / / bit . ly / 1qrySKC ) ENDCOM SECURE_ORIGINS = [ # ▁ protocol , ▁ hostname , ▁ port ENDCOM ( " https " , " * " , " * " ) , ( " * " , " localhost " , " * " ) , ( " * " , "127.0.0.0/8" , " * " ) , ( " * " , " : :1/128" , " * " ) , ( " file " , " * " , None ) , ] NEW_LINE logger = logging . getLogger ( __name__ ) NEW_LINE class InstallationCandidate ( object ) : NEW_LINE INDENT def __init__ ( self , project , version , location ) : NEW_LINE INDENT self . project = project NEW_LINE self . version = parse_version ( version ) NEW_LINE self . location = location NEW_LINE self . _key = ( self . project , self . version , self . location ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " < InstallationCandidate ( {0 ! r } , ▁ { 1 ! r } , ▁ { 2 ! r } ) > " . format ( self . project , self . version , self . location , ) NEW_LINE DEDENT def __hash__ ( self ) : NEW_LINE INDENT return hash ( self . _key ) NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s < o ) NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s <= o ) NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s == o ) NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s >= o ) NEW_LINE DEDENT def __gt__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s > o ) NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s != o ) NEW_LINE DEDENT def _compare ( self , other , method ) : NEW_LINE INDENT if not isinstance ( other , InstallationCandidate ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return method ( self . _key , other . _key ) NEW_LINE DEDENT DEDENT class PackageFinder ( object ) : NEW_LINE INDENT """ This ▁ finds ▁ packages . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ meant ▁ to ▁ match ▁ easy _ install ' s ▁ technique ▁ for ▁ looking ▁ for STRNEWLINE ▁ packages , ▁ by ▁ reading ▁ pages ▁ and ▁ looking ▁ for ▁ appropriate ▁ links . STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , find_links , index_urls , allow_external = ( ) , allow_unverified = ( ) , allow_all_external = False , allow_all_prereleases = False , trusted_hosts = None , process_dependency_links = False , session = None , format_control = None ) : NEW_LINE INDENT """ Create ▁ a ▁ PackageFinder . STRNEWLINE STRNEWLINE ▁ : param ▁ format _ control : ▁ A ▁ FormatControl ▁ object ▁ or ▁ None . ▁ Used ▁ to ▁ control STRNEWLINE ▁ the ▁ selection ▁ of ▁ source ▁ packages ▁ / ▁ binary ▁ packages ▁ when ▁ consulting STRNEWLINE ▁ the ▁ index ▁ and ▁ links . STRNEWLINE ▁ """ NEW_LINE if session is None : NEW_LINE INDENT raise TypeError ( " PackageFinder ( ) ▁ missing ▁ 1 ▁ required ▁ keyword ▁ argument : ▁ " " ' session ' " ) NEW_LINE # ▁ Build ▁ find _ links . ▁ If ▁ an ▁ argument ▁ starts ▁ with ▁ ~ , ▁ it ▁ may ▁ be ENDCOM # ▁ a ▁ local ▁ file ▁ relative ▁ to ▁ a ▁ home ▁ directory . ▁ So ▁ try ▁ normalizing ENDCOM # ▁ it ▁ and ▁ if ▁ it ▁ exists , ▁ use ▁ the ▁ normalized ▁ version . ENDCOM # ▁ This ▁ is ▁ deliberately ▁ conservative ▁ - ▁ it ▁ might ▁ be ▁ fine ▁ just ▁ to ENDCOM # ▁ blindly ▁ normalize ▁ anything ▁ starting ▁ with ▁ a ▁ ~ . . . ENDCOM DEDENT self . find_links = [ ] NEW_LINE for link in find_links : NEW_LINE INDENT if link . startswith ( ' ~ ' ) : NEW_LINE INDENT new_link = normalize_path ( link ) NEW_LINE if os . path . exists ( new_link ) : NEW_LINE INDENT link = new_link NEW_LINE DEDENT DEDENT self . find_links . append ( link ) NEW_LINE DEDENT self . index_urls = index_urls NEW_LINE self . dependency_links = [ ] NEW_LINE # ▁ These ▁ are ▁ boring ▁ links ▁ that ▁ have ▁ already ▁ been ▁ logged ▁ somehow : ENDCOM self . logged_links = set ( ) NEW_LINE self . format_control = format_control or FormatControl ( set ( ) , set ( ) ) NEW_LINE # ▁ Do ▁ we ▁ allow ▁ ( safe ▁ and ▁ verifiable ) ▁ externally ▁ hosted ▁ files ? ENDCOM self . allow_external = set ( normalize_name ( n ) for n in allow_external ) NEW_LINE # ▁ Which ▁ names ▁ are ▁ allowed ▁ to ▁ install ▁ insecure ▁ and ▁ unverifiable ▁ files ? ENDCOM self . allow_unverified = set ( normalize_name ( n ) for n in allow_unverified ) NEW_LINE # ▁ Anything ▁ that ▁ is ▁ allowed ▁ unverified ▁ is ▁ also ▁ allowed ▁ external ENDCOM self . allow_external |= self . allow_unverified NEW_LINE # ▁ Do ▁ we ▁ allow ▁ all ▁ ( safe ▁ and ▁ verifiable ) ▁ externally ▁ hosted ▁ files ? ENDCOM self . allow_all_external = allow_all_external NEW_LINE # ▁ Domains ▁ that ▁ we ▁ won ' t ▁ emit ▁ warnings ▁ for ▁ when ▁ not ▁ using ▁ HTTPS ENDCOM self . secure_origins = [ ( " * " , host , " * " ) for host in ( trusted_hosts if trusted_hosts else [ ] ) ] NEW_LINE # ▁ Stores ▁ if ▁ we ▁ ignored ▁ any ▁ external ▁ links ▁ so ▁ that ▁ we ▁ can ▁ instruct ENDCOM # ▁ end ▁ users ▁ how ▁ to ▁ install ▁ them ▁ if ▁ no ▁ distributions ▁ are ▁ available ENDCOM self . need_warn_external = False NEW_LINE # ▁ Stores ▁ if ▁ we ▁ ignored ▁ any ▁ unsafe ▁ links ▁ so ▁ that ▁ we ▁ can ▁ instruct ENDCOM # ▁ end ▁ users ▁ how ▁ to ▁ install ▁ them ▁ if ▁ no ▁ distributions ▁ are ▁ available ENDCOM self . need_warn_unverified = False NEW_LINE # ▁ Do ▁ we ▁ want ▁ to ▁ allow ▁ _ all _ ▁ pre - releases ? ENDCOM self . allow_all_prereleases = allow_all_prereleases NEW_LINE # ▁ Do ▁ we ▁ process ▁ dependency ▁ links ? ENDCOM self . process_dependency_links = process_dependency_links NEW_LINE # ▁ The ▁ Session ▁ we ' ll ▁ use ▁ to ▁ make ▁ requests ENDCOM self . session = session NEW_LINE # ▁ If ▁ we ▁ don ' t ▁ have ▁ TLS ▁ enabled , ▁ then ▁ WARN ▁ if ▁ anyplace ▁ we ' re ▁ looking ENDCOM # ▁ relies ▁ on ▁ TLS . ENDCOM if not HAS_TLS : NEW_LINE INDENT for link in itertools . chain ( self . index_urls , self . find_links ) : NEW_LINE INDENT parsed = urllib_parse . urlparse ( link ) NEW_LINE if parsed . scheme == " https " : NEW_LINE INDENT logger . warning ( " pip ▁ is ▁ configured ▁ with ▁ locations ▁ that ▁ require ▁ " " TLS / SSL , ▁ however ▁ the ▁ ssl ▁ module ▁ in ▁ Python ▁ is ▁ not ▁ " " available . " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT def add_dependency_links ( self , links ) : NEW_LINE # ▁ # ▁ FIXME : ▁ this ▁ shouldn ' t ▁ be ▁ global ▁ list ▁ this , ▁ it ▁ should ▁ only ENDCOM # ▁ # ▁ apply ▁ to ▁ requirements ▁ of ▁ the ▁ package ▁ that ▁ specifies ▁ the ENDCOM # ▁ # ▁ dependency _ links ▁ value ENDCOM # ▁ # ▁ FIXME : ▁ also , ▁ we ▁ should ▁ track ▁ comes _ from ▁ ( i . e . , ▁ use ▁ Link ) ENDCOM INDENT if self . process_dependency_links : NEW_LINE INDENT warnings . warn ( " Dependency ▁ Links ▁ processing ▁ has ▁ been ▁ deprecated ▁ and ▁ will ▁ be ▁ " " removed ▁ in ▁ a ▁ future ▁ release . " , RemovedInPip8Warning , ) NEW_LINE self . dependency_links . extend ( links ) NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def _sort_locations ( locations , expand_dir = False ) : NEW_LINE INDENT """ STRNEWLINE ▁ Sort ▁ locations ▁ into ▁ " files " ▁ ( archives ) ▁ and ▁ " urls " , ▁ and ▁ return STRNEWLINE ▁ a ▁ pair ▁ of ▁ lists ▁ ( files , urls ) STRNEWLINE ▁ """ NEW_LINE files = [ ] NEW_LINE urls = [ ] NEW_LINE # ▁ puts ▁ the ▁ url ▁ for ▁ the ▁ given ▁ file ▁ path ▁ into ▁ the ▁ appropriate ▁ list ENDCOM def sort_path ( path ) : NEW_LINE INDENT url = path_to_url ( path ) NEW_LINE if mimetypes . guess_type ( url , strict = False ) [ 0 ] == ' text / html ' : NEW_LINE INDENT urls . append ( url ) NEW_LINE DEDENT else : NEW_LINE INDENT files . append ( url ) NEW_LINE DEDENT DEDENT for url in locations : NEW_LINE INDENT is_local_path = os . path . exists ( url ) NEW_LINE is_file_url = url . startswith ( ' file : ' ) NEW_LINE if is_local_path or is_file_url : NEW_LINE INDENT if is_local_path : NEW_LINE INDENT path = url NEW_LINE DEDENT else : NEW_LINE INDENT path = url_to_path ( url ) NEW_LINE DEDENT if os . path . isdir ( path ) : NEW_LINE INDENT if expand_dir : NEW_LINE INDENT path = os . path . realpath ( path ) NEW_LINE for item in os . listdir ( path ) : NEW_LINE INDENT sort_path ( os . path . join ( path , item ) ) NEW_LINE DEDENT DEDENT elif is_file_url : NEW_LINE INDENT urls . append ( url ) NEW_LINE DEDENT DEDENT elif os . path . isfile ( path ) : NEW_LINE INDENT sort_path ( path ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT urls . append ( url ) NEW_LINE DEDENT DEDENT return files , urls NEW_LINE DEDENT def _candidate_sort_key ( self , candidate ) : NEW_LINE INDENT """ STRNEWLINE ▁ Function ▁ used ▁ to ▁ generate ▁ link ▁ sort ▁ key ▁ for ▁ link ▁ tuples . STRNEWLINE ▁ The ▁ greater ▁ the ▁ return ▁ value , ▁ the ▁ more ▁ preferred ▁ it ▁ is . STRNEWLINE ▁ If ▁ not ▁ finding ▁ wheels , ▁ then ▁ sorted ▁ by ▁ version ▁ only . STRNEWLINE ▁ If ▁ finding ▁ wheels , ▁ then ▁ the ▁ sort ▁ order ▁ is ▁ by ▁ version , ▁ then : STRNEWLINE ▁ 1 . ▁ existing ▁ installs STRNEWLINE ▁ 2 . ▁ wheels ▁ ordered ▁ via ▁ Wheel . support _ index _ min ( ) STRNEWLINE ▁ 3 . ▁ source ▁ archives STRNEWLINE ▁ Note : ▁ it ▁ was ▁ considered ▁ to ▁ embed ▁ this ▁ logic ▁ into ▁ the ▁ Link STRNEWLINE ▁ comparison ▁ operators , ▁ but ▁ then ▁ different ▁ sdist ▁ links STRNEWLINE ▁ with ▁ the ▁ same ▁ version , ▁ would ▁ have ▁ to ▁ be ▁ considered ▁ equal STRNEWLINE ▁ """ NEW_LINE support_num = len ( supported_tags ) NEW_LINE if candidate . location == INSTALLED_VERSION : NEW_LINE INDENT pri = 1 NEW_LINE DEDENT elif candidate . location . is_wheel : NEW_LINE # ▁ can ▁ raise ▁ InvalidWheelFilename ENDCOM INDENT wheel = Wheel ( candidate . location . filename ) NEW_LINE if not wheel . supported ( ) : NEW_LINE INDENT raise UnsupportedWheel ( " % s ▁ is ▁ not ▁ a ▁ supported ▁ wheel ▁ for ▁ this ▁ platform . ▁ It ▁ " " can ' t ▁ be ▁ sorted . " % wheel . filename ) NEW_LINE DEDENT pri = - ( wheel . support_index_min ( ) ) NEW_LINE DEDENT else : # ▁ sdist ENDCOM NEW_LINE INDENT pri = - ( support_num ) NEW_LINE DEDENT return ( candidate . version , pri ) NEW_LINE DEDENT def _sort_versions ( self , applicable_versions ) : NEW_LINE INDENT """ STRNEWLINE ▁ Bring ▁ the ▁ latest ▁ version ▁ ( and ▁ wheels ) ▁ to ▁ the ▁ front , ▁ but ▁ maintain ▁ the STRNEWLINE ▁ existing ▁ ordering ▁ as ▁ secondary . ▁ See ▁ the ▁ docstring ▁ for ▁ ` _ link _ sort _ key ` STRNEWLINE ▁ for ▁ details . ▁ This ▁ function ▁ is ▁ isolated ▁ for ▁ easier ▁ unit ▁ testing . STRNEWLINE ▁ """ NEW_LINE return sorted ( applicable_versions , key = self . _candidate_sort_key , reverse = True ) NEW_LINE DEDENT def _validate_secure_origin ( self , logger , location ) : NEW_LINE # ▁ Determine ▁ if ▁ this ▁ url ▁ used ▁ a ▁ secure ▁ transport ▁ mechanism ENDCOM INDENT parsed = urllib_parse . urlparse ( str ( location ) ) NEW_LINE origin = ( parsed . scheme , parsed . hostname , parsed . port ) NEW_LINE # ▁ Determine ▁ if ▁ our ▁ origin ▁ is ▁ a ▁ secure ▁ origin ▁ by ▁ looking ▁ through ▁ our ENDCOM # ▁ hardcoded ▁ list ▁ of ▁ secure ▁ origins , ▁ as ▁ well ▁ as ▁ any ▁ additional ▁ ones ENDCOM # ▁ configured ▁ on ▁ this ▁ PackageFinder ▁ instance . ENDCOM for secure_origin in ( SECURE_ORIGINS + self . secure_origins ) : NEW_LINE # ▁ Check ▁ to ▁ see ▁ if ▁ the ▁ protocol ▁ matches ENDCOM INDENT if origin [ 0 ] != secure_origin [ 0 ] and secure_origin [ 0 ] != " * " : NEW_LINE INDENT continue NEW_LINE DEDENT try : NEW_LINE # ▁ We ▁ need ▁ to ▁ do ▁ this ▁ decode ▁ dance ▁ to ▁ ensure ▁ that ▁ we ▁ have ▁ a ENDCOM # ▁ unicode ▁ object , ▁ even ▁ on ▁ Python ▁ 2 . x . ENDCOM INDENT addr = ipaddress . ip_address ( origin [ 1 ] if ( isinstance ( origin [ 1 ] , six . text_type ) or origin [ 1 ] is None ) else origin [ 1 ] . decode ( " utf8" ) ) NEW_LINE network = ipaddress . ip_network ( secure_origin [ 1 ] if isinstance ( secure_origin [ 1 ] , six . text_type ) else secure_origin [ 1 ] . decode ( " utf8" ) ) NEW_LINE DEDENT except ValueError : NEW_LINE # ▁ We ▁ don ' t ▁ have ▁ both ▁ a ▁ valid ▁ address ▁ or ▁ a ▁ valid ▁ network , ▁ so ENDCOM # ▁ we ' ll ▁ check ▁ this ▁ origin ▁ against ▁ hostnames . ENDCOM INDENT if origin [ 1 ] != secure_origin [ 1 ] and secure_origin [ 1 ] != " * " : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT else : NEW_LINE # ▁ We ▁ have ▁ a ▁ valid ▁ address ▁ and ▁ network , ▁ so ▁ see ▁ if ▁ the ▁ address ENDCOM # ▁ is ▁ contained ▁ within ▁ the ▁ network . ENDCOM INDENT if addr not in network : NEW_LINE INDENT continue NEW_LINE # ▁ Check ▁ to ▁ see ▁ if ▁ the ▁ port ▁ patches ENDCOM DEDENT DEDENT if ( origin [ 2 ] != secure_origin [ 2 ] and secure_origin [ 2 ] != " * " and secure_origin [ 2 ] is not None ) : NEW_LINE INDENT continue NEW_LINE # ▁ If ▁ we ' ve ▁ gotten ▁ here , ▁ then ▁ this ▁ origin ▁ matches ▁ the ▁ current ENDCOM # ▁ secure ▁ origin ▁ and ▁ we ▁ should ▁ return ▁ True ENDCOM DEDENT return True NEW_LINE # ▁ If ▁ we ' ve ▁ gotten ▁ to ▁ this ▁ point , ▁ then ▁ the ▁ origin ▁ isn ' t ▁ secure ▁ and ▁ we ENDCOM # ▁ will ▁ not ▁ accept ▁ it ▁ as ▁ a ▁ valid ▁ location ▁ to ▁ search . ▁ We ▁ will ▁ however ENDCOM # ▁ log ▁ a ▁ warning ▁ that ▁ we ▁ are ▁ ignoring ▁ it . ENDCOM DEDENT logger . warning ( " The ▁ repository ▁ located ▁ at ▁ % s ▁ is ▁ not ▁ a ▁ trusted ▁ or ▁ secure ▁ host ▁ and ▁ " " is ▁ being ▁ ignored . ▁ If ▁ this ▁ repository ▁ is ▁ available ▁ via ▁ HTTPS ▁ it ▁ " " is ▁ recommended ▁ to ▁ use ▁ HTTPS ▁ instead , ▁ otherwise ▁ you ▁ may ▁ silence ▁ " " this ▁ warning ▁ and ▁ allow ▁ it ▁ anyways ▁ with ▁ ' - - trusted - host ▁ % s ' . " , parsed . hostname , parsed . hostname , ) NEW_LINE return False NEW_LINE DEDENT def _get_index_urls_locations ( self , project_name ) : NEW_LINE INDENT """ Returns ▁ the ▁ locations ▁ found ▁ via ▁ self . index _ urls STRNEWLINE STRNEWLINE ▁ Checks ▁ the ▁ url _ name ▁ on ▁ the ▁ main ▁ ( first ▁ in ▁ the ▁ list ) ▁ index ▁ and STRNEWLINE ▁ use ▁ this ▁ url _ name ▁ to ▁ produce ▁ all ▁ locations STRNEWLINE ▁ """ NEW_LINE def mkurl_pypi_url ( url ) : NEW_LINE INDENT loc = posixpath . join ( url , project_url_name ) NEW_LINE # ▁ For ▁ maximum ▁ compatibility ▁ with ▁ easy _ install , ▁ ensure ▁ the ▁ path ENDCOM # ▁ ends ▁ in ▁ a ▁ trailing ▁ slash . ▁ Although ▁ this ▁ isn ' t ▁ in ▁ the ▁ spec ENDCOM # ▁ ( and ▁ PyPI ▁ can ▁ handle ▁ it ▁ without ▁ the ▁ slash ) ▁ some ▁ other ▁ index ENDCOM # ▁ implementations ▁ might ▁ break ▁ if ▁ they ▁ relied ▁ on ▁ easy _ install ' s ENDCOM # ▁ behavior . ENDCOM if not loc . endswith ( ' / ' ) : NEW_LINE INDENT loc = loc + ' / ' NEW_LINE DEDENT return loc NEW_LINE DEDENT project_url_name = urllib_parse . quote ( project_name . lower ( ) ) NEW_LINE if self . index_urls : NEW_LINE # ▁ Check ▁ that ▁ we ▁ have ▁ the ▁ url _ name ▁ correctly ▁ spelled : ENDCOM # ▁ Only ▁ check ▁ main ▁ index ▁ if ▁ index ▁ URL ▁ is ▁ given ENDCOM INDENT main_index_url = Link ( mkurl_pypi_url ( self . index_urls [ 0 ] ) , trusted = True , ) NEW_LINE page = self . _get_page ( main_index_url ) NEW_LINE if page is None and PyPI . netloc not in str ( main_index_url ) : NEW_LINE INDENT warnings . warn ( " Failed ▁ to ▁ find ▁ % r ▁ at ▁ % s . ▁ It ▁ is ▁ suggested ▁ to ▁ upgrade ▁ " " your ▁ index ▁ to ▁ support ▁ normalized ▁ names ▁ as ▁ the ▁ name ▁ in ▁ " " / simple / { name } . " % ( project_name , main_index_url ) , RemovedInPip8Warning , ) NEW_LINE project_url_name = self . _find_url_name ( Link ( self . index_urls [ 0 ] , trusted = True ) , project_url_name , ) or project_url_name NEW_LINE DEDENT DEDENT if project_url_name is not None : NEW_LINE INDENT return [ mkurl_pypi_url ( url ) for url in self . index_urls ] NEW_LINE DEDENT return [ ] NEW_LINE DEDENT def _find_all_versions ( self , project_name ) : NEW_LINE INDENT """ Find ▁ all ▁ available ▁ versions ▁ for ▁ project _ name STRNEWLINE STRNEWLINE ▁ This ▁ checks ▁ index _ urls , ▁ find _ links ▁ and ▁ dependency _ links STRNEWLINE ▁ All ▁ versions ▁ found ▁ are ▁ returned STRNEWLINE STRNEWLINE ▁ See ▁ _ link _ package _ versions ▁ for ▁ details ▁ on ▁ which ▁ files ▁ are ▁ accepted STRNEWLINE ▁ """ NEW_LINE index_locations = self . _get_index_urls_locations ( project_name ) NEW_LINE index_file_loc , index_url_loc = self . _sort_locations ( index_locations ) NEW_LINE fl_file_loc , fl_url_loc = self . _sort_locations ( self . find_links , expand_dir = True ) NEW_LINE dep_file_loc , dep_url_loc = self . _sort_locations ( self . dependency_links ) NEW_LINE file_locations = ( Link ( url ) for url in itertools . chain ( index_file_loc , fl_file_loc , dep_file_loc ) ) NEW_LINE # ▁ We ▁ trust ▁ every ▁ url ▁ that ▁ the ▁ user ▁ has ▁ given ▁ us ▁ whether ▁ it ▁ was ▁ given ENDCOM # ▁ via ▁ - - index - url ▁ or ▁ - - find - links ENDCOM # ▁ We ▁ explicitly ▁ do ▁ not ▁ trust ▁ links ▁ that ▁ came ▁ from ▁ dependency _ links ENDCOM # ▁ We ▁ want ▁ to ▁ filter ▁ out ▁ any ▁ thing ▁ which ▁ does ▁ not ▁ have ▁ a ▁ secure ▁ origin . ENDCOM url_locations = [ link for link in itertools . chain ( ( Link ( url , trusted = True ) for url in index_url_loc ) , ( Link ( url , trusted = True ) for url in fl_url_loc ) , ( Link ( url ) for url in dep_url_loc ) , ) if self . _validate_secure_origin ( logger , link ) ] NEW_LINE logger . debug ( ' % d ▁ location ( s ) ▁ to ▁ search ▁ for ▁ versions ▁ of ▁ % s : ' , len ( url_locations ) , project_name ) NEW_LINE for location in url_locations : NEW_LINE INDENT logger . debug ( ' * ▁ % s ' , location ) NEW_LINE DEDENT canonical_name = pkg_resources . safe_name ( project_name ) . lower ( ) NEW_LINE formats = fmt_ctl_formats ( self . format_control , canonical_name ) NEW_LINE search = Search ( project_name . lower ( ) , canonical_name , formats ) NEW_LINE find_links_versions = self . _package_versions ( # ▁ We ▁ trust ▁ every ▁ directly ▁ linked ▁ archive ▁ in ▁ find _ links ENDCOM ( Link ( url , ' - f ' , trusted = True ) for url in self . find_links ) , search ) NEW_LINE page_versions = [ ] NEW_LINE for page in self . _get_pages ( url_locations , project_name ) : NEW_LINE INDENT logger . debug ( ' Analyzing ▁ links ▁ from ▁ page ▁ % s ' , page . url ) NEW_LINE with indent_log ( ) : NEW_LINE INDENT page_versions . extend ( self . _package_versions ( page . links , search ) ) NEW_LINE DEDENT DEDENT dependency_versions = self . _package_versions ( ( Link ( url ) for url in self . dependency_links ) , search ) NEW_LINE if dependency_versions : NEW_LINE INDENT logger . debug ( ' dependency _ links ▁ found : ▁ % s ' , ' , ▁ ' . join ( [ version . location . url for version in dependency_versions ] ) ) NEW_LINE DEDENT file_versions = self . _package_versions ( file_locations , search ) NEW_LINE if file_versions : NEW_LINE INDENT file_versions . sort ( reverse = True ) NEW_LINE logger . debug ( ' Local ▁ files ▁ found : ▁ % s ' , ' , ▁ ' . join ( [ url_to_path ( candidate . location . url ) for candidate in file_versions ] ) ) NEW_LINE # ▁ This ▁ is ▁ an ▁ intentional ▁ priority ▁ ordering ENDCOM DEDENT return ( file_versions + find_links_versions + page_versions + dependency_versions ) NEW_LINE DEDENT def find_requirement ( self , req , upgrade ) : NEW_LINE INDENT """ Try ▁ to ▁ find ▁ an ▁ InstallationCandidate ▁ for ▁ req STRNEWLINE STRNEWLINE ▁ Expects ▁ req , ▁ an ▁ InstallRequirement ▁ and ▁ upgrade , ▁ a ▁ boolean STRNEWLINE ▁ Returns ▁ an ▁ InstallationCandidate ▁ or ▁ None STRNEWLINE ▁ May ▁ raise ▁ DistributionNotFound ▁ or ▁ BestVersionAlreadyInstalled STRNEWLINE ▁ """ NEW_LINE all_versions = self . _find_all_versions ( req . name ) NEW_LINE # ▁ Filter ▁ out ▁ anything ▁ which ▁ doesn ' t ▁ match ▁ our ▁ specifier ENDCOM _versions = set ( req . specifier . filter ( # ▁ We ▁ turn ▁ the ▁ version ▁ object ▁ into ▁ a ▁ str ▁ here ▁ because ▁ otherwise ENDCOM # ▁ when ▁ we ' re ▁ debundled ▁ but ▁ setuptools ▁ isn ' t , ▁ Python ▁ will ▁ see ENDCOM # ▁ packaging . version . Version ▁ and ENDCOM # ▁ pkg _ resources . _ vendor . packaging . version . Version ▁ as ▁ different ENDCOM # ▁ types . ▁ This ▁ way ▁ we ' ll ▁ use ▁ a ▁ str ▁ as ▁ a ▁ common ▁ data ▁ interchange ENDCOM # ▁ format . ▁ If ▁ we ▁ stop ▁ using ▁ the ▁ pkg _ resources ▁ provided ▁ specifier ENDCOM # ▁ and ▁ start ▁ using ▁ our ▁ own , ▁ we ▁ can ▁ drop ▁ the ▁ cast ▁ to ▁ str ( ) . ENDCOM [ str ( x . version ) for x in all_versions ] , prereleases = ( self . allow_all_prereleases if self . allow_all_prereleases else None ) , ) ) NEW_LINE applicable_versions = [ # ▁ Again , ▁ converting ▁ to ▁ str ▁ to ▁ deal ▁ with ▁ debundling . ENDCOM x for x in all_versions if str ( x . version ) in _versions ] NEW_LINE if req . satisfied_by is not None : NEW_LINE # ▁ Finally ▁ add ▁ our ▁ existing ▁ versions ▁ to ▁ the ▁ front ▁ of ▁ our ▁ versions . ENDCOM INDENT applicable_versions . insert ( 0 , InstallationCandidate ( req . name , req . satisfied_by . version , INSTALLED_VERSION , ) ) NEW_LINE existing_applicable = True NEW_LINE DEDENT else : NEW_LINE INDENT existing_applicable = False NEW_LINE DEDENT applicable_versions = self . _sort_versions ( applicable_versions ) NEW_LINE if not upgrade and existing_applicable : NEW_LINE INDENT if applicable_versions [ 0 ] . location is INSTALLED_VERSION : NEW_LINE INDENT logger . debug ( ' Existing ▁ installed ▁ version ▁ ( % s ) ▁ is ▁ most ▁ up - to - date ▁ and ▁ ' ' satisfies ▁ requirement ' , req . satisfied_by . version , ) NEW_LINE DEDENT else : NEW_LINE INDENT logger . debug ( ' Existing ▁ installed ▁ version ▁ ( % s ) ▁ satisfies ▁ requirement ▁ ' ' ( most ▁ up - to - date ▁ version ▁ is ▁ % s ) ' , req . satisfied_by . version , applicable_versions [ 0 ] [ 2 ] , ) NEW_LINE DEDENT return None NEW_LINE DEDENT if not applicable_versions : NEW_LINE INDENT logger . critical ( ' Could ▁ not ▁ find ▁ a ▁ version ▁ that ▁ satisfies ▁ the ▁ requirement ▁ % s ▁ ' ' ( from ▁ versions : ▁ % s ) ' , req , ' , ▁ ' . join ( sorted ( set ( str ( i . version ) for i in all_versions ) , key = parse_version , ) ) ) NEW_LINE if self . need_warn_external : NEW_LINE INDENT logger . warning ( " Some ▁ externally ▁ hosted ▁ files ▁ were ▁ ignored ▁ as ▁ access ▁ to ▁ " " them ▁ may ▁ be ▁ unreliable ▁ ( use ▁ - - allow - external ▁ % s ▁ to ▁ " " allow ) . " , req . name , ) NEW_LINE DEDENT if self . need_warn_unverified : NEW_LINE INDENT logger . warning ( " Some ▁ insecure ▁ and ▁ unverifiable ▁ files ▁ were ▁ ignored " " ▁ ( use ▁ - - allow - unverified ▁ % s ▁ to ▁ allow ) . " , req . name , ) NEW_LINE DEDENT raise DistributionNotFound ( ' No ▁ matching ▁ distribution ▁ found ▁ for ▁ % s ' % req ) NEW_LINE DEDENT if applicable_versions [ 0 ] . location is INSTALLED_VERSION : NEW_LINE # ▁ We ▁ have ▁ an ▁ existing ▁ version , ▁ and ▁ its ▁ the ▁ best ▁ version ENDCOM INDENT logger . debug ( ' Installed ▁ version ▁ ( % s ) ▁ is ▁ most ▁ up - to - date ▁ ( past ▁ versions : ▁ ' ' % s ) ' , req . satisfied_by . version , ' , ▁ ' . join ( str ( i . version ) for i in applicable_versions [ 1 : ] ) or " none " , ) NEW_LINE raise BestVersionAlreadyInstalled NEW_LINE DEDENT if len ( applicable_versions ) > 1 : NEW_LINE INDENT logger . debug ( ' Using ▁ version ▁ % s ▁ ( newest ▁ of ▁ versions : ▁ % s ) ' , applicable_versions [ 0 ] . version , ' , ▁ ' . join ( str ( i . version ) for i in applicable_versions ) ) NEW_LINE DEDENT selected_version = applicable_versions [ 0 ] . location NEW_LINE if ( selected_version . verifiable is not None and not selected_version . verifiable ) : NEW_LINE INDENT logger . warning ( " % s ▁ is ▁ potentially ▁ insecure ▁ and ▁ unverifiable . " , req . name , ) NEW_LINE DEDENT return selected_version NEW_LINE DEDENT def _find_url_name ( self , index_url , url_name ) : NEW_LINE INDENT """ STRNEWLINE ▁ Finds ▁ the ▁ true ▁ URL ▁ name ▁ of ▁ a ▁ package , ▁ when ▁ the ▁ given ▁ name ▁ isn ' t ▁ quite STRNEWLINE ▁ correct . STRNEWLINE ▁ This ▁ is ▁ usually ▁ used ▁ to ▁ implement ▁ case - insensitivity . STRNEWLINE ▁ """ NEW_LINE if not index_url . url . endswith ( ' / ' ) : NEW_LINE # ▁ Vaguely ▁ part ▁ of ▁ the ▁ PyPI ▁ API . . . ▁ weird ▁ but ▁ true . ENDCOM # ▁ FIXME : ▁ bad ▁ to ▁ modify ▁ this ? ENDCOM INDENT index_url . url += ' / ' NEW_LINE DEDENT page = self . _get_page ( index_url ) NEW_LINE if page is None : NEW_LINE INDENT logger . critical ( ' Cannot ▁ fetch ▁ index ▁ base ▁ URL ▁ % s ' , index_url ) NEW_LINE return NEW_LINE DEDENT norm_name = normalize_name ( url_name ) NEW_LINE for link in page . links : NEW_LINE INDENT base = posixpath . basename ( link . path . rstrip ( ' / ' ) ) NEW_LINE if norm_name == normalize_name ( base ) : NEW_LINE INDENT logger . debug ( ' Real ▁ name ▁ of ▁ requirement ▁ % s ▁ is ▁ % s ' , url_name , base , ) NEW_LINE return base NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def _get_pages ( self , locations , project_name ) : NEW_LINE INDENT """ STRNEWLINE ▁ Yields ▁ ( page , ▁ page _ url ) ▁ from ▁ the ▁ given ▁ locations , ▁ skipping STRNEWLINE ▁ locations ▁ that ▁ have ▁ errors , ▁ and ▁ adding ▁ download / homepage ▁ links STRNEWLINE ▁ """ NEW_LINE all_locations = list ( locations ) NEW_LINE seen = set ( ) NEW_LINE normalized = normalize_name ( project_name ) NEW_LINE while all_locations : NEW_LINE INDENT location = all_locations . pop ( 0 ) NEW_LINE if location in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . add ( location ) NEW_LINE page = self . _get_page ( location ) NEW_LINE if page is None : NEW_LINE INDENT continue NEW_LINE DEDENT yield page NEW_LINE for link in page . rel_links ( ) : NEW_LINE INDENT if ( normalized not in self . allow_external and not self . allow_all_external ) : NEW_LINE INDENT self . need_warn_external = True NEW_LINE logger . debug ( " Not ▁ searching ▁ % s ▁ for ▁ files ▁ because ▁ external ▁ " " urls ▁ are ▁ disallowed . " , link , ) NEW_LINE continue NEW_LINE DEDENT if ( link . trusted is not None and not link . trusted and normalized not in self . allow_unverified ) : NEW_LINE INDENT logger . debug ( " Not ▁ searching ▁ % s ▁ for ▁ urls , ▁ it ▁ is ▁ an ▁ " " untrusted ▁ link ▁ and ▁ cannot ▁ produce ▁ safe ▁ or ▁ " " verifiable ▁ files . " , link , ) NEW_LINE self . need_warn_unverified = True NEW_LINE continue NEW_LINE DEDENT all_locations . append ( link ) NEW_LINE DEDENT DEDENT DEDENT _py_version_re = re . compile ( r ' - py ( [123 ] \ . ? [ 0-9 ] ? ) $ ' ) NEW_LINE def _sort_links ( self , links ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ elements ▁ of ▁ links ▁ in ▁ order , ▁ non - egg ▁ links ▁ first , ▁ egg ▁ links STRNEWLINE ▁ second , ▁ while ▁ eliminating ▁ duplicates STRNEWLINE ▁ """ NEW_LINE eggs , no_eggs = [ ] , [ ] NEW_LINE seen = set ( ) NEW_LINE for link in links : NEW_LINE INDENT if link not in seen : NEW_LINE INDENT seen . add ( link ) NEW_LINE if link . egg_fragment : NEW_LINE INDENT eggs . append ( link ) NEW_LINE DEDENT else : NEW_LINE INDENT no_eggs . append ( link ) NEW_LINE DEDENT DEDENT DEDENT return no_eggs + eggs NEW_LINE DEDENT def _package_versions ( self , links , search ) : NEW_LINE INDENT result = [ ] NEW_LINE for link in self . _sort_links ( links ) : NEW_LINE INDENT v = self . _link_package_versions ( link , search ) NEW_LINE if v is not None : NEW_LINE INDENT result . append ( v ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def _log_skipped_link ( self , link , reason ) : NEW_LINE INDENT if link not in self . logged_links : NEW_LINE INDENT logger . debug ( ' Skipping ▁ link ▁ % s ; ▁ % s ' , link , reason ) NEW_LINE self . logged_links . add ( link ) NEW_LINE DEDENT DEDENT def _link_package_versions ( self , link , search ) : NEW_LINE INDENT """ Return ▁ an ▁ InstallationCandidate ▁ or ▁ None """ NEW_LINE platform = get_platform ( ) NEW_LINE version = None NEW_LINE if link . egg_fragment : NEW_LINE INDENT egg_info = link . egg_fragment NEW_LINE ext = link . ext NEW_LINE DEDENT else : NEW_LINE INDENT egg_info , ext = link . splitext ( ) NEW_LINE if not ext : NEW_LINE INDENT self . _log_skipped_link ( link , ' not ▁ a ▁ file ' ) NEW_LINE return NEW_LINE DEDENT if ext not in SUPPORTED_EXTENSIONS : NEW_LINE INDENT self . _log_skipped_link ( link , ' unsupported ▁ archive ▁ format : ▁ % s ' % ext ) NEW_LINE return NEW_LINE DEDENT if " binary " not in search . formats and ext == wheel_ext : NEW_LINE INDENT self . _log_skipped_link ( link , ' No ▁ binaries ▁ permitted ▁ for ▁ % s ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if " macosx10" in link . path and ext == ' . zip ' : NEW_LINE INDENT self . _log_skipped_link ( link , ' macosx10 ▁ one ' ) NEW_LINE return NEW_LINE DEDENT if ext == wheel_ext : NEW_LINE INDENT try : NEW_LINE INDENT wheel = Wheel ( link . filename ) NEW_LINE DEDENT except InvalidWheelFilename : NEW_LINE INDENT self . _log_skipped_link ( link , ' invalid ▁ wheel ▁ filename ' ) NEW_LINE return NEW_LINE DEDENT if ( pkg_resources . safe_name ( wheel . name ) . lower ( ) != search . canonical ) : NEW_LINE INDENT self . _log_skipped_link ( link , ' wrong ▁ project ▁ name ▁ ( not ▁ % s ) ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if not wheel . supported ( ) : NEW_LINE INDENT self . _log_skipped_link ( link , ' it ▁ is ▁ not ▁ compatible ▁ with ▁ this ▁ Python ' ) NEW_LINE return NEW_LINE # ▁ This ▁ is ▁ a ▁ dirty ▁ hack ▁ to ▁ prevent ▁ installing ▁ Binary ▁ Wheels ▁ from ENDCOM # ▁ PyPI ▁ unless ▁ it ▁ is ▁ a ▁ Windows ▁ or ▁ Mac ▁ Binary ▁ Wheel . ▁ This ▁ is ENDCOM # ▁ paired ▁ with ▁ a ▁ change ▁ to ▁ PyPI ▁ disabling ▁ uploads ▁ for ▁ the ENDCOM # ▁ same . ▁ Once ▁ we ▁ have ▁ a ▁ mechanism ▁ for ▁ enabling ▁ support ▁ for ENDCOM # ▁ binary ▁ wheels ▁ on ▁ linux ▁ that ▁ deals ▁ with ▁ the ▁ inherent ▁ problems ENDCOM # ▁ of ▁ binary ▁ distribution ▁ this ▁ can ▁ be ▁ removed . ENDCOM DEDENT comes_from = getattr ( link , " comes _ from " , None ) NEW_LINE if ( ( not platform . startswith ( ' win ' ) and not platform . startswith ( ' macosx ' ) and not platform == ' cli ' ) and comes_from is not None and urllib_parse . urlparse ( comes_from . url ) . netloc . endswith ( PyPI . netloc ) ) : NEW_LINE INDENT if not wheel . supported ( tags = supported_tags_noarch ) : NEW_LINE INDENT self . _log_skipped_link ( link , " it ▁ is ▁ a ▁ pypi - hosted ▁ binary ▁ " " Wheel ▁ on ▁ an ▁ unsupported ▁ platform " , ) NEW_LINE return NEW_LINE DEDENT DEDENT version = wheel . version NEW_LINE # ▁ This ▁ should ▁ be ▁ up ▁ by ▁ the ▁ search . ok _ binary ▁ check , ▁ but ▁ see ▁ issue ▁ 2700 . ENDCOM DEDENT DEDENT if " source " not in search . formats and ext != wheel_ext : NEW_LINE INDENT self . _log_skipped_link ( link , ' No ▁ sources ▁ permitted ▁ for ▁ % s ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if not version : NEW_LINE INDENT version = egg_info_matches ( egg_info , search . supplied , link ) NEW_LINE DEDENT if version is None : NEW_LINE INDENT self . _log_skipped_link ( link , ' wrong ▁ project ▁ name ▁ ( not ▁ % s ) ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if ( link . internal is not None and not link . internal and not normalize_name ( search . supplied ) . lower ( ) in self . allow_external and not self . allow_all_external ) : NEW_LINE # ▁ We ▁ have ▁ a ▁ link ▁ that ▁ we ▁ are ▁ sure ▁ is ▁ external , ▁ so ▁ we ▁ should ▁ skip ENDCOM # ▁ it ▁ unless ▁ we ▁ are ▁ allowing ▁ externals ENDCOM INDENT self . _log_skipped_link ( link , ' it ▁ is ▁ externally ▁ hosted ' ) NEW_LINE self . need_warn_external = True NEW_LINE return NEW_LINE DEDENT if ( link . verifiable is not None and not link . verifiable and not ( normalize_name ( search . supplied ) . lower ( ) in self . allow_unverified ) ) : NEW_LINE # ▁ We ▁ have ▁ a ▁ link ▁ that ▁ we ▁ are ▁ sure ▁ we ▁ cannot ▁ verify ▁ its ▁ integrity , ENDCOM # ▁ so ▁ we ▁ should ▁ skip ▁ it ▁ unless ▁ we ▁ are ▁ allowing ▁ unsafe ▁ installs ENDCOM # ▁ for ▁ this ▁ requirement . ENDCOM INDENT self . _log_skipped_link ( link , ' it ▁ is ▁ an ▁ insecure ▁ and ▁ unverifiable ▁ file ' ) NEW_LINE self . need_warn_unverified = True NEW_LINE return NEW_LINE DEDENT match = self . _py_version_re . search ( version ) NEW_LINE if match : NEW_LINE INDENT version = version [ : match . start ( ) ] NEW_LINE py_version = match . group ( 1 ) NEW_LINE if py_version != sys . version [ : 3 ] : NEW_LINE INDENT self . _log_skipped_link ( link , ' Python ▁ version ▁ is ▁ incorrect ' ) NEW_LINE return NEW_LINE DEDENT DEDENT logger . debug ( ' Found ▁ link ▁ % s , ▁ version : ▁ % s ' , link , version ) NEW_LINE return InstallationCandidate ( search . supplied , version , link ) NEW_LINE DEDENT def _get_page ( self , link ) : NEW_LINE INDENT return HTMLPage . get_page ( link , session = self . session ) NEW_LINE DEDENT DEDENT def egg_info_matches ( egg_info , search_name , link , _egg_info_re = re . compile ( r ' ( [ a - z0-9 _ . ] + ) - ( [ a - z0-9 _ . ! + - ] + ) ' , re . I ) ) : NEW_LINE INDENT """ Pull ▁ the ▁ version ▁ part ▁ out ▁ of ▁ a ▁ string . STRNEWLINE STRNEWLINE ▁ : param ▁ egg _ info : ▁ The ▁ string ▁ to ▁ parse . ▁ E . g . ▁ foo - 2.1 STRNEWLINE ▁ : param ▁ search _ name : ▁ The ▁ name ▁ of ▁ the ▁ package ▁ this ▁ belongs ▁ to . ▁ None ▁ to STRNEWLINE ▁ infer ▁ the ▁ name . ▁ Note ▁ that ▁ this ▁ cannot ▁ unambiguously ▁ parse ▁ strings STRNEWLINE ▁ like ▁ foo - 2-2 ▁ which ▁ might ▁ be ▁ foo , ▁ 2-2 ▁ or ▁ foo - 2 , ▁ 2 . STRNEWLINE ▁ : param ▁ link : ▁ The ▁ link ▁ the ▁ string ▁ came ▁ from , ▁ for ▁ logging ▁ on ▁ failure . STRNEWLINE ▁ """ NEW_LINE match = _egg_info_re . search ( egg_info ) NEW_LINE if not match : NEW_LINE INDENT logger . debug ( ' Could ▁ not ▁ parse ▁ version ▁ from ▁ link : ▁ % s ' , link ) NEW_LINE return None NEW_LINE DEDENT if search_name is None : NEW_LINE INDENT full_match = match . group ( 0 ) NEW_LINE return full_match [ full_match . index ( ' - ' ) : ] NEW_LINE DEDENT name = match . group ( 0 ) . lower ( ) NEW_LINE # ▁ To ▁ match ▁ the ▁ " safe " ▁ name ▁ that ▁ pkg _ resources ▁ creates : ENDCOM name = name . replace ( ' _ ' , ' - ' ) NEW_LINE # ▁ project ▁ name ▁ and ▁ version ▁ must ▁ be ▁ separated ▁ by ▁ a ▁ dash ENDCOM look_for = search_name . lower ( ) + " - " NEW_LINE if name . startswith ( look_for ) : NEW_LINE INDENT return match . group ( 0 ) [ len ( look_for ) : ] NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT class HTMLPage ( object ) : NEW_LINE INDENT """ Represents ▁ one ▁ page , ▁ along ▁ with ▁ its ▁ URL """ NEW_LINE def __init__ ( self , content , url , headers = None , trusted = None ) : NEW_LINE # ▁ Determine ▁ if ▁ we ▁ have ▁ any ▁ encoding ▁ information ▁ in ▁ our ▁ headers ENDCOM INDENT encoding = None NEW_LINE if headers and " Content - Type " in headers : NEW_LINE INDENT content_type , params = cgi . parse_header ( headers [ " Content - Type " ] ) NEW_LINE if " charset " in params : NEW_LINE INDENT encoding = params [ ' charset ' ] NEW_LINE DEDENT DEDENT self . content = content NEW_LINE self . parsed = html5lib . parse ( self . content , encoding = encoding , namespaceHTMLElements = False , ) NEW_LINE self . url = url NEW_LINE self . headers = headers NEW_LINE self . trusted = trusted NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return self . url NEW_LINE DEDENT @ classmethod NEW_LINE def get_page ( cls , link , skip_archives = True , session = None ) : NEW_LINE INDENT if session is None : NEW_LINE INDENT raise TypeError ( " get _ page ( ) ▁ missing ▁ 1 ▁ required ▁ keyword ▁ argument : ▁ ' session ' " ) NEW_LINE DEDENT url = link . url NEW_LINE url = url . split ( ' # ' , 1 ) [ 0 ] NEW_LINE # ▁ Check ▁ for ▁ VCS ▁ schemes ▁ that ▁ do ▁ not ▁ support ▁ lookup ▁ as ▁ web ▁ pages . ENDCOM from pip . vcs import VcsSupport NEW_LINE for scheme in VcsSupport . schemes : NEW_LINE INDENT if url . lower ( ) . startswith ( scheme ) and url [ len ( scheme ) ] in ' + : ' : NEW_LINE INDENT logger . debug ( ' Cannot ▁ look ▁ at ▁ % s ▁ URL ▁ % s ' , scheme , link ) NEW_LINE return None NEW_LINE DEDENT DEDENT try : NEW_LINE INDENT if skip_archives : NEW_LINE INDENT filename = link . filename NEW_LINE for bad_ext in ARCHIVE_EXTENSIONS : NEW_LINE INDENT if filename . endswith ( bad_ext ) : NEW_LINE INDENT content_type = cls . _get_content_type ( url , session = session , ) NEW_LINE if content_type . lower ( ) . startswith ( ' text / html ' ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT logger . debug ( ' Skipping ▁ page ▁ % s ▁ because ▁ of ▁ Content - Type : ▁ % s ' , link , content_type , ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT logger . debug ( ' Getting ▁ page ▁ % s ' , url ) NEW_LINE # ▁ Tack ▁ index . html ▁ onto ▁ file : / / ▁ URLs ▁ that ▁ point ▁ to ▁ directories ENDCOM ( scheme , netloc , path , params , query , fragment ) = urllib_parse . urlparse ( url ) NEW_LINE if ( scheme == ' file ' and os . path . isdir ( urllib_request . url2pathname ( path ) ) ) : NEW_LINE # ▁ add ▁ trailing ▁ slash ▁ if ▁ not ▁ present ▁ so ▁ urljoin ▁ doesn ' t ▁ trim ENDCOM # ▁ final ▁ segment ENDCOM INDENT if not url . endswith ( ' / ' ) : NEW_LINE INDENT url += ' / ' NEW_LINE DEDENT url = urllib_parse . urljoin ( url , ' index . html ' ) NEW_LINE logger . debug ( ' ▁ file : ▁ URL ▁ is ▁ directory , ▁ getting ▁ % s ' , url ) NEW_LINE DEDENT resp = session . get ( url , headers = { " Accept " : " text / html " , " Cache - Control " : " max - age = 600" , } , ) NEW_LINE resp . raise_for_status ( ) NEW_LINE # ▁ The ▁ check ▁ for ▁ archives ▁ above ▁ only ▁ works ▁ if ▁ the ▁ url ▁ ends ▁ with ENDCOM # ▁ something ▁ that ▁ looks ▁ like ▁ an ▁ archive . ▁ However ▁ that ▁ is ▁ not ▁ a ENDCOM # ▁ requirement ▁ of ▁ an ▁ url . ▁ Unless ▁ we ▁ issue ▁ a ▁ HEAD ▁ request ▁ on ▁ every ENDCOM # ▁ url ▁ we ▁ cannot ▁ know ▁ ahead ▁ of ▁ time ▁ for ▁ sure ▁ if ▁ something ▁ is ▁ HTML ENDCOM # ▁ or ▁ not . ▁ However ▁ we ▁ can ▁ check ▁ after ▁ we ' ve ▁ downloaded ▁ it . ENDCOM content_type = resp . headers . get ( ' Content - Type ' , ' unknown ' ) NEW_LINE if not content_type . lower ( ) . startswith ( " text / html " ) : NEW_LINE INDENT logger . debug ( ' Skipping ▁ page ▁ % s ▁ because ▁ of ▁ Content - Type : ▁ % s ' , link , content_type , ) NEW_LINE return NEW_LINE DEDENT inst = cls ( resp . content , resp . url , resp . headers , trusted = link . trusted , ) NEW_LINE DEDENT except requests . HTTPError as exc : NEW_LINE INDENT level = 2 if exc . response . status_code == 404 else 1 NEW_LINE cls . _handle_fail ( link , exc , url , level = level ) NEW_LINE DEDENT except requests . ConnectionError as exc : NEW_LINE INDENT cls . _handle_fail ( link , " connection ▁ error : ▁ % s " % exc , url ) NEW_LINE DEDENT except requests . Timeout : NEW_LINE INDENT cls . _handle_fail ( link , " timed ▁ out " , url ) NEW_LINE DEDENT except SSLError as exc : NEW_LINE INDENT reason = ( " There ▁ was ▁ a ▁ problem ▁ confirming ▁ the ▁ ssl ▁ certificate : ▁ " " % s " % exc ) NEW_LINE cls . _handle_fail ( link , reason , url , level = 2 , meth = logger . info ) NEW_LINE DEDENT else : NEW_LINE INDENT return inst NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def _handle_fail ( link , reason , url , level = 1 , meth = None ) : NEW_LINE INDENT if meth is None : NEW_LINE INDENT meth = logger . debug NEW_LINE DEDENT meth ( " Could ▁ not ▁ fetch ▁ URL ▁ % s : ▁ % s ▁ - ▁ skipping " , link , reason ) NEW_LINE DEDENT @ staticmethod NEW_LINE def _get_content_type ( url , session ) : NEW_LINE INDENT """ Get ▁ the ▁ Content - Type ▁ of ▁ the ▁ given ▁ url , ▁ using ▁ a ▁ HEAD ▁ request """ NEW_LINE scheme , netloc , path , query , fragment = urllib_parse . urlsplit ( url ) NEW_LINE if scheme not in ( ' http ' , ' https ' ) : NEW_LINE # ▁ FIXME : ▁ some ▁ warning ▁ or ▁ something ? ENDCOM # ▁ assertion ▁ error ? ENDCOM INDENT return ' ' NEW_LINE DEDENT resp = session . head ( url , allow_redirects = True ) NEW_LINE resp . raise_for_status ( ) NEW_LINE return resp . headers . get ( " Content - Type " , " " ) NEW_LINE DEDENT @ cached_property NEW_LINE def api_version ( self ) : NEW_LINE INDENT metas = [ x for x in self . parsed . findall ( " . / / meta " ) if x . get ( " name " , " " ) . lower ( ) == " api - version " ] NEW_LINE if metas : NEW_LINE INDENT try : NEW_LINE INDENT return int ( metas [ 0 ] . get ( " value " , None ) ) NEW_LINE DEDENT except ( TypeError , ValueError ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT @ cached_property NEW_LINE def base_url ( self ) : NEW_LINE INDENT bases = [ x for x in self . parsed . findall ( " . / / base " ) if x . get ( " href " ) is not None ] NEW_LINE if bases and bases [ 0 ] . get ( " href " ) : NEW_LINE INDENT return bases [ 0 ] . get ( " href " ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . url NEW_LINE DEDENT DEDENT @ property NEW_LINE def links ( self ) : NEW_LINE INDENT """ Yields ▁ all ▁ links ▁ in ▁ the ▁ page """ NEW_LINE for anchor in self . parsed . findall ( " . / / a " ) : NEW_LINE INDENT if anchor . get ( " href " ) : NEW_LINE INDENT href = anchor . get ( " href " ) NEW_LINE url = self . clean_link ( urllib_parse . urljoin ( self . base_url , href ) ) NEW_LINE # ▁ Determine ▁ if ▁ this ▁ link ▁ is ▁ internal . ▁ If ▁ that ▁ distinction ENDCOM # ▁ doesn ' t ▁ make ▁ sense ▁ in ▁ this ▁ context , ▁ then ▁ we ▁ don ' t ▁ make ENDCOM # ▁ any ▁ distinction . ENDCOM internal = None NEW_LINE if self . api_version and self . api_version >= 2 : NEW_LINE # ▁ Only ▁ api _ versions ▁ > = ▁ 2 ▁ have ▁ a ▁ distinction ▁ between ENDCOM # ▁ external ▁ and ▁ internal ▁ links ENDCOM INDENT internal = bool ( anchor . get ( " rel " ) and " internal " in anchor . get ( " rel " ) . split ( ) ) NEW_LINE DEDENT yield Link ( url , self , internal = internal ) NEW_LINE DEDENT DEDENT DEDENT def rel_links ( self , rels = ( ' homepage ' , ' download ' ) ) : NEW_LINE INDENT """ Yields ▁ all ▁ links ▁ with ▁ the ▁ given ▁ relations """ NEW_LINE rels = set ( rels ) NEW_LINE for anchor in self . parsed . findall ( " . / / a " ) : NEW_LINE INDENT if anchor . get ( " rel " ) and anchor . get ( " href " ) : NEW_LINE INDENT found_rels = set ( anchor . get ( " rel " ) . split ( ) ) NEW_LINE # ▁ Determine ▁ the ▁ intersection ▁ between ▁ what ▁ rels ▁ were ▁ found ▁ and ENDCOM # ▁ what ▁ rels ▁ were ▁ being ▁ looked ▁ for ENDCOM if found_rels & rels : NEW_LINE INDENT href = anchor . get ( " href " ) NEW_LINE url = self . clean_link ( urllib_parse . urljoin ( self . base_url , href ) ) NEW_LINE yield Link ( url , self , trusted = False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT _clean_re = re . compile ( r ' [ ^ a - z0-9 $ & + , / : ; = ? @ . # % _ \\ | - ] ' , re . I ) NEW_LINE def clean_link ( self , url ) : NEW_LINE INDENT """ Makes ▁ sure ▁ a ▁ link ▁ is ▁ fully ▁ encoded . ▁ That ▁ is , ▁ if ▁ a ▁ ' ▁ ' ▁ shows ▁ up ▁ in STRNEWLINE ▁ the ▁ link , ▁ it ▁ will ▁ be ▁ rewritten ▁ to ▁ % 20 ▁ ( while ▁ not ▁ over - quoting STRNEWLINE ▁ % ▁ or ▁ other ▁ characters ) . """ NEW_LINE return self . _clean_re . sub ( lambda match : ' % % % 2x ' % ord ( match . group ( 0 ) ) , url ) NEW_LINE DEDENT DEDENT class Link ( object ) : NEW_LINE INDENT def __init__ ( self , url , comes_from = None , internal = None , trusted = None ) : NEW_LINE # ▁ url ▁ can ▁ be ▁ a ▁ UNC ▁ windows ▁ share ENDCOM INDENT if url != Inf and url . startswith ( ' \\\\ ' ) : NEW_LINE INDENT url = path_to_url ( url ) NEW_LINE DEDENT self . url = url NEW_LINE self . comes_from = comes_from NEW_LINE self . internal = internal NEW_LINE self . trusted = trusted NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT if self . comes_from : NEW_LINE INDENT return ' % s ▁ ( from ▁ % s ) ' % ( self . url , self . comes_from ) NEW_LINE DEDENT else : NEW_LINE INDENT return str ( self . url ) NEW_LINE DEDENT DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' < Link ▁ % s > ' % self NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url == other . url NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url != other . url NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url < other . url NEW_LINE DEDENT def __le__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url <= other . url NEW_LINE DEDENT def __gt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url > other . url NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url >= other . url NEW_LINE DEDENT def __hash__ ( self ) : NEW_LINE INDENT return hash ( self . url ) NEW_LINE DEDENT @ property NEW_LINE def filename ( self ) : NEW_LINE INDENT _ , netloc , path , _ , _ = urllib_parse . urlsplit ( self . url ) NEW_LINE name = posixpath . basename ( path . rstrip ( ' / ' ) ) or netloc NEW_LINE name = urllib_parse . unquote ( name ) NEW_LINE assert name , ( ' URL ▁ % r ▁ produced ▁ no ▁ filename ' % self . url ) NEW_LINE return name NEW_LINE DEDENT @ property NEW_LINE def scheme ( self ) : NEW_LINE INDENT return urllib_parse . urlsplit ( self . url ) [ 0 ] NEW_LINE DEDENT @ property NEW_LINE def netloc ( self ) : NEW_LINE INDENT return urllib_parse . urlsplit ( self . url ) [ 1 ] NEW_LINE DEDENT @ property NEW_LINE def path ( self ) : NEW_LINE INDENT return urllib_parse . unquote ( urllib_parse . urlsplit ( self . url ) [ 2 ] ) NEW_LINE DEDENT def splitext ( self ) : NEW_LINE INDENT return splitext ( posixpath . basename ( self . path . rstrip ( ' / ' ) ) ) NEW_LINE DEDENT @ property NEW_LINE def ext ( self ) : NEW_LINE INDENT return self . splitext ( ) [ 1 ] NEW_LINE DEDENT @ property NEW_LINE def url_without_fragment ( self ) : NEW_LINE INDENT scheme , netloc , path , query , fragment = urllib_parse . urlsplit ( self . url ) NEW_LINE return urllib_parse . urlunsplit ( ( scheme , netloc , path , query , None ) ) NEW_LINE DEDENT _egg_fragment_re = re . compile ( r ' # egg = ( [ ^ & ] * ) ' ) NEW_LINE @ property NEW_LINE def egg_fragment ( self ) : NEW_LINE INDENT match = self . _egg_fragment_re . search ( self . url ) NEW_LINE if not match : NEW_LINE INDENT return None NEW_LINE DEDENT return match . group ( 1 ) NEW_LINE DEDENT _hash_re = re . compile ( r ' ( sha1 | sha224 | sha384 | sha256 | sha512 | md5 ) = ( [ a - f0-9 ] + ) ' ) NEW_LINE @ property NEW_LINE def hash ( self ) : NEW_LINE INDENT match = self . _hash_re . search ( self . url ) NEW_LINE if match : NEW_LINE INDENT return match . group ( 2 ) NEW_LINE DEDENT return None NEW_LINE DEDENT @ property NEW_LINE def hash_name ( self ) : NEW_LINE INDENT match = self . _hash_re . search ( self . url ) NEW_LINE if match : NEW_LINE INDENT return match . group ( 1 ) NEW_LINE DEDENT return None NEW_LINE DEDENT @ property NEW_LINE def show_url ( self ) : NEW_LINE INDENT return posixpath . basename ( self . url . split ( ' # ' , 1 ) [ 0 ] . split ( ' ? ' , 1 ) [ 0 ] ) NEW_LINE DEDENT @ property NEW_LINE def verifiable ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ True ▁ if ▁ this ▁ link ▁ can ▁ be ▁ verified ▁ after ▁ download , ▁ False ▁ if ▁ it STRNEWLINE ▁ cannot , ▁ and ▁ None ▁ if ▁ we ▁ cannot ▁ determine . STRNEWLINE ▁ """ NEW_LINE trusted = self . trusted or getattr ( self . comes_from , " trusted " , None ) NEW_LINE if trusted is not None and trusted : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ a ▁ trusted ▁ source . ▁ It ▁ * may * ▁ be ▁ verifiable ▁ but ENDCOM # ▁ first ▁ we ▁ need ▁ to ▁ see ▁ if ▁ this ▁ page ▁ is ▁ operating ▁ under ▁ the ▁ new ENDCOM # ▁ API ▁ version . ENDCOM INDENT try : NEW_LINE INDENT api_version = getattr ( self . comes_from , " api _ version " , None ) NEW_LINE api_version = int ( api_version ) NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT api_version = None NEW_LINE DEDENT if api_version is None or api_version <= 1 : NEW_LINE # ▁ This ▁ link ▁ is ▁ either ▁ trusted , ▁ or ▁ it ▁ came ▁ from ▁ a ▁ trusted , ENDCOM # ▁ however ▁ it ▁ is ▁ not ▁ operating ▁ under ▁ the ▁ API ▁ version ▁ 2 ▁ so ENDCOM # ▁ we ▁ can ' t ▁ make ▁ any ▁ claims ▁ about ▁ if ▁ it ' s ▁ safe ▁ or ▁ not ENDCOM INDENT return NEW_LINE DEDENT if self . hash : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ a ▁ trusted ▁ source ▁ and ▁ it ▁ has ▁ a ▁ hash , ▁ so ▁ we ENDCOM # ▁ can ▁ consider ▁ it ▁ safe . ENDCOM INDENT return True NEW_LINE DEDENT else : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ a ▁ trusted ▁ source , ▁ using ▁ the ▁ new ▁ API ENDCOM # ▁ version , ▁ and ▁ it ▁ does ▁ not ▁ have ▁ a ▁ hash . ▁ It ▁ is ▁ NOT ▁ verifiable ENDCOM INDENT return False NEW_LINE DEDENT DEDENT elif trusted is not None : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ an ▁ untrusted ▁ source ▁ and ▁ we ▁ cannot ▁ trust ▁ it ENDCOM INDENT return False NEW_LINE DEDENT DEDENT @ property NEW_LINE def is_wheel ( self ) : NEW_LINE INDENT return self . ext == wheel_ext NEW_LINE DEDENT @ property NEW_LINE def is_artifact ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Determines ▁ if ▁ this ▁ points ▁ to ▁ an ▁ actual ▁ artifact ▁ ( e . g . ▁ a ▁ tarball ) ▁ or ▁ if STRNEWLINE ▁ it ▁ points ▁ to ▁ an ▁ " abstract " ▁ thing ▁ like ▁ a ▁ path ▁ or ▁ a ▁ VCS ▁ location . STRNEWLINE ▁ """ NEW_LINE from pip . vcs import vcs NEW_LINE if self . scheme in vcs . all_schemes : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE # ▁ An ▁ object ▁ to ▁ represent ▁ the ▁ " link " ▁ for ▁ the ▁ installed ▁ version ▁ of ▁ a ▁ requirement . ENDCOM # ▁ Using ▁ Inf ▁ as ▁ the ▁ url ▁ makes ▁ it ▁ sort ▁ higher . ENDCOM DEDENT DEDENT INSTALLED_VERSION = Link ( Inf ) NEW_LINE FormatControl = namedtuple ( ' FormatControl ' , ' no _ binary ▁ only _ binary ' ) NEW_LINE """ This ▁ object ▁ has ▁ two ▁ fields , ▁ no _ binary ▁ and ▁ only _ binary . STRNEWLINE STRNEWLINE If ▁ a ▁ field ▁ is ▁ falsy , ▁ it ▁ isn ' t ▁ set . ▁ If ▁ it ▁ is ▁ { ' : all : ' } , ▁ it ▁ should ▁ match ▁ all STRNEWLINE packages ▁ except ▁ those ▁ listed ▁ in ▁ the ▁ other ▁ field . ▁ Only ▁ one ▁ field ▁ can ▁ be ▁ set STRNEWLINE to ▁ { ' : all : ' } ▁ at ▁ a ▁ time . ▁ The ▁ rest ▁ of ▁ the ▁ time ▁ exact ▁ package ▁ name ▁ matches STRNEWLINE are ▁ listed , ▁ with ▁ any ▁ given ▁ package ▁ only ▁ showing ▁ up ▁ in ▁ one ▁ field ▁ at ▁ a ▁ time . STRNEWLINE """ NEW_LINE def fmt_ctl_handle_mutual_exclude ( value , target , other ) : NEW_LINE INDENT new = value . split ( ' , ' ) NEW_LINE while ' : all : ' in new : NEW_LINE INDENT other . clear ( ) NEW_LINE target . clear ( ) NEW_LINE target . add ( ' : all : ' ) NEW_LINE del new [ : new . index ( ' : all : ' ) + 1 ] NEW_LINE if ' : none : ' not in new : NEW_LINE # ▁ Without ▁ a ▁ none , ▁ we ▁ want ▁ to ▁ discard ▁ everything ▁ as ▁ : all : ▁ covers ▁ it ENDCOM INDENT return NEW_LINE DEDENT DEDENT for name in new : NEW_LINE INDENT if name == ' : none : ' : NEW_LINE INDENT target . clear ( ) NEW_LINE continue NEW_LINE DEDENT name = pkg_resources . safe_name ( name ) . lower ( ) NEW_LINE other . discard ( name ) NEW_LINE target . add ( name ) NEW_LINE DEDENT DEDENT def fmt_ctl_formats ( fmt_ctl , canonical_name ) : NEW_LINE INDENT result = set ( [ " binary " , " source " ] ) NEW_LINE if canonical_name in fmt_ctl . only_binary : NEW_LINE INDENT result . discard ( ' source ' ) NEW_LINE DEDENT elif canonical_name in fmt_ctl . no_binary : NEW_LINE INDENT result . discard ( ' binary ' ) NEW_LINE DEDENT elif ' : all : ' in fmt_ctl . only_binary : NEW_LINE INDENT result . discard ( ' source ' ) NEW_LINE DEDENT elif ' : all : ' in fmt_ctl . no_binary : NEW_LINE INDENT result . discard ( ' binary ' ) NEW_LINE DEDENT return frozenset ( result ) NEW_LINE DEDENT def fmt_ctl_no_binary ( fmt_ctl ) : NEW_LINE INDENT fmt_ctl_handle_mutual_exclude ( ' : all : ' , fmt_ctl . no_binary , fmt_ctl . only_binary ) NEW_LINE DEDENT def fmt_ctl_no_use_wheel ( fmt_ctl ) : NEW_LINE INDENT fmt_ctl_no_binary ( fmt_ctl ) NEW_LINE warnings . warn ( ' - - no - use - wheel ▁ is ▁ deprecated ▁ and ▁ will ▁ be ▁ removed ▁ in ▁ the ▁ future . ▁ ' ' ▁ Please ▁ use ▁ - - no - binary ▁ : all : ▁ instead . ' , DeprecationWarning , stacklevel = 2 ) NEW_LINE DEDENT Search = namedtuple ( ' Search ' , ' supplied ▁ canonical ▁ formats ' ) NEW_LINE """ Capture ▁ key ▁ aspects ▁ of ▁ a ▁ search . STRNEWLINE STRNEWLINE : attribute ▁ supplied : ▁ The ▁ user ▁ supplied ▁ package . STRNEWLINE : attribute ▁ canonical : ▁ The ▁ canonical ▁ package ▁ name . STRNEWLINE : attribute ▁ formats : ▁ The ▁ formats ▁ allowed ▁ for ▁ this ▁ package . ▁ Should ▁ be ▁ a ▁ set STRNEWLINE ▁ with ▁ ' binary ' ▁ or ▁ ' source ' ▁ or ▁ both ▁ in ▁ it . STRNEWLINE """ NEW_LINE </DOCUMENT>
<DOCUMENT_ID="nikolay-fedotov/tempest/tree/master/tempest/api/object_storage/test_account_services_negative.py"> # ▁ Copyright ▁ ( C ) ▁ 2013 ▁ eNovance ▁ SAS ▁ < licensing @ enovance . com > ENDCOM # ▁ Author : ▁ Joe ▁ H . ▁ Rahme ▁ < joe . hakim . rahme @ enovance . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ENDCOM # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ENDCOM # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ENDCOM # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ENDCOM # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM # ▁ under ▁ the ▁ License . ENDCOM from tempest . api . object_storage import base NEW_LINE from tempest import clients NEW_LINE from tempest import exceptions NEW_LINE from tempest import test NEW_LINE class AccountNegativeTest ( base . BaseObjectTest ) : NEW_LINE INDENT @ test . attr ( type = [ ' negative ' , ' gate ' ] ) NEW_LINE def test_list_containers_with_non_authorized_user ( self ) : NEW_LINE # ▁ list ▁ containers ▁ using ▁ non - authorized ▁ user ENDCOM # ▁ create ▁ user ENDCOM INDENT self . data . setup_test_user ( ) NEW_LINE test_os = clients . Manager ( self . data . test_credentials ) NEW_LINE test_auth_provider = test_os . auth_provider NEW_LINE # ▁ Get ▁ auth ▁ for ▁ the ▁ test ▁ user ENDCOM test_auth_provider . auth_data NEW_LINE # ▁ Get ▁ fresh ▁ auth ▁ for ▁ test ▁ user ▁ and ▁ set ▁ it ▁ to ▁ next ▁ auth ▁ request ▁ for ENDCOM # ▁ custom _ account _ client ENDCOM delattr ( test_auth_provider , ' auth _ data ' ) NEW_LINE test_auth_new_data = test_auth_provider . auth_data NEW_LINE self . custom_account_client . auth_provider . set_alt_auth_data ( request_part = ' headers ' , auth_data = test_auth_new_data ) NEW_LINE params = { ' format ' : ' json ' } NEW_LINE # ▁ list ▁ containers ▁ with ▁ non - authorized ▁ user ▁ token ENDCOM self . assertRaises ( exceptions . Unauthorized , self . custom_account_client . list_account_containers , params = params ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="xxxIsaacPeralxxx/anim-studio-tools/tree/master/kip/houdini/code/kip_houdini/convert.py"> # ▁ Dr . ▁ D ▁ Studios ▁ - ▁ Software ▁ Disclaimer ENDCOM # ▁ Copyright ▁ 2009 ▁ Dr ▁ D ▁ Studios ▁ Pty ▁ Limited ▁ ( ACN ▁ 127 ▁ 184 ▁ 954 ) ▁ ( Dr . ▁ D ▁ Studios ) , ▁ its ENDCOM # ▁ affiliates ▁ and / or ▁ its ▁ licensors . ENDCOM """ STRNEWLINE This ▁ module ▁ will ▁ help ▁ TD ' s ▁ to ▁ convert ▁ houdini ▁ animation ▁ curve ▁ to ▁ nuke ▁ or ▁ maya STRNEWLINE the ▁ other ▁ way ▁ around ▁ also . STRNEWLINE STRNEWLINE . . ▁ note : : STRNEWLINE STRNEWLINE ▁ Please ▁ make ▁ sure ▁ you ▁ are ▁ running ▁ in ▁ proper ▁ kipHoudini ▁ environment STRNEWLINE STRNEWLINE . . ▁ warning : : STRNEWLINE STRNEWLINE ▁ Dont ▁ import ▁ this ▁ module ▁ as ▁ standalone ▁ , ▁ use ▁ this ▁ module ▁ with ▁ kip ▁ project STRNEWLINE STRNEWLINE """ NEW_LINE __authors__ = [ " kurian . os " ] NEW_LINE __version__ = " $ Revision : ▁ 104961 ▁ $ " . split ( ) [ 1 ] NEW_LINE __revision__ = __version__ NEW_LINE __date__ = " $ Date : ▁ ▁ July ▁ 19 , ▁ 2011 ▁ 12:00:00 ▁ PM $ " . split ( ) [ 1 ] NEW_LINE __copyright__ = "2011" NEW_LINE __license__ = " Copyright ▁ 2011 ▁ Dr ▁ D ▁ Studios ▁ Pty ▁ Limited " NEW_LINE __contact__ = " kurian . os @ drdstudios . com " NEW_LINE __status__ = " Development " NEW_LINE import os NEW_LINE import traceback NEW_LINE # import ▁ hou ENDCOM import napalm . core as nap_core NEW_LINE import node_curves as node_curves NEW_LINE import kip . kip_reader as kip_reader NEW_LINE reload ( node_curves ) NEW_LINE reload ( kip_reader ) NEW_LINE from rodin import logging NEW_LINE from kip . kip_curve_class import * NEW_LINE from kip . kip_napalm_class import * NEW_LINE from kip . utils . kipError import * NEW_LINE from kip . template import * NEW_LINE rodin_logger = logging . get_logger ( ' kipHoudini ' ) NEW_LINE napalm_func = Napalm ( ) NEW_LINE GLOBAL_FPS = 24 NEW_LINE GLOBAL_TIME = 1 NEW_LINE class HoudiniWriter ( object ) : NEW_LINE INDENT """ STRNEWLINE ▁ Creating ▁ houdini ▁ curve ▁ writer ▁ class STRNEWLINE STRNEWLINE ▁ * Parents : * STRNEWLINE STRNEWLINE ▁ None STRNEWLINE STRNEWLINE ▁ * Children : * STRNEWLINE STRNEWLINE ▁ * ▁ : func : ` writeOutCurves ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def __init__ ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Base ▁ init ▁ function ▁ for ▁ houdini ▁ convert . write ▁ Class . STRNEWLINE ▁ """ NEW_LINE rodin_logger . info ( " kip ▁ houdini ▁ writing ▁ class ▁ initialized " ) NEW_LINE self . houdini_version = " houdini , % s " % hou . applicationVersionString ( ) NEW_LINE self . kip_houdini_version = " kipHoudini % s " % os . getenv ( " DRD _ KIPHOUDINI _ VERSION " ) NEW_LINE DEDENT def writeOutCurves ( self , nap_file_name = None , houdini_nodes = [ ] , houdini_node_attributes = [ ] , start_frame = None , end_frame = None , write_xml = False , silent = False , left_eyes = [ ] , right_eyes = [ ] , map_file_name = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ function ▁ will ▁ create ▁ a ▁ curve ▁ class ▁ object ▁ first ▁ and ▁ then ▁ it ▁ will ▁ write ▁ out ▁ the ▁ napalm ▁ file . STRNEWLINE STRNEWLINE ▁ . . ▁ warning : : STRNEWLINE STRNEWLINE ▁ If ▁ you ▁ are ▁ unable ▁ to ▁ write ▁ out ▁ napalm ▁ file ▁ or ▁ write _ status = False ▁ that ▁ means ▁ napalm ▁ failed ▁ to ▁ write ▁ out . STRNEWLINE STRNEWLINE ▁ : param ▁ nap _ file _ name : ▁ User ▁ must ▁ pass ▁ a ▁ file ▁ where ▁ he ▁ want ▁ to ▁ write ▁ out ▁ curves ▁ and ▁ make ▁ sure ▁ you ▁ supply ▁ a ▁ . nap ▁ or ▁ . xml ▁ file ▁ format ( strict ) STRNEWLINE STRNEWLINE ▁ : type ▁ nap _ file _ name : ▁ string STRNEWLINE STRNEWLINE ▁ : param ▁ houdini _ nodes : ▁ list ▁ of ▁ houdini ▁ objects ( strict ) STRNEWLINE STRNEWLINE ▁ : type ▁ houdini _ nodes : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ houdini _ node _ attribute : ▁ if ▁ you ▁ want ▁ to ▁ replace ▁ attribute ▁ from ▁ the ▁ map ▁ file ▁ then ▁ you ▁ can ▁ specify ▁ the ▁ override ▁ attribute ▁ here STRNEWLINE STRNEWLINE ▁ : type ▁ houdini _ node _ attribute : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ start _ frame : ▁ start ▁ frame ▁ to ▁ capture STRNEWLINE STRNEWLINE ▁ : type ▁ start _ frame : ▁ int STRNEWLINE STRNEWLINE ▁ : param ▁ end _ frame : ▁ end ▁ frame ▁ to ▁ capture STRNEWLINE STRNEWLINE ▁ : type ▁ end _ frame : ▁ int STRNEWLINE STRNEWLINE ▁ : param ▁ write _ xml : ▁ If ▁ you ▁ want ▁ to ▁ write ▁ out ▁ a ▁ xml ▁ file ▁ instead ▁ of ▁ napalm ▁ file ▁ then ▁ this ▁ should ▁ be ▁ true STRNEWLINE STRNEWLINE ▁ : type ▁ end _ frame : ▁ string STRNEWLINE STRNEWLINE ▁ : param ▁ left _ eyes : ▁ Left ▁ eye ▁ objects STRNEWLINE STRNEWLINE ▁ : type ▁ left _ eyes : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ right _ eyes : ▁ Right ▁ eye ▁ objects STRNEWLINE STRNEWLINE ▁ : type ▁ right _ eyes : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ map _ file _ name : ▁ Filepath ▁ of ▁ napalm ▁ channel ▁ data STRNEWLINE STRNEWLINE ▁ : type ▁ map _ file _ name : ▁ string STRNEWLINE STRNEWLINE ▁ : return : ▁ Status , channel ▁ file ▁ , ▁ map ▁ file STRNEWLINE STRNEWLINE ▁ : rtype : ▁ boot , string , string STRNEWLINE STRNEWLINE ▁ Example STRNEWLINE STRNEWLINE ▁ > > > ▁ import ▁ kip _ houdini . convert ▁ as ▁ kh STRNEWLINE ▁ > > > ▁ reload ( kh ) STRNEWLINE ▁ > > > ▁ khcw ▁ = ▁ kh . HoudiniWriter ( ) STRNEWLINE ▁ > > > ▁ status , nap _ file , map _ file = khcw . writeOutCurves ( nap _ file _ name ▁ = ▁ " / tmp / houdini _ kip _ test _ s . nap " , map _ file _ name = ▁ " / tmp / houdini _ kip _ test _ m . nap " , houdini _ nodes ▁ = ▁ [ " / obj / geo / xform _ 1 " , " / obj / geo / xform _ 2 " ] , left _ eyes = [ " / obj / geo / xform _ 1 " ] , right _ eyes = [ " / obj / geo / xform _ 2 " ] ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if nap_file_name : NEW_LINE INDENT node_curv = node_curves . NodeCurves ( ) NEW_LINE get_all_curves = node_curv . getCurves ( houdini_node_curves = houdini_nodes , houdini_attribute_curves = houdini_node_attributes , start_frame = start_frame , end_frame = end_frame , silent = silent , left_eye_curves = left_eyes , right_eye_curves = right_eyes ) NEW_LINE if write_xml : NEW_LINE INDENT if not nap_file_name . endswith ( " . xml " ) : NEW_LINE INDENT split_base_ext = os . path . splitext ( nap_file_name ) NEW_LINE if split_base_ext [ - 1 ] : NEW_LINE INDENT nap_file_name = " % s / . xml " % ( split_base_ext [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT nap_file_name = " % s / . xml " % ( nap_file_name ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if not nap_file_name . endswith ( " . nap " ) : NEW_LINE INDENT raise KipBaseError ( " Unknown ▁ file ▁ extension ▁ found ▁ in ▁ % s ▁ ! " % nap_file_name ) NEW_LINE DEDENT DEDENT write_status , map_file , nap_file = napalm_func . write ( nap_file_name , get_all_curves , debug = True , map_file_name = map_file_name , software = self . houdini_version , app_version = self . kip_houdini_version ) NEW_LINE rodin_logger . info ( " % s ▁ % s ▁ % s " % ( write_status , map_file , nap_file ) ) NEW_LINE return ( write_status , map_file , nap_file ) NEW_LINE DEDENT else : NEW_LINE INDENT raise KipBaseError ( " Expected ▁ napalm ▁ file ▁ name ▁ for ▁ write ▁ curve ▁ ! " ) NEW_LINE DEDENT DEDENT DEDENT class HoudiniReader ( object ) : NEW_LINE INDENT """ STRNEWLINE STRNEWLINE ▁ Creating ▁ houdini ▁ curve ▁ reader ▁ class STRNEWLINE STRNEWLINE ▁ * Parents : * STRNEWLINE STRNEWLINE ▁ None STRNEWLINE STRNEWLINE ▁ * Children : * STRNEWLINE STRNEWLINE ▁ * ▁ : func : ` houSetAttr ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def __init__ ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Base ▁ init ▁ function ▁ for ▁ houdini ▁ convert . write ▁ Class . STRNEWLINE ▁ """ NEW_LINE rodin_logger . info ( " kip ▁ houdini ▁ read ▁ class ▁ initialized " ) NEW_LINE self . nuke_tan_types = { " spline " : " spline ( ) " , " linear " : " linear ( ) " , " constant " : " constant ( ) " , " cubic " : " bezier ( ) " } NEW_LINE self . channel_match = { ' translateX ' : ' tx ' , ' translateY ' : ' ty ' , ' translateZ ' : ' tz ' , ' rotateX ' : ' rx ' , ' rotateY ' : ' ry ' , ' rotateZ ' : ' rz ' , ' scaleX ' : ' sx ' , ' scaleY ' : ' sy ' , ' scaleZ ' : ' sz ' } NEW_LINE DEDENT def houSetAttr ( self , nap_file_name = None , houdini_nodes = [ ] , houdini_node_attribute = None , map_file_name = None , offset_value = 0 , start_frame = None , end_frame = None , attribute_map = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ function ▁ will ▁ get ▁ all ▁ curve ▁ data ▁ from ▁ a ▁ map ▁ and ▁ channel ▁ file ▁ then ▁ those ▁ data ▁ will ▁ be ▁ applied ▁ to ▁ proper ▁ nodes STRNEWLINE STRNEWLINE ▁ : param ▁ nap _ file _ name : ▁ User ▁ must ▁ pass ▁ a ▁ file ▁ where ▁ he ▁ want ▁ to ▁ write ▁ out ▁ curves ▁ and ▁ make ▁ sure ▁ you ▁ supply ▁ a ▁ . nap ▁ or ▁ . xml ▁ file ▁ format STRNEWLINE STRNEWLINE ▁ : type ▁ nap _ file _ name : ▁ string STRNEWLINE STRNEWLINE ▁ : param ▁ houdini _ nodes : ▁ list ▁ of ▁ houdini ▁ objects STRNEWLINE STRNEWLINE ▁ : type ▁ houdini _ nodes : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ houdini _ node _ attribute : ▁ if ▁ you ▁ want ▁ to ▁ replace ▁ attribute ▁ from ▁ the ▁ map ▁ file ▁ then ▁ you ▁ can ▁ specify ▁ the ▁ override ▁ attribute ▁ here STRNEWLINE STRNEWLINE ▁ : type ▁ houdini _ node _ attribute : ▁ string STRNEWLINE STRNEWLINE ▁ : param ▁ map _ file _ name : ▁ Filepath ▁ of ▁ napalm ▁ channel ▁ data STRNEWLINE STRNEWLINE ▁ : type ▁ map _ file _ name : ▁ string STRNEWLINE STRNEWLINE ▁ : param ▁ offset _ value : ▁ Animation ▁ key ▁ offset ▁ value STRNEWLINE STRNEWLINE ▁ : type ▁ offset _ value : ▁ int STRNEWLINE STRNEWLINE ▁ : param ▁ start _ frame : ▁ start ▁ frame ▁ to ▁ capture STRNEWLINE STRNEWLINE ▁ : type ▁ start _ frame : ▁ int STRNEWLINE STRNEWLINE ▁ : param ▁ end _ frame : ▁ end ▁ frame ▁ to ▁ capture STRNEWLINE STRNEWLINE ▁ : type ▁ end _ frame : ▁ int STRNEWLINE STRNEWLINE ▁ : param ▁ attribute _ map : ▁ This ▁ a ▁ template ▁ object ▁ from ▁ template ▁ module STRNEWLINE STRNEWLINE ▁ : type ▁ attribute _ map : ▁ list ▁ of ▁ tuple STRNEWLINE STRNEWLINE ▁ Example STRNEWLINE STRNEWLINE ▁ > > > ▁ import ▁ kip _ houdini . convert ▁ as ▁ kh STRNEWLINE ▁ > > > ▁ reload ( kh ) STRNEWLINE ▁ > > > ▁ khpr = kh . HoudiniReader ( ) STRNEWLINE ▁ > > > ▁ import ▁ kip . template ▁ as ▁ template STRNEWLINE ▁ > > > ▁ attr _ mp ▁ = ▁ template . KipTemplates ( ) STRNEWLINE ▁ > > > ▁ attr _ mp . ATTRMAP = { " t1 . cutatt1 " : " / obj / geo1 / xform1 . ottr _ 1 " , " t1 . cutatt2 " : " / obj / geo1 / xform1 . ottr _ 2 " , " t2 . cutatt1 " : " / obj / geo1 / xform1 . ottr _ 3 " , " t2 . cutatt2 " : " / obj / geo1 / xform1 . ottr _ 4 " } STRNEWLINE ▁ > > > ▁ a ▁ = ▁ attr _ mp . ATTRMAP STRNEWLINE ▁ > > > ▁ khpr . houSetAttr ( nap _ file _ name = " / tmp / single _ maya _ test . nap " , houdini _ nodes = " / obj / geo1 / xform1 " , attribute _ map = a ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if nap_file_name : NEW_LINE INDENT if not map_file_name : NEW_LINE INDENT map_file_name = kip_reader . build_map_file_name ( nap_file_name ) NEW_LINE DEDENT header_info = kip_reader . header ( map_file_name ) NEW_LINE array_index = kip_reader . find_software_index ( header_info [ " client _ software " ] ) NEW_LINE houdini_node_list = houdini_nodes NEW_LINE knob_read = kip_reader . ReadCurve ( ) NEW_LINE get_curve_class = knob_read . getCurves ( nap_file_name = nap_file_name , map_file_name = map_file_name , offset_value = offset_value ) NEW_LINE DEDENT for each_node in get_curve_class : NEW_LINE INDENT node_key = get_curve_class . index ( each_node ) NEW_LINE current_node_curve = each_node [ 2 ] NEW_LINE curent_source_node = each_node [ 0 ] NEW_LINE for each_curve in current_node_curve : NEW_LINE INDENT curve_attr = each_curve [ 1 ] NEW_LINE current_key_dict = each_curve [ 2 ] NEW_LINE time_keys = current_key_dict [ " time " ] NEW_LINE key_value = current_key_dict [ " key _ value " ] NEW_LINE in_angle = current_key_dict [ " in _ angle " ] NEW_LINE out_angle = current_key_dict [ " out _ angle " ] NEW_LINE in_weight = current_key_dict [ " in _ weight " ] NEW_LINE out_weight = current_key_dict [ " out _ weight " ] NEW_LINE in_tan_type = current_key_dict [ " in _ tan _ type " ] NEW_LINE out_tan_type = current_key_dict [ " out _ tan _ type " ] NEW_LINE in_slope = current_key_dict [ " in _ slope " ] NEW_LINE out_slope = current_key_dict [ " out _ slope " ] NEW_LINE try : NEW_LINE INDENT for time in time_keys : NEW_LINE INDENT if houdini_node_attribute : NEW_LINE INDENT curve_attr = houdini_node_attribute NEW_LINE DEDENT else : NEW_LINE INDENT if attribute_map : NEW_LINE INDENT temp_attr_keys = attribute_map . keys ( ) NEW_LINE for each_template in temp_attr_keys : NEW_LINE INDENT source_details = each_template . split ( " . " ) NEW_LINE current_node_attr = " % s . % s " % ( curent_source_node , each_curve [ 1 ] ) NEW_LINE if current_node_attr == each_template : NEW_LINE INDENT destenation_details = attribute_map [ each_template ] . split ( " . " ) NEW_LINE curve_attr = destenation_details [ 1 ] NEW_LINE current_houdini_node = destenation_details [ 0 ] NEW_LINE current_houdini_node = hou . node ( current_houdini_node ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT current_houdini_node = hou . node ( houdini_node_list [ node_key ] ) NEW_LINE DEDENT DEDENT if start_frame and end_frame : NEW_LINE INDENT if time in range ( start_frame , end_frame + 1 ) : NEW_LINE INDENT key_index = time_keys . index ( time ) NEW_LINE DEDENT else : NEW_LINE INDENT print " % s ▁ not ▁ in ▁ range ▁ not ▁ applying ▁ the ▁ key " % time NEW_LINE continue NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT key_index = time_keys . index ( time ) NEW_LINE DEDENT in_tan_v = in_tan_type [ key_index ] NEW_LINE if self . nuke_tan_types . has_key ( in_tan_v ) : NEW_LINE INDENT in_tan_v = self . nuke_tan_types [ in_tan_v ] NEW_LINE DEDENT else : NEW_LINE INDENT in_tan_v = " bezier ( ) " NEW_LINE DEDENT hkey = hou . Keyframe ( ) NEW_LINE hkey . setTime ( ( time_keys [ key_index ] / GLOBAL_FPS ) ) NEW_LINE hkey . setValue ( key_value [ key_index ] ) NEW_LINE hkey . setExpression ( " bezier ( ) " ) NEW_LINE hkey . setExpression ( " spline ( ) " ) NEW_LINE hkey . setInAccel ( in_weight [ key_index ] ) NEW_LINE hkey . setAccel ( out_weight [ key_index ] ) NEW_LINE hkey . setInSlope ( in_slope [ key_index ] ) NEW_LINE hkey . setSlope ( out_slope [ key_index ] ) NEW_LINE this_node_attr = curve_attr NEW_LINE if self . channel_match . has_key ( curve_attr ) : NEW_LINE INDENT this_node_attr = self . channel_match [ curve_attr ] NEW_LINE DEDENT hou_nod = current_houdini_node . parm ( this_node_attr ) . setKeyframe ( hkey ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT traceback . print_exc ( ) NEW_LINE raise KipBaseError ( " No ▁ objects ▁ found ▁ in ▁ node ▁ list ! " ) NEW_LINE DEDENT DEDENT DEDENT rodin_logger . info ( " Aniamtion ▁ curve ▁ trasfer ▁ is ▁ finished ▁ ! " ) NEW_LINE return True NEW_LINE DEDENT DEDENT def header ( map_file_name ) : NEW_LINE INDENT """ STRNEWLINE STRNEWLINE ▁ This ▁ function ▁ will ▁ return ▁ a ▁ dict ▁ of ▁ header ▁ details ▁ from ▁ map ▁ file STRNEWLINE STRNEWLINE ▁ : param ▁ map _ file _ name : ▁ Filepath ▁ of ▁ napalm ▁ channel ▁ data STRNEWLINE STRNEWLINE ▁ : type ▁ map _ file _ name : ▁ string STRNEWLINE STRNEWLINE ▁ : return : ▁ header ▁ details STRNEWLINE STRNEWLINE ▁ : rtype : ▁ dict STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if os . path . exists ( map_file_name ) : NEW_LINE INDENT nap_header = kip_reader . header ( map_file_name ) NEW_LINE return nap_header NEW_LINE DEDENT return None NEW_LINE # ▁ Copyright ▁ 2008-2012 ▁ Dr ▁ D ▁ Studios ▁ Pty ▁ Limited ▁ ( ACN ▁ 127 ▁ 184 ▁ 954 ) ▁ ( Dr . ▁ D ▁ Studios ) ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ anim - studio - tools . ENDCOM # ▁ anim - studio - tools ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ anim - studio - tools ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ Lesser ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ anim - studio - tools . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM DEDENT </DOCUMENT>
<DOCUMENT_ID="peonycredit/peonycredit/tree/master/qa/pull-tester/pull-tester.py"> # ! / usr / bin / python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2013 ▁ The ▁ Bitcoin ▁ Core ▁ developers ENDCOM # ▁ Distributed ▁ under ▁ the ▁ MIT / X11 ▁ software ▁ license , ▁ see ▁ the ▁ accompanying ENDCOM # ▁ file ▁ COPYING ▁ or ▁ http : / / www . opensource . org / licenses / mit - license . php . ENDCOM import json NEW_LINE from urllib import urlopen NEW_LINE import requests NEW_LINE import getpass NEW_LINE from string import Template NEW_LINE import sys NEW_LINE import os NEW_LINE import subprocess NEW_LINE class RunError ( Exception ) : NEW_LINE INDENT def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return repr ( self . value ) NEW_LINE DEDENT DEDENT def run ( command , ** kwargs ) : NEW_LINE INDENT fail_hard = kwargs . pop ( " fail _ hard " , True ) NEW_LINE # ▁ output ▁ to ▁ / dev / null ▁ by ▁ default : ENDCOM kwargs . setdefault ( " stdout " , open ( ' / dev / null ' , ' w ' ) ) NEW_LINE kwargs . setdefault ( " stderr " , open ( ' / dev / null ' , ' w ' ) ) NEW_LINE command = Template ( command ) . substitute ( os . environ ) NEW_LINE if " TRACE " in os . environ : NEW_LINE INDENT if ' cwd ' in kwargs : NEW_LINE INDENT print ( " [ cwd = % s ] ▁ % s " % ( kwargs [ ' cwd ' ] , command ) ) NEW_LINE DEDENT else : print ( command ) NEW_LINE DEDENT try : NEW_LINE INDENT process = subprocess . Popen ( command . split ( ' ▁ ' ) , ** kwargs ) NEW_LINE process . wait ( ) NEW_LINE DEDENT except KeyboardInterrupt : NEW_LINE INDENT process . terminate ( ) NEW_LINE raise NEW_LINE DEDENT if process . returncode != 0 and fail_hard : NEW_LINE INDENT raise RunError ( " Failed : ▁ " + command ) NEW_LINE DEDENT return process . returncode NEW_LINE DEDENT def checkout_pull ( clone_url , commit , out ) : NEW_LINE # ▁ Init ENDCOM INDENT build_dir = os . environ [ " BUILD _ DIR " ] NEW_LINE run ( " umount ▁ $ { CHROOT _ COPY } / proc " , fail_hard = False ) NEW_LINE run ( " rsync ▁ - - delete ▁ - apv ▁ $ { CHROOT _ MASTER } / ▁ $ { CHROOT _ COPY } " ) NEW_LINE run ( " rm ▁ - rf ▁ $ { CHROOT _ COPY } $ { SCRIPTS _ DIR } " ) NEW_LINE run ( " cp ▁ - a ▁ $ { SCRIPTS _ DIR } ▁ $ { CHROOT _ COPY } $ { SCRIPTS _ DIR } " ) NEW_LINE # ▁ Merge ▁ onto ▁ upstream / master ENDCOM run ( " rm ▁ - rf ▁ $ { BUILD _ DIR } " ) NEW_LINE run ( " mkdir ▁ - p ▁ $ { BUILD _ DIR } " ) NEW_LINE run ( " git ▁ clone ▁ $ { CLONE _ URL } ▁ $ { BUILD _ DIR } " ) NEW_LINE run ( " git ▁ remote ▁ add ▁ pull ▁ " + clone_url , cwd = build_dir , stdout = out , stderr = out ) NEW_LINE run ( " git ▁ fetch ▁ pull " , cwd = build_dir , stdout = out , stderr = out ) NEW_LINE if run ( " git ▁ merge ▁ " + commit , fail_hard = False , cwd = build_dir , stdout = out , stderr = out ) != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT run ( " chown ▁ - R ▁ $ { BUILD _ USER } : $ { BUILD _ GROUP } ▁ $ { BUILD _ DIR } " , stdout = out , stderr = out ) NEW_LINE run ( " mount ▁ - - bind ▁ / proc ▁ $ { CHROOT _ COPY } / proc " ) NEW_LINE return True NEW_LINE DEDENT def commentOn ( commentUrl , success , inMerge , needTests , linkUrl ) : NEW_LINE INDENT common_message = """ STRNEWLINE This ▁ test ▁ script ▁ verifies ▁ pulls ▁ every ▁ time ▁ they ▁ are ▁ updated . ▁ It , ▁ however , ▁ dies ▁ sometimes ▁ and ▁ fails ▁ to ▁ test ▁ properly . ▁ ▁ If ▁ you ▁ are ▁ waiting ▁ on ▁ a ▁ test , ▁ please ▁ check ▁ timestamps ▁ to ▁ verify ▁ that ▁ the ▁ test . log ▁ is ▁ moving ▁ at ▁ http : / / jenkins . bluematt . me / pull - tester / current / STRNEWLINE Contact ▁ BlueMatt ▁ on ▁ freenode ▁ if ▁ something ▁ looks ▁ broken . """ NEW_LINE # ▁ Remove ▁ old ▁ BitcoinPullTester ▁ comments ▁ ( I ' m ▁ being ▁ lazy ▁ and ▁ not ▁ paginating ▁ here ) ENDCOM recentcomments = requests . get ( commentUrl + " ? sort = created & direction = desc " , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) . json NEW_LINE for comment in recentcomments : NEW_LINE INDENT if comment [ " user " ] [ " login " ] == os . environ [ " GITHUB _ USER " ] and common_message in comment [ " body " ] : NEW_LINE INDENT requests . delete ( comment [ " url " ] , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) NEW_LINE DEDENT DEDENT if success == True : NEW_LINE INDENT if needTests : NEW_LINE INDENT message = " Automatic ▁ sanity - testing : ▁ PLEASE ▁ ADD ▁ TEST - CASES , ▁ though ▁ technically ▁ passed . ▁ See ▁ " + linkUrl + " ▁ for ▁ binaries ▁ and ▁ test ▁ log . " NEW_LINE DEDENT else : NEW_LINE INDENT message = " Automatic ▁ sanity - testing : ▁ PASSED , ▁ see ▁ " + linkUrl + " ▁ for ▁ binaries ▁ and ▁ test ▁ log . " NEW_LINE DEDENT post_data = { " body " : message + common_message } NEW_LINE DEDENT elif inMerge : NEW_LINE INDENT post_data = { " body " : " Automatic ▁ sanity - testing : ▁ FAILED ▁ MERGE , ▁ see ▁ " + linkUrl + " ▁ for ▁ test ▁ log . " + """ STRNEWLINE STRNEWLINE This ▁ pull ▁ does ▁ not ▁ merge ▁ cleanly ▁ onto ▁ current ▁ master """ + common_message } NEW_LINE DEDENT else : NEW_LINE INDENT post_data = { " body " : " Automatic ▁ sanity - testing : ▁ FAILED ▁ BUILD / TEST , ▁ see ▁ " + linkUrl + " ▁ for ▁ binaries ▁ and ▁ test ▁ log . " + """ STRNEWLINE STRNEWLINE This ▁ could ▁ happen ▁ for ▁ one ▁ of ▁ several ▁ reasons : STRNEWLINE 1 . ▁ It ▁ chanages ▁ changes ▁ build ▁ scripts ▁ in ▁ a ▁ way ▁ that ▁ made ▁ them ▁ incompatible ▁ with ▁ the ▁ automated ▁ testing ▁ scripts ▁ ( please ▁ tweak ▁ those ▁ patches ▁ in ▁ qa / pull - tester ) STRNEWLINE 2 . ▁ It ▁ adds / modifies ▁ tests ▁ which ▁ test ▁ network ▁ rules ▁ ( thanks ▁ for ▁ doing ▁ that ) , ▁ which ▁ conflicts ▁ with ▁ a ▁ patch ▁ applied ▁ at ▁ test ▁ time STRNEWLINE 3 . ▁ It ▁ does ▁ not ▁ build ▁ on ▁ either ▁ Linux ▁ i386 ▁ or ▁ Win32 ▁ ( via ▁ MinGW ▁ cross ▁ compile ) STRNEWLINE 4 . ▁ The ▁ test ▁ suite ▁ fails ▁ on ▁ either ▁ Linux ▁ i386 ▁ or ▁ Win32 STRNEWLINE 5 . ▁ The ▁ block ▁ test - cases ▁ failed ▁ ( lookup ▁ the ▁ first ▁ bNN ▁ identifier ▁ which ▁ failed ▁ in ▁ https : / / github . com / TheBlueMatt / test - scripts / blob / master / FullBlockTestGenerator . java ) STRNEWLINE STRNEWLINE If ▁ you ▁ believe ▁ this ▁ to ▁ be ▁ in ▁ error , ▁ please ▁ ping ▁ BlueMatt ▁ on ▁ freenode ▁ or ▁ TheBlueMatt ▁ here . STRNEWLINE """ + common_message } NEW_LINE DEDENT resp = requests . post ( commentUrl , json . dumps ( post_data ) , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) NEW_LINE DEDENT def testpull ( number , comment_url , clone_url , commit ) : NEW_LINE INDENT print ( " Testing ▁ pull ▁ % d : ▁ % s ▁ : ▁ % s " % ( number , clone_url , commit ) ) NEW_LINE dir = os . environ [ " RESULTS _ DIR " ] + " / " + commit + " / " NEW_LINE print ( " ▁ ouput ▁ to ▁ % s " % dir ) NEW_LINE if os . path . exists ( dir ) : NEW_LINE INDENT os . system ( " rm ▁ - r ▁ " + dir ) NEW_LINE DEDENT os . makedirs ( dir ) NEW_LINE currentdir = os . environ [ " RESULTS _ DIR " ] + " / current " NEW_LINE os . system ( " rm ▁ - r ▁ " + currentdir ) NEW_LINE os . system ( " ln ▁ - s ▁ " + dir + " ▁ " + currentdir ) NEW_LINE out = open ( dir + " test . log " , ' w + ' ) NEW_LINE resultsurl = os . environ [ " RESULTS _ URL " ] + commit NEW_LINE checkedout = checkout_pull ( clone_url , commit , out ) NEW_LINE if checkedout != True : NEW_LINE INDENT print ( " Failed ▁ to ▁ test ▁ pull ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , False , True , False , resultsurl ) NEW_LINE open ( os . environ [ " TESTED _ DB " ] , " a " ) . write ( commit + " \n " ) NEW_LINE return NEW_LINE DEDENT run ( " rm ▁ - rf ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } " , fail_hard = False ) ; NEW_LINE run ( " mkdir ▁ - p ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } " , fail_hard = False ) ; NEW_LINE run ( " chown ▁ - R ▁ $ { BUILD _ USER } : $ { BUILD _ GROUP } ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } " , fail_hard = False ) NEW_LINE script = os . environ [ " BUILD _ PATH " ] + " / qa / pull - tester / pull - tester . sh " NEW_LINE script += " ▁ $ { BUILD _ PATH } ▁ $ { MINGW _ DEPS _ DIR } ▁ $ { SCRIPTS _ DIR } / BitcoindComparisonTool _ jar / BitcoindComparisonTool . jar ▁ 0 ▁ 6 ▁ $ { OUT _ DIR } " NEW_LINE returncode = run ( " chroot ▁ $ { CHROOT _ COPY } ▁ sudo ▁ - u ▁ $ { BUILD _ USER } ▁ - H ▁ timeout ▁ $ { TEST _ TIMEOUT } ▁ " + script , fail_hard = False , stdout = out , stderr = out ) NEW_LINE run ( " mv ▁ $ { CHROOT _ COPY } / $ { OUT _ DIR } ▁ " + dir ) NEW_LINE run ( " mv ▁ $ { BUILD _ DIR } ▁ " + dir ) NEW_LINE if returncode == 42 : NEW_LINE INDENT print ( " Successfully ▁ tested ▁ pull ▁ ( needs ▁ tests ) ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , True , False , True , resultsurl ) NEW_LINE DEDENT elif returncode != 0 : NEW_LINE INDENT print ( " Failed ▁ to ▁ test ▁ pull ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , False , False , False , resultsurl ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Successfully ▁ tested ▁ pull ▁ - ▁ sending ▁ comment ▁ to : ▁ " + comment_url ) NEW_LINE commentOn ( comment_url , True , False , False , resultsurl ) NEW_LINE DEDENT open ( os . environ [ " TESTED _ DB " ] , " a " ) . write ( commit + " \n " ) NEW_LINE DEDENT def environ_default ( setting , value ) : NEW_LINE INDENT if not setting in os . environ : NEW_LINE INDENT os . environ [ setting ] = value NEW_LINE DEDENT DEDENT if getpass . getuser ( ) != " root " : NEW_LINE INDENT print ( " Run ▁ me ▁ as ▁ root ! " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT if " GITHUB _ USER " not in os . environ or " GITHUB _ AUTH _ TOKEN " not in os . environ : NEW_LINE INDENT print ( " GITHUB _ USER ▁ and / or ▁ GITHUB _ AUTH _ TOKEN ▁ environment ▁ variables ▁ not ▁ set " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT environ_default ( " CLONE _ URL " , " https : / / github . com / bitcoin / bitcoin . git " ) NEW_LINE environ_default ( " MINGW _ DEPS _ DIR " , " / mnt / w32deps " ) NEW_LINE environ_default ( " SCRIPTS _ DIR " , " / mnt / test - scripts " ) NEW_LINE environ_default ( " CHROOT _ COPY " , " / mnt / chroot - tmp " ) NEW_LINE environ_default ( " CHROOT _ MASTER " , " / mnt / chroot " ) NEW_LINE environ_default ( " OUT _ DIR " , " / mnt / out " ) NEW_LINE environ_default ( " BUILD _ PATH " , " / mnt / bitcoin " ) NEW_LINE os . environ [ " BUILD _ DIR " ] = os . environ [ " CHROOT _ COPY " ] + os . environ [ " BUILD _ PATH " ] NEW_LINE environ_default ( " RESULTS _ DIR " , " / mnt / www / pull - tester " ) NEW_LINE environ_default ( " RESULTS _ URL " , " http : / / jenkins . bluematt . me / pull - tester / " ) NEW_LINE environ_default ( " GITHUB _ REPO " , " bitcoin / bitcoin " ) NEW_LINE environ_default ( " TESTED _ DB " , " / mnt / commits - tested . txt " ) NEW_LINE environ_default ( " BUILD _ USER " , " matt " ) NEW_LINE environ_default ( " BUILD _ GROUP " , " matt " ) NEW_LINE environ_default ( " TEST _ TIMEOUT " , str ( 60 * 60 * 2 ) ) NEW_LINE print ( " Optional ▁ usage : ▁ pull - tester . py ▁ 2112" ) NEW_LINE f = open ( os . environ [ " TESTED _ DB " ] ) NEW_LINE tested = set ( line . rstrip ( ) for line in f . readlines ( ) ) NEW_LINE f . close ( ) NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT pull = requests . get ( " https : / / api . github . com / repos / " + os . environ [ " GITHUB _ REPO " ] + " / pulls / " + sys . argv [ 1 ] , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) . json NEW_LINE testpull ( pull [ " number " ] , pull [ " _ links " ] [ " comments " ] [ " href " ] , pull [ " head " ] [ " repo " ] [ " clone _ url " ] , pull [ " head " ] [ " sha " ] ) NEW_LINE DEDENT else : NEW_LINE INDENT for page in range ( 1 , 100 ) : NEW_LINE INDENT result = requests . get ( " https : / / api . github . com / repos / " + os . environ [ " GITHUB _ REPO " ] + " / pulls ? state = open & page = % d " % ( page , ) , auth = ( os . environ [ ' GITHUB _ USER ' ] , os . environ [ " GITHUB _ AUTH _ TOKEN " ] ) ) . json NEW_LINE if len ( result ) == 0 : break ; NEW_LINE for pull in result : NEW_LINE INDENT if pull [ " head " ] [ " sha " ] in tested : NEW_LINE INDENT print ( " Pull ▁ % d ▁ already ▁ tested " % ( pull [ " number " ] , ) ) NEW_LINE continue NEW_LINE DEDENT testpull ( pull [ " number " ] , pull [ " _ links " ] [ " comments " ] [ " href " ] , pull [ " head " ] [ " repo " ] [ " clone _ url " ] , pull [ " head " ] [ " sha " ] ) NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
