def _amount_all_wrapper ( self , cr , uid , ids , field_name , arg , context = None ) : NEW_LINE INDENT """ ▁ Wrapper ▁ because ▁ of ▁ direct ▁ method ▁ passing ▁ as ▁ parameter ▁ for ▁ function ▁ fields ▁ """ NEW_LINE return self . _amount_all ( cr , uid , ids , field_name , arg , context = context ) NEW_LINE DEDENT
def _amount_all ( self , cr , uid , ids , field_name , arg , context = None ) : NEW_LINE INDENT res = super ( SaleOrder , self ) . _amount_all ( cr , uid , ids , field_name , arg , context = context ) NEW_LINE currency_pool = self . pool . get ( ' res . currency ' ) NEW_LINE for order in self . browse ( cr , uid , ids , context = context ) : NEW_LINE INDENT line_amount = sum ( [ line . price_subtotal for line in order . order_line if line . is_delivery ] ) NEW_LINE currency = order . pricelist_id . currency_id NEW_LINE res [ order . id ] [ ' amount _ delivery ' ] = currency_pool . round ( cr , uid , currency , line_amount ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def _get_order ( self , cr , uid , ids , context = None ) : NEW_LINE INDENT result = { } NEW_LINE for line in self . pool . get ( ' sale . order . line ' ) . browse ( cr , uid , ids , context = context ) : NEW_LINE INDENT result [ line . order_id . id ] = True NEW_LINE DEDENT return result . keys ( ) NEW_LINE DEDENT
def _check_carrier_quotation ( self , cr , uid , order , force_carrier_id = None , context = None ) : NEW_LINE INDENT carrier_obj = self . pool . get ( ' delivery . carrier ' ) NEW_LINE # ▁ check ▁ to ▁ add ▁ or ▁ remove ▁ carrier _ id ENDCOM if not order : NEW_LINE INDENT return False NEW_LINE DEDENT if all ( line . product_id . type == " service " for line in order . website_order_line ) : NEW_LINE INDENT order . write ( { ' carrier _ id ' : None } ) NEW_LINE self . pool [ ' sale . order ' ] . _delivery_unset ( cr , SUPERUSER_ID , [ order . id ] , context = context ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT carrier_id = force_carrier_id or order . carrier_id . id NEW_LINE carrier_ids = self . _get_delivery_methods ( cr , uid , order , context = context ) NEW_LINE if carrier_id : NEW_LINE INDENT if carrier_id not in carrier_ids : NEW_LINE INDENT carrier_id = False NEW_LINE DEDENT else : NEW_LINE INDENT carrier_ids . remove ( carrier_id ) NEW_LINE carrier_ids . insert ( 0 , carrier_id ) NEW_LINE DEDENT DEDENT if force_carrier_id or not carrier_id or not carrier_id in carrier_ids : NEW_LINE INDENT for delivery_id in carrier_ids : NEW_LINE INDENT grid_id = carrier_obj . grid_get ( cr , SUPERUSER_ID , [ delivery_id ] , order . partner_shipping_id . id ) NEW_LINE if grid_id : NEW_LINE INDENT carrier_id = delivery_id NEW_LINE break NEW_LINE DEDENT DEDENT order . write ( { ' carrier _ id ' : carrier_id } ) NEW_LINE DEDENT if carrier_id : NEW_LINE INDENT order . delivery_set ( ) NEW_LINE DEDENT else : NEW_LINE INDENT order . _delivery_unset ( ) NEW_LINE DEDENT DEDENT return bool ( carrier_id ) NEW_LINE DEDENT
def _get_delivery_methods ( self , cr , uid , order , context = None ) : NEW_LINE INDENT carrier_obj = self . pool . get ( ' delivery . carrier ' ) NEW_LINE delivery_ids = carrier_obj . search ( cr , uid , [ ( ' website _ published ' , ' = ' , True ) ] , context = context ) NEW_LINE # ▁ Following ▁ loop ▁ is ▁ done ▁ to ▁ avoid ▁ displaying ▁ delivery ▁ methods ▁ who ▁ are ▁ not ▁ available ▁ for ▁ this ▁ order ENDCOM # ▁ This ▁ can ▁ surely ▁ be ▁ done ▁ in ▁ a ▁ more ▁ efficient ▁ way , ▁ but ▁ at ▁ the ▁ moment , ▁ it ▁ mimics ▁ the ▁ way ▁ it ' s ENDCOM # ▁ done ▁ in ▁ delivery _ set ▁ method ▁ of ▁ sale . py , ▁ from ▁ delivery ▁ module ENDCOM for delivery_id in carrier_obj . browse ( cr , SUPERUSER_ID , delivery_ids , context = dict ( context , order_id = order . id ) ) : NEW_LINE INDENT if not delivery_id . available : NEW_LINE INDENT delivery_ids . remove ( delivery_id . id ) NEW_LINE DEDENT DEDENT return delivery_ids NEW_LINE DEDENT
def _get_errors ( self , cr , uid , order , context = None ) : NEW_LINE INDENT errors = super ( SaleOrder , self ) . _get_errors ( cr , uid , order , context = context ) NEW_LINE if not self . _get_delivery_methods ( cr , uid , order , context = context ) : NEW_LINE INDENT errors . append ( ( ' No ▁ delivery ▁ method ▁ available ' , ' There ▁ is ▁ no ▁ available ▁ delivery ▁ method ▁ for ▁ your ▁ order ' ) ) NEW_LINE DEDENT return errors NEW_LINE DEDENT
def _get_website_data ( self , cr , uid , order , context = None ) : NEW_LINE INDENT """ ▁ Override ▁ to ▁ add ▁ delivery - related ▁ website ▁ data . ▁ """ NEW_LINE values = super ( SaleOrder , self ) . _get_website_data ( cr , uid , order , context = context ) NEW_LINE # ▁ We ▁ need ▁ a ▁ delivery ▁ only ▁ if ▁ we ▁ have ▁ stockable ▁ products ENDCOM has_stockable_products = False NEW_LINE for line in order . order_line : NEW_LINE INDENT if line . product_id . type in ( ' consu ' , ' product ' ) : NEW_LINE INDENT has_stockable_products = True NEW_LINE DEDENT DEDENT if not has_stockable_products : NEW_LINE INDENT return values NEW_LINE DEDENT delivery_ctx = dict ( context , order_id = order . id ) NEW_LINE DeliveryCarrier = self . pool . get ( ' delivery . carrier ' ) NEW_LINE delivery_ids = self . _get_delivery_methods ( cr , uid , order , context = context ) NEW_LINE values [ ' deliveries ' ] = DeliveryCarrier . browse ( cr , SUPERUSER_ID , delivery_ids , context = delivery_ctx ) NEW_LINE return values NEW_LINE DEDENT
def _get_plot_components ( self ) : NEW_LINE INDENT warnings . warn ( " Use ▁ of ▁ plot _ components ▁ attribute ▁ deprecated . " " Use ▁ components ▁ attribute ▁ instead . " , DeprecationWarning ) NEW_LINE return self . _components NEW_LINE DEDENT
def _set_plot_components ( self , new ) : NEW_LINE INDENT warnings . warn ( " Use ▁ of ▁ plot _ components ▁ attribute ▁ deprecated . " " Use ▁ components ▁ attribute ▁ instead . " , DeprecationWarning ) NEW_LINE self . _components = new NEW_LINE DEDENT
def _use_draw_order_changed ( self , old , new ) : NEW_LINE INDENT """ ▁ Handler ▁ to ▁ catch ▁ the ▁ case ▁ when ▁ someone ▁ is ▁ trying ▁ to ▁ use ▁ the STRNEWLINE ▁ old - style ▁ drawing ▁ mechanism , ▁ which ▁ is ▁ now ▁ unsupported . STRNEWLINE ▁ """ NEW_LINE if new == False : NEW_LINE INDENT raise RuntimeError ( " The ▁ old - style ▁ drawing ▁ mechanism ▁ is ▁ no ▁ longer ▁ " " supported ▁ in ▁ Chaco . " ) NEW_LINE # ▁ EOF ENDCOM DEDENT DEDENT
def urlopen ( self , url ) : NEW_LINE INDENT return urlopen ( self . live_server_url + url ) NEW_LINE DEDENT
def test_live_server_url_is_class_property ( self ) : NEW_LINE INDENT self . assertIsInstance ( self . live_server_url_test [ 0 ] , text_type ) NEW_LINE self . assertEqual ( self . live_server_url_test [ 0 ] , self . live_server_url ) NEW_LINE DEDENT
def test_404 ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ 404s . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . urlopen ( ' / ' ) NEW_LINE DEDENT except HTTPError as err : NEW_LINE INDENT self . assertEqual ( err . code , 404 , ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT DEDENT
def test_view ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ views . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / example _ view / ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) , b ' example ▁ view ' ) NEW_LINE DEDENT DEDENT
def test_static_files ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ static ▁ files . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / static / example _ static _ file . txt ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . rstrip ( b ' \n ' ) , b ' example ▁ static ▁ file ' ) NEW_LINE DEDENT DEDENT
def test_no_collectstatic_emulation ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ that ▁ LiveServerTestCase ▁ reports ▁ a ▁ 404 ▁ status ▁ code ▁ when ▁ HTTP ▁ client STRNEWLINE ▁ tries ▁ to ▁ access ▁ a ▁ static ▁ file ▁ that ▁ isn ' t ▁ explicitly ▁ put ▁ under STRNEWLINE ▁ STATIC _ ROOT . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . urlopen ( ' / static / another _ app / another _ app _ static _ file . txt ' ) NEW_LINE DEDENT except HTTPError as err : NEW_LINE INDENT self . assertEqual ( err . code , 404 , ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Expected ▁ 404 ▁ response ▁ ( got ▁ % d ) ' % err . code ) NEW_LINE DEDENT DEDENT
def test_media_files ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ media ▁ files . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / media / example _ media _ file . txt ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . rstrip ( b ' \n ' ) , b ' example ▁ media ▁ file ' ) NEW_LINE DEDENT DEDENT
def test_environ ( self ) : NEW_LINE INDENT with contextlib . closing ( self . urlopen ( ' / environ _ view / ? % s ' % urlencode ( { ' q ' : ' тест ' } ) ) ) as f : NEW_LINE INDENT self . assertIn ( b " QUERY _ STRING : ▁ ' q = % D1%82 % D0 % B5 % D1%81 % D1%82 ' " , f . read ( ) ) NEW_LINE DEDENT DEDENT
def test_fixtures_loaded ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ fixtures ▁ are ▁ properly ▁ loaded ▁ and ▁ visible ▁ to ▁ the STRNEWLINE ▁ live ▁ server ▁ thread . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / model _ view / ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . splitlines ( ) , [ b ' jane ' , b ' robert ' ] ) NEW_LINE DEDENT DEDENT
def test_database_writes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ data ▁ written ▁ to ▁ the ▁ database ▁ by ▁ a ▁ view ▁ can ▁ be ▁ read . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE self . urlopen ( ' / create _ model _ instance / ' ) NEW_LINE self . assertQuerysetEqual ( Person . objects . all ( ) . order_by ( ' pk ' ) , [ ' jane ' , ' robert ' , ' emily ' ] , lambda b : b . name ) NEW_LINE DEDENT
def test_port_bind ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Each ▁ LiveServerTestCase ▁ binds ▁ to ▁ a ▁ unique ▁ port ▁ or ▁ fails ▁ to ▁ start ▁ a STRNEWLINE ▁ server ▁ thread ▁ when ▁ run ▁ concurrently ▁ ( # 26011 ) . STRNEWLINE ▁ """ NEW_LINE TestCase = type ( str ( " TestCase " ) , ( LiveServerBase , ) , { } ) NEW_LINE try : NEW_LINE INDENT TestCase . setUpClass ( ) NEW_LINE DEDENT except socket . error as e : NEW_LINE INDENT if e . errno == errno . EADDRINUSE : NEW_LINE # ▁ We ' re ▁ out ▁ of ▁ ports , ▁ LiveServerTestCase ▁ correctly ▁ fails ▁ with ENDCOM # ▁ a ▁ socket ▁ error . ENDCOM INDENT return NEW_LINE # ▁ Unexpected ▁ error . ENDCOM DEDENT raise NEW_LINE DEDENT try : NEW_LINE # ▁ We ' ve ▁ acquired ▁ a ▁ port , ▁ ensure ▁ our ▁ server ▁ threads ▁ acquired ENDCOM # ▁ different ▁ addresses . ENDCOM INDENT self . assertNotEqual ( self . live_server_url , TestCase . live_server_url , " Acquired ▁ duplicate ▁ server ▁ addresses ▁ for ▁ server ▁ threads : ▁ % s " % self . live_server_url ) NEW_LINE DEDENT finally : NEW_LINE INDENT TestCase . tearDownClass ( ) NEW_LINE DEDENT DEDENT
def run ( self ) : NEW_LINE INDENT cmd = [ self . env [ ' VALAC ' ] ] + self . env [ ' VALAFLAGS ' ] NEW_LINE cmd . extend ( [ a . abspath ( ) for a in self . inputs ] ) NEW_LINE ret = self . exec_command ( cmd , cwd = self . outputs [ 0 ] . parent . abspath ( ) ) NEW_LINE if ret : NEW_LINE INDENT return ret NEW_LINE DEDENT for x in self . outputs : NEW_LINE INDENT if id ( x . parent ) != id ( self . outputs [ 0 ] . parent ) : NEW_LINE INDENT shutil . move ( self . outputs [ 0 ] . parent . abspath ( ) + os . sep + x . name , x . abspath ( ) ) NEW_LINE DEDENT DEDENT if self . generator . dump_deps_node : NEW_LINE INDENT self . generator . dump_deps_node . write ( ' \n ' . join ( self . generator . packages ) ) NEW_LINE DEDENT return ret NEW_LINE DEDENT
def init_vala_task ( self ) : NEW_LINE INDENT self . profile = getattr ( self , ' profile ' , ' gobject ' ) NEW_LINE if self . profile == ' gobject ' : NEW_LINE INDENT self . uselib = Utils . to_list ( getattr ( self , ' uselib ' , [ ] ) ) NEW_LINE if not ' GOBJECT ' in self . uselib : NEW_LINE INDENT self . uselib . append ( ' GOBJECT ' ) NEW_LINE DEDENT DEDENT def addflags ( flags ) : NEW_LINE INDENT self . env . append_value ( ' VALAFLAGS ' , flags ) NEW_LINE DEDENT if self . profile : NEW_LINE INDENT addflags ( ' - - profile = % s ' % self . profile ) NEW_LINE DEDENT if hasattr ( self , ' threading ' ) : NEW_LINE INDENT if self . profile == ' gobject ' : NEW_LINE INDENT if not ' GTHREAD ' in self . uselib : NEW_LINE INDENT self . uselib . append ( ' GTHREAD ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Logs . warn ( " Profile ▁ % s ▁ means ▁ no ▁ threading ▁ support " % self . profile ) NEW_LINE self . threading = False NEW_LINE DEDENT if self . threading : NEW_LINE INDENT addflags ( ' - - threading ' ) NEW_LINE DEDENT DEDENT valatask = self . valatask NEW_LINE self . is_lib = ' cprogram ' not in self . features NEW_LINE if self . is_lib : NEW_LINE INDENT addflags ( ' - - library = % s ' % self . target ) NEW_LINE h_node = self . path . find_or_declare ( ' % s . h ' % self . target ) NEW_LINE valatask . outputs . append ( h_node ) NEW_LINE addflags ( ' - - header = % s ' % h_node . name ) NEW_LINE valatask . outputs . append ( self . path . find_or_declare ( ' % s . vapi ' % self . target ) ) NEW_LINE if getattr ( self , ' gir ' , None ) : NEW_LINE INDENT gir_node = self . path . find_or_declare ( ' % s . gir ' % self . gir ) NEW_LINE addflags ( ' - - gir = % s ' % gir_node . name ) NEW_LINE valatask . outputs . append ( gir_node ) NEW_LINE DEDENT DEDENT self . vala_target_glib = getattr ( self , ' vala _ target _ glib ' , getattr ( Options . options , ' vala _ target _ glib ' , None ) ) NEW_LINE if self . vala_target_glib : NEW_LINE INDENT addflags ( ' - - target - glib = % s ' % self . vala_target_glib ) NEW_LINE DEDENT addflags ( [ ' - - define = % s ' % x for x in getattr ( self , ' vala _ defines ' , [ ] ) ] ) NEW_LINE packages_private = Utils . to_list ( getattr ( self , ' packages _ private ' , [ ] ) ) NEW_LINE addflags ( [ ' - - pkg = % s ' % x for x in packages_private ] ) NEW_LINE def _get_api_version ( ) : NEW_LINE INDENT api_version = '1.0' NEW_LINE if hasattr ( Context . g_module , ' API _ VERSION ' ) : NEW_LINE INDENT version = Context . g_module . API_VERSION . split ( " . " ) NEW_LINE if version [ 0 ] == "0" : NEW_LINE INDENT api_version = "0 . " + version [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT api_version = version [ 0 ] + " . 0" NEW_LINE DEDENT DEDENT return api_version NEW_LINE DEDENT self . includes = Utils . to_list ( getattr ( self , ' includes ' , [ ] ) ) NEW_LINE self . uselib = self . to_list ( getattr ( self , ' uselib ' , [ ] ) ) NEW_LINE valatask . install_path = getattr ( self , ' install _ path ' , ' ' ) NEW_LINE valatask . vapi_path = getattr ( self , ' vapi _ path ' , ' $ { DATAROOTDIR } / vala / vapi ' ) NEW_LINE valatask . pkg_name = getattr ( self , ' pkg _ name ' , self . env [ ' PACKAGE ' ] ) NEW_LINE valatask . header_path = getattr ( self , ' header _ path ' , ' $ { INCLUDEDIR } / % s - % s ' % ( valatask . pkg_name , _get_api_version ( ) ) ) NEW_LINE valatask . install_binding = getattr ( self , ' install _ binding ' , True ) NEW_LINE self . packages = packages = Utils . to_list ( getattr ( self , ' packages ' , [ ] ) ) NEW_LINE self . vapi_dirs = vapi_dirs = Utils . to_list ( getattr ( self , ' vapi _ dirs ' , [ ] ) ) NEW_LINE includes = [ ] NEW_LINE if hasattr ( self , ' use ' ) : NEW_LINE INDENT local_packages = Utils . to_list ( self . use ) [ : ] NEW_LINE seen = [ ] NEW_LINE while len ( local_packages ) > 0 : NEW_LINE INDENT package = local_packages . pop ( ) NEW_LINE if package in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . append ( package ) NEW_LINE try : NEW_LINE INDENT package_obj = self . bld . get_tgen_by_name ( package ) NEW_LINE DEDENT except Errors . WafError : NEW_LINE INDENT continue NEW_LINE DEDENT package_name = package_obj . target NEW_LINE package_node = package_obj . path NEW_LINE package_dir = package_node . path_from ( self . path ) NEW_LINE for task in package_obj . tasks : NEW_LINE INDENT for output in task . outputs : NEW_LINE INDENT if output . name == package_name + " . vapi " : NEW_LINE INDENT valatask . set_run_after ( task ) NEW_LINE if package_name not in packages : NEW_LINE INDENT packages . append ( package_name ) NEW_LINE DEDENT if package_dir not in vapi_dirs : NEW_LINE INDENT vapi_dirs . append ( package_dir ) NEW_LINE DEDENT if package_dir not in includes : NEW_LINE INDENT includes . append ( package_dir ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if hasattr ( package_obj , ' use ' ) : NEW_LINE INDENT lst = self . to_list ( package_obj . use ) NEW_LINE lst . reverse ( ) NEW_LINE local_packages = [ pkg for pkg in lst if pkg not in seen ] + local_packages NEW_LINE DEDENT DEDENT DEDENT addflags ( [ ' - - pkg = % s ' % p for p in packages ] ) NEW_LINE for vapi_dir in vapi_dirs : NEW_LINE INDENT v_node = self . path . find_dir ( vapi_dir ) NEW_LINE if not v_node : NEW_LINE INDENT Logs . warn ( ' Unable ▁ to ▁ locate ▁ Vala ▁ API ▁ directory : ▁ % r ' % vapi_dir ) NEW_LINE DEDENT else : NEW_LINE INDENT addflags ( ' - - vapidir = % s ' % v_node . abspath ( ) ) NEW_LINE addflags ( ' - - vapidir = % s ' % v_node . get_bld ( ) . abspath ( ) ) NEW_LINE DEDENT DEDENT self . dump_deps_node = None NEW_LINE if self . is_lib and self . packages : NEW_LINE INDENT self . dump_deps_node = self . path . find_or_declare ( ' % s . deps ' % self . target ) NEW_LINE valatask . outputs . append ( self . dump_deps_node ) NEW_LINE DEDENT self . includes . append ( self . bld . srcnode . abspath ( ) ) NEW_LINE self . includes . append ( self . bld . bldnode . abspath ( ) ) NEW_LINE for include in includes : NEW_LINE INDENT try : NEW_LINE INDENT self . includes . append ( self . path . find_dir ( include ) . abspath ( ) ) NEW_LINE self . includes . append ( self . path . find_dir ( include ) . get_bld ( ) . abspath ( ) ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT Logs . warn ( " Unable ▁ to ▁ locate ▁ include ▁ directory : ▁ ' % s ' " % include ) NEW_LINE DEDENT DEDENT if self . is_lib and valatask . install_binding : NEW_LINE INDENT headers_list = [ o for o in valatask . outputs if o . suffix ( ) == " . h " ] NEW_LINE try : NEW_LINE INDENT self . install_vheader . source = headers_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_vheader = self . bld . install_files ( valatask . header_path , headers_list , self . env ) NEW_LINE DEDENT vapi_list = [ o for o in valatask . outputs if ( o . suffix ( ) in ( " . vapi " , " . deps " ) ) ] NEW_LINE try : NEW_LINE INDENT self . install_vapi . source = vapi_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_vapi = self . bld . install_files ( valatask . vapi_path , vapi_list , self . env ) NEW_LINE DEDENT gir_list = [ o for o in valatask . outputs if o . suffix ( ) == ' . gir ' ] NEW_LINE try : NEW_LINE INDENT self . install_gir . source = gir_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_gir = self . bld . install_files ( getattr ( self , ' gir _ path ' , ' $ { DATAROOTDIR } / gir - 1.0' ) , gir_list , self . env ) NEW_LINE DEDENT DEDENT DEDENT
def vala_file ( self , node ) : NEW_LINE INDENT try : NEW_LINE INDENT valatask = self . valatask NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT valatask = self . valatask = self . create_task ( ' valac ' ) NEW_LINE self . init_vala_task ( ) NEW_LINE DEDENT valatask . inputs . append ( node ) NEW_LINE c_node = node . change_ext ( ' . c ' ) NEW_LINE valatask . outputs . append ( c_node ) NEW_LINE self . source . append ( c_node ) NEW_LINE DEDENT
def find_valac ( self , valac_name , min_version ) : NEW_LINE INDENT valac = self . find_program ( valac_name , var = ' VALAC ' ) NEW_LINE try : NEW_LINE INDENT output = self . cmd_and_log ( valac + ' ▁ - - version ' ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT valac_version = None NEW_LINE DEDENT else : NEW_LINE INDENT ver = re . search ( r ' \d + . \d + . \d + ' , output ) . group ( 0 ) . split ( ' . ' ) NEW_LINE valac_version = tuple ( [ int ( x ) for x in ver ] ) NEW_LINE DEDENT self . msg ( ' Checking ▁ for ▁ % s ▁ version ▁ > = ▁ % r ' % ( valac_name , min_version ) , valac_version , valac_version and valac_version >= min_version ) NEW_LINE if valac and valac_version < min_version : NEW_LINE INDENT self . fatal ( " % s ▁ version ▁ % r ▁ is ▁ too ▁ old , ▁ need ▁ > = ▁ % r " % ( valac_name , valac_version , min_version ) ) NEW_LINE DEDENT self . env [ ' VALAC _ VERSION ' ] = valac_version NEW_LINE return valac NEW_LINE DEDENT
def check_vala ( self , min_version = ( 0 , 8 , 0 ) , branch = None ) : NEW_LINE INDENT if not branch : NEW_LINE INDENT branch = min_version [ : 2 ] NEW_LINE DEDENT try : NEW_LINE INDENT find_valac ( self , ' valac - % d . % d ' % ( branch [ 0 ] , branch [ 1 ] ) , min_version ) NEW_LINE DEDENT except self . errors . ConfigurationError : NEW_LINE INDENT find_valac ( self , ' valac ' , min_version ) NEW_LINE DEDENT DEDENT
def check_vala_deps ( self ) : NEW_LINE INDENT if not self . env [ ' HAVE _ GOBJECT ' ] : NEW_LINE INDENT pkg_args = { ' package ' : ' gobject - 2.0' , ' uselib _ store ' : ' GOBJECT ' , ' args ' : ' - - cflags ▁ - - libs ' } NEW_LINE if getattr ( Options . options , ' vala _ target _ glib ' , None ) : NEW_LINE INDENT pkg_args [ ' atleast _ version ' ] = Options . options . vala_target_glib NEW_LINE DEDENT self . check_cfg ( ** pkg_args ) NEW_LINE DEDENT if not self . env [ ' HAVE _ GTHREAD ' ] : NEW_LINE INDENT pkg_args = { ' package ' : ' gthread - 2.0' , ' uselib _ store ' : ' GTHREAD ' , ' args ' : ' - - cflags ▁ - - libs ' } NEW_LINE if getattr ( Options . options , ' vala _ target _ glib ' , None ) : NEW_LINE INDENT pkg_args [ ' atleast _ version ' ] = Options . options . vala_target_glib NEW_LINE DEDENT self . check_cfg ( ** pkg_args ) NEW_LINE DEDENT DEDENT
def configure ( self ) : NEW_LINE INDENT self . load ( ' gnu _ dirs ' ) NEW_LINE self . check_vala_deps ( ) NEW_LINE self . check_vala ( ) NEW_LINE self . env . VALAFLAGS = [ ' - C ' , ' - - quiet ' ] NEW_LINE DEDENT
def ▁ get ( self ) : STRNEWLINE ▁ self . write ( " Hello , ▁ world " ) STRNEWLINE STRNEWLINE ▁ if ▁ _ _ name _ _ ▁ = = ▁ " _ _ main _ _ " : STRNEWLINE ▁ application ▁ = ▁ tornado . wsgi . WSGIApplication ( [ STRNEWLINE ▁ ( r " / " , ▁ MainHandler ) , STRNEWLINE ▁ ] ) STRNEWLINE ▁ server ▁ = ▁ wsgiref . simple _ server . make _ server ( ' ' , ▁ 8888 , ▁ application ) STRNEWLINE ▁ server . serve _ forever ( ) STRNEWLINE STRNEWLINE ▁ See ▁ the ▁ ` appengine ▁ demo STRNEWLINE ▁ < https : / / github . com / facebook / tornado / tree / master / demos / appengine > ` _ STRNEWLINE ▁ for ▁ an ▁ example ▁ of ▁ using ▁ this ▁ module ▁ to ▁ run ▁ a ▁ Tornado ▁ app ▁ on ▁ Google STRNEWLINE ▁ App ▁ Engine . STRNEWLINE STRNEWLINE ▁ WSGI ▁ applications ▁ use ▁ the ▁ same ▁ ` . RequestHandler ` ▁ class , ▁ but ▁ not STRNEWLINE ▁ ` ` @ asynchronous ` ` ▁ methods ▁ or ▁ ` ` flush ( ) ` ` . ▁ This ▁ means ▁ that ▁ it ▁ is STRNEWLINE ▁ not ▁ possible ▁ to ▁ use ▁ ` . AsyncHTTPClient ` , ▁ or ▁ the ▁ ` tornado . auth ` ▁ or STRNEWLINE ▁ ` tornado . websocket ` ▁ modules . STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , handlers = None , default_host = " " , ** settings ) : NEW_LINE INDENT web . Application . __init__ ( self , handlers , default_host , transforms = [ ] , wsgi = True , ** settings ) NEW_LINE DEDENT
def __call__ ( self , environ , start_response ) : NEW_LINE INDENT handler = web . Application . __call__ ( self , HTTPRequest ( environ ) ) NEW_LINE assert handler . _finished NEW_LINE reason = handler . _reason NEW_LINE status = str ( handler . _status_code ) + " ▁ " + reason NEW_LINE headers = list ( handler . _headers . get_all ( ) ) NEW_LINE if hasattr ( handler , " _ new _ cookie " ) : NEW_LINE INDENT for cookie in handler . _new_cookie . values ( ) : NEW_LINE INDENT headers . append ( ( " Set - Cookie " , cookie . OutputString ( None ) ) ) NEW_LINE DEDENT DEDENT start_response ( status , [ ( native_str ( k ) , native_str ( v ) ) for ( k , v ) in headers ] ) NEW_LINE return handler . _write_buffer NEW_LINE DEDENT
def __init__ ( self , environ ) : NEW_LINE INDENT """ Parses ▁ the ▁ given ▁ WSGI ▁ environment ▁ to ▁ construct ▁ the ▁ request . """ NEW_LINE self . method = environ [ " REQUEST _ METHOD " ] NEW_LINE self . path = urllib_parse . quote ( from_wsgi_str ( environ . get ( " SCRIPT _ NAME " , " " ) ) ) NEW_LINE self . path += urllib_parse . quote ( from_wsgi_str ( environ . get ( " PATH _ INFO " , " " ) ) ) NEW_LINE self . uri = self . path NEW_LINE self . arguments = { } NEW_LINE self . query_arguments = { } NEW_LINE self . body_arguments = { } NEW_LINE self . query = environ . get ( " QUERY _ STRING " , " " ) NEW_LINE if self . query : NEW_LINE INDENT self . uri += " ? " + self . query NEW_LINE self . arguments = parse_qs_bytes ( native_str ( self . query ) , keep_blank_values = True ) NEW_LINE self . query_arguments = copy . deepcopy ( self . arguments ) NEW_LINE DEDENT self . version = " HTTP / 1.1" NEW_LINE self . headers = httputil . HTTPHeaders ( ) NEW_LINE if environ . get ( " CONTENT _ TYPE " ) : NEW_LINE INDENT self . headers [ " Content - Type " ] = environ [ " CONTENT _ TYPE " ] NEW_LINE DEDENT if environ . get ( " CONTENT _ LENGTH " ) : NEW_LINE INDENT self . headers [ " Content - Length " ] = environ [ " CONTENT _ LENGTH " ] NEW_LINE DEDENT for key in environ : NEW_LINE INDENT if key . startswith ( " HTTP _ " ) : NEW_LINE INDENT self . headers [ key [ 5 : ] . replace ( " _ " , " - " ) ] = environ [ key ] NEW_LINE DEDENT DEDENT if self . headers . get ( " Content - Length " ) : NEW_LINE INDENT self . body = environ [ " wsgi . input " ] . read ( int ( self . headers [ " Content - Length " ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . body = " " NEW_LINE DEDENT self . protocol = environ [ " wsgi . url _ scheme " ] NEW_LINE self . remote_ip = environ . get ( " REMOTE _ ADDR " , " " ) NEW_LINE if environ . get ( " HTTP _ HOST " ) : NEW_LINE INDENT self . host = environ [ " HTTP _ HOST " ] NEW_LINE DEDENT else : NEW_LINE INDENT self . host = environ [ " SERVER _ NAME " ] NEW_LINE # ▁ Parse ▁ request ▁ body ENDCOM DEDENT self . files = { } NEW_LINE httputil . parse_body_arguments ( self . headers . get ( " Content - Type " , " " ) , self . body , self . body_arguments , self . files ) NEW_LINE for k , v in self . body_arguments . items ( ) : NEW_LINE INDENT self . arguments . setdefault ( k , [ ] ) . extend ( v ) NEW_LINE DEDENT self . _start_time = time . time ( ) NEW_LINE self . _finish_time = None NEW_LINE DEDENT
def supports_http_1_1 ( self ) : NEW_LINE INDENT """ Returns ▁ True ▁ if ▁ this ▁ request ▁ supports ▁ HTTP / 1.1 ▁ semantics """ NEW_LINE return self . version == " HTTP / 1.1" NEW_LINE DEDENT
def cookies ( self ) : NEW_LINE INDENT """ A ▁ dictionary ▁ of ▁ Cookie . Morsel ▁ objects . """ NEW_LINE if not hasattr ( self , " _ cookies " ) : NEW_LINE INDENT self . _cookies = Cookie . SimpleCookie ( ) NEW_LINE if " Cookie " in self . headers : NEW_LINE INDENT try : NEW_LINE INDENT self . _cookies . load ( native_str ( self . headers [ " Cookie " ] ) ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT self . _cookies = None NEW_LINE DEDENT DEDENT DEDENT return self . _cookies NEW_LINE DEDENT
def full_url ( self ) : NEW_LINE INDENT """ Reconstructs ▁ the ▁ full ▁ URL ▁ for ▁ this ▁ request . """ NEW_LINE return self . protocol + " : / / " + self . host + self . uri NEW_LINE DEDENT
def request_time ( self ) : NEW_LINE INDENT """ Returns ▁ the ▁ amount ▁ of ▁ time ▁ it ▁ took ▁ for ▁ this ▁ request ▁ to ▁ execute . """ NEW_LINE if self . _finish_time is None : NEW_LINE INDENT return time . time ( ) - self . _start_time NEW_LINE DEDENT else : NEW_LINE INDENT return self . _finish_time - self . _start_time NEW_LINE DEDENT DEDENT
def __call__ ( self , request ) : NEW_LINE INDENT data = { } NEW_LINE response = [ ] NEW_LINE def start_response ( status , response_headers , exc_info = None ) : NEW_LINE INDENT data [ " status " ] = status NEW_LINE data [ " headers " ] = response_headers NEW_LINE return response . append NEW_LINE DEDENT app_response = self . wsgi_application ( WSGIContainer . environ ( request ) , start_response ) NEW_LINE try : NEW_LINE INDENT response . extend ( app_response ) NEW_LINE body = b " " . join ( response ) NEW_LINE DEDENT finally : NEW_LINE INDENT if hasattr ( app_response , " close " ) : NEW_LINE INDENT app_response . close ( ) NEW_LINE DEDENT DEDENT if not data : NEW_LINE INDENT raise Exception ( " WSGI ▁ app ▁ did ▁ not ▁ call ▁ start _ response " ) NEW_LINE DEDENT status_code = int ( data [ " status " ] . split ( ) [ 0 ] ) NEW_LINE headers = data [ " headers " ] NEW_LINE header_set = set ( k . lower ( ) for ( k , v ) in headers ) NEW_LINE body = escape . utf8 ( body ) NEW_LINE if status_code != 304 : NEW_LINE INDENT if " content - length " not in header_set : NEW_LINE INDENT headers . append ( ( " Content - Length " , str ( len ( body ) ) ) ) NEW_LINE DEDENT if " content - type " not in header_set : NEW_LINE INDENT headers . append ( ( " Content - Type " , " text / html ; ▁ charset = UTF - 8" ) ) NEW_LINE DEDENT DEDENT if " server " not in header_set : NEW_LINE INDENT headers . append ( ( " Server " , " TornadoServer / % s " % tornado . version ) ) NEW_LINE DEDENT parts = [ escape . utf8 ( " HTTP / 1.1 ▁ " + data [ " status " ] + " \n " ) ] NEW_LINE for key , value in headers : NEW_LINE INDENT parts . append ( escape . utf8 ( key ) + b " : ▁ " + escape . utf8 ( value ) + b " \n " ) NEW_LINE DEDENT parts . append ( b " \n " ) NEW_LINE parts . append ( body ) NEW_LINE request . write ( b " " . join ( parts ) ) NEW_LINE request . finish ( ) NEW_LINE self . _log ( status_code , request ) NEW_LINE DEDENT
def _log ( self , status_code , request ) : NEW_LINE INDENT if status_code < 400 : NEW_LINE INDENT log_method = access_log . info NEW_LINE DEDENT elif status_code < 500 : NEW_LINE INDENT log_method = access_log . warning NEW_LINE DEDENT else : NEW_LINE INDENT log_method = access_log . error NEW_LINE DEDENT request_time = 1000.0 * request . request_time ( ) NEW_LINE summary = request . method + " ▁ " + request . uri + " ▁ ( " + request . remote_ip + " ) " NEW_LINE log_method ( " % d ▁ % s ▁ % .2fms " , status_code , summary , request_time ) NEW_LINE DEDENT
def _searchOnTitle ( self , title , media , quality , results ) : NEW_LINE INDENT url = self . buildUrl ( title , media , quality ) NEW_LINE data = self . getHTMLData ( url ) NEW_LINE if data : NEW_LINE INDENT html = BeautifulSoup ( data ) NEW_LINE try : NEW_LINE INDENT resultsTable = html . find ( ' table ' , attrs = { ' id ' : ' torrents - table ' } ) NEW_LINE if resultsTable is None : NEW_LINE INDENT return NEW_LINE DEDENT entries = resultsTable . find_all ( ' tr ' , attrs = { ' class ' : ' tt _ row ' } ) NEW_LINE for result in entries : NEW_LINE INDENT link = result . find ( ' td ' , attrs = { ' class ' : ' ttr _ name ' } ) . find ( ' a ' ) NEW_LINE url = result . find ( ' td ' , attrs = { ' class ' : ' td _ dl ' } ) . find ( ' a ' ) NEW_LINE leechers = result . find ( ' td ' , attrs = { ' class ' : ' ttr _ leechers ' } ) . find ( ' a ' ) NEW_LINE torrent_id = link [ ' href ' ] . replace ( ' details ? id = ' , ' ' ) NEW_LINE results . append ( { ' id ' : torrent_id , ' name ' : link [ ' title ' ] , ' url ' : self . urls [ ' download ' ] % url [ ' href ' ] , ' detail _ url ' : self . urls [ ' detail ' ] % torrent_id , ' size ' : self . parseSize ( result . find ( ' td ' , attrs = { ' class ' : ' ttr _ size ' } ) . contents [ 0 ] ) , ' seeders ' : tryInt ( result . find ( ' td ' , attrs = { ' class ' : ' ttr _ seeders ' } ) . find ( ' a ' ) . string ) , ' leechers ' : tryInt ( leechers . string ) if leechers else 0 , ' get _ more _ info ' : self . getMoreInfo , } ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT log . error ( ' Failed ▁ getting ▁ results ▁ from ▁ % s : ▁ % s ' , ( self . getName ( ) , traceback . format_exc ( ) ) ) NEW_LINE DEDENT DEDENT DEDENT
def getMoreInfo ( self , item ) : NEW_LINE INDENT full_description = self . getCache ( ' sceneaccess . % s ' % item [ ' id ' ] , item [ ' detail _ url ' ] , cache_timeout = 25920000 ) NEW_LINE html = BeautifulSoup ( full_description ) NEW_LINE nfo_pre = html . find ( ' div ' , attrs = { ' id ' : ' details _ table ' } ) NEW_LINE description = toUnicode ( nfo_pre . text ) if nfo_pre else ' ' NEW_LINE item [ ' description ' ] = description NEW_LINE return item NEW_LINE # ▁ Login ENDCOM DEDENT
def getLoginParams ( self ) : NEW_LINE INDENT return { ' username ' : self . conf ( ' username ' ) , ' password ' : self . conf ( ' password ' ) , ' submit ' : ' come ▁ on ▁ in ' , } NEW_LINE DEDENT
def loginSuccess ( self , output ) : NEW_LINE INDENT return ' / inbox ' in output . lower ( ) NEW_LINE DEDENT
def assertMessageHasHeaders ( self , message , headers ) : NEW_LINE INDENT """ STRNEWLINE ▁ Asserts ▁ that ▁ the ▁ ` message ` ▁ has ▁ all ▁ ` headers ` . STRNEWLINE STRNEWLINE ▁ message : ▁ can ▁ be ▁ an ▁ instance ▁ of ▁ an ▁ email . Message ▁ subclass ▁ or ▁ a ▁ string STRNEWLINE ▁ with ▁ the ▁ contents ▁ of ▁ an ▁ email ▁ message . STRNEWLINE ▁ headers : ▁ should ▁ be ▁ a ▁ set ▁ of ▁ ( header - name , ▁ header - value ) ▁ tuples . STRNEWLINE ▁ """ NEW_LINE if isinstance ( message , bytes ) : NEW_LINE INDENT message = message_from_bytes ( message ) NEW_LINE DEDENT msg_headers = set ( message . items ( ) ) NEW_LINE self . assertTrue ( headers . issubset ( msg_headers ) , msg = ' Message ▁ is ▁ missing ▁ ' ' the ▁ following ▁ headers : ▁ % s ' % ( headers - msg_headers ) , ) NEW_LINE DEDENT
def get_decoded_attachments ( self , django_message ) : NEW_LINE INDENT """ STRNEWLINE ▁ Encode ▁ the ▁ specified ▁ django . core . mail . message . EmailMessage , ▁ then ▁ decode STRNEWLINE ▁ it ▁ using ▁ Python ' s ▁ email . parser ▁ module ▁ and , ▁ for ▁ each ▁ attachment ▁ of ▁ the STRNEWLINE ▁ message , ▁ return ▁ a ▁ list ▁ of ▁ tuples ▁ with ▁ ( filename , ▁ content , ▁ mimetype ) . STRNEWLINE ▁ """ NEW_LINE msg_bytes = django_message . message ( ) . as_bytes ( ) NEW_LINE email_message = message_from_bytes ( msg_bytes ) NEW_LINE def iter_attachments ( ) : NEW_LINE INDENT for i in email_message . walk ( ) : NEW_LINE # ▁ Once ▁ support ▁ for ▁ Python < 3.5 ▁ has ▁ been ▁ dropped , ▁ we ▁ can ▁ use ENDCOM # ▁ i . get _ content _ disposition ( ) ▁ here ▁ instead . ENDCOM INDENT content_disposition = i . get ( ' content - disposition ' , ' ' ) . split ( ' ; ' ) [ 0 ] . lower ( ) NEW_LINE if content_disposition == ' attachment ' : NEW_LINE INDENT filename = i . get_filename ( ) NEW_LINE content = i . get_payload ( decode = True ) NEW_LINE mimetype = i . get_content_type ( ) NEW_LINE yield filename , content , mimetype NEW_LINE DEDENT DEDENT DEDENT return list ( iter_attachments ( ) ) NEW_LINE DEDENT
def test_ascii ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' to @ example . com ' ) NEW_LINE DEDENT
def test_multiple_recipients ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' to @ example . com , ▁ other @ example . com ' ) NEW_LINE DEDENT
def test_recipients_with_empty_strings ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Empty ▁ strings ▁ in ▁ various ▁ recipient ▁ arguments ▁ are ▁ always ▁ stripped STRNEWLINE ▁ off ▁ the ▁ final ▁ recipient ▁ list . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' ' ] , cc = [ ' cc @ example . com ' , ' ' ] , bcc = [ ' ' , ' bcc @ example . com ' ] , reply_to = [ ' ' , None ] , ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' cc @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT
def test_cc ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 7722 """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , cc = [ ' cc @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' cc @ example . com ' ] ) NEW_LINE # ▁ Test ▁ multiple ▁ CC ▁ with ▁ multiple ▁ To ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] , cc = [ ' cc @ example . com ' , ' cc . other @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' ] ) NEW_LINE # ▁ Testing ▁ with ▁ Bcc ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] , cc = [ ' cc @ example . com ' , ' cc . other @ example . com ' ] , bcc = [ ' bcc @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT
def test_reply_to ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' reply _ to @ example . com ' ] , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' reply _ to @ example . com ' ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' reply _ to1 @ example . com ' , ' reply _ to2 @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' reply _ to1 @ example . com , ▁ reply _ to2 @ example . com ' ) NEW_LINE DEDENT
def test_recipients_as_tuple ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , ( ' to @ example . com ' , ' other @ example . com ' ) , cc = ( ' cc @ example . com ' , ' cc . other @ example . com ' ) , bcc = ( ' bcc @ example . com ' , ) ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT
def test_recipients_as_string ( self ) : NEW_LINE INDENT with self . assertRaisesMessage ( TypeError , ' " to " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( to = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " cc " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( cc = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " bcc " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( bcc = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " reply _ to " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( reply_to = ' reply _ to @ example . com ' ) NEW_LINE DEDENT DEDENT
def test_header_injection ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject \n Injection ▁ Test ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT email . message ( ) NEW_LINE DEDENT email = EmailMessage ( gettext_lazy ( ' Subject \n Injection ▁ Test ' ) , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT email . message ( ) NEW_LINE DEDENT DEDENT
def test_space_continuation ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ for ▁ space ▁ continuation ▁ character ▁ in ▁ long ▁ ( ASCII ) ▁ subject ▁ headers ▁ ( # 7747 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Long ▁ subject ▁ lines ▁ that ▁ get ▁ wrapped ▁ should ▁ contain ▁ a ▁ space ▁ ' ' continuation ▁ character ▁ to ▁ get ▁ expected ▁ behavior ▁ in ▁ Outlook ▁ and ▁ Thunderbird ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] . encode ( ) , b ' Long ▁ subject ▁ lines ▁ that ▁ get ▁ wrapped ▁ should ▁ contain ▁ a ▁ space ▁ continuation \n ' b ' ▁ character ▁ to ▁ get ▁ expected ▁ behavior ▁ in ▁ Outlook ▁ and ▁ Thunderbird ' ) NEW_LINE DEDENT
def test_message_header_overrides ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Specifying ▁ dates ▁ or ▁ message - ids ▁ in ▁ the ▁ extra ▁ headers ▁ overrides ▁ the STRNEWLINE ▁ default ▁ values ▁ ( # 9233 ) STRNEWLINE ▁ """ NEW_LINE headers = { " date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE email = EmailMessage ( ' subject ' , ' content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , headers = headers ) NEW_LINE self . assertMessageHasHeaders ( email . message ( ) , { ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' MIME - Version ' , '1.0' ) , ( ' Message - ID ' , ' foo ' ) , ( ' Subject ' , ' subject ' ) , ( ' To ' , ' to @ example . com ' ) , ( ' date ' , ' Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000' ) , } ) NEW_LINE DEDENT
def test_from_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ we ▁ can ▁ manually ▁ set ▁ the ▁ From ▁ header ▁ ( # 9214 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE DEDENT
def test_to_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ we ▁ can ▁ manually ▁ set ▁ the ▁ To ▁ header ▁ ( # 17444 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] , headers = { ' To ' : ' mailing - list @ example . com ' } ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' mailing - list @ example . com ' ) NEW_LINE self . assertEqual ( email . to , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE # ▁ If ▁ we ▁ don ' t ▁ set ▁ the ▁ To ▁ header ▁ manually , ▁ it ▁ should ▁ default ▁ to ▁ the ▁ ` to ` ▁ argument ▁ to ▁ the ▁ constructor ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' list - subscriber @ example . com , ▁ list - subscriber2 @ example . com ' ) NEW_LINE self . assertEqual ( email . to , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE DEDENT
def test_reply_to_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Specifying ▁ ' Reply - To ' ▁ in ▁ headers ▁ should ▁ override ▁ reply _ to . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' foo @ example . com ' ] , headers = { ' Reply - To ' : ' override @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' override @ example . com ' ) NEW_LINE DEDENT
def test_multiple_message_call ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 13259 ▁ - ▁ Make ▁ sure ▁ that ▁ headers ▁ are ▁ not ▁ changed ▁ when STRNEWLINE ▁ calling ▁ EmailMessage . message ( ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE DEDENT
def test_unicode_address_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 11144 ▁ - ▁ When ▁ a ▁ to / from / cc ▁ header ▁ contains ▁ unicode , STRNEWLINE ▁ make ▁ sure ▁ the ▁ email ▁ addresses ▁ are ▁ parsed ▁ correctly ▁ ( especially ▁ with STRNEWLINE ▁ regards ▁ to ▁ commas ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' " Firstname ▁ Sürname " ▁ < to @ example . com > ' , ' other @ example . com ' ] , ) NEW_LINE self . assertEqual ( email . message ( ) [ ' To ' ] , ' = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < to @ example . com > , ▁ other @ example . com ' ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' " Sürname , ▁ Firstname " ▁ < to @ example . com > ' , ' other @ example . com ' ] , ) NEW_LINE self . assertEqual ( email . message ( ) [ ' To ' ] , ' = ? utf - 8 ? q ? S = C3 = BCrname = 2C _ Firstname ? = ▁ < to @ example . com > , ▁ other @ example . com ' ) NEW_LINE DEDENT
def test_unicode_headers ( self ) : NEW_LINE INDENT email = EmailMessage ( " Gżegżółka " , " Content " , " from @ example . com " , [ " to @ example . com " ] , headers = { " Sender " : ' " Firstname ▁ Sürname " ▁ < sender @ example . com > ' , " Comments " : ' My ▁ Sürname ▁ is ▁ non - ASCII ' } ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' = ? utf - 8 ? b ? R8W8ZWfFvMOzxYJrYQ = = ? = ' ) NEW_LINE self . assertEqual ( message [ ' Sender ' ] , ' = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < sender @ example . com > ' ) NEW_LINE self . assertEqual ( message [ ' Comments ' ] , ' = ? utf - 8 ? q ? My _ S = C3 = BCrname _ is _ non - ASCII ? = ' ) NEW_LINE DEDENT
def test_safe_mime_multipart ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ headers ▁ can ▁ be ▁ set ▁ with ▁ a ▁ different ▁ encoding ▁ than ▁ utf - 8 ▁ in STRNEWLINE ▁ SafeMIMEMultipart ▁ as ▁ well STRNEWLINE ▁ """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE from_email , to = ' from @ example . com ' , ' " Sürname , ▁ Firstname " ▁ < to @ example . com > ' NEW_LINE text_content = ' This ▁ is ▁ an ▁ important ▁ message . ' NEW_LINE html_content = ' < p > This ▁ is ▁ an ▁ < strong > important < / strong > ▁ message . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( ' Message ▁ from ▁ Firstname ▁ Sürname ' , text_content , from_email , [ to ] , headers = headers ) NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE msg . encoding = ' iso - 8859-1' NEW_LINE self . assertEqual ( msg . message ( ) [ ' To ' ] , ' = ? iso - 8859-1 ? q ? S = FCrname = 2C _ Firstname ? = ▁ < to @ example . com > ' ) NEW_LINE self . assertEqual ( msg . message ( ) [ ' Subject ' ] , ' = ? iso - 8859-1 ? q ? Message _ from _ Firstname _ S = FCrname ? = ' ) NEW_LINE DEDENT
def test_encoding ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 12791 ▁ - ▁ Encode ▁ body ▁ correctly ▁ with ▁ other ▁ encodings STRNEWLINE ▁ than ▁ utf - 8 STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Firstname ▁ Sürname ▁ is ▁ a ▁ great ▁ guy . ' , ' from @ example . com ' , [ ' other @ example . com ' ] ) NEW_LINE email . encoding = ' iso - 8859-1' NEW_LINE message = email . message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' other @ example . com ' ) } ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Firstname ▁ S = FCrname ▁ is ▁ a ▁ great ▁ guy . ' ) NEW_LINE # ▁ Make ▁ sure ▁ MIME ▁ attachments ▁ also ▁ works ▁ correctly ▁ with ▁ other ▁ encodings ▁ than ▁ utf - 8 ENDCOM text_content = ' Firstname ▁ Sürname ▁ is ▁ a ▁ great ▁ guy . ' NEW_LINE html_content = ' < p > Firstname ▁ Sürname ▁ is ▁ a ▁ < strong > great < / strong > ▁ guy . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( ' Subject ' , text_content , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . encoding = ' iso - 8859-1' NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE payload0 = msg . message ( ) . get_payload ( 0 ) NEW_LINE self . assertMessageHasHeaders ( payload0 , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) } ) NEW_LINE self . assertTrue ( payload0 . as_bytes ( ) . endswith ( b ' \n \n Firstname ▁ S = FCrname ▁ is ▁ a ▁ great ▁ guy . ' ) ) NEW_LINE payload1 = msg . message ( ) . get_payload ( 1 ) NEW_LINE self . assertMessageHasHeaders ( payload1 , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / html ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) } ) NEW_LINE self . assertTrue ( payload1 . as_bytes ( ) . endswith ( b ' \n \n < p > Firstname ▁ S = FCrname ▁ is ▁ a ▁ < strong > great < / strong > ▁ guy . < / p > ' ) ) NEW_LINE DEDENT
def test_attachments ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 9367 """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE subject , from_email , to = ' hello ' , ' from @ example . com ' , ' to @ example . com ' NEW_LINE text_content = ' This ▁ is ▁ an ▁ important ▁ message . ' NEW_LINE html_content = ' < p > This ▁ is ▁ an ▁ < strong > important < / strong > ▁ message . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( subject , text_content , from_email , [ to ] , headers = headers ) NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE msg . attach ( " an ▁ attachment . pdf " , b " % PDF - 1.4 . % . . . " , mimetype = " application / pdf " ) NEW_LINE msg_bytes = msg . message ( ) . as_bytes ( ) NEW_LINE message = message_from_bytes ( msg_bytes ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( message . get_content_type ( ) , ' multipart / mixed ' ) NEW_LINE self . assertEqual ( message . get_default_type ( ) , ' text / plain ' ) NEW_LINE payload = message . get_payload ( ) NEW_LINE self . assertEqual ( payload [ 0 ] . get_content_type ( ) , ' multipart / alternative ' ) NEW_LINE self . assertEqual ( payload [ 1 ] . get_content_type ( ) , ' application / pdf ' ) NEW_LINE DEDENT
def test_non_ascii_attachment_filename ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 14964 """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE subject , from_email , to = ' hello ' , ' from @ example . com ' , ' to @ example . com ' NEW_LINE content = ' This ▁ is ▁ the ▁ message . ' NEW_LINE msg = EmailMessage ( subject , content , from_email , [ to ] , headers = headers ) NEW_LINE # ▁ Unicode ▁ in ▁ file ▁ name ENDCOM msg . attach ( " une ▁ pièce ▁ jointe . pdf " , b " % PDF - 1.4 . % . . . " , mimetype = " application / pdf " ) NEW_LINE msg_bytes = msg . message ( ) . as_bytes ( ) NEW_LINE message = message_from_bytes ( msg_bytes ) NEW_LINE payload = message . get_payload ( ) NEW_LINE self . assertEqual ( payload [ 1 ] . get_filename ( ) , ' une ▁ pièce ▁ jointe . pdf ' ) NEW_LINE DEDENT
def test_attach_file ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ attaching ▁ a ▁ file ▁ against ▁ different ▁ mimetypes ▁ and ▁ make ▁ sure ▁ that STRNEWLINE ▁ a ▁ file ▁ will ▁ be ▁ attached ▁ and ▁ sent ▁ properly ▁ even ▁ if ▁ an ▁ invalid ▁ mimetype STRNEWLINE ▁ is ▁ specified . STRNEWLINE ▁ """ NEW_LINE files = ( # ▁ filename , ▁ actual ▁ mimetype ENDCOM ( ' file . txt ' , ' text / plain ' ) , ( ' file . png ' , ' image / png ' ) , ( ' file _ txt ' , None ) , ( ' file _ png ' , None ) , ( ' file _ txt . png ' , ' image / png ' ) , ( ' file _ png . txt ' , ' text / plain ' ) , ( ' file . eml ' , ' message / rfc822' ) , ) NEW_LINE test_mimetypes = [ ' text / plain ' , ' image / png ' , None ] NEW_LINE for basename , real_mimetype in files : NEW_LINE INDENT for mimetype in test_mimetypes : NEW_LINE INDENT email = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertEqual ( mimetypes . guess_type ( basename ) [ 0 ] , real_mimetype ) NEW_LINE self . assertEqual ( email . attachments , [ ] ) NEW_LINE file_path = os . path . join ( os . path . dirname ( __file__ ) , ' attachments ' , basename ) NEW_LINE email . attach_file ( file_path , mimetype = mimetype ) NEW_LINE self . assertEqual ( len ( email . attachments ) , 1 ) NEW_LINE self . assertIn ( basename , email . attachments [ 0 ] ) NEW_LINE msgs_sent_num = email . send ( ) NEW_LINE self . assertEqual ( msgs_sent_num , 1 ) NEW_LINE DEDENT DEDENT DEDENT
def test_attach_text_as_bytes ( self ) : NEW_LINE INDENT msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' file ▁ content ' ) NEW_LINE sent_num = msg . send ( ) NEW_LINE self . assertEqual ( sent_num , 1 ) NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE self . assertEqual ( content , b ' file ▁ content ' ) NEW_LINE self . assertEqual ( mimetype , ' text / plain ' ) NEW_LINE DEDENT
def test_attach_utf8_text_as_bytes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Non - ASCII ▁ characters ▁ encoded ▁ as ▁ valid ▁ UTF - 8 ▁ are ▁ correctly ▁ transported STRNEWLINE ▁ and ▁ decoded . STRNEWLINE ▁ """ NEW_LINE msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' \xc3\xa4' ) # ▁ UTF - 8 ▁ encoded ▁ a ▁ umlaut . ENDCOM NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE self . assertEqual ( content , b ' \xc3\xa4' ) NEW_LINE self . assertEqual ( mimetype , ' text / plain ' ) NEW_LINE DEDENT
def test_attach_non_utf8_text_as_bytes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Binary ▁ data ▁ that ▁ can ' t ▁ be ▁ decoded ▁ as ▁ UTF - 8 ▁ overrides ▁ the ▁ MIME ▁ type STRNEWLINE ▁ instead ▁ of ▁ decoding ▁ the ▁ data . STRNEWLINE ▁ """ NEW_LINE msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' \xff ' ) # ▁ Invalid ▁ UTF - 8 . ENDCOM NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE # ▁ Content ▁ should ▁ be ▁ passed ▁ through ▁ unmodified . ENDCOM self . assertEqual ( content , b ' \xff ' ) NEW_LINE self . assertEqual ( mimetype , ' application / octet - stream ' ) NEW_LINE DEDENT
def test_dummy_backend ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ dummy ▁ backends ▁ returns ▁ correct ▁ number ▁ of ▁ sent ▁ messages STRNEWLINE ▁ """ NEW_LINE connection = dummy . EmailBackend ( ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertEqual ( connection . send_messages ( [ email , email , email ] ) , 3 ) NEW_LINE DEDENT
def test_arbitrary_keyword ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ get _ connection ( ) ▁ accepts ▁ arbitrary ▁ keyword ▁ that ▁ might ▁ be STRNEWLINE ▁ used ▁ with ▁ custom ▁ backends . STRNEWLINE ▁ """ NEW_LINE c = mail . get_connection ( fail_silently = True , foo = ' bar ' ) NEW_LINE self . assertTrue ( c . fail_silently ) NEW_LINE DEDENT
def test_custom_backend ( self ) : NEW_LINE INDENT """ Test ▁ custom ▁ backend ▁ defined ▁ in ▁ this ▁ suite . """ NEW_LINE conn = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE self . assertTrue ( hasattr ( conn , ' test _ outbox ' ) ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE conn . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( len ( conn . test_outbox ) , 1 ) NEW_LINE DEDENT
def test_backend_arg ( self ) : NEW_LINE INDENT """ Test ▁ backend ▁ argument ▁ of ▁ mail . get _ connection ( ) """ NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . smtp . EmailBackend ' ) , smtp . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . locmem . EmailBackend ' ) , locmem . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . dummy . EmailBackend ' ) , dummy . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . console . EmailBackend ' ) , console . EmailBackend ) NEW_LINE with tempfile . TemporaryDirectory ( ) as tmp_dir : NEW_LINE INDENT self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . filebased . EmailBackend ' , file_path = tmp_dir ) , filebased . EmailBackend ) NEW_LINE DEDENT self . assertIsInstance ( mail . get_connection ( ) , locmem . EmailBackend ) NEW_LINE DEDENT
def test_connection_arg ( self ) : NEW_LINE INDENT """ Test ▁ connection ▁ argument ▁ to ▁ send _ mail ( ) , ▁ et . ▁ al . """ NEW_LINE mail . outbox = [ ] NEW_LINE # ▁ Send ▁ using ▁ non - default ▁ connection ENDCOM connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' Subject ' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE send_mass_mail ( [ ( ' Subject1' , ' Content1' , ' from1 @ example . com ' , [ ' to1 @ example . com ' ] ) , ( ' Subject2' , ' Content2' , ' from2 @ example . com ' , [ ' to2 @ example . com ' ] ) , ] , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 2 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' Subject1' ) NEW_LINE self . assertEqual ( connection . test_outbox [ 1 ] . subject , ' Subject2' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE mail_admins ( ' Admin ▁ message ' , ' Content ' , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' [ Django ] ▁ Admin ▁ message ' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE mail_managers ( ' Manager ▁ message ' , ' Content ' , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' [ Django ] ▁ Manager ▁ message ' ) NEW_LINE DEDENT
def test_dont_mangle_from_in_body ( self ) : NEW_LINE # ▁ Regression ▁ for ▁ # 13433 ▁ - ▁ Make ▁ sure ▁ that ▁ EmailMessage ▁ doesn ' t ▁ mangle ENDCOM # ▁ ' From ▁ ' ▁ in ▁ message ▁ body . ENDCOM INDENT email = EmailMessage ( ' Subject ' , ' From ▁ the ▁ future ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertNotIn ( b ' > From ▁ the ▁ future ' , email . message ( ) . as_bytes ( ) ) NEW_LINE DEDENT
def test_dont_base64_encode ( self ) : NEW_LINE # ▁ Ticket ▁ # 3472 ENDCOM # ▁ Shouldn ' t ▁ use ▁ Base64 ▁ encoding ▁ at ▁ all ENDCOM INDENT msg = EmailMessage ( ' Subject ' , ' UTF - 8 ▁ encoded ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 7bit ' , msg . message ( ) . as_bytes ( ) ) NEW_LINE # ▁ Ticket ▁ # 11212 ENDCOM # ▁ Shouldn ' t ▁ use ▁ quoted ▁ printable , ▁ should ▁ detect ▁ it ▁ can ▁ represent ▁ content ▁ with ▁ 7 ▁ bit ▁ data ENDCOM msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ only ▁ ASCII ▁ characters . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 7bit ' , s ) NEW_LINE # ▁ Shouldn ' t ▁ use ▁ quoted ▁ printable , ▁ should ▁ detect ▁ it ▁ can ▁ represent ▁ content ▁ with ▁ 8 ▁ bit ▁ data ENDCOM msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ latin ▁ characters : ▁ àáä . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE s = msg . message ( ) . as_string ( ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ non ▁ latin ▁ characters : ▁ А ▁ Б ▁ В ▁ Г ▁ Д ▁ Е ▁ Ж ▁ Ѕ ▁ З ▁ И ▁ І ▁ К ▁ Л ▁ М ▁ Н ▁ О ▁ П . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE s = msg . message ( ) . as_string ( ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE DEDENT
def test_dont_base64_encode_message_rfc822 ( self ) : NEW_LINE # ▁ Ticket ▁ # 18967 ENDCOM # ▁ Shouldn ' t ▁ use ▁ base64 ▁ encoding ▁ for ▁ a ▁ child ▁ EmailMessage ▁ attachment . ENDCOM # ▁ Create ▁ a ▁ child ▁ message ▁ first ENDCOM INDENT child_msg = EmailMessage ( ' Child ▁ Subject ' , ' Some ▁ body ▁ of ▁ child ▁ message ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE child_s = child_msg . message ( ) . as_string ( ) NEW_LINE # ▁ Now ▁ create ▁ a ▁ parent ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE # ▁ Attach ▁ to ▁ parent ▁ as ▁ a ▁ string ENDCOM parent_msg . attach ( content = child_s , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE # ▁ Feature ▁ test : ▁ try ▁ attaching ▁ email . Message ▁ object ▁ directly ▁ to ▁ the ▁ mail . ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE parent_msg . attach ( content = child_msg . message ( ) , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE # ▁ Feature ▁ test : ▁ try ▁ attaching ▁ Django ' s ▁ EmailMessage ▁ object ▁ directly ▁ to ▁ the ▁ mail . ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE parent_msg . attach ( content = child_msg , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE DEDENT
def test_sanitize_address ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ addresses ▁ are ▁ properly ▁ sanitized . STRNEWLINE ▁ """ NEW_LINE # ▁ Simple ▁ ASCII ▁ address ▁ - ▁ string ▁ form ENDCOM self . assertEqual ( sanitize_address ( ' to @ example . com ' , ' ascii ' ) , ' to @ example . com ' ) NEW_LINE self . assertEqual ( sanitize_address ( ' to @ example . com ' , ' utf - 8' ) , ' to @ example . com ' ) NEW_LINE # ▁ Simple ▁ ASCII ▁ address ▁ - ▁ tuple ▁ form ENDCOM self . assertEqual ( sanitize_address ( ( ' A ▁ name ' , ' to @ example . com ' ) , ' ascii ' ) , ' A ▁ name ▁ < to @ example . com > ' ) NEW_LINE self . assertEqual ( sanitize_address ( ( ' A ▁ name ' , ' to @ example . com ' ) , ' utf - 8' ) , ' = ? utf - 8 ? q ? A _ name ? = ▁ < to @ example . com > ' ) NEW_LINE # ▁ Unicode ▁ characters ▁ are ▁ are ▁ supported ▁ in ▁ RFC - 6532 . ENDCOM self . assertEqual ( sanitize_address ( ' tó @ example . com ' , ' utf - 8' ) , ' = ? utf - 8 ? b ? dMOz ? = @ example . com ' ) NEW_LINE self . assertEqual ( sanitize_address ( ( ' Tó ▁ Example ' , ' tó @ example . com ' ) , ' utf - 8' ) , ' = ? utf - 8 ? q ? T = C3 = B3 _ Example ? = ▁ < = ? utf - 8 ? b ? dMOz ? = @ example . com > ' ) NEW_LINE DEDENT
def test_date_header_utc ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ EMAIL _ USE _ LOCALTIME = False ▁ creates ▁ a ▁ datetime ▁ in ▁ UTC . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertTrue ( email . message ( ) [ ' Date ' ] . endswith ( ' - 0000' ) ) NEW_LINE DEDENT
def test_date_header_localtime ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ EMAIL _ USE _ LOCALTIME = True ▁ creates ▁ a ▁ datetime ▁ in ▁ the ▁ local ▁ time ▁ zone . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertTrue ( email . message ( ) [ ' Date ' ] . endswith ( ' + 0100' ) ) # ▁ Africa / Algiers ▁ is ▁ UTC + 1 ENDCOM NEW_LINE DEDENT
def test_utf8 ( self ) : NEW_LINE INDENT txt = MIMEText ( ' UTF - 8 ▁ encoded ▁ body ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT
def test_7bit ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ only ▁ ASCII ▁ characters . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT
def test_8bit_latin ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ latin ▁ characters : ▁ àáä . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT
def test_8bit_non_latin ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ non ▁ latin ▁ characters : ▁ А ▁ Б ▁ В ▁ Г ▁ Д ▁ Е ▁ Ж ▁ Ѕ ▁ З ▁ И ▁ І ▁ К ▁ Л ▁ М ▁ Н ▁ О ▁ П . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT self . settings_override = override_settings ( EMAIL_BACKEND = self . email_backend ) NEW_LINE self . settings_override . enable ( ) NEW_LINE DEDENT
def tearDown ( self ) : NEW_LINE INDENT self . settings_override . disable ( ) NEW_LINE DEDENT
def assertStartsWith ( self , first , second ) : NEW_LINE INDENT if not first . startswith ( second ) : NEW_LINE INDENT self . longMessage = True NEW_LINE self . assertEqual ( first [ : len ( second ) ] , second , " First ▁ string ▁ doesn ' t ▁ start ▁ with ▁ the ▁ second . " ) NEW_LINE DEDENT DEDENT
def get_mailbox_content ( self ) : NEW_LINE INDENT raise NotImplementedError ( ' subclasses ▁ of ▁ BaseEmailBackendTests ▁ must ▁ provide ▁ a ▁ get _ mailbox _ content ( ) ▁ method ' ) NEW_LINE DEDENT
def flush_mailbox ( self ) : NEW_LINE INDENT raise NotImplementedError ( ' subclasses ▁ of ▁ BaseEmailBackendTests ▁ may ▁ require ▁ a ▁ flush _ mailbox ( ) ▁ method ' ) NEW_LINE DEDENT
def get_the_message ( self ) : NEW_LINE INDENT mailbox = self . get_mailbox_content ( ) NEW_LINE self . assertEqual ( len ( mailbox ) , 1 , " Expected ▁ exactly ▁ one ▁ message , ▁ got ▁ % d . \n % r " % ( len ( mailbox ) , [ m . as_string ( ) for m in mailbox ] ) ) NEW_LINE return mailbox [ 0 ] NEW_LINE DEDENT
def test_send ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE num_sent = mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( num_sent , 1 ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , " Subject " ) NEW_LINE self . assertEqual ( message . get_payload ( ) , " Content " ) NEW_LINE self . assertEqual ( message [ " from " ] , " from @ example . com " ) NEW_LINE self . assertEqual ( message . get_all ( " to " ) , [ " to @ example . com " ] ) NEW_LINE DEDENT
def test_send_unicode ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Chère ▁ maman ' , ' Je ▁ t\ ' aime ▁ très ▁ fort ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE num_sent = mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( num_sent , 1 ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , ' = ? utf - 8 ? q ? Ch = C3 = A8re _ maman ? = ' ) NEW_LINE self . assertEqual ( force_text ( message . get_payload ( decode = True ) ) , ' Je ▁ t\ ' aime ▁ très ▁ fort ' ) NEW_LINE DEDENT
def test_send_long_lines ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ line ▁ length ▁ is ▁ limited ▁ to ▁ 998 ▁ chars ▁ by ▁ the ▁ RFC : STRNEWLINE ▁ https : / / tools . ietf . org / html / rfc5322 # section - 2.1.1 STRNEWLINE ▁ Message ▁ body ▁ containing ▁ longer ▁ lines ▁ are ▁ converted ▁ to ▁ Quoted - Printable STRNEWLINE ▁ to ▁ avoid ▁ having ▁ to ▁ insert ▁ newlines , ▁ which ▁ could ▁ be ▁ hairy ▁ to ▁ do ▁ properly . STRNEWLINE ▁ """ NEW_LINE # ▁ Unencoded ▁ body ▁ length ▁ is ▁ < ▁ 998 ▁ ( 840 ) ▁ but ▁ > ▁ 998 ▁ when ▁ utf - 8 ▁ encoded . ENDCOM email = EmailMessage ( ' Subject ' , ' В ▁ южных ▁ морях ▁ ' * 60 , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE email . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) , } ) NEW_LINE DEDENT
def test_send_many ( self ) : NEW_LINE INDENT email1 = EmailMessage ( ' Subject ' , ' Content1' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE email2 = EmailMessage ( ' Subject ' , ' Content2' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE # ▁ send _ messages ( ) ▁ may ▁ take ▁ a ▁ list ▁ or ▁ a ▁ generator . ENDCOM emails_lists = ( [ email1 , email2 ] , ( email for email in [ email1 , email2 ] ) ) NEW_LINE for emails_list in emails_lists : NEW_LINE INDENT num_sent = mail . get_connection ( ) . send_messages ( emails_list ) NEW_LINE self . assertEqual ( num_sent , 2 ) NEW_LINE messages = self . get_mailbox_content ( ) NEW_LINE self . assertEqual ( len ( messages ) , 2 ) NEW_LINE self . assertEqual ( messages [ 0 ] . get_payload ( ) , ' Content1' ) NEW_LINE self . assertEqual ( messages [ 1 ] . get_payload ( ) , ' Content2' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE DEDENT DEDENT
def test_send_verbose_name ( self ) : NEW_LINE INDENT email = EmailMessage ( " Subject " , " Content " , ' " Firstname ▁ Sürname " ▁ < from @ example . com > ' , [ " to @ example . com " ] ) NEW_LINE email . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , " Subject " ) NEW_LINE self . assertEqual ( message . get_payload ( ) , " Content " ) NEW_LINE self . assertEqual ( message [ " from " ] , " = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < from @ example . com > " ) NEW_LINE DEDENT
def test_plaintext_send_mail ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ send _ mail ▁ without ▁ the ▁ html _ message STRNEWLINE ▁ regression ▁ test ▁ for ▁ adding ▁ html _ message ▁ parameter ▁ to ▁ send _ mail ( ) STRNEWLINE ▁ """ NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' sender @ example . com ' , [ ' nobody @ example . com ' ] ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertFalse ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_content_type ( ) , ' text / plain ' ) NEW_LINE DEDENT
def test_html_send_mail ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ send _ mail """ NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' sender @ example . com ' , [ ' nobody @ example . com ' ] , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT
def test_html_mail_managers ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ mail _ managers """ NEW_LINE mail_managers ( ' Subject ' , ' Content ' , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT
def test_html_mail_admins ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ mail _ admins ▁ """ NEW_LINE mail_admins ( ' Subject ' , ' Content ' , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT
def test_manager_and_admin_mail_prefix ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ String ▁ prefix ▁ + ▁ lazy ▁ translated ▁ subject ▁ = ▁ bad ▁ output STRNEWLINE ▁ Regression ▁ for ▁ # 13494 STRNEWLINE ▁ """ NEW_LINE mail_managers ( gettext_lazy ( ' Subject ' ) , ' Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE mail_admins ( gettext_lazy ( ' Subject ' ) , ' Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE DEDENT
def test_empty_admins ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ mail _ admins / mail _ managers ▁ doesn ' t ▁ connect ▁ to ▁ the ▁ mail ▁ server STRNEWLINE ▁ if ▁ there ▁ are ▁ no ▁ recipients ▁ ( # 9383 ) STRNEWLINE ▁ """ NEW_LINE mail_admins ( ' hi ' , ' there ' ) NEW_LINE self . assertEqual ( self . get_mailbox_content ( ) , [ ] ) NEW_LINE mail_managers ( ' hi ' , ' there ' ) NEW_LINE self . assertEqual ( self . get_mailbox_content ( ) , [ ] ) NEW_LINE DEDENT
def test_message_cc_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 7722 STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , cc = [ ' cc @ example . com ' ] ) NEW_LINE mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' to @ example . com ' ) , ( ' Cc ' , ' cc @ example . com ' ) } ) NEW_LINE self . assertIn ( ' \n Date : ▁ ' , message . as_string ( ) ) NEW_LINE DEDENT
def test_idn_send ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 14301 STRNEWLINE ▁ """ NEW_LINE self . assertTrue ( send_mail ( ' Subject ' , ' Content ' , ' from @ öäü . com ' , [ ' to @ öäü . com ' ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ xn - -4ca9at . com ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE m = EmailMessage ( ' Subject ' , ' Content ' , ' from @ öäü . com ' , [ ' to @ öäü . com ' ] , cc = [ ' cc @ öäü . com ' ] ) NEW_LINE m . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' cc ' ) , ' cc @ xn - -4ca9at . com ' ) NEW_LINE DEDENT
def test_recipient_without_domain ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 15042 STRNEWLINE ▁ """ NEW_LINE self . assertTrue ( send_mail ( " Subject " , " Content " , " tester " , [ " django " ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , " tester " ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , " django " ) NEW_LINE DEDENT
def test_lazy_addresses ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ sending ▁ should ▁ support ▁ lazy ▁ email ▁ addresses ▁ ( # 24416 ) . STRNEWLINE ▁ """ NEW_LINE _ = gettext_lazy NEW_LINE self . assertTrue ( send_mail ( ' Subject ' , ' Content ' , _ ( ' tester ' ) , [ _ ( ' django ' ) ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' tester ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' django ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE m = EmailMessage ( ' Subject ' , ' Content ' , _ ( ' tester ' ) , [ _ ( ' to1' ) , _ ( ' to2' ) ] , cc = [ _ ( ' cc1' ) , _ ( ' cc2' ) ] , bcc = [ _ ( ' bcc ' ) ] , reply_to = [ _ ( ' reply ' ) ] , ) NEW_LINE self . assertEqual ( m . recipients ( ) , [ ' to1' , ' to2' , ' cc1' , ' cc2' , ' bcc ' ] ) NEW_LINE m . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' tester ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to1 , ▁ to2' ) NEW_LINE self . assertEqual ( message . get ( ' cc ' ) , ' cc1 , ▁ cc2' ) NEW_LINE self . assertEqual ( message . get ( ' Reply - To ' ) , ' reply ' ) NEW_LINE DEDENT
def test_close_connection ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Connection ▁ can ▁ be ▁ closed ▁ ( even ▁ when ▁ not ▁ explicitly ▁ opened ) STRNEWLINE ▁ """ NEW_LINE conn = mail . get_connection ( username = ' ' , password = ' ' ) NEW_LINE conn . close ( ) NEW_LINE DEDENT
def test_use_as_contextmanager ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ connection ▁ can ▁ be ▁ used ▁ as ▁ a ▁ contextmanager . STRNEWLINE ▁ """ NEW_LINE opened = [ False ] NEW_LINE closed = [ False ] NEW_LINE conn = mail . get_connection ( username = ' ' , password = ' ' ) NEW_LINE def open ( ) : NEW_LINE INDENT opened [ 0 ] = True NEW_LINE DEDENT conn . open = open NEW_LINE def close ( ) : NEW_LINE INDENT closed [ 0 ] = True NEW_LINE DEDENT conn . close = close NEW_LINE with conn as same_conn : NEW_LINE INDENT self . assertTrue ( opened [ 0 ] ) NEW_LINE self . assertIs ( same_conn , conn ) NEW_LINE self . assertFalse ( closed [ 0 ] ) NEW_LINE DEDENT self . assertTrue ( closed [ 0 ] ) NEW_LINE DEDENT
def get_mailbox_content ( self ) : NEW_LINE INDENT return [ m . message ( ) for m in mail . outbox ] NEW_LINE DEDENT
def flush_mailbox ( self ) : NEW_LINE INDENT mail . outbox = [ ] NEW_LINE DEDENT
def tearDown ( self ) : NEW_LINE INDENT super ( ) . tearDown ( ) NEW_LINE mail . outbox = [ ] NEW_LINE DEDENT
def test_locmem_shared_messages ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ the ▁ locmen ▁ backend ▁ populates ▁ the ▁ outbox . STRNEWLINE ▁ """ NEW_LINE connection = locmem . EmailBackend ( ) NEW_LINE connection2 = locmem . EmailBackend ( ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE connection . send_messages ( [ email ] ) NEW_LINE connection2 . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( len ( mail . outbox ) , 2 ) NEW_LINE DEDENT
def test_validate_multiline_headers ( self ) : NEW_LINE # ▁ Ticket ▁ # 18861 ▁ - ▁ Validate ▁ emails ▁ when ▁ using ▁ the ▁ locmem ▁ backend ENDCOM INDENT with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT send_mail ( ' Subject \n Multiline ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE DEDENT DEDENT
def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . tmp_dir = tempfile . mkdtemp ( ) NEW_LINE self . addCleanup ( shutil . rmtree , self . tmp_dir ) NEW_LINE self . _settings_override = override_settings ( EMAIL_FILE_PATH = self . tmp_dir ) NEW_LINE self . _settings_override . enable ( ) NEW_LINE DEDENT
def tearDown ( self ) : NEW_LINE INDENT self . _settings_override . disable ( ) NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT
def flush_mailbox ( self ) : NEW_LINE INDENT for filename in os . listdir ( self . tmp_dir ) : NEW_LINE INDENT os . unlink ( os . path . join ( self . tmp_dir , filename ) ) NEW_LINE DEDENT DEDENT
def get_mailbox_content ( self ) : NEW_LINE INDENT messages = [ ] NEW_LINE for filename in os . listdir ( self . tmp_dir ) : NEW_LINE INDENT with open ( os . path . join ( self . tmp_dir , filename ) , ' rb ' ) as fp : NEW_LINE INDENT session = fp . read ( ) . split ( force_bytes ( ' \n ' + ( ' - ' * 79 ) + ' \n ' , encoding = ' ascii ' ) ) NEW_LINE DEDENT messages . extend ( message_from_bytes ( m ) for m in session if m ) NEW_LINE DEDENT return messages NEW_LINE DEDENT
def test_file_sessions ( self ) : NEW_LINE INDENT """ Make ▁ sure ▁ opening ▁ a ▁ connection ▁ creates ▁ a ▁ new ▁ file """ NEW_LINE msg = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE connection = mail . get_connection ( ) NEW_LINE connection . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 1 ) NEW_LINE with open ( os . path . join ( self . tmp_dir , os . listdir ( self . tmp_dir ) [ 0 ] ) , ' rb ' ) as fp : NEW_LINE INDENT message = message_from_binary_file ( fp ) NEW_LINE DEDENT self . assertEqual ( message . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ example . com ' ) NEW_LINE connection2 = mail . get_connection ( ) NEW_LINE connection2 . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 2 ) NEW_LINE connection . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 2 ) NEW_LINE msg . connection = mail . get_connection ( ) NEW_LINE self . assertTrue ( connection . open ( ) ) NEW_LINE msg . send ( ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 3 ) NEW_LINE msg . send ( ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 3 ) NEW_LINE connection . close ( ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . __stdout = sys . stdout NEW_LINE self . stream = sys . stdout = StringIO ( ) NEW_LINE DEDENT
def tearDown ( self ) : NEW_LINE INDENT del self . stream NEW_LINE sys . stdout = self . __stdout NEW_LINE del self . __stdout NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT
def flush_mailbox ( self ) : NEW_LINE INDENT self . stream = sys . stdout = StringIO ( ) NEW_LINE DEDENT
def get_mailbox_content ( self ) : NEW_LINE INDENT messages = self . stream . getvalue ( ) . split ( ' \n ' + ( ' - ' * 79 ) + ' \n ' ) NEW_LINE return [ message_from_bytes ( force_bytes ( m ) ) for m in messages if m ] NEW_LINE DEDENT
def test_console_stream_kwarg ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ console ▁ backend ▁ can ▁ be ▁ pointed ▁ at ▁ an ▁ arbitrary ▁ stream . STRNEWLINE ▁ """ NEW_LINE s = StringIO ( ) NEW_LINE connection = mail . get_connection ( ' django . core . mail . backends . console . EmailBackend ' , stream = s ) NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , connection = connection ) NEW_LINE message = force_bytes ( s . getvalue ( ) . split ( ' \n ' + ( ' - ' * 79 ) + ' \n ' ) [ 0 ] ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' to @ example . com ' ) } ) NEW_LINE self . assertIn ( b ' \n Date : ▁ ' , message ) NEW_LINE DEDENT
def collect_incoming_data ( self , data ) : NEW_LINE INDENT try : NEW_LINE INDENT smtpd . SMTPChannel . collect_incoming_data ( self , data ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE # ▁ ignore ▁ decode ▁ error ▁ in ▁ SSL / TLS ▁ connection ▁ tests ▁ as ▁ we ▁ only ▁ care ENDCOM # ▁ whether ▁ the ▁ connection ▁ attempt ▁ was ▁ made ENDCOM INDENT pass NEW_LINE DEDENT DEDENT
def smtp_AUTH ( self , arg ) : NEW_LINE INDENT if arg == ' CRAM - MD5' : NEW_LINE # ▁ This ▁ is ▁ only ▁ the ▁ first ▁ part ▁ of ▁ the ▁ login ▁ process . ▁ But ▁ it ' s ▁ enough ENDCOM # ▁ for ▁ our ▁ tests . ENDCOM INDENT challenge = base64 . b64encode ( b ' somerandomstring13579' ) NEW_LINE self . push ( '334 ▁ % s ' % challenge . decode ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . push ( '502 ▁ Error : ▁ login ▁ " % s " ▁ not ▁ implemented ' % arg ) NEW_LINE DEDENT DEDENT
def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT threading . Thread . __init__ ( self ) NEW_LINE # ▁ New ▁ kwarg ▁ added ▁ in ▁ Python ▁ 3.5 ; ▁ default ▁ switching ▁ to ▁ False ▁ in ▁ 3.6 . ENDCOM if sys . version_info >= ( 3 , 5 ) : NEW_LINE INDENT kwargs [ ' decode _ data ' ] = True NEW_LINE DEDENT smtpd . SMTPServer . __init__ ( self , * args , ** kwargs ) NEW_LINE self . _sink = [ ] NEW_LINE self . active = False NEW_LINE self . active_lock = threading . Lock ( ) NEW_LINE self . sink_lock = threading . Lock ( ) NEW_LINE DEDENT
def process_message ( self , peer , mailfrom , rcpttos , data ) : NEW_LINE INDENT data = data . encode ( ) NEW_LINE m = message_from_bytes ( data ) NEW_LINE maddr = parseaddr ( m . get ( ' from ' ) ) [ 1 ] NEW_LINE if mailfrom != maddr : NEW_LINE # ▁ According ▁ to ▁ the ▁ spec , ▁ mailfrom ▁ does ▁ not ▁ necessarily ▁ match ▁ the ENDCOM # ▁ From ▁ header ▁ - ▁ this ▁ is ▁ the ▁ case ▁ where ▁ the ▁ local ▁ part ▁ isn ' t ENDCOM # ▁ encoded , ▁ so ▁ try ▁ to ▁ correct ▁ that . ENDCOM INDENT lp , domain = mailfrom . split ( ' @ ' , 1 ) NEW_LINE lp = Header ( lp , ' utf - 8' ) . encode ( ) NEW_LINE mailfrom = ' @ ' . join ( [ lp , domain ] ) NEW_LINE DEDENT if mailfrom != maddr : NEW_LINE INDENT return "553 ▁ ' % s ' ▁ ! = ▁ ' % s ' " % ( mailfrom , maddr ) NEW_LINE DEDENT with self . sink_lock : NEW_LINE INDENT self . _sink . append ( m ) NEW_LINE DEDENT DEDENT
def get_sink ( self ) : NEW_LINE INDENT with self . sink_lock : NEW_LINE INDENT return self . _sink [ : ] NEW_LINE DEDENT DEDENT
def flush_sink ( self ) : NEW_LINE INDENT with self . sink_lock : NEW_LINE INDENT self . _sink [ : ] = [ ] NEW_LINE DEDENT DEDENT
def start ( self ) : NEW_LINE INDENT assert not self . active NEW_LINE self . __flag = threading . Event ( ) NEW_LINE threading . Thread . start ( self ) NEW_LINE self . __flag . wait ( ) NEW_LINE DEDENT
def run ( self ) : NEW_LINE INDENT self . active = True NEW_LINE self . __flag . set ( ) NEW_LINE while self . active and asyncore . socket_map : NEW_LINE INDENT with self . active_lock : NEW_LINE INDENT asyncore . loop ( timeout = 0.1 , count = 1 ) NEW_LINE DEDENT DEDENT asyncore . close_all ( ) NEW_LINE DEDENT
def stop ( self ) : NEW_LINE INDENT if self . active : NEW_LINE INDENT self . active = False NEW_LINE self . join ( ) NEW_LINE DEDENT DEDENT
def ehlo ( self , name = ' ' ) : NEW_LINE INDENT response = SMTP . ehlo ( self , name = name ) NEW_LINE self . esmtp_features . update ( { ' auth ' : ' CRAM - MD5 ▁ PLAIN ▁ LOGIN ' , } ) NEW_LINE return response NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . server . flush_sink ( ) NEW_LINE DEDENT
def tearDown ( self ) : NEW_LINE INDENT self . server . flush_sink ( ) NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT
def flush_mailbox ( self ) : NEW_LINE INDENT self . server . flush_sink ( ) NEW_LINE DEDENT
def get_mailbox_content ( self ) : NEW_LINE INDENT return self . server . get_sink ( ) NEW_LINE DEDENT
def test_email_authentication_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . username , ' not ▁ empty ▁ username ' ) NEW_LINE self . assertEqual ( backend . password , ' not ▁ empty ▁ password ' ) NEW_LINE DEDENT
def test_email_authentication_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( username = ' username ' , password = ' password ' ) NEW_LINE self . assertEqual ( backend . username , ' username ' ) NEW_LINE self . assertEqual ( backend . password , ' password ' ) NEW_LINE DEDENT
def test_email_disabled_authentication ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE self . assertEqual ( backend . username , ' ' ) NEW_LINE self . assertEqual ( backend . password , ' ' ) NEW_LINE DEDENT
def test_auth_attempted ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Opening ▁ the ▁ backend ▁ with ▁ non ▁ empty ▁ username / password ▁ tries STRNEWLINE ▁ to ▁ authenticate ▁ against ▁ the ▁ SMTP ▁ server . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( username = ' not ▁ empty ▁ username ' , password = ' not ▁ empty ▁ password ' ) NEW_LINE with self . assertRaisesMessage ( SMTPException , ' SMTP ▁ AUTH ▁ extension ▁ not ▁ supported ▁ by ▁ server . ' ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT
def test_server_open ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ open ( ) ▁ returns ▁ whether ▁ it ▁ opened ▁ a ▁ connection . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE self . assertFalse ( backend . connection ) NEW_LINE opened = backend . open ( ) NEW_LINE backend . close ( ) NEW_LINE self . assertTrue ( opened ) NEW_LINE DEDENT
def test_server_login ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Even ▁ if ▁ the ▁ Python ▁ SMTP ▁ server ▁ doesn ' t ▁ support ▁ authentication , ▁ the STRNEWLINE ▁ login ▁ process ▁ starts ▁ and ▁ the ▁ appropriate ▁ exception ▁ is ▁ raised . STRNEWLINE ▁ """ NEW_LINE class CustomEmailBackend ( smtp . EmailBackend ) : NEW_LINE INDENT connection_class = FakeAUTHSMTPConnection NEW_LINE DEDENT backend = CustomEmailBackend ( username = ' username ' , password = ' password ' ) NEW_LINE with self . assertRaises ( SMTPAuthenticationError ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT
def test_email_tls_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_tls ) NEW_LINE DEDENT
def test_email_tls_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( use_tls = False ) NEW_LINE self . assertFalse ( backend . use_tls ) NEW_LINE DEDENT
def test_email_tls_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertFalse ( backend . use_tls ) NEW_LINE DEDENT
def test_email_ssl_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_ssl ) NEW_LINE DEDENT
def test_email_ssl_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( use_ssl = False ) NEW_LINE self . assertFalse ( backend . use_ssl ) NEW_LINE DEDENT
def test_email_ssl_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertFalse ( backend . use_ssl ) NEW_LINE DEDENT
def test_email_ssl_certfile_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . ssl_certfile , ' foo ' ) NEW_LINE DEDENT
def test_email_ssl_certfile_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ssl_certfile = ' bar ' ) NEW_LINE self . assertEqual ( backend . ssl_certfile , ' bar ' ) NEW_LINE DEDENT
def test_email_ssl_certfile_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertIsNone ( backend . ssl_certfile ) NEW_LINE DEDENT
def test_email_ssl_keyfile_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . ssl_keyfile , ' foo ' ) NEW_LINE DEDENT
def test_email_ssl_keyfile_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ssl_keyfile = ' bar ' ) NEW_LINE self . assertEqual ( backend . ssl_keyfile , ' bar ' ) NEW_LINE DEDENT
def test_email_ssl_keyfile_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertIsNone ( backend . ssl_keyfile ) NEW_LINE DEDENT
def test_email_tls_attempts_starttls ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_tls ) NEW_LINE with self . assertRaisesMessage ( SMTPException , ' STARTTLS ▁ extension ▁ not ▁ supported ▁ by ▁ server . ' ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT
def test_email_ssl_attempts_ssl_connection ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_ssl ) NEW_LINE with self . assertRaises ( SSLError ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT
def test_connection_timeout_default ( self ) : NEW_LINE INDENT """ The ▁ connection ' s ▁ timeout ▁ value ▁ is ▁ None ▁ by ▁ default . """ NEW_LINE connection = mail . get_connection ( ' django . core . mail . backends . smtp . EmailBackend ' ) NEW_LINE self . assertIsNone ( connection . timeout ) NEW_LINE DEDENT
def test_connection_timeout_custom ( self ) : NEW_LINE INDENT """ The ▁ timeout ▁ parameter ▁ can ▁ be ▁ customized . """ NEW_LINE class MyEmailBackend ( smtp . EmailBackend ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT kwargs . setdefault ( ' timeout ' , 42 ) NEW_LINE super ( ) . __init__ ( * args , ** kwargs ) NEW_LINE DEDENT DEDENT myemailbackend = MyEmailBackend ( ) NEW_LINE myemailbackend . open ( ) NEW_LINE self . assertEqual ( myemailbackend . timeout , 42 ) NEW_LINE self . assertEqual ( myemailbackend . connection . timeout , 42 ) NEW_LINE myemailbackend . close ( ) NEW_LINE DEDENT
def test_email_timeout_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . timeout , 10 ) NEW_LINE DEDENT
def test_email_msg_uses_crlf ( self ) : NEW_LINE INDENT """ # 23063 ▁ - - ▁ RFC - compliant ▁ messages ▁ are ▁ sent ▁ over ▁ SMTP . """ NEW_LINE send = SMTP . send NEW_LINE try : NEW_LINE INDENT smtp_messages = [ ] NEW_LINE def mock_send ( self , s ) : NEW_LINE INDENT smtp_messages . append ( s ) NEW_LINE return send ( self , s ) NEW_LINE DEDENT SMTP . send = mock_send NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE # ▁ Find ▁ the ▁ actual ▁ message ENDCOM msg = None NEW_LINE for i , m in enumerate ( smtp_messages ) : NEW_LINE INDENT if m [ : 4 ] == ' data ' : NEW_LINE INDENT msg = smtp_messages [ i + 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT self . assertTrue ( msg ) NEW_LINE msg = msg . decode ( ) NEW_LINE # ▁ The ▁ message ▁ only ▁ contains ▁ CRLF ▁ and ▁ not ▁ combinations ▁ of ▁ CRLF , ▁ LF , ▁ and ▁ CR . ENDCOM msg = msg . replace ( ' \n ' , ' ' ) NEW_LINE self . assertNotIn ( ' ' , msg ) NEW_LINE self . assertNotIn ( ' \n ' , msg ) NEW_LINE DEDENT finally : NEW_LINE INDENT SMTP . send = send NEW_LINE DEDENT DEDENT
def test_send_messages_after_open_failed ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ send _ messages ( ) ▁ shouldn ' t ▁ try ▁ to ▁ send ▁ messages ▁ if ▁ open ( ) ▁ raises ▁ an STRNEWLINE ▁ exception ▁ after ▁ initializing ▁ the ▁ connection . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( ) NEW_LINE # ▁ Simulate ▁ connection ▁ initialization ▁ success ▁ and ▁ a ▁ subsequent ENDCOM # ▁ connection ▁ exception . ENDCOM backend . connection = True NEW_LINE backend . open = lambda : None NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertEqual ( backend . send_messages ( [ email ] ) , None ) NEW_LINE DEDENT
def test_server_stopped ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Closing ▁ the ▁ backend ▁ while ▁ the ▁ SMTP ▁ server ▁ is ▁ stopped ▁ doesn ' t ▁ raise ▁ an STRNEWLINE ▁ exception . STRNEWLINE ▁ """ NEW_LINE self . backend . close ( ) NEW_LINE DEDENT
def test_fail_silently_on_connection_error ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ socket ▁ connection ▁ error ▁ is ▁ silenced ▁ with ▁ fail _ silently = True . STRNEWLINE ▁ """ NEW_LINE with self . assertRaises ( socket . error ) : NEW_LINE INDENT self . backend . open ( ) NEW_LINE DEDENT self . backend . fail_silently = True NEW_LINE self . backend . open ( ) NEW_LINE DEDENT
