<DOCUMENT_ID="andrewburnheimer/ptpop/tree/master/ptpop/Console.py"> # ! / usr / local / bin / python ENDCOM ''' STRNEWLINE Console ▁ Class STRNEWLINE ''' NEW_LINE ''' STRNEWLINE To ▁ Do : STRNEWLINE ▁ - STRNEWLINE ''' NEW_LINE from Listener import Listener NEW_LINE from _version import __version__ NEW_LINE import time NEW_LINE # ▁ Console ENDCOM # ▁ Inheriting ▁ from ▁ ` object ` ▁ ( top - level ▁ class ) ENDCOM class Console ( object ) : NEW_LINE INDENT def __init__ ( self , args = None ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Console ▁ Initialization STRNEWLINE ▁ Input ▁ Attributes : STRNEWLINE ▁ - - - - - STRNEWLINE ▁ self . args ▁ - > ▁ argparse . Namespace : ▁ object ▁ holding ▁ attributes ▁ set STRNEWLINE ▁ on ▁ command - line . STRNEWLINE ▁ ''' NEW_LINE # ▁ Default ▁ Values ENDCOM delay = 3.0 NEW_LINE number = 1 # ▁ XXX ▁ should ▁ be ▁ = ▁ 0 ENDCOM NEW_LINE command = [ ] NEW_LINE interface = ' eth0' NEW_LINE listen = False NEW_LINE host = ' localhost ' NEW_LINE if args : NEW_LINE INDENT delay = float ( args . delay ) if args . delay else delay NEW_LINE number = args . number if ( args . number != None ) else number NEW_LINE command = args . command if args . command else command NEW_LINE interface = args . interface if args . interface else interface NEW_LINE listen = args . listen if args . listen else listen NEW_LINE host = args . host if args . host else host NEW_LINE # ▁ Input ▁ Checks ENDCOM DEDENT if command != [ ] : NEW_LINE INDENT raise NotImplementedError ( ' Issuing ▁ commands ▁ to ▁ hosts ▁ has ▁ ' + ' not ▁ been ▁ implemented ▁ yet ' ) NEW_LINE # ▁ init ▁ . . . ENDCOM DEDENT if listen : NEW_LINE INDENT self . listener = Listener ( interface ) NEW_LINE key = ''' STRNEWLINE remote ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Dly ▁ St ▁ Dom ▁ Pr1 ▁ ▁ Cl ▁ Acc ▁ ▁ ▁ Var ▁ ▁ Pr2 ▁ ▁ ▁ ▁ ▁ ▁ ▁ Uniq ▁ ▁ ▁ ▁ ▁ ▁ ▁ SyncT ▁ ▁ DlyT ▁ ▁ AnnT STRNEWLINE = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = ''' . strip ( ) NEW_LINE while number > 0 : NEW_LINE # ▁ Report ▁ output ▁ directly ▁ to ▁ console ENDCOM INDENT fmt = ' % a ▁ % b ▁ % d ▁ % Y ▁ % H : % M : % S ' NEW_LINE t = time . time ( ) NEW_LINE time_str = time . strftime ( fmt , time . localtime ( t ) ) NEW_LINE time_msecs = int ( ( t - int ( t ) ) * 1000 ) NEW_LINE print time_str + ' . %03d ▁ ' % ( time_msecs ) + time . tzname [ 0 ] NEW_LINE print key NEW_LINE # ▁ output ▁ data ▁ seen ▁ in ▁ since ▁ last ▁ iteration ENDCOM neighbor_stats = self . listener . ptp_neighbors NEW_LINE for neighbor in neighbor_stats : NEW_LINE INDENT print self . listener . ptp_neighbors [ neighbor ] NEW_LINE DEDENT print NEW_LINE number -= 1 NEW_LINE if number <= 0 : NEW_LINE INDENT exit ( 0 ) NEW_LINE # ▁ No ▁ need ▁ to ▁ wait ▁ after ▁ the ▁ last ▁ iteration ENDCOM DEDENT time . sleep ( delay ) NEW_LINE # ▁ Enter ▁ into ▁ the ▁ interactive ▁ environment , ▁ exit ▁ when ▁ q ▁ is ENDCOM # ▁ issued ENDCOM DEDENT DEDENT else : NEW_LINE INDENT for supplied_command in command : NEW_LINE INDENT command = supplied_command . lower ( ) NEW_LINE if command == ' rv ' or command == ' readvar ' : NEW_LINE INDENT None NEW_LINE # ▁ Assuming ▁ to ▁ be ▁ similar ▁ to ▁ NTPQ ENDCOM # ▁ root @ raspberrypi : / home / puppet # ▁ ntpq ▁ - n ▁ - c ▁ rv ▁ - c ▁ peers ENDCOM # associd = 0 ▁ status = 0615 ▁ leap _ none , ▁ sync _ ntp , ▁ 1 ▁ event , ▁ clock _ sync , ENDCOM # version = " ntpd ▁ 4.2.6p5@1.2349 - o ▁ Mon ▁ Nov ▁ 2 ▁ 04:29:47 ▁ UTC ▁ 2015 ▁ ( 1 ) " , ENDCOM # processor = " armv6l " , ▁ system = " Linux / 4.1.17 + " , ▁ leap = 00 , ▁ stratum = 3 , ENDCOM # precision = - 20 , ▁ rootdelay = 2.916 , ▁ rootdisp = 60.561 , ENDCOM # refid = 3.44.174.43 , ENDCOM # reftime = da7f3666.54078831 ▁ Mon , ▁ Feb ▁ 29 ▁ 2016 ▁ 21:28:06.328 , ENDCOM # clock = da7f38cd . 57a72dc6 ▁ Mon , ▁ Feb ▁ 29 ▁ 2016 ▁ 21:38:21.342 , ENDCOM # peer = 7185 , ▁ tc = 8 , ENDCOM # mintc = 3 , ▁ offset = 9.208 , ▁ frequency = - 48.954 , ▁ sys _ jitter = 0.000 , ENDCOM # clk _ jitter = 16.919 , ▁ clk _ wander = 4.216 ENDCOM DEDENT elif command == ' peers ' : NEW_LINE INDENT None NEW_LINE # ▁ Assuming ▁ to ▁ be ▁ similar ▁ to ▁ NTPQ ENDCOM # ▁ remote ▁ refid ▁ st ▁ t ▁ when ▁ poll ▁ reach ▁ delay ▁ offset ▁ jitter ENDCOM # * useclsifl158 . tf ▁ 3.199.96.254 ▁ 2 ▁ u ▁ 14 ▁ 1024 ▁ 377 ▁ 1.582 ▁ 0.186 ▁ 0.919 ENDCOM DEDENT else : NEW_LINE INDENT raise NotImplementedError ( ' Unknown ▁ command , ▁ \ ' ' + command + ' \ ' ' ) NEW_LINE # ▁ _ _ main _ _ . py ▁ is ▁ executed ▁ when ▁ the ▁ package ▁ is ▁ instantiated ENDCOM DEDENT DEDENT DEDENT DEDENT DEDENT import argparse NEW_LINE def main ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( prog = ' ptpop ' , description = ' Gain ▁ ' + ' insight ▁ into ▁ the ▁ operations ▁ of ▁ IEEE ▁ 1588 ▁ Precision ▁ Time ▁ Protocol ▁ ' + ' domains ▁ on ▁ a ▁ network . ▁ Press ▁ the ▁ \ ' q\ ' ▁ key ▁ to ▁ quit . ' ) NEW_LINE command_choices = [ ' readvar ' , ' rv ' , ' peers ' ] NEW_LINE parser . add_argument ( ' host ' , type = str , nargs = ' ? ' , help = ' each ▁ of ▁ the ▁ ' + ' commands ▁ will ▁ be ▁ sent ▁ to ▁ the ▁ PTP ▁ servers ▁ ' + ' running ▁ on ▁ the ▁ host ▁ provided , ▁ localhost ▁ by ▁ ' + ' default . ' ) NEW_LINE parser . add_argument ( ' - c ' , ' - - command ' , type = str , action = ' append ' , help = ' a ▁ command ▁ to ▁ run ▁ on ▁ the ▁ provided ▁ host , ▁ ' + ' i . e . ▁ ' + str ( command_choices ) + ' , ▁ \ ' readvar\ ' ▁ ' + ' by ▁ default . ▁ Multiple ▁ commands ▁ can ▁ be ▁ issued . ' ) NEW_LINE parser . add_argument ( ' - i ' , ' - - interface ' , type = str , help = ' interface ▁ to ▁ issue ▁ commands ▁ on ▁ or ▁ to ▁ ' + ' observe ▁ on ▁ in ▁ listen ▁ mode . ' ) NEW_LINE parser . add_argument ( ' - l ' , ' - - listen ' , action = ' store _ true ' , help = ' don\ ' t ▁ contact ▁ any ▁ PTP ▁ servers , ▁ but ▁ ' + ' report ▁ on ▁ any ▁ services ▁ currently ▁ observed ▁ ' + ' on ▁ the ▁ network , ▁ instead . ' ) NEW_LINE parser . add_argument ( ' - d ' , ' - - delay ' , metavar = ' SECS . TENTHS ' , type = str , help = ' Specifies ▁ the ▁ delay ▁ between ▁ screen ▁ ' + ' updates ▁ when ▁ interactive . ▁ Can ▁ be ▁ changed ▁ while ▁ ' + ' running ▁ using ▁ the ▁ \ ' d\ ' ▁ key . ▁ Negative ▁ ' + ' numbers ▁ are ▁ not ▁ allowed . ▁ Setting ▁ this ▁ value ▁ ' + ' to ▁ 0 ▁ is ▁ the ▁ same ▁ as ▁ issuing ▁ the ▁ \ ' - n ▁ 1\ ' ▁ ' + ' option . ' ) NEW_LINE parser . add_argument ( ' - n ' , ' - - number ' , metavar = ' COUNT ' , type = int , help = ' Specifies ▁ the ▁ maximum ▁ number ▁ of ▁ iterations ▁ ' + ' in ▁ interactive ▁ mode ▁ before ▁ ending . ' ) NEW_LINE parser . add_argument ( ' - v ' , ' - - version ' , action = ' version ' , version = ' % ( prog ) s ▁ ' + __version__ ) NEW_LINE args = parser . parse_args ( ) NEW_LINE try : NEW_LINE INDENT c = Console ( args ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT print type ( e ) . __name__ + " : ▁ " + str ( e . message ) NEW_LINE exit ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="michalkurka/h2o-3/tree/master/h2o-py/tests/testdir_algos/pca/pyunit_pubdev_4961_pca_implementations.py"> from __future__ import print_function NEW_LINE from builtins import str NEW_LINE from builtins import range NEW_LINE import sys NEW_LINE sys . path . insert ( 1 , " . . / . . / . . / " ) NEW_LINE import h2o NEW_LINE from tests import pyunit_utils NEW_LINE from h2o . estimators . pca import H2OPrincipalComponentAnalysisEstimator as H2OPCA NEW_LINE def pca_arrests ( ) : NEW_LINE INDENT print ( " Importing ▁ USArrests . csv ▁ data . . . " ) NEW_LINE arrestsH2O = h2o . upload_file ( pyunit_utils . locate ( " smalldata / pca _ test / USArrests . csv " ) ) NEW_LINE print ( " Testing ▁ to ▁ see ▁ whether ▁ the ▁ trained ▁ PCA ▁ are ▁ essentially ▁ the ▁ same ▁ using ▁ different ▁ implementation . . . " ) NEW_LINE eigenvector_standard = None NEW_LINE for impl in [ " MTJ _ EVD _ DENSEMATRIX " , " MTJ _ EVD _ SYMMMATRIX " , " MTJ _ SVD _ DENSEMATRIX " , " JAMA " ] : NEW_LINE INDENT print ( " Run ▁ PCA ▁ with ▁ implementation : ▁ " + impl ) NEW_LINE model = H2OPCA ( k = 4 , pca_impl = impl , seed = 1234 ) NEW_LINE model . train ( x = list ( range ( 4 ) ) , training_frame = arrestsH2O ) NEW_LINE eigenvectors = model . _model_json [ " output " ] [ " eigenvectors " ] NEW_LINE if eigenvector_standard is not None : NEW_LINE # ▁ Compare ▁ to ▁ see ▁ if ▁ they ▁ are ▁ fundamentally ▁ the ▁ same ENDCOM INDENT pyunit_utils . assert_H2OTwoDimTable_equal ( eigenvector_standard , eigenvectors , model . _model_json [ " output " ] [ " names " ] , tolerance = 1e-6 , check_sign = True , check_all = False ) NEW_LINE DEDENT else : NEW_LINE INDENT eigenvector_standard = eigenvectors NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT pyunit_utils . standalone_test ( pca_arrests ) NEW_LINE DEDENT else : NEW_LINE INDENT pca_arrests ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="tianweizhang/nova/tree/master/nova/cmd/network.py"> # ▁ Copyright ▁ 2010 ▁ United ▁ States ▁ Government ▁ as ▁ represented ▁ by ▁ the ENDCOM # ▁ Administrator ▁ of ▁ the ▁ National ▁ Aeronautics ▁ and ▁ Space ▁ Administration . ENDCOM # ▁ All ▁ Rights ▁ Reserved . ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ENDCOM # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ENDCOM # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ENDCOM # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ENDCOM # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM # ▁ under ▁ the ▁ License . ENDCOM """ Starter ▁ script ▁ for ▁ Nova ▁ Network . """ NEW_LINE import sys NEW_LINE import traceback NEW_LINE from oslo . config import cfg NEW_LINE from nova . conductor import rpcapi as conductor_rpcapi NEW_LINE from nova import config NEW_LINE import nova . db . api NEW_LINE from nova import exception NEW_LINE from nova . i18n import _ NEW_LINE from nova import objects NEW_LINE from nova . objects import base as objects_base NEW_LINE from nova . openstack . common import log as logging NEW_LINE from nova . openstack . common . report import guru_meditation_report as gmr NEW_LINE from nova import service NEW_LINE from nova import utils NEW_LINE from nova import version NEW_LINE CONF = cfg . CONF NEW_LINE CONF . import_opt ( ' network _ topic ' , ' nova . network . rpcapi ' ) NEW_LINE CONF . import_opt ( ' use _ local ' , ' nova . conductor . api ' , group = ' conductor ' ) NEW_LINE def block_db_access ( ) : NEW_LINE INDENT class NoDB ( object ) : NEW_LINE INDENT def __getattr__ ( self , attr ) : NEW_LINE INDENT return self NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT stacktrace = " " . join ( traceback . format_stack ( ) ) NEW_LINE LOG = logging . getLogger ( ' nova . network ' ) NEW_LINE LOG . error ( _ ( ' No ▁ db ▁ access ▁ allowed ▁ in ▁ nova - network : ▁ % s ' ) , stacktrace ) NEW_LINE raise exception . DBNotAllowed ( ' nova - network ' ) NEW_LINE DEDENT DEDENT nova . db . api . IMPL = NoDB ( ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT config . parse_args ( sys . argv ) NEW_LINE logging . setup ( " nova " ) NEW_LINE utils . monkey_patch ( ) NEW_LINE objects . register_all ( ) NEW_LINE gmr . TextGuruMeditation . setup_autorun ( version ) NEW_LINE if not CONF . conductor . use_local : NEW_LINE INDENT block_db_access ( ) NEW_LINE objects_base . NovaObject . indirection_api = conductor_rpcapi . ConductorAPI ( ) NEW_LINE DEDENT server = service . Service . create ( binary = ' nova - network ' , topic = CONF . network_topic , db_allowed = CONF . conductor . use_local ) NEW_LINE service . serve ( server ) NEW_LINE service . wait ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="roandelyf/iTerm2/tree/master/tests/esctest/tests/el.py"> from esc import NUL , blank NEW_LINE import escargs NEW_LINE import esccmd NEW_LINE import escio NEW_LINE from esctypes import Point , Rect NEW_LINE from escutil import AssertEQ , AssertScreenCharsInRectEqual , GetCursorPosition , knownBug NEW_LINE class ELTests ( object ) : NEW_LINE INDENT def prepare ( self ) : NEW_LINE INDENT """ Initializes ▁ the ▁ screen ▁ to ▁ abcdefghij ▁ on ▁ the ▁ first ▁ line ▁ with ▁ the ▁ cursor STRNEWLINE ▁ on ▁ the ▁ ' e ' . """ NEW_LINE esccmd . CUP ( Point ( 1 , 1 ) ) NEW_LINE escio . Write ( " abcdefghij " ) NEW_LINE esccmd . CUP ( Point ( 5 , 1 ) ) NEW_LINE DEDENT def test_EL_Default ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ to ▁ right ▁ of ▁ cursor . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ " abcd " + 6 * NUL ] ) NEW_LINE DEDENT def test_EL_0 ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ to ▁ right ▁ of ▁ cursor . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( 0 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ " abcd " + 6 * NUL ] ) NEW_LINE DEDENT def test_EL_1 ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ to ▁ left ▁ of ▁ cursor . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( 1 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ 5 * blank ( ) + " fghij " ] ) NEW_LINE DEDENT def test_EL_2 ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ whole ▁ line . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ 10 * NUL ] ) NEW_LINE DEDENT def test_EL_IgnoresScrollRegion ( self ) : NEW_LINE INDENT """ Should ▁ erase ▁ whole ▁ line . """ NEW_LINE self . prepare ( ) NEW_LINE esccmd . DECSET ( esccmd . DECLRMM ) NEW_LINE esccmd . DECSLRM ( 2 , 4 ) NEW_LINE esccmd . CUP ( Point ( 5 , 1 ) ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE esccmd . DECRESET ( esccmd . DECLRMM ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 10 , 1 ) , [ 10 * NUL ] ) NEW_LINE DEDENT def test_EL_doesNotRespectDECProtection ( self ) : NEW_LINE INDENT """ EL ▁ respects ▁ DECSCA . """ NEW_LINE escio . Write ( " a " ) NEW_LINE escio . Write ( " b " ) NEW_LINE esccmd . DECSCA ( 1 ) NEW_LINE escio . Write ( " c " ) NEW_LINE esccmd . DECSCA ( 0 ) NEW_LINE esccmd . CUP ( Point ( 1 , 1 ) ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 3 , 1 ) , [ NUL * 3 ] ) NEW_LINE DEDENT @ knownBug ( terminal = " iTerm2" , reason = " Protection ▁ not ▁ implemented . " ) NEW_LINE def test_EL_respectsISOProtection ( self ) : NEW_LINE INDENT """ EL ▁ respects ▁ SPA / EPA . """ NEW_LINE escio . Write ( " a " ) NEW_LINE escio . Write ( " b " ) NEW_LINE esccmd . SPA ( ) NEW_LINE escio . Write ( " c " ) NEW_LINE esccmd . EPA ( ) NEW_LINE esccmd . CUP ( Point ( 1 , 1 ) ) NEW_LINE esccmd . EL ( 2 ) NEW_LINE AssertScreenCharsInRectEqual ( Rect ( 1 , 1 , 3 , 1 ) , [ blank ( ) * 2 + " c " ] ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="moijes12/oh-mainline/tree/master/vendor/packages/sphinx/tests/test_intersphinx.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM """ STRNEWLINE ▁ test _ intersphinx STRNEWLINE ▁ ~ ~ ~ ~ ~ STRNEWLINE STRNEWLINE ▁ Test ▁ the ▁ intersphinx ▁ extension . STRNEWLINE STRNEWLINE ▁ : copyright : ▁ Copyright ▁ 2007-2013 ▁ by ▁ the ▁ Sphinx ▁ team , ▁ see ▁ AUTHORS . STRNEWLINE ▁ : license : ▁ BSD , ▁ see ▁ LICENSE ▁ for ▁ details . STRNEWLINE """ NEW_LINE import zlib NEW_LINE import posixpath NEW_LINE try : NEW_LINE INDENT from io import BytesIO NEW_LINE DEDENT except ImportError : NEW_LINE INDENT from cStringIO import StringIO as BytesIO NEW_LINE DEDENT from docutils import nodes NEW_LINE from sphinx import addnodes NEW_LINE from sphinx . ext . intersphinx import read_inventory_v1 , read_inventory_v2 , load_mappings , missing_reference NEW_LINE from util import with_app , with_tempdir , write_file NEW_LINE inventory_v1 = ''' \ STRNEWLINE # ▁ Sphinx ▁ inventory ▁ version ▁ 1 STRNEWLINE # ▁ Project : ▁ foo STRNEWLINE # ▁ Version : ▁ 1.0 STRNEWLINE module ▁ mod ▁ foo . html STRNEWLINE module . cls ▁ class ▁ foo . html STRNEWLINE ''' . encode ( ' utf - 8' ) NEW_LINE inventory_v2 = ''' \ STRNEWLINE # ▁ Sphinx ▁ inventory ▁ version ▁ 2 STRNEWLINE # ▁ Project : ▁ foo STRNEWLINE # ▁ Version : ▁ 2.0 STRNEWLINE # ▁ The ▁ remainder ▁ of ▁ this ▁ file ▁ is ▁ compressed ▁ with ▁ zlib . STRNEWLINE ''' . encode ( ' utf - 8' ) + zlib . compress ( ''' \ STRNEWLINE module1 ▁ py : module ▁ 0 ▁ foo . html # module - module1 ▁ Long ▁ Module ▁ desc STRNEWLINE module2 ▁ py : module ▁ 0 ▁ foo . html # module - $ ▁ - STRNEWLINE module1 . func ▁ py : function ▁ 1 ▁ sub / foo . html # $ ▁ - STRNEWLINE CFunc ▁ c : function ▁ 2 ▁ cfunc . html # CFunc ▁ - STRNEWLINE a ▁ term ▁ std : term ▁ - 1 ▁ glossary . html # term - a - term ▁ - STRNEWLINE ''' . encode ( ' utf - 8' ) ) NEW_LINE def test_read_inventory_v1 ( ) : NEW_LINE INDENT f = BytesIO ( inventory_v1 ) NEW_LINE f . readline ( ) NEW_LINE invdata = read_inventory_v1 ( f , ' / util ' , posixpath . join ) NEW_LINE assert invdata [ ' py : module ' ] [ ' module ' ] == ( ' foo ' , '1.0' , ' / util / foo . html # module - module ' , ' - ' ) NEW_LINE assert invdata [ ' py : class ' ] [ ' module . cls ' ] == ( ' foo ' , '1.0' , ' / util / foo . html # module . cls ' , ' - ' ) NEW_LINE DEDENT def test_read_inventory_v2 ( ) : NEW_LINE INDENT f = BytesIO ( inventory_v2 ) NEW_LINE f . readline ( ) NEW_LINE invdata1 = read_inventory_v2 ( f , ' / util ' , posixpath . join ) NEW_LINE # ▁ try ▁ again ▁ with ▁ a ▁ small ▁ buffer ▁ size ▁ to ▁ test ▁ the ▁ chunking ▁ algorithm ENDCOM f = BytesIO ( inventory_v2 ) NEW_LINE f . readline ( ) NEW_LINE invdata2 = read_inventory_v2 ( f , ' / util ' , posixpath . join , bufsize = 5 ) NEW_LINE assert invdata1 == invdata2 NEW_LINE assert len ( invdata1 [ ' py : module ' ] ) == 2 NEW_LINE assert invdata1 [ ' py : module ' ] [ ' module1' ] == ( ' foo ' , '2.0' , ' / util / foo . html # module - module1' , ' Long ▁ Module ▁ desc ' ) NEW_LINE assert invdata1 [ ' py : module ' ] [ ' module2' ] == ( ' foo ' , '2.0' , ' / util / foo . html # module - module2' , ' - ' ) NEW_LINE assert invdata1 [ ' py : function ' ] [ ' module1 . func ' ] [ 2 ] == ' / util / sub / foo . html # module1 . func ' NEW_LINE assert invdata1 [ ' c : function ' ] [ ' CFunc ' ] [ 2 ] == ' / util / cfunc . html # CFunc ' NEW_LINE assert invdata1 [ ' std : term ' ] [ ' a ▁ term ' ] [ 2 ] == ' / util / glossary . html # term - a - term ' NEW_LINE DEDENT @ with_app ( confoverrides = { ' extensions ' : ' sphinx . ext . intersphinx ' } ) NEW_LINE @ with_tempdir NEW_LINE def test_missing_reference ( tempdir , app ) : NEW_LINE INDENT inv_file = tempdir / ' inventory ' NEW_LINE write_file ( inv_file , inventory_v2 ) NEW_LINE app . config . intersphinx_mapping = { ' http : / / docs . python . org / ' : inv_file , ' py3k ' : ( ' http : / / docs . python . org / py3k / ' , inv_file ) , } NEW_LINE app . config . intersphinx_cache_limit = 0 NEW_LINE # ▁ load ▁ the ▁ inventory ▁ and ▁ check ▁ if ▁ it ' s ▁ done ▁ correctly ENDCOM load_mappings ( app ) NEW_LINE inv = app . env . intersphinx_inventory NEW_LINE assert inv [ ' py : module ' ] [ ' module2' ] == ( ' foo ' , '2.0' , ' http : / / docs . python . org / foo . html # module - module2' , ' - ' ) NEW_LINE # ▁ create ▁ fake ▁ nodes ▁ and ▁ check ▁ referencing ENDCOM def fake_node ( domain , type , target , content , ** attrs ) : NEW_LINE INDENT contnode = nodes . emphasis ( content , content ) NEW_LINE node = addnodes . pending_xref ( ' ' ) NEW_LINE node [ ' reftarget ' ] = target NEW_LINE node [ ' reftype ' ] = type NEW_LINE node [ ' refdomain ' ] = domain NEW_LINE node . attributes . update ( attrs ) NEW_LINE node += contnode NEW_LINE return node , contnode NEW_LINE DEDENT def reference_check ( * args , ** kwds ) : NEW_LINE INDENT node , contnode = fake_node ( * args , ** kwds ) NEW_LINE return missing_reference ( app , app . env , node , contnode ) NEW_LINE # ▁ check ▁ resolution ▁ when ▁ a ▁ target ▁ is ▁ found ENDCOM DEDENT rn = reference_check ( ' py ' , ' func ' , ' module1 . func ' , ' foo ' ) NEW_LINE assert isinstance ( rn , nodes . reference ) NEW_LINE assert rn [ ' refuri ' ] == ' http : / / docs . python . org / sub / foo . html # module1 . func ' NEW_LINE assert rn [ ' reftitle ' ] == ' ( in ▁ foo ▁ v2.0 ) ' NEW_LINE assert rn [ 0 ] . astext ( ) == ' foo ' NEW_LINE # ▁ create ▁ unresolvable ▁ nodes ▁ and ▁ check ▁ None ▁ return ▁ value ENDCOM assert reference_check ( ' py ' , ' foo ' , ' module1 . func ' , ' foo ' ) is None NEW_LINE assert reference_check ( ' py ' , ' func ' , ' foo ' , ' foo ' ) is None NEW_LINE assert reference_check ( ' py ' , ' func ' , ' foo ' , ' foo ' ) is None NEW_LINE # ▁ check ▁ handling ▁ of ▁ prefixes ENDCOM # ▁ prefix ▁ given , ▁ target ▁ found : ▁ prefix ▁ is ▁ stripped ENDCOM rn = reference_check ( ' py ' , ' mod ' , ' py3k : module2' , ' py3k : module2' ) NEW_LINE assert rn [ 0 ] . astext ( ) == ' module2' NEW_LINE # ▁ prefix ▁ given , ▁ but ▁ not ▁ in ▁ title : ▁ nothing ▁ stripped ENDCOM rn = reference_check ( ' py ' , ' mod ' , ' py3k : module2' , ' module2' ) NEW_LINE assert rn [ 0 ] . astext ( ) == ' module2' NEW_LINE # ▁ prefix ▁ given , ▁ but ▁ explicit : ▁ nothing ▁ stripped ENDCOM rn = reference_check ( ' py ' , ' mod ' , ' py3k : module2' , ' py3k : module2' , refexplicit = True ) NEW_LINE assert rn [ 0 ] . astext ( ) == ' py3k : module2' NEW_LINE # ▁ prefix ▁ given , ▁ target ▁ not ▁ found ▁ and ▁ nonexplicit ▁ title : ▁ prefix ▁ is ▁ stripped ENDCOM node , contnode = fake_node ( ' py ' , ' mod ' , ' py3k : unknown ' , ' py3k : unknown ' , refexplicit = False ) NEW_LINE rn = missing_reference ( app , app . env , node , contnode ) NEW_LINE assert rn is None NEW_LINE assert contnode [ 0 ] . astext ( ) == ' unknown ' NEW_LINE # ▁ prefix ▁ given , ▁ target ▁ not ▁ found ▁ and ▁ explicit ▁ title : ▁ nothing ▁ is ▁ changed ENDCOM node , contnode = fake_node ( ' py ' , ' mod ' , ' py3k : unknown ' , ' py3k : unknown ' , refexplicit = True ) NEW_LINE rn = missing_reference ( app , app . env , node , contnode ) NEW_LINE assert rn is None NEW_LINE assert contnode [ 0 ] . astext ( ) == ' py3k : unknown ' NEW_LINE DEDENT @ with_app ( confoverrides = { ' extensions ' : ' sphinx . ext . intersphinx ' } ) NEW_LINE @ with_tempdir NEW_LINE def test_load_mappings_warnings ( tempdir , app ) : NEW_LINE INDENT """ STRNEWLINE ▁ load _ mappings ▁ issues ▁ a ▁ warning ▁ if ▁ new - style ▁ mapping STRNEWLINE ▁ identifiers ▁ are ▁ not ▁ alphanumeric STRNEWLINE ▁ """ NEW_LINE inv_file = tempdir / ' inventory ' NEW_LINE write_file ( inv_file , inventory_v2 ) NEW_LINE app . config . intersphinx_mapping = { ' http : / / docs . python . org / ' : inv_file , ' py3k ' : ( ' http : / / docs . python . org / py3k / ' , inv_file ) , ' repoze . workflow ' : ( ' http : / / docs . repoze . org / workflow / ' , inv_file ) , ' django - taggit ' : ( ' http : / / django - taggit . readthedocs . org / en / latest / ' , inv_file ) } NEW_LINE app . config . intersphinx_cache_limit = 0 NEW_LINE # ▁ load ▁ the ▁ inventory ▁ and ▁ check ▁ if ▁ it ' s ▁ done ▁ correctly ENDCOM load_mappings ( app ) NEW_LINE assert len ( app . _warning . content ) == 2 NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="giorgiop/scipy/tree/master/scipy/interpolate/tests/test_fitpack2.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Created ▁ by ▁ Pearu ▁ Peterson , ▁ June ▁ 2003 ENDCOM from __future__ import division , print_function , absolute_import NEW_LINE import warnings NEW_LINE import numpy as np NEW_LINE from numpy . testing import ( assert_equal , assert_almost_equal , assert_array_equal , assert_array_almost_equal , assert_allclose , assert_raises , TestCase , run_module_suite ) NEW_LINE from numpy import array , diff , linspace , meshgrid , ones , pi , shape NEW_LINE from scipy . interpolate . fitpack import bisplrep , bisplev NEW_LINE from scipy . interpolate . fitpack2 import ( UnivariateSpline , LSQUnivariateSpline , InterpolatedUnivariateSpline , LSQBivariateSpline , SmoothBivariateSpline , RectBivariateSpline , LSQSphereBivariateSpline , SmoothSphereBivariateSpline , RectSphereBivariateSpline ) NEW_LINE class TestUnivariateSpline ( TestCase ) : NEW_LINE INDENT def test_linear_constant ( self ) : NEW_LINE INDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 3 , 3 , 3 ] NEW_LINE lut = UnivariateSpline ( x , y , k = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , [ 1 , 3 ] ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 3 , 3 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] ) , [ 3 , 3 , 3 ] ) NEW_LINE DEDENT def test_preserve_shape ( self ) : NEW_LINE INDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 0 , 2 , 4 ] NEW_LINE lut = UnivariateSpline ( x , y , k = 1 ) NEW_LINE arg = 2 NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg ) ) ) NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg , nu = 1 ) ) ) NEW_LINE arg = [ 1.5 , 2 , 2.5 ] NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg ) ) ) NEW_LINE assert_equal ( shape ( arg ) , shape ( lut ( arg , nu = 1 ) ) ) NEW_LINE DEDENT def test_linear_1d ( self ) : NEW_LINE INDENT x = [ 1 , 2 , 3 ] NEW_LINE y = [ 0 , 2 , 4 ] NEW_LINE lut = UnivariateSpline ( x , y , k = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , [ 1 , 3 ] ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 0 , 4 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] ) , [ 0 , 1 , 2 ] ) NEW_LINE DEDENT def test_subclassing ( self ) : NEW_LINE # ▁ See ▁ # 731 ENDCOM INDENT class ZeroSpline ( UnivariateSpline ) : NEW_LINE INDENT def __call__ ( self , x ) : NEW_LINE INDENT return 0 * array ( x ) NEW_LINE DEDENT DEDENT sp = ZeroSpline ( [ 1 , 2 , 3 , 4 , 5 ] , [ 3 , 2 , 3 , 2 , 3 ] , k = 2 ) NEW_LINE assert_array_equal ( sp ( [ 1.5 , 2.5 ] ) , [ 0. , 0. ] ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE # ▁ Test ▁ whether ▁ empty ▁ input ▁ returns ▁ an ▁ empty ▁ output . ▁ Ticket ▁ 1014 ENDCOM INDENT x = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE y = [ 0 , 4 , 9 , 12 , 21 ] NEW_LINE spl = UnivariateSpline ( x , y , k = 3 ) NEW_LINE assert_array_equal ( spl ( [ ] ) , array ( [ ] ) ) NEW_LINE DEDENT def test_resize_regression ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 1375 . """ NEW_LINE x = [ - 1. , - 0.65016502 , - 0.58856235 , - 0.26903553 , - 0.17370892 , - 0.10011001 , 0. , 0.10011001 , 0.17370892 , 0.26903553 , 0.58856235 , 0.65016502 , 1. ] NEW_LINE y = [ 1. , 0.62928599 , 0.5797223 , 0.39965815 , 0.36322694 , 0.3508061 , 0.35214793 , 0.3508061 , 0.36322694 , 0.39965815 , 0.5797223 , 0.62928599 , 1. ] NEW_LINE w = [ 1.00000000e+12 , 6.88875973e+02 , 4.89314737e+02 , 4.26864807e+02 , 6.07746770e+02 , 4.51341444e+02 , 3.17480210e+02 , 4.51341444e+02 , 6.07746770e+02 , 4.26864807e+02 , 4.89314737e+02 , 6.88875973e+02 , 1.00000000e+12 ] NEW_LINE spl = UnivariateSpline ( x = x , y = y , w = w , s = None ) NEW_LINE desired = array ( [ 0.35100374 , 0.51715855 , 0.87789547 , 0.98719344 ] ) NEW_LINE assert_allclose ( spl ( [ 0.1 , 0.5 , 0.9 , 0.99 ] ) , desired , atol = 5e-4 ) NEW_LINE DEDENT def test_out_of_range_regression ( self ) : NEW_LINE # ▁ Test ▁ different ▁ extrapolation ▁ modes . ▁ See ▁ ticket ▁ 3557 ENDCOM INDENT x = np . arange ( 5 , dtype = float ) NEW_LINE y = x ** 3 NEW_LINE xp = linspace ( - 8 , 13 , 100 ) NEW_LINE xp_zeros = xp . copy ( ) NEW_LINE xp_zeros [ np . logical_or ( xp_zeros < 0. , xp_zeros > 4. ) ] = 0 NEW_LINE xp_clip = xp . copy ( ) NEW_LINE xp_clip [ xp_clip < x [ 0 ] ] = x [ 0 ] NEW_LINE xp_clip [ xp_clip > x [ - 1 ] ] = x [ - 1 ] NEW_LINE for cls in [ UnivariateSpline , InterpolatedUnivariateSpline ] : NEW_LINE INDENT spl = cls ( x = x , y = y ) NEW_LINE for ext in [ 0 , ' extrapolate ' ] : NEW_LINE INDENT assert_allclose ( spl ( xp , ext = ext ) , xp ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( cls ( x , y , ext = ext ) ( xp ) , xp ** 3 , atol = 1e-16 ) NEW_LINE DEDENT for ext in [ 1 , ' zeros ' ] : NEW_LINE INDENT assert_allclose ( spl ( xp , ext = ext ) , xp_zeros ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( cls ( x , y , ext = ext ) ( xp ) , xp_zeros ** 3 , atol = 1e-16 ) NEW_LINE DEDENT for ext in [ 2 , ' raise ' ] : NEW_LINE INDENT assert_raises ( ValueError , spl , xp , ** dict ( ext = ext ) ) NEW_LINE DEDENT for ext in [ 3 , ' const ' ] : NEW_LINE INDENT assert_allclose ( spl ( xp , ext = ext ) , xp_clip ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( cls ( x , y , ext = ext ) ( xp ) , xp_clip ** 3 , atol = 1e-16 ) NEW_LINE # ▁ also ▁ test ▁ LSQUnivariateSpline ▁ [ which ▁ needs ▁ explicit ▁ knots ] ENDCOM DEDENT DEDENT t = spl . get_knots ( ) [ 3 : 4 ] # ▁ interior ▁ knots ▁ w / ▁ default ▁ k = 3 ENDCOM NEW_LINE spl = LSQUnivariateSpline ( x , y , t ) NEW_LINE assert_allclose ( spl ( xp , ext = 0 ) , xp ** 3 , atol = 1e-16 ) NEW_LINE assert_allclose ( spl ( xp , ext = 1 ) , xp_zeros ** 3 , atol = 1e-16 ) NEW_LINE assert_raises ( ValueError , spl , xp , ** dict ( ext = 2 ) ) NEW_LINE assert_allclose ( spl ( xp , ext = 3 ) , xp_clip ** 3 , atol = 1e-16 ) NEW_LINE # ▁ also ▁ make ▁ sure ▁ that ▁ unknown ▁ values ▁ for ▁ ` ext ` ▁ are ▁ caught ▁ early ENDCOM for ext in [ - 1 , ' unknown ' ] : NEW_LINE INDENT spl = UnivariateSpline ( x , y ) NEW_LINE assert_raises ( ValueError , spl , xp , ** dict ( ext = ext ) ) NEW_LINE assert_raises ( ValueError , UnivariateSpline , ** dict ( x = x , y = y , ext = ext ) ) NEW_LINE DEDENT DEDENT def test_lsq_fpchec ( self ) : NEW_LINE INDENT xs = np . arange ( 100 ) * 1. NEW_LINE ys = np . arange ( 100 ) * 1. NEW_LINE knots = np . linspace ( 0 , 99 , 10 ) NEW_LINE bbox = ( - 1 , 101 ) NEW_LINE assert_raises ( ValueError , LSQUnivariateSpline , xs , ys , knots , bbox = bbox ) NEW_LINE DEDENT def test_derivative_and_antiderivative ( self ) : NEW_LINE # ▁ Thin ▁ wrappers ▁ to ▁ splder / splantider , ▁ so ▁ light ▁ smoke ▁ test ▁ only . ENDCOM INDENT x = np . linspace ( 0 , 1 , 70 ) ** 3 NEW_LINE y = np . cos ( x ) NEW_LINE spl = UnivariateSpline ( x , y , s = 0 ) NEW_LINE spl2 = spl . antiderivative ( 2 ) . derivative ( 2 ) NEW_LINE assert_allclose ( spl ( 0.3 ) , spl2 ( 0.3 ) ) NEW_LINE spl2 = spl . antiderivative ( 1 ) NEW_LINE assert_allclose ( spl2 ( 0.6 ) - spl2 ( 0.2 ) , spl . integral ( 0.2 , 0.6 ) ) NEW_LINE DEDENT def test_nan ( self ) : NEW_LINE # ▁ bail ▁ out ▁ early ▁ if ▁ the ▁ input ▁ data ▁ contains ▁ nans ENDCOM INDENT x = np . arange ( 10 , dtype = float ) NEW_LINE y = x ** 3 NEW_LINE for z in [ np . nan , np . inf , - np . inf ] : NEW_LINE INDENT y [ - 1 ] = z NEW_LINE assert_raises ( ValueError , UnivariateSpline , ** dict ( x = x , y = y , check_finite = True ) ) NEW_LINE DEDENT DEDENT DEDENT class TestLSQBivariateSpline ( TestCase ) : NEW_LINE # ▁ NOTE : ▁ The ▁ systems ▁ in ▁ this ▁ test ▁ class ▁ are ▁ rank - deficient ENDCOM INDENT def test_linear_constant ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( record = True ) : # ▁ coefficients ▁ of ▁ the ▁ . . . ENDCOM NEW_LINE INDENT lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT assert_almost_equal ( lut ( 2 , 2 ) , 3. ) NEW_LINE DEDENT def test_bilinearity ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 0 , 7 , 8 , 3 , 4 , 7 , 1 , 3 , 4 ] NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( ) : NEW_LINE # ▁ This ▁ seems ▁ to ▁ fail ▁ ( ier = 1 , ▁ see ▁ ticket ▁ 1642 ) . ENDCOM INDENT warnings . simplefilter ( ' ignore ' , UserWarning ) NEW_LINE lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT tx , ty = lut . get_knots ( ) NEW_LINE for xa , xb in zip ( tx [ : - 1 ] , tx [ 1 : ] ) : NEW_LINE INDENT for ya , yb in zip ( ty [ : - 1 ] , ty [ 1 : ] ) : NEW_LINE INDENT for t in [ 0.1 , 0.5 , 0.9 ] : NEW_LINE INDENT for s in [ 0.3 , 0.4 , 0.7 ] : NEW_LINE INDENT xp = xa * ( 1 - t ) + xb * t NEW_LINE yp = ya * ( 1 - s ) + yb * s NEW_LINE zp = ( + lut ( xa , ya ) * ( 1 - t ) * ( 1 - s ) + lut ( xb , ya ) * t * ( 1 - s ) + lut ( xa , yb ) * ( 1 - t ) * s + lut ( xb , yb ) * t * s ) NEW_LINE assert_almost_equal ( lut ( xp , yp ) , zp ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def test_integral ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 8 , 8 , 8 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = array ( [ 0 , 7 , 8 , 3 , 4 , 7 , 1 , 3 , 4 ] ) NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( record = True ) : # ▁ coefficients ▁ of ▁ the ▁ . . . ENDCOM NEW_LINE INDENT lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT tx , ty = lut . get_knots ( ) NEW_LINE tz = lut ( tx , ty ) NEW_LINE trpz = .25 * ( diff ( tx ) [ : , None ] * diff ( ty ) [ None , : ] * ( tz [ : - 1 , : - 1 ] + tz [ 1 : , : - 1 ] + tz [ : - 1 , 1 : ] + tz [ 1 : , 1 : ] ) ) . sum ( ) NEW_LINE assert_almost_equal ( lut . integral ( tx [ 0 ] , tx [ - 1 ] , ty [ 0 ] , ty [ - 1 ] ) , trpz ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE # ▁ Test ▁ whether ▁ empty ▁ inputs ▁ returns ▁ an ▁ empty ▁ output . ▁ Ticket ▁ 1014 ENDCOM INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE s = 0.1 NEW_LINE tx = [ 1 + s , 3 - s ] NEW_LINE ty = [ 1 + s , 3 - s ] NEW_LINE with warnings . catch_warnings ( record = True ) : # ▁ coefficients ▁ of ▁ the ▁ . . . ENDCOM NEW_LINE INDENT lut = LSQBivariateSpline ( x , y , z , tx , ty , kx = 1 , ky = 1 ) NEW_LINE DEDENT assert_array_equal ( lut ( [ ] , [ ] ) , np . zeros ( ( 0 , 0 ) ) ) NEW_LINE assert_array_equal ( lut ( [ ] , [ ] , grid = False ) , np . zeros ( ( 0 , ) ) ) NEW_LINE DEDENT DEDENT class TestSmoothBivariateSpline ( TestCase ) : NEW_LINE INDENT def test_linear_constant ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] NEW_LINE lut = SmoothBivariateSpline ( x , y , z , kx = 1 , ky = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , ( [ 1 , 1 , 3 , 3 ] , [ 1 , 1 , 3 , 3 ] ) ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 3 , 3 , 3 , 3 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] , [ 1 , 1.5 ] ) , [ [ 3 , 3 ] , [ 3 , 3 ] , [ 3 , 3 ] ] ) NEW_LINE DEDENT def test_linear_1d ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = [ 0 , 0 , 0 , 2 , 2 , 2 , 4 , 4 , 4 ] NEW_LINE lut = SmoothBivariateSpline ( x , y , z , kx = 1 , ky = 1 ) NEW_LINE assert_array_almost_equal ( lut . get_knots ( ) , ( [ 1 , 1 , 3 , 3 ] , [ 1 , 1 , 3 , 3 ] ) ) NEW_LINE assert_array_almost_equal ( lut . get_coeffs ( ) , [ 0 , 0 , 4 , 4 ] ) NEW_LINE assert_almost_equal ( lut . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( lut ( [ 1 , 1.5 , 2 ] , [ 1 , 1.5 ] ) , [ [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ] ) NEW_LINE DEDENT def test_integral ( self ) : NEW_LINE INDENT x = [ 1 , 1 , 1 , 2 , 2 , 2 , 4 , 4 , 4 ] NEW_LINE y = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE z = array ( [ 0 , 7 , 8 , 3 , 4 , 7 , 1 , 3 , 4 ] ) NEW_LINE with warnings . catch_warnings ( ) : NEW_LINE # ▁ This ▁ seems ▁ to ▁ fail ▁ ( ier = 1 , ▁ see ▁ ticket ▁ 1642 ) . ENDCOM INDENT warnings . simplefilter ( ' ignore ' , UserWarning ) NEW_LINE lut = SmoothBivariateSpline ( x , y , z , kx = 1 , ky = 1 , s = 0 ) NEW_LINE DEDENT tx = [ 1 , 2 , 4 ] NEW_LINE ty = [ 1 , 2 , 3 ] NEW_LINE tz = lut ( tx , ty ) NEW_LINE trpz = .25 * ( diff ( tx ) [ : , None ] * diff ( ty ) [ None , : ] * ( tz [ : - 1 , : - 1 ] + tz [ 1 : , : - 1 ] + tz [ : - 1 , 1 : ] + tz [ 1 : , 1 : ] ) ) . sum ( ) NEW_LINE assert_almost_equal ( lut . integral ( tx [ 0 ] , tx [ - 1 ] , ty [ 0 ] , ty [ - 1 ] ) , trpz ) NEW_LINE lut2 = SmoothBivariateSpline ( x , y , z , kx = 2 , ky = 2 , s = 0 ) NEW_LINE assert_almost_equal ( lut2 . integral ( tx [ 0 ] , tx [ - 1 ] , ty [ 0 ] , ty [ - 1 ] ) , trpz , decimal = 0 ) # ▁ the ▁ quadratures ▁ give ▁ 23.75 ▁ and ▁ 23.85 ENDCOM NEW_LINE tz = lut ( tx [ : - 1 ] , ty [ : - 1 ] ) NEW_LINE trpz = .25 * ( diff ( tx [ : - 1 ] ) [ : , None ] * diff ( ty [ : - 1 ] ) [ None , : ] * ( tz [ : - 1 , : - 1 ] + tz [ 1 : , : - 1 ] + tz [ : - 1 , 1 : ] + tz [ 1 : , 1 : ] ) ) . sum ( ) NEW_LINE assert_almost_equal ( lut . integral ( tx [ 0 ] , tx [ - 2 ] , ty [ 0 ] , ty [ - 2 ] ) , trpz ) NEW_LINE DEDENT def test_rerun_lwrk2_too_small ( self ) : NEW_LINE # ▁ in ▁ this ▁ setting , ▁ lwrk2 ▁ is ▁ too ▁ small ▁ in ▁ the ▁ default ▁ run . ▁ Here ▁ we ENDCOM # ▁ check ▁ for ▁ equality ▁ with ▁ the ▁ bisplrep / bisplev ▁ output ▁ because ▁ there , ENDCOM # ▁ an ▁ automatic ▁ re - run ▁ of ▁ the ▁ spline ▁ representation ▁ is ▁ done ▁ if ▁ ier > 10 . ENDCOM INDENT x = np . linspace ( - 2 , 2 , 80 ) NEW_LINE y = np . linspace ( - 2 , 2 , 80 ) NEW_LINE z = x + y NEW_LINE xi = np . linspace ( - 1 , 1 , 100 ) NEW_LINE yi = np . linspace ( - 2 , 2 , 100 ) NEW_LINE tck = bisplrep ( x , y , z ) NEW_LINE res1 = bisplev ( xi , yi , tck ) NEW_LINE interp_ = SmoothBivariateSpline ( x , y , z ) NEW_LINE res2 = interp_ ( xi , yi ) NEW_LINE assert_almost_equal ( res1 , res2 ) NEW_LINE DEDENT DEDENT class TestLSQSphereBivariateSpline ( TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE # ▁ define ▁ the ▁ input ▁ data ▁ and ▁ coordinates ENDCOM INDENT ntheta , nphi = 70 , 90 NEW_LINE theta = linspace ( 0.5 / ( ntheta - 1 ) , 1 - 0.5 / ( ntheta - 1 ) , ntheta ) * pi NEW_LINE phi = linspace ( 0.5 / ( nphi - 1 ) , 1 - 0.5 / ( nphi - 1 ) , nphi ) * 2. * pi NEW_LINE data = ones ( ( theta . shape [ 0 ] , phi . shape [ 0 ] ) ) NEW_LINE # ▁ define ▁ knots ▁ and ▁ extract ▁ data ▁ values ▁ at ▁ the ▁ knots ENDCOM knotst = theta [ : : 5 ] NEW_LINE knotsp = phi [ : : 5 ] NEW_LINE knotdata = data [ : : 5 , : : 5 ] NEW_LINE # ▁ calculate ▁ spline ▁ coefficients ENDCOM lats , lons = meshgrid ( theta , phi ) NEW_LINE lut_lsq = LSQSphereBivariateSpline ( lats . ravel ( ) , lons . ravel ( ) , data . T . ravel ( ) , knotst , knotsp ) NEW_LINE self . lut_lsq = lut_lsq NEW_LINE self . data = knotdata NEW_LINE self . new_lons , self . new_lats = knotsp , knotst NEW_LINE DEDENT def test_linear_constant ( self ) : NEW_LINE INDENT assert_almost_equal ( self . lut_lsq . get_residual ( ) , 0.0 ) NEW_LINE assert_array_almost_equal ( self . lut_lsq ( self . new_lats , self . new_lons ) , self . data ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE INDENT assert_array_almost_equal ( self . lut_lsq ( [ ] , [ ] ) , np . zeros ( ( 0 , 0 ) ) ) NEW_LINE assert_array_almost_equal ( self . lut_lsq ( [ ] , [ ] , grid = False ) , np . zeros ( ( 0 , ) ) ) NEW_LINE DEDENT DEDENT class TestSmoothSphereBivariateSpline ( TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT theta = array ( [ .25 * pi , .25 * pi , .25 * pi , .5 * pi , .5 * pi , .5 * pi , .75 * pi , .75 * pi , .75 * pi ] ) NEW_LINE phi = array ( [ .5 * pi , pi , 1.5 * pi , .5 * pi , pi , 1.5 * pi , .5 * pi , pi , 1.5 * pi ] ) NEW_LINE r = array ( [ 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 ] ) NEW_LINE self . lut = SmoothSphereBivariateSpline ( theta , phi , r , s = 1E10 ) NEW_LINE DEDENT def test_linear_constant ( self ) : NEW_LINE INDENT assert_almost_equal ( self . lut . get_residual ( ) , 0. ) NEW_LINE assert_array_almost_equal ( self . lut ( [ 1 , 1.5 , 2 ] , [ 1 , 1.5 ] ) , [ [ 3 , 3 ] , [ 3 , 3 ] , [ 3 , 3 ] ] ) NEW_LINE DEDENT def test_empty_input ( self ) : NEW_LINE INDENT assert_array_almost_equal ( self . lut ( [ ] , [ ] ) , np . zeros ( ( 0 , 0 ) ) ) NEW_LINE assert_array_almost_equal ( self . lut ( [ ] , [ ] , grid = False ) , np . zeros ( ( 0 , ) ) ) NEW_LINE DEDENT DEDENT class TestRectBivariateSpline ( TestCase ) : NEW_LINE INDENT def test_defaults ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y ) , z ) NEW_LINE DEDENT def test_evaluate ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE xi = [ 1 , 2.3 , 5.3 , 0.5 , 3.3 , 1.2 , 3 ] NEW_LINE yi = [ 1 , 3.3 , 1.2 , 4.0 , 5.0 , 1.0 , 3 ] NEW_LINE zi = lut . ev ( xi , yi ) NEW_LINE zi2 = array ( [ lut ( xp , yp ) [ 0 , 0 ] for xp , yp in zip ( xi , yi ) ] ) NEW_LINE assert_almost_equal ( zi , zi2 ) NEW_LINE DEDENT def test_derivatives_grid ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE dx = array ( [ [ 0 , 0 , - 20 , 0 , 0 ] , [ 0 , 0 , 13 , 0 , 0 ] , [ 0 , 0 , 4 , 0 , 0 ] , [ 0 , 0 , - 11 , 0 , 0 ] , [ 0 , 0 , 4 , 0 , 0 ] ] ) / 6. NEW_LINE dy = array ( [ [ 4 , - 1 , 0 , 1 , - 4 ] , [ 4 , - 1 , 0 , 1 , - 4 ] , [ 0 , 1.5 , 0 , - 1.5 , 0 ] , [ 2 , .25 , 0 , - .25 , - 2 ] , [ 4 , - 1 , 0 , 1 , - 4 ] ] ) NEW_LINE dxdy = array ( [ [ 40 , - 25 , 0 , 25 , - 40 ] , [ - 26 , 16.25 , 0 , - 16.25 , 26 ] , [ - 8 , 5 , 0 , - 5 , 8 ] , [ 22 , - 13.75 , 0 , 13.75 , - 22 ] , [ - 8 , 5 , 0 , - 5 , 8 ] ] ) / 6. NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 ) , dx ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dy = 1 ) , dy ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 , dy = 1 ) , dxdy ) NEW_LINE DEDENT def test_derivatives ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE dx = array ( [ 0 , 0 , 2. / 3 , 0 , 0 ] ) NEW_LINE dy = array ( [ 4 , - 1 , 0 , - .25 , - 4 ] ) NEW_LINE dxdy = array ( [ 160 , 65 , 0 , 55 , 32 ] ) / 24. NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 , grid = False ) , dx ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dy = 1 , grid = False ) , dy ) NEW_LINE assert_array_almost_equal ( lut ( x , y , dx = 1 , dy = 1 , grid = False ) , dxdy ) NEW_LINE DEDENT def test_broadcast ( self ) : NEW_LINE INDENT x = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE y = array ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectBivariateSpline ( x , y , z ) NEW_LINE assert_allclose ( lut ( x , y ) , lut ( x [ : , None ] , y [ None , : ] , grid = False ) ) NEW_LINE DEDENT DEDENT class TestRectSphereBivariateSpline ( TestCase ) : NEW_LINE INDENT def test_defaults ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE assert_array_almost_equal ( lut ( x , y ) , z ) NEW_LINE DEDENT def test_evaluate ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE yi = [ 0.2 , 1 , 2.3 , 2.35 , 3.0 , 3.99 , 5.25 ] NEW_LINE xi = [ 1.5 , 0.4 , 1.1 , 0.45 , 0.2345 , 1. , 0.0001 ] NEW_LINE zi = lut . ev ( xi , yi ) NEW_LINE zi2 = array ( [ lut ( xp , yp ) [ 0 , 0 ] for xp , yp in zip ( xi , yi ) ] ) NEW_LINE assert_almost_equal ( zi , zi2 ) NEW_LINE DEDENT def test_derivatives_grid ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE y = linspace ( 0.02 , 2 * pi - 0.02 , 7 ) NEW_LINE x = linspace ( 0.02 , pi - 0.02 , 7 ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 ) , _numdiff_2d ( lut , x , y , dx = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dphi = 1 ) , _numdiff_2d ( lut , x , y , dy = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 , dphi = 1 ) , _numdiff_2d ( lut , x , y , dx = 1 , dy = 1 , eps = 1e-6 ) , rtol = 1e-3 , atol = 1e-3 ) NEW_LINE DEDENT def test_derivatives ( self ) : NEW_LINE INDENT y = linspace ( 0.01 , 2 * pi - 0.01 , 7 ) NEW_LINE x = linspace ( 0.01 , pi - 0.01 , 7 ) NEW_LINE z = array ( [ [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 3 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 2 , 2 , 1 , 2 , 1 ] , [ 1 , 2 , 1 , 2 , 1 , 2 , 1 ] ] ) NEW_LINE lut = RectSphereBivariateSpline ( x , y , z ) NEW_LINE y = linspace ( 0.02 , 2 * pi - 0.02 , 7 ) NEW_LINE x = linspace ( 0.02 , pi - 0.02 , 7 ) NEW_LINE assert_equal ( lut ( x , y , dtheta = 1 , grid = False ) . shape , x . shape ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 , grid = False ) , _numdiff_2d ( lambda x , y : lut ( x , y , grid = False ) , x , y , dx = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dphi = 1 , grid = False ) , _numdiff_2d ( lambda x , y : lut ( x , y , grid = False ) , x , y , dy = 1 ) , rtol = 1e-4 , atol = 1e-4 ) NEW_LINE assert_allclose ( lut ( x , y , dtheta = 1 , dphi = 1 , grid = False ) , _numdiff_2d ( lambda x , y : lut ( x , y , grid = False ) , x , y , dx = 1 , dy = 1 , eps = 1e-6 ) , rtol = 1e-3 , atol = 1e-3 ) NEW_LINE DEDENT DEDENT def _numdiff_2d ( func , x , y , dx = 0 , dy = 0 , eps = 1e-8 ) : NEW_LINE INDENT if dx == 0 and dy == 0 : NEW_LINE INDENT return func ( x , y ) NEW_LINE DEDENT elif dx == 1 and dy == 0 : NEW_LINE INDENT return ( func ( x + eps , y ) - func ( x - eps , y ) ) / ( 2 * eps ) NEW_LINE DEDENT elif dx == 0 and dy == 1 : NEW_LINE INDENT return ( func ( x , y + eps ) - func ( x , y - eps ) ) / ( 2 * eps ) NEW_LINE DEDENT elif dx == 1 and dy == 1 : NEW_LINE INDENT return ( func ( x + eps , y + eps ) - func ( x - eps , y + eps ) - func ( x + eps , y - eps ) + func ( x - eps , y - eps ) ) / ( 2 * eps ) ** 2 NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " invalid ▁ derivative ▁ order " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT run_module_suite ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="chenlian2015/skia_from_google/tree/master/tools/skp/page_sets/skia_youtube_desktop.py"> # ▁ Copyright ▁ 2014 ▁ The ▁ Chromium ▁ Authors . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Use ▁ of ▁ this ▁ source ▁ code ▁ is ▁ governed ▁ by ▁ a ▁ BSD - style ▁ license ▁ that ▁ can ▁ be ENDCOM # ▁ found ▁ in ▁ the ▁ LICENSE ▁ file . ENDCOM # ▁ pylint : ▁ disable = W0401 , W0614 ENDCOM from telemetry . page import page as page_module NEW_LINE from telemetry . page import page_set as page_set_module NEW_LINE class SkiaBuildbotDesktopPage ( page_module . Page ) : NEW_LINE INDENT def __init__ ( self , url , page_set ) : NEW_LINE INDENT super ( SkiaBuildbotDesktopPage , self ) . __init__ ( url = url , page_set = page_set , credentials_path = ' data / credentials . json ' ) NEW_LINE self . user_agent_type = ' desktop ' NEW_LINE self . archive_data_file = ' data / skia _ youtube _ desktop . json ' NEW_LINE DEDENT def RunNavigateSteps ( self , action_runner ) : NEW_LINE INDENT action_runner . NavigateToPage ( self ) NEW_LINE action_runner . Wait ( 25 ) NEW_LINE DEDENT DEDENT class SkiaYoutubeDesktopPageSet ( page_set_module . PageSet ) : NEW_LINE INDENT """ ▁ Pages ▁ designed ▁ to ▁ represent ▁ the ▁ median , ▁ not ▁ highly ▁ optimized ▁ web ▁ """ NEW_LINE def __init__ ( self ) : NEW_LINE INDENT super ( SkiaYoutubeDesktopPageSet , self ) . __init__ ( user_agent_type = ' desktop ' , archive_data_file = ' data / skia _ youtube _ desktop . json ' ) NEW_LINE urls_list = [ # ▁ Why : ▁ # 3 ▁ ( Alexa ▁ global ) ENDCOM ' http : / / www . youtube . com / watch ? v = PC57z - oDPLs ' , ] NEW_LINE for url in urls_list : NEW_LINE INDENT self . AddPage ( SkiaBuildbotDesktopPage ( url , self ) ) NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="brandonivey/django-marimo/tree/master/marimo/templatetags/writecapture.py"> import json NEW_LINE import random NEW_LINE from django import template NEW_LINE import logging NEW_LINE logger = logging . getLogger ( __name__ ) NEW_LINE register = template . Library ( ) NEW_LINE def jsescape ( string ) : NEW_LINE INDENT """ ▁ escaping ▁ so ▁ that ▁ javascript ▁ can ▁ be ▁ safely ▁ put ▁ into ▁ json ▁ dicts STRNEWLINE ▁ for ▁ some ▁ reason ▁ json ▁ newline ▁ escaping ▁ isn ' t ▁ enough ? ? STRNEWLINE ▁ """ NEW_LINE return string . replace ( ' < script ' , ' $ BEGINSCRIPT ' ) . replace ( ' < / script > ' , ' $ ENDSCRIPT ' ) . replace ( ' \n ' , ' $ NEWLINE ' ) . replace ( ' ' , ' ' ) NEW_LINE DEDENT @ register . tag ( name = ' writecapture ' ) NEW_LINE def write_capture ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture ▁ [ filter ] ▁ [ " prototype " ] ▁ [ " widget _ id " ] ▁ % } STRNEWLINE ▁ < script ▁ src = " evil . js " > STRNEWLINE ▁ document . write ( ' this ▁ is ▁ evil ' ) STRNEWLINE ▁ < script > STRNEWLINE ▁ { % ▁ endwritecapture ▁ % } STRNEWLINE STRNEWLINE ▁ Wraps ▁ the ▁ enclosed ▁ HTML ▁ inside ▁ of ▁ a ▁ marimo ▁ writecapture ▁ widget . STRNEWLINE STRNEWLINE ▁ The ▁ ` ` filter ` ` ▁ argument ▁ is ▁ a ▁ boolean ▁ ( default ▁ False ) ▁ that ▁ turns ▁ on ▁ a STRNEWLINE ▁ writecapture ▁ feature ▁ called ▁ writeOnGetElementById . ▁ This ▁ fixes ▁ some STRNEWLINE ▁ extra - bad ▁ scripts . STRNEWLINE STRNEWLINE ▁ The ▁ ` ` prototype ` ` ▁ argument ▁ defaults ▁ to ▁ ' writecapture . ' ▁ You ▁ will ▁ only STRNEWLINE ▁ need ▁ to ▁ use ▁ this ▁ if ▁ you ▁ have ▁ subclassed ▁ marimo ' s ▁ built - in ▁ writecapture STRNEWLINE ▁ widget ▁ and ▁ want ▁ to ▁ use ▁ that ▁ instead . STRNEWLINE STRNEWLINE ▁ The ▁ ` ` widget _ id ` ` ▁ argument ▁ defaults ▁ to ▁ a ▁ ' writecapture _ < randomnumber > . ' STRNEWLINE ▁ Use ▁ this ▁ only ▁ if ▁ you ▁ need ▁ to ▁ specify ▁ an ▁ alternate ▁ element ▁ id ▁ in ▁ the ▁ DOM STRNEWLINE ▁ to ▁ write ▁ to ▁ ( otherwise ▁ one ▁ will ▁ be ▁ created ▁ for ▁ you ▁ at ▁ the ▁ site ▁ of ▁ the STRNEWLINE ▁ { % writecapture % } ▁ invocation ) . . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE # ▁ TODO ▁ should ▁ work ▁ with ▁ marimo ▁ fast ▁ and ▁ widget _ id ▁ should ▁ be ▁ resolved ▁ maybe ENDCOM tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 4 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture ▁ block ▁ takes ▁ at ▁ most ▁ 3 ▁ arguments " ) NEW_LINE DEDENT nodelist = parser . parse ( ( ' endwritecapture ' , ) ) NEW_LINE parser . delete_first_token ( ) NEW_LINE if len ( tokens ) > 1 : NEW_LINE INDENT script_filter = tokens [ 1 ] NEW_LINE if script_filter == ' False ' : NEW_LINE INDENT script_filter = False NEW_LINE DEDENT elif script_filter == ' True ' : NEW_LINE INDENT script_filter = True NEW_LINE DEDENT else : NEW_LINE INDENT script_filter = template . Variable ( script_filter ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT script_filter = False NEW_LINE DEDENT return WriteCaptureNode ( nodelist , script_filter , * tokens [ 2 : ] ) NEW_LINE DEDENT class WriteCaptureNode ( template . Node ) : NEW_LINE INDENT def __init__ ( self , nodelist , script_filter = False , prototype = ' writecapture _ widget ' , widget_id = None ) : NEW_LINE INDENT self . nodelist = nodelist NEW_LINE self . script_filter = script_filter NEW_LINE self . prototype = prototype NEW_LINE self . widget_id = widget_id NEW_LINE if not self . widget_id : NEW_LINE INDENT self . widget_id = ' writecapture ' + str ( random . randint ( 0 , 99999999 ) ) NEW_LINE DEDENT DEDENT def render ( self , context ) : NEW_LINE INDENT eviloutput = jsescape ( self . nodelist . render ( context ) ) NEW_LINE if isinstance ( self . script_filter , template . Variable ) : NEW_LINE INDENT self . script_filter = bool ( self . script_filter . resolve ( context ) ) NEW_LINE # ▁ Set ▁ this ▁ flag ▁ in ▁ your ▁ template ▁ tag ▁ for ▁ advanced ▁ write ▁ capture ▁ widget ▁ sanitation . ENDCOM # ▁ Source : ▁ https : / / github . com / iamnoah / writeCapture / wiki / Usage ENDCOM DEDENT global_compatibility_mode = context . get ( ' wc _ compatibility _ mode ' , None ) NEW_LINE if global_compatibility_mode is None : NEW_LINE INDENT wc_compatibility_mode = self . script_filter NEW_LINE DEDENT else : NEW_LINE INDENT wc_compatibility_mode = global_compatibility_mode NEW_LINE DEDENT widget_dict = dict ( widget_prototype = self . prototype , id = self . widget_id , html = eviloutput , wc_compatibility_mode = wc_compatibility_mode , ) NEW_LINE output = """ < div ▁ id = " { widget _ id } " > < / div > STRNEWLINE < script ▁ type = " text / javascript " > STRNEWLINE ▁ ▁ ▁ ▁ marimo . emit ( ' { widget _ id } _ ready ' ) ; STRNEWLINE ▁ ▁ ▁ ▁ marimo . add _ widget ( { widget _ json } ) ; STRNEWLINE < / script > """ NEW_LINE output = output . format ( widget_id = self . widget_id , widget_json = json . dumps ( widget_dict ) , ) NEW_LINE return output NEW_LINE DEDENT DEDENT @ register . tag ( name = ' writecapture _ delay ' ) NEW_LINE def write_capture_delay ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture _ delay ▁ [ event _ name ] ▁ % } STRNEWLINE ▁ """ NEW_LINE tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 2 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture _ delay ▁ takes ▁ at ▁ most ▁ 1 ▁ argument " ) NEW_LINE DEDENT if len ( tokens ) == 2 : NEW_LINE INDENT return WriteCaptureDelayNode ( tokens [ 1 ] ) NEW_LINE DEDENT return WriteCaptureDelayNode ( ) NEW_LINE DEDENT class WriteCaptureDelayNode ( template . Node ) : NEW_LINE INDENT def __init__ ( self , event = None ) : NEW_LINE INDENT self . event = event NEW_LINE DEDENT def render ( self , context ) : NEW_LINE INDENT output = ' ' NEW_LINE if self . event is None : NEW_LINE INDENT self . event = ' write _ ' + str ( random . randint ( 0 , 999999 ) ) NEW_LINE output = """ < script ▁ type = " text / javascript " > marimo . emit ( ' % s ' ) ; < / script > """ % self . event NEW_LINE # ▁ this ▁ should ▁ only ▁ be ▁ used ▁ once ▁ per ▁ page ▁ if ▁ it ' s ▁ uses ▁ a ▁ second ▁ time ENDCOM # ▁ overwrite ▁ but ▁ log ▁ an ▁ error ENDCOM DEDENT wc_delay = context . get ( ' marimo _ writecapture _ delay ' , None ) NEW_LINE if not wc_delay : NEW_LINE INDENT logger . error ( " The ▁ writecapture _ delay ▁ was ▁ called ▁ but ▁ didn ' t ▁ find ▁ " " marimo _ writecapture _ delay ▁ in ▁ the ▁ context . ▁ The ▁ tag ▁ " " depends ▁ on ▁ the ▁ Marimo ▁ middleware ▁ and ▁ context _ processor . " ) NEW_LINE return output NEW_LINE DEDENT if wc_delay . marimo_event : NEW_LINE INDENT logger . error ( ' Overwriting ▁ the ▁ marimo ▁ event ▁ delay ▁ % s ▁ with ▁ % s ' % ( wc_delay . marimo_event , self . event ) ) NEW_LINE DEDENT wc_delay . marimo_event = self . event NEW_LINE return output NEW_LINE DEDENT DEDENT @ register . tag ( name = ' writecapture _ delay ' ) NEW_LINE def write_capture_delay ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture _ delay ▁ [ event _ name ] ▁ % } STRNEWLINE ▁ """ NEW_LINE tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 2 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture _ delay ▁ takes ▁ at ▁ most ▁ 1 ▁ argument " ) NEW_LINE DEDENT if len ( tokens ) == 2 : NEW_LINE INDENT return WriteCaptureDelayNode ( tokens [ 1 ] ) NEW_LINE DEDENT return WriteCaptureDelayNode ( ) NEW_LINE DEDENT class WriteCaptureDelayNode ( template . Node ) : NEW_LINE INDENT def __init__ ( self , event = None ) : NEW_LINE INDENT self . event = event NEW_LINE DEDENT def render ( self , context ) : NEW_LINE INDENT output = ' ' NEW_LINE if self . event is None : NEW_LINE INDENT self . event = ' write _ ' + str ( random . randint ( 0 , 999999 ) ) NEW_LINE output = """ < script ▁ type = " text / javascript " > marimo . emit ( ' % s ' ) ; < / script > """ % self . event NEW_LINE # ▁ this ▁ should ▁ only ▁ be ▁ used ▁ once ▁ per ▁ page ▁ if ▁ it ' s ▁ uses ▁ a ▁ second ▁ time ENDCOM # ▁ overwrite ▁ but ▁ log ▁ an ▁ error ENDCOM DEDENT wc_delay = context . get ( ' marimo _ writecapture _ delay ' , None ) NEW_LINE if not wc_delay : NEW_LINE INDENT logger . error ( " The ▁ writecapture _ delay ▁ was ▁ called ▁ but ▁ didn ' t ▁ find ▁ " " marimo _ writecapture _ delay ▁ in ▁ the ▁ context . ▁ The ▁ tag ▁ " " depends ▁ on ▁ the ▁ Marimo ▁ middleware ▁ and ▁ context _ processor . " ) NEW_LINE return output NEW_LINE DEDENT if wc_delay . marimo_event : NEW_LINE INDENT logger . error ( ' Overwriting ▁ the ▁ marimo ▁ event ▁ delay ▁ % s ▁ with ▁ % s ' % ( wc_delay . marimo_event , self . event ) ) NEW_LINE DEDENT wc_delay . marimo_event = self . event NEW_LINE return output NEW_LINE DEDENT DEDENT @ register . tag ( name = ' writecapture _ delay ' ) NEW_LINE def write_capture_delay ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture _ delay ▁ [ event _ name ] ▁ % } STRNEWLINE ▁ """ NEW_LINE tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 2 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture _ delay ▁ takes ▁ at ▁ most ▁ 1 ▁ argument " ) NEW_LINE DEDENT if len ( tokens ) == 2 : NEW_LINE INDENT return WriteCaptureDelayNode ( tokens [ 1 ] ) NEW_LINE DEDENT return WriteCaptureDelayNode ( ) NEW_LINE DEDENT class WriteCaptureDelayNode ( template . Node ) : NEW_LINE INDENT def __init__ ( self , event = None ) : NEW_LINE INDENT self . event = event NEW_LINE DEDENT def render ( self , context ) : NEW_LINE INDENT output = ' ' NEW_LINE if self . event is None : NEW_LINE INDENT self . event = ' write _ ' + str ( random . randint ( 0 , 999999 ) ) NEW_LINE output = """ < script ▁ type = " text / javascript " > marimo . emit ( ' % s ' ) ; < / script > """ % self . event NEW_LINE # ▁ this ▁ should ▁ only ▁ be ▁ used ▁ once ▁ per ▁ page ▁ if ▁ it ' s ▁ uses ▁ a ▁ second ▁ time ENDCOM # ▁ overwrite ▁ but ▁ log ▁ an ▁ error ENDCOM DEDENT wc_delay = context . get ( ' marimo _ writecapture _ delay ' , None ) NEW_LINE if not wc_delay : NEW_LINE INDENT logger . error ( " The ▁ writecapture _ delay ▁ was ▁ called ▁ but ▁ didn ' t ▁ find ▁ " " marimo _ writecapture _ delay ▁ in ▁ the ▁ context . ▁ The ▁ tag ▁ " " depends ▁ on ▁ the ▁ Marimo ▁ middleware ▁ and ▁ context _ processor . " ) NEW_LINE return output NEW_LINE DEDENT if wc_delay . marimo_event : NEW_LINE INDENT logger . error ( ' Overwriting ▁ the ▁ marimo ▁ event ▁ delay ▁ % s ▁ with ▁ % s ' % ( wc_delay . marimo_event , self . event ) ) NEW_LINE DEDENT wc_delay . marimo_event = self . event NEW_LINE return output NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="FHannes/intellij-community/tree/master/python/testData/intentions/returnTypeInPy3Annotation2_after.py"> def my_func ( p1 = 1 ) -> object : NEW_LINE INDENT return p1 NEW_LINE DEDENT d = my_func ( 1 ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="xadahiya/django/tree/master/django/contrib/admin/actions.py"> """ STRNEWLINE Built - in , ▁ globally - available ▁ admin ▁ actions . STRNEWLINE """ NEW_LINE from django . contrib import messages NEW_LINE from django . contrib . admin import helpers NEW_LINE from django . contrib . admin . utils import get_deleted_objects , model_ngettext NEW_LINE from django . core . exceptions import PermissionDenied NEW_LINE from django . db import router NEW_LINE from django . template . response import TemplateResponse NEW_LINE from django . utils . encoding import force_text NEW_LINE from django . utils . translation import ugettext as _ , ugettext_lazy NEW_LINE def delete_selected ( modeladmin , request , queryset ) : NEW_LINE INDENT """ STRNEWLINE ▁ Default ▁ action ▁ which ▁ deletes ▁ the ▁ selected ▁ objects . STRNEWLINE STRNEWLINE ▁ This ▁ action ▁ first ▁ displays ▁ a ▁ confirmation ▁ page ▁ whichs ▁ shows ▁ all ▁ the STRNEWLINE ▁ deleteable ▁ objects , ▁ or , ▁ if ▁ the ▁ user ▁ has ▁ no ▁ permission ▁ one ▁ of ▁ the ▁ related STRNEWLINE ▁ childs ▁ ( foreignkeys ) , ▁ a ▁ " permission ▁ denied " ▁ message . STRNEWLINE STRNEWLINE ▁ Next , ▁ it ▁ deletes ▁ all ▁ selected ▁ objects ▁ and ▁ redirects ▁ back ▁ to ▁ the ▁ change ▁ list . STRNEWLINE ▁ """ NEW_LINE opts = modeladmin . model . _meta NEW_LINE app_label = opts . app_label NEW_LINE # ▁ Check ▁ that ▁ the ▁ user ▁ has ▁ delete ▁ permission ▁ for ▁ the ▁ actual ▁ model ENDCOM if not modeladmin . has_delete_permission ( request ) : NEW_LINE INDENT raise PermissionDenied NEW_LINE DEDENT using = router . db_for_write ( modeladmin . model ) NEW_LINE # ▁ Populate ▁ deletable _ objects , ▁ a ▁ data ▁ structure ▁ of ▁ all ▁ related ▁ objects ▁ that ENDCOM # ▁ will ▁ also ▁ be ▁ deleted . ENDCOM deletable_objects , model_count , perms_needed , protected = get_deleted_objects ( queryset , opts , request . user , modeladmin . admin_site , using ) NEW_LINE # ▁ The ▁ user ▁ has ▁ already ▁ confirmed ▁ the ▁ deletion . ENDCOM # ▁ Do ▁ the ▁ deletion ▁ and ▁ return ▁ a ▁ None ▁ to ▁ display ▁ the ▁ change ▁ list ▁ view ▁ again . ENDCOM if request . POST . get ( ' post ' ) : NEW_LINE INDENT if perms_needed : NEW_LINE INDENT raise PermissionDenied NEW_LINE DEDENT n = queryset . count ( ) NEW_LINE if n : NEW_LINE INDENT for obj in queryset : NEW_LINE INDENT obj_display = force_text ( obj ) NEW_LINE modeladmin . log_deletion ( request , obj , obj_display ) NEW_LINE DEDENT queryset . delete ( ) NEW_LINE modeladmin . message_user ( request , _ ( " Successfully ▁ deleted ▁ % ( count ) d ▁ % ( items ) s . " ) % { " count " : n , " items " : model_ngettext ( modeladmin . opts , n ) } , messages . SUCCESS ) NEW_LINE # ▁ Return ▁ None ▁ to ▁ display ▁ the ▁ change ▁ list ▁ page ▁ again . ENDCOM DEDENT return None NEW_LINE DEDENT if len ( queryset ) == 1 : NEW_LINE INDENT objects_name = force_text ( opts . verbose_name ) NEW_LINE DEDENT else : NEW_LINE INDENT objects_name = force_text ( opts . verbose_name_plural ) NEW_LINE DEDENT if perms_needed or protected : NEW_LINE INDENT title = _ ( " Cannot ▁ delete ▁ % ( name ) s " ) % { " name " : objects_name } NEW_LINE DEDENT else : NEW_LINE INDENT title = _ ( " Are ▁ you ▁ sure ? " ) NEW_LINE DEDENT context = dict ( modeladmin . admin_site . each_context ( request ) , title = title , objects_name = objects_name , deletable_objects = [ deletable_objects ] , model_count = dict ( model_count ) . items ( ) , queryset = queryset , perms_lacking = perms_needed , protected = protected , opts = opts , action_checkbox_name = helpers . ACTION_CHECKBOX_NAME , ) NEW_LINE request . current_app = modeladmin . admin_site . name NEW_LINE # ▁ Display ▁ the ▁ confirmation ▁ page ENDCOM return TemplateResponse ( request , modeladmin . delete_selected_confirmation_template or [ " admin / % s / % s / delete _ selected _ confirmation . html " % ( app_label , opts . model_name ) , " admin / % s / delete _ selected _ confirmation . html " % app_label , " admin / delete _ selected _ confirmation . html " ] , context ) NEW_LINE DEDENT delete_selected . short_description = ugettext_lazy ( " Delete ▁ selected ▁ % ( verbose _ name _ plural ) s " ) NEW_LINE </DOCUMENT>
