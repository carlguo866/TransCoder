def setUp ( self ) : NEW_LINE INDENT ''' Create ▁ temporary ▁ output ▁ and ▁ cache ▁ folders ''' NEW_LINE self . temp_path = mkdtemp ( prefix = ' pelicantests . ' ) NEW_LINE self . temp_cache = mkdtemp ( prefix = ' pelican _ cache . ' ) NEW_LINE os . chdir ( TEST_DATA_DIR ) NEW_LINE DEDENT
def tearDown ( self ) : NEW_LINE INDENT ''' Remove ▁ output ▁ and ▁ cache ▁ folders ''' NEW_LINE rmtree ( self . temp_path ) NEW_LINE rmtree ( self . temp_cache ) NEW_LINE os . chdir ( PLUGIN_DIR ) NEW_LINE DEDENT
def test_generate_with_ipython3 ( self ) : NEW_LINE INDENT ''' Test ▁ generation ▁ of ▁ site ▁ with ▁ the ▁ plugin . ''' NEW_LINE base_path = os . path . dirname ( os . path . abspath ( __file__ ) ) NEW_LINE base_path = os . path . join ( base_path , ' test _ data ' ) NEW_LINE content_path = os . path . join ( base_path , ' content ' ) NEW_LINE output_path = os . path . join ( base_path , ' output ' ) NEW_LINE settings_path = os . path . join ( base_path , ' pelicanconf . py ' ) NEW_LINE settings = read_settings ( path = settings_path , override = { ' PATH ' : content_path , ' OUTPUT _ PATH ' : self . temp_path , ' CACHE _ PATH ' : self . temp_cache , } ) NEW_LINE pelican = Pelican ( settings ) NEW_LINE pelican . run ( ) NEW_LINE # ▁ test ▁ existence ENDCOM assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 3 . html ' ) ) NEW_LINE assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 4 . html ' ) ) NEW_LINE # ▁ test ▁ differences ENDCOM # assert ▁ filecmp . cmp ( os . path . join ( output _ path , ENDCOM # ▁ ' test - ipython - notebook - v2 . html ' ) , ENDCOM # ▁ os . path . join ( self . temp _ path , ENDCOM # ▁ ' test - ipython - notebook . html ' ) ) ENDCOM DEDENT
def test_generate_with_ipython2 ( self ) : NEW_LINE INDENT ''' Test ▁ generation ▁ of ▁ site ▁ with ▁ the ▁ plugin . ''' NEW_LINE base_path = os . path . dirname ( os . path . abspath ( __file__ ) ) NEW_LINE base_path = os . path . join ( base_path , ' test _ data ' ) NEW_LINE content_path = os . path . join ( base_path , ' content ' ) NEW_LINE output_path = os . path . join ( base_path , ' output ' ) NEW_LINE settings_path = os . path . join ( base_path , ' pelicanconf . py ' ) NEW_LINE settings = read_settings ( path = settings_path , override = { ' PATH ' : content_path , ' OUTPUT _ PATH ' : self . temp_path , ' CACHE _ PATH ' : self . temp_cache , } ) NEW_LINE pelican = Pelican ( settings ) NEW_LINE pelican . run ( ) NEW_LINE # ▁ test ▁ existence ENDCOM assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 3 . html ' ) ) NEW_LINE assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 4 . html ' ) ) NEW_LINE # ▁ test ▁ differences ENDCOM # assert ▁ filecmp . cmp ( os . path . join ( output _ path , ENDCOM # ▁ ' test - ipython - notebook - v3 . html ' ) , ENDCOM # ▁ os . path . join ( self . temp _ path , ENDCOM # ▁ ' test - ipython - notebook . html ' ) ) ENDCOM DEDENT
def __init__ ( self ) : NEW_LINE INDENT self . handler = handlers . handler ( self . handle_request ) NEW_LINE DEDENT
def __call__ ( self , request , response ) : NEW_LINE INDENT return self . handler ( request , response ) NEW_LINE DEDENT
def handle_request ( self , request , response ) : NEW_LINE INDENT worker_path = request . url_parts . path . replace ( " . worker " , " . worker . js " ) NEW_LINE return """ < ! doctype ▁ html > STRNEWLINE < meta ▁ charset = utf - 8 > STRNEWLINE < script ▁ src = " / resources / testharness . js " > < / script > STRNEWLINE < script ▁ src = " / resources / testharnessreport . js " > < / script > STRNEWLINE < div ▁ id = log > < / div > STRNEWLINE < script > STRNEWLINE fetch _ tests _ from _ worker ( new ▁ Worker ( " % s " ) ) ; STRNEWLINE < / script > STRNEWLINE """ % ( worker_path , ) NEW_LINE DEDENT
def __init__ ( self ) : NEW_LINE INDENT self . forbidden_override = [ ( " GET " , " / tools / runner / * " , handlers . file_handler ) , ( " POST " , " / tools / runner / update _ manifest . py " , handlers . python_script_handler ) ] NEW_LINE self . forbidden = [ ( " * " , " / _ certs / * " , handlers . ErrorHandler ( 404 ) ) , ( " * " , " / tools / * " , handlers . ErrorHandler ( 404 ) ) , ( " * " , " { spec } / tools / * " , handlers . ErrorHandler ( 404 ) ) , ( " * " , " / serve . py " , handlers . ErrorHandler ( 404 ) ) ] NEW_LINE self . static = [ ( " GET " , " * . worker " , WorkersHandler ( ) ) ] NEW_LINE self . mountpoint_routes = OrderedDict ( ) NEW_LINE self . add_mount_point ( " / " , None ) NEW_LINE DEDENT
def get_routes ( self ) : NEW_LINE INDENT routes = self . forbidden_override + self . forbidden + self . static NEW_LINE # ▁ Using ▁ reversed ▁ here ▁ means ▁ that ▁ mount ▁ points ▁ that ▁ are ▁ added ▁ later ENDCOM # ▁ get ▁ higher ▁ priority . ▁ This ▁ makes ▁ sense ▁ since ▁ / ▁ is ▁ typically ▁ added ENDCOM # ▁ first . ENDCOM for item in reversed ( self . mountpoint_routes . values ( ) ) : NEW_LINE INDENT routes . extend ( item ) NEW_LINE DEDENT return routes NEW_LINE DEDENT
def add_static ( self , path , format_args , content_type , route ) : NEW_LINE INDENT handler = handlers . StaticHandler ( path , format_args , content_type ) NEW_LINE self . static . append ( ( b " GET " , str ( route ) , handler ) ) NEW_LINE DEDENT
def add_mount_point ( self , url_base , path ) : NEW_LINE INDENT url_base = " / % s / " % url_base . strip ( " / " ) if url_base != " / " else " / " NEW_LINE self . mountpoint_routes [ url_base ] = [ ] NEW_LINE routes = [ ( " GET " , " * . asis " , handlers . AsIsHandler ) , ( " * " , " * . py " , handlers . PythonScriptHandler ) , ( " GET " , " * " , handlers . FileHandler ) ] NEW_LINE for ( method , suffix , handler_cls ) in routes : NEW_LINE INDENT self . mountpoint_routes [ url_base ] . append ( ( method , b " % s % s " % ( str ( url_base ) if url_base != " / " else " " , str ( suffix ) ) , handler_cls ( base_path = path , url_base = url_base ) ) ) NEW_LINE DEDENT DEDENT
def __init__ ( self ) : NEW_LINE INDENT self . proc = None NEW_LINE self . daemon = None NEW_LINE self . stop = Event ( ) NEW_LINE DEDENT
def start ( self , init_func , host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT self . proc = Process ( target = self . create_daemon , args = ( init_func , host , port , paths , routes , bind_hostname , external_config , ssl_config ) ) NEW_LINE self . proc . daemon = True NEW_LINE self . proc . start ( ) NEW_LINE DEDENT
def wait ( self ) : NEW_LINE INDENT self . stop . set ( ) NEW_LINE self . proc . join ( ) NEW_LINE DEDENT
def kill ( self ) : NEW_LINE INDENT self . stop . set ( ) NEW_LINE self . proc . terminate ( ) NEW_LINE self . proc . join ( ) NEW_LINE DEDENT
def is_alive ( self ) : NEW_LINE INDENT return self . proc . is_alive ( ) NEW_LINE DEDENT
def start ( self , block = False ) : NEW_LINE INDENT self . started = True NEW_LINE if block : NEW_LINE INDENT self . server . serve_forever ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . server_thread = threading . Thread ( target = self . server . serve_forever ) NEW_LINE self . server_thread . setDaemon ( True ) # ▁ don ' t ▁ hang ▁ on ▁ exit ENDCOM NEW_LINE self . server_thread . start ( ) NEW_LINE DEDENT DEDENT
def stop ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Stops ▁ the ▁ server . STRNEWLINE STRNEWLINE ▁ If ▁ the ▁ server ▁ is ▁ not ▁ running , ▁ this ▁ method ▁ has ▁ no ▁ effect . STRNEWLINE ▁ """ NEW_LINE if self . started : NEW_LINE INDENT try : NEW_LINE INDENT self . server . shutdown ( ) NEW_LINE self . server . server_close ( ) NEW_LINE self . server_thread . join ( ) NEW_LINE self . server_thread = None NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT pass NEW_LINE DEDENT self . started = False NEW_LINE DEDENT self . server = None NEW_LINE DEDENT
def ▁ user ( self ) : STRNEWLINE ▁ return ▁ relationship ( " User " ) STRNEWLINE STRNEWLINE ▁ It ▁ also ▁ can ▁ be ▁ applied ▁ to ▁ mapped ▁ classes , ▁ such ▁ as ▁ to ▁ provide STRNEWLINE ▁ a ▁ " polymorphic " ▁ scheme ▁ for ▁ inheritance : : STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( Base ) : STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ type ▁ = ▁ Column ( String ( 50 ) , ▁ nullable = False ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ tablename _ _ ( cls ) : STRNEWLINE ▁ return ▁ cls . _ _ name _ _ . lower ( ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ mapper _ args _ _ ( cls ) : STRNEWLINE ▁ if ▁ cls . _ _ name _ _ ▁ = = ▁ ' Employee ' : STRNEWLINE ▁ return ▁ { STRNEWLINE ▁ " polymorphic _ on " : cls . type , STRNEWLINE ▁ " polymorphic _ identity " : " Employee " STRNEWLINE ▁ } STRNEWLINE ▁ else : STRNEWLINE ▁ return ▁ { " polymorphic _ identity " : cls . _ _ name _ _ } STRNEWLINE STRNEWLINE ▁ . . ▁ versionchanged : : ▁ 0.8 ▁ : class : ` . declared _ attr ` ▁ can ▁ be ▁ used ▁ with STRNEWLINE ▁ non - ORM ▁ or ▁ extension ▁ attributes , ▁ such ▁ as ▁ user - defined ▁ attributes STRNEWLINE ▁ or ▁ : func : ` . association _ proxy ` ▁ objects , ▁ which ▁ will ▁ be ▁ assigned STRNEWLINE ▁ to ▁ the ▁ class ▁ at ▁ class ▁ construction ▁ time . STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , fget , cascading = False ) : NEW_LINE INDENT super ( declared_attr , self ) . __init__ ( fget ) NEW_LINE self . __doc__ = fget . __doc__ NEW_LINE self . _cascading = cascading NEW_LINE DEDENT
def __init__ ( self , ** kw ) : NEW_LINE INDENT self . kw = kw NEW_LINE DEDENT
def _stateful ( self , ** kw ) : NEW_LINE INDENT new_kw = self . kw . copy ( ) NEW_LINE new_kw . update ( kw ) NEW_LINE return _stateful_declared_attr ( ** new_kw ) NEW_LINE DEDENT
def __call__ ( self , fn ) : NEW_LINE INDENT return declared_attr ( fn , ** self . kw ) NEW_LINE DEDENT
def __len__ ( self ) : NEW_LINE INDENT return 1 << 31 NEW_LINE DEDENT
def __init__ ( self , name ) : NEW_LINE INDENT self . name = name NEW_LINE DEDENT
def __get__ ( self , obj , tp ) : NEW_LINE INDENT result = self . _resolve ( ) NEW_LINE setattr ( obj , self . name , result ) # ▁ Invokes ▁ _ _ set _ _ . ENDCOM NEW_LINE try : NEW_LINE # ▁ This ▁ is ▁ a ▁ bit ▁ ugly , ▁ but ▁ it ▁ avoids ▁ running ▁ this ▁ again ▁ by ENDCOM # ▁ removing ▁ this ▁ descriptor . ENDCOM INDENT delattr ( obj . __class__ , self . name ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT pass NEW_LINE DEDENT return result NEW_LINE DEDENT
def __init__ ( self , name , old , new = None ) : NEW_LINE INDENT super ( MovedModule , self ) . __init__ ( name ) NEW_LINE if PY3 : NEW_LINE INDENT if new is None : NEW_LINE INDENT new = name NEW_LINE DEDENT self . mod = new NEW_LINE DEDENT else : NEW_LINE INDENT self . mod = old NEW_LINE DEDENT DEDENT
def _resolve ( self ) : NEW_LINE INDENT return _import_module ( self . mod ) NEW_LINE DEDENT
def __getattr__ ( self , attr ) : NEW_LINE INDENT _module = self . _resolve ( ) NEW_LINE value = getattr ( _module , attr ) NEW_LINE setattr ( self , attr , value ) NEW_LINE return value NEW_LINE DEDENT
def __init__ ( self , name ) : NEW_LINE INDENT super ( _LazyModule , self ) . __init__ ( name ) NEW_LINE self . __doc__ = self . __class__ . __doc__ NEW_LINE DEDENT
def __dir__ ( self ) : NEW_LINE INDENT attrs = [ " _ _ doc _ _ " , " _ _ name _ _ " ] NEW_LINE attrs += [ attr . name for attr in self . _moved_attributes ] NEW_LINE return attrs NEW_LINE # ▁ Subclasses ▁ should ▁ override ▁ this ENDCOM DEDENT
def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) : NEW_LINE INDENT super ( MovedAttribute , self ) . __init__ ( name ) NEW_LINE if PY3 : NEW_LINE INDENT if new_mod is None : NEW_LINE INDENT new_mod = name NEW_LINE DEDENT self . mod = new_mod NEW_LINE if new_attr is None : NEW_LINE INDENT if old_attr is None : NEW_LINE INDENT new_attr = name NEW_LINE DEDENT else : NEW_LINE INDENT new_attr = old_attr NEW_LINE DEDENT DEDENT self . attr = new_attr NEW_LINE DEDENT else : NEW_LINE INDENT self . mod = old_mod NEW_LINE if old_attr is None : NEW_LINE INDENT old_attr = name NEW_LINE DEDENT self . attr = old_attr NEW_LINE DEDENT DEDENT
def _resolve ( self ) : NEW_LINE INDENT module = _import_module ( self . mod ) NEW_LINE return getattr ( module , self . attr ) NEW_LINE DEDENT
def __init__ ( self , six_module_name ) : NEW_LINE INDENT self . name = six_module_name NEW_LINE self . known_modules = { } NEW_LINE DEDENT
def _add_module ( self , mod , * fullnames ) : NEW_LINE INDENT for fullname in fullnames : NEW_LINE INDENT self . known_modules [ self . name + " . " + fullname ] = mod NEW_LINE DEDENT DEDENT
def _get_module ( self , fullname ) : NEW_LINE INDENT return self . known_modules [ self . name + " . " + fullname ] NEW_LINE DEDENT
def find_module ( self , fullname , path = None ) : NEW_LINE INDENT if fullname in self . known_modules : NEW_LINE INDENT return self NEW_LINE DEDENT return None NEW_LINE DEDENT
def __get_module ( self , fullname ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . known_modules [ fullname ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise ImportError ( " This ▁ loader ▁ does ▁ not ▁ know ▁ module ▁ " + fullname ) NEW_LINE DEDENT DEDENT
def load_module ( self , fullname ) : NEW_LINE INDENT try : NEW_LINE # ▁ in ▁ case ▁ of ▁ a ▁ reload ENDCOM INDENT return sys . modules [ fullname ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT mod = self . __get_module ( fullname ) NEW_LINE if isinstance ( mod , MovedModule ) : NEW_LINE INDENT mod = mod . _resolve ( ) NEW_LINE DEDENT else : NEW_LINE INDENT mod . __loader__ = self NEW_LINE DEDENT sys . modules [ fullname ] = mod NEW_LINE return mod NEW_LINE DEDENT
def is_package ( self , fullname ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ true , ▁ if ▁ the ▁ named ▁ module ▁ is ▁ a ▁ package . STRNEWLINE STRNEWLINE ▁ We ▁ need ▁ this ▁ method ▁ to ▁ get ▁ correct ▁ spec ▁ objects ▁ with STRNEWLINE ▁ Python ▁ 3.4 ▁ ( see ▁ PEP451 ) STRNEWLINE ▁ """ NEW_LINE return hasattr ( self . __get_module ( fullname ) , " _ _ path _ _ " ) NEW_LINE DEDENT
def get_code ( self , fullname ) : NEW_LINE INDENT """ Return ▁ None STRNEWLINE STRNEWLINE ▁ Required , ▁ if ▁ is _ package ▁ is ▁ implemented """ NEW_LINE self . __get_module ( fullname ) # ▁ eventually ▁ raises ▁ ImportError ENDCOM NEW_LINE return None NEW_LINE DEDENT
def __dir__ ( self ) : NEW_LINE INDENT return [ ' parse ' , ' error ' , ' request ' , ' response ' , ' robotparser ' ] NEW_LINE DEDENT
def next ( self ) : NEW_LINE INDENT return type ( self ) . __next__ ( self ) NEW_LINE DEDENT
def assertCountEqual ( self , * args , ** kwargs ) : NEW_LINE INDENT return getattr ( self , _assertCountEqual ) ( * args , ** kwargs ) NEW_LINE DEDENT
def assertRaisesRegex ( self , * args , ** kwargs ) : NEW_LINE INDENT return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs ) NEW_LINE DEDENT
def assertRegex ( self , * args , ** kwargs ) : NEW_LINE INDENT return getattr ( self , _assertRegex ) ( * args , ** kwargs ) NEW_LINE DEDENT
def execute ( self ) : NEW_LINE INDENT if ' username ' not in self . params or self . params [ ' username ' ] == None or self . params [ ' username ' ] == ' ' : NEW_LINE INDENT raise MMException ( ' Please ▁ enter ▁ a ▁ Salesforce . com ▁ username ' ) NEW_LINE DEDENT if ' password ' not in self . params or self . params [ ' password ' ] == None or self . params [ ' password ' ] == ' ' : NEW_LINE INDENT raise MMException ( ' Please ▁ enter ▁ a ▁ Salesforce . com ▁ password ' ) NEW_LINE DEDENT if ' org _ type ' not in self . params or self . params [ ' org _ type ' ] == None or self . params [ ' org _ type ' ] == ' ' : NEW_LINE INDENT raise MMException ( ' Please ▁ select ▁ an ▁ org ▁ type ' ) NEW_LINE DEDENT if ' org _ type ' in self . params and self . params [ ' org _ type ' ] == " custom " and " org _ url " not in self . params : NEW_LINE INDENT raise MMException ( ' To ▁ use ▁ a ▁ custom ▁ org ▁ type , ▁ please ▁ include ▁ a ▁ org _ url ▁ parameter ' ) NEW_LINE DEDENT if ' org _ type ' in self . params and self . params [ ' org _ type ' ] == " custom " and " org _ url " in self . params and self . params [ " org _ url " ] == " " : NEW_LINE INDENT raise MMException ( ' Please ▁ specify ▁ the ▁ org ▁ url ' ) NEW_LINE DEDENT config . logger . debug ( ' = = = = = = = = = = = = = = = = = > ' ) NEW_LINE config . logger . debug ( self . params ) NEW_LINE client = MavensMateClient ( credentials = { " username " : self . params [ ' username ' ] , " password " : self . params [ ' password ' ] , " org _ type " : self . params [ ' org _ type ' ] , " org _ url " : self . params . get ( ' org _ url ' , None ) } ) NEW_LINE response = { " sid " : client . sid , " user _ id " : client . user_id , " metadata _ server _ url " : client . metadata_server_url , " server _ url " : client . server_url , " metadata " : client . get_org_metadata ( subscription = self . params . get ( ' subscription ' , None ) ) , " org _ metadata _ types " : util . metadata_types ( ) , " success " : True } NEW_LINE return util . generate_response ( response ) NEW_LINE DEDENT
def execute ( self ) : NEW_LINE INDENT return config . project . index_apex_symbols ( self . params . get ( " files " , None ) ) NEW_LINE DEDENT
def execute ( self ) : NEW_LINE INDENT return config . project . reset_metadata_container ( accept = " json " ) NEW_LINE DEDENT
def execute ( self ) : NEW_LINE INDENT file_name = self . params [ " file _ name " ] NEW_LINE extension = util . get_file_extension_no_period ( file_name ) NEW_LINE mtype = util . get_meta_type_by_suffix ( extension ) NEW_LINE full_file_path = os . path . join ( config . project . location , " src " , mtype [ " directoryName " ] , file_name ) NEW_LINE params = { " project _ name " : config . project . project_name , " file _ name " : full_file_path , " line _ number " : self . params . get ( " line _ number " , 0 ) } NEW_LINE config . connection . run_subl_command ( " open _ file _ in _ project " , json . dumps ( params ) ) NEW_LINE return util . generate_success_response ( " ok " ) NEW_LINE DEDENT
def execute ( self ) : NEW_LINE INDENT if ' script _ name ' in self . params : # running ▁ an ▁ apex ▁ script ENDCOM NEW_LINE INDENT self . params [ " body " ] = util . get_file_as_string ( os . path . join ( config . project . location , " apex - scripts " , self . params [ " script _ name " ] ) ) NEW_LINE DEDENT if ' debug _ categories ' not in self . params and not os . path . isfile ( os . path . join ( config . project . location , " config " , " . apex _ script " ) ) : NEW_LINE INDENT self . params [ " debug _ categories " ] = [ { " category " : " Apex _ code " , " level " : " DEBUG " } ] NEW_LINE DEDENT elif os . path . isfile ( os . path . join ( config . project . location , " config " , " . apex _ script " ) ) : NEW_LINE INDENT log_settings = util . parse_json_from_file ( os . path . join ( config . project . location , " config " , " . apex _ script " ) ) NEW_LINE categories = [ ] NEW_LINE levels = log_settings [ " levels " ] NEW_LINE for category in levels . keys ( ) : NEW_LINE INDENT categories . append ( { " category " : category , " level " : levels [ category ] } ) NEW_LINE DEDENT self . params [ " debug _ categories " ] = categories NEW_LINE DEDENT elif ' debug _ categories ' not in self . params : NEW_LINE INDENT self . params [ " debug _ categories " ] = [ { " category " : " Apex _ code " , " level " : " DEBUG " } ] NEW_LINE DEDENT return_log = self . params . get ( " return _ log " , True ) NEW_LINE execute_result = config . sfdc_client . execute_apex ( self . params ) NEW_LINE result = { ' column ' : execute_result [ ' column ' ] , ' compileProblem ' : execute_result [ ' compileProblem ' ] , ' compiled ' : execute_result [ ' compiled ' ] , ' exceptionMessage ' : execute_result [ ' exceptionMessage ' ] , ' exceptionStackTrace ' : execute_result [ ' exceptionStackTrace ' ] , ' line ' : execute_result [ ' line ' ] , ' success ' : execute_result [ ' success ' ] , } NEW_LINE if ' log ' in execute_result and return_log : NEW_LINE INDENT result [ ' log ' ] = execute_result [ ' log ' ] NEW_LINE DEDENT if result [ ' success ' ] : NEW_LINE INDENT log_apex = config . connection . get_plugin_client_setting ( ' mm _ log _ anonymous _ apex ' , False ) NEW_LINE if log_apex : NEW_LINE INDENT location = config . project . log_anonymous_apex ( self . params [ ' body ' ] , execute_result [ ' log ' ] , self . params . get ( " script _ name " , None ) ) NEW_LINE result [ " log _ location " ] = location NEW_LINE DEDENT DEDENT return util . generate_response ( result ) NEW_LINE DEDENT
def execute ( self ) : NEW_LINE INDENT return config . connection . sign_in_with_github ( self . params ) NEW_LINE DEDENT
def encode ( self , input , errors = ' strict ' ) : NEW_LINE INDENT return codecs . charmap_encode ( input , errors , encoding_table ) NEW_LINE DEDENT
def decode ( self , input , errors = ' strict ' ) : NEW_LINE INDENT return codecs . charmap_decode ( input , errors , decoding_table ) NEW_LINE DEDENT
def encode ( self , input , final = False ) : NEW_LINE INDENT return codecs . charmap_encode ( input , self . errors , encoding_table ) [ 0 ] NEW_LINE DEDENT
def decode ( self , input , final = False ) : NEW_LINE INDENT return codecs . charmap_decode ( input , self . errors , decoding_table ) [ 0 ] NEW_LINE DEDENT
def Skip ( self , marker ) : NEW_LINE INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE ImageFile . _safe_read ( self . fp , n ) NEW_LINE DEDENT
def APP ( self , marker ) : NEW_LINE # ▁ Application ▁ marker . ▁ Store ▁ these ▁ in ▁ the ▁ APP ▁ dictionary . ENDCOM # ▁ Also ▁ look ▁ for ▁ well - known ▁ application ▁ markers . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE app = " APP % d " % ( marker & 15 ) NEW_LINE self . app [ app ] = s # ▁ compatibility ENDCOM NEW_LINE self . applist . append ( ( app , s ) ) NEW_LINE if marker == 0xFFE0 and s [ : 4 ] == b " JFIF " : NEW_LINE # ▁ extract ▁ JFIF ▁ information ENDCOM INDENT self . info [ " jfif " ] = version = i16 ( s , 5 ) # ▁ version ENDCOM NEW_LINE self . info [ " jfif _ version " ] = divmod ( version , 256 ) NEW_LINE # ▁ extract ▁ JFIF ▁ properties ENDCOM try : NEW_LINE INDENT jfif_unit = i8 ( s [ 7 ] ) NEW_LINE jfif_density = i16 ( s , 8 ) , i16 ( s , 10 ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT if jfif_unit == 1 : NEW_LINE INDENT self . info [ " dpi " ] = jfif_density NEW_LINE DEDENT self . info [ " jfif _ unit " ] = jfif_unit NEW_LINE self . info [ " jfif _ density " ] = jfif_density NEW_LINE DEDENT DEDENT elif marker == 0xFFE1 and s [ : 5 ] == b " Exif\0" : NEW_LINE # ▁ extract ▁ Exif ▁ information ▁ ( incomplete ) ENDCOM INDENT self . info [ " exif " ] = s # ▁ FIXME : ▁ value ▁ will ▁ change ENDCOM NEW_LINE DEDENT elif marker == 0xFFE2 and s [ : 5 ] == b " FPXR\0" : NEW_LINE # ▁ extract ▁ FlashPix ▁ information ▁ ( incomplete ) ENDCOM INDENT self . info [ " flashpix " ] = s # ▁ FIXME : ▁ value ▁ will ▁ change ENDCOM NEW_LINE DEDENT elif marker == 0xFFE2 and s [ : 12 ] == b " ICC _ PROFILE\0" : NEW_LINE # ▁ Since ▁ an ▁ ICC ▁ profile ▁ can ▁ be ▁ larger ▁ than ▁ the ▁ maximum ▁ size ▁ of ENDCOM # ▁ a ▁ JPEG ▁ marker ▁ ( 64K ) , ▁ we ▁ need ▁ provisions ▁ to ▁ split ▁ it ▁ into ENDCOM # ▁ multiple ▁ markers . ▁ The ▁ format ▁ defined ▁ by ▁ the ▁ ICC ▁ specifies ENDCOM # ▁ one ▁ or ▁ more ▁ APP2 ▁ markers ▁ containing ▁ the ▁ following ▁ data : ENDCOM # ▁ Identifying ▁ string ▁ ASCII ▁ " ICC _ PROFILE\0 " ▁ ( 12 ▁ bytes ) ENDCOM # ▁ Marker ▁ sequence ▁ number ▁ 1 , ▁ 2 , ▁ etc ▁ ( 1 ▁ byte ) ENDCOM # ▁ Number ▁ of ▁ markers ▁ Total ▁ of ▁ APP2 ' s ▁ used ▁ ( 1 ▁ byte ) ENDCOM # ▁ Profile ▁ data ▁ ( remainder ▁ of ▁ APP2 ▁ data ) ENDCOM # ▁ Decoders ▁ should ▁ use ▁ the ▁ marker ▁ sequence ▁ numbers ▁ to ENDCOM # ▁ reassemble ▁ the ▁ profile , ▁ rather ▁ than ▁ assuming ▁ that ▁ the ▁ APP2 ENDCOM # ▁ markers ▁ appear ▁ in ▁ the ▁ correct ▁ sequence . ENDCOM INDENT self . icclist . append ( s ) NEW_LINE DEDENT elif marker == 0xFFEE and s [ : 5 ] == b " Adobe " : NEW_LINE INDENT self . info [ " adobe " ] = i16 ( s , 5 ) NEW_LINE # ▁ extract ▁ Adobe ▁ custom ▁ properties ENDCOM try : NEW_LINE INDENT adobe_transform = i8 ( s [ 1 ] ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT self . info [ " adobe _ transform " ] = adobe_transform NEW_LINE DEDENT DEDENT elif marker == 0xFFE2 and s [ : 4 ] == b " MPF\0" : NEW_LINE # ▁ extract ▁ MPO ▁ information ENDCOM INDENT self . info [ " mp " ] = s [ 4 : ] NEW_LINE # ▁ offset ▁ is ▁ current ▁ location ▁ minus ▁ buffer ▁ size ENDCOM # ▁ plus ▁ constant ▁ header ▁ size ENDCOM self . info [ " mpoffset " ] = self . fp . tell ( ) - n + 4 NEW_LINE DEDENT DEDENT
def COM ( self , marker ) : NEW_LINE # ▁ Comment ▁ marker . ▁ Store ▁ these ▁ in ▁ the ▁ APP ▁ dictionary . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE self . app [ " COM " ] = s # ▁ compatibility ENDCOM NEW_LINE self . applist . append ( ( " COM " , s ) ) NEW_LINE DEDENT
def SOF ( self , marker ) : NEW_LINE # ▁ Start ▁ of ▁ frame ▁ marker . ▁ Defines ▁ the ▁ size ▁ and ▁ mode ▁ of ▁ the ENDCOM # ▁ image . ▁ JPEG ▁ is ▁ colour ▁ blind , ▁ so ▁ we ▁ use ▁ some ▁ simple ENDCOM # ▁ heuristics ▁ to ▁ map ▁ the ▁ number ▁ of ▁ layers ▁ to ▁ an ▁ appropriate ENDCOM # ▁ mode . ▁ Note ▁ that ▁ this ▁ could ▁ be ▁ made ▁ a ▁ bit ▁ brighter , ▁ by ENDCOM # ▁ looking ▁ for ▁ JFIF ▁ and ▁ Adobe ▁ APP ▁ markers . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE self . size = i16 ( s [ 3 : ] ) , i16 ( s [ 1 : ] ) NEW_LINE self . bits = i8 ( s [ 0 ] ) NEW_LINE if self . bits != 8 : NEW_LINE INDENT raise SyntaxError ( " cannot ▁ handle ▁ % d - bit ▁ layers " % self . bits ) NEW_LINE DEDENT self . layers = i8 ( s [ 5 ] ) NEW_LINE if self . layers == 1 : NEW_LINE INDENT self . mode = " L " NEW_LINE DEDENT elif self . layers == 3 : NEW_LINE INDENT self . mode = " RGB " NEW_LINE DEDENT elif self . layers == 4 : NEW_LINE INDENT self . mode = " CMYK " NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " cannot ▁ handle ▁ % d - layer ▁ images " % self . layers ) NEW_LINE DEDENT if marker in [ 0xFFC2 , 0xFFC6 , 0xFFCA , 0xFFCE ] : NEW_LINE INDENT self . info [ " progressive " ] = self . info [ " progression " ] = 1 NEW_LINE DEDENT if self . icclist : NEW_LINE # ▁ fixup ▁ icc ▁ profile ENDCOM INDENT self . icclist . sort ( ) # ▁ sort ▁ by ▁ sequence ▁ number ENDCOM NEW_LINE if i8 ( self . icclist [ 0 ] [ 13 ] ) == len ( self . icclist ) : NEW_LINE INDENT profile = [ ] NEW_LINE for p in self . icclist : NEW_LINE INDENT profile . append ( p [ 14 : ] ) NEW_LINE DEDENT icc_profile = b " " . join ( profile ) NEW_LINE DEDENT else : NEW_LINE INDENT icc_profile = None # ▁ wrong ▁ number ▁ of ▁ fragments ENDCOM NEW_LINE DEDENT self . info [ " icc _ profile " ] = icc_profile NEW_LINE self . icclist = None NEW_LINE DEDENT for i in range ( 6 , len ( s ) , 3 ) : NEW_LINE INDENT t = s [ i : i + 3 ] NEW_LINE # ▁ 4 - tuples : ▁ id , ▁ vsamp , ▁ hsamp , ▁ qtable ENDCOM self . layer . append ( ( t [ 0 ] , i8 ( t [ 1 ] ) // 16 , i8 ( t [ 1 ] ) & 15 , i8 ( t [ 2 ] ) ) ) NEW_LINE DEDENT DEDENT
def DQT ( self , marker ) : NEW_LINE # ▁ Define ▁ quantization ▁ table . ▁ Support ▁ baseline ▁ 8 - bit ▁ tables ENDCOM # ▁ only . ▁ Note ▁ that ▁ there ▁ might ▁ be ▁ more ▁ than ▁ one ▁ table ▁ in ENDCOM # ▁ each ▁ marker . ENDCOM # ▁ FIXME : ▁ The ▁ quantization ▁ tables ▁ can ▁ be ▁ used ▁ to ▁ estimate ▁ the ENDCOM # ▁ compression ▁ quality . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE while len ( s ) : NEW_LINE INDENT if len ( s ) < 65 : NEW_LINE INDENT raise SyntaxError ( " bad ▁ quantization ▁ table ▁ marker " ) NEW_LINE DEDENT v = i8 ( s [ 0 ] ) NEW_LINE if v // 16 == 0 : NEW_LINE INDENT self . quantization [ v & 15 ] = array . array ( " B " , s [ 1 : 65 ] ) NEW_LINE s = s [ 65 : ] NEW_LINE DEDENT else : NEW_LINE INDENT return # ▁ FIXME : ▁ add ▁ code ▁ to ▁ read ▁ 16 - bit ▁ tables ! ENDCOM NEW_LINE # ▁ raise ▁ SyntaxError , ▁ " bad ▁ quantization ▁ table ▁ element ▁ size " ENDCOM # ▁ JPEG ▁ marker ▁ table ENDCOM DEDENT DEDENT DEDENT
def _open ( self ) : NEW_LINE INDENT s = self . fp . read ( 1 ) NEW_LINE if i8 ( s ) != 255 : NEW_LINE INDENT raise SyntaxError ( " not ▁ a ▁ JPEG ▁ file " ) NEW_LINE # ▁ Create ▁ attributes ENDCOM DEDENT self . bits = self . layers = 0 NEW_LINE # ▁ JPEG ▁ specifics ▁ ( internal ) ENDCOM self . layer = [ ] NEW_LINE self . huffman_dc = { } NEW_LINE self . huffman_ac = { } NEW_LINE self . quantization = { } NEW_LINE self . app = { } # ▁ compatibility ENDCOM NEW_LINE self . applist = [ ] NEW_LINE self . icclist = [ ] NEW_LINE while True : NEW_LINE INDENT i = i8 ( s ) NEW_LINE if i == 0xFF : NEW_LINE INDENT s = s + self . fp . read ( 1 ) NEW_LINE i = i16 ( s ) NEW_LINE DEDENT else : NEW_LINE # ▁ Skip ▁ non - 0xFF ▁ junk ENDCOM INDENT s = self . fp . read ( 1 ) NEW_LINE continue NEW_LINE DEDENT if i in MARKER : NEW_LINE INDENT name , description , handler = MARKER [ i ] NEW_LINE # ▁ print ( hex ( i ) , ▁ name , ▁ description ) ENDCOM if handler is not None : NEW_LINE INDENT handler ( self , i ) NEW_LINE DEDENT if i == 0xFFDA : # ▁ start ▁ of ▁ scan ENDCOM NEW_LINE INDENT rawmode = self . mode NEW_LINE if self . mode == " CMYK " : NEW_LINE INDENT rawmode = " CMYK ; I " # ▁ assume ▁ adobe ▁ conventions ENDCOM NEW_LINE DEDENT self . tile = [ ( " jpeg " , ( 0 , 0 ) + self . size , 0 , ( rawmode , " " ) ) ] NEW_LINE # ▁ self . _ _ offset ▁ = ▁ self . fp . tell ( ) ENDCOM break NEW_LINE DEDENT s = self . fp . read ( 1 ) NEW_LINE DEDENT elif i == 0 or i == 0xFFFF : NEW_LINE # ▁ padded ▁ marker ▁ or ▁ junk ; ▁ move ▁ on ENDCOM INDENT s = b " \xff " NEW_LINE DEDENT elif i == 0xFF00 : # ▁ Skip ▁ extraneous ▁ data ▁ ( escaped ▁ 0xFF ) ENDCOM NEW_LINE INDENT s = self . fp . read ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " no ▁ marker ▁ found " ) NEW_LINE DEDENT DEDENT DEDENT
def draft ( self , mode , size ) : NEW_LINE INDENT if len ( self . tile ) != 1 : NEW_LINE INDENT return NEW_LINE # ▁ Protect ▁ from ▁ second ▁ call ENDCOM DEDENT if self . decoderconfig : NEW_LINE INDENT return NEW_LINE DEDENT d , e , o , a = self . tile [ 0 ] NEW_LINE scale = 0 NEW_LINE if a [ 0 ] == " RGB " and mode in [ " L " , " YCbCr " ] : NEW_LINE INDENT self . mode = mode NEW_LINE a = mode , " " NEW_LINE DEDENT if size : NEW_LINE INDENT scale = min ( self . size [ 0 ] // size [ 0 ] , self . size [ 1 ] // size [ 1 ] ) NEW_LINE for s in [ 8 , 4 , 2 , 1 ] : NEW_LINE INDENT if scale >= s : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT e = e [ 0 ] , e [ 1 ] , ( e [ 2 ] - e [ 0 ] + s - 1 ) // s + e [ 0 ] , ( e [ 3 ] - e [ 1 ] + s - 1 ) // s + e [ 1 ] NEW_LINE self . size = ( ( self . size [ 0 ] + s - 1 ) // s , ( self . size [ 1 ] + s - 1 ) // s ) NEW_LINE scale = s NEW_LINE DEDENT self . tile = [ ( d , e , o , a ) ] NEW_LINE self . decoderconfig = ( scale , 0 ) NEW_LINE return self NEW_LINE DEDENT
def load_djpeg ( self ) : NEW_LINE # ▁ ALTERNATIVE : ▁ handle ▁ JPEGs ▁ via ▁ the ▁ IJG ▁ command ▁ line ▁ utilities ENDCOM INDENT import subprocess NEW_LINE import tempfile NEW_LINE import os NEW_LINE f , path = tempfile . mkstemp ( ) NEW_LINE os . close ( f ) NEW_LINE if os . path . exists ( self . filename ) : NEW_LINE INDENT subprocess . check_call ( [ " djpeg " , " - outfile " , path , self . filename ] ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " Invalid ▁ Filename " ) NEW_LINE DEDENT try : NEW_LINE INDENT _im = Image . open ( path ) NEW_LINE _im . load ( ) NEW_LINE self . im = _im . im NEW_LINE DEDENT finally : NEW_LINE INDENT try : NEW_LINE INDENT os . unlink ( path ) NEW_LINE DEDENT except OSError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT self . mode = self . im . mode NEW_LINE self . size = self . im . size NEW_LINE self . tile = [ ] NEW_LINE DEDENT
def _getexif ( self ) : NEW_LINE INDENT return _getexif ( self ) NEW_LINE DEDENT
def _getmp ( self ) : NEW_LINE INDENT return _getmp ( self ) NEW_LINE DEDENT
def _getexif ( self ) : NEW_LINE # ▁ Extract ▁ EXIF ▁ information . ▁ This ▁ method ▁ is ▁ highly ▁ experimental , ENDCOM # ▁ and ▁ is ▁ likely ▁ to ▁ be ▁ replaced ▁ with ▁ something ▁ better ▁ in ▁ a ▁ future ENDCOM # ▁ version . ENDCOM # ▁ The ▁ EXIF ▁ record ▁ consists ▁ of ▁ a ▁ TIFF ▁ file ▁ embedded ▁ in ▁ a ▁ JPEG ENDCOM # ▁ application ▁ marker ▁ ( ! ) . ENDCOM INDENT try : NEW_LINE INDENT data = self . info [ " exif " ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT file = io . BytesIO ( data [ 6 : ] ) NEW_LINE head = file . read ( 8 ) NEW_LINE # ▁ process ▁ dictionary ENDCOM info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif = dict ( _fixup_dict ( info ) ) NEW_LINE # ▁ get ▁ exif ▁ extension ENDCOM try : NEW_LINE # ▁ exif ▁ field ▁ 0x8769 ▁ is ▁ an ▁ offset ▁ pointer ▁ to ▁ the ▁ location ENDCOM # ▁ of ▁ the ▁ nested ▁ embedded ▁ exif ▁ ifd . ENDCOM # ▁ It ▁ should ▁ be ▁ a ▁ long , ▁ but ▁ may ▁ be ▁ corrupted . ENDCOM INDENT file . seek ( exif [ 0x8769 ] ) NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif . update ( _fixup_dict ( info ) ) NEW_LINE # ▁ get ▁ gpsinfo ▁ extension ENDCOM DEDENT try : NEW_LINE # ▁ exif ▁ field ▁ 0x8825 ▁ is ▁ an ▁ offset ▁ pointer ▁ to ▁ the ▁ location ENDCOM # ▁ of ▁ the ▁ nested ▁ embedded ▁ gps ▁ exif ▁ ifd . ENDCOM # ▁ It ▁ should ▁ be ▁ a ▁ long , ▁ but ▁ may ▁ be ▁ corrupted . ENDCOM INDENT file . seek ( exif [ 0x8825 ] ) NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif [ 0x8825 ] = _fixup_dict ( info ) NEW_LINE DEDENT return exif NEW_LINE DEDENT
def _getmp ( self ) : NEW_LINE # ▁ Extract ▁ MP ▁ information . ▁ This ▁ method ▁ was ▁ inspired ▁ by ▁ the ▁ " highly ENDCOM # ▁ experimental " ▁ _ getexif ▁ version ▁ that ' s ▁ been ▁ in ▁ use ▁ for ▁ years ▁ now , ENDCOM # ▁ itself ▁ based ▁ on ▁ the ▁ ImageFileDirectory ▁ class ▁ in ▁ the ▁ TIFF ▁ plug - in . ENDCOM # ▁ The ▁ MP ▁ record ▁ essentially ▁ consists ▁ of ▁ a ▁ TIFF ▁ file ▁ embedded ▁ in ▁ a ▁ JPEG ENDCOM # ▁ application ▁ marker . ENDCOM INDENT try : NEW_LINE INDENT data = self . info [ " mp " ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT file_contents = io . BytesIO ( data ) NEW_LINE head = file_contents . read ( 8 ) NEW_LINE endianness = ' > ' if head [ : 4 ] == b ' \x4d\x4d\x00\x2a ' else ' < ' NEW_LINE # ▁ process ▁ dictionary ENDCOM try : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v2 ( head ) NEW_LINE info . load ( file_contents ) NEW_LINE mp = dict ( info ) NEW_LINE DEDENT except : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( unreadable ▁ directory ) " ) NEW_LINE # ▁ it ' s ▁ an ▁ error ▁ not ▁ to ▁ have ▁ a ▁ number ▁ of ▁ images ENDCOM DEDENT try : NEW_LINE INDENT quant = mp [ 0xB001 ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( no ▁ number ▁ of ▁ images ) " ) NEW_LINE # ▁ get ▁ MP ▁ entries ENDCOM DEDENT mpentries = [ ] NEW_LINE try : NEW_LINE INDENT rawmpentries = mp [ 0xB002 ] NEW_LINE for entrynum in range ( 0 , quant ) : NEW_LINE INDENT unpackedentry = unpack_from ( ' { } LLLHH ' . format ( endianness ) , rawmpentries , entrynum * 16 ) NEW_LINE labels = ( ' Attribute ' , ' Size ' , ' DataOffset ' , ' EntryNo1' , ' EntryNo2' ) NEW_LINE mpentry = dict ( zip ( labels , unpackedentry ) ) NEW_LINE mpentryattr = { ' DependentParentImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 31 ) ) , ' DependentChildImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 30 ) ) , ' RepresentativeImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 29 ) ) , ' Reserved ' : ( mpentry [ ' Attribute ' ] & ( 3 << 27 ) ) >> 27 , ' ImageDataFormat ' : ( mpentry [ ' Attribute ' ] & ( 7 << 24 ) ) >> 24 , ' MPType ' : mpentry [ ' Attribute ' ] & 0x00FFFFFF } NEW_LINE if mpentryattr [ ' ImageDataFormat ' ] == 0 : NEW_LINE INDENT mpentryattr [ ' ImageDataFormat ' ] = ' JPEG ' NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " unsupported ▁ picture ▁ format ▁ in ▁ MPO " ) NEW_LINE DEDENT mptypemap = { 0x000000 : ' Undefined ' , 0x010001 : ' Large ▁ Thumbnail ▁ ( VGA ▁ Equivalent ) ' , 0x010002 : ' Large ▁ Thumbnail ▁ ( Full ▁ HD ▁ Equivalent ) ' , 0x020001 : ' Multi - Frame ▁ Image ▁ ( Panorama ) ' , 0x020002 : ' Multi - Frame ▁ Image : ▁ ( Disparity ) ' , 0x020003 : ' Multi - Frame ▁ Image : ▁ ( Multi - Angle ) ' , 0x030000 : ' Baseline ▁ MP ▁ Primary ▁ Image ' } NEW_LINE mpentryattr [ ' MPType ' ] = mptypemap . get ( mpentryattr [ ' MPType ' ] , ' Unknown ' ) NEW_LINE mpentry [ ' Attribute ' ] = mpentryattr NEW_LINE mpentries . append ( mpentry ) NEW_LINE DEDENT mp [ 0xB002 ] = mpentries NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( bad ▁ MP ▁ Entry ) " ) NEW_LINE # ▁ Next ▁ we ▁ should ▁ try ▁ and ▁ parse ▁ the ▁ individual ▁ image ▁ unique ▁ ID ▁ list ; ENDCOM # ▁ we ▁ don ' t ▁ because ▁ I ' ve ▁ never ▁ seen ▁ this ▁ actually ▁ used ▁ in ▁ a ▁ real ▁ MPO ENDCOM # ▁ file ▁ and ▁ so ▁ can ' t ▁ test ▁ it . ENDCOM DEDENT return mp NEW_LINE # ▁ stuff ▁ to ▁ save ▁ JPEG ▁ files ENDCOM DEDENT
