def trace_end ( ) : NEW_LINE INDENT print_unhandled ( ) NEW_LINE DEDENT
def trace_unhandled ( event_name , context , event_fields_dict ) : NEW_LINE INDENT try : NEW_LINE INDENT unhandled [ event_name ] += 1 NEW_LINE DEDENT except TypeError : NEW_LINE INDENT unhandled [ event_name ] = 1 NEW_LINE DEDENT DEDENT
def default_routes ( ) : NEW_LINE INDENT return RoutesBuilder ( ) . get_routes ( ) NEW_LINE DEDENT
def setup_logger ( level ) : NEW_LINE INDENT import logging NEW_LINE global logger NEW_LINE logger = logging . getLogger ( " web - platform - tests " ) NEW_LINE logging . basicConfig ( level = getattr ( logging , level . upper ( ) ) ) NEW_LINE set_logger ( logger ) NEW_LINE DEDENT
def open_socket ( port ) : NEW_LINE INDENT sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) NEW_LINE if port != 0 : NEW_LINE INDENT sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) NEW_LINE DEDENT sock . bind ( ( '127.0.0.1' , port ) ) NEW_LINE sock . listen ( 5 ) NEW_LINE return sock NEW_LINE DEDENT
def get_port ( ) : NEW_LINE INDENT free_socket = open_socket ( 0 ) NEW_LINE port = free_socket . getsockname ( ) [ 1 ] NEW_LINE logger . debug ( " Going ▁ to ▁ use ▁ port ▁ % s " % port ) NEW_LINE free_socket . close ( ) NEW_LINE return port NEW_LINE DEDENT
def get_subdomains ( host ) : NEW_LINE # This ▁ assumes ▁ that ▁ the ▁ tld ▁ is ▁ ascii - only ▁ or ▁ already ▁ in ▁ punycode ENDCOM INDENT return { subdomain : ( subdomain . encode ( " idna " ) , host ) for subdomain in subdomains } NEW_LINE DEDENT
def start_http_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return wptserve . WebTestHttpd ( host = host , port = port , doc_root = paths [ " doc _ root " ] , routes = routes , rewrites = rewrites , bind_hostname = bind_hostname , config = external_config , use_ssl = False , key_file = None , certificate = None , latency = kwargs . get ( " latency " ) ) NEW_LINE DEDENT
def start_https_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return wptserve . WebTestHttpd ( host = host , port = port , doc_root = paths [ " doc _ root " ] , routes = routes , rewrites = rewrites , bind_hostname = bind_hostname , config = external_config , use_ssl = True , key_file = ssl_config [ " key _ path " ] , certificate = ssl_config [ " cert _ path " ] , encrypt_after_connect = ssl_config [ " encrypt _ after _ connect " ] , latency = kwargs . get ( " latency " ) ) NEW_LINE DEDENT
def start_ws_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return WebSocketDaemon ( host , str ( port ) , repo_root , paths [ " ws _ doc _ root " ] , " debug " , bind_hostname , ssl_config = None ) NEW_LINE DEDENT
def start_wss_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return WebSocketDaemon ( host , str ( port ) , repo_root , paths [ " ws _ doc _ root " ] , " debug " , bind_hostname , ssl_config ) NEW_LINE DEDENT
def get_ssl_config ( config , external_domains , ssl_environment ) : NEW_LINE INDENT key_path , cert_path = ssl_environment . host_cert_path ( external_domains ) NEW_LINE return { " key _ path " : key_path , " cert _ path " : cert_path , " encrypt _ after _ connect " : config [ " ssl " ] [ " encrypt _ after _ connect " ] } NEW_LINE DEDENT
def start ( config , ssl_environment , routes , ** kwargs ) : NEW_LINE INDENT host = config [ " host " ] NEW_LINE domains = get_subdomains ( host ) NEW_LINE ports = get_ports ( config , ssl_environment ) NEW_LINE bind_hostname = config [ " bind _ hostname " ] NEW_LINE paths = { " doc _ root " : config [ " doc _ root " ] , " ws _ doc _ root " : config [ " ws _ doc _ root " ] } NEW_LINE external_config = normalise_config ( config , ports ) NEW_LINE ssl_config = get_ssl_config ( config , external_config [ " domains " ] . values ( ) , ssl_environment ) NEW_LINE if config [ " check _ subdomains " ] : NEW_LINE INDENT check_subdomains ( host , paths , bind_hostname , ssl_config ) NEW_LINE DEDENT servers = start_servers ( host , ports , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) NEW_LINE return external_config , servers NEW_LINE DEDENT
def iter_procs ( servers ) : NEW_LINE INDENT for servers in servers . values ( ) : NEW_LINE INDENT for port , server in servers : NEW_LINE INDENT yield server . proc NEW_LINE DEDENT DEDENT DEDENT
def value_set ( config , key ) : NEW_LINE INDENT return key in config and config [ key ] is not None NEW_LINE DEDENT
def get_value_or_default ( config , key , default = None ) : NEW_LINE INDENT return config [ key ] if value_set ( config , key ) else default NEW_LINE DEDENT
def set_computed_defaults ( config ) : NEW_LINE INDENT if not value_set ( config , " doc _ root " ) : NEW_LINE INDENT config [ " doc _ root " ] = repo_root NEW_LINE DEDENT if not value_set ( config , " ws _ doc _ root " ) : NEW_LINE INDENT root = get_value_or_default ( config , " doc _ root " , default = repo_root ) NEW_LINE config [ " ws _ doc _ root " ] = os . path . join ( root , " websockets " , " handlers " ) NEW_LINE DEDENT DEDENT
def get_ssl_environment ( config ) : NEW_LINE INDENT implementation_type = config [ " ssl " ] [ " type " ] NEW_LINE cls = sslutils . environments [ implementation_type ] NEW_LINE try : NEW_LINE INDENT kwargs = config [ " ssl " ] [ implementation_type ] . copy ( ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise ValueError ( " % s ▁ is ▁ not ▁ a ▁ vaid ▁ ssl ▁ type . " % implementation_type ) NEW_LINE DEDENT return cls ( logger , ** kwargs ) NEW_LINE DEDENT
def load_config ( default_path , override_path = None , ** kwargs ) : NEW_LINE INDENT if os . path . exists ( default_path ) : NEW_LINE INDENT with open ( default_path ) as f : NEW_LINE INDENT base_obj = json . load ( f ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT raise ValueError ( " Config ▁ path ▁ % s ▁ does ▁ not ▁ exist " % default_path ) NEW_LINE DEDENT if os . path . exists ( override_path ) : NEW_LINE INDENT with open ( override_path ) as f : NEW_LINE INDENT override_obj = json . load ( f ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT override_obj = { } NEW_LINE DEDENT rv = merge_json ( base_obj , override_obj ) NEW_LINE if kwargs . get ( " config _ path " ) : NEW_LINE INDENT other_path = os . path . abspath ( os . path . expanduser ( kwargs . get ( " config _ path " ) ) ) NEW_LINE if os . path . exists ( other_path ) : NEW_LINE INDENT base_obj = rv NEW_LINE with open ( other_path ) as f : NEW_LINE INDENT override_obj = json . load ( f ) NEW_LINE DEDENT rv = merge_json ( base_obj , override_obj ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " Config ▁ path ▁ % s ▁ does ▁ not ▁ exist " % other_path ) NEW_LINE DEDENT DEDENT overriding_path_args = [ ( " doc _ root " , " Document ▁ root " ) , ( " ws _ doc _ root " , " WebSockets ▁ document ▁ root " ) ] NEW_LINE for key , title in overriding_path_args : NEW_LINE INDENT value = kwargs . get ( key ) NEW_LINE if value is None : NEW_LINE INDENT continue NEW_LINE DEDENT value = os . path . abspath ( os . path . expanduser ( value ) ) NEW_LINE if not os . path . exists ( value ) : NEW_LINE INDENT raise ValueError ( " % s ▁ path ▁ % s ▁ does ▁ not ▁ exist " % ( title , value ) ) NEW_LINE DEDENT rv [ key ] = value NEW_LINE DEDENT set_computed_defaults ( rv ) NEW_LINE return rv NEW_LINE DEDENT
def get_parser ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( ) NEW_LINE parser . add_argument ( " - - latency " , type = int , help = " Artificial ▁ latency ▁ to ▁ add ▁ before ▁ sending ▁ http ▁ responses , ▁ in ▁ ms " ) NEW_LINE parser . add_argument ( " - - config " , action = " store " , dest = " config _ path " , help = " Path ▁ to ▁ external ▁ config ▁ file " ) NEW_LINE parser . add_argument ( " - - doc _ root " , action = " store " , dest = " doc _ root " , help = " Path ▁ to ▁ document ▁ root . ▁ Overrides ▁ config . " ) NEW_LINE parser . add_argument ( " - - ws _ doc _ root " , action = " store " , dest = " ws _ doc _ root " , help = " Path ▁ to ▁ WebSockets ▁ document ▁ root . ▁ Overrides ▁ config . " ) NEW_LINE return parser NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT kwargs = vars ( get_parser ( ) . parse_args ( ) ) NEW_LINE config = load_config ( " config . default . json " , " config . json " , ** kwargs ) NEW_LINE setup_logger ( config [ " log _ level " ] ) NEW_LINE with stash . StashServer ( ( config [ " host " ] , get_port ( ) ) , authkey = str ( uuid . uuid4 ( ) ) ) : NEW_LINE INDENT with get_ssl_environment ( config ) as ssl_env : NEW_LINE INDENT config_ , servers = start ( config , ssl_env , default_routes ( ) , ** kwargs ) NEW_LINE try : NEW_LINE INDENT while any ( item . is_alive ( ) for item in iter_procs ( servers ) ) : NEW_LINE INDENT for item in iter_procs ( servers ) : NEW_LINE INDENT item . join ( 1 ) NEW_LINE DEDENT DEDENT DEDENT except KeyboardInterrupt : NEW_LINE INDENT logger . info ( " Shutting ▁ down " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def instrument_declarative ( cls , registry , metadata ) : NEW_LINE INDENT """ Given ▁ a ▁ class , ▁ configure ▁ the ▁ class ▁ declaratively , STRNEWLINE ▁ using ▁ the ▁ given ▁ registry , ▁ which ▁ can ▁ be ▁ any ▁ dictionary , ▁ and STRNEWLINE ▁ MetaData ▁ object . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if ' _ decl _ class _ registry ' in cls . __dict__ : NEW_LINE INDENT raise exc . InvalidRequestError ( " Class ▁ % r ▁ already ▁ has ▁ been ▁ " " instrumented ▁ declaratively " % cls ) NEW_LINE DEDENT cls . _decl_class_registry = registry NEW_LINE cls . metadata = metadata NEW_LINE _as_declarative ( cls , cls . __name__ , cls . __dict__ ) NEW_LINE DEDENT
def has_inherited_table ( cls ) : NEW_LINE INDENT """ Given ▁ a ▁ class , ▁ return ▁ True ▁ if ▁ any ▁ of ▁ the ▁ classes ▁ it ▁ inherits ▁ from ▁ has ▁ a STRNEWLINE ▁ mapped ▁ table , ▁ otherwise ▁ return ▁ False . STRNEWLINE ▁ """ NEW_LINE for class_ in cls . __mro__ [ 1 : ] : NEW_LINE INDENT if getattr ( class_ , ' _ _ table _ _ ' , None ) is not None : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def __init__ ( cls , classname , bases , dict_ ) : NEW_LINE INDENT if ' _ decl _ class _ registry ' not in cls . __dict__ : NEW_LINE INDENT _as_declarative ( cls , classname , cls . __dict__ ) NEW_LINE DEDENT type . __init__ ( cls , classname , bases , dict_ ) NEW_LINE DEDENT
def __setattr__ ( cls , key , value ) : NEW_LINE INDENT _add_attribute ( cls , key , value ) NEW_LINE DEDENT
def synonym_for ( name , map_column = False ) : NEW_LINE INDENT """ Decorator , ▁ make ▁ a ▁ Python ▁ @ property ▁ a ▁ query ▁ synonym ▁ for ▁ a ▁ column . STRNEWLINE STRNEWLINE ▁ A ▁ decorator ▁ version ▁ of ▁ : func : ` ~ sqlalchemy . orm . synonym ` . ▁ The ▁ function ▁ being STRNEWLINE ▁ decorated ▁ is ▁ the ▁ ' descriptor ' , ▁ otherwise ▁ passes ▁ its ▁ arguments ▁ through ▁ to STRNEWLINE ▁ synonym ( ) : : STRNEWLINE STRNEWLINE ▁ @ synonym _ for ( ' col ' ) STRNEWLINE ▁ @ property STRNEWLINE ▁ def ▁ prop ( self ) : STRNEWLINE ▁ return ▁ ' special ▁ sauce ' STRNEWLINE STRNEWLINE ▁ The ▁ regular ▁ ` ` synonym ( ) ` ` ▁ is ▁ also ▁ usable ▁ directly ▁ in ▁ a ▁ declarative ▁ setting STRNEWLINE ▁ and ▁ may ▁ be ▁ convenient ▁ for ▁ read / write ▁ properties : : STRNEWLINE STRNEWLINE ▁ prop ▁ = ▁ synonym ( ' col ' , ▁ descriptor = property ( _ read _ prop , ▁ _ write _ prop ) ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( fn ) : NEW_LINE INDENT return _orm_synonym ( name , map_column = map_column , descriptor = fn ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT
def comparable_using ( comparator_factory ) : NEW_LINE INDENT """ Decorator , ▁ allow ▁ a ▁ Python ▁ @ property ▁ to ▁ be ▁ used ▁ in ▁ query ▁ criteria . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ a ▁ decorator ▁ front ▁ end ▁ to STRNEWLINE ▁ : func : ` ~ sqlalchemy . orm . comparable _ property ` ▁ that ▁ passes STRNEWLINE ▁ through ▁ the ▁ comparator _ factory ▁ and ▁ the ▁ function ▁ being ▁ decorated : : STRNEWLINE STRNEWLINE ▁ @ comparable _ using ( MyComparatorType ) STRNEWLINE ▁ @ property STRNEWLINE ▁ def ▁ prop ( self ) : STRNEWLINE ▁ return ▁ ' special ▁ sauce ' STRNEWLINE STRNEWLINE ▁ The ▁ regular ▁ ` ` comparable _ property ( ) ` ` ▁ is ▁ also ▁ usable ▁ directly ▁ in ▁ a STRNEWLINE ▁ declarative ▁ setting ▁ and ▁ may ▁ be ▁ convenient ▁ for ▁ read / write ▁ properties : : STRNEWLINE STRNEWLINE ▁ prop ▁ = ▁ comparable _ property ( MyComparatorType ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( fn ) : NEW_LINE INDENT return comparable_property ( comparator_factory , fn ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT
def __get__ ( desc , self , cls ) : NEW_LINE INDENT reg = cls . __dict__ . get ( ' _ sa _ declared _ attr _ reg ' , None ) NEW_LINE if reg is None : NEW_LINE INDENT manager = attributes . manager_of_class ( cls ) NEW_LINE if manager is None : NEW_LINE INDENT util . warn ( " Unmanaged ▁ access ▁ of ▁ declarative ▁ attribute ▁ % s ▁ from ▁ " " non - mapped ▁ class ▁ % s " % ( desc . fget . __name__ , cls . __name__ ) ) NEW_LINE DEDENT return desc . fget ( cls ) NEW_LINE DEDENT if reg is None : NEW_LINE INDENT return desc . fget ( cls ) NEW_LINE DEDENT elif desc in reg : NEW_LINE INDENT return reg [ desc ] NEW_LINE DEDENT else : NEW_LINE INDENT reg [ desc ] = obj = desc . fget ( cls ) NEW_LINE return obj NEW_LINE DEDENT DEDENT
def _stateful ( cls , ** kw ) : NEW_LINE INDENT return _stateful_declared_attr ( ** kw ) NEW_LINE DEDENT
def cascading ( cls ) : NEW_LINE INDENT """ Mark ▁ a ▁ : class : ` . declared _ attr ` ▁ as ▁ cascading . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ a ▁ special - use ▁ modifier ▁ which ▁ indicates ▁ that ▁ a ▁ column STRNEWLINE ▁ or ▁ MapperProperty - based ▁ declared ▁ attribute ▁ should ▁ be ▁ configured STRNEWLINE ▁ distinctly ▁ per ▁ mapped ▁ subclass , ▁ within ▁ a ▁ mapped - inheritance ▁ scenario . STRNEWLINE STRNEWLINE ▁ Below , ▁ both ▁ MyClass ▁ as ▁ well ▁ as ▁ MySubClass ▁ will ▁ have ▁ a ▁ distinct STRNEWLINE ▁ ` ` id ` ` ▁ Column ▁ object ▁ established : : STRNEWLINE STRNEWLINE ▁ class ▁ HasSomeAttribute ( object ) : STRNEWLINE ▁ @ declared _ attr . cascading STRNEWLINE ▁ def ▁ some _ id ( cls ) : STRNEWLINE ▁ if ▁ has _ inherited _ table ( cls ) : STRNEWLINE ▁ return ▁ Column ( STRNEWLINE ▁ ForeignKey ( ' myclass . id ' ) , ▁ primary _ key = True ) STRNEWLINE ▁ else : STRNEWLINE ▁ return ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ return ▁ Column ( ' id ' , ▁ Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ MyClass ( HasSomeAttribute , ▁ Base ) : STRNEWLINE ▁ " " STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ class ▁ MySubClass ( MyClass ) : STRNEWLINE ▁ " " STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ The ▁ behavior ▁ of ▁ the ▁ above ▁ configuration ▁ is ▁ that ▁ ` ` MySubClass ` ` STRNEWLINE ▁ will ▁ refer ▁ to ▁ both ▁ its ▁ own ▁ ` ` id ` ` ▁ column ▁ as ▁ well ▁ as ▁ that ▁ of STRNEWLINE ▁ ` ` MyClass ` ` ▁ underneath ▁ the ▁ attribute ▁ named ▁ ` ` some _ id ` ` . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : ref : ` declarative _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` mixin _ inheritance _ columns ` STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE return cls . _stateful ( cascading = True ) NEW_LINE DEDENT
def declarative_base ( bind = None , metadata = None , mapper = None , cls = object , name = ' Base ' , constructor = _declarative_constructor , class_registry = None , metaclass = DeclarativeMeta ) : NEW_LINE INDENT """ Construct ▁ a ▁ base ▁ class ▁ for ▁ declarative ▁ class ▁ definitions . STRNEWLINE STRNEWLINE ▁ The ▁ new ▁ base ▁ class ▁ will ▁ be ▁ given ▁ a ▁ metaclass ▁ that ▁ produces STRNEWLINE ▁ appropriate ▁ : class : ` ~ sqlalchemy . schema . Table ` ▁ objects ▁ and ▁ makes STRNEWLINE ▁ the ▁ appropriate ▁ : func : ` ~ sqlalchemy . orm . mapper ` ▁ calls ▁ based ▁ on ▁ the STRNEWLINE ▁ information ▁ provided ▁ declaratively ▁ in ▁ the ▁ class ▁ and ▁ any ▁ subclasses STRNEWLINE ▁ of ▁ the ▁ class . STRNEWLINE STRNEWLINE ▁ : param ▁ bind : ▁ An ▁ optional STRNEWLINE ▁ : class : ` ~ sqlalchemy . engine . Connectable ` , ▁ will ▁ be ▁ assigned STRNEWLINE ▁ the ▁ ` ` bind ` ` ▁ attribute ▁ on ▁ the ▁ : class : ` ~ sqlalchemy . schema . MetaData ` STRNEWLINE ▁ instance . STRNEWLINE STRNEWLINE ▁ : param ▁ metadata : STRNEWLINE ▁ An ▁ optional ▁ : class : ` ~ sqlalchemy . schema . MetaData ` ▁ instance . ▁ All STRNEWLINE ▁ : class : ` ~ sqlalchemy . schema . Table ` ▁ objects ▁ implicitly ▁ declared ▁ by STRNEWLINE ▁ subclasses ▁ of ▁ the ▁ base ▁ will ▁ share ▁ this ▁ MetaData . ▁ A ▁ MetaData ▁ instance STRNEWLINE ▁ will ▁ be ▁ created ▁ if ▁ none ▁ is ▁ provided . ▁ The STRNEWLINE ▁ : class : ` ~ sqlalchemy . schema . MetaData ` ▁ instance ▁ will ▁ be ▁ available ▁ via ▁ the STRNEWLINE ▁ ` metadata ` ▁ attribute ▁ of ▁ the ▁ generated ▁ declarative ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ : param ▁ mapper : STRNEWLINE ▁ An ▁ optional ▁ callable , ▁ defaults ▁ to ▁ : func : ` ~ sqlalchemy . orm . mapper ` . ▁ Will STRNEWLINE ▁ be ▁ used ▁ to ▁ map ▁ subclasses ▁ to ▁ their ▁ Tables . STRNEWLINE STRNEWLINE ▁ : param ▁ cls : STRNEWLINE ▁ Defaults ▁ to ▁ : class : ` object ` . ▁ A ▁ type ▁ to ▁ use ▁ as ▁ the ▁ base ▁ for ▁ the ▁ generated STRNEWLINE ▁ declarative ▁ base ▁ class . ▁ May ▁ be ▁ a ▁ class ▁ or ▁ tuple ▁ of ▁ classes . STRNEWLINE STRNEWLINE ▁ : param ▁ name : STRNEWLINE ▁ Defaults ▁ to ▁ ` ` Base ` ` . ▁ The ▁ display ▁ name ▁ for ▁ the ▁ generated STRNEWLINE ▁ class . ▁ Customizing ▁ this ▁ is ▁ not ▁ required , ▁ but ▁ can ▁ improve ▁ clarity ▁ in STRNEWLINE ▁ tracebacks ▁ and ▁ debugging . STRNEWLINE STRNEWLINE ▁ : param ▁ constructor : STRNEWLINE ▁ Defaults ▁ to STRNEWLINE ▁ : func : ` ~ sqlalchemy . ext . declarative . _ declarative _ constructor ` , ▁ an STRNEWLINE ▁ _ _ init _ _ ▁ implementation ▁ that ▁ assigns ▁ \ * * kwargs ▁ for ▁ declared STRNEWLINE ▁ fields ▁ and ▁ relationships ▁ to ▁ an ▁ instance . ▁ If ▁ ` ` None ` ` ▁ is ▁ supplied , STRNEWLINE ▁ no ▁ _ _ init _ _ ▁ will ▁ be ▁ provided ▁ and ▁ construction ▁ will ▁ fall ▁ back ▁ to STRNEWLINE ▁ cls . _ _ init _ _ ▁ by ▁ way ▁ of ▁ the ▁ normal ▁ Python ▁ semantics . STRNEWLINE STRNEWLINE ▁ : param ▁ class _ registry : ▁ optional ▁ dictionary ▁ that ▁ will ▁ serve ▁ as ▁ the STRNEWLINE ▁ registry ▁ of ▁ class ▁ names - > ▁ mapped ▁ classes ▁ when ▁ string ▁ names STRNEWLINE ▁ are ▁ used ▁ to ▁ identify ▁ classes ▁ inside ▁ of ▁ : func : ` . relationship ` STRNEWLINE ▁ and ▁ others . ▁ Allows ▁ two ▁ or ▁ more ▁ declarative ▁ base ▁ classes STRNEWLINE ▁ to ▁ share ▁ the ▁ same ▁ registry ▁ of ▁ class ▁ names ▁ for ▁ simplified STRNEWLINE ▁ inter - base ▁ relationships . STRNEWLINE STRNEWLINE ▁ : param ▁ metaclass : STRNEWLINE ▁ Defaults ▁ to ▁ : class : ` . DeclarativeMeta ` . ▁ A ▁ metaclass ▁ or ▁ _ _ metaclass _ _ STRNEWLINE ▁ compatible ▁ callable ▁ to ▁ use ▁ as ▁ the ▁ meta ▁ type ▁ of ▁ the ▁ generated STRNEWLINE ▁ declarative ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : func : ` . as _ declarative ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE lcl_metadata = metadata or MetaData ( ) NEW_LINE if bind : NEW_LINE INDENT lcl_metadata . bind = bind NEW_LINE DEDENT if class_registry is None : NEW_LINE INDENT class_registry = weakref . WeakValueDictionary ( ) NEW_LINE DEDENT bases = not isinstance ( cls , tuple ) and ( cls , ) or cls NEW_LINE class_dict = dict ( _decl_class_registry = class_registry , metadata = lcl_metadata ) NEW_LINE if constructor : NEW_LINE INDENT class_dict [ ' _ _ init _ _ ' ] = constructor NEW_LINE DEDENT if mapper : NEW_LINE INDENT class_dict [ ' _ _ mapper _ cls _ _ ' ] = mapper NEW_LINE DEDENT return metaclass ( name , bases , class_dict ) NEW_LINE DEDENT
def as_declarative ( ** kw ) : NEW_LINE INDENT """ STRNEWLINE ▁ Class ▁ decorator ▁ for ▁ : func : ` . declarative _ base ` . STRNEWLINE STRNEWLINE ▁ Provides ▁ a ▁ syntactical ▁ shortcut ▁ to ▁ the ▁ ` ` cls ` ` ▁ argument STRNEWLINE ▁ sent ▁ to ▁ : func : ` . declarative _ base ` , ▁ allowing ▁ the ▁ base ▁ class STRNEWLINE ▁ to ▁ be ▁ converted ▁ in - place ▁ to ▁ a ▁ " declarative " ▁ base : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ as _ declarative STRNEWLINE STRNEWLINE ▁ @ as _ declarative ( ) STRNEWLINE ▁ class ▁ Base ( object ) : STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ tablename _ _ ( cls ) : STRNEWLINE ▁ return ▁ cls . _ _ name _ _ . lower ( ) STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ MyMappedClass ( Base ) : STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ All ▁ keyword ▁ arguments ▁ passed ▁ to ▁ : func : ` . as _ declarative ` ▁ are ▁ passed STRNEWLINE ▁ along ▁ to ▁ : func : ` . declarative _ base ` . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 0.8.3 STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : func : ` . declarative _ base ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( cls ) : NEW_LINE INDENT kw [ ' cls ' ] = cls NEW_LINE kw [ ' name ' ] = cls . __name__ NEW_LINE return declarative_base ( ** kw ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT
def _create_polymorphic_union ( cls , mappers ) : NEW_LINE INDENT return polymorphic_union ( OrderedDict ( ( mp . polymorphic_identity , mp . local_table ) for mp in mappers ) , ' type ' , ' pjoin ' ) NEW_LINE DEDENT
def __declare_first__ ( cls ) : NEW_LINE INDENT m = cls . __mapper__ NEW_LINE if m . with_polymorphic : NEW_LINE INDENT return NEW_LINE DEDENT mappers = list ( m . self_and_descendants ) NEW_LINE pjoin = cls . _create_polymorphic_union ( mappers ) NEW_LINE m . _set_with_polymorphic ( ( " * " , pjoin ) ) NEW_LINE m . _set_polymorphic_on ( pjoin . c . type ) NEW_LINE DEDENT
def ▁ company _ id ( cls ) : STRNEWLINE ▁ return ▁ Column ( ForeignKey ( ' company . id ' ) ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ company ( cls ) : STRNEWLINE ▁ return ▁ relationship ( " Company " ) STRNEWLINE STRNEWLINE ▁ class ▁ Manager ( Employee ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' manager ' STRNEWLINE STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ manager _ data ▁ = ▁ Column ( String ( 40 ) ) STRNEWLINE STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' manager ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ When ▁ we ▁ make ▁ use ▁ of ▁ our ▁ mappings ▁ however , ▁ both ▁ ` ` Manager ` ` ▁ and STRNEWLINE ▁ ` ` Employee ` ` ▁ will ▁ have ▁ an ▁ independently ▁ usable ▁ ` ` . company ` ` ▁ attribute : : STRNEWLINE STRNEWLINE ▁ session . query ( Employee ) . filter ( Employee . company . has ( id = 5 ) ) STRNEWLINE STRNEWLINE ▁ . . ▁ versionchanged : : ▁ 1.0.0 ▁ - ▁ The ▁ mechanics ▁ of ▁ : class : ` . AbstractConcreteBase ` STRNEWLINE ▁ have ▁ been ▁ reworked ▁ to ▁ support ▁ relationships ▁ established ▁ directly STRNEWLINE ▁ on ▁ the ▁ abstract ▁ base , ▁ without ▁ any ▁ special ▁ configurational ▁ steps . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : class : ` . ConcreteBase ` STRNEWLINE STRNEWLINE ▁ : ref : ` concrete _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` inheritance _ concrete _ helpers ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE __no_table__ = True NEW_LINE @ classmethod NEW_LINE def __declare_first__ ( cls ) : NEW_LINE INDENT cls . _sa_decl_prepare_nocascade ( ) NEW_LINE DEDENT
def _sa_decl_prepare_nocascade ( cls ) : NEW_LINE INDENT if getattr ( cls , ' _ _ mapper _ _ ' , None ) : NEW_LINE INDENT return NEW_LINE DEDENT to_map = _DeferredMapperConfig . config_for_cls ( cls ) NEW_LINE # ▁ can ' t ▁ rely ▁ on ▁ ' self _ and _ descendants ' ▁ here ENDCOM # ▁ since ▁ technically ▁ an ▁ immediate ▁ subclass ENDCOM # ▁ might ▁ not ▁ be ▁ mapped , ▁ but ▁ a ▁ subclass ENDCOM # ▁ may ▁ be . ENDCOM mappers = [ ] NEW_LINE stack = list ( cls . __subclasses__ ( ) ) NEW_LINE while stack : NEW_LINE INDENT klass = stack . pop ( ) NEW_LINE stack . extend ( klass . __subclasses__ ( ) ) NEW_LINE mn = _mapper_or_none ( klass ) NEW_LINE if mn is not None : NEW_LINE INDENT mappers . append ( mn ) NEW_LINE DEDENT DEDENT pjoin = cls . _create_polymorphic_union ( mappers ) NEW_LINE # ▁ For ▁ columns ▁ that ▁ were ▁ declared ▁ on ▁ the ▁ class , ▁ these ENDCOM # ▁ are ▁ normally ▁ ignored ▁ with ▁ the ▁ " _ _ no _ table _ _ " ▁ mapping , ENDCOM # ▁ unless ▁ they ▁ have ▁ a ▁ different ▁ attribute ▁ key ▁ vs . ▁ col ▁ name ENDCOM # ▁ and ▁ are ▁ in ▁ the ▁ properties ▁ argument . ENDCOM # ▁ In ▁ that ▁ case , ▁ ensure ▁ we ▁ update ▁ the ▁ properties ▁ entry ENDCOM # ▁ to ▁ the ▁ correct ▁ column ▁ from ▁ the ▁ pjoin ▁ target ▁ table . ENDCOM declared_cols = set ( to_map . declared_columns ) NEW_LINE for k , v in list ( to_map . properties . items ( ) ) : NEW_LINE INDENT if v in declared_cols : NEW_LINE INDENT to_map . properties [ k ] = pjoin . c [ v . key ] NEW_LINE DEDENT DEDENT to_map . local_table = pjoin NEW_LINE m_args = to_map . mapper_args_fn or dict NEW_LINE def mapper_args ( ) : NEW_LINE INDENT args = m_args ( ) NEW_LINE args [ ' polymorphic _ on ' ] = pjoin . c . type NEW_LINE return args NEW_LINE DEDENT to_map . mapper_args_fn = mapper_args NEW_LINE m = to_map . map ( ) NEW_LINE for scls in cls . __subclasses__ ( ) : NEW_LINE INDENT sm = _mapper_or_none ( scls ) NEW_LINE if sm and sm . concrete and cls in scls . __bases__ : NEW_LINE INDENT sm . _set_concrete_base ( m ) NEW_LINE DEDENT DEDENT DEDENT
def prepare ( cls , engine ) : NEW_LINE INDENT """ Reflect ▁ all ▁ : class : ` . Table ` ▁ objects ▁ for ▁ all ▁ current STRNEWLINE ▁ : class : ` . DeferredReflection ` ▁ subclasses """ NEW_LINE to_map = _DeferredMapperConfig . classes_for_base ( cls ) NEW_LINE for thingy in to_map : NEW_LINE INDENT cls . _sa_decl_prepare ( thingy . local_table , engine ) NEW_LINE thingy . map ( ) NEW_LINE mapper = thingy . cls . __mapper__ NEW_LINE metadata = mapper . class_ . metadata NEW_LINE for rel in mapper . _props . values ( ) : NEW_LINE INDENT if isinstance ( rel , properties . RelationshipProperty ) and rel . secondary is not None : NEW_LINE INDENT if isinstance ( rel . secondary , Table ) : NEW_LINE INDENT cls . _reflect_table ( rel . secondary , engine ) NEW_LINE DEDENT elif isinstance ( rel . secondary , _class_resolver ) : NEW_LINE INDENT rel . secondary . _resolvers += ( cls . _sa_deferred_table_resolver ( engine , metadata ) , ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def _sa_deferred_table_resolver ( cls , engine , metadata ) : NEW_LINE INDENT def _resolve ( key ) : NEW_LINE INDENT t1 = Table ( key , metadata ) NEW_LINE cls . _reflect_table ( t1 , engine ) NEW_LINE return t1 NEW_LINE DEDENT return _resolve NEW_LINE DEDENT
def _sa_decl_prepare ( cls , local_table , engine ) : NEW_LINE # ▁ autoload ▁ Table , ▁ which ▁ is ▁ already ENDCOM # ▁ present ▁ in ▁ the ▁ metadata . ▁ This ENDCOM # ▁ will ▁ fill ▁ in ▁ db - loaded ▁ columns ENDCOM # ▁ into ▁ the ▁ existing ▁ Table ▁ object . ENDCOM INDENT if local_table is not None : NEW_LINE INDENT cls . _reflect_table ( local_table , engine ) NEW_LINE DEDENT DEDENT
def _reflect_table ( cls , table , engine ) : NEW_LINE INDENT Table ( table . name , table . metadata , extend_existing = True , autoload_replace = False , autoload = True , autoload_with = engine , schema = table . schema ) NEW_LINE DEDENT
def _add_doc ( func , doc ) : NEW_LINE INDENT """ Add ▁ documentation ▁ to ▁ a ▁ function . """ NEW_LINE func . __doc__ = doc NEW_LINE DEDENT
def _import_module ( name ) : NEW_LINE INDENT """ Import ▁ module , ▁ returning ▁ the ▁ module ▁ after ▁ the ▁ last ▁ dot . """ NEW_LINE __import__ ( name ) NEW_LINE return sys . modules [ name ] NEW_LINE DEDENT
def add_move ( move ) : NEW_LINE INDENT """ Add ▁ an ▁ item ▁ to ▁ six . moves . """ NEW_LINE setattr ( _MovedItems , move . name , move ) NEW_LINE DEDENT
def remove_move ( name ) : NEW_LINE INDENT """ Remove ▁ item ▁ from ▁ six . moves . """ NEW_LINE try : NEW_LINE INDENT delattr ( _MovedItems , name ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT try : NEW_LINE INDENT del moves . __dict__ [ name ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise AttributeError ( " no ▁ such ▁ move , ▁ % r " % ( name , ) ) NEW_LINE DEDENT DEDENT DEDENT
def advance_iterator ( it ) : NEW_LINE INDENT return it . next ( ) NEW_LINE DEDENT
def callable ( obj ) : NEW_LINE INDENT return any ( " _ _ call _ _ " in klass . __dict__ for klass in type ( obj ) . __mro__ ) NEW_LINE DEDENT
def get_unbound_function ( unbound ) : NEW_LINE INDENT return unbound NEW_LINE DEDENT
def create_unbound_method ( func , cls ) : NEW_LINE INDENT return func NEW_LINE DEDENT
def get_unbound_function ( unbound ) : NEW_LINE INDENT return unbound . im_func NEW_LINE DEDENT
def create_bound_method ( func , obj ) : NEW_LINE INDENT return types . MethodType ( func , obj , obj . __class__ ) NEW_LINE DEDENT
def create_unbound_method ( func , cls ) : NEW_LINE INDENT return types . MethodType ( func , None , cls ) NEW_LINE DEDENT
def iterkeys ( d , ** kw ) : NEW_LINE INDENT return iter ( d . keys ( ** kw ) ) NEW_LINE DEDENT
def itervalues ( d , ** kw ) : NEW_LINE INDENT return iter ( d . values ( ** kw ) ) NEW_LINE DEDENT
def iteritems ( d , ** kw ) : NEW_LINE INDENT return iter ( d . items ( ** kw ) ) NEW_LINE DEDENT
def iterlists ( d , ** kw ) : NEW_LINE INDENT return iter ( d . lists ( ** kw ) ) NEW_LINE DEDENT
def iterkeys ( d , ** kw ) : NEW_LINE INDENT return d . iterkeys ( ** kw ) NEW_LINE DEDENT
def itervalues ( d , ** kw ) : NEW_LINE INDENT return d . itervalues ( ** kw ) NEW_LINE DEDENT
def iteritems ( d , ** kw ) : NEW_LINE INDENT return d . iteritems ( ** kw ) NEW_LINE DEDENT
def iterlists ( d , ** kw ) : NEW_LINE INDENT return d . iterlists ( ** kw ) NEW_LINE DEDENT
def b ( s ) : NEW_LINE INDENT return s . encode ( " latin - 1" ) NEW_LINE DEDENT
def u ( s ) : NEW_LINE INDENT return s NEW_LINE DEDENT
def b ( s ) : NEW_LINE INDENT return s NEW_LINE # ▁ Workaround ▁ for ▁ standalone ▁ backslash ENDCOM DEDENT
def u ( s ) : NEW_LINE INDENT return unicode ( s . replace ( r ' \\ ' , r ' \\\\ ' ) , " unicode _ escape " ) NEW_LINE DEDENT
def byte2int ( bs ) : NEW_LINE INDENT return ord ( bs [ 0 ] ) NEW_LINE DEDENT
def indexbytes ( buf , i ) : NEW_LINE INDENT return ord ( buf [ i ] ) NEW_LINE DEDENT
def reraise ( tp , value , tb = None ) : NEW_LINE INDENT if value is None : NEW_LINE INDENT value = tp ( ) NEW_LINE DEDENT if value . __traceback__ is not tb : NEW_LINE INDENT raise value . with_traceback ( tb ) NEW_LINE DEDENT raise value NEW_LINE DEDENT
def exec_ ( _code_ , _globs_ = None , _locs_ = None ) : NEW_LINE INDENT """ Execute ▁ code ▁ in ▁ a ▁ namespace . """ NEW_LINE if _globs_ is None : NEW_LINE INDENT frame = sys . _getframe ( 1 ) NEW_LINE _globs_ = frame . f_globals NEW_LINE if _locs_ is None : NEW_LINE INDENT _locs_ = frame . f_locals NEW_LINE DEDENT del frame NEW_LINE DEDENT elif _locs_ is None : NEW_LINE INDENT _locs_ = _globs_ NEW_LINE DEDENT exec ( """ exec ▁ _ code _ ▁ in ▁ _ globs _ , ▁ _ locs _ """ ) NEW_LINE DEDENT
def ▁ reraise ( tp , ▁ value , ▁ tb = None ) : STRNEWLINE ▁ ▁ ▁ ▁ raise ▁ tp , ▁ value , ▁ tb STRNEWLINE """ ) NEW_LINE DEDENT if sys . version_info [ : 2 ] == ( 3 , 2 ) : NEW_LINE INDENT exec_ ( """ def ▁ raise _ from ( value , ▁ from _ value ) : STRNEWLINE ▁ ▁ ▁ ▁ if ▁ from _ value ▁ is ▁ None : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ value STRNEWLINE ▁ ▁ ▁ ▁ raise ▁ value ▁ from ▁ from _ value STRNEWLINE """ ) NEW_LINE DEDENT elif sys . version_info [ : 2 ] > ( 3 , 2 ) : NEW_LINE INDENT exec_ ( """ def ▁ raise _ from ( value , ▁ from _ value ) : STRNEWLINE ▁ ▁ ▁ ▁ raise ▁ value ▁ from ▁ from _ value STRNEWLINE """ ) NEW_LINE DEDENT else : NEW_LINE INDENT def raise_from ( value , from_value ) : NEW_LINE INDENT raise value NEW_LINE DEDENT
def print_ ( * args , ** kwargs ) : NEW_LINE INDENT fp = kwargs . get ( " file " , sys . stdout ) NEW_LINE flush = kwargs . pop ( " flush " , False ) NEW_LINE _print ( * args , ** kwargs ) NEW_LINE if flush and fp is not None : NEW_LINE INDENT fp . flush ( ) NEW_LINE DEDENT DEDENT
def wraps ( wrapped , assigned = functools . WRAPPER_ASSIGNMENTS , updated = functools . WRAPPER_UPDATES ) : NEW_LINE INDENT def wrapper ( f ) : NEW_LINE INDENT f = functools . wraps ( wrapped , assigned , updated ) ( f ) NEW_LINE f . __wrapped__ = wrapped NEW_LINE return f NEW_LINE DEDENT return wrapper NEW_LINE DEDENT
def with_metaclass ( meta , * bases ) : NEW_LINE INDENT """ Create ▁ a ▁ base ▁ class ▁ with ▁ a ▁ metaclass . """ NEW_LINE # ▁ This ▁ requires ▁ a ▁ bit ▁ of ▁ explanation : ▁ the ▁ basic ▁ idea ▁ is ▁ to ▁ make ▁ a ▁ dummy ENDCOM # ▁ metaclass ▁ for ▁ one ▁ level ▁ of ▁ class ▁ instantiation ▁ that ▁ replaces ▁ itself ▁ with ENDCOM # ▁ the ▁ actual ▁ metaclass . ENDCOM class metaclass ( meta ) : NEW_LINE INDENT def __new__ ( cls , name , this_bases , d ) : NEW_LINE INDENT return meta ( name , bases , d ) NEW_LINE DEDENT DEDENT return type . __new__ ( metaclass , ' temporary _ class ' , ( ) , { } ) NEW_LINE DEDENT
def add_metaclass ( metaclass ) : NEW_LINE INDENT """ Class ▁ decorator ▁ for ▁ creating ▁ a ▁ class ▁ with ▁ a ▁ metaclass . """ NEW_LINE def wrapper ( cls ) : NEW_LINE INDENT orig_vars = cls . __dict__ . copy ( ) NEW_LINE slots = orig_vars . get ( ' _ _ slots _ _ ' ) NEW_LINE if slots is not None : NEW_LINE INDENT if isinstance ( slots , str ) : NEW_LINE INDENT slots = [ slots ] NEW_LINE DEDENT for slots_var in slots : NEW_LINE INDENT orig_vars . pop ( slots_var ) NEW_LINE DEDENT DEDENT orig_vars . pop ( ' _ _ dict _ _ ' , None ) NEW_LINE orig_vars . pop ( ' _ _ weakref _ _ ' , None ) NEW_LINE return metaclass ( cls . __name__ , cls . __bases__ , orig_vars ) NEW_LINE DEDENT return wrapper NEW_LINE DEDENT
def python_2_unicode_compatible ( klass ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ decorator ▁ that ▁ defines ▁ _ _ unicode _ _ ▁ and ▁ _ _ str _ _ ▁ methods ▁ under ▁ Python ▁ 2 . STRNEWLINE ▁ Under ▁ Python ▁ 3 ▁ it ▁ does ▁ nothing . STRNEWLINE STRNEWLINE ▁ To ▁ support ▁ Python ▁ 2 ▁ and ▁ 3 ▁ with ▁ a ▁ single ▁ code ▁ base , ▁ define ▁ a ▁ _ _ str _ _ ▁ method STRNEWLINE ▁ returning ▁ text ▁ and ▁ apply ▁ this ▁ decorator ▁ to ▁ the ▁ class . STRNEWLINE ▁ """ NEW_LINE if PY2 : NEW_LINE INDENT if ' _ _ str _ _ ' not in klass . __dict__ : NEW_LINE INDENT raise ValueError ( " @ python _ 2 _ unicode _ compatible ▁ cannot ▁ be ▁ applied ▁ " " to ▁ % s ▁ because ▁ it ▁ doesn ' t ▁ define ▁ _ _ str _ _ ( ) . " % klass . __name__ ) NEW_LINE DEDENT klass . __unicode__ = klass . __str__ NEW_LINE klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( ' utf - 8' ) NEW_LINE DEDENT return klass NEW_LINE # ▁ Complete ▁ the ▁ moves ▁ implementation . ENDCOM # ▁ This ▁ code ▁ is ▁ at ▁ the ▁ end ▁ of ▁ this ▁ module ▁ to ▁ speed ▁ up ▁ module ▁ loading . ENDCOM # ▁ Turn ▁ this ▁ module ▁ into ▁ a ▁ package . ENDCOM DEDENT
def getETreeBuilder ( ElementTreeImplementation ) : NEW_LINE INDENT ElementTree = ElementTreeImplementation NEW_LINE ElementTreeCommentType = ElementTree . Comment ( " asd " ) . tag NEW_LINE class TreeWalker ( _base . NonRecursiveTreeWalker ) : NEW_LINE INDENT """ Given ▁ the ▁ particular ▁ ElementTree ▁ representation , ▁ this ▁ implementation , STRNEWLINE ▁ to ▁ avoid ▁ using ▁ recursion , ▁ returns ▁ " nodes " ▁ as ▁ tuples ▁ with ▁ the ▁ following STRNEWLINE ▁ content : STRNEWLINE STRNEWLINE ▁ 1 . ▁ The ▁ current ▁ element STRNEWLINE STRNEWLINE ▁ 2 . ▁ The ▁ index ▁ of ▁ the ▁ element ▁ relative ▁ to ▁ its ▁ parent STRNEWLINE STRNEWLINE ▁ 3 . ▁ A ▁ stack ▁ of ▁ ancestor ▁ elements STRNEWLINE STRNEWLINE ▁ 4 . ▁ A ▁ flag ▁ " text " , ▁ " tail " ▁ or ▁ None ▁ to ▁ indicate ▁ if ▁ the ▁ current ▁ node ▁ is ▁ a STRNEWLINE ▁ text ▁ node ; ▁ either ▁ the ▁ text ▁ or ▁ tail ▁ of ▁ the ▁ current ▁ element ▁ ( 1 ) STRNEWLINE ▁ """ NEW_LINE def getNodeDetails ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : # ▁ It ▁ might ▁ be ▁ the ▁ root ▁ Element ENDCOM NEW_LINE INDENT elt , key , parents , flag = node NEW_LINE if flag in ( " text " , " tail " ) : NEW_LINE INDENT return _base . TEXT , getattr ( elt , flag ) NEW_LINE DEDENT else : NEW_LINE INDENT node = elt NEW_LINE DEDENT DEDENT if not ( hasattr ( node , " tag " ) ) : NEW_LINE INDENT node = node . getroot ( ) NEW_LINE DEDENT if node . tag in ( " DOCUMENT _ ROOT " , " DOCUMENT _ FRAGMENT " ) : NEW_LINE INDENT return ( _base . DOCUMENT , ) NEW_LINE DEDENT elif node . tag == " < ! DOCTYPE > " : NEW_LINE INDENT return ( _base . DOCTYPE , node . text , node . get ( " publicId " ) , node . get ( " systemId " ) ) NEW_LINE DEDENT elif node . tag == ElementTreeCommentType : NEW_LINE INDENT return _base . COMMENT , node . text NEW_LINE DEDENT else : NEW_LINE INDENT assert isinstance ( node . tag , string_types ) , type ( node . tag ) NEW_LINE # ▁ This ▁ is ▁ assumed ▁ to ▁ be ▁ an ▁ ordinary ▁ element ENDCOM match = tag_regexp . match ( node . tag ) NEW_LINE if match : NEW_LINE INDENT namespace , tag = match . groups ( ) NEW_LINE DEDENT else : NEW_LINE INDENT namespace = None NEW_LINE tag = node . tag NEW_LINE DEDENT attrs = OrderedDict ( ) NEW_LINE for name , value in list ( node . attrib . items ( ) ) : NEW_LINE INDENT match = tag_regexp . match ( name ) NEW_LINE if match : NEW_LINE INDENT attrs [ ( match . group ( 1 ) , match . group ( 2 ) ) ] = value NEW_LINE DEDENT else : NEW_LINE INDENT attrs [ ( None , name ) ] = value NEW_LINE DEDENT DEDENT return ( _base . ELEMENT , namespace , tag , attrs , len ( node ) or node . text ) NEW_LINE DEDENT DEDENT def getFirstChild ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : NEW_LINE INDENT element , key , parents , flag = node NEW_LINE DEDENT else : NEW_LINE INDENT element , key , parents , flag = node , None , [ ] , None NEW_LINE DEDENT if flag in ( " text " , " tail " ) : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT if element . text : NEW_LINE INDENT return element , key , parents , " text " NEW_LINE DEDENT elif len ( element ) : NEW_LINE INDENT parents . append ( element ) NEW_LINE return element [ 0 ] , 0 , parents , None NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT DEDENT def getNextSibling ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : NEW_LINE INDENT element , key , parents , flag = node NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT if flag == " text " : NEW_LINE INDENT if len ( element ) : NEW_LINE INDENT parents . append ( element ) NEW_LINE return element [ 0 ] , 0 , parents , None NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if element . tail and flag != " tail " : NEW_LINE INDENT return element , key , parents , " tail " NEW_LINE DEDENT elif key < len ( parents [ - 1 ] ) - 1 : NEW_LINE INDENT return parents [ - 1 ] [ key + 1 ] , key + 1 , parents , None NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT DEDENT def getParentNode ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : NEW_LINE INDENT element , key , parents , flag = node NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT if flag == " text " : NEW_LINE INDENT if not parents : NEW_LINE INDENT return element NEW_LINE DEDENT else : NEW_LINE INDENT return element , key , parents , None NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT parent = parents . pop ( ) NEW_LINE if not parents : NEW_LINE INDENT return parent NEW_LINE DEDENT else : NEW_LINE INDENT return parent , list ( parents [ - 1 ] ) . index ( parent ) , parents , None NEW_LINE DEDENT DEDENT DEDENT DEDENT return locals ( ) NEW_LINE DEDENT
def getregentry ( ) : NEW_LINE INDENT return codecs . CodecInfo ( name = ' cp1006' , encode = Codec ( ) . encode , decode = Codec ( ) . decode , incrementalencoder = IncrementalEncoder , incrementaldecoder = IncrementalDecoder , streamreader = StreamReader , streamwriter = StreamWriter , ) NEW_LINE # # # ▁ Decoding ▁ Table ENDCOM DEDENT
def _accept ( prefix ) : NEW_LINE INDENT return prefix [ 0 : 1 ] == b " \377" NEW_LINE # ▁ Image ▁ plugin ▁ for ▁ JPEG ▁ and ▁ JFIF ▁ images . ENDCOM DEDENT
def _fixup_dict ( src_dict ) : NEW_LINE # ▁ Helper ▁ function ▁ for ▁ _ getexif ( ) ENDCOM # ▁ returns ▁ a ▁ dict ▁ with ▁ any ▁ single ▁ item ▁ tuples / lists ▁ as ▁ individual ▁ values ENDCOM INDENT def _fixup ( value ) : NEW_LINE INDENT try : NEW_LINE INDENT if len ( value ) == 1 and not isinstance ( value , dict ) : NEW_LINE INDENT return value [ 0 ] NEW_LINE DEDENT DEDENT except : pass NEW_LINE return value NEW_LINE DEDENT return { k : _fixup ( v ) for k , v in src_dict . items ( ) } NEW_LINE DEDENT
def convert_dict_qtables ( qtables ) : NEW_LINE INDENT qtables = [ qtables [ key ] for key in range ( len ( qtables ) ) if key in qtables ] NEW_LINE for idx , table in enumerate ( qtables ) : NEW_LINE INDENT qtables [ idx ] = [ table [ i ] for i in zigzag_index ] NEW_LINE DEDENT return qtables NEW_LINE DEDENT
def get_sampling ( im ) : NEW_LINE # ▁ There ' s ▁ no ▁ subsampling ▁ when ▁ image ▁ have ▁ only ▁ 1 ▁ layer ENDCOM # ▁ ( grayscale ▁ images ) ▁ or ▁ when ▁ they ▁ are ▁ CMYK ▁ ( 4 ▁ layers ) , ENDCOM # ▁ so ▁ set ▁ subsampling ▁ to ▁ default ▁ value . ENDCOM # ▁ NOTE : ▁ currently ▁ Pillow ▁ can ' t ▁ encode ▁ JPEG ▁ to ▁ YCCK ▁ format . ENDCOM # ▁ If ▁ YCCK ▁ support ▁ is ▁ added ▁ in ▁ the ▁ future , ▁ subsampling ▁ code ▁ will ▁ have ENDCOM # ▁ to ▁ be ▁ updated ▁ ( here ▁ and ▁ in ▁ JpegEncode . c ) ▁ to ▁ deal ▁ with ▁ 4 ▁ layers . ENDCOM INDENT if not hasattr ( im , ' layers ' ) or im . layers in ( 1 , 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sampling = im . layer [ 0 ] [ 1 : 3 ] + im . layer [ 1 ] [ 1 : 3 ] + im . layer [ 2 ] [ 1 : 3 ] NEW_LINE return samplings . get ( sampling , - 1 ) NEW_LINE DEDENT
def _save ( im , fp , filename ) : NEW_LINE INDENT try : NEW_LINE INDENT rawmode = RAWMODE [ im . mode ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise IOError ( " cannot ▁ write ▁ mode ▁ % s ▁ as ▁ JPEG " % im . mode ) NEW_LINE DEDENT if im . mode == ' RGBA ' : NEW_LINE INDENT warnings . warn ( ' You ▁ are ▁ saving ▁ RGBA ▁ image ▁ as ▁ JPEG . ▁ The ▁ alpha ▁ channel ▁ will ▁ be ▁ ' ' discarded . ▁ This ▁ conversion ▁ is ▁ deprecated ▁ and ▁ will ▁ be ▁ disabled ▁ ' ' in ▁ Pillow ▁ 3.7 . ▁ Please , ▁ convert ▁ the ▁ image ▁ to ▁ RGB ▁ explicitly . ' , DeprecationWarning ) NEW_LINE DEDENT info = im . encoderinfo NEW_LINE dpi = [ int ( round ( x ) ) for x in info . get ( " dpi " , ( 0 , 0 ) ) ] NEW_LINE quality = info . get ( " quality " , 0 ) NEW_LINE subsampling = info . get ( " subsampling " , - 1 ) NEW_LINE qtables = info . get ( " qtables " ) NEW_LINE if quality == " keep " : NEW_LINE INDENT quality = 0 NEW_LINE subsampling = " keep " NEW_LINE qtables = " keep " NEW_LINE DEDENT elif quality in presets : NEW_LINE INDENT preset = presets [ quality ] NEW_LINE quality = 0 NEW_LINE subsampling = preset . get ( ' subsampling ' , - 1 ) NEW_LINE qtables = preset . get ( ' quantization ' ) NEW_LINE DEDENT elif not isinstance ( quality , int ) : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quality ▁ setting " ) NEW_LINE DEDENT else : NEW_LINE INDENT if subsampling in presets : NEW_LINE INDENT subsampling = presets [ subsampling ] . get ( ' subsampling ' , - 1 ) NEW_LINE DEDENT if isStringType ( qtables ) and qtables in presets : NEW_LINE INDENT qtables = presets [ qtables ] . get ( ' quantization ' ) NEW_LINE DEDENT DEDENT if subsampling == "4:4:4" : NEW_LINE INDENT subsampling = 0 NEW_LINE DEDENT elif subsampling == "4:2:2" : NEW_LINE INDENT subsampling = 1 NEW_LINE DEDENT elif subsampling == "4:1:1" : NEW_LINE INDENT subsampling = 2 NEW_LINE DEDENT elif subsampling == " keep " : NEW_LINE INDENT if im . format != " JPEG " : NEW_LINE INDENT raise ValueError ( " Cannot ▁ use ▁ ' keep ' ▁ when ▁ original ▁ image ▁ is ▁ not ▁ a ▁ JPEG " ) NEW_LINE DEDENT subsampling = get_sampling ( im ) NEW_LINE DEDENT def validate_qtables ( qtables ) : NEW_LINE INDENT if qtables is None : NEW_LINE INDENT return qtables NEW_LINE DEDENT if isStringType ( qtables ) : NEW_LINE INDENT try : NEW_LINE INDENT lines = [ int ( num ) for line in qtables . splitlines ( ) for num in line . split ( ' # ' , 1 ) [ 0 ] . split ( ) ] NEW_LINE DEDENT except ValueError : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quantization ▁ table " ) NEW_LINE DEDENT else : NEW_LINE INDENT qtables = [ lines [ s : s + 64 ] for s in range ( 0 , len ( lines ) , 64 ) ] NEW_LINE DEDENT DEDENT if isinstance ( qtables , ( tuple , list , dict ) ) : NEW_LINE INDENT if isinstance ( qtables , dict ) : NEW_LINE INDENT qtables = convert_dict_qtables ( qtables ) NEW_LINE DEDENT elif isinstance ( qtables , tuple ) : NEW_LINE INDENT qtables = list ( qtables ) NEW_LINE DEDENT if not ( 0 < len ( qtables ) < 5 ) : NEW_LINE INDENT raise ValueError ( " None ▁ or ▁ too ▁ many ▁ quantization ▁ tables " ) NEW_LINE DEDENT for idx , table in enumerate ( qtables ) : NEW_LINE INDENT try : NEW_LINE INDENT if len ( table ) != 64 : NEW_LINE INDENT raise NEW_LINE DEDENT table = array . array ( ' B ' , table ) NEW_LINE DEDENT except TypeError : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quantization ▁ table " ) NEW_LINE DEDENT else : NEW_LINE INDENT qtables [ idx ] = list ( table ) NEW_LINE DEDENT DEDENT return qtables NEW_LINE DEDENT DEDENT if qtables == " keep " : NEW_LINE INDENT if im . format != " JPEG " : NEW_LINE INDENT raise ValueError ( " Cannot ▁ use ▁ ' keep ' ▁ when ▁ original ▁ image ▁ is ▁ not ▁ a ▁ JPEG " ) NEW_LINE DEDENT qtables = getattr ( im , " quantization " , None ) NEW_LINE DEDENT qtables = validate_qtables ( qtables ) NEW_LINE extra = b " " NEW_LINE icc_profile = info . get ( " icc _ profile " ) NEW_LINE if icc_profile : NEW_LINE INDENT ICC_OVERHEAD_LEN = 14 NEW_LINE MAX_BYTES_IN_MARKER = 65533 NEW_LINE MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN NEW_LINE markers = [ ] NEW_LINE while icc_profile : NEW_LINE INDENT markers . append ( icc_profile [ : MAX_DATA_BYTES_IN_MARKER ] ) NEW_LINE icc_profile = icc_profile [ MAX_DATA_BYTES_IN_MARKER : ] NEW_LINE DEDENT i = 1 NEW_LINE for marker in markers : NEW_LINE INDENT size = struct . pack ( " > H " , 2 + ICC_OVERHEAD_LEN + len ( marker ) ) NEW_LINE extra += ( b " \xFF\xE2" + size + b " ICC _ PROFILE\0" + o8 ( i ) + o8 ( len ( markers ) ) + marker ) NEW_LINE i += 1 NEW_LINE # ▁ " progressive " ▁ is ▁ the ▁ official ▁ name , ▁ but ▁ older ▁ documentation ENDCOM # ▁ says ▁ " progression " ENDCOM # ▁ FIXME : ▁ issue ▁ a ▁ warning ▁ if ▁ the ▁ wrong ▁ form ▁ is ▁ used ▁ ( post - 1.1.7 ) ENDCOM DEDENT DEDENT progressive = info . get ( " progressive " , False ) or info . get ( " progression " , False ) NEW_LINE optimize = info . get ( " optimize " , False ) NEW_LINE # ▁ get ▁ keyword ▁ arguments ENDCOM im . encoderconfig = ( quality , progressive , info . get ( " smooth " , 0 ) , optimize , info . get ( " streamtype " , 0 ) , dpi [ 0 ] , dpi [ 1 ] , subsampling , qtables , extra , info . get ( " exif " , b " " ) ) NEW_LINE # ▁ if ▁ we ▁ optimize , ▁ libjpeg ▁ needs ▁ a ▁ buffer ▁ big ▁ enough ▁ to ▁ hold ▁ the ▁ whole ▁ image ENDCOM # ▁ in ▁ a ▁ shot . ▁ Guessing ▁ on ▁ the ▁ size , ▁ at ▁ im . size ▁ bytes . ▁ ( raw ▁ pizel ▁ size ▁ is ENDCOM # ▁ channels * size , ▁ this ▁ is ▁ a ▁ value ▁ that ' s ▁ been ▁ used ▁ in ▁ a ▁ django ▁ patch . ENDCOM # ▁ https : / / github . com / matthewwithanm / django - imagekit / issues / 50 ENDCOM bufsize = 0 NEW_LINE if optimize or progressive : NEW_LINE # ▁ CMYK ▁ can ▁ be ▁ bigger ENDCOM INDENT if im . mode == ' CMYK ' : NEW_LINE INDENT bufsize = 4 * im . size [ 0 ] * im . size [ 1 ] NEW_LINE # ▁ keep ▁ sets ▁ quality ▁ to ▁ 0 , ▁ but ▁ the ▁ actual ▁ value ▁ may ▁ be ▁ high . ENDCOM DEDENT elif quality >= 95 or quality == 0 : NEW_LINE INDENT bufsize = 2 * im . size [ 0 ] * im . size [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT bufsize = im . size [ 0 ] * im . size [ 1 ] NEW_LINE # ▁ The ▁ exif ▁ info ▁ needs ▁ to ▁ be ▁ written ▁ as ▁ one ▁ block , ▁ + ▁ APP1 , ▁ + ▁ one ▁ spare ▁ byte . ENDCOM # ▁ Ensure ▁ that ▁ our ▁ buffer ▁ is ▁ big ▁ enough ENDCOM DEDENT DEDENT bufsize = max ( ImageFile . MAXBLOCK , bufsize , len ( info . get ( " exif " , b " " ) ) + 5 ) NEW_LINE ImageFile . _save ( im , fp , [ ( " jpeg " , ( 0 , 0 ) + im . size , 0 , rawmode ) ] , bufsize ) NEW_LINE DEDENT
def _save_cjpeg ( im , fp , filename ) : NEW_LINE # ▁ ALTERNATIVE : ▁ handle ▁ JPEGs ▁ via ▁ the ▁ IJG ▁ command ▁ line ▁ utilities . ENDCOM INDENT import os NEW_LINE import subprocess NEW_LINE tempfile = im . _dump ( ) NEW_LINE subprocess . check_call ( [ " cjpeg " , " - outfile " , filename , tempfile ] ) NEW_LINE try : NEW_LINE INDENT os . unlink ( tempfile ) NEW_LINE DEDENT except OSError : NEW_LINE INDENT pass NEW_LINE # ▁ Factory ▁ for ▁ making ▁ JPEG ▁ and ▁ MPO ▁ instances ENDCOM DEDENT DEDENT
def jpeg_factory ( fp = None , filename = None ) : NEW_LINE INDENT im = JpegImageFile ( fp , filename ) NEW_LINE try : NEW_LINE INDENT mpheader = im . _getmp ( ) NEW_LINE if mpheader [ 45057 ] > 1 : NEW_LINE # ▁ It ' s ▁ actually ▁ an ▁ MPO ENDCOM INDENT from . MpoImagePlugin import MpoImageFile NEW_LINE im = MpoImageFile ( fp , filename ) NEW_LINE DEDENT DEDENT except ( TypeError , IndexError ) : NEW_LINE # ▁ It ▁ is ▁ really ▁ a ▁ JPEG ENDCOM INDENT pass NEW_LINE DEDENT except SyntaxError : NEW_LINE INDENT warnings . warn ( " Image ▁ appears ▁ to ▁ be ▁ a ▁ malformed ▁ MPO ▁ file , ▁ it ▁ will ▁ be ▁ " " interpreted ▁ as ▁ a ▁ base ▁ JPEG ▁ file " ) NEW_LINE DEDENT return im NEW_LINE # ▁ Registry ▁ stuff ENDCOM DEDENT
def check_cli ( module , cli ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ method ▁ checks ▁ for ▁ idempotency ▁ using ▁ the ▁ vtep - show ▁ command . STRNEWLINE ▁ If ▁ a ▁ name ▁ exists , ▁ return ▁ True ▁ if ▁ name ▁ exists ▁ else ▁ False . STRNEWLINE ▁ : param ▁ module : ▁ The ▁ Ansible ▁ module ▁ to ▁ fetch ▁ input ▁ parameters STRNEWLINE ▁ : param ▁ cli : ▁ The ▁ CLI ▁ string STRNEWLINE ▁ """ NEW_LINE name = module . params [ ' pn _ name ' ] NEW_LINE cli += ' ▁ vtep - show ▁ format ▁ name ▁ no - show - headers ' NEW_LINE out = run_commands ( module , cli ) [ 1 ] NEW_LINE if out : NEW_LINE INDENT out = out . split ( ) NEW_LINE DEDENT return True if name in out else False NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT """ ▁ This ▁ section ▁ is ▁ for ▁ arguments ▁ parsing ▁ """ NEW_LINE state_map = dict ( present = ' vtep - create ' , absent = ' vtep - delete ' ) NEW_LINE argument_spec = dict ( pn_cliswitch = dict ( required = False , type = ' str ' ) , state = dict ( required = False , type = ' str ' , choices = state_map . keys ( ) , default = ' present ' ) , pn_name = dict ( required = False , type = ' str ' ) , pn_ip = dict ( required = False , type = ' str ' ) , pn_vrouter_name = dict ( required = False , type = ' str ' ) , pn_virtual_ip = dict ( required = False , type = ' str ' ) , pn_location = dict ( required = False , type = ' str ' ) , pn_switch_in_cluster = dict ( required = False , type = ' bool ' , default = ' True ' ) ) NEW_LINE module = AnsibleModule ( argument_spec = argument_spec , required_if = ( [ " state " , " present " , [ " pn _ name " , " pn _ ip " , " pn _ vrouter _ name " , " pn _ location " ] ] , [ " state " , " absent " , [ " pn _ name " ] ] , ) , ) NEW_LINE # ▁ Accessing ▁ the ▁ arguments ENDCOM cliswitch = module . params [ ' pn _ cliswitch ' ] NEW_LINE state = module . params [ ' state ' ] NEW_LINE name = module . params [ ' pn _ name ' ] NEW_LINE ip = module . params [ ' pn _ ip ' ] NEW_LINE vrouter_name = module . params [ ' pn _ vrouter _ name ' ] NEW_LINE virtual_ip = module . params [ ' pn _ virtual _ ip ' ] NEW_LINE location = module . params [ ' pn _ location ' ] NEW_LINE switch_in_cluster = module . params [ ' pn _ switch _ in _ cluster ' ] NEW_LINE if switch_in_cluster and not virtual_ip and state == ' present ' : NEW_LINE INDENT module . exit_json ( failed = True , msg = ' virtual ▁ ip ▁ is ▁ required ▁ when ▁ switch ▁ is ▁ in ▁ cluster ' ) NEW_LINE DEDENT command = state_map [ state ] NEW_LINE # ▁ Building ▁ the ▁ CLI ▁ command ▁ string ENDCOM cli = pn_cli ( module , cliswitch ) NEW_LINE NAME_EXISTS = check_cli ( module , cli ) NEW_LINE cli += ' ▁ % s ▁ name ▁ % s ▁ ' % ( command , name ) NEW_LINE if command == ' vtep - delete ' : NEW_LINE INDENT if NAME_EXISTS is False : NEW_LINE INDENT module . exit_json ( skipped = True , msg = ' vtep ▁ with ▁ name ▁ % s ▁ does ▁ not ▁ exist ' % name ) NEW_LINE DEDENT DEDENT if command == ' vtep - create ' : NEW_LINE INDENT if NAME_EXISTS is True : NEW_LINE INDENT module . exit_json ( skipped = True , msg = ' vtpe ▁ with ▁ name ▁ % s ▁ already ▁ exists ' % name ) NEW_LINE DEDENT cli += ' vrouter - name ▁ % s ▁ ' % vrouter_name NEW_LINE cli += ' ip ▁ % s ▁ ' % ip NEW_LINE cli += ' location ▁ % s ▁ ' % location NEW_LINE if virtual_ip : NEW_LINE INDENT cli += ' virtual - ip ▁ % s ▁ ' % virtual_ip NEW_LINE DEDENT DEDENT run_cli ( module , cli , state_map ) NEW_LINE DEDENT
