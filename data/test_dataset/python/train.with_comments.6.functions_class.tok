def _read_image ( self , filename ) : NEW_LINE INDENT filepath = testutils . get_absolute_file_path ( os . path . join ( ' data ' , filename ) ) NEW_LINE self . assert_ ( testutils . CheckFileSum ( filepath , self . checksums [ filename ] ) ) NEW_LINE m = ImageMetadata ( filepath ) NEW_LINE m . read ( ) NEW_LINE return m NEW_LINE DEDENT
def _expected_raw_value ( self , endianness , value ) : NEW_LINE INDENT from pyexiv2 import __exiv2_version__ NEW_LINE if __exiv2_version__ >= '0.20' : NEW_LINE INDENT return value NEW_LINE DEDENT else : NEW_LINE INDENT encodings = { ' ii ' : ' utf - 16le ' , ' mm ' : ' utf - 16be ' } NEW_LINE return value . decode ( ' utf - 8' ) . encode ( encodings [ endianness ] ) NEW_LINE DEDENT DEDENT
def test_read_ascii ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - ascii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Ascii " ▁ deja ▁ vu ' ) NEW_LINE self . assertEqual ( tag . value , u ' deja ▁ vu ' ) NEW_LINE DEDENT
def test_read_unicode_little_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - ii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' ii ' , ' déjà ▁ vu ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' déjà ▁ vu ' ) NEW_LINE DEDENT
def test_read_unicode_big_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - mm . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' mm ' , ' déjà ▁ vu ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' déjà ▁ vu ' ) NEW_LINE DEDENT
def test_write_ascii ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - ascii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = ' foo ▁ bar ' NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Ascii " ▁ foo ▁ bar ' ) NEW_LINE self . assertEqual ( tag . value , u ' foo ▁ bar ' ) NEW_LINE DEDENT
def test_write_unicode_over_ascii ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - ascii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = u ' déjà ▁ vu ' NEW_LINE self . assertEqual ( tag . raw_value , ' déjà ▁ vu ' ) NEW_LINE self . assertEqual ( tag . value , u ' déjà ▁ vu ' ) NEW_LINE DEDENT
def test_write_unicode_little_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - ii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = u ' DÉJÀ ▁ VU ' NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' ii ' , ' DÉJÀ ▁ VU ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' DÉJÀ ▁ VU ' ) NEW_LINE DEDENT
def test_write_unicode_big_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - mm . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = u ' DÉJÀ ▁ VU ' NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' mm ' , ' DÉJÀ ▁ VU ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' DÉJÀ ▁ VU ' ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE # ▁ Create ▁ an ▁ empty ▁ image ▁ file ENDCOM INDENT fd , self . pathname = tempfile . mkstemp ( suffix = ' . jpg ' ) NEW_LINE os . write ( fd , EMPTY_JPG_DATA ) NEW_LINE os . close ( fd ) NEW_LINE DEDENT
def tearDown ( self ) : NEW_LINE INDENT os . remove ( self . pathname ) NEW_LINE DEDENT
def _test_add_comment ( self , value ) : NEW_LINE INDENT metadata = ImageMetadata ( self . pathname ) NEW_LINE metadata . read ( ) NEW_LINE key = ' Exif . Photo . UserComment ' NEW_LINE metadata [ key ] = value NEW_LINE metadata . write ( ) NEW_LINE metadata = ImageMetadata ( self . pathname ) NEW_LINE metadata . read ( ) NEW_LINE self . assert_ ( key in metadata . exif_keys ) NEW_LINE tag = metadata [ key ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . value , value ) NEW_LINE DEDENT
def test_add_comment_ascii ( self ) : NEW_LINE INDENT self . _test_add_comment ( ' deja ▁ vu ' ) NEW_LINE DEDENT
def test_add_comment_unicode ( self ) : NEW_LINE INDENT self . _test_add_comment ( u ' déjà ▁ vu ' ) NEW_LINE DEDENT
def __init__ ( self , n = 0 , e = 0 , d = 0 , p = 0 , q = 0 , dP = 0 , dQ = 0 , qInv = 0 ) : NEW_LINE INDENT if not d : NEW_LINE INDENT self . rsa = RSA . construct ( ( n , e ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . rsa = RSA . construct ( ( n , e , d , p , q ) ) NEW_LINE DEDENT DEDENT
def __getattr__ ( self , name ) : NEW_LINE INDENT return getattr ( self . rsa , name ) NEW_LINE DEDENT
def hasPrivateKey ( self ) : NEW_LINE INDENT return self . rsa . has_private ( ) NEW_LINE DEDENT
def hash ( self ) : NEW_LINE INDENT return Python_RSAKey ( self . n , self . e ) . hash ( ) NEW_LINE DEDENT
def _rawPrivateKeyOp ( self , m ) : NEW_LINE INDENT s = numberToString ( m ) NEW_LINE byteLength = numBytes ( self . n ) NEW_LINE if len ( s ) == byteLength : NEW_LINE INDENT pass NEW_LINE DEDENT elif len ( s ) == byteLength - 1 : NEW_LINE INDENT s = ' \0' + s NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT c = stringToNumber ( self . rsa . decrypt ( ( s , ) ) ) NEW_LINE return c NEW_LINE DEDENT
def _rawPublicKeyOp ( self , c ) : NEW_LINE INDENT s = numberToString ( c ) NEW_LINE byteLength = numBytes ( self . n ) NEW_LINE if len ( s ) == byteLength : NEW_LINE INDENT pass NEW_LINE DEDENT elif len ( s ) == byteLength - 1 : NEW_LINE INDENT s = ' \0' + s NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT m = stringToNumber ( self . rsa . encrypt ( s , None ) [ 0 ] ) NEW_LINE return m NEW_LINE DEDENT
def writeXMLPublicKey ( self , indent = ' ' ) : NEW_LINE INDENT return Python_RSAKey ( self . n , self . e ) . write ( indent ) NEW_LINE DEDENT
def __hash__ ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def __iter__ ( self ) : NEW_LINE INDENT while False : NEW_LINE INDENT yield None NEW_LINE DEDENT DEDENT
def __next__ ( self ) : NEW_LINE INDENT raise StopIteration NEW_LINE DEDENT
def __iter__ ( self ) : NEW_LINE INDENT return self NEW_LINE DEDENT
def __len__ ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def __contains__ ( self , x ) : NEW_LINE INDENT return False NEW_LINE DEDENT
def __call__ ( self , * args , ** kwds ) : NEW_LINE INDENT return False NEW_LINE DEDENT
def __le__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT if len ( self ) > len ( other ) : NEW_LINE INDENT return False NEW_LINE DEDENT for elem in self : NEW_LINE INDENT if elem not in other : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def __lt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return len ( self ) < len ( other ) and self . __le__ ( other ) NEW_LINE DEDENT
def __gt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return other < self NEW_LINE DEDENT
def __ge__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return other <= self NEW_LINE DEDENT
def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return len ( self ) == len ( other ) and self . __le__ ( other ) NEW_LINE DEDENT
def __ne__ ( self , other ) : NEW_LINE INDENT return not ( self == other ) NEW_LINE DEDENT
def __and__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . _from_iterable ( value for value in other if value in self ) NEW_LINE DEDENT
def isdisjoint ( self , other ) : NEW_LINE INDENT for value in other : NEW_LINE INDENT if value in self : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def __or__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT chain = ( e for s in ( self , other ) for e in s ) NEW_LINE return self . _from_iterable ( chain ) NEW_LINE DEDENT
def __sub__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT other = self . _from_iterable ( other ) NEW_LINE DEDENT return self . _from_iterable ( value for value in self if value not in other ) NEW_LINE DEDENT
def __xor__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT other = self . _from_iterable ( other ) NEW_LINE DEDENT return ( self - other ) | ( other - self ) NEW_LINE DEDENT
def _hash ( self ) : NEW_LINE INDENT """ Compute ▁ the ▁ hash ▁ value ▁ of ▁ a ▁ set . STRNEWLINE STRNEWLINE ▁ Note ▁ that ▁ we ▁ don ' t ▁ define ▁ _ _ hash _ _ : ▁ not ▁ all ▁ sets ▁ are ▁ hashable . STRNEWLINE ▁ But ▁ if ▁ you ▁ define ▁ a ▁ hashable ▁ set ▁ type , ▁ its ▁ _ _ hash _ _ ▁ should STRNEWLINE ▁ call ▁ this ▁ function . STRNEWLINE STRNEWLINE ▁ This ▁ must ▁ be ▁ compatible ▁ _ _ eq _ _ . STRNEWLINE STRNEWLINE ▁ All ▁ sets ▁ ought ▁ to ▁ compare ▁ equal ▁ if ▁ they ▁ contain ▁ the ▁ same STRNEWLINE ▁ elements , ▁ regardless ▁ of ▁ how ▁ they ▁ are ▁ implemented , ▁ and STRNEWLINE ▁ regardless ▁ of ▁ the ▁ order ▁ of ▁ the ▁ elements ; ▁ so ▁ there ' s ▁ not ▁ much STRNEWLINE ▁ freedom ▁ for ▁ _ _ eq _ _ ▁ or ▁ _ _ hash _ _ . ▁ We ▁ match ▁ the ▁ algorithm ▁ used STRNEWLINE ▁ by ▁ the ▁ built - in ▁ frozenset ▁ type . STRNEWLINE ▁ """ NEW_LINE MAX = sys . maxsize NEW_LINE MASK = 2 * MAX + 1 NEW_LINE n = len ( self ) NEW_LINE h = 1927868237 * ( n + 1 ) NEW_LINE h &= MASK NEW_LINE for x in self : NEW_LINE INDENT hx = hash ( x ) NEW_LINE h ^= ( hx ^ ( hx << 16 ) ^ 89869747 ) * 3644798167 NEW_LINE h &= MASK NEW_LINE DEDENT h = h * 69069 + 907133923 NEW_LINE h &= MASK NEW_LINE if h > MAX : NEW_LINE INDENT h -= MASK + 1 NEW_LINE DEDENT if h == - 1 : NEW_LINE INDENT h = 590923713 NEW_LINE DEDENT return h NEW_LINE DEDENT
def add ( self , value ) : NEW_LINE INDENT """ Add ▁ an ▁ element . """ NEW_LINE raise NotImplementedError NEW_LINE DEDENT
def discard ( self , value ) : NEW_LINE INDENT """ Remove ▁ an ▁ element . ▁ Do ▁ not ▁ raise ▁ an ▁ exception ▁ if ▁ absent . """ NEW_LINE raise NotImplementedError NEW_LINE DEDENT
def remove ( self , value ) : NEW_LINE INDENT """ Remove ▁ an ▁ element . ▁ If ▁ not ▁ a ▁ member , ▁ raise ▁ a ▁ KeyError . """ NEW_LINE if value not in self : NEW_LINE INDENT raise KeyError ( value ) NEW_LINE DEDENT self . discard ( value ) NEW_LINE DEDENT
def pop ( self ) : NEW_LINE INDENT """ Return ▁ the ▁ popped ▁ value . ▁ Raise ▁ KeyError ▁ if ▁ empty . """ NEW_LINE it = iter ( self ) NEW_LINE try : NEW_LINE INDENT value = next ( it ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT self . discard ( value ) NEW_LINE return value NEW_LINE DEDENT
def clear ( self ) : NEW_LINE INDENT """ This ▁ is ▁ slow ▁ ( creates ▁ N ▁ new ▁ iterators ! ) ▁ but ▁ effective . """ NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT self . pop ( ) NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def __ior__ ( self , it ) : NEW_LINE INDENT for value in it : NEW_LINE INDENT self . add ( value ) NEW_LINE DEDENT return self NEW_LINE DEDENT
def __iand__ ( self , it ) : NEW_LINE INDENT for value in ( self - it ) : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT return self NEW_LINE DEDENT
def __ixor__ ( self , it ) : NEW_LINE INDENT if it is self : NEW_LINE INDENT self . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT if not isinstance ( it , Set ) : NEW_LINE INDENT it = self . _from_iterable ( it ) NEW_LINE DEDENT for value in it : NEW_LINE INDENT if value in self : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT else : NEW_LINE INDENT self . add ( value ) NEW_LINE DEDENT DEDENT DEDENT return self NEW_LINE DEDENT
def __isub__ ( self , it ) : NEW_LINE INDENT if it is self : NEW_LINE INDENT self . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for value in it : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT DEDENT return self NEW_LINE DEDENT
def __getitem__ ( self , key ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT
def get ( self , key , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT
def __contains__ ( self , key ) : NEW_LINE INDENT try : NEW_LINE INDENT self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def keys ( self ) : NEW_LINE INDENT return KeysView ( self ) NEW_LINE DEDENT
def items ( self ) : NEW_LINE INDENT return ItemsView ( self ) NEW_LINE DEDENT
def values ( self ) : NEW_LINE INDENT return ValuesView ( self ) NEW_LINE DEDENT
def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Mapping ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return dict ( self . items ( ) ) == dict ( other . items ( ) ) NEW_LINE DEDENT
def __ne__ ( self , other ) : NEW_LINE INDENT return not ( self == other ) NEW_LINE DEDENT
def __init__ ( self , mapping ) : NEW_LINE INDENT self . _mapping = mapping NEW_LINE DEDENT
def __len__ ( self ) : NEW_LINE INDENT return len ( self . _mapping ) NEW_LINE DEDENT
def __repr__ ( self ) : NEW_LINE INDENT return ' { 0 . _ _ class _ _ . _ _ name _ _ } ( { 0 . _ mapping ! r } ) ' . format ( self ) NEW_LINE DEDENT
def _from_iterable ( self , it ) : NEW_LINE INDENT return set ( it ) NEW_LINE DEDENT
def __contains__ ( self , key ) : NEW_LINE INDENT return key in self . _mapping NEW_LINE DEDENT
def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield key NEW_LINE DEDENT DEDENT
def _from_iterable ( self , it ) : NEW_LINE INDENT return set ( it ) NEW_LINE DEDENT
def __contains__ ( self , item ) : NEW_LINE INDENT key , value = item NEW_LINE try : NEW_LINE INDENT v = self . _mapping [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return v == value NEW_LINE DEDENT DEDENT
def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield ( key , self . _mapping [ key ] ) NEW_LINE DEDENT DEDENT
def __contains__ ( self , value ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT if value == self . _mapping [ key ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield self . _mapping [ key ] NEW_LINE DEDENT DEDENT
def __setitem__ ( self , key , value ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT
def __delitem__ ( self , key ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT
def pop ( self , key , default = __marker ) : NEW_LINE INDENT try : NEW_LINE INDENT value = self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT if default is self . __marker : NEW_LINE INDENT raise NEW_LINE DEDENT return default NEW_LINE DEDENT else : NEW_LINE INDENT del self [ key ] NEW_LINE return value NEW_LINE DEDENT DEDENT
def popitem ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT key = next ( iter ( self ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT value = self [ key ] NEW_LINE del self [ key ] NEW_LINE return key , value NEW_LINE DEDENT
def clear ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT self . popitem ( ) NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def setdefault ( self , key , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT self [ key ] = default NEW_LINE DEDENT return default NEW_LINE DEDENT
def __getitem__ ( self , index ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT
def __iter__ ( self ) : NEW_LINE INDENT i = 0 NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT v = self [ i ] NEW_LINE yield v NEW_LINE i += 1 NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT
def __contains__ ( self , value ) : NEW_LINE INDENT for v in self : NEW_LINE INDENT if v == value : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def __reversed__ ( self ) : NEW_LINE INDENT for i in reversed ( range ( len ( self ) ) ) : NEW_LINE INDENT yield self [ i ] NEW_LINE DEDENT DEDENT
def index ( self , value ) : NEW_LINE INDENT for i , v in enumerate ( self ) : NEW_LINE INDENT if v == value : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT raise ValueError NEW_LINE DEDENT
def count ( self , value ) : NEW_LINE INDENT return sum ( 1 for v in self if v == value ) NEW_LINE DEDENT
def __setitem__ ( self , index , value ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT
def __delitem__ ( self , index ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT
def insert ( self , index , value ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT
def append ( self , value ) : NEW_LINE INDENT self . insert ( len ( self ) , value ) NEW_LINE DEDENT
def clear ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT self . pop ( ) NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def reverse ( self ) : NEW_LINE INDENT n = len ( self ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT self [ i ] , self [ n - i - 1 ] = self [ n - i - 1 ] , self [ i ] NEW_LINE DEDENT DEDENT
def extend ( self , values ) : NEW_LINE INDENT for v in values : NEW_LINE INDENT self . append ( v ) NEW_LINE DEDENT DEDENT
def pop ( self , index = - 1 ) : NEW_LINE INDENT v = self [ index ] NEW_LINE del self [ index ] NEW_LINE return v NEW_LINE DEDENT
def remove ( self , value ) : NEW_LINE INDENT del self [ self . index ( value ) ] NEW_LINE DEDENT
def __iadd__ ( self , values ) : NEW_LINE INDENT self . extend ( values ) NEW_LINE return self NEW_LINE DEDENT
def get_device_by_ip ( self , ip ) : NEW_LINE INDENT for i in netifaces . interfaces ( ) : NEW_LINE INDENT try : NEW_LINE INDENT if i == ' pkt1' : NEW_LINE INDENT continue NEW_LINE DEDENT if netifaces . AF_INET in netifaces . ifaddresses ( i ) : NEW_LINE INDENT interfaces = netifaces . ifaddresses ( i ) [ netifaces . AF_INET ] NEW_LINE for interface in interfaces : NEW_LINE INDENT if ip == interface [ ' addr ' ] : NEW_LINE INDENT if i == ' vhost0' : NEW_LINE INDENT log . info ( " vhost0 ▁ is ▁ already ▁ present ! " ) NEW_LINE DEDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT except ValueError : NEW_LINE INDENT log . info ( " Skipping ▁ interface ▁ % s " , i ) NEW_LINE DEDENT DEDENT raise RuntimeError ( ' % s ▁ not ▁ configured , ▁ rerun ▁ w / ▁ - - physical _ interface ' % ip ) NEW_LINE # ▁ end ▁ get _ device _ by _ ip ENDCOM DEDENT
def get_device_info ( self , ip ) : NEW_LINE INDENT reprov = False NEW_LINE cfg_file = " / etc / contrail / contrail - vrouter - agent . conf " NEW_LINE try : NEW_LINE INDENT dev = self . get_device_by_ip ( ip ) NEW_LINE if dev == " vhost0" : NEW_LINE INDENT dev = self . get_config ( cfg_file , " VIRTUAL - HOST - INTERFACE " , " physical _ interface " ) NEW_LINE log . info ( " Re - provision . ▁ vhost0 ▁ present " ) NEW_LINE reprov = True NEW_LINE DEDENT else : NEW_LINE INDENT log . info ( " Fresh ▁ Install . ▁ vhost0 ▁ not ▁ present " ) NEW_LINE DEDENT DEDENT except RuntimeError : NEW_LINE INDENT dev = self . get_config ( cfg_file , " VIRTUAL - HOST - INTERFACE " , " physical _ interface " ) NEW_LINE if not dev . succeeded : NEW_LINE INDENT raise NEW_LINE DEDENT log . info ( " vhost0 ▁ not ▁ present , ▁ vrouter ▁ not ▁ running " ) NEW_LINE reprov = True NEW_LINE DEDENT return ( dev . strip ( ) , reprov ) NEW_LINE # ▁ end ▁ get _ device _ info ENDCOM DEDENT
def get_secondary_device ( self , primary ) : NEW_LINE INDENT for i in netifaces . interfaces ( ) : NEW_LINE INDENT try : NEW_LINE INDENT if i == ' pkt1' : NEW_LINE INDENT continue NEW_LINE DEDENT if i == primary : NEW_LINE INDENT continue NEW_LINE DEDENT if i == ' vhost0' : NEW_LINE INDENT continue NEW_LINE DEDENT if netifaces . AF_INET not in netifaces . ifaddresses ( i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT except ValueError : NEW_LINE INDENT log . info ( " Skipping ▁ interface ▁ % s " % i ) NEW_LINE DEDENT DEDENT raise RuntimeError ( ' Secondary ▁ interace ▁ ▁ not ▁ configured , ' , ' rerun ▁ w / ▁ - - physical _ interface ' ) NEW_LINE # ▁ end ▁ get _ secondary _ device ENDCOM DEDENT
def get_if_mac ( self , dev ) : NEW_LINE INDENT iface_addr = netifaces . ifaddresses ( dev ) NEW_LINE link_info = iface_addr [ netifaces . AF_LINK ] NEW_LINE mac_addr = link_info [ 0 ] [ ' addr ' ] NEW_LINE return mac_addr NEW_LINE # ▁ end ▁ get _ if _ mac ENDCOM DEDENT
def _rewrite_ifcfg_file ( self , filename , dev , prsv_cfg ) : NEW_LINE INDENT bond = False NEW_LINE mac = ' ' NEW_LINE temp_dir_name = self . _temp_dir_name NEW_LINE vlan = False NEW_LINE if os . path . isfile ( ' / proc / net / vlan / % s ' % dev ) : NEW_LINE INDENT vlan_info = open ( ' / proc / net / vlan / config ' ) . readlines ( ) NEW_LINE match = re . search ( ' ^ % s . * \ | \s + ( \S + ) $ ' % dev , " \n " . join ( vlan_info ) , flags = re . M | re . I ) NEW_LINE if not match : NEW_LINE INDENT raise RuntimeError ( " Configured ▁ vlan ▁ % s ▁ is ▁ not ▁ found ▁ in " , " / proc / net / vlan / config " % dev ) NEW_LINE DEDENT vlan = True NEW_LINE DEDENT if os . path . isdir ( ' / sys / class / net / % s / bonding ' % dev ) : NEW_LINE INDENT bond = True NEW_LINE # ▁ end ▁ if ▁ os . path . isdir . . . ENDCOM DEDENT mac = netifaces . ifaddresses ( dev ) [ netifaces . AF_LINK ] [ 0 ] [ ' addr ' ] NEW_LINE ifcfg_file = ' / etc / sysconfig / network - scripts / ifcfg - % s ' % dev NEW_LINE if not os . path . isfile ( ifcfg_file ) : NEW_LINE INDENT ifcfg_file = temp_dir_name + ' ifcfg - ' + dev NEW_LINE with open ( ifcfg_file , ' w ' ) as f : NEW_LINE INDENT f . write ( ''' # Contrail ▁ % s STRNEWLINE TYPE = Ethernet STRNEWLINE ONBOOT = yes STRNEWLINE DEVICE = " % s " STRNEWLINE USERCTL = yes STRNEWLINE NM _ CONTROLLED = no STRNEWLINE HWADDR = % s STRNEWLINE ''' % ( dev , dev , mac ) ) NEW_LINE for dcfg in prsv_cfg : NEW_LINE INDENT f . write ( dcfg + ' \n ' ) NEW_LINE DEDENT if vlan : NEW_LINE INDENT f . write ( ' VLAN = yes \n ' ) NEW_LINE DEDENT DEDENT DEDENT fd = open ( ifcfg_file ) NEW_LINE f_lines = fd . readlines ( ) NEW_LINE fd . close ( ) NEW_LINE local ( " sudo ▁ rm ▁ - f ▁ % s " % ifcfg_file ) NEW_LINE new_f_lines = [ ] NEW_LINE remove_items = [ ' IPADDR ' , ' NETMASK ' , ' PREFIX ' , ' GATEWAY ' , ' HWADDR ' , ' DNS1' , ' DNS2' , ' BOOTPROTO ' , ' NM _ CONTROLLED ' , ' # Contrail ' ] NEW_LINE remove_items . append ( ' DEVICE ' ) NEW_LINE new_f_lines . append ( ' # Contrail ▁ % s \n ' % dev ) NEW_LINE new_f_lines . append ( ' DEVICE = % s \n ' % dev ) NEW_LINE for line in f_lines : NEW_LINE INDENT found = False NEW_LINE for text in remove_items : NEW_LINE INDENT if text in line : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT if not found : NEW_LINE INDENT new_f_lines . append ( line ) NEW_LINE DEDENT DEDENT new_f_lines . append ( ' NM _ CONTROLLED = no \n ' ) NEW_LINE if bond : NEW_LINE INDENT new_f_lines . append ( ' SUBCHANNELS = 1,2,3 \n ' ) NEW_LINE DEDENT elif not vlan : NEW_LINE INDENT new_f_lines . append ( ' HWADDR = % s \n ' % mac ) NEW_LINE DEDENT fdw = open ( filename , ' w ' ) NEW_LINE fdw . writelines ( new_f_lines ) NEW_LINE fdw . close ( ) NEW_LINE DEDENT
def migrate_routes ( self , device ) : NEW_LINE INDENT ''' STRNEWLINE ▁ add ▁ route ▁ entries ▁ in ▁ / proc / net / route STRNEWLINE ▁ ''' NEW_LINE temp_dir_name = self . _temp_dir_name NEW_LINE cfg_file = ' / etc / sysconfig / network - scripts / route - vhost0' NEW_LINE tmp_file = ' % s / route - vhost0' % temp_dir_name NEW_LINE with open ( tmp_file , ' w ' ) as route_cfg_file : NEW_LINE INDENT for route in open ( ' / proc / net / route ' , ' r ' ) . readlines ( ) : NEW_LINE INDENT if route . startswith ( device ) : NEW_LINE INDENT route_fields = route . split ( ) NEW_LINE destination = int ( route_fields [ 1 ] , 16 ) NEW_LINE gateway = int ( route_fields [ 2 ] , 16 ) NEW_LINE flags = int ( route_fields [ 3 ] , 16 ) NEW_LINE mask = int ( route_fields [ 7 ] , 16 ) NEW_LINE if flags & 0x2 : NEW_LINE INDENT if destination != 0 : NEW_LINE INDENT route_cfg_file . write ( socket . inet_ntoa ( struct . pack ( ' I ' , destination ) ) ) NEW_LINE route_cfg_file . write ( ' / ' + str ( bin ( mask ) . count ( '1' ) ) + ' ▁ ' ) NEW_LINE route_cfg_file . write ( ' via ▁ ' ) NEW_LINE route_cfg_file . write ( socket . inet_ntoa ( struct . pack ( ' I ' , gateway ) ) + ' ▁ ' ) NEW_LINE route_cfg_file . write ( ' dev ▁ vhost0' ) NEW_LINE # ▁ end ▁ if ▁ detination . . . ENDCOM # ▁ end ▁ if ▁ flags ▁ & . . . ENDCOM # ▁ end ▁ if ▁ route . startswith . . . ENDCOM # ▁ end ▁ for ▁ route . . . ENDCOM # ▁ end ▁ with ▁ open . . . ENDCOM DEDENT DEDENT DEDENT DEDENT DEDENT local ( " sudo ▁ mv ▁ - f ▁ % s ▁ % s " % ( tmp_file , cfg_file ) ) NEW_LINE # ▁ delete ▁ the ▁ route - dev ▁ file ENDCOM if os . path . isfile ( ' / etc / sysconfig / network - scripts / route - % s ' % device ) : NEW_LINE INDENT os . unlink ( ' / etc / sysconfig / network - scripts / route - % s ' % device ) NEW_LINE # ▁ end ▁ def ▁ migrate _ routes ENDCOM DEDENT DEDENT
def get_cfgfile_for_dev ( self , iface , cfg_files ) : NEW_LINE INDENT if not cfg_files : NEW_LINE INDENT return None NEW_LINE DEDENT mapped_intf_cfgfile = None NEW_LINE for file in cfg_files : NEW_LINE INDENT with open ( file , ' r ' ) as fd : NEW_LINE INDENT contents = fd . read ( ) NEW_LINE regex = ' ( ? : ^ | \n ) \s * iface\s + % s\s + ' % iface NEW_LINE if re . search ( regex , contents ) : NEW_LINE INDENT mapped_intf_cfgfile = file NEW_LINE DEDENT DEDENT DEDENT return mapped_intf_cfgfile NEW_LINE DEDENT
def get_sourced_files ( self ) : NEW_LINE INDENT ''' Get ▁ all ▁ sourced ▁ config ▁ files ''' NEW_LINE files = self . get_valid_files ( self . get_source_entries ( ) ) NEW_LINE files += self . get_source_directory_files ( ) NEW_LINE return list ( set ( files ) ) NEW_LINE DEDENT
def get_source_directory_files ( self ) : NEW_LINE INDENT ''' Get ▁ source - directory ▁ entry ▁ and ▁ make ▁ list ▁ of ▁ valid ▁ files ''' NEW_LINE regex = ' ( ? : ^ | \n ) \s * source - directory\s + ( \S + ) ' NEW_LINE files = list ( ) NEW_LINE with open ( self . default_cfg_file , ' r ' ) as fd : NEW_LINE INDENT entries = re . findall ( regex , fd . read ( ) ) NEW_LINE DEDENT dirs = [ d for d in self . get_valid_files ( entries ) if os . path . isdir ( d ) ] NEW_LINE for dir in dirs : NEW_LINE INDENT files . extend ( [ os . path . join ( dir , f ) for f in os . listdir ( dir ) if os . path . isfile ( os . path . join ( dir , f ) ) and re . match ( ' ^ [ a - zA - Z0-9 _ - ] + $ ' , f ) ] ) NEW_LINE DEDENT return files NEW_LINE DEDENT
def get_source_entries ( self ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Get ▁ entries ▁ matching ▁ source ▁ keyword ▁ from STRNEWLINE ▁ / etc / network / interfaces ▁ file . STRNEWLINE ▁ ''' NEW_LINE regex = ' ( ? : ^ | \n ) \s * source\s + ( \S + ) ' NEW_LINE with open ( self . default_cfg_file , ' r ' ) as fd : NEW_LINE INDENT return re . findall ( regex , fd . read ( ) ) NEW_LINE DEDENT DEDENT
def get_valid_files ( self , entries ) : NEW_LINE INDENT ''' Provided ▁ a ▁ list ▁ of ▁ glob ' d ▁ strings , ▁ return ▁ matching ▁ file ▁ names ''' NEW_LINE files = list ( ) NEW_LINE prepend = os . path . join ( os . path . sep , ' etc ' , ' network ' ) + os . path . sep NEW_LINE for entry in entries : NEW_LINE INDENT entry = entry . lstrip ( ' . / ' ) if entry . startswith ( ' . / ' ) else entry NEW_LINE if entry . startswith ( os . path . sep ) : NEW_LINE INDENT entry = entry NEW_LINE DEDENT else : NEW_LINE INDENT entry = prepend + entry NEW_LINE DEDENT files . extend ( glob . glob ( entry ) ) NEW_LINE DEDENT return files NEW_LINE DEDENT
def _rewrite_net_interfaces_file ( self , dev , mac , vhost_ip , netmask , gateway_ip , esxi_vm , vmpg_mtu , datapg_mtu ) : NEW_LINE INDENT self . default_cfg_file = ' / etc / network / interfaces ' NEW_LINE cfg_files = self . get_sourced_files ( ) NEW_LINE cfg_files . append ( self . default_cfg_file ) NEW_LINE intf_cfgfile = self . get_cfgfile_for_dev ( ' vhost0' , cfg_files ) NEW_LINE if intf_cfgfile : NEW_LINE INDENT log . info ( " Interface ▁ vhost0 ▁ is ▁ already ▁ present ▁ in " + " / etc / network / interfaces " ) NEW_LINE log . info ( " Skipping ▁ rewrite ▁ of ▁ this ▁ file " ) NEW_LINE return NEW_LINE # ▁ endif ENDCOM DEDENT vlan = False NEW_LINE if os . path . isfile ( ' / proc / net / vlan / % s ' % dev ) : NEW_LINE INDENT vlan_info = open ( ' / proc / net / vlan / config ' ) . readlines ( ) NEW_LINE match = re . search ( ' ^ % s . * \ | \s + ( \S + ) $ ' % dev , " \n " . join ( vlan_info ) , flags = re . M | re . I ) NEW_LINE if not match : NEW_LINE INDENT raise RuntimeError ( ' Configured ▁ vlan ▁ % s ▁ is ▁ not ▁ found ▁ in ' , ' / proc / net / vlan / config ' % dev ) NEW_LINE DEDENT phydev = match . group ( 1 ) NEW_LINE vlan = True NEW_LINE # ▁ Replace ▁ strings ▁ matching ▁ dev ▁ to ▁ vhost0 ▁ in ▁ ifup ▁ and ▁ ifdown ▁ parts ▁ file ENDCOM # ▁ Any ▁ changes ▁ to ▁ the ▁ file / logic ▁ with ▁ static ▁ routes ▁ has ▁ to ▁ be ENDCOM # ▁ reflected ▁ in ▁ setup - vnc - static - routes . py ▁ too ENDCOM DEDENT ifup_parts_file = os . path . join ( os . path . sep , ' etc ' , ' network ' , ' if - up . d ' , ' routes ' ) NEW_LINE ifdown_parts_file = os . path . join ( os . path . sep , ' etc ' , ' network ' , ' if - down . d ' , ' routes ' ) NEW_LINE if ( os . path . isfile ( ifup_parts_file ) and os . path . isfile ( ifdown_parts_file ) ) : NEW_LINE INDENT local ( " sudo ▁ sed ▁ - i ▁ ' s / % s / vhost0 / g ' ▁ % s " % ( dev , ifup_parts_file ) , warn_only = True ) NEW_LINE local ( " sudo ▁ sed ▁ - i ▁ ' s / % s / vhost0 / g ' ▁ % s " % ( dev , ifdown_parts_file ) , warn_only = True ) NEW_LINE DEDENT dev_cfgfile = self . get_cfgfile_for_dev ( dev , cfg_files ) NEW_LINE temp_intf_file = ' % s / interfaces ' % self . _temp_dir_name NEW_LINE local ( " sudo ▁ cp ▁ % s ▁ % s " % ( dev_cfgfile , temp_intf_file ) ) NEW_LINE with open ( dev_cfgfile , ' r ' ) as fd : NEW_LINE INDENT cfg_file = fd . read ( ) NEW_LINE DEDENT if not self . _args . non_mgmt_ip : NEW_LINE # ▁ remove ▁ entry ▁ from ▁ auto ▁ < dev > ▁ to ▁ auto ▁ excluding ▁ these ▁ pattern ENDCOM # ▁ then ▁ delete ▁ specifically ▁ auto ▁ < dev > ENDCOM INDENT local ( " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / , / auto / { / auto / ! d } ' ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / d ' ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE # ▁ add ▁ manual ▁ entry ▁ for ▁ dev ENDCOM local ( " sudo ▁ echo ▁ ' auto ▁ % s ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' iface ▁ % s ▁ inet ▁ manual ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE if vlan : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - up ▁ ifconfig ▁ % s ▁ up ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - down ▁ ifconfig ▁ % s ▁ down ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE DEDENT else : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - down ▁ ifconfig ▁ % s ▁ down ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE DEDENT if esxi_vm : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( dev , datapg_mtu , temp_intf_file ) ) NEW_LINE cmd = " sudo ▁ ethtool ▁ - i ▁ % s ▁ | ▁ grep ▁ driver ▁ | ▁ cut ▁ - f ▁ 2 ▁ - d ▁ ' ▁ ' " % dev NEW_LINE device_driver = local ( cmd , capture = True ) NEW_LINE if ( device_driver == " vmxnet3" ) : NEW_LINE INDENT cmd = " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ethtool ▁ - - offload ▁ " NEW_LINE rx_cmd = ( cmd + " % s ▁ rx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE tx_cmd = ( cmd + " % s ▁ tx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( rx_cmd ) NEW_LINE local ( tx_cmd ) NEW_LINE DEDENT DEDENT if vlan : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ vlan - raw - device ▁ % s ' ▁ > > ▁ % s " % ( phydev , temp_intf_file ) ) NEW_LINE DEDENT if ' bond ' in dev . lower ( ) : NEW_LINE INDENT iters = re . finditer ( ' ^ \s * auto\s ' , cfg_file , re . M ) NEW_LINE indices = [ pat_match . start ( ) for pat_match in iters ] NEW_LINE matches = map ( cfg_file . __getslice__ , indices , indices [ 1 : ] + [ len ( cfg_file ) ] ) NEW_LINE for each in matches : NEW_LINE INDENT each = each . strip ( ) NEW_LINE if re . match ( ' ^ auto\s + % s ' % dev , each ) : NEW_LINE INDENT string = ' ' NEW_LINE for lines in each . splitlines ( ) : NEW_LINE INDENT if ' bond - ' in lines : NEW_LINE INDENT string += lines + os . linesep NEW_LINE DEDENT DEDENT local ( " sudo ▁ echo ▁ ' % s ' ▁ > > ▁ % s " % ( string , temp_intf_file ) ) NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT local ( " sudo ▁ echo ▁ ' ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE DEDENT else : NEW_LINE # ▁ remove ▁ ip ▁ address ▁ and ▁ gateway ENDCOM INDENT local ( " sudo ▁ sed ▁ - i ▁ ' / iface ▁ % s ▁ inet ▁ static / , ▁ + 2d ' ▁ % s " % ( dev , temp_intf_file ) , warn_only = True ) NEW_LINE if esxi_vm : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( dev , datapg_mtu , temp_intf_file ) , warn_only = True ) NEW_LINE cmd = " sudo ▁ ethtool ▁ - i ▁ % s ▁ | ▁ " % dev NEW_LINE cmd += " sudo ▁ grep ▁ driver ▁ | ▁ sudo ▁ cut ▁ - f ▁ 2 ▁ - d ▁ ' ▁ ' " NEW_LINE device_driver = local ( cmd , capture = True , warn_only = True ) NEW_LINE if ( device_driver == " vmxnet3" ) : NEW_LINE INDENT cmd = " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ethtool ▁ - - offload ▁ " NEW_LINE rx_cmd = cmd + " % s ▁ rx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) NEW_LINE tx_cmd = cmd + " % s ▁ tx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) NEW_LINE local ( rx_cmd , warn_only = True ) NEW_LINE local ( tx_cmd , warn_only = True ) NEW_LINE DEDENT DEDENT if vlan : NEW_LINE INDENT cmd = " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / ▁ a\iface ▁ % s ▁ inet ▁ manual\ \n ▁ ▁ ▁ ▁ " % ( dev , dev ) NEW_LINE cmd += " post - up ▁ ifconfig ▁ % s ▁ up\ \n ▁ ▁ ▁ ▁ " % dev NEW_LINE cmd += " pre - down ▁ ifconfig ▁ % s ▁ down\ ' ▁ % s " % ( dev , temp_intf_file ) NEW_LINE local ( cmd ) NEW_LINE DEDENT else : NEW_LINE INDENT cmd = " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / ▁ a\iface ▁ % s ▁ inet ▁ manual\ \n ▁ ▁ ▁ ▁ " % ( dev , dev ) NEW_LINE cmd += " pre - up ▁ ifconfig ▁ % s ▁ up\ \n ▁ ▁ ▁ ▁ " % dev NEW_LINE cmd += " post - down ▁ ifconfig ▁ % s ▁ down\ ' ▁ % s " % ( dev , temp_intf_file ) NEW_LINE local ( cmd ) NEW_LINE DEDENT DEDENT if esxi_vm and vmpg_mtu : NEW_LINE INDENT intf = self . get_secondary_device ( self . dev ) NEW_LINE mac_addr = self . get_if_mac ( intf ) NEW_LINE udev_net_file = ' / etc / udev / rules . d / 70 - persistent - net . rules ' NEW_LINE temp_udev_net_file = ' % s / 70 - persistent - net . rules ' % ( self . _temp_dir_name ) NEW_LINE local ( " sudo ▁ touch ▁ % s " % temp_udev_net_file ) NEW_LINE local ( " sudo ▁ cp ▁ % s ▁ % s " % ( udev_net_file , temp_udev_net_file ) ) NEW_LINE cmd = " sudo ▁ echo ▁ ' SUBSYSTEM = = \ " net\ " , ▁ ACTION = = \ " add\ " , " NEW_LINE cmd += " ▁ DRIVERS = = \ " ? * \ " , " NEW_LINE cmd += " ▁ ATTR { address } = = \ " % s\ " , ▁ ATTR { dev _ id } = = \ " 0x0\ " , ▁ " % mac_addr NEW_LINE cmd += " ATTR { type } = = \ " 1\ " , ▁ KERNEL = = \ " eth * \ " , ▁ NAME = \ " % s\ " ' ▁ > > ▁ % s " % ( intf , temp_udev_net_file ) NEW_LINE local ( cmd ) NEW_LINE local ( " sudo ▁ mv ▁ - f ▁ % s ▁ % s " % ( temp_udev_net_file , udev_net_file ) ) NEW_LINE local ( " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / , / down / d ' ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' \n auto ▁ % s ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' iface ▁ % s ▁ inet ▁ manual ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( intf , vmpg_mtu , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - down ▁ ifconfig ▁ % s ▁ down ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ethtool ▁ - - offload ▁ % s ▁ lro ▁ off ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE # ▁ populte ▁ vhost0 ▁ as ▁ static ENDCOM DEDENT local ( " sudo ▁ echo ▁ ' ' ▁ > > ▁ % s " % ( temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' auto ▁ vhost0 ' ▁ > > ▁ % s " % ( temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' iface ▁ vhost0 ▁ inet ▁ static ' ▁ > > ▁ % s " % ( temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ % s / if - vhost0 ' ▁ > > ▁ % s " % ( self . contrail_bin_dir , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ netmask ▁ % s ' ▁ > > ▁ % s " % ( netmask , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ network _ name ▁ application ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE if esxi_vm and datapg_mtu : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( datapg_mtu , temp_intf_file ) ) NEW_LINE DEDENT if vhost_ip : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ address ▁ % s ' ▁ > > ▁ % s " % ( vhost_ip , temp_intf_file ) ) NEW_LINE DEDENT if ( not self . _args . non_mgmt_ip ) and gateway_ip : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ gateway ▁ % s ' ▁ > > ▁ % s " % ( gateway_ip , temp_intf_file ) ) NEW_LINE DEDENT domain = self . get_domain_search_list ( ) NEW_LINE if domain : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ dns - search ▁ % s ' ▁ > > ▁ % s " % ( domain , temp_intf_file ) ) NEW_LINE DEDENT dns_list = self . get_dns_servers ( dev ) NEW_LINE if dns_list : NEW_LINE INDENT local ( " sudo ▁ echo ▁ - n ▁ ' ▁ ▁ ▁ ▁ dns - nameservers ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE for dns in dns_list : NEW_LINE INDENT local ( " sudo ▁ echo ▁ - n ▁ ' ▁ % s ' ▁ > > ▁ % s " % ( dns , temp_intf_file ) ) NEW_LINE DEDENT local ( " sudo ▁ echo ▁ ' ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE DEDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - up ▁ ip ▁ link ▁ set ▁ vhost0 ▁ address ▁ % s ' ▁ > > ▁ % s " % ( mac , temp_intf_file ) ) NEW_LINE # ▁ move ▁ it ▁ to ▁ right ▁ place ENDCOM local ( " sudo ▁ mv ▁ - f ▁ % s ▁ % s " % ( temp_intf_file , dev_cfgfile ) ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def test_simple_send ( self ) : NEW_LINE INDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertEquals ( b . recv ( ) , " Hallo " ) NEW_LINE b . send ( " Servus " ) NEW_LINE self . assertEquals ( a . recv ( ) , " Servus " ) NEW_LINE DEDENT
def test_ready_to_recv ( self ) : NEW_LINE INDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE self . assertTrue ( b . ready_to_recv ( ) ) NEW_LINE self . assertEquals ( b . recv ( ) , " Hallo " ) NEW_LINE self . assertFalse ( b . ready_to_recv ( ) ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE b . send ( " Servus " ) NEW_LINE self . assertTrue ( a . ready_to_recv ( ) ) NEW_LINE self . assertEquals ( a . recv ( ) , " Servus " ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE DEDENT
def test_on_ready_to_recv ( self ) : NEW_LINE INDENT self . seen_size = - 1 NEW_LINE self . called = 0 NEW_LINE def ready ( socket , size ) : NEW_LINE INDENT self . called += 1 NEW_LINE self . seen_size = size NEW_LINE DEDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE b . set_on_ready_to_recv ( ready ) NEW_LINE self . assertEquals ( self . called , 0 ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertEquals ( self . called , 1 ) NEW_LINE self . assertEquals ( self . seen_size , 5 ) NEW_LINE # ▁ check ▁ that ▁ it ▁ doesn ' t ▁ get ▁ called ▁ on ▁ the ▁ other ▁ sockets ▁ data ENDCOM b . send ( " Huhu " ) NEW_LINE self . assertEquals ( self . called , 1 ) NEW_LINE DEDENT
def test_empty_recv ( self ) : NEW_LINE INDENT """ ▁ test _ empty _ recv : ▁ Check ▁ that ▁ empty ▁ reads ▁ on ▁ socket ▁ return ▁ " " STRNEWLINE ▁ Note ▁ that ▁ this ▁ is ▁ actually ▁ non - sockety ▁ behavior ▁ and ▁ should ▁ probably ▁ be ▁ changed . ▁ This STRNEWLINE ▁ test ▁ documents ▁ it ▁ as ▁ intended ▁ for ▁ now , ▁ though STRNEWLINE ▁ """ NEW_LINE ( a , b ) = MockSocket . pair ( ) NEW_LINE self . assertEquals ( a . recv ( ) , " " ) NEW_LINE DEDENT
def _compute_res_reference ( self ) : NEW_LINE INDENT if self . res_model and self . res_id : NEW_LINE INDENT self . res_reference = ' % s , % s ' % ( self . res_model , self . res_id ) NEW_LINE DEDENT DEDENT
def _inverse_res_reference ( self ) : NEW_LINE INDENT if self . res_reference : NEW_LINE INDENT self . write ( { ' res _ model ' : self . res_reference . _model . _model , ' res _ id ' : self . res_reference . id , } ) NEW_LINE DEDENT else : NEW_LINE INDENT self . write ( { ' res _ model ' : False , ' res _ id ' : False } ) NEW_LINE DEDENT DEDENT
def _selection_res_reference ( self ) : NEW_LINE INDENT return self . env [ ' ir . model ' ] . search ( [ ( ' osv _ memory ' , ' = ' , False ) , ( ' access _ ids . group _ id . users ' , ' = ' , self . env . uid ) ] ) . mapped ( lambda rec : ( rec . model , rec . name ) ) NEW_LINE DEDENT
def test_module_parameters_keys ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE # ▁ Assert ▁ the ▁ top - level ▁ keys ENDCOM assert p . name == ' http _ example ' NEW_LINE assert p . partition == ' Common ' NEW_LINE assert p . template == ' / Common / f5 . http ' NEW_LINE DEDENT
def test_module_parameters_lists ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert ' lists ' in p . _values NEW_LINE assert p . lists [ 0 ] [ ' name ' ] == ' irules _ _ irules ' NEW_LINE assert p . lists [ 0 ] [ ' encrypted ' ] == ' no ' NEW_LINE assert len ( p . lists [ 0 ] [ ' value ' ] ) == 1 NEW_LINE assert p . lists [ 0 ] [ ' value ' ] [ 0 ] == ' / Common / lgyft ' NEW_LINE assert p . lists [ 1 ] [ ' name ' ] == ' net _ _ client _ vlan ' NEW_LINE assert p . lists [ 1 ] [ ' encrypted ' ] == ' no ' NEW_LINE assert len ( p . lists [ 1 ] [ ' value ' ] ) == 1 NEW_LINE assert p . lists [ 1 ] [ ' value ' ] [ 0 ] == ' / Common / net2' NEW_LINE DEDENT
def test_module_parameters_tables ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert ' tables ' in p . _values NEW_LINE assert ' columnNames ' in p . tables [ 0 ] NEW_LINE assert len ( p . tables [ 0 ] [ ' columnNames ' ] ) == 1 NEW_LINE assert p . tables [ 0 ] [ ' columnNames ' ] [ 0 ] == ' name ' NEW_LINE assert ' name ' in p . tables [ 0 ] NEW_LINE assert p . tables [ 0 ] [ ' name ' ] == ' pool _ _ hosts ' NEW_LINE assert ' rows ' in p . tables [ 0 ] NEW_LINE assert len ( p . tables [ 0 ] [ ' rows ' ] ) == 1 NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 0 ] NEW_LINE assert len ( p . tables [ 0 ] [ ' rows ' ] [ 0 ] [ ' row ' ] ) == 1 NEW_LINE assert p . tables [ 0 ] [ ' rows ' ] [ 0 ] [ ' row ' ] [ 0 ] == ' demo . example . com ' NEW_LINE assert len ( p . tables [ 1 ] [ ' rows ' ] ) == 2 NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 0 ] NEW_LINE assert len ( p . tables [ 1 ] [ ' rows ' ] [ 0 ] [ ' row ' ] ) == 2 NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 0 ] [ ' row ' ] [ 0 ] == '10.1.1.1' NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 0 ] [ ' row ' ] [ 1 ] == '0' NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 1 ] [ ' row ' ] [ 0 ] == '10.1.1.2' NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 1 ] [ ' row ' ] [ 1 ] == '0' NEW_LINE DEDENT
def test_module_parameters_variables ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert ' variables ' in p . _values NEW_LINE assert len ( p . variables ) == 34 NEW_LINE # ▁ Assert ▁ one ▁ configuration ▁ value ENDCOM assert ' name ' in p . variables [ 0 ] NEW_LINE assert ' value ' in p . variables [ 0 ] NEW_LINE assert p . variables [ 0 ] [ ' name ' ] == ' afm _ _ dos _ security _ profile ' NEW_LINE assert p . variables [ 0 ] [ ' value ' ] == ' / # do _ not _ use # ' NEW_LINE # ▁ Assert ▁ a ▁ second ▁ configuration ▁ value ENDCOM assert ' name ' in p . variables [ 1 ] NEW_LINE assert ' value ' in p . variables [ 1 ] NEW_LINE assert p . variables [ 1 ] [ ' name ' ] == ' afm _ _ policy ' NEW_LINE assert p . variables [ 1 ] [ ' value ' ] == ' / # do _ not _ use # ' NEW_LINE DEDENT
def test_api_parameters_variables ( self ) : NEW_LINE INDENT args = dict ( variables = [ dict ( name = " client _ _ http _ compression " , encrypted = " no " , value = " / # create _ new # " ) ] ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . variables [ 0 ] [ ' name ' ] == ' client _ _ http _ compression ' NEW_LINE DEDENT
def test_api_parameters_tables ( self ) : NEW_LINE INDENT args = dict ( tables = [ { " name " : " pool _ _ members " , " columnNames " : [ " addr " , " port " , " connection _ limit " ] , " rows " : [ { " row " : [ "12.12.12.12" , "80" , ] } , { " row " : [ "13.13.13.13" , "443" , 10 ] } ] } ] ) p = Parameters ( args ) NEW_LINE assert p . tables [ 0 ] [ ' name ' ] == ' pool _ _ members ' NEW_LINE assert p . tables [ 0 ] [ ' columnNames ' ] == [ ' addr ' , ' port ' , ' connection _ limit ' ] NEW_LINE assert len ( p . tables [ 0 ] [ ' rows ' ] ) == 2 NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 0 ] NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 1 ] NEW_LINE assert p . tables [ 0 ] [ ' rows ' ] [ 0 ] [ ' row ' ] == [ '12.12.12.12' , '80' , '0' ] NEW_LINE assert p . tables [ 0 ] [ ' rows ' ] [ 1 ] [ ' row ' ] == [ '13.13.13.13' , '443' , '10' ] NEW_LINE DEDENT
def test_module_template_same_partition ( self ) : NEW_LINE INDENT args = dict ( template = ' foo ' , partition = ' bar ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . template == ' / bar / foo ' NEW_LINE DEDENT
def test_module_template_same_partition_full_path ( self ) : NEW_LINE INDENT args = dict ( template = ' / bar / foo ' , partition = ' bar ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . template == ' / bar / foo ' NEW_LINE DEDENT
def test_module_template_different_partition_full_path ( self ) : NEW_LINE INDENT args = dict ( template = ' / Common / foo ' , partition = ' bar ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . template == ' / Common / foo ' NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT self . spec = ArgumentSpec ( ) NEW_LINE DEDENT
def test_create_service ( self , * args ) : NEW_LINE INDENT parameters = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE set_module_args ( dict ( name = ' foo ' , template = ' f5 . http ' , parameters = parameters , state = ' present ' , password = ' passsword ' , server = ' localhost ' , user = ' admin ' ) ) NEW_LINE client = AnsibleF5Client ( argument_spec = self . spec . argument_spec , supports_check_mode = self . spec . supports_check_mode , f5_product_name = self . spec . f5_product_name ) NEW_LINE mm = ModuleManager ( client ) NEW_LINE # ▁ Override ▁ methods ▁ to ▁ force ▁ specific ▁ logic ▁ in ▁ the ▁ module ▁ to ▁ happen ENDCOM mm . exists = Mock ( return_value = False ) NEW_LINE mm . create_on_device = Mock ( return_value = True ) NEW_LINE results = mm . exec_module ( ) NEW_LINE assert results [ ' changed ' ] is True NEW_LINE DEDENT
def test_update_agent_status_traps ( self , * args ) : NEW_LINE INDENT parameters = load_fixture ( ' update _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE set_module_args ( dict ( name = ' foo ' , template = ' f5 . http ' , parameters = parameters , state = ' present ' , password = ' passsword ' , server = ' localhost ' , user = ' admin ' ) ) NEW_LINE # ▁ Configure ▁ the ▁ parameters ▁ that ▁ would ▁ be ▁ returned ▁ by ▁ querying ▁ the ENDCOM # ▁ remote ▁ device ENDCOM parameters = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE current = Parameters ( parameters ) NEW_LINE client = AnsibleF5Client ( argument_spec = self . spec . argument_spec , supports_check_mode = self . spec . supports_check_mode , f5_product_name = self . spec . f5_product_name ) NEW_LINE mm = ModuleManager ( client ) NEW_LINE # ▁ Override ▁ methods ▁ to ▁ force ▁ specific ▁ logic ▁ in ▁ the ▁ module ▁ to ▁ happen ENDCOM mm . exists = Mock ( return_value = True ) NEW_LINE mm . update_on_device = Mock ( return_value = True ) NEW_LINE mm . read_current_from_device = Mock ( return_value = current ) NEW_LINE results = mm . exec_module ( ) NEW_LINE assert results [ ' changed ' ] is True NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE # ▁ This ▁ is ▁ how ▁ you ▁ change ▁ the ▁ default ▁ fields ▁ defined ▁ in ▁ a ▁ Django ▁ abstract ▁ class ENDCOM # ▁ ( in ▁ this ▁ case , ▁ MP _ Node ) , ▁ since ▁ Django ▁ doesn ' t ▁ allow ▁ overriding ▁ fields , ▁ only ENDCOM # ▁ mehods ▁ and ▁ attributes ENDCOM DEDENT
def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT self . set_MP ( ) NEW_LINE self . unchanged = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE DEDENT
def set_MP ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = MP_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = MP_TestNode NEW_LINE DEDENT self . sorted_model = MP_TestNodeSorted NEW_LINE self . dep_model = MP_TestNodeSomeDep NEW_LINE DEDENT
def set_NS ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = NS_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = NS_TestNode NEW_LINE DEDENT self . sorted_model = NS_TestNodeSorted NEW_LINE self . dep_model = NS_TestNodeSomeDep NEW_LINE DEDENT
def set_AL ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = AL_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = AL_TestNode NEW_LINE DEDENT self . sorted_model = AL_TestNodeSorted NEW_LINE self . dep_model = AL_TestNodeSomeDep NEW_LINE DEDENT
def got ( self ) : NEW_LINE INDENT nsmodels = [ NS_TestNode ] NEW_LINE if DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT nsmodels . append ( NS_TestNode_Proxy ) NEW_LINE DEDENT if self . model in nsmodels : NEW_LINE # ▁ this ▁ slows ▁ down ▁ nested ▁ sets ▁ tests ▁ quite ▁ a ▁ bit , ▁ but ▁ it ▁ has ▁ the ENDCOM # ▁ advantage ▁ that ▁ we ' ll ▁ check ▁ the ▁ node ▁ edges ▁ are ▁ correct ENDCOM INDENT d = { } NEW_LINE for tree_id , lft , rgt in self . model . objects . values_list ( ' tree _ id ' , ' lft ' , ' rgt ' ) : NEW_LINE INDENT d . setdefault ( tree_id , [ ] ) . extend ( [ lft , rgt ] ) NEW_LINE DEDENT for tree_id , got_edges in d . items ( ) : NEW_LINE INDENT self . assertEqual ( len ( got_edges ) , max ( got_edges ) ) NEW_LINE good_edges = range ( 1 , len ( got_edges ) + 1 ) NEW_LINE self . assertEqual ( sorted ( got_edges ) , good_edges ) NEW_LINE DEDENT DEDENT return [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE DEDENT
def _assert_get_annotated_list ( self , expected , parent = None ) : NEW_LINE INDENT got = [ ( obj [ 0 ] . desc , obj [ 1 ] [ ' open ' ] , obj [ 1 ] [ ' close ' ] , obj [ 1 ] [ ' level ' ] ) for obj in self . model . get_annotated_list ( parent ) ] NEW_LINE self . assertEqual ( expected , got ) NEW_LINE DEDENT
def _multi_load_bulk_empty ( self ) : NEW_LINE INDENT ids = self . model . load_bulk ( BASE_DATA ) NEW_LINE got_descs = [ obj . desc for obj in self . model . objects . filter ( id__in = ids ) ] NEW_LINE expected_descs = [ x [ 0 ] for x in self . unchanged ] NEW_LINE self . assertEqual ( sorted ( got_descs ) , sorted ( expected_descs ) ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT
def _multi_dump_bulk_empty ( self ) : NEW_LINE INDENT self . assertEqual ( self . model . dump_bulk ( ) , [ ] ) NEW_LINE DEDENT
def _multi_add_root_empty ( self ) : NEW_LINE INDENT self . model . add_root ( desc = '1' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_get_root_nodes_empty ( self ) : NEW_LINE INDENT got = self . model . get_root_nodes ( ) NEW_LINE expected = [ ] NEW_LINE self . assertEqual ( [ node . desc for node in got ] , expected ) NEW_LINE DEDENT
def _multi_get_first_root_node_empty ( self ) : NEW_LINE INDENT got = self . model . get_first_root_node ( ) NEW_LINE self . assertEqual ( got , None ) NEW_LINE DEDENT
def _multi_get_last_root_node_empty ( self ) : NEW_LINE INDENT got = self . model . get_last_root_node ( ) NEW_LINE self . assertEqual ( got , None ) NEW_LINE DEDENT
def _multi_get_tree ( self ) : NEW_LINE INDENT got = list ( self . model . get_tree ( ) ) NEW_LINE self . assertEqual ( got , [ ] ) NEW_LINE DEDENT
def _multi_get_annotated_list ( self ) : NEW_LINE INDENT expected = [ ] NEW_LINE self . _assert_get_annotated_list ( expected ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT super ( TestNonEmptyTree , self ) . setUp ( ) NEW_LINE MP_TestNode . load_bulk ( BASE_DATA ) NEW_LINE AL_TestNode . load_bulk ( BASE_DATA ) NEW_LINE NS_TestNode . load_bulk ( BASE_DATA ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT super ( TestClassMethods , self ) . setUp ( ) NEW_LINE DEDENT
def _multi_load_bulk_existing ( self ) : NEW_LINE # ▁ inserting ▁ on ▁ an ▁ existing ▁ node ENDCOM INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE ids = self . model . load_bulk ( BASE_DATA , node ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 4 ) , ( u ' 1' , 4 , 0 ) , ( u ' 2' , 4 , 4 ) , ( u ' 21' , 5 , 0 ) , ( u ' 22' , 5 , 0 ) , ( u ' 23' , 5 , 1 ) , ( u ' 231' , 6 , 0 ) , ( u ' 24' , 5 , 0 ) , ( u ' 3' , 4 , 0 ) , ( u ' 4' , 4 , 1 ) , ( u ' 41' , 5 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE expected_descs = [ u ' 1' , u ' 2' , u ' 21' , u ' 22' , u ' 23' , u ' 231' , u ' 24' , u ' 3' , u ' 4' , u ' 41' ] NEW_LINE got_descs = [ obj . desc for obj in self . model . objects . filter ( id__in = ids ) ] NEW_LINE self . assertEqual ( sorted ( got_descs ) , sorted ( expected_descs ) ) NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_get_tree_all ( self ) : NEW_LINE INDENT got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE self . assertEqual ( got , self . unchanged ) NEW_LINE DEDENT
def _multi_dump_bulk_all ( self ) : NEW_LINE INDENT self . assertEqual ( self . model . dump_bulk ( keep_ids = False ) , BASE_DATA ) NEW_LINE DEDENT
def _multi_get_tree_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . model . load_bulk ( BASE_DATA , node ) NEW_LINE # ▁ the ▁ tree ▁ was ▁ modified ▁ by ▁ load _ bulk , ▁ so ▁ we ▁ reload ▁ our ▁ node ▁ object ENDCOM node = self . model . objects . get ( pk = node . id ) NEW_LINE got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( node ) ] NEW_LINE expected = [ ( u ' 231' , 3 , 4 ) , ( u ' 1' , 4 , 0 ) , ( u ' 2' , 4 , 4 ) , ( u ' 21' , 5 , 0 ) , ( u ' 22' , 5 , 0 ) , ( u ' 23' , 5 , 1 ) , ( u ' 231' , 6 , 0 ) , ( u ' 24' , 5 , 0 ) , ( u ' 3' , 4 , 0 ) , ( u ' 4' , 4 , 1 ) , ( u ' 41' , 5 , 0 ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT
def _multi_get_tree_leaf ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE self . assertEqual ( 0 , node . get_children_count ( ) ) NEW_LINE got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( node ) ] NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT
def _multi_get_annotated_list_all ( self ) : NEW_LINE INDENT expected = [ ( u ' 1' , True , [ ] , 0 ) , ( u ' 2' , False , [ ] , 0 ) , ( u ' 21' , True , [ ] , 1 ) , ( u ' 22' , False , [ ] , 1 ) , ( u ' 23' , False , [ ] , 1 ) , ( u ' 231' , True , [ 0 ] , 2 ) , ( u ' 24' , False , [ 0 ] , 1 ) , ( u ' 3' , False , [ ] , 0 ) , ( u ' 4' , False , [ ] , 0 ) , ( u ' 41' , True , [ 0 , 1 ] , 1 ) ] NEW_LINE self . _assert_get_annotated_list ( expected ) NEW_LINE DEDENT
def _multi_get_annotated_list_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 2' ) NEW_LINE expected = [ ( u ' 2' , True , [ ] , 0 ) , ( u ' 21' , True , [ ] , 1 ) , ( u ' 22' , False , [ ] , 1 ) , ( u ' 23' , False , [ ] , 1 ) , ( u ' 231' , True , [ 0 ] , 2 ) , ( u ' 24' , False , [ 0 , 1 ] , 1 ) ] NEW_LINE self . _assert_get_annotated_list ( expected , node ) NEW_LINE DEDENT
def _multi_get_annotated_list_leaf ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE expected = [ ( u ' 1' , True , [ 0 ] , 0 ) ] NEW_LINE self . _assert_get_annotated_list ( expected , node ) NEW_LINE DEDENT
def _multi_dump_bulk_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . model . load_bulk ( BASE_DATA , node ) NEW_LINE # ▁ the ▁ tree ▁ was ▁ modified ▁ by ▁ load _ bulk , ▁ so ▁ we ▁ reload ▁ our ▁ node ▁ object ENDCOM node = self . model . objects . get ( pk = node . id ) NEW_LINE got = self . model . dump_bulk ( node , False ) NEW_LINE expected = [ { ' data ' : { ' desc ' : u ' 231' } , ' children ' : BASE_DATA } ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT
def _multi_load_and_dump_bulk_keeping_ids ( self ) : NEW_LINE INDENT exp = self . model . dump_bulk ( keep_ids = True ) NEW_LINE self . model . objects . all ( ) . delete ( ) NEW_LINE self . model . load_bulk ( exp , None , True ) NEW_LINE got = self . model . dump_bulk ( keep_ids = True ) NEW_LINE self . assertEqual ( got , exp ) NEW_LINE # ▁ do ▁ we ▁ really ▁ have ▁ an ▁ unchaged ▁ tree ▁ after ▁ the ▁ dump / delete / load ? ENDCOM got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE self . assertEqual ( got , self . unchanged ) NEW_LINE DEDENT
def _multi_get_root_nodes ( self ) : NEW_LINE INDENT got = self . model . get_root_nodes ( ) NEW_LINE expected = [ '1' , '2' , '3' , '4' ] NEW_LINE self . assertEqual ( [ node . desc for node in got ] , expected ) NEW_LINE DEDENT
def _multi_get_first_root_node ( self ) : NEW_LINE INDENT got = self . model . get_first_root_node ( ) NEW_LINE self . assertEqual ( got . desc , '1' ) NEW_LINE DEDENT
def _multi_get_last_root_node ( self ) : NEW_LINE INDENT got = self . model . get_last_root_node ( ) NEW_LINE self . assertEqual ( got . desc , '4' ) NEW_LINE DEDENT
def _multi_add_root ( self ) : NEW_LINE INDENT obj = self . model . add_root ( desc = '5' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE self . assertEqual ( self . model . get_last_root_node ( ) . desc , '5' ) NEW_LINE DEDENT
def _multi_is_root ( self ) : NEW_LINE INDENT data = [ ( '2' , True ) , ( '1' , True ) , ( '4' , True ) , ( '21' , False ) , ( '24' , False ) , ( '22' , False ) , ( '231' , False ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . is_root ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT
def _multi_is_leaf ( self ) : NEW_LINE INDENT data = [ ( '2' , False ) , ( '23' , False ) , ( '231' , True ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . is_leaf ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_root ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' ) , ( '1' , '1' ) , ( '4' , '4' ) , ( '21' , '2' ) , ( '24' , '2' ) , ( '22' , '2' ) , ( '231' , '2' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_root ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_parent ( self ) : NEW_LINE INDENT data = [ ( '2' , None ) , ( '1' , None ) , ( '4' , None ) , ( '21' , '2' ) , ( '24' , '2' ) , ( '22' , '2' ) , ( '231' , '23' ) , ] NEW_LINE data = dict ( data ) NEW_LINE objs = { } NEW_LINE for desc , expected in data . items ( ) : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) NEW_LINE parent = node . get_parent ( ) NEW_LINE if expected : NEW_LINE INDENT self . assertEqual ( parent . desc , expected ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( parent , None ) NEW_LINE DEDENT objs [ desc ] = node NEW_LINE # ▁ corrupt ▁ the ▁ objects ' ▁ parent ▁ cache ENDCOM node . _parent_obj = ' CORRUPTED ! ! ! ' NEW_LINE DEDENT for desc , expected in data . items ( ) : NEW_LINE INDENT node = objs [ desc ] NEW_LINE # ▁ asking ▁ get _ parent ▁ to ▁ not ▁ use ▁ the ▁ parent ▁ cache ▁ ( since ▁ we ENDCOM # ▁ corrupted ▁ it ▁ in ▁ the ▁ previous ▁ loop ) ENDCOM parent = node . get_parent ( True ) NEW_LINE if expected : NEW_LINE INDENT self . assertEqual ( parent . desc , expected ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( parent , None ) NEW_LINE DEDENT DEDENT DEDENT
def _multi_get_children ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '21' , '22' , '23' , '24' ] ) , ( '23' , [ '231' ] ) , ( '231' , [ ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT children = self . model . objects . get ( desc = desc ) . get_children ( ) NEW_LINE self . assertEqual ( [ node . desc for node in children ] , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_children_count ( self ) : NEW_LINE INDENT data = [ ( '2' , 4 ) , ( '23' , 1 ) , ( '231' , 0 ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . get_children_count ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_siblings ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '1' , '2' , '3' , '4' ] ) , ( '21' , [ '21' , '22' , '23' , '24' ] ) , ( '231' , [ '231' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT siblings = self . model . objects . get ( desc = desc ) . get_siblings ( ) NEW_LINE self . assertEqual ( [ node . desc for node in siblings ] , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_first_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '1' ) , ( '1' , '1' ) , ( '4' , '1' ) , ( '21' , '21' ) , ( '24' , '21' ) , ( '22' , '21' ) , ( '231' , '231' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_first_sibling ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_prev_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '1' ) , ( '1' , None ) , ( '4' , '3' ) , ( '21' , None ) , ( '24' , '23' ) , ( '22' , '21' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_prev_sibling ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT
def _multi_get_next_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '3' ) , ( '1' , '2' ) , ( '4' , None ) , ( '21' , '22' ) , ( '24' , None ) , ( '22' , '23' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_next_sibling ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT
def _multi_get_last_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '4' ) , ( '1' , '4' ) , ( '4' , '4' ) , ( '21' , '24' ) , ( '24' , '24' ) , ( '22' , '24' ) , ( '231' , '231' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_last_sibling ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_first_child ( self ) : NEW_LINE INDENT data = [ ( '2' , '21' ) , ( '21' , None ) , ( '23' , '231' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_first_child ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT
def _multi_get_last_child ( self ) : NEW_LINE INDENT data = [ ( '2' , '24' ) , ( '21' , None ) , ( '23' , '231' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_last_child ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT
def _multi_get_ancestors ( self ) : NEW_LINE INDENT data = [ ( '2' , [ ] ) , ( '21' , [ '2' ] ) , ( '231' , [ '2' , '23' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT nodes = self . model . objects . get ( desc = desc ) . get_ancestors ( ) NEW_LINE self . assertEqual ( [ node . desc for node in nodes ] , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_descendants ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '21' , '22' , '23' , '231' , '24' ] ) , ( '23' , [ '231' ] ) , ( '231' , [ ] ) , ( '1' , [ ] ) , ( '4' , [ '41' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT nodes = self . model . objects . get ( desc = desc ) . get_descendants ( ) NEW_LINE self . assertEqual ( [ node . desc for node in nodes ] , expected ) NEW_LINE DEDENT DEDENT
def _multi_get_descendant_count ( self ) : NEW_LINE INDENT data = [ ( '2' , 5 ) , ( '23' , 1 ) , ( '231' , 0 ) , ( '1' , 0 ) , ( '4' , 1 ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . get_descendant_count ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT
def _multi_is_sibling_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , True ) , ( '2' , '1' , True ) , ( '21' , '2' , False ) , ( '231' , '2' , False ) , ( '22' , '23' , True ) , ( '231' , '23' , False ) , ( '231' , '231' , True ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_sibling_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT
def _multi_is_child_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , False ) , ( '2' , '1' , False ) , ( '21' , '2' , True ) , ( '231' , '2' , False ) , ( '231' , '23' , True ) , ( '231' , '231' , False ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_child_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT
def _multi_is_descendant_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , False ) , ( '2' , '1' , False ) , ( '21' , '2' , True ) , ( '231' , '2' , True ) , ( '231' , '23' , True ) , ( '231' , '231' , False ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_descendant_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT
def _multi_add_child_to_leaf ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . add_child ( desc = '2311' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 1 ) , ( u ' 2311' , 4 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_child_to_node ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 2' ) . add_child ( desc = '25' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 25' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_invalid_pos ( self ) : NEW_LINE INDENT method = self . model . objects . get ( desc = u ' 231' ) . add_sibling NEW_LINE self . assertRaises ( InvalidPosition , method , ' invalid _ pos ' ) NEW_LINE DEDENT
def _multi_add_sibling_missing_nodeorderby ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE method = node_wchildren . add_sibling NEW_LINE self . assertRaises ( MissingNodeOrderBy , method , ' sorted - sibling ' , desc = ' aaa ' ) NEW_LINE DEDENT
def _multi_add_sibling_last_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' last - sibling ' , desc = '5' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE self . assertEqual ( node_wchildren . get_last_sibling ( ) . desc , u ' 5' ) NEW_LINE DEDENT
def _multi_add_sibling_last ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' last - sibling ' , desc = '232' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE self . assertEqual ( node . get_last_sibling ( ) . desc , u ' 232' ) NEW_LINE DEDENT
def _multi_add_sibling_first_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' first - sibling ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' new ' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_first ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' first - sibling ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' new ' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_left_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' new ' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_left ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' new ' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_left_noleft_root ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE obj = node . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' new ' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_left_noleft ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' new ' , 3 , 0 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_right_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' new ' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_right ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' new ' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_right_noright_root ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 4' ) NEW_LINE obj = node . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' new ' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_sibling_right_noright ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 231' , 3 , 0 ) , ( u ' new ' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT super ( TestDelete , self ) . setUp ( ) NEW_LINE for node in self . model . objects . all ( ) : NEW_LINE INDENT self . dep_model ( node = node ) . save ( ) NEW_LINE DEDENT DEDENT
def _multi_delete_leaf ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_delete_node ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 23' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 3 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_delete_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 2' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_delete_filter_root_nodes ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '3' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_delete_filter_children ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '23' , '231' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_delete_nonexistant_nodes ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( ' ZZZ ' , ' XXX ' ) ) . delete ( ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT
def _multi_delete_same_node_twice ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '2' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_delete_all_root_nodes ( self ) : NEW_LINE INDENT self . model . get_root_nodes ( ) . delete ( ) NEW_LINE count = self . model . objects . count ( ) NEW_LINE self . assertEqual ( count , 0 ) NEW_LINE DEDENT
def _multi_delete_all_nodes ( self ) : NEW_LINE INDENT self . model . objects . all ( ) . delete ( ) NEW_LINE count = self . model . objects . count ( ) NEW_LINE self . assertEqual ( count , 0 ) NEW_LINE DEDENT
def _multi_move_invalid_pos ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( InvalidPosition , node . move , node , ' invalid _ pos ' ) NEW_LINE DEDENT
def _multi_move_to_descendant ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 2' ) NEW_LINE target = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( InvalidMoveToDescendant , node . move , target , ' first - sibling ' ) NEW_LINE DEDENT
def _multi_move_missing_nodeorderby ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( MissingNodeOrderBy , node . move , node , ' sorted - child ' ) NEW_LINE self . assertRaises ( MissingNodeOrderBy , node . move , node , ' sorted - sibling ' ) NEW_LINE DEDENT
def _multi_nonsorted_move_in_sorted ( self ) : NEW_LINE INDENT node = self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . assertRaises ( InvalidPosition , node . move , node , ' left ' ) NEW_LINE DEDENT
def _multi_move_leaf_last_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 231' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_first_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 231' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_left_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 231' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_right_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_last_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_first_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 231' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_last_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_first_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 231' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_left_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_right_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_left_sibling_itself ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 231' ) , ' left ' ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT
def _multi_move_leaf_last_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_leaf_first_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_first_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_last_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_left_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_right_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_left_noleft_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) . get_first_sibling ( ) , ' left ' ) NEW_LINE expected = [ ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_right_noright_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) . get_last_sibling ( ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_first_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_last_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_first_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_last_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_left_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_right_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_left_noleft_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) . get_first_sibling ( ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_right_noright_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) . get_last_sibling ( ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_left_itself_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '4' ) , ' left ' ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT
def _multi_move_branch_first_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 4' , 3 , 1 ) , ( u ' 41' , 4 , 0 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_branch_last_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 231' , 3 , 0 ) , ( u ' 4' , 3 , 1 ) , ( u ' 41' , 4 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def got ( self ) : NEW_LINE INDENT return [ ( o . val1 , o . val2 , o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . sorted_model . get_tree ( ) ] NEW_LINE DEDENT
def _multi_add_root_sorted ( self ) : NEW_LINE INDENT self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE expected = [ ( 1 , 4 , u ' bcd ' , 1 , 0 ) , ( 2 , 2 , u ' qwe ' , 1 , 0 ) , ( 2 , 5 , u ' zxy ' , 1 , 0 ) , ( 3 , 2 , u ' vcx ' , 1 , 0 ) , ( 3 , 3 , u ' abc ' , 1 , 0 ) , ( 3 , 3 , u ' abc ' , 1 , 0 ) , ( 3 , 3 , u ' zxy ' , 1 , 0 ) , ( 4 , 1 , u ' fgh ' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_child_root_sorted ( self ) : NEW_LINE INDENT root = self . sorted_model . add_root ( val1 = 0 , val2 = 0 , desc = ' aaa ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE root . add_child ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE root . add_child ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE root . add_child ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE root . add_child ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE expected = [ ( 0 , 0 , u ' aaa ' , 1 , 8 ) , ( 1 , 4 , u ' bcd ' , 2 , 0 ) , ( 2 , 2 , u ' qwe ' , 2 , 0 ) , ( 2 , 5 , u ' zxy ' , 2 , 0 ) , ( 3 , 2 , u ' vcx ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' zxy ' , 2 , 0 ) , ( 4 , 1 , u ' fgh ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_add_child_nonroot_sorted ( self ) : NEW_LINE INDENT get_node = lambda node_id : self . sorted_model . objects . get ( pk = node_id ) NEW_LINE root_id = self . sorted_model . add_root ( val1 = 0 , val2 = 0 , desc = ' a ' ) . id NEW_LINE node_id = get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' ac ' ) . id NEW_LINE get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' aa ' ) NEW_LINE get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' av ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' aca ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' acc ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' acb ' ) NEW_LINE expected = [ ( 0 , 0 , u ' a ' , 1 , 3 ) , ( 0 , 0 , u ' aa ' , 2 , 0 ) , ( 0 , 0 , u ' ac ' , 2 , 3 ) , ( 0 , 0 , u ' aca ' , 3 , 0 ) , ( 0 , 0 , u ' acb ' , 3 , 0 ) , ( 0 , 0 , u ' acc ' , 3 , 0 ) , ( 0 , 0 , u ' av ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def _multi_move_sorted ( self ) : NEW_LINE INDENT self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE root_nodes = self . sorted_model . get_root_nodes ( ) NEW_LINE target = root_nodes [ 0 ] NEW_LINE for node in root_nodes [ 1 : ] : NEW_LINE # ▁ because ▁ raw ▁ queries ▁ don ' t ▁ update ▁ django ▁ objects ENDCOM INDENT node = self . sorted_model . objects . get ( pk = node . id ) NEW_LINE target = self . sorted_model . objects . get ( pk = target . id ) NEW_LINE node . move ( target , ' sorted - child ' ) NEW_LINE DEDENT expected = [ ( 1 , 4 , u ' bcd ' , 1 , 7 ) , ( 2 , 2 , u ' qwe ' , 2 , 0 ) , ( 2 , 5 , u ' zxy ' , 2 , 0 ) , ( 3 , 2 , u ' vcx ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' zxy ' , 2 , 0 ) , ( 4 , 1 , u ' fgh ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT for model in ( MP_TestNode , AL_TestNode , NS_TestNode ) : NEW_LINE INDENT model . load_bulk ( BASE_DATA ) NEW_LINE for node in model . get_root_nodes ( ) : NEW_LINE INDENT model . load_bulk ( BASE_DATA , node ) NEW_LINE DEDENT model . add_root ( desc = '5' ) NEW_LINE DEDENT DEDENT
def _multi_descendants_group_count_root ( self ) : NEW_LINE INDENT expected = [ ( o . desc , o . get_descendant_count ( ) ) for o in self . model . get_root_nodes ( ) ] NEW_LINE got = [ ( o . desc , o . descendants_count ) for o in self . model . get_descendants_group_count ( ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT
def _multi_descendants_group_count_node ( self ) : NEW_LINE INDENT parent = self . model . get_root_nodes ( ) . get ( desc = '2' ) NEW_LINE expected = [ ( o . desc , o . get_descendant_count ( ) ) for o in parent . get_children ( ) ] NEW_LINE got = [ ( o . desc , o . descendants_count ) for o in self . model . get_descendants_group_count ( parent ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT
def test_sorted_by_autonow_workaround ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ workaround STRNEWLINE ▁ """ NEW_LINE import datetime NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT MP_TestNodeSortedAutoNow . add_root ( desc = ' node % d ' % ( i , ) , created = datetime . datetime . now ( ) ) NEW_LINE DEDENT DEDENT
def test_sorted_by_autonow_FAIL ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ test ▁ asserts ▁ that ▁ we ▁ have ▁ a ▁ problem . STRNEWLINE ▁ fix ▁ this , ▁ somehow STRNEWLINE ▁ """ NEW_LINE MP_TestNodeSortedAutoNow . add_root ( desc = ' node1' ) NEW_LINE self . assertRaises ( ValueError , MP_TestNodeSortedAutoNow . add_root , desc = ' node2' ) NEW_LINE DEDENT
def test_add_root ( self ) : NEW_LINE INDENT method = MP_TestNodeSmallStep . add_root NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT method ( ) NEW_LINE DEDENT self . assertRaises ( PathOverflow , method ) NEW_LINE DEDENT
def test_add_child ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE method = root . add_child NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT method ( ) NEW_LINE DEDENT self . assertRaises ( PathOverflow , method ) NEW_LINE DEDENT
def test_add_sibling ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT root . add_child ( ) NEW_LINE DEDENT method = root . get_last_child ( ) . add_sibling NEW_LINE positions = ( ' first - sibling ' , ' left ' , ' right ' , ' last - sibling ' ) NEW_LINE for pos in positions : NEW_LINE INDENT self . assertRaises ( PathOverflow , method , pos ) NEW_LINE DEDENT DEDENT
def test_move ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT root . add_child ( ) NEW_LINE DEDENT newroot = MP_TestNodeSmallStep . add_root ( ) NEW_LINE targets = [ ( root , [ ' first - child ' , ' last - child ' ] ) , ( root . get_first_child ( ) , [ ' first - sibling ' , ' left ' , ' right ' , ' last - sibling ' ] ) ] NEW_LINE for target , positions in targets : NEW_LINE INDENT for pos in positions : NEW_LINE INDENT self . assertRaises ( PathOverflow , newroot . move , target , pos ) NEW_LINE DEDENT DEDENT DEDENT
def test_short_path ( self ) : NEW_LINE INDENT obj = MP_TestNodeShortPath . add_root ( ) NEW_LINE obj = obj . add_child ( ) . add_child ( ) . add_child ( ) NEW_LINE self . assertRaises ( PathOverflow , obj . add_child ) NEW_LINE DEDENT
def test_find_problems ( self ) : NEW_LINE INDENT model = MP_TestNodeAlphabet NEW_LINE model . alphabet = '01234' NEW_LINE model ( path = '01' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '1' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '111' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = ' abcd ' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = ' qa # $ % ! ' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0201' , depth = 2 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '020201' , depth = 3 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '03' , depth = 1 , numchild = 2 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0301' , depth = 2 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '030102' , depth = 3 , numchild = 10 , numval = 0 ) . save ( ) NEW_LINE model ( path = '04' , depth = 10 , numchild = 1 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0401' , depth = 20 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE evil_chars , bad_steplen , orphans , wrong_depth , wrong_numchild = model . find_problems ( ) NEW_LINE self . assertEqual ( [ ' abcd ' , ' qa # $ % ! ' ] , [ o . path for o in model . objects . filter ( id__in = evil_chars ) ] ) NEW_LINE self . assertEqual ( [ '1' , '111' ] , [ o . path for o in model . objects . filter ( id__in = bad_steplen ) ] ) NEW_LINE self . assertEqual ( [ '0201' , '020201' ] , [ o . path for o in model . objects . filter ( id__in = orphans ) ] ) NEW_LINE self . assertEqual ( [ '03' , '0301' , '030102' ] , [ o . path for o in model . objects . filter ( id__in = wrong_numchild ) ] ) NEW_LINE self . assertEqual ( [ '04' , '0401' ] , [ o . path for o in model . objects . filter ( id__in = wrong_depth ) ] ) NEW_LINE DEDENT
def setUp ( self ) : NEW_LINE INDENT super ( TestMP_TreeFix , self ) . setUp ( ) NEW_LINE self . expected_no_holes = { MP_TestNodeShortPath : [ ( u ' 1' , u ' b ' , 1 , 2 ) , ( u ' 11' , u ' u ' , 2 , 1 ) , ( u ' 111' , u ' i ' , 3 , 1 ) , ( u ' 1111' , u ' e ' , 4 , 0 ) , ( u ' 12' , u ' o ' , 2 , 0 ) , ( u ' 2' , u ' d ' , 1 , 0 ) , ( u ' 3' , u ' g ' , 1 , 0 ) , ( u ' 4' , u ' a ' , 1 , 4 ) , ( u ' 41' , u ' a ' , 2 , 0 ) , ( u ' 42' , u ' a ' , 2 , 0 ) , ( u ' 43' , u ' u ' , 2 , 1 ) , ( u ' 431' , u ' i ' , 3 , 1 ) , ( u ' 4311' , u ' e ' , 4 , 0 ) , ( u ' 44' , u ' o ' , 2 , 0 ) ] , MP_TestSortedNodeShortPath : [ ( u ' 1' , u ' a ' , 1 , 4 ) , ( u ' 11' , u ' a ' , 2 , 0 ) , ( u ' 12' , u ' a ' , 2 , 0 ) , ( u ' 13' , u ' o ' , 2 , 0 ) , ( u ' 14' , u ' u ' , 2 , 1 ) , ( u ' 141' , u ' i ' , 3 , 1 ) , ( u ' 1411' , u ' e ' , 4 , 0 ) , ( u ' 2' , u ' b ' , 1 , 2 ) , ( u ' 21' , u ' o ' , 2 , 0 ) , ( u ' 22' , u ' u ' , 2 , 1 ) , ( u ' 221' , u ' i ' , 3 , 1 ) , ( u ' 2211' , u ' e ' , 4 , 0 ) , ( u ' 3' , u ' d ' , 1 , 0 ) , ( u ' 4' , u ' g ' , 1 , 0 ) ] } NEW_LINE self . expected_with_holes = { MP_TestNodeShortPath : [ ( u ' 1' , u ' b ' , 1 L , 2 L ) , ( u ' 13' , u ' u ' , 2 L , 1 L ) , ( u ' 134' , u ' i ' , 3 L , 1 L ) , ( u ' 1343' , u ' e ' , 4 L , 0 L ) , ( u ' 14' , u ' o ' , 2 L , 0 L ) , ( u ' 2' , u ' d ' , 1 L , 0 L ) , ( u ' 3' , u ' g ' , 1 L , 0 L ) , ( u ' 4' , u ' a ' , 1 L , 4 L ) , ( u ' 41' , u ' a ' , 2 L , 0 L ) , ( u ' 42' , u ' a ' , 2 L , 0 L ) , ( u ' 43' , u ' u ' , 2 L , 1 L ) , ( u ' 434' , u ' i ' , 3 L , 1 L ) , ( u ' 4343' , u ' e ' , 4 L , 0 L ) , ( u ' 44' , u ' o ' , 2 L , 0 L ) ] , MP_TestSortedNodeShortPath : [ ( u ' 1' , u ' b ' , 1 L , 2 L ) , ( u ' 13' , u ' u ' , 2 L , 1 L ) , ( u ' 134' , u ' i ' , 3 L , 1 L ) , ( u ' 1343' , u ' e ' , 4 L , 0 L ) , ( u ' 14' , u ' o ' , 2 L , 0 L ) , ( u ' 2' , u ' d ' , 1 L , 0 L ) , ( u ' 3' , u ' g ' , 1 L , 0 L ) , ( u ' 4' , u ' a ' , 1 L , 4 L ) , ( u ' 41' , u ' a ' , 2 L , 0 L ) , ( u ' 42' , u ' a ' , 2 L , 0 L ) , ( u ' 43' , u ' u ' , 2 L , 1 L ) , ( u ' 434' , u ' i ' , 3 L , 1 L ) , ( u ' 4343' , u ' e ' , 4 L , 0 L ) , ( u ' 44' , u ' o ' , 2 L , 0 L ) ] } NEW_LINE DEDENT
def got ( self , model ) : NEW_LINE INDENT return [ ( o . path , o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in model . get_tree ( ) ] NEW_LINE DEDENT
def add_broken_test_data ( self , model ) : NEW_LINE INDENT model ( path = '4' , depth = 2 , numchild = 2 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '13' , depth = 1000 , numchild = 0 , desc = ' u ' ) . save ( ) NEW_LINE model ( path = '14' , depth = 4 , numchild = 500 , desc = ' o ' ) . save ( ) NEW_LINE model ( path = '134' , depth = 321 , numchild = 543 , desc = ' i ' ) . save ( ) NEW_LINE model ( path = '1343' , depth = 321 , numchild = 543 , desc = ' e ' ) . save ( ) NEW_LINE model ( path = '42' , depth = 1 , numchild = 1 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '43' , depth = 1000 , numchild = 0 , desc = ' u ' ) . save ( ) NEW_LINE model ( path = '44' , depth = 4 , numchild = 500 , desc = ' o ' ) . save ( ) NEW_LINE model ( path = '434' , depth = 321 , numchild = 543 , desc = ' i ' ) . save ( ) NEW_LINE model ( path = '4343' , depth = 321 , numchild = 543 , desc = ' e ' ) . save ( ) NEW_LINE model ( path = '41' , depth = 1 , numchild = 1 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '3' , depth = 221 , numchild = 322 , desc = ' g ' ) . save ( ) NEW_LINE model ( path = '1' , depth = 10 , numchild = 3 , desc = ' b ' ) . save ( ) NEW_LINE model ( path = '2' , depth = 10 , numchild = 3 , desc = ' d ' ) . save ( ) NEW_LINE DEDENT
def test_fix_tree_non_destructive ( self ) : NEW_LINE INDENT for model in ( MP_TestNodeShortPath , MP_TestSortedNodeShortPath ) : NEW_LINE INDENT self . add_broken_test_data ( model ) NEW_LINE model . fix_tree ( destructive = False ) NEW_LINE self . assertEqual ( self . got ( model ) , self . expected_with_holes [ model ] ) NEW_LINE model . find_problems ( ) NEW_LINE DEDENT DEDENT
def test_fix_tree_destructive ( self ) : NEW_LINE INDENT for model in ( MP_TestNodeShortPath , MP_TestSortedNodeShortPath ) : NEW_LINE INDENT self . add_broken_test_data ( model ) NEW_LINE model . fix_tree ( destructive = True ) NEW_LINE self . assertEqual ( self . got ( model ) , self . expected_no_holes [ model ] ) NEW_LINE model . find_problems ( ) NEW_LINE DEDENT DEDENT
def test_many_to_many_django_user_anonymous ( self ) : NEW_LINE INDENT if not HAS_DJANGO_AUTH : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT self . fail ( ' this ▁ test ▁ needs ▁ django . contrib . auth ▁ in ▁ INSTALLED _ APPS ' ) NEW_LINE # ▁ Using ▁ AnonymousUser ( ) ▁ in ▁ the ▁ querysets ▁ will ▁ expose ▁ non - treebeard ENDCOM # ▁ related ▁ problems ▁ in ▁ Django ▁ 1.0 ENDCOM # ▁ Postgres : ENDCOM # ▁ ProgrammingError : ▁ can ' t ▁ adapt ENDCOM # ▁ SQLite : ENDCOM # ▁ InterfaceError : ▁ Error ▁ binding ▁ parameter ▁ 4 ▁ - ▁ probably ▁ unsupported ENDCOM # ▁ type . ENDCOM # ▁ MySQL ▁ compared ▁ a ▁ string ▁ to ▁ an ▁ integer ▁ field : ENDCOM # ▁ ` treebeard _ mp _ testissue14 _ users ` . ` user _ id ` ▁ = ▁ ' AnonymousUser ' ENDCOM # ▁ Using ▁ a ▁ None ▁ field ▁ instead ▁ works ▁ ( will ▁ be ▁ translated ▁ to ▁ IS ▁ NULL ) . ENDCOM # ▁ anonuserobj ▁ = ▁ AnonymousUser ( ) ENDCOM DEDENT anonuserobj = None NEW_LINE def qs_check ( qs , expected ) : NEW_LINE INDENT self . assertEqual ( [ o . name for o in qs ] , expected ) NEW_LINE DEDENT user = User . objects . create_user ( ' test _ user ' , ' test @ example . com ' , ' testpasswd ' ) NEW_LINE user . save ( ) NEW_LINE root = MP_TestIssue14 . add_root ( name = " the ▁ root ▁ node " ) NEW_LINE root . add_child ( name = " first " ) NEW_LINE second = root . add_child ( name = " second " ) NEW_LINE qs_check ( root . get_children ( ) , [ ' first ' , ' second ' ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) ) , [ ' first ' ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( users = user ) ) , [ ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' ] ) NEW_LINE user = anonuserobj NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' , ' second ' ] ) NEW_LINE user = User . objects . get ( username = " test _ user " ) NEW_LINE second . users . add ( user ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' , ' second ' ] ) NEW_LINE user = anonuserobj NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' ] ) NEW_LINE DEDENT
def _multi_form_html_root_node ( self ) : NEW_LINE INDENT self . model . load_bulk ( BASE_DATA ) NEW_LINE node = self . model . get_tree ( ) [ 0 ] NEW_LINE form = MoveNodeForm ( instance = node ) NEW_LINE rtpl = self . tpl NEW_LINE self . assertEqual ( [ ' _ position ' , ' _ ref _ node _ id ' ] , form . base_fields . keys ( ) ) NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT if node != obj or obj . is_descendant_of ( node ) : NEW_LINE INDENT rtpl += ' < option ▁ value = " % d " > % sNode ▁ % d < / option > \n ' % ( obj . id , ' . ▁ . ▁ ' * ( obj . get_depth ( ) - 1 ) , obj . id ) NEW_LINE DEDENT DEDENT rtpl += ' < / select > < / td > < / tr > ' NEW_LINE formstr = unicode ( form ) . replace ( u ' ▁ selected = " selected " ' , u ' ' ) NEW_LINE self . assertEqual ( rtpl , formstr ) NEW_LINE DEDENT
def _multi_form_html_leaf_node ( self ) : NEW_LINE INDENT self . model . load_bulk ( BASE_DATA ) NEW_LINE nodes = list ( self . model . get_tree ( ) ) NEW_LINE node = nodes [ - 1 ] NEW_LINE form = MoveNodeForm ( instance = node ) NEW_LINE rtpl = self . tpl NEW_LINE self . assertEqual ( [ ' _ position ' , ' _ ref _ node _ id ' ] , form . base_fields . keys ( ) ) NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT if node != obj or obj . is_descendant_of ( node ) : NEW_LINE INDENT rtpl += ' < option ▁ value = " % d " > % sNode ▁ % d < / option > \n ' % ( obj . id , ' . ▁ . ▁ ' * ( obj . get_depth ( ) - 1 ) , obj . id ) NEW_LINE DEDENT DEDENT rtpl += ' < / select > < / td > < / tr > ' NEW_LINE formstr = unicode ( form ) . replace ( u ' ▁ selected = " selected " ' , u ' ' ) NEW_LINE self . assertEqual ( rtpl , formstr ) NEW_LINE DEDENT
def _multi_admin_html ( self ) : NEW_LINE INDENT tpl = ( ' < tr > < th > < label ▁ for = " id _ desc " > Desc : < / label > ' ' < / th > < td > < input ▁ id = " id _ desc " ▁ type = " text " ▁ class = " vTextField " ▁ ' ' name = " desc " ▁ maxlength = " 255 " ▁ / > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ position " > Position : < / label > < / th > ' ' < td > < select ▁ name = " _ position " ▁ id = " id _ _ position " > \n ' ' < option ▁ value = " first - child " > First ▁ child ▁ of < / option > \n ' ' < option ▁ value = " left " > Before < / option > \n ' ' < option ▁ value = " right " > After < / option > \n ' ' < / select > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ ref _ node _ id " > Relative ▁ to : < / label > ' ' < / th > < td > < select ▁ name = " _ ref _ node _ id " ▁ id = " id _ _ ref _ node _ id " > \n ' ' < option ▁ value = " 0 " > - - ▁ root ▁ - - < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < / select > < / td > < / tr > ' ) NEW_LINE request = None NEW_LINE self . model . load_bulk ( BASE_DATA ) NEW_LINE for node in self . model . objects . all ( ) : NEW_LINE INDENT site = AdminSite ( ) NEW_LINE ma = TestModelAdmin ( self . model , site ) NEW_LINE self . assertEqual ( [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] , ma . get_form ( request ) . base_fields . keys ( ) ) NEW_LINE self . assertEqual ( [ ( None , { ' fields ' : [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] } ) ] , ma . get_fieldsets ( request ) ) NEW_LINE self . assertEqual ( [ ( None , { ' fields ' : [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] } ) ] , ma . get_fieldsets ( request , node ) ) NEW_LINE form = ma . get_form ( request ) ( ) NEW_LINE ids = [ ] NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT ids . extend ( [ obj . id ] * 2 ) NEW_LINE DEDENT self . assertEqual ( tpl % tuple ( ids ) , unicode ( form ) ) NEW_LINE DEDENT DEDENT
