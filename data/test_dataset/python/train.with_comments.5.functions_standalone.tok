def setUp ( ) : NEW_LINE INDENT import socket NEW_LINE socket . setdefaulttimeout ( 5 ) NEW_LINE DEDENT
def compare_rules_change ( old_list , new_list , purge_list ) : NEW_LINE INDENT old_list = old_list or [ ] NEW_LINE new_list = new_list or [ ] NEW_LINE changed = False NEW_LINE for old_rule in old_list : NEW_LINE INDENT matched = next ( ( x for x in new_list if x [ ' name ' ] == old_rule [ ' name ' ] ) , [ ] ) NEW_LINE if matched : # ▁ if ▁ the ▁ new ▁ one ▁ is ▁ in ▁ the ▁ old ▁ list , ▁ check ▁ whether ▁ it ▁ is ▁ updated ENDCOM NEW_LINE INDENT changed = changed or compare_rules ( old_rule , matched ) NEW_LINE DEDENT elif not purge_list : # ▁ keep ▁ this ▁ rule ENDCOM NEW_LINE INDENT new_list . append ( old_rule ) NEW_LINE DEDENT else : # ▁ one ▁ rule ▁ is ▁ removed ENDCOM NEW_LINE INDENT changed = True NEW_LINE # ▁ Compare ▁ new ▁ list ▁ and ▁ old ▁ list ▁ is ▁ the ▁ same ? ▁ here ▁ only ▁ compare ▁ names ENDCOM DEDENT DEDENT if not changed : NEW_LINE INDENT new_names = [ to_native ( x [ ' name ' ] ) for x in new_list ] NEW_LINE old_names = [ to_native ( x [ ' name ' ] ) for x in old_list ] NEW_LINE changed = ( set ( new_names ) != set ( old_names ) ) NEW_LINE DEDENT return changed , new_list NEW_LINE DEDENT
def compare_rules ( old_rule , rule ) : NEW_LINE INDENT changed = False NEW_LINE if old_rule [ ' name ' ] != rule [ ' name ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule . get ( ' description ' , None ) != old_rule [ ' description ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' protocol ' ] != old_rule [ ' protocol ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' source _ port _ range ' ] ) != str ( old_rule [ ' source _ port _ range ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' destination _ port _ range ' ] ) != str ( old_rule [ ' destination _ port _ range ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' access ' ] != old_rule [ ' access ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' priority ' ] != old_rule [ ' priority ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if rule [ ' direction ' ] != old_rule [ ' direction ' ] : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' source _ address _ prefix ' ] ) != str ( old_rule [ ' source _ address _ prefix ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if str ( rule [ ' destination _ address _ prefix ' ] ) != str ( old_rule [ ' destination _ address _ prefix ' ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' source _ address _ prefixes ' ) or [ ] ) != set ( old_rule . get ( ' source _ address _ prefixes ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' destination _ address _ prefixes ' ) or [ ] ) != set ( old_rule . get ( ' destination _ address _ prefixes ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' source _ port _ ranges ' ) or [ ] ) != set ( old_rule . get ( ' source _ port _ ranges ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT if set ( rule . get ( ' destination _ port _ ranges ' ) or [ ] ) != set ( old_rule . get ( ' destination _ port _ ranges ' ) or [ ] ) : NEW_LINE INDENT changed = True NEW_LINE DEDENT return changed NEW_LINE DEDENT
def create_rule_dict_from_obj ( rule ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Create ▁ a ▁ dict ▁ from ▁ an ▁ instance ▁ of ▁ a ▁ SecurityRule . STRNEWLINE STRNEWLINE ▁ : param ▁ rule : ▁ SecurityRule STRNEWLINE ▁ : return : ▁ dict STRNEWLINE ▁ ''' NEW_LINE return dict ( id = rule . id , name = rule . name , description = rule . description , protocol = rule . protocol , source_port_range = rule . source_port_range , destination_port_range = rule . destination_port_range , source_address_prefix = rule . source_address_prefix , destination_address_prefix = rule . destination_address_prefix , source_port_ranges = rule . source_port_ranges , destination_port_ranges = rule . destination_port_ranges , source_address_prefixes = rule . source_address_prefixes , destination_address_prefixes = rule . destination_address_prefixes , access = rule . access , priority = rule . priority , direction = rule . direction , provisioning_state = rule . provisioning_state , etag = rule . etag ) NEW_LINE DEDENT
def create_network_security_group_dict ( nsg ) : NEW_LINE INDENT results = dict ( id = nsg . id , name = nsg . name , type = nsg . type , location = nsg . location , tags = nsg . tags , ) NEW_LINE results [ ' rules ' ] = [ ] NEW_LINE if nsg . security_rules : NEW_LINE INDENT for rule in nsg . security_rules : NEW_LINE INDENT results [ ' rules ' ] . append ( create_rule_dict_from_obj ( rule ) ) NEW_LINE DEDENT DEDENT results [ ' default _ rules ' ] = [ ] NEW_LINE if nsg . default_security_rules : NEW_LINE INDENT for rule in nsg . default_security_rules : NEW_LINE INDENT results [ ' default _ rules ' ] . append ( create_rule_dict_from_obj ( rule ) ) NEW_LINE DEDENT DEDENT results [ ' network _ interfaces ' ] = [ ] NEW_LINE if nsg . network_interfaces : NEW_LINE INDENT for interface in nsg . network_interfaces : NEW_LINE INDENT results [ ' network _ interfaces ' ] . append ( interface . id ) NEW_LINE DEDENT DEDENT results [ ' subnets ' ] = [ ] NEW_LINE if nsg . subnets : NEW_LINE INDENT for subnet in nsg . subnets : NEW_LINE INDENT results [ ' subnets ' ] . append ( subnet . id ) NEW_LINE DEDENT DEDENT return results NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT AzureRMSecurityGroup ( ) NEW_LINE DEDENT
def test_explicit_instance_paths ( modules_tmpdir ) : NEW_LINE INDENT with pytest . raises ( ValueError ) as excinfo : NEW_LINE INDENT flask . Flask ( __name__ , instance_path = ' instance ' ) NEW_LINE DEDENT assert ' must ▁ be ▁ absolute ' in str ( excinfo . value ) NEW_LINE app = flask . Flask ( __name__ , instance_path = str ( modules_tmpdir ) ) NEW_LINE assert app . instance_path == str ( modules_tmpdir ) NEW_LINE DEDENT
def test_main_module_paths ( modules_tmpdir , purge_module ) : NEW_LINE INDENT app = modules_tmpdir . join ( ' main _ app . py ' ) NEW_LINE app . write ( ' import ▁ flask \n \n app ▁ = ▁ flask . Flask ( " _ _ main _ _ " ) ' ) NEW_LINE purge_module ( ' main _ app ' ) NEW_LINE from main_app import app NEW_LINE here = os . path . abspath ( os . getcwd ( ) ) NEW_LINE assert app . instance_path == os . path . join ( here , ' instance ' ) NEW_LINE DEDENT
def test_uninstalled_module_paths ( modules_tmpdir , purge_module ) : NEW_LINE INDENT app = modules_tmpdir . join ( ' config _ module _ app . py ' ) . write ( ' import ▁ os \n ' ' import ▁ flask \n ' ' here ▁ = ▁ os . path . abspath ( os . path . dirname ( _ _ file _ _ ) ) \n ' ' app ▁ = ▁ flask . Flask ( _ _ name _ _ ) \n ' ) NEW_LINE purge_module ( ' config _ module _ app ' ) NEW_LINE from config_module_app import app NEW_LINE assert app . instance_path == str ( modules_tmpdir . join ( ' instance ' ) ) NEW_LINE DEDENT
def test_uninstalled_package_paths ( modules_tmpdir , purge_module ) : NEW_LINE INDENT app = modules_tmpdir . mkdir ( ' config _ package _ app ' ) NEW_LINE init = app . join ( ' _ _ init _ _ . py ' ) NEW_LINE init . write ( ' import ▁ os \n ' ' import ▁ flask \n ' ' here ▁ = ▁ os . path . abspath ( os . path . dirname ( _ _ file _ _ ) ) \n ' ' app ▁ = ▁ flask . Flask ( _ _ name _ _ ) \n ' ) NEW_LINE purge_module ( ' config _ package _ app ' ) NEW_LINE from config_package_app import app NEW_LINE assert app . instance_path == str ( modules_tmpdir . join ( ' instance ' ) ) NEW_LINE DEDENT
def test_installed_module_paths ( modules_tmpdir , modules_tmpdir_prefix , purge_module , site_packages , limit_loader ) : NEW_LINE INDENT site_packages . join ( ' site _ app . py ' ) . write ( ' import ▁ flask \n ' ' app ▁ = ▁ flask . Flask ( _ _ name _ _ ) \n ' ) NEW_LINE purge_module ( ' site _ app ' ) NEW_LINE from site_app import app NEW_LINE assert app . instance_path == modules_tmpdir . join ( ' var ' ) . join ( ' site _ app - instance ' ) NEW_LINE DEDENT
def test_installed_package_paths ( limit_loader , modules_tmpdir , modules_tmpdir_prefix , purge_module , monkeypatch ) : NEW_LINE INDENT installed_path = modules_tmpdir . mkdir ( ' path ' ) NEW_LINE monkeypatch . syspath_prepend ( installed_path ) NEW_LINE app = installed_path . mkdir ( ' installed _ package ' ) NEW_LINE init = app . join ( ' _ _ init _ _ . py ' ) NEW_LINE init . write ( ' import ▁ flask \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE purge_module ( ' installed _ package ' ) NEW_LINE from installed_package import app NEW_LINE assert app . instance_path == modules_tmpdir . join ( ' var ' ) . join ( ' installed _ package - instance ' ) NEW_LINE DEDENT
def test_prefix_package_paths ( limit_loader , modules_tmpdir , modules_tmpdir_prefix , purge_module , site_packages ) : NEW_LINE INDENT app = site_packages . mkdir ( ' site _ package ' ) NEW_LINE init = app . join ( ' _ _ init _ _ . py ' ) NEW_LINE init . write ( ' import ▁ flask \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE purge_module ( ' site _ package ' ) NEW_LINE import site_package NEW_LINE assert site_package . app . instance_path == modules_tmpdir . join ( ' var ' ) . join ( ' site _ package - instance ' ) NEW_LINE DEDENT
def test_egg_installed_paths ( install_egg , modules_tmpdir , modules_tmpdir_prefix ) : NEW_LINE INDENT modules_tmpdir . mkdir ( ' site _ egg ' ) . join ( ' _ _ init _ _ . py ' ) . write ( ' import ▁ flask \n \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE install_egg ( ' site _ egg ' ) NEW_LINE try : NEW_LINE INDENT import site_egg NEW_LINE assert site_egg . app . instance_path == str ( modules_tmpdir . join ( ' var / ' ) . join ( ' site _ egg - instance ' ) ) NEW_LINE DEDENT finally : NEW_LINE INDENT if ' site _ egg ' in sys . modules : NEW_LINE INDENT del sys . modules [ ' site _ egg ' ] NEW_LINE DEDENT DEDENT DEDENT
def test_meta_path_loader_without_is_package ( request , modules_tmpdir ) : NEW_LINE INDENT app = modules_tmpdir . join ( ' unimportable . py ' ) NEW_LINE app . write ( ' import ▁ flask \n app ▁ = ▁ flask . Flask ( _ _ name _ _ ) ' ) NEW_LINE class Loader ( object ) : NEW_LINE INDENT def find_module ( self , name , path = None ) : NEW_LINE INDENT return self NEW_LINE DEDENT DEDENT sys . meta_path . append ( Loader ( ) ) NEW_LINE request . addfinalizer ( sys . meta_path . pop ) NEW_LINE with pytest . raises ( AttributeError ) : NEW_LINE INDENT import unimportable NEW_LINE DEDENT DEDENT
def syscalls__sys_enter_futex ( event , ctxt , cpu , s , ns , tid , comm , nr , uaddr , op , val , utime , uaddr2 , val3 ) : NEW_LINE INDENT cmd = op & FUTEX_CMD_MASK NEW_LINE if cmd != FUTEX_WAIT : NEW_LINE INDENT return # ▁ we ▁ don ' t ▁ care ▁ about ▁ originators ▁ of ▁ WAKE ▁ events ENDCOM NEW_LINE DEDENT process_names [ tid ] = comm NEW_LINE thread_thislock [ tid ] = uaddr NEW_LINE thread_blocktime [ tid ] = nsecs ( s , ns ) NEW_LINE DEDENT
def syscalls__sys_exit_futex ( event , ctxt , cpu , s , ns , tid , comm , nr , ret ) : NEW_LINE INDENT if thread_blocktime . has_key ( tid ) : NEW_LINE INDENT elapsed = nsecs ( s , ns ) - thread_blocktime [ tid ] NEW_LINE add_stats ( lock_waits , ( tid , thread_thislock [ tid ] ) , elapsed ) NEW_LINE del thread_blocktime [ tid ] NEW_LINE del thread_thislock [ tid ] NEW_LINE DEDENT DEDENT
def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : NEW_LINE INDENT """ Set ▁ up ▁ the ▁ HomematicIP ▁ Cloud ▁ weather ▁ sensor . """ NEW_LINE pass NEW_LINE DEDENT
def async_setup_entry ( hass : HomeAssistant , config_entry : ConfigEntry , async_add_entities ) -> None : NEW_LINE INDENT """ Set ▁ up ▁ the ▁ HomematicIP ▁ weather ▁ sensor ▁ from ▁ a ▁ config ▁ entry . """ NEW_LINE home = hass . data [ HMIPC_DOMAIN ] [ config_entry . data [ HMIPC_HAPID ] ] . home NEW_LINE devices = [ ] NEW_LINE for device in home . devices : NEW_LINE INDENT if isinstance ( device , AsyncWeatherSensorPro ) : NEW_LINE INDENT devices . append ( HomematicipWeatherSensorPro ( home , device ) ) NEW_LINE DEDENT elif isinstance ( device , ( AsyncWeatherSensor , AsyncWeatherSensorPlus ) ) : NEW_LINE INDENT devices . append ( HomematicipWeatherSensor ( home , device ) ) NEW_LINE DEDENT DEDENT if devices : NEW_LINE INDENT async_add_entities ( devices ) NEW_LINE DEDENT DEDENT
def aligned ( left , right , length = 59 ) : NEW_LINE INDENT while len ( left ) < length : NEW_LINE INDENT left += " ▁ " NEW_LINE DEDENT return left + right NEW_LINE DEDENT
def capitalize_first ( string ) : NEW_LINE INDENT return string [ : 1 ] . upper ( ) + string [ 1 : ] NEW_LINE DEDENT
def parse_object ( block ) : NEW_LINE # ▁ expected ▁ format : ▁ [ managed ] ▁ object ▁ < name > ▁ [ extends ▁ < name > ] ENDCOM INDENT header_items = block [ 0 ] [ 1 ] . split ( ) NEW_LINE managed = False NEW_LINE if header_items [ 0 ] == " managed " : NEW_LINE INDENT managed = True NEW_LINE del header_items [ 0 ] NEW_LINE DEDENT if len ( header_items ) < 2 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT assert header_items [ 0 ] == " object " NEW_LINE name = header_items [ 1 ] NEW_LINE extends = None NEW_LINE if len ( header_items ) > 2 : NEW_LINE INDENT if header_items [ 2 ] != " extends " : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT else : NEW_LINE INDENT extends = header_items [ 3 ] NEW_LINE DEDENT DEDENT properties = [ ] NEW_LINE for line in block [ 1 : ] : NEW_LINE # ▁ expected ▁ format : ▁ < type > ▁ < name > ▁ < occurrence > ENDCOM INDENT items = line [ 1 ] . split ( ) NEW_LINE if len ( items ) != 3 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ property " % line [ 0 ] ) NEW_LINE DEDENT if items [ 2 ] not in valid_occurrences : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ occurrence " % line [ 0 ] ) NEW_LINE DEDENT properties . append ( Property ( type = items [ 0 ] , name = items [ 1 ] , occurrence = items [ 2 ] ) ) NEW_LINE DEDENT if managed : NEW_LINE INDENT return ManagedObject ( name = name , extends = extends , properties = properties ) NEW_LINE DEDENT else : NEW_LINE INDENT return Object ( name = name , extends = extends , properties = properties ) NEW_LINE DEDENT DEDENT
def parse_enum ( block ) : NEW_LINE # ▁ expected ▁ format : ▁ enum ▁ < name > ENDCOM INDENT header_items = block [ 0 ] [ 1 ] . split ( ) NEW_LINE if len ( header_items ) < 2 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT assert header_items [ 0 ] == " enum " NEW_LINE name = header_items [ 1 ] NEW_LINE values = [ ] NEW_LINE for line in block [ 1 : ] : NEW_LINE # ▁ expected ▁ format : ▁ < value > ENDCOM INDENT values . append ( line [ 1 ] ) NEW_LINE DEDENT return Enum ( name = name , values = values ) NEW_LINE DEDENT
def parse_method ( block ) : NEW_LINE # ▁ expected ▁ format : ▁ method ▁ < name > ▁ [ returns ▁ < type > ▁ < occurrence > ] ENDCOM INDENT header_items = block [ 0 ] [ 1 ] . split ( ) NEW_LINE if len ( header_items ) < 2 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT assert header_items [ 0 ] == " method " NEW_LINE name = header_items [ 1 ] NEW_LINE returns = None NEW_LINE if len ( header_items ) > 2 : NEW_LINE INDENT if header_items [ 2 ] != " returns " : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ block ▁ header " % ( number ) ) NEW_LINE DEDENT else : NEW_LINE INDENT returns = Parameter ( type = header_items [ 3 ] , name = " output " , occurrence = header_items [ 4 ] ) NEW_LINE DEDENT DEDENT parameters = [ ] NEW_LINE for line in block [ 1 : ] : NEW_LINE # ▁ expected ▁ format : ▁ < type > ▁ < name > ▁ < occurrence > ENDCOM INDENT items = line [ 1 ] . split ( ) NEW_LINE if len ( items ) != 3 : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ property " % line [ 0 ] ) NEW_LINE DEDENT if items [ 2 ] not in valid_occurrences : NEW_LINE INDENT report_error ( " line ▁ % d : ▁ invalid ▁ occurrence " % line [ 0 ] ) NEW_LINE DEDENT parameters . append ( Parameter ( type = items [ 0 ] , name = items [ 1 ] , occurrence = items [ 2 ] ) ) NEW_LINE DEDENT return Method ( name = name , parameters = parameters , returns = returns ) NEW_LINE DEDENT
def is_known_type ( type ) : NEW_LINE INDENT return type in predefined_objects or type in predefined_enums or type in objects_by_name or type in managed_objects_by_name or type in enums_by_name NEW_LINE DEDENT
def propagate_feature ( obj , feature ) : NEW_LINE INDENT global features_have_changed NEW_LINE if not ( obj . features & feature ) : NEW_LINE INDENT return NEW_LINE DEDENT for property in obj . properties : NEW_LINE INDENT if property . occurrence == OCCURRENCE__IGNORED or not property . is_type_generated ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT if property . is_enum ( ) : NEW_LINE INDENT if feature == Object . FEATURE__SERIALIZE and not ( enums_by_name [ property . type ] . features & Enum . FEATURE__SERIALIZE ) : NEW_LINE INDENT enums_by_name [ property . type ] . features |= Enum . FEATURE__SERIALIZE NEW_LINE features_have_changed = True NEW_LINE DEDENT elif feature == Object . FEATURE__DESERIALIZE and not ( enums_by_name [ property . type ] . features & Enum . FEATURE__DESERIALIZE ) : NEW_LINE INDENT enums_by_name [ property . type ] . features |= Enum . FEATURE__DESERIALIZE NEW_LINE features_have_changed = True NEW_LINE DEDENT DEDENT elif property . is_object ( ) : NEW_LINE INDENT if not ( objects_by_name [ property . type ] . features & feature ) : NEW_LINE INDENT objects_by_name [ property . type ] . features |= feature NEW_LINE features_have_changed = True NEW_LINE DEDENT if obj . name != property . type : NEW_LINE INDENT propagate_feature ( objects_by_name [ property . type ] , feature ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def inherit_features ( obj ) : NEW_LINE INDENT global features_have_changed NEW_LINE if obj . extended_by is not None : NEW_LINE INDENT for extended_by in obj . extended_by : NEW_LINE INDENT previous = objects_by_name [ extended_by ] . features NEW_LINE objects_by_name [ extended_by ] . features |= obj . features NEW_LINE if objects_by_name [ extended_by ] . features != previous : NEW_LINE INDENT features_have_changed = True NEW_LINE DEDENT DEDENT DEDENT if obj . extends is not None : NEW_LINE INDENT previous = objects_by_name [ obj . extends ] . features NEW_LINE objects_by_name [ obj . extends ] . features |= obj . features NEW_LINE if objects_by_name [ obj . extends ] . features != previous : NEW_LINE INDENT features_have_changed = True NEW_LINE DEDENT DEDENT if obj . extended_by is not None : NEW_LINE INDENT for extended_by in obj . extended_by : NEW_LINE INDENT inherit_features ( objects_by_name [ extended_by ] ) NEW_LINE # ▁ there ▁ are ▁ two ▁ directions ▁ to ▁ spread ▁ features : ENDCOM # ▁ 1 ) ▁ up ▁ and ▁ down ▁ the ▁ inheritance ▁ chain ENDCOM # ▁ 2 ) ▁ from ▁ object ▁ types ▁ to ▁ their ▁ member ▁ property ▁ types ENDCOM # ▁ spreading ▁ needs ▁ to ▁ be ▁ done ▁ alternating ▁ on ▁ both ▁ directions ▁ because ▁ they ▁ can ENDCOM # ▁ affect ▁ each ▁ other ENDCOM DEDENT DEDENT DEDENT
def setup_php ( program_path ) : NEW_LINE INDENT global php_path NEW_LINE for p in possible_php_paths : NEW_LINE INDENT p = p . replace ( ' PROGRAM _ PATH ' , program_path ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT php_path = p NEW_LINE return NEW_LINE DEDENT DEDENT raise Exception ( " No ▁ php ▁ binary ▁ found ▁ - ▁ not ▁ even ▁ fake _ php . py ▁ ( program _ path = % s ) ▁ ! " % program_path ) NEW_LINE DEDENT
def serve ( bind = ' localhost ' , port = 8000 , handler = PHPHTTPRequestHandler ) : NEW_LINE INDENT httpd = BaseHTTPServer . HTTPServer ( ( bind , port ) , handler ) NEW_LINE httpd . serve_forever ( ) NEW_LINE DEDENT
