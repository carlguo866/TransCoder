<DOCUMENT_ID="hobson/pyexiv2/tree/master/test/usercomment.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2010 ▁ Olivier ▁ Tilloy ▁ < olivier @ tilloy . net > ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ the ▁ pyexiv2 ▁ distribution . ENDCOM # ▁ pyexiv2 ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ENDCOM # ▁ modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 ENDCOM # ▁ of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ pyexiv2 ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ pyexiv2 ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software ENDCOM # ▁ Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ 5th ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 ▁ USA . ENDCOM # ▁ Author : ▁ Olivier ▁ Tilloy ▁ < olivier @ tilloy . net > ENDCOM from pyexiv2 . metadata import ImageMetadata NEW_LINE import unittest NEW_LINE import testutils NEW_LINE import os NEW_LINE import tempfile NEW_LINE from testutils import EMPTY_JPG_DATA NEW_LINE class TestUserCommentReadWrite ( unittest . TestCase ) : NEW_LINE INDENT checksums = { ' usercomment - ascii . jpg ' : ' ad29ac65fb6f63c8361aaed6cb02f8c7' , ' usercomment - unicode - ii . jpg ' : '13b7cc09129a8677f2cf18634f5abd3c ' , ' usercomment - unicode - mm . jpg ' : '7addfed7823c556ba489cd4ab2037200' , } NEW_LINE def _read_image ( self , filename ) : NEW_LINE INDENT filepath = testutils . get_absolute_file_path ( os . path . join ( ' data ' , filename ) ) NEW_LINE self . assert_ ( testutils . CheckFileSum ( filepath , self . checksums [ filename ] ) ) NEW_LINE m = ImageMetadata ( filepath ) NEW_LINE m . read ( ) NEW_LINE return m NEW_LINE DEDENT def _expected_raw_value ( self , endianness , value ) : NEW_LINE INDENT from pyexiv2 import __exiv2_version__ NEW_LINE if __exiv2_version__ >= '0.20' : NEW_LINE INDENT return value NEW_LINE DEDENT else : NEW_LINE INDENT encodings = { ' ii ' : ' utf - 16le ' , ' mm ' : ' utf - 16be ' } NEW_LINE return value . decode ( ' utf - 8' ) . encode ( encodings [ endianness ] ) NEW_LINE DEDENT DEDENT def test_read_ascii ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - ascii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Ascii " ▁ deja ▁ vu ' ) NEW_LINE self . assertEqual ( tag . value , u ' deja ▁ vu ' ) NEW_LINE DEDENT def test_read_unicode_little_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - ii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' ii ' , ' déjà ▁ vu ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' déjà ▁ vu ' ) NEW_LINE DEDENT def test_read_unicode_big_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - mm . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' mm ' , ' déjà ▁ vu ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' déjà ▁ vu ' ) NEW_LINE DEDENT def test_write_ascii ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - ascii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = ' foo ▁ bar ' NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Ascii " ▁ foo ▁ bar ' ) NEW_LINE self . assertEqual ( tag . value , u ' foo ▁ bar ' ) NEW_LINE DEDENT def test_write_unicode_over_ascii ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - ascii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = u ' déjà ▁ vu ' NEW_LINE self . assertEqual ( tag . raw_value , ' déjà ▁ vu ' ) NEW_LINE self . assertEqual ( tag . value , u ' déjà ▁ vu ' ) NEW_LINE DEDENT def test_write_unicode_little_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - ii . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = u ' DÉJÀ ▁ VU ' NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' ii ' , ' DÉJÀ ▁ VU ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' DÉJÀ ▁ VU ' ) NEW_LINE DEDENT def test_write_unicode_big_endian ( self ) : NEW_LINE INDENT m = self . _read_image ( ' usercomment - unicode - mm . jpg ' ) NEW_LINE tag = m [ ' Exif . Photo . UserComment ' ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE tag . value = u ' DÉJÀ ▁ VU ' NEW_LINE self . assertEqual ( tag . raw_value , ' charset = " Unicode " ▁ % s ' % self . _expected_raw_value ( ' mm ' , ' DÉJÀ ▁ VU ' ) ) NEW_LINE self . assertEqual ( tag . value , u ' DÉJÀ ▁ VU ' ) NEW_LINE DEDENT DEDENT class TestUserCommentAdd ( unittest . TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE # ▁ Create ▁ an ▁ empty ▁ image ▁ file ENDCOM INDENT fd , self . pathname = tempfile . mkstemp ( suffix = ' . jpg ' ) NEW_LINE os . write ( fd , EMPTY_JPG_DATA ) NEW_LINE os . close ( fd ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT os . remove ( self . pathname ) NEW_LINE DEDENT def _test_add_comment ( self , value ) : NEW_LINE INDENT metadata = ImageMetadata ( self . pathname ) NEW_LINE metadata . read ( ) NEW_LINE key = ' Exif . Photo . UserComment ' NEW_LINE metadata [ key ] = value NEW_LINE metadata . write ( ) NEW_LINE metadata = ImageMetadata ( self . pathname ) NEW_LINE metadata . read ( ) NEW_LINE self . assert_ ( key in metadata . exif_keys ) NEW_LINE tag = metadata [ key ] NEW_LINE self . assertEqual ( tag . type , ' Comment ' ) NEW_LINE self . assertEqual ( tag . value , value ) NEW_LINE DEDENT def test_add_comment_ascii ( self ) : NEW_LINE INDENT self . _test_add_comment ( ' deja ▁ vu ' ) NEW_LINE DEDENT def test_add_comment_unicode ( self ) : NEW_LINE INDENT self . _test_add_comment ( u ' déjà ▁ vu ' ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="nischalsheth/contrail-controller/tree/master/src/vnsw/provisioning/contrail_vrouter_provisioning/network.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2013 ▁ Juniper ▁ Networks , ▁ Inc . ▁ All ▁ rights ▁ reserved . ENDCOM import os NEW_LINE import re NEW_LINE import glob NEW_LINE import struct NEW_LINE import socket NEW_LINE import logging NEW_LINE import netifaces NEW_LINE from contrail_vrouter_provisioning import local NEW_LINE log = logging . getLogger ( ' contrail _ vrouter _ provisioning . network ' ) NEW_LINE class ComputeNetworkSetup ( object ) : NEW_LINE INDENT def find_gateway ( self , dev ) : NEW_LINE INDENT gateway = ' ' NEW_LINE cmd = " sudo ▁ netstat ▁ - rn ▁ | ▁ sudo ▁ grep ▁ ^ \ " 0.0.0.0\ " ▁ | ▁ " NEW_LINE cmd += " sudo ▁ head ▁ - n ▁ 1 ▁ | ▁ sudo ▁ grep ▁ % s ▁ | ▁ sudo ▁ awk ▁ ' { ▁ print ▁ $ 2 ▁ } ' " % dev NEW_LINE gateway = local ( cmd , capture = True ) . strip ( ) NEW_LINE return gateway NEW_LINE # ▁ end ▁ find _ gateway ENDCOM DEDENT def get_dns_servers ( self , dev ) : NEW_LINE INDENT cmd = " sudo ▁ grep ▁ \ " ^ nameserver\\ > \ " ▁ / etc / resolv . conf ▁ | ▁ " NEW_LINE cmd += " sudo ▁ awk ▁ ▁ ' { print ▁ $ 2 } ' " NEW_LINE dns_list = local ( cmd , capture = True ) NEW_LINE return dns_list . split ( ) NEW_LINE # ▁ end ▁ get _ dns _ servers ENDCOM DEDENT def get_domain_search_list ( self ) : NEW_LINE INDENT domain_list = ' ' NEW_LINE cmd = " sudo ▁ grep ▁ ^ \ " search\ " ▁ / etc / resolv . conf ▁ | ▁ " NEW_LINE cmd += " sudo ▁ awk ▁ ' { $ 1 = \ " \ " ; print ▁ $ 0 } ' " NEW_LINE domain_list = local ( cmd , capture = True ) . strip ( ) NEW_LINE if not domain_list : NEW_LINE INDENT cmd = " sudo ▁ grep ▁ ^ \ " domain\ " ▁ / etc / resolv . conf ▁ | ▁ " NEW_LINE cmd += " sudo ▁ awk ▁ ' { $ 1 = \ " \ " ; ▁ print ▁ $ 0 } ' " NEW_LINE domain_list = local ( cmd , capture = True ) . strip ( ) NEW_LINE DEDENT return domain_list NEW_LINE DEDENT def get_if_mtu ( self , dev ) : NEW_LINE INDENT cmd = " sudo ▁ ifconfig ▁ % s ▁ | ▁ sudo ▁ grep ▁ mtu ▁ | ▁ sudo ▁ awk ▁ ' { ▁ print ▁ $ NF ▁ } ' " % dev NEW_LINE mtu = local ( cmd , capture = True ) . strip ( ) NEW_LINE if not mtu : NEW_LINE # ▁ for ▁ debian ENDCOM INDENT cmd = r " sudo ▁ ifconfig ▁ % s ▁ | ▁ sudo ▁ grep ▁ MTU ▁ | ▁ " % dev NEW_LINE cmd += r " sudo ▁ sed ▁ ' s / . * MTU . \ ( [0-9 ] \ + \ ) . * / \1 / g ' " NEW_LINE mtu = local ( cmd , capture = True ) . strip ( ) NEW_LINE DEDENT if ( mtu and mtu != '1500' ) : NEW_LINE INDENT return mtu NEW_LINE DEDENT return ' ' NEW_LINE # ▁ end ▁ if _ mtu ENDCOM DEDENT def get_device_by_ip ( self , ip ) : NEW_LINE INDENT for i in netifaces . interfaces ( ) : NEW_LINE INDENT try : NEW_LINE INDENT if i == ' pkt1' : NEW_LINE INDENT continue NEW_LINE DEDENT if netifaces . AF_INET in netifaces . ifaddresses ( i ) : NEW_LINE INDENT interfaces = netifaces . ifaddresses ( i ) [ netifaces . AF_INET ] NEW_LINE for interface in interfaces : NEW_LINE INDENT if ip == interface [ ' addr ' ] : NEW_LINE INDENT if i == ' vhost0' : NEW_LINE INDENT log . info ( " vhost0 ▁ is ▁ already ▁ present ! " ) NEW_LINE DEDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT except ValueError : NEW_LINE INDENT log . info ( " Skipping ▁ interface ▁ % s " , i ) NEW_LINE DEDENT DEDENT raise RuntimeError ( ' % s ▁ not ▁ configured , ▁ rerun ▁ w / ▁ - - physical _ interface ' % ip ) NEW_LINE # ▁ end ▁ get _ device _ by _ ip ENDCOM DEDENT def get_device_info ( self , ip ) : NEW_LINE INDENT reprov = False NEW_LINE cfg_file = " / etc / contrail / contrail - vrouter - agent . conf " NEW_LINE try : NEW_LINE INDENT dev = self . get_device_by_ip ( ip ) NEW_LINE if dev == " vhost0" : NEW_LINE INDENT dev = self . get_config ( cfg_file , " VIRTUAL - HOST - INTERFACE " , " physical _ interface " ) NEW_LINE log . info ( " Re - provision . ▁ vhost0 ▁ present " ) NEW_LINE reprov = True NEW_LINE DEDENT else : NEW_LINE INDENT log . info ( " Fresh ▁ Install . ▁ vhost0 ▁ not ▁ present " ) NEW_LINE DEDENT DEDENT except RuntimeError : NEW_LINE INDENT dev = self . get_config ( cfg_file , " VIRTUAL - HOST - INTERFACE " , " physical _ interface " ) NEW_LINE if not dev . succeeded : NEW_LINE INDENT raise NEW_LINE DEDENT log . info ( " vhost0 ▁ not ▁ present , ▁ vrouter ▁ not ▁ running " ) NEW_LINE reprov = True NEW_LINE DEDENT return ( dev . strip ( ) , reprov ) NEW_LINE # ▁ end ▁ get _ device _ info ENDCOM DEDENT def get_secondary_device ( self , primary ) : NEW_LINE INDENT for i in netifaces . interfaces ( ) : NEW_LINE INDENT try : NEW_LINE INDENT if i == ' pkt1' : NEW_LINE INDENT continue NEW_LINE DEDENT if i == primary : NEW_LINE INDENT continue NEW_LINE DEDENT if i == ' vhost0' : NEW_LINE INDENT continue NEW_LINE DEDENT if netifaces . AF_INET not in netifaces . ifaddresses ( i ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT except ValueError : NEW_LINE INDENT log . info ( " Skipping ▁ interface ▁ % s " % i ) NEW_LINE DEDENT DEDENT raise RuntimeError ( ' Secondary ▁ interace ▁ ▁ not ▁ configured , ' , ' rerun ▁ w / ▁ - - physical _ interface ' ) NEW_LINE # ▁ end ▁ get _ secondary _ device ENDCOM DEDENT def get_if_mac ( self , dev ) : NEW_LINE INDENT iface_addr = netifaces . ifaddresses ( dev ) NEW_LINE link_info = iface_addr [ netifaces . AF_LINK ] NEW_LINE mac_addr = link_info [ 0 ] [ ' addr ' ] NEW_LINE return mac_addr NEW_LINE # ▁ end ▁ get _ if _ mac ENDCOM DEDENT @ staticmethod NEW_LINE def is_interface_vlan ( interface ) : NEW_LINE INDENT iface = local ( " sudo ▁ ip ▁ link ▁ show ▁ % s ▁ | ▁ head ▁ - 1" % interface + " | ▁ cut ▁ - f2 ▁ - d ' : ' ▁ | ▁ grep ▁ ' @ ' " , capture = True , warn_only = True ) NEW_LINE if iface . succeeded : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT @ staticmethod NEW_LINE def get_physical_interface_of_vlan ( interface ) : NEW_LINE INDENT iface = local ( " sudo ▁ ip ▁ link ▁ show ▁ % s ▁ | ▁ head ▁ - 1 ▁ | ▁ cut ▁ - f2 ▁ - d ' : ' " % interface + " | ▁ cut ▁ - f2 ▁ - d ' @ ' " , capture = True ) NEW_LINE return iface NEW_LINE DEDENT def _rewrite_ifcfg_file ( self , filename , dev , prsv_cfg ) : NEW_LINE INDENT bond = False NEW_LINE mac = ' ' NEW_LINE temp_dir_name = self . _temp_dir_name NEW_LINE vlan = False NEW_LINE if os . path . isfile ( ' / proc / net / vlan / % s ' % dev ) : NEW_LINE INDENT vlan_info = open ( ' / proc / net / vlan / config ' ) . readlines ( ) NEW_LINE match = re . search ( ' ^ % s . * \ | \s + ( \S + ) $ ' % dev , " \n " . join ( vlan_info ) , flags = re . M | re . I ) NEW_LINE if not match : NEW_LINE INDENT raise RuntimeError ( " Configured ▁ vlan ▁ % s ▁ is ▁ not ▁ found ▁ in " , " / proc / net / vlan / config " % dev ) NEW_LINE DEDENT vlan = True NEW_LINE DEDENT if os . path . isdir ( ' / sys / class / net / % s / bonding ' % dev ) : NEW_LINE INDENT bond = True NEW_LINE # ▁ end ▁ if ▁ os . path . isdir . . . ENDCOM DEDENT mac = netifaces . ifaddresses ( dev ) [ netifaces . AF_LINK ] [ 0 ] [ ' addr ' ] NEW_LINE ifcfg_file = ' / etc / sysconfig / network - scripts / ifcfg - % s ' % dev NEW_LINE if not os . path . isfile ( ifcfg_file ) : NEW_LINE INDENT ifcfg_file = temp_dir_name + ' ifcfg - ' + dev NEW_LINE with open ( ifcfg_file , ' w ' ) as f : NEW_LINE INDENT f . write ( ''' # Contrail ▁ % s STRNEWLINE TYPE = Ethernet STRNEWLINE ONBOOT = yes STRNEWLINE DEVICE = " % s " STRNEWLINE USERCTL = yes STRNEWLINE NM _ CONTROLLED = no STRNEWLINE HWADDR = % s STRNEWLINE ''' % ( dev , dev , mac ) ) NEW_LINE for dcfg in prsv_cfg : NEW_LINE INDENT f . write ( dcfg + ' \n ' ) NEW_LINE DEDENT if vlan : NEW_LINE INDENT f . write ( ' VLAN = yes \n ' ) NEW_LINE DEDENT DEDENT DEDENT fd = open ( ifcfg_file ) NEW_LINE f_lines = fd . readlines ( ) NEW_LINE fd . close ( ) NEW_LINE local ( " sudo ▁ rm ▁ - f ▁ % s " % ifcfg_file ) NEW_LINE new_f_lines = [ ] NEW_LINE remove_items = [ ' IPADDR ' , ' NETMASK ' , ' PREFIX ' , ' GATEWAY ' , ' HWADDR ' , ' DNS1' , ' DNS2' , ' BOOTPROTO ' , ' NM _ CONTROLLED ' , ' # Contrail ' ] NEW_LINE remove_items . append ( ' DEVICE ' ) NEW_LINE new_f_lines . append ( ' # Contrail ▁ % s \n ' % dev ) NEW_LINE new_f_lines . append ( ' DEVICE = % s \n ' % dev ) NEW_LINE for line in f_lines : NEW_LINE INDENT found = False NEW_LINE for text in remove_items : NEW_LINE INDENT if text in line : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT if not found : NEW_LINE INDENT new_f_lines . append ( line ) NEW_LINE DEDENT DEDENT new_f_lines . append ( ' NM _ CONTROLLED = no \n ' ) NEW_LINE if bond : NEW_LINE INDENT new_f_lines . append ( ' SUBCHANNELS = 1,2,3 \n ' ) NEW_LINE DEDENT elif not vlan : NEW_LINE INDENT new_f_lines . append ( ' HWADDR = % s \n ' % mac ) NEW_LINE DEDENT fdw = open ( filename , ' w ' ) NEW_LINE fdw . writelines ( new_f_lines ) NEW_LINE fdw . close ( ) NEW_LINE DEDENT def migrate_routes ( self , device ) : NEW_LINE INDENT ''' STRNEWLINE ▁ add ▁ route ▁ entries ▁ in ▁ / proc / net / route STRNEWLINE ▁ ''' NEW_LINE temp_dir_name = self . _temp_dir_name NEW_LINE cfg_file = ' / etc / sysconfig / network - scripts / route - vhost0' NEW_LINE tmp_file = ' % s / route - vhost0' % temp_dir_name NEW_LINE with open ( tmp_file , ' w ' ) as route_cfg_file : NEW_LINE INDENT for route in open ( ' / proc / net / route ' , ' r ' ) . readlines ( ) : NEW_LINE INDENT if route . startswith ( device ) : NEW_LINE INDENT route_fields = route . split ( ) NEW_LINE destination = int ( route_fields [ 1 ] , 16 ) NEW_LINE gateway = int ( route_fields [ 2 ] , 16 ) NEW_LINE flags = int ( route_fields [ 3 ] , 16 ) NEW_LINE mask = int ( route_fields [ 7 ] , 16 ) NEW_LINE if flags & 0x2 : NEW_LINE INDENT if destination != 0 : NEW_LINE INDENT route_cfg_file . write ( socket . inet_ntoa ( struct . pack ( ' I ' , destination ) ) ) NEW_LINE route_cfg_file . write ( ' / ' + str ( bin ( mask ) . count ( '1' ) ) + ' ▁ ' ) NEW_LINE route_cfg_file . write ( ' via ▁ ' ) NEW_LINE route_cfg_file . write ( socket . inet_ntoa ( struct . pack ( ' I ' , gateway ) ) + ' ▁ ' ) NEW_LINE route_cfg_file . write ( ' dev ▁ vhost0' ) NEW_LINE # ▁ end ▁ if ▁ detination . . . ENDCOM # ▁ end ▁ if ▁ flags ▁ & . . . ENDCOM # ▁ end ▁ if ▁ route . startswith . . . ENDCOM # ▁ end ▁ for ▁ route . . . ENDCOM # ▁ end ▁ with ▁ open . . . ENDCOM DEDENT DEDENT DEDENT DEDENT DEDENT local ( " sudo ▁ mv ▁ - f ▁ % s ▁ % s " % ( tmp_file , cfg_file ) ) NEW_LINE # ▁ delete ▁ the ▁ route - dev ▁ file ENDCOM if os . path . isfile ( ' / etc / sysconfig / network - scripts / route - % s ' % device ) : NEW_LINE INDENT os . unlink ( ' / etc / sysconfig / network - scripts / route - % s ' % device ) NEW_LINE # ▁ end ▁ def ▁ migrate _ routes ENDCOM DEDENT DEDENT def get_cfgfile_for_dev ( self , iface , cfg_files ) : NEW_LINE INDENT if not cfg_files : NEW_LINE INDENT return None NEW_LINE DEDENT mapped_intf_cfgfile = None NEW_LINE for file in cfg_files : NEW_LINE INDENT with open ( file , ' r ' ) as fd : NEW_LINE INDENT contents = fd . read ( ) NEW_LINE regex = ' ( ? : ^ | \n ) \s * iface\s + % s\s + ' % iface NEW_LINE if re . search ( regex , contents ) : NEW_LINE INDENT mapped_intf_cfgfile = file NEW_LINE DEDENT DEDENT DEDENT return mapped_intf_cfgfile NEW_LINE DEDENT def get_sourced_files ( self ) : NEW_LINE INDENT ''' Get ▁ all ▁ sourced ▁ config ▁ files ''' NEW_LINE files = self . get_valid_files ( self . get_source_entries ( ) ) NEW_LINE files += self . get_source_directory_files ( ) NEW_LINE return list ( set ( files ) ) NEW_LINE DEDENT def get_source_directory_files ( self ) : NEW_LINE INDENT ''' Get ▁ source - directory ▁ entry ▁ and ▁ make ▁ list ▁ of ▁ valid ▁ files ''' NEW_LINE regex = ' ( ? : ^ | \n ) \s * source - directory\s + ( \S + ) ' NEW_LINE files = list ( ) NEW_LINE with open ( self . default_cfg_file , ' r ' ) as fd : NEW_LINE INDENT entries = re . findall ( regex , fd . read ( ) ) NEW_LINE DEDENT dirs = [ d for d in self . get_valid_files ( entries ) if os . path . isdir ( d ) ] NEW_LINE for dir in dirs : NEW_LINE INDENT files . extend ( [ os . path . join ( dir , f ) for f in os . listdir ( dir ) if os . path . isfile ( os . path . join ( dir , f ) ) and re . match ( ' ^ [ a - zA - Z0-9 _ - ] + $ ' , f ) ] ) NEW_LINE DEDENT return files NEW_LINE DEDENT def get_source_entries ( self ) : NEW_LINE INDENT ''' STRNEWLINE ▁ Get ▁ entries ▁ matching ▁ source ▁ keyword ▁ from STRNEWLINE ▁ / etc / network / interfaces ▁ file . STRNEWLINE ▁ ''' NEW_LINE regex = ' ( ? : ^ | \n ) \s * source\s + ( \S + ) ' NEW_LINE with open ( self . default_cfg_file , ' r ' ) as fd : NEW_LINE INDENT return re . findall ( regex , fd . read ( ) ) NEW_LINE DEDENT DEDENT def get_valid_files ( self , entries ) : NEW_LINE INDENT ''' Provided ▁ a ▁ list ▁ of ▁ glob ' d ▁ strings , ▁ return ▁ matching ▁ file ▁ names ''' NEW_LINE files = list ( ) NEW_LINE prepend = os . path . join ( os . path . sep , ' etc ' , ' network ' ) + os . path . sep NEW_LINE for entry in entries : NEW_LINE INDENT entry = entry . lstrip ( ' . / ' ) if entry . startswith ( ' . / ' ) else entry NEW_LINE if entry . startswith ( os . path . sep ) : NEW_LINE INDENT entry = entry NEW_LINE DEDENT else : NEW_LINE INDENT entry = prepend + entry NEW_LINE DEDENT files . extend ( glob . glob ( entry ) ) NEW_LINE DEDENT return files NEW_LINE DEDENT def _rewrite_net_interfaces_file ( self , dev , mac , vhost_ip , netmask , gateway_ip , esxi_vm , vmpg_mtu , datapg_mtu ) : NEW_LINE INDENT self . default_cfg_file = ' / etc / network / interfaces ' NEW_LINE cfg_files = self . get_sourced_files ( ) NEW_LINE cfg_files . append ( self . default_cfg_file ) NEW_LINE intf_cfgfile = self . get_cfgfile_for_dev ( ' vhost0' , cfg_files ) NEW_LINE if intf_cfgfile : NEW_LINE INDENT log . info ( " Interface ▁ vhost0 ▁ is ▁ already ▁ present ▁ in " + " / etc / network / interfaces " ) NEW_LINE log . info ( " Skipping ▁ rewrite ▁ of ▁ this ▁ file " ) NEW_LINE return NEW_LINE # ▁ endif ENDCOM DEDENT vlan = False NEW_LINE if os . path . isfile ( ' / proc / net / vlan / % s ' % dev ) : NEW_LINE INDENT vlan_info = open ( ' / proc / net / vlan / config ' ) . readlines ( ) NEW_LINE match = re . search ( ' ^ % s . * \ | \s + ( \S + ) $ ' % dev , " \n " . join ( vlan_info ) , flags = re . M | re . I ) NEW_LINE if not match : NEW_LINE INDENT raise RuntimeError ( ' Configured ▁ vlan ▁ % s ▁ is ▁ not ▁ found ▁ in ' , ' / proc / net / vlan / config ' % dev ) NEW_LINE DEDENT phydev = match . group ( 1 ) NEW_LINE vlan = True NEW_LINE # ▁ Replace ▁ strings ▁ matching ▁ dev ▁ to ▁ vhost0 ▁ in ▁ ifup ▁ and ▁ ifdown ▁ parts ▁ file ENDCOM # ▁ Any ▁ changes ▁ to ▁ the ▁ file / logic ▁ with ▁ static ▁ routes ▁ has ▁ to ▁ be ENDCOM # ▁ reflected ▁ in ▁ setup - vnc - static - routes . py ▁ too ENDCOM DEDENT ifup_parts_file = os . path . join ( os . path . sep , ' etc ' , ' network ' , ' if - up . d ' , ' routes ' ) NEW_LINE ifdown_parts_file = os . path . join ( os . path . sep , ' etc ' , ' network ' , ' if - down . d ' , ' routes ' ) NEW_LINE if ( os . path . isfile ( ifup_parts_file ) and os . path . isfile ( ifdown_parts_file ) ) : NEW_LINE INDENT local ( " sudo ▁ sed ▁ - i ▁ ' s / % s / vhost0 / g ' ▁ % s " % ( dev , ifup_parts_file ) , warn_only = True ) NEW_LINE local ( " sudo ▁ sed ▁ - i ▁ ' s / % s / vhost0 / g ' ▁ % s " % ( dev , ifdown_parts_file ) , warn_only = True ) NEW_LINE DEDENT dev_cfgfile = self . get_cfgfile_for_dev ( dev , cfg_files ) NEW_LINE temp_intf_file = ' % s / interfaces ' % self . _temp_dir_name NEW_LINE local ( " sudo ▁ cp ▁ % s ▁ % s " % ( dev_cfgfile , temp_intf_file ) ) NEW_LINE with open ( dev_cfgfile , ' r ' ) as fd : NEW_LINE INDENT cfg_file = fd . read ( ) NEW_LINE DEDENT if not self . _args . non_mgmt_ip : NEW_LINE # ▁ remove ▁ entry ▁ from ▁ auto ▁ < dev > ▁ to ▁ auto ▁ excluding ▁ these ▁ pattern ENDCOM # ▁ then ▁ delete ▁ specifically ▁ auto ▁ < dev > ENDCOM INDENT local ( " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / , / auto / { / auto / ! d } ' ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / d ' ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE # ▁ add ▁ manual ▁ entry ▁ for ▁ dev ENDCOM local ( " sudo ▁ echo ▁ ' auto ▁ % s ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' iface ▁ % s ▁ inet ▁ manual ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE if vlan : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - up ▁ ifconfig ▁ % s ▁ up ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - down ▁ ifconfig ▁ % s ▁ down ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE DEDENT else : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - down ▁ ifconfig ▁ % s ▁ down ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE DEDENT if esxi_vm : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( dev , datapg_mtu , temp_intf_file ) ) NEW_LINE cmd = " sudo ▁ ethtool ▁ - i ▁ % s ▁ | ▁ grep ▁ driver ▁ | ▁ cut ▁ - f ▁ 2 ▁ - d ▁ ' ▁ ' " % dev NEW_LINE device_driver = local ( cmd , capture = True ) NEW_LINE if ( device_driver == " vmxnet3" ) : NEW_LINE INDENT cmd = " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ethtool ▁ - - offload ▁ " NEW_LINE rx_cmd = ( cmd + " % s ▁ rx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE tx_cmd = ( cmd + " % s ▁ tx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) ) NEW_LINE local ( rx_cmd ) NEW_LINE local ( tx_cmd ) NEW_LINE DEDENT DEDENT if vlan : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ vlan - raw - device ▁ % s ' ▁ > > ▁ % s " % ( phydev , temp_intf_file ) ) NEW_LINE DEDENT if ' bond ' in dev . lower ( ) : NEW_LINE INDENT iters = re . finditer ( ' ^ \s * auto\s ' , cfg_file , re . M ) NEW_LINE indices = [ pat_match . start ( ) for pat_match in iters ] NEW_LINE matches = map ( cfg_file . __getslice__ , indices , indices [ 1 : ] + [ len ( cfg_file ) ] ) NEW_LINE for each in matches : NEW_LINE INDENT each = each . strip ( ) NEW_LINE if re . match ( ' ^ auto\s + % s ' % dev , each ) : NEW_LINE INDENT string = ' ' NEW_LINE for lines in each . splitlines ( ) : NEW_LINE INDENT if ' bond - ' in lines : NEW_LINE INDENT string += lines + os . linesep NEW_LINE DEDENT DEDENT local ( " sudo ▁ echo ▁ ' % s ' ▁ > > ▁ % s " % ( string , temp_intf_file ) ) NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT local ( " sudo ▁ echo ▁ ' ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE DEDENT else : NEW_LINE # ▁ remove ▁ ip ▁ address ▁ and ▁ gateway ENDCOM INDENT local ( " sudo ▁ sed ▁ - i ▁ ' / iface ▁ % s ▁ inet ▁ static / , ▁ + 2d ' ▁ % s " % ( dev , temp_intf_file ) , warn_only = True ) NEW_LINE if esxi_vm : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( dev , datapg_mtu , temp_intf_file ) , warn_only = True ) NEW_LINE cmd = " sudo ▁ ethtool ▁ - i ▁ % s ▁ | ▁ " % dev NEW_LINE cmd += " sudo ▁ grep ▁ driver ▁ | ▁ sudo ▁ cut ▁ - f ▁ 2 ▁ - d ▁ ' ▁ ' " NEW_LINE device_driver = local ( cmd , capture = True , warn_only = True ) NEW_LINE if ( device_driver == " vmxnet3" ) : NEW_LINE INDENT cmd = " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ethtool ▁ - - offload ▁ " NEW_LINE rx_cmd = cmd + " % s ▁ rx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) NEW_LINE tx_cmd = cmd + " % s ▁ tx ▁ off ' ▁ > > ▁ % s " % ( dev , temp_intf_file ) NEW_LINE local ( rx_cmd , warn_only = True ) NEW_LINE local ( tx_cmd , warn_only = True ) NEW_LINE DEDENT DEDENT if vlan : NEW_LINE INDENT cmd = " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / ▁ a\iface ▁ % s ▁ inet ▁ manual\ \n ▁ ▁ ▁ ▁ " % ( dev , dev ) NEW_LINE cmd += " post - up ▁ ifconfig ▁ % s ▁ up\ \n ▁ ▁ ▁ ▁ " % dev NEW_LINE cmd += " pre - down ▁ ifconfig ▁ % s ▁ down\ ' ▁ % s " % ( dev , temp_intf_file ) NEW_LINE local ( cmd ) NEW_LINE DEDENT else : NEW_LINE INDENT cmd = " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / ▁ a\iface ▁ % s ▁ inet ▁ manual\ \n ▁ ▁ ▁ ▁ " % ( dev , dev ) NEW_LINE cmd += " pre - up ▁ ifconfig ▁ % s ▁ up\ \n ▁ ▁ ▁ ▁ " % dev NEW_LINE cmd += " post - down ▁ ifconfig ▁ % s ▁ down\ ' ▁ % s " % ( dev , temp_intf_file ) NEW_LINE local ( cmd ) NEW_LINE DEDENT DEDENT if esxi_vm and vmpg_mtu : NEW_LINE INDENT intf = self . get_secondary_device ( self . dev ) NEW_LINE mac_addr = self . get_if_mac ( intf ) NEW_LINE udev_net_file = ' / etc / udev / rules . d / 70 - persistent - net . rules ' NEW_LINE temp_udev_net_file = ' % s / 70 - persistent - net . rules ' % ( self . _temp_dir_name ) NEW_LINE local ( " sudo ▁ touch ▁ % s " % temp_udev_net_file ) NEW_LINE local ( " sudo ▁ cp ▁ % s ▁ % s " % ( udev_net_file , temp_udev_net_file ) ) NEW_LINE cmd = " sudo ▁ echo ▁ ' SUBSYSTEM = = \ " net\ " , ▁ ACTION = = \ " add\ " , " NEW_LINE cmd += " ▁ DRIVERS = = \ " ? * \ " , " NEW_LINE cmd += " ▁ ATTR { address } = = \ " % s\ " , ▁ ATTR { dev _ id } = = \ " 0x0\ " , ▁ " % mac_addr NEW_LINE cmd += " ATTR { type } = = \ " 1\ " , ▁ KERNEL = = \ " eth * \ " , ▁ NAME = \ " % s\ " ' ▁ > > ▁ % s " % ( intf , temp_udev_net_file ) NEW_LINE local ( cmd ) NEW_LINE local ( " sudo ▁ mv ▁ - f ▁ % s ▁ % s " % ( temp_udev_net_file , udev_net_file ) ) NEW_LINE local ( " sudo ▁ sed ▁ - i ▁ ' / auto ▁ % s / , / down / d ' ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' \n auto ▁ % s ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' iface ▁ % s ▁ inet ▁ manual ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ifconfig ▁ % s ▁ up ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( intf , vmpg_mtu , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - down ▁ ifconfig ▁ % s ▁ down ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ ethtool ▁ - - offload ▁ % s ▁ lro ▁ off ' ▁ > > ▁ % s " % ( intf , temp_intf_file ) ) NEW_LINE # ▁ populte ▁ vhost0 ▁ as ▁ static ENDCOM DEDENT local ( " sudo ▁ echo ▁ ' ' ▁ > > ▁ % s " % ( temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' auto ▁ vhost0 ' ▁ > > ▁ % s " % ( temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' iface ▁ vhost0 ▁ inet ▁ static ' ▁ > > ▁ % s " % ( temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ pre - up ▁ % s / if - vhost0 ' ▁ > > ▁ % s " % ( self . contrail_bin_dir , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ netmask ▁ % s ' ▁ > > ▁ % s " % ( netmask , temp_intf_file ) ) NEW_LINE local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ network _ name ▁ application ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE if esxi_vm and datapg_mtu : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ mtu ▁ % s ' ▁ > > ▁ % s " % ( datapg_mtu , temp_intf_file ) ) NEW_LINE DEDENT if vhost_ip : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ address ▁ % s ' ▁ > > ▁ % s " % ( vhost_ip , temp_intf_file ) ) NEW_LINE DEDENT if ( not self . _args . non_mgmt_ip ) and gateway_ip : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ gateway ▁ % s ' ▁ > > ▁ % s " % ( gateway_ip , temp_intf_file ) ) NEW_LINE DEDENT domain = self . get_domain_search_list ( ) NEW_LINE if domain : NEW_LINE INDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ dns - search ▁ % s ' ▁ > > ▁ % s " % ( domain , temp_intf_file ) ) NEW_LINE DEDENT dns_list = self . get_dns_servers ( dev ) NEW_LINE if dns_list : NEW_LINE INDENT local ( " sudo ▁ echo ▁ - n ▁ ' ▁ ▁ ▁ ▁ dns - nameservers ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE for dns in dns_list : NEW_LINE INDENT local ( " sudo ▁ echo ▁ - n ▁ ' ▁ % s ' ▁ > > ▁ % s " % ( dns , temp_intf_file ) ) NEW_LINE DEDENT local ( " sudo ▁ echo ▁ ' ' ▁ > > ▁ % s " % temp_intf_file ) NEW_LINE DEDENT local ( " sudo ▁ echo ▁ ' ▁ ▁ ▁ ▁ post - up ▁ ip ▁ link ▁ set ▁ vhost0 ▁ address ▁ % s ' ▁ > > ▁ % s " % ( mac , temp_intf_file ) ) NEW_LINE # ▁ move ▁ it ▁ to ▁ right ▁ place ENDCOM local ( " sudo ▁ mv ▁ - f ▁ % s ▁ % s " % ( temp_intf_file , dev_cfgfile ) ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="dentaku65/plugin.video.italyalacarta/tree/master/lib/gdata/tlslite/utils/PyCrypto_RSAKey.py"> """ PyCrypto ▁ RSA ▁ implementation . """ NEW_LINE from cryptomath import * NEW_LINE from RSAKey import * NEW_LINE from Python_RSAKey import Python_RSAKey NEW_LINE if pycryptoLoaded : NEW_LINE INDENT from Crypto . PublicKey import RSA NEW_LINE class PyCrypto_RSAKey ( RSAKey ) : NEW_LINE INDENT def __init__ ( self , n = 0 , e = 0 , d = 0 , p = 0 , q = 0 , dP = 0 , dQ = 0 , qInv = 0 ) : NEW_LINE INDENT if not d : NEW_LINE INDENT self . rsa = RSA . construct ( ( n , e ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . rsa = RSA . construct ( ( n , e , d , p , q ) ) NEW_LINE DEDENT DEDENT def __getattr__ ( self , name ) : NEW_LINE INDENT return getattr ( self . rsa , name ) NEW_LINE DEDENT def hasPrivateKey ( self ) : NEW_LINE INDENT return self . rsa . has_private ( ) NEW_LINE DEDENT def hash ( self ) : NEW_LINE INDENT return Python_RSAKey ( self . n , self . e ) . hash ( ) NEW_LINE DEDENT def _rawPrivateKeyOp ( self , m ) : NEW_LINE INDENT s = numberToString ( m ) NEW_LINE byteLength = numBytes ( self . n ) NEW_LINE if len ( s ) == byteLength : NEW_LINE INDENT pass NEW_LINE DEDENT elif len ( s ) == byteLength - 1 : NEW_LINE INDENT s = ' \0' + s NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT c = stringToNumber ( self . rsa . decrypt ( ( s , ) ) ) NEW_LINE return c NEW_LINE DEDENT def _rawPublicKeyOp ( self , c ) : NEW_LINE INDENT s = numberToString ( c ) NEW_LINE byteLength = numBytes ( self . n ) NEW_LINE if len ( s ) == byteLength : NEW_LINE INDENT pass NEW_LINE DEDENT elif len ( s ) == byteLength - 1 : NEW_LINE INDENT s = ' \0' + s NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT m = stringToNumber ( self . rsa . encrypt ( s , None ) [ 0 ] ) NEW_LINE return m NEW_LINE DEDENT def writeXMLPublicKey ( self , indent = ' ' ) : NEW_LINE INDENT return Python_RSAKey ( self . n , self . e ) . write ( indent ) NEW_LINE DEDENT def generate ( bits ) : NEW_LINE INDENT key = PyCrypto_RSAKey ( ) NEW_LINE def f ( numBytes ) : NEW_LINE INDENT return bytesToString ( getRandomBytes ( numBytes ) ) NEW_LINE DEDENT key . rsa = RSA . generate ( bits , f ) NEW_LINE return key NEW_LINE DEDENT generate = staticmethod ( generate ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="2014cdbg14/2014cdbg14/tree/master/wsgi/static/Brython2.1.0-20140419-113919/Lib/collections/abc.py"> # ▁ Copyright ▁ 2007 ▁ Google , ▁ Inc . ▁ All ▁ Rights ▁ Reserved . ENDCOM # ▁ Licensed ▁ to ▁ PSF ▁ under ▁ a ▁ Contributor ▁ Agreement . ENDCOM """ Abstract ▁ Base ▁ Classes ▁ ( ABCs ) ▁ for ▁ collections , ▁ according ▁ to ▁ PEP ▁ 3119 . STRNEWLINE STRNEWLINE Unit ▁ tests ▁ are ▁ in ▁ test _ collections . STRNEWLINE """ NEW_LINE from abc import ABCMeta , abstractmethod NEW_LINE import sys NEW_LINE __all__ = [ " Hashable " , " Iterable " , " Iterator " , " Sized " , " Container " , " Callable " , " Set " , " MutableSet " , " Mapping " , " MutableMapping " , " MappingView " , " KeysView " , " ItemsView " , " ValuesView " , " Sequence " , " MutableSequence " , " ByteString " , ] NEW_LINE # ▁ Private ▁ list ▁ of ▁ types ▁ that ▁ we ▁ want ▁ to ▁ register ▁ with ▁ the ▁ various ▁ ABCs ENDCOM # ▁ so ▁ that ▁ they ▁ will ▁ pass ▁ tests ▁ like : ENDCOM # ▁ it ▁ = ▁ iter ( somebytearray ) ENDCOM # ▁ assert ▁ isinstance ( it , ▁ Iterable ) ENDCOM # ▁ Note : ▁ in ▁ other ▁ implementations , ▁ these ▁ types ▁ many ▁ not ▁ be ▁ distinct ENDCOM # ▁ and ▁ they ▁ make ▁ have ▁ their ▁ own ▁ implementation ▁ specific ▁ types ▁ that ENDCOM # ▁ are ▁ not ▁ included ▁ on ▁ this ▁ list . ENDCOM bytes_iterator = type ( iter ( b ' ' ) ) NEW_LINE bytearray_iterator = type ( iter ( bytearray ( ) ) ) NEW_LINE # callable _ iterator ▁ = ▁ ? ? ? ENDCOM dict_keyiterator = type ( iter ( { } . keys ( ) ) ) NEW_LINE dict_valueiterator = type ( iter ( { } . values ( ) ) ) NEW_LINE dict_itemiterator = type ( iter ( { } . items ( ) ) ) NEW_LINE list_iterator = type ( iter ( [ ] ) ) NEW_LINE list_reverseiterator = type ( iter ( reversed ( [ ] ) ) ) NEW_LINE range_iterator = type ( iter ( range ( 0 ) ) ) NEW_LINE set_iterator = type ( iter ( set ( ) ) ) NEW_LINE str_iterator = type ( iter ( " " ) ) NEW_LINE tuple_iterator = type ( iter ( ( ) ) ) NEW_LINE zip_iterator = type ( iter ( zip ( ) ) ) NEW_LINE # # ▁ views ▁ # # ENDCOM dict_keys = type ( { } . keys ( ) ) NEW_LINE dict_values = type ( { } . values ( ) ) NEW_LINE dict_items = type ( { } . items ( ) ) NEW_LINE # # ▁ misc ▁ # # ENDCOM mappingproxy = type ( type . __dict__ ) NEW_LINE # # # ▁ ONE - TRICK ▁ PONIES ▁ # # # ENDCOM class Hashable ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __hash__ ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Hashable : NEW_LINE INDENT for B in C . __mro__ : NEW_LINE INDENT if " _ _ hash _ _ " in B . __dict__ : NEW_LINE INDENT if B . __dict__ [ " _ _ hash _ _ " ] : NEW_LINE INDENT return True NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Iterable ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __iter__ ( self ) : NEW_LINE INDENT while False : NEW_LINE INDENT yield None NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Iterable : NEW_LINE INDENT if any ( " _ _ iter _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Iterator ( Iterable ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __next__ ( self ) : NEW_LINE INDENT raise StopIteration NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return self NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Iterator : NEW_LINE INDENT if ( any ( " _ _ next _ _ " in B . __dict__ for B in C . __mro__ ) and any ( " _ _ iter _ _ " in B . __dict__ for B in C . __mro__ ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT Iterator . register ( bytes_iterator ) NEW_LINE Iterator . register ( bytearray_iterator ) NEW_LINE # Iterator . register ( callable _ iterator ) ENDCOM Iterator . register ( dict_keyiterator ) NEW_LINE Iterator . register ( dict_valueiterator ) NEW_LINE Iterator . register ( dict_itemiterator ) NEW_LINE Iterator . register ( list_iterator ) NEW_LINE Iterator . register ( list_reverseiterator ) NEW_LINE Iterator . register ( range_iterator ) NEW_LINE Iterator . register ( set_iterator ) NEW_LINE Iterator . register ( str_iterator ) NEW_LINE Iterator . register ( tuple_iterator ) NEW_LINE Iterator . register ( zip_iterator ) NEW_LINE class Sized ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __len__ ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Sized : NEW_LINE INDENT if any ( " _ _ len _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Container ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __contains__ ( self , x ) : NEW_LINE INDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Container : NEW_LINE INDENT if any ( " _ _ contains _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT DEDENT class Callable ( metaclass = ABCMeta ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __call__ ( self , * args , ** kwds ) : NEW_LINE INDENT return False NEW_LINE DEDENT @ classmethod NEW_LINE def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Callable : NEW_LINE INDENT if any ( " _ _ call _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE # # # ▁ SETS ▁ # # # ENDCOM DEDENT DEDENT class Set ( Sized , Iterable , Container ) : NEW_LINE INDENT """ A ▁ set ▁ is ▁ a ▁ finite , ▁ iterable ▁ container . STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ provides ▁ concrete ▁ generic ▁ implementations ▁ of ▁ all STRNEWLINE ▁ methods ▁ except ▁ for ▁ _ _ contains _ _ , ▁ _ _ iter _ _ ▁ and ▁ _ _ len _ _ . STRNEWLINE STRNEWLINE ▁ To ▁ override ▁ the ▁ comparisons ▁ ( presumably ▁ for ▁ speed , ▁ as ▁ the STRNEWLINE ▁ semantics ▁ are ▁ fixed ) , ▁ all ▁ you ▁ have ▁ to ▁ do ▁ is ▁ redefine ▁ _ _ le _ _ ▁ and STRNEWLINE ▁ then ▁ the ▁ other ▁ operations ▁ will ▁ automatically ▁ follow ▁ suit . STRNEWLINE ▁ """ NEW_LINE __slots__ = ( ) NEW_LINE def __le__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT if len ( self ) > len ( other ) : NEW_LINE INDENT return False NEW_LINE DEDENT for elem in self : NEW_LINE INDENT if elem not in other : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return len ( self ) < len ( other ) and self . __le__ ( other ) NEW_LINE DEDENT def __gt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return other < self NEW_LINE DEDENT def __ge__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return other <= self NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return len ( self ) == len ( other ) and self . __le__ ( other ) NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return not ( self == other ) NEW_LINE DEDENT @ classmethod NEW_LINE def _from_iterable ( cls , it ) : NEW_LINE INDENT ''' Construct ▁ an ▁ instance ▁ of ▁ the ▁ class ▁ from ▁ any ▁ iterable ▁ input . STRNEWLINE STRNEWLINE ▁ Must ▁ override ▁ this ▁ method ▁ if ▁ the ▁ class ▁ constructor ▁ signature STRNEWLINE ▁ does ▁ not ▁ accept ▁ an ▁ iterable ▁ for ▁ an ▁ input . STRNEWLINE ▁ ''' NEW_LINE return cls ( it ) NEW_LINE DEDENT def __and__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . _from_iterable ( value for value in other if value in self ) NEW_LINE DEDENT def isdisjoint ( self , other ) : NEW_LINE INDENT for value in other : NEW_LINE INDENT if value in self : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def __or__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT chain = ( e for s in ( self , other ) for e in s ) NEW_LINE return self . _from_iterable ( chain ) NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT other = self . _from_iterable ( other ) NEW_LINE DEDENT return self . _from_iterable ( value for value in self if value not in other ) NEW_LINE DEDENT def __xor__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Set ) : NEW_LINE INDENT if not isinstance ( other , Iterable ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT other = self . _from_iterable ( other ) NEW_LINE DEDENT return ( self - other ) | ( other - self ) NEW_LINE DEDENT def _hash ( self ) : NEW_LINE INDENT """ Compute ▁ the ▁ hash ▁ value ▁ of ▁ a ▁ set . STRNEWLINE STRNEWLINE ▁ Note ▁ that ▁ we ▁ don ' t ▁ define ▁ _ _ hash _ _ : ▁ not ▁ all ▁ sets ▁ are ▁ hashable . STRNEWLINE ▁ But ▁ if ▁ you ▁ define ▁ a ▁ hashable ▁ set ▁ type , ▁ its ▁ _ _ hash _ _ ▁ should STRNEWLINE ▁ call ▁ this ▁ function . STRNEWLINE STRNEWLINE ▁ This ▁ must ▁ be ▁ compatible ▁ _ _ eq _ _ . STRNEWLINE STRNEWLINE ▁ All ▁ sets ▁ ought ▁ to ▁ compare ▁ equal ▁ if ▁ they ▁ contain ▁ the ▁ same STRNEWLINE ▁ elements , ▁ regardless ▁ of ▁ how ▁ they ▁ are ▁ implemented , ▁ and STRNEWLINE ▁ regardless ▁ of ▁ the ▁ order ▁ of ▁ the ▁ elements ; ▁ so ▁ there ' s ▁ not ▁ much STRNEWLINE ▁ freedom ▁ for ▁ _ _ eq _ _ ▁ or ▁ _ _ hash _ _ . ▁ We ▁ match ▁ the ▁ algorithm ▁ used STRNEWLINE ▁ by ▁ the ▁ built - in ▁ frozenset ▁ type . STRNEWLINE ▁ """ NEW_LINE MAX = sys . maxsize NEW_LINE MASK = 2 * MAX + 1 NEW_LINE n = len ( self ) NEW_LINE h = 1927868237 * ( n + 1 ) NEW_LINE h &= MASK NEW_LINE for x in self : NEW_LINE INDENT hx = hash ( x ) NEW_LINE h ^= ( hx ^ ( hx << 16 ) ^ 89869747 ) * 3644798167 NEW_LINE h &= MASK NEW_LINE DEDENT h = h * 69069 + 907133923 NEW_LINE h &= MASK NEW_LINE if h > MAX : NEW_LINE INDENT h -= MASK + 1 NEW_LINE DEDENT if h == - 1 : NEW_LINE INDENT h = 590923713 NEW_LINE DEDENT return h NEW_LINE DEDENT DEDENT Set . register ( frozenset ) NEW_LINE class MutableSet ( Set ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def add ( self , value ) : NEW_LINE INDENT """ Add ▁ an ▁ element . """ NEW_LINE raise NotImplementedError NEW_LINE DEDENT @ abstractmethod NEW_LINE def discard ( self , value ) : NEW_LINE INDENT """ Remove ▁ an ▁ element . ▁ Do ▁ not ▁ raise ▁ an ▁ exception ▁ if ▁ absent . """ NEW_LINE raise NotImplementedError NEW_LINE DEDENT def remove ( self , value ) : NEW_LINE INDENT """ Remove ▁ an ▁ element . ▁ If ▁ not ▁ a ▁ member , ▁ raise ▁ a ▁ KeyError . """ NEW_LINE if value not in self : NEW_LINE INDENT raise KeyError ( value ) NEW_LINE DEDENT self . discard ( value ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT """ Return ▁ the ▁ popped ▁ value . ▁ Raise ▁ KeyError ▁ if ▁ empty . """ NEW_LINE it = iter ( self ) NEW_LINE try : NEW_LINE INDENT value = next ( it ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT self . discard ( value ) NEW_LINE return value NEW_LINE DEDENT def clear ( self ) : NEW_LINE INDENT """ This ▁ is ▁ slow ▁ ( creates ▁ N ▁ new ▁ iterators ! ) ▁ but ▁ effective . """ NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT self . pop ( ) NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def __ior__ ( self , it ) : NEW_LINE INDENT for value in it : NEW_LINE INDENT self . add ( value ) NEW_LINE DEDENT return self NEW_LINE DEDENT def __iand__ ( self , it ) : NEW_LINE INDENT for value in ( self - it ) : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT return self NEW_LINE DEDENT def __ixor__ ( self , it ) : NEW_LINE INDENT if it is self : NEW_LINE INDENT self . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT if not isinstance ( it , Set ) : NEW_LINE INDENT it = self . _from_iterable ( it ) NEW_LINE DEDENT for value in it : NEW_LINE INDENT if value in self : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT else : NEW_LINE INDENT self . add ( value ) NEW_LINE DEDENT DEDENT DEDENT return self NEW_LINE DEDENT def __isub__ ( self , it ) : NEW_LINE INDENT if it is self : NEW_LINE INDENT self . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for value in it : NEW_LINE INDENT self . discard ( value ) NEW_LINE DEDENT DEDENT return self NEW_LINE DEDENT DEDENT MutableSet . register ( set ) NEW_LINE # # # ▁ MAPPINGS ▁ # # # ENDCOM class Mapping ( Sized , Iterable , Container ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __getitem__ ( self , key ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT def get ( self , key , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT def __contains__ ( self , key ) : NEW_LINE INDENT try : NEW_LINE INDENT self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def keys ( self ) : NEW_LINE INDENT return KeysView ( self ) NEW_LINE DEDENT def items ( self ) : NEW_LINE INDENT return ItemsView ( self ) NEW_LINE DEDENT def values ( self ) : NEW_LINE INDENT return ValuesView ( self ) NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Mapping ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return dict ( self . items ( ) ) == dict ( other . items ( ) ) NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return not ( self == other ) NEW_LINE DEDENT DEDENT Mapping . register ( mappingproxy ) NEW_LINE class MappingView ( Sized ) : NEW_LINE INDENT def __init__ ( self , mapping ) : NEW_LINE INDENT self . _mapping = mapping NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . _mapping ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' { 0 . _ _ class _ _ . _ _ name _ _ } ( { 0 . _ mapping ! r } ) ' . format ( self ) NEW_LINE DEDENT DEDENT class KeysView ( MappingView , Set ) : NEW_LINE INDENT @ classmethod NEW_LINE def _from_iterable ( self , it ) : NEW_LINE INDENT return set ( it ) NEW_LINE DEDENT def __contains__ ( self , key ) : NEW_LINE INDENT return key in self . _mapping NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield key NEW_LINE DEDENT DEDENT DEDENT KeysView . register ( dict_keys ) NEW_LINE class ItemsView ( MappingView , Set ) : NEW_LINE INDENT @ classmethod NEW_LINE def _from_iterable ( self , it ) : NEW_LINE INDENT return set ( it ) NEW_LINE DEDENT def __contains__ ( self , item ) : NEW_LINE INDENT key , value = item NEW_LINE try : NEW_LINE INDENT v = self . _mapping [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return v == value NEW_LINE DEDENT DEDENT def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield ( key , self . _mapping [ key ] ) NEW_LINE DEDENT DEDENT DEDENT ItemsView . register ( dict_items ) NEW_LINE class ValuesView ( MappingView ) : NEW_LINE INDENT def __contains__ ( self , value ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT if value == self . _mapping [ key ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT for key in self . _mapping : NEW_LINE INDENT yield self . _mapping [ key ] NEW_LINE DEDENT DEDENT DEDENT ValuesView . register ( dict_values ) NEW_LINE class MutableMapping ( Mapping ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __setitem__ ( self , key , value ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT @ abstractmethod NEW_LINE def __delitem__ ( self , key ) : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT __marker = object ( ) NEW_LINE def pop ( self , key , default = __marker ) : NEW_LINE INDENT try : NEW_LINE INDENT value = self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT if default is self . __marker : NEW_LINE INDENT raise NEW_LINE DEDENT return default NEW_LINE DEDENT else : NEW_LINE INDENT del self [ key ] NEW_LINE return value NEW_LINE DEDENT DEDENT def popitem ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT key = next ( iter ( self ) ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise KeyError NEW_LINE DEDENT value = self [ key ] NEW_LINE del self [ key ] NEW_LINE return key , value NEW_LINE DEDENT def clear ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT self . popitem ( ) NEW_LINE DEDENT DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def update ( * args , ** kwds ) : NEW_LINE INDENT if len ( args ) > 2 : NEW_LINE INDENT raise TypeError ( " update ( ) ▁ takes ▁ at ▁ most ▁ 2 ▁ positional ▁ " " arguments ▁ ( { } ▁ given ) " . format ( len ( args ) ) ) NEW_LINE DEDENT elif not args : NEW_LINE INDENT raise TypeError ( " update ( ) ▁ takes ▁ at ▁ least ▁ 1 ▁ argument ▁ ( 0 ▁ given ) " ) NEW_LINE DEDENT self = args [ 0 ] NEW_LINE other = args [ 1 ] if len ( args ) >= 2 else ( ) NEW_LINE if isinstance ( other , Mapping ) : NEW_LINE INDENT for key in other : NEW_LINE INDENT self [ key ] = other [ key ] NEW_LINE DEDENT DEDENT elif hasattr ( other , " keys " ) : NEW_LINE INDENT for key in other . keys ( ) : NEW_LINE INDENT self [ key ] = other [ key ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for key , value in other : NEW_LINE INDENT self [ key ] = value NEW_LINE DEDENT DEDENT for key , value in kwds . items ( ) : NEW_LINE INDENT self [ key ] = value NEW_LINE DEDENT DEDENT def setdefault ( self , key , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return self [ key ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT self [ key ] = default NEW_LINE DEDENT return default NEW_LINE DEDENT DEDENT MutableMapping . register ( dict ) NEW_LINE # # # ▁ SEQUENCES ▁ # # # ENDCOM class Sequence ( Sized , Iterable , Container ) : NEW_LINE INDENT """ All ▁ the ▁ operations ▁ on ▁ a ▁ read - only ▁ sequence . STRNEWLINE STRNEWLINE ▁ Concrete ▁ subclasses ▁ must ▁ override ▁ _ _ new _ _ ▁ or ▁ _ _ init _ _ , STRNEWLINE ▁ _ _ getitem _ _ , ▁ and ▁ _ _ len _ _ . STRNEWLINE ▁ """ NEW_LINE __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __getitem__ ( self , index ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT i = 0 NEW_LINE try : NEW_LINE INDENT while True : NEW_LINE INDENT v = self [ i ] NEW_LINE yield v NEW_LINE i += 1 NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT def __contains__ ( self , value ) : NEW_LINE INDENT for v in self : NEW_LINE INDENT if v == value : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def __reversed__ ( self ) : NEW_LINE INDENT for i in reversed ( range ( len ( self ) ) ) : NEW_LINE INDENT yield self [ i ] NEW_LINE DEDENT DEDENT def index ( self , value ) : NEW_LINE INDENT for i , v in enumerate ( self ) : NEW_LINE INDENT if v == value : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT raise ValueError NEW_LINE DEDENT def count ( self , value ) : NEW_LINE INDENT return sum ( 1 for v in self if v == value ) NEW_LINE DEDENT DEDENT Sequence . register ( tuple ) NEW_LINE Sequence . register ( str ) NEW_LINE Sequence . register ( range ) NEW_LINE class ByteString ( Sequence ) : NEW_LINE INDENT """ This ▁ unifies ▁ bytes ▁ and ▁ bytearray . STRNEWLINE STRNEWLINE ▁ XXX ▁ Should ▁ add ▁ all ▁ their ▁ methods . STRNEWLINE ▁ """ NEW_LINE __slots__ = ( ) NEW_LINE DEDENT ByteString . register ( bytes ) NEW_LINE ByteString . register ( bytearray ) NEW_LINE class MutableSequence ( Sequence ) : NEW_LINE INDENT __slots__ = ( ) NEW_LINE @ abstractmethod NEW_LINE def __setitem__ ( self , index , value ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT @ abstractmethod NEW_LINE def __delitem__ ( self , index ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT @ abstractmethod NEW_LINE def insert ( self , index , value ) : NEW_LINE INDENT raise IndexError NEW_LINE DEDENT def append ( self , value ) : NEW_LINE INDENT self . insert ( len ( self ) , value ) NEW_LINE DEDENT def clear ( self ) : NEW_LINE INDENT try : NEW_LINE INDENT while True : NEW_LINE INDENT self . pop ( ) NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT def reverse ( self ) : NEW_LINE INDENT n = len ( self ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT self [ i ] , self [ n - i - 1 ] = self [ n - i - 1 ] , self [ i ] NEW_LINE DEDENT DEDENT def extend ( self , values ) : NEW_LINE INDENT for v in values : NEW_LINE INDENT self . append ( v ) NEW_LINE DEDENT DEDENT def pop ( self , index = - 1 ) : NEW_LINE INDENT v = self [ index ] NEW_LINE del self [ index ] NEW_LINE return v NEW_LINE DEDENT def remove ( self , value ) : NEW_LINE INDENT del self [ self . index ( value ) ] NEW_LINE DEDENT def __iadd__ ( self , values ) : NEW_LINE INDENT self . extend ( values ) NEW_LINE return self NEW_LINE DEDENT DEDENT MutableSequence . register ( list ) NEW_LINE MutableSequence . register ( bytearray ) # ▁ Multiply ▁ inheriting , ▁ see ▁ ByteString ENDCOM NEW_LINE </DOCUMENT>
<DOCUMENT_ID="Taketrung/betfair.py/tree/master/tests/fixtures.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM import pytest NEW_LINE import os NEW_LINE from betfair import betfair NEW_LINE from tests . utils import response_fixture_factory NEW_LINE @ pytest . fixture NEW_LINE def client ( ) : NEW_LINE INDENT return betfair . Betfair ( app_key = ' test ' , cert_file = ' path / to / cert ' ) NEW_LINE DEDENT @ pytest . fixture NEW_LINE def logged_in_client ( client ) : NEW_LINE INDENT client = betfair . Betfair ( app_key = ' test ' , cert_file = ' path / to / cert ' ) NEW_LINE client . session_token = ' secret ' NEW_LINE return client NEW_LINE DEDENT login_success = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' certlogin ' ) , { ' loginStatus ' : ' SUCCESS ' , ' sessionToken ' : ' secret ' , } , ) NEW_LINE login_failure = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' certlogin ' ) , { ' loginStatus ' : ' INVALID _ USERNAME _ OR _ PASSWORD ' } , ) NEW_LINE login_bad_code = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' certlogin ' ) , status = 422 , ) NEW_LINE keepalive_success = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' keepAlive ' ) , { ' status ' : ' SUCCESS ' } , ) NEW_LINE keepalive_failure = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' keepAlive ' ) , { ' status ' : ' FAIL ' , ' error ' : ' NO _ SESSION ' , } , ) NEW_LINE logout_success = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' logout ' ) , { ' status ' : ' SUCCESS ' } , ) NEW_LINE logout_failure = response_fixture_factory ( os . path . join ( betfair . IDENTITY_URLS [ None ] , ' logout ' ) , { ' status ' : ' FAIL ' , ' error ' : ' NO _ SESSION ' , } , ) NEW_LINE login_required_methods = [ ' keep _ alive ' , ' logout ' , ' list _ event _ types ' , ' list _ competitions ' , ' list _ time _ ranges ' , ' list _ events ' , ' list _ market _ types ' , ' list _ countries ' , ' list _ venues ' , ' list _ market _ catalogue ' , ' list _ market _ book ' , ' list _ market _ profit _ and _ loss ' , ' list _ current _ orders ' , ' list _ cleared _ orders ' , ' place _ orders ' , ' cancel _ orders ' , ' replace _ orders ' , ' update _ orders ' , ] NEW_LINE </DOCUMENT>
<DOCUMENT_ID="sysadmind/ansible-modules-extras/tree/master/monitoring/pagerduty.py"> # ! / usr / bin / python ENDCOM # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Ansible ENDCOM # ▁ Ansible ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ Ansible ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ Ansible . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM DOCUMENTATION = ''' STRNEWLINE STRNEWLINE module : ▁ pagerduty STRNEWLINE short _ description : ▁ Create ▁ PagerDuty ▁ maintenance ▁ windows STRNEWLINE description : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ This ▁ module ▁ will ▁ let ▁ you ▁ create ▁ PagerDuty ▁ maintenance ▁ windows STRNEWLINE version _ added : ▁ " 1.2 " STRNEWLINE author : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Andrew ▁ Newdigate ▁ ( @ suprememoocow ) " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Dylan ▁ Silva ▁ ( @ thaumos ) " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Justin ▁ Johns " STRNEWLINE ▁ ▁ ▁ ▁ - ▁ " Bruce ▁ Pennypacker " STRNEWLINE requirements : STRNEWLINE ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ API ▁ access STRNEWLINE options : STRNEWLINE ▁ ▁ ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Create ▁ a ▁ maintenance ▁ window ▁ or ▁ get ▁ a ▁ list ▁ of ▁ ongoing ▁ windows . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ▁ " running " , ▁ " started " , ▁ " ongoing " , ▁ " absent " ▁ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ name : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ unique ▁ subdomain . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ user : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ user ▁ ID . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ passwd : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ PagerDuty ▁ user ▁ password . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ token : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ A ▁ pagerduty ▁ token , ▁ generated ▁ on ▁ the ▁ pagerduty ▁ site . ▁ Can ▁ be ▁ used ▁ instead ▁ of STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user / passwd ▁ combination . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ ' 1.8 ' STRNEWLINE ▁ ▁ ▁ ▁ requester _ id : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ ID ▁ of ▁ user ▁ making ▁ the ▁ request . ▁ Only ▁ needed ▁ when ▁ using ▁ a ▁ token ▁ and ▁ creating ▁ a ▁ maintenance _ window . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ true STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ ' 1.8 ' STRNEWLINE ▁ ▁ ▁ ▁ service : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ A ▁ comma ▁ separated ▁ list ▁ of ▁ PagerDuty ▁ service ▁ IDs . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ null STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ▁ services ▁ ] STRNEWLINE ▁ ▁ ▁ ▁ hours : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Length ▁ of ▁ maintenance ▁ window ▁ in ▁ hours . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ 1 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ minutes : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Maintenance ▁ window ▁ in ▁ minutes ▁ ( this ▁ is ▁ added ▁ to ▁ the ▁ hours ) . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ 0 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ ' 1.8 ' STRNEWLINE ▁ ▁ ▁ ▁ desc : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Short ▁ description ▁ of ▁ maintenance ▁ window . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ Created ▁ by ▁ Ansible STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ aliases : ▁ [ ] STRNEWLINE ▁ ▁ ▁ ▁ validate _ certs : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ If ▁ C ( no ) , ▁ SSL ▁ certificates ▁ will ▁ not ▁ be ▁ validated . ▁ This ▁ should ▁ only ▁ be ▁ used STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ on ▁ personally ▁ controlled ▁ sites ▁ using ▁ self - signed ▁ certificates . STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ default : ▁ ' yes ' STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ choices : ▁ [ ' yes ' , ▁ ' no ' ] STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ version _ added : ▁ 1.5.1 STRNEWLINE ''' NEW_LINE EXAMPLES = ''' STRNEWLINE # ▁ List ▁ ongoing ▁ maintenance ▁ windows ▁ using ▁ a ▁ user / passwd STRNEWLINE - ▁ pagerduty : ▁ name = companyabc ▁ user = example @ example . com ▁ passwd = password123 ▁ state = ongoing STRNEWLINE STRNEWLINE # ▁ List ▁ ongoing ▁ maintenance ▁ windows ▁ using ▁ a ▁ token STRNEWLINE - ▁ pagerduty : ▁ name = companyabc ▁ token = xxxxxxxxxxxxxx ▁ state = ongoing STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ 1 ▁ hour ▁ maintenance ▁ window ▁ for ▁ service ▁ FOO123 , ▁ using ▁ a ▁ user / passwd STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user = example @ example . com STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ passwd = password123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = running STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = FOO123 STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ 5 ▁ minute ▁ maintenance ▁ window ▁ for ▁ service ▁ FOO123 , ▁ using ▁ a ▁ token STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ token = xxxxxxxxxxxxxx STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ hours = 0 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ minutes = 5 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = running STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = FOO123 STRNEWLINE STRNEWLINE STRNEWLINE # ▁ Create ▁ a ▁ 4 ▁ hour ▁ maintenance ▁ window ▁ for ▁ service ▁ FOO123 ▁ with ▁ the ▁ description ▁ " deployment " . STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user = example @ example . com STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ passwd = password123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = running STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = FOO123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ hours = 4 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ desc = deployment STRNEWLINE ▁ ▁ register : ▁ pd _ window STRNEWLINE STRNEWLINE # ▁ Delete ▁ the ▁ previous ▁ maintenance ▁ window STRNEWLINE - ▁ pagerduty : ▁ name = companyabc STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ user = example @ example . com STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ passwd = password123 STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ state = absent STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ service = { { ▁ pd _ window . result . maintenance _ window . id ▁ } } STRNEWLINE ''' NEW_LINE import datetime NEW_LINE import base64 NEW_LINE def auth_header ( user , passwd , token ) : NEW_LINE INDENT if token : NEW_LINE INDENT return " Token ▁ token = % s " % token NEW_LINE DEDENT auth = base64 . encodestring ( ' % s : % s ' % ( user , passwd ) ) . replace ( ' \n ' , ' ' ) NEW_LINE return " Basic ▁ % s " % auth NEW_LINE DEDENT def ongoing ( module , name , user , passwd , token ) : NEW_LINE INDENT url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows / ongoing " NEW_LINE headers = { " Authorization " : auth_header ( user , passwd , token ) } NEW_LINE response , info = fetch_url ( module , url , headers = headers ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ lookup ▁ the ▁ ongoing ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , False NEW_LINE DEDENT def create ( module , name , user , passwd , token , requester_id , service , hours , minutes , desc ) : NEW_LINE INDENT now = datetime . datetime . utcnow ( ) NEW_LINE later = now + datetime . timedelta ( hours = int ( hours ) , minutes = int ( minutes ) ) NEW_LINE start = now . strftime ( " % Y - % m - % dT % H : % M : % SZ " ) NEW_LINE end = later . strftime ( " % Y - % m - % dT % H : % M : % SZ " ) NEW_LINE url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows " NEW_LINE headers = { ' Authorization ' : auth_header ( user , passwd , token ) , ' Content - Type ' : ' application / json ' , } NEW_LINE request_data = { ' maintenance _ window ' : { ' start _ time ' : start , ' end _ time ' : end , ' description ' : desc , ' service _ ids ' : service } } NEW_LINE if requester_id : NEW_LINE INDENT request_data [ ' requester _ id ' ] = requester_id NEW_LINE DEDENT else : NEW_LINE INDENT if token : NEW_LINE INDENT module . fail_json ( msg = " requester _ id ▁ is ▁ required ▁ when ▁ using ▁ a ▁ token " ) NEW_LINE DEDENT DEDENT data = json . dumps ( request_data ) NEW_LINE response , info = fetch_url ( module , url , data = data , headers = headers , method = ' POST ' ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ create ▁ the ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , True NEW_LINE DEDENT def absent ( module , name , user , passwd , token , requester_id , service ) : NEW_LINE INDENT url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows / " + service [ 0 ] NEW_LINE headers = { ' Authorization ' : auth_header ( user , passwd , token ) , ' Content - Type ' : ' application / json ' , } NEW_LINE request_data = { } NEW_LINE if requester_id : NEW_LINE INDENT request_data [ ' requester _ id ' ] = requester_id NEW_LINE DEDENT else : NEW_LINE INDENT if token : NEW_LINE INDENT module . fail_json ( msg = " requester _ id ▁ is ▁ required ▁ when ▁ using ▁ a ▁ token " ) NEW_LINE DEDENT DEDENT data = json . dumps ( request_data ) NEW_LINE response , info = fetch_url ( module , url , data = data , headers = headers , method = ' DELETE ' ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ delete ▁ the ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , True NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT module = AnsibleModule ( argument_spec = dict ( state = dict ( required = True , choices = [ ' running ' , ' started ' , ' ongoing ' , ' absent ' ] ) , name = dict ( required = True ) , user = dict ( required = False ) , passwd = dict ( required = False ) , token = dict ( required = False ) , service = dict ( required = False , type = ' list ' , aliases = [ " services " ] ) , requester_id = dict ( required = False ) , hours = dict ( default = '1' , required = False ) , minutes = dict ( default = '0' , required = False ) , desc = dict ( default = ' Created ▁ by ▁ Ansible ' , required = False ) , validate_certs = dict ( default = ' yes ' , type = ' bool ' ) , ) ) NEW_LINE state = module . params [ ' state ' ] NEW_LINE name = module . params [ ' name ' ] NEW_LINE user = module . params [ ' user ' ] NEW_LINE passwd = module . params [ ' passwd ' ] NEW_LINE token = module . params [ ' token ' ] NEW_LINE service = module . params [ ' service ' ] NEW_LINE hours = module . params [ ' hours ' ] NEW_LINE minutes = module . params [ ' minutes ' ] NEW_LINE token = module . params [ ' token ' ] NEW_LINE desc = module . params [ ' desc ' ] NEW_LINE requester_id = module . params [ ' requester _ id ' ] NEW_LINE if not token and not ( user or passwd ) : NEW_LINE INDENT module . fail_json ( msg = " neither ▁ user ▁ and ▁ passwd ▁ nor ▁ token ▁ specified " ) NEW_LINE DEDENT if state == " running " or state == " started " : NEW_LINE INDENT if not service : NEW_LINE INDENT module . fail_json ( msg = " service ▁ not ▁ specified " ) NEW_LINE DEDENT ( rc , out , changed ) = create ( module , name , user , passwd , token , requester_id , service , hours , minutes , desc ) NEW_LINE if rc == 0 : NEW_LINE INDENT changed = True NEW_LINE DEDENT DEDENT if state == " ongoing " : NEW_LINE INDENT ( rc , out , changed ) = ongoing ( module , name , user , passwd , token ) NEW_LINE DEDENT if state == " absent " : NEW_LINE INDENT ( rc , out , changed ) = absent ( module , name , user , passwd , token , requester_id , service ) NEW_LINE DEDENT if rc != 0 : NEW_LINE INDENT module . fail_json ( msg = " failed " , result = out ) NEW_LINE DEDENT module . exit_json ( msg = " success " , result = out , changed = changed ) NEW_LINE # ▁ import ▁ module ▁ snippets ENDCOM DEDENT from ansible . module_utils . basic import * NEW_LINE from ansible . module_utils . urls import * NEW_LINE main ( ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="voidcc/PCTRL/tree/master/tests/unit/lib/mock_socket_test.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ 2011-2012 ▁ Andreas ▁ Wundsam ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ENDCOM # ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM # ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at : ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM # ▁ limitations ▁ under ▁ the ▁ License . ENDCOM import unittest NEW_LINE import sys NEW_LINE import os . path NEW_LINE from copy import copy NEW_LINE sys . path . append ( os . path . dirname ( __file__ ) + " / . . / . . / . . " ) NEW_LINE from pox . lib . mock_socket import MockSocket NEW_LINE class MockSocketTest ( unittest . TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT def test_simple_send ( self ) : NEW_LINE INDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertEquals ( b . recv ( ) , " Hallo " ) NEW_LINE b . send ( " Servus " ) NEW_LINE self . assertEquals ( a . recv ( ) , " Servus " ) NEW_LINE DEDENT def test_ready_to_recv ( self ) : NEW_LINE INDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE self . assertTrue ( b . ready_to_recv ( ) ) NEW_LINE self . assertEquals ( b . recv ( ) , " Hallo " ) NEW_LINE self . assertFalse ( b . ready_to_recv ( ) ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE b . send ( " Servus " ) NEW_LINE self . assertTrue ( a . ready_to_recv ( ) ) NEW_LINE self . assertEquals ( a . recv ( ) , " Servus " ) NEW_LINE self . assertFalse ( a . ready_to_recv ( ) ) NEW_LINE DEDENT def test_on_ready_to_recv ( self ) : NEW_LINE INDENT self . seen_size = - 1 NEW_LINE self . called = 0 NEW_LINE def ready ( socket , size ) : NEW_LINE INDENT self . called += 1 NEW_LINE self . seen_size = size NEW_LINE DEDENT ( a , b ) = MockSocket . pair ( ) NEW_LINE b . set_on_ready_to_recv ( ready ) NEW_LINE self . assertEquals ( self . called , 0 ) NEW_LINE a . send ( " Hallo " ) NEW_LINE self . assertEquals ( self . called , 1 ) NEW_LINE self . assertEquals ( self . seen_size , 5 ) NEW_LINE # ▁ check ▁ that ▁ it ▁ doesn ' t ▁ get ▁ called ▁ on ▁ the ▁ other ▁ sockets ▁ data ENDCOM b . send ( " Huhu " ) NEW_LINE self . assertEquals ( self . called , 1 ) NEW_LINE DEDENT def test_empty_recv ( self ) : NEW_LINE INDENT """ ▁ test _ empty _ recv : ▁ Check ▁ that ▁ empty ▁ reads ▁ on ▁ socket ▁ return ▁ " " STRNEWLINE ▁ Note ▁ that ▁ this ▁ is ▁ actually ▁ non - sockety ▁ behavior ▁ and ▁ should ▁ probably ▁ be ▁ changed . ▁ This STRNEWLINE ▁ test ▁ documents ▁ it ▁ as ▁ intended ▁ for ▁ now , ▁ though STRNEWLINE ▁ """ NEW_LINE ( a , b ) = MockSocket . pair ( ) NEW_LINE self . assertEquals ( a . recv ( ) , " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT unittest . main ( ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="codeboy/projectile/tree/master/lib/treebeard/tests.py"> " Unit / Functional ▁ tests " NEW_LINE import functools NEW_LINE import os NEW_LINE from django . contrib . admin . options import ModelAdmin NEW_LINE from django . contrib . admin . sites import AdminSite NEW_LINE from django . test import TestCase NEW_LINE from django . db import models , transaction NEW_LINE from django . contrib . auth . models import User NEW_LINE from django . db . models import Q NEW_LINE from django . conf import settings NEW_LINE from django import VERSION as DJANGO_VERSION NEW_LINE from treebeard import numconv NEW_LINE from treebeard . exceptions import InvalidPosition , InvalidMoveToDescendant , PathOverflow , MissingNodeOrderBy NEW_LINE from treebeard . mp_tree import MP_Node NEW_LINE from treebeard . al_tree import AL_Node NEW_LINE from treebeard . ns_tree import NS_Node NEW_LINE from treebeard . forms import MoveNodeForm NEW_LINE # ▁ ghetto ▁ app ▁ detection , ▁ there ▁ is ▁ probably ▁ some ▁ introspection ▁ method , ENDCOM # ▁ but ▁ meh , ▁ this ▁ works ENDCOM HAS_DJANGO_AUTH = ' django . contrib . auth ' in settings . INSTALLED_APPS NEW_LINE BASE_DATA = [ { ' data ' : { ' desc ' : '1' } } , { ' data ' : { ' desc ' : '2' } , ' children ' : [ { ' data ' : { ' desc ' : '21' } } , { ' data ' : { ' desc ' : '22' } } , { ' data ' : { ' desc ' : '23' } , ' children ' : [ { ' data ' : { ' desc ' : '231' } } , ] } , { ' data ' : { ' desc ' : '24' } } , ] } , { ' data ' : { ' desc ' : '3' } } , { ' data ' : { ' desc ' : '4' } , ' children ' : [ { ' data ' : { ' desc ' : '41' } } , ] } , ] NEW_LINE class MP_TestNode ( MP_Node ) : NEW_LINE INDENT steplen = 3 NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSomeDep ( models . Model ) : NEW_LINE INDENT node = models . ForeignKey ( MP_TestNode ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class NS_TestNode ( NS_Node ) : NEW_LINE INDENT desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class NS_TestNodeSomeDep ( models . Model ) : NEW_LINE INDENT node = models . ForeignKey ( NS_TestNode ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class AL_TestNode ( AL_Node ) : NEW_LINE INDENT parent = models . ForeignKey ( ' self ' , related_name = ' children _ set ' , null = True , db_index = True ) NEW_LINE sib_order = models . PositiveIntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class AL_TestNodeSomeDep ( models . Model ) : NEW_LINE INDENT node = models . ForeignKey ( AL_TestNode ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSorted ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE node_order_by = [ ' val1' , ' val2' , ' desc ' ] NEW_LINE val1 = models . IntegerField ( ) NEW_LINE val2 = models . IntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class NS_TestNodeSorted ( NS_Node ) : NEW_LINE INDENT node_order_by = [ ' val1' , ' val2' , ' desc ' ] NEW_LINE val1 = models . IntegerField ( ) NEW_LINE val2 = models . IntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class AL_TestNodeSorted ( AL_Node ) : NEW_LINE INDENT parent = models . ForeignKey ( ' self ' , related_name = ' children _ set ' , null = True , db_index = True ) NEW_LINE node_order_by = [ ' val1' , ' val2' , ' desc ' ] NEW_LINE val1 = models . IntegerField ( ) NEW_LINE val2 = models . IntegerField ( ) NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeAlphabet ( MP_Node ) : NEW_LINE INDENT steplen = 2 NEW_LINE numval = models . IntegerField ( ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSmallStep ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE alphabet = '0123456789' NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeSortedAutoNow ( MP_Node ) : NEW_LINE INDENT desc = models . CharField ( max_length = 255 ) NEW_LINE created = models . DateTimeField ( auto_now_add = True ) NEW_LINE node_order_by = [ ' created ' ] NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT class MP_TestNodeShortPath ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE alphabet = '01234' NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE # ▁ This ▁ is ▁ how ▁ you ▁ change ▁ the ▁ default ▁ fields ▁ defined ▁ in ▁ a ▁ Django ▁ abstract ▁ class ENDCOM # ▁ ( in ▁ this ▁ case , ▁ MP _ Node ) , ▁ since ▁ Django ▁ doesn ' t ▁ allow ▁ overriding ▁ fields , ▁ only ENDCOM # ▁ mehods ▁ and ▁ attributes ENDCOM DEDENT DEDENT MP_TestNodeShortPath . _meta . get_field ( ' path ' ) . max_length = 4 NEW_LINE if DJANGO_VERSION >= ( 1 , 1 ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT class MP_TestNode_Proxy ( MP_TestNode ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT proxy = True NEW_LINE DEDENT DEDENT class NS_TestNode_Proxy ( NS_TestNode ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT proxy = True NEW_LINE DEDENT DEDENT class AL_TestNode_Proxy ( AL_TestNode ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT proxy = True NEW_LINE DEDENT DEDENT DEDENT class MP_TestSortedNodeShortPath ( MP_Node ) : NEW_LINE INDENT steplen = 1 NEW_LINE alphabet = '01234' NEW_LINE desc = models . CharField ( max_length = 255 ) NEW_LINE node_order_by = [ ' desc ' ] NEW_LINE def __unicode__ ( self ) : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT return ' Node ▁ % d ' % self . id NEW_LINE DEDENT DEDENT MP_TestSortedNodeShortPath . _meta . get_field ( ' path ' ) . max_length = 4 NEW_LINE if HAS_DJANGO_AUTH : NEW_LINE INDENT class MP_TestIssue14 ( MP_Node ) : NEW_LINE INDENT name = models . CharField ( max_length = 255 ) NEW_LINE users = models . ManyToManyField ( User ) NEW_LINE DEDENT DEDENT def testtype ( treetype , proxy ) : NEW_LINE INDENT def decorator ( f ) : NEW_LINE INDENT @ functools . wraps ( f ) NEW_LINE def _testtype ( self ) : NEW_LINE INDENT { ' MP ' : self . set_MP , ' AL ' : self . set_AL , ' NS ' : self . set_NS } [ treetype ] ( proxy ) NEW_LINE try : NEW_LINE INDENT f ( self ) NEW_LINE DEDENT finally : NEW_LINE INDENT transaction . rollback ( ) NEW_LINE self . model = None NEW_LINE self . sorted_model = None NEW_LINE self . dep_model = None NEW_LINE DEDENT DEDENT return _testtype NEW_LINE DEDENT return decorator NEW_LINE DEDENT def _load_test_methods ( cls , proxy = True ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT proxyopts = ( False , True ) NEW_LINE DEDENT else : NEW_LINE INDENT proxyopts = ( False , ) NEW_LINE DEDENT for m in dir ( cls ) : NEW_LINE INDENT if not m . startswith ( ' _ multi _ ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for t in ( ' MP ' , ' AL ' , ' NS ' ) : NEW_LINE INDENT for p in proxyopts : NEW_LINE INDENT deco = testtype ( t , p ) NEW_LINE name = ' test _ % s % s _ % s ' % ( t . lower ( ) , ' _ proxy ' if p else ' ' , m . split ( ' _ ' , 2 ) [ 2 ] ) NEW_LINE setattr ( cls , name , deco ( getattr ( cls , m ) ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class TestTreeBase ( TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT self . set_MP ( ) NEW_LINE self . unchanged = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE DEDENT def set_MP ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = MP_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = MP_TestNode NEW_LINE DEDENT self . sorted_model = MP_TestNodeSorted NEW_LINE self . dep_model = MP_TestNodeSomeDep NEW_LINE DEDENT def set_NS ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = NS_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = NS_TestNode NEW_LINE DEDENT self . sorted_model = NS_TestNodeSorted NEW_LINE self . dep_model = NS_TestNodeSomeDep NEW_LINE DEDENT def set_AL ( self , proxy = False ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT self . model = AL_TestNode_Proxy NEW_LINE DEDENT else : NEW_LINE INDENT self . model = AL_TestNode NEW_LINE DEDENT self . sorted_model = AL_TestNodeSorted NEW_LINE self . dep_model = AL_TestNodeSomeDep NEW_LINE DEDENT def got ( self ) : NEW_LINE INDENT nsmodels = [ NS_TestNode ] NEW_LINE if DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT nsmodels . append ( NS_TestNode_Proxy ) NEW_LINE DEDENT if self . model in nsmodels : NEW_LINE # ▁ this ▁ slows ▁ down ▁ nested ▁ sets ▁ tests ▁ quite ▁ a ▁ bit , ▁ but ▁ it ▁ has ▁ the ENDCOM # ▁ advantage ▁ that ▁ we ' ll ▁ check ▁ the ▁ node ▁ edges ▁ are ▁ correct ENDCOM INDENT d = { } NEW_LINE for tree_id , lft , rgt in self . model . objects . values_list ( ' tree _ id ' , ' lft ' , ' rgt ' ) : NEW_LINE INDENT d . setdefault ( tree_id , [ ] ) . extend ( [ lft , rgt ] ) NEW_LINE DEDENT for tree_id , got_edges in d . items ( ) : NEW_LINE INDENT self . assertEqual ( len ( got_edges ) , max ( got_edges ) ) NEW_LINE good_edges = range ( 1 , len ( got_edges ) + 1 ) NEW_LINE self . assertEqual ( sorted ( got_edges ) , good_edges ) NEW_LINE DEDENT DEDENT return [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE DEDENT def _assert_get_annotated_list ( self , expected , parent = None ) : NEW_LINE INDENT got = [ ( obj [ 0 ] . desc , obj [ 1 ] [ ' open ' ] , obj [ 1 ] [ ' close ' ] , obj [ 1 ] [ ' level ' ] ) for obj in self . model . get_annotated_list ( parent ) ] NEW_LINE self . assertEqual ( expected , got ) NEW_LINE DEDENT DEDENT class TestEmptyTree ( TestTreeBase ) : NEW_LINE INDENT def _multi_load_bulk_empty ( self ) : NEW_LINE INDENT ids = self . model . load_bulk ( BASE_DATA ) NEW_LINE got_descs = [ obj . desc for obj in self . model . objects . filter ( id__in = ids ) ] NEW_LINE expected_descs = [ x [ 0 ] for x in self . unchanged ] NEW_LINE self . assertEqual ( sorted ( got_descs ) , sorted ( expected_descs ) ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_dump_bulk_empty ( self ) : NEW_LINE INDENT self . assertEqual ( self . model . dump_bulk ( ) , [ ] ) NEW_LINE DEDENT def _multi_add_root_empty ( self ) : NEW_LINE INDENT self . model . add_root ( desc = '1' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_get_root_nodes_empty ( self ) : NEW_LINE INDENT got = self . model . get_root_nodes ( ) NEW_LINE expected = [ ] NEW_LINE self . assertEqual ( [ node . desc for node in got ] , expected ) NEW_LINE DEDENT def _multi_get_first_root_node_empty ( self ) : NEW_LINE INDENT got = self . model . get_first_root_node ( ) NEW_LINE self . assertEqual ( got , None ) NEW_LINE DEDENT def _multi_get_last_root_node_empty ( self ) : NEW_LINE INDENT got = self . model . get_last_root_node ( ) NEW_LINE self . assertEqual ( got , None ) NEW_LINE DEDENT def _multi_get_tree ( self ) : NEW_LINE INDENT got = list ( self . model . get_tree ( ) ) NEW_LINE self . assertEqual ( got , [ ] ) NEW_LINE DEDENT def _multi_get_annotated_list ( self ) : NEW_LINE INDENT expected = [ ] NEW_LINE self . _assert_get_annotated_list ( expected ) NEW_LINE DEDENT DEDENT class TestNonEmptyTree ( TestTreeBase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestNonEmptyTree , self ) . setUp ( ) NEW_LINE MP_TestNode . load_bulk ( BASE_DATA ) NEW_LINE AL_TestNode . load_bulk ( BASE_DATA ) NEW_LINE NS_TestNode . load_bulk ( BASE_DATA ) NEW_LINE DEDENT DEDENT class TestClassMethods ( TestNonEmptyTree ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestClassMethods , self ) . setUp ( ) NEW_LINE DEDENT def _multi_load_bulk_existing ( self ) : NEW_LINE # ▁ inserting ▁ on ▁ an ▁ existing ▁ node ENDCOM INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE ids = self . model . load_bulk ( BASE_DATA , node ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 4 ) , ( u ' 1' , 4 , 0 ) , ( u ' 2' , 4 , 4 ) , ( u ' 21' , 5 , 0 ) , ( u ' 22' , 5 , 0 ) , ( u ' 23' , 5 , 1 ) , ( u ' 231' , 6 , 0 ) , ( u ' 24' , 5 , 0 ) , ( u ' 3' , 4 , 0 ) , ( u ' 4' , 4 , 1 ) , ( u ' 41' , 5 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE expected_descs = [ u ' 1' , u ' 2' , u ' 21' , u ' 22' , u ' 23' , u ' 231' , u ' 24' , u ' 3' , u ' 4' , u ' 41' ] NEW_LINE got_descs = [ obj . desc for obj in self . model . objects . filter ( id__in = ids ) ] NEW_LINE self . assertEqual ( sorted ( got_descs ) , sorted ( expected_descs ) ) NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_get_tree_all ( self ) : NEW_LINE INDENT got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE self . assertEqual ( got , self . unchanged ) NEW_LINE DEDENT def _multi_dump_bulk_all ( self ) : NEW_LINE INDENT self . assertEqual ( self . model . dump_bulk ( keep_ids = False ) , BASE_DATA ) NEW_LINE DEDENT def _multi_get_tree_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . model . load_bulk ( BASE_DATA , node ) NEW_LINE # ▁ the ▁ tree ▁ was ▁ modified ▁ by ▁ load _ bulk , ▁ so ▁ we ▁ reload ▁ our ▁ node ▁ object ENDCOM node = self . model . objects . get ( pk = node . id ) NEW_LINE got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( node ) ] NEW_LINE expected = [ ( u ' 231' , 3 , 4 ) , ( u ' 1' , 4 , 0 ) , ( u ' 2' , 4 , 4 ) , ( u ' 21' , 5 , 0 ) , ( u ' 22' , 5 , 0 ) , ( u ' 23' , 5 , 1 ) , ( u ' 231' , 6 , 0 ) , ( u ' 24' , 5 , 0 ) , ( u ' 3' , 4 , 0 ) , ( u ' 4' , 4 , 1 ) , ( u ' 41' , 5 , 0 ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_get_tree_leaf ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE self . assertEqual ( 0 , node . get_children_count ( ) ) NEW_LINE got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( node ) ] NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_get_annotated_list_all ( self ) : NEW_LINE INDENT expected = [ ( u ' 1' , True , [ ] , 0 ) , ( u ' 2' , False , [ ] , 0 ) , ( u ' 21' , True , [ ] , 1 ) , ( u ' 22' , False , [ ] , 1 ) , ( u ' 23' , False , [ ] , 1 ) , ( u ' 231' , True , [ 0 ] , 2 ) , ( u ' 24' , False , [ 0 ] , 1 ) , ( u ' 3' , False , [ ] , 0 ) , ( u ' 4' , False , [ ] , 0 ) , ( u ' 41' , True , [ 0 , 1 ] , 1 ) ] NEW_LINE self . _assert_get_annotated_list ( expected ) NEW_LINE DEDENT def _multi_get_annotated_list_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 2' ) NEW_LINE expected = [ ( u ' 2' , True , [ ] , 0 ) , ( u ' 21' , True , [ ] , 1 ) , ( u ' 22' , False , [ ] , 1 ) , ( u ' 23' , False , [ ] , 1 ) , ( u ' 231' , True , [ 0 ] , 2 ) , ( u ' 24' , False , [ 0 , 1 ] , 1 ) ] NEW_LINE self . _assert_get_annotated_list ( expected , node ) NEW_LINE DEDENT def _multi_get_annotated_list_leaf ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE expected = [ ( u ' 1' , True , [ 0 ] , 0 ) ] NEW_LINE self . _assert_get_annotated_list ( expected , node ) NEW_LINE DEDENT def _multi_dump_bulk_node ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . model . load_bulk ( BASE_DATA , node ) NEW_LINE # ▁ the ▁ tree ▁ was ▁ modified ▁ by ▁ load _ bulk , ▁ so ▁ we ▁ reload ▁ our ▁ node ▁ object ENDCOM node = self . model . objects . get ( pk = node . id ) NEW_LINE got = self . model . dump_bulk ( node , False ) NEW_LINE expected = [ { ' data ' : { ' desc ' : u ' 231' } , ' children ' : BASE_DATA } ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_load_and_dump_bulk_keeping_ids ( self ) : NEW_LINE INDENT exp = self . model . dump_bulk ( keep_ids = True ) NEW_LINE self . model . objects . all ( ) . delete ( ) NEW_LINE self . model . load_bulk ( exp , None , True ) NEW_LINE got = self . model . dump_bulk ( keep_ids = True ) NEW_LINE self . assertEqual ( got , exp ) NEW_LINE # ▁ do ▁ we ▁ really ▁ have ▁ an ▁ unchaged ▁ tree ▁ after ▁ the ▁ dump / delete / load ? ENDCOM got = [ ( o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . model . get_tree ( ) ] NEW_LINE self . assertEqual ( got , self . unchanged ) NEW_LINE DEDENT def _multi_get_root_nodes ( self ) : NEW_LINE INDENT got = self . model . get_root_nodes ( ) NEW_LINE expected = [ '1' , '2' , '3' , '4' ] NEW_LINE self . assertEqual ( [ node . desc for node in got ] , expected ) NEW_LINE DEDENT def _multi_get_first_root_node ( self ) : NEW_LINE INDENT got = self . model . get_first_root_node ( ) NEW_LINE self . assertEqual ( got . desc , '1' ) NEW_LINE DEDENT def _multi_get_last_root_node ( self ) : NEW_LINE INDENT got = self . model . get_last_root_node ( ) NEW_LINE self . assertEqual ( got . desc , '4' ) NEW_LINE DEDENT def _multi_add_root ( self ) : NEW_LINE INDENT obj = self . model . add_root ( desc = '5' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE self . assertEqual ( self . model . get_last_root_node ( ) . desc , '5' ) NEW_LINE DEDENT DEDENT class TestSimpleNodeMethods ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_is_root ( self ) : NEW_LINE INDENT data = [ ( '2' , True ) , ( '1' , True ) , ( '4' , True ) , ( '21' , False ) , ( '24' , False ) , ( '22' , False ) , ( '231' , False ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . is_root ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_is_leaf ( self ) : NEW_LINE INDENT data = [ ( '2' , False ) , ( '23' , False ) , ( '231' , True ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . is_leaf ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_get_root ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' ) , ( '1' , '1' ) , ( '4' , '4' ) , ( '21' , '2' ) , ( '24' , '2' ) , ( '22' , '2' ) , ( '231' , '2' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_root ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT def _multi_get_parent ( self ) : NEW_LINE INDENT data = [ ( '2' , None ) , ( '1' , None ) , ( '4' , None ) , ( '21' , '2' ) , ( '24' , '2' ) , ( '22' , '2' ) , ( '231' , '23' ) , ] NEW_LINE data = dict ( data ) NEW_LINE objs = { } NEW_LINE for desc , expected in data . items ( ) : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) NEW_LINE parent = node . get_parent ( ) NEW_LINE if expected : NEW_LINE INDENT self . assertEqual ( parent . desc , expected ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( parent , None ) NEW_LINE DEDENT objs [ desc ] = node NEW_LINE # ▁ corrupt ▁ the ▁ objects ' ▁ parent ▁ cache ENDCOM node . _parent_obj = ' CORRUPTED ! ! ! ' NEW_LINE DEDENT for desc , expected in data . items ( ) : NEW_LINE INDENT node = objs [ desc ] NEW_LINE # ▁ asking ▁ get _ parent ▁ to ▁ not ▁ use ▁ the ▁ parent ▁ cache ▁ ( since ▁ we ENDCOM # ▁ corrupted ▁ it ▁ in ▁ the ▁ previous ▁ loop ) ENDCOM parent = node . get_parent ( True ) NEW_LINE if expected : NEW_LINE INDENT self . assertEqual ( parent . desc , expected ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( parent , None ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_children ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '21' , '22' , '23' , '24' ] ) , ( '23' , [ '231' ] ) , ( '231' , [ ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT children = self . model . objects . get ( desc = desc ) . get_children ( ) NEW_LINE self . assertEqual ( [ node . desc for node in children ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_children_count ( self ) : NEW_LINE INDENT data = [ ( '2' , 4 ) , ( '23' , 1 ) , ( '231' , 0 ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . get_children_count ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_get_siblings ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '1' , '2' , '3' , '4' ] ) , ( '21' , [ '21' , '22' , '23' , '24' ] ) , ( '231' , [ '231' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT siblings = self . model . objects . get ( desc = desc ) . get_siblings ( ) NEW_LINE self . assertEqual ( [ node . desc for node in siblings ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_first_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '1' ) , ( '1' , '1' ) , ( '4' , '1' ) , ( '21' , '21' ) , ( '24' , '21' ) , ( '22' , '21' ) , ( '231' , '231' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_first_sibling ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT def _multi_get_prev_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '1' ) , ( '1' , None ) , ( '4' , '3' ) , ( '21' , None ) , ( '24' , '23' ) , ( '22' , '21' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_prev_sibling ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_next_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '3' ) , ( '1' , '2' ) , ( '4' , None ) , ( '21' , '22' ) , ( '24' , None ) , ( '22' , '23' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_next_sibling ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_last_sibling ( self ) : NEW_LINE INDENT data = [ ( '2' , '4' ) , ( '1' , '4' ) , ( '4' , '4' ) , ( '21' , '24' ) , ( '24' , '24' ) , ( '22' , '24' ) , ( '231' , '231' ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_last_sibling ( ) NEW_LINE self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT def _multi_get_first_child ( self ) : NEW_LINE INDENT data = [ ( '2' , '21' ) , ( '21' , None ) , ( '23' , '231' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_first_child ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_last_child ( self ) : NEW_LINE INDENT data = [ ( '2' , '24' ) , ( '21' , None ) , ( '23' , '231' ) , ( '231' , None ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT node = self . model . objects . get ( desc = desc ) . get_last_child ( ) NEW_LINE if expected is None : NEW_LINE INDENT self . assertEqual ( node , None ) NEW_LINE DEDENT else : NEW_LINE INDENT self . assertEqual ( node . desc , expected ) NEW_LINE DEDENT DEDENT DEDENT def _multi_get_ancestors ( self ) : NEW_LINE INDENT data = [ ( '2' , [ ] ) , ( '21' , [ '2' ] ) , ( '231' , [ '2' , '23' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT nodes = self . model . objects . get ( desc = desc ) . get_ancestors ( ) NEW_LINE self . assertEqual ( [ node . desc for node in nodes ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_descendants ( self ) : NEW_LINE INDENT data = [ ( '2' , [ '21' , '22' , '23' , '231' , '24' ] ) , ( '23' , [ '231' ] ) , ( '231' , [ ] ) , ( '1' , [ ] ) , ( '4' , [ '41' ] ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT nodes = self . model . objects . get ( desc = desc ) . get_descendants ( ) NEW_LINE self . assertEqual ( [ node . desc for node in nodes ] , expected ) NEW_LINE DEDENT DEDENT def _multi_get_descendant_count ( self ) : NEW_LINE INDENT data = [ ( '2' , 5 ) , ( '23' , 1 ) , ( '231' , 0 ) , ( '1' , 0 ) , ( '4' , 1 ) , ] NEW_LINE for desc , expected in data : NEW_LINE INDENT got = self . model . objects . get ( desc = desc ) . get_descendant_count ( ) NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT def _multi_is_sibling_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , True ) , ( '2' , '1' , True ) , ( '21' , '2' , False ) , ( '231' , '2' , False ) , ( '22' , '23' , True ) , ( '231' , '23' , False ) , ( '231' , '231' , True ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_sibling_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT def _multi_is_child_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , False ) , ( '2' , '1' , False ) , ( '21' , '2' , True ) , ( '231' , '2' , False ) , ( '231' , '23' , True ) , ( '231' , '231' , False ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_child_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT def _multi_is_descendant_of ( self ) : NEW_LINE INDENT data = [ ( '2' , '2' , False ) , ( '2' , '1' , False ) , ( '21' , '2' , True ) , ( '231' , '2' , True ) , ( '231' , '23' , True ) , ( '231' , '231' , False ) , ] NEW_LINE for desc1 , desc2 , expected in data : NEW_LINE INDENT node1 = self . model . objects . get ( desc = desc1 ) NEW_LINE node2 = self . model . objects . get ( desc = desc2 ) NEW_LINE self . assertEqual ( node1 . is_descendant_of ( node2 ) , expected ) NEW_LINE DEDENT DEDENT DEDENT class TestAddChild ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_add_child_to_leaf ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . add_child ( desc = '2311' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 1 ) , ( u ' 2311' , 4 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_child_to_node ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 2' ) . add_child ( desc = '25' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 25' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestAddSibling ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_add_sibling_invalid_pos ( self ) : NEW_LINE INDENT method = self . model . objects . get ( desc = u ' 231' ) . add_sibling NEW_LINE self . assertRaises ( InvalidPosition , method , ' invalid _ pos ' ) NEW_LINE DEDENT def _multi_add_sibling_missing_nodeorderby ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE method = node_wchildren . add_sibling NEW_LINE self . assertRaises ( MissingNodeOrderBy , method , ' sorted - sibling ' , desc = ' aaa ' ) NEW_LINE DEDENT def _multi_add_sibling_last_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' last - sibling ' , desc = '5' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE self . assertEqual ( node_wchildren . get_last_sibling ( ) . desc , u ' 5' ) NEW_LINE DEDENT def _multi_add_sibling_last ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' last - sibling ' , desc = '232' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE self . assertEqual ( node . get_last_sibling ( ) . desc , u ' 232' ) NEW_LINE DEDENT def _multi_add_sibling_first_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' first - sibling ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' new ' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_first ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' first - sibling ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' new ' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' new ' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' new ' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left_noleft_root ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 1' ) NEW_LINE obj = node . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' new ' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_left_noleft ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' left ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' new ' , 3 , 0 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right_root ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 2' ) NEW_LINE obj = node_wchildren . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' new ' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right ( self ) : NEW_LINE INDENT node_wchildren = self . model . objects . get ( desc = u ' 23' ) NEW_LINE obj = node_wchildren . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 2 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' new ' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right_noright_root ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 4' ) NEW_LINE obj = node . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 1 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' new ' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_sibling_right_noright ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE obj = node . add_sibling ( ' right ' , desc = ' new ' ) NEW_LINE self . assertEqual ( obj . get_depth ( ) , 3 ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 231' , 3 , 0 ) , ( u ' new ' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestDelete ( TestNonEmptyTree ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestDelete , self ) . setUp ( ) NEW_LINE for node in self . model . objects . all ( ) : NEW_LINE INDENT self . dep_model ( node = node ) . save ( ) NEW_LINE DEDENT DEDENT def _multi_delete_leaf ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_node ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 23' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 3 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 2' ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_filter_root_nodes ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '3' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_filter_children ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '23' , '231' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_nonexistant_nodes ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( ' ZZZ ' , ' XXX ' ) ) . delete ( ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_delete_same_node_twice ( self ) : NEW_LINE INDENT self . model . objects . filter ( desc__in = ( '2' , '2' ) ) . delete ( ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_delete_all_root_nodes ( self ) : NEW_LINE INDENT self . model . get_root_nodes ( ) . delete ( ) NEW_LINE count = self . model . objects . count ( ) NEW_LINE self . assertEqual ( count , 0 ) NEW_LINE DEDENT def _multi_delete_all_nodes ( self ) : NEW_LINE INDENT self . model . objects . all ( ) . delete ( ) NEW_LINE count = self . model . objects . count ( ) NEW_LINE self . assertEqual ( count , 0 ) NEW_LINE DEDENT DEDENT class TestMoveErrors ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_invalid_pos ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( InvalidPosition , node . move , node , ' invalid _ pos ' ) NEW_LINE DEDENT def _multi_move_to_descendant ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 2' ) NEW_LINE target = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( InvalidMoveToDescendant , node . move , target , ' first - sibling ' ) NEW_LINE DEDENT def _multi_move_missing_nodeorderby ( self ) : NEW_LINE INDENT node = self . model . objects . get ( desc = u ' 231' ) NEW_LINE self . assertRaises ( MissingNodeOrderBy , node . move , node , ' sorted - child ' ) NEW_LINE self . assertRaises ( MissingNodeOrderBy , node . move , node , ' sorted - sibling ' ) NEW_LINE DEDENT DEDENT class TestMoveSortedErrors ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_nonsorted_move_in_sorted ( self ) : NEW_LINE INDENT node = self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . assertRaises ( InvalidPosition , node . move , node , ' left ' ) NEW_LINE DEDENT DEDENT class TestMoveLeafRoot ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_leaf_last_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 231' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 231' , 1 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_left_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 231' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_right_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 1 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_last_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 2' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 231' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMoveLeaf ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_leaf_last_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 231' , 2 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_left_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_right_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 231' , 2 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_left_sibling_itself ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 231' ) , ' left ' ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_move_leaf_last_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_leaf_first_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = u ' 231' ) . move ( self . model . objects . get ( desc = u ' 22' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 23' , 2 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMoveBranchRoot ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_branch_first_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_noleft_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) . get_first_sibling ( ) , ' left ' ) NEW_LINE expected = [ ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) , ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_noright_sibling_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) . get_last_sibling ( ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) , ( u ' 4' , 1 , 1 ) , ( u ' 41' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_first_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_child_root ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '2' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMoveBranch ( TestNonEmptyTree ) : NEW_LINE INDENT def _multi_move_branch_first_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' first - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' last - sibling ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_noleft_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) . get_first_sibling ( ) , ' left ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_right_noright_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) . get_last_sibling ( ) , ' right ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 5 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 1 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 4' , 2 , 1 ) , ( u ' 41' , 3 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_left_itself_sibling ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '4' ) , ' left ' ) NEW_LINE self . assertEqual ( self . got ( ) , self . unchanged ) NEW_LINE DEDENT def _multi_move_branch_first_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' first - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 4' , 3 , 1 ) , ( u ' 41' , 4 , 0 ) , ( u ' 231' , 3 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_branch_last_child ( self ) : NEW_LINE INDENT self . model . objects . get ( desc = '4' ) . move ( self . model . objects . get ( desc = '23' ) , ' last - child ' ) NEW_LINE expected = [ ( u ' 1' , 1 , 0 ) , ( u ' 2' , 1 , 4 ) , ( u ' 21' , 2 , 0 ) , ( u ' 22' , 2 , 0 ) , ( u ' 23' , 2 , 2 ) , ( u ' 231' , 3 , 0 ) , ( u ' 4' , 3 , 1 ) , ( u ' 41' , 4 , 0 ) , ( u ' 24' , 2 , 0 ) , ( u ' 3' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestTreeSorted ( TestTreeBase ) : NEW_LINE INDENT def got ( self ) : NEW_LINE INDENT return [ ( o . val1 , o . val2 , o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in self . sorted_model . get_tree ( ) ] NEW_LINE DEDENT def _multi_add_root_sorted ( self ) : NEW_LINE INDENT self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE expected = [ ( 1 , 4 , u ' bcd ' , 1 , 0 ) , ( 2 , 2 , u ' qwe ' , 1 , 0 ) , ( 2 , 5 , u ' zxy ' , 1 , 0 ) , ( 3 , 2 , u ' vcx ' , 1 , 0 ) , ( 3 , 3 , u ' abc ' , 1 , 0 ) , ( 3 , 3 , u ' abc ' , 1 , 0 ) , ( 3 , 3 , u ' zxy ' , 1 , 0 ) , ( 4 , 1 , u ' fgh ' , 1 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_child_root_sorted ( self ) : NEW_LINE INDENT root = self . sorted_model . add_root ( val1 = 0 , val2 = 0 , desc = ' aaa ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE root . add_child ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE root . add_child ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE root . add_child ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE root . add_child ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE root . add_child ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE expected = [ ( 0 , 0 , u ' aaa ' , 1 , 8 ) , ( 1 , 4 , u ' bcd ' , 2 , 0 ) , ( 2 , 2 , u ' qwe ' , 2 , 0 ) , ( 2 , 5 , u ' zxy ' , 2 , 0 ) , ( 3 , 2 , u ' vcx ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' zxy ' , 2 , 0 ) , ( 4 , 1 , u ' fgh ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_add_child_nonroot_sorted ( self ) : NEW_LINE INDENT get_node = lambda node_id : self . sorted_model . objects . get ( pk = node_id ) NEW_LINE root_id = self . sorted_model . add_root ( val1 = 0 , val2 = 0 , desc = ' a ' ) . id NEW_LINE node_id = get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' ac ' ) . id NEW_LINE get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' aa ' ) NEW_LINE get_node ( root_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' av ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' aca ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' acc ' ) NEW_LINE get_node ( node_id ) . add_child ( val1 = 0 , val2 = 0 , desc = ' acb ' ) NEW_LINE expected = [ ( 0 , 0 , u ' a ' , 1 , 3 ) , ( 0 , 0 , u ' aa ' , 2 , 0 ) , ( 0 , 0 , u ' ac ' , 2 , 3 ) , ( 0 , 0 , u ' aca ' , 3 , 0 ) , ( 0 , 0 , u ' acb ' , 3 , 0 ) , ( 0 , 0 , u ' acc ' , 3 , 0 ) , ( 0 , 0 , u ' av ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT def _multi_move_sorted ( self ) : NEW_LINE INDENT self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 1 , val2 = 4 , desc = ' bcd ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 5 , desc = ' zxy ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 4 , val2 = 1 , desc = ' fgh ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 3 , desc = ' abc ' ) NEW_LINE self . sorted_model . add_root ( val1 = 2 , val2 = 2 , desc = ' qwe ' ) NEW_LINE self . sorted_model . add_root ( val1 = 3 , val2 = 2 , desc = ' vcx ' ) NEW_LINE root_nodes = self . sorted_model . get_root_nodes ( ) NEW_LINE target = root_nodes [ 0 ] NEW_LINE for node in root_nodes [ 1 : ] : NEW_LINE # ▁ because ▁ raw ▁ queries ▁ don ' t ▁ update ▁ django ▁ objects ENDCOM INDENT node = self . sorted_model . objects . get ( pk = node . id ) NEW_LINE target = self . sorted_model . objects . get ( pk = target . id ) NEW_LINE node . move ( target , ' sorted - child ' ) NEW_LINE DEDENT expected = [ ( 1 , 4 , u ' bcd ' , 1 , 7 ) , ( 2 , 2 , u ' qwe ' , 2 , 0 ) , ( 2 , 5 , u ' zxy ' , 2 , 0 ) , ( 3 , 2 , u ' vcx ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' abc ' , 2 , 0 ) , ( 3 , 3 , u ' zxy ' , 2 , 0 ) , ( 4 , 1 , u ' fgh ' , 2 , 0 ) ] NEW_LINE self . assertEqual ( self . got ( ) , expected ) NEW_LINE DEDENT DEDENT class TestMP_TreeAlphabet ( TestCase ) : NEW_LINE INDENT def test_alphabet ( self ) : NEW_LINE INDENT if not os . getenv ( ' TREEBEARD _ TEST _ ALPHABET ' , False ) : NEW_LINE # ▁ run ▁ this ▁ test ▁ only ▁ if ▁ the ▁ enviroment ▁ variable ▁ is ▁ set ENDCOM INDENT return NEW_LINE DEDENT basealpha = numconv . BASE85 NEW_LINE got_err = False NEW_LINE last_good = None NEW_LINE for alphabetlen in range ( 35 , len ( basealpha ) + 1 ) : NEW_LINE INDENT alphabet = basealpha [ 0 : alphabetlen ] NEW_LINE expected = [ alphabet [ 0 ] + char for char in alphabet [ 1 : ] ] NEW_LINE expected . extend ( [ alphabet [ 1 ] + char for char in alphabet ] ) NEW_LINE expected . append ( alphabet [ 2 ] + alphabet [ 0 ] ) NEW_LINE # ▁ remove ▁ all ▁ nodes ENDCOM MP_TestNodeAlphabet . objects . all ( ) . delete ( ) NEW_LINE # ▁ change ▁ the ▁ model ' s ▁ alphabet ENDCOM MP_TestNodeAlphabet . alphabet = alphabet NEW_LINE # ▁ insert ▁ root ▁ nodes ENDCOM for pos in range ( len ( alphabet ) * 2 ) : NEW_LINE INDENT try : NEW_LINE INDENT MP_TestNodeAlphabet . add_root ( numval = pos ) NEW_LINE DEDENT except : NEW_LINE INDENT got_err = True NEW_LINE break NEW_LINE DEDENT DEDENT if got_err : NEW_LINE INDENT break NEW_LINE DEDENT got = [ obj . path for obj in MP_TestNodeAlphabet . objects . all ( ) ] NEW_LINE if got != expected : NEW_LINE INDENT got_err = True NEW_LINE DEDENT last_good = alphabet NEW_LINE DEDENT print ' \n The ▁ best ▁ BASE85 ▁ based ▁ alphabet ▁ for ▁ your ▁ setup ▁ is : ▁ % s ' % ( last_good , ) NEW_LINE DEDENT DEDENT class TestHelpers ( TestTreeBase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT for model in ( MP_TestNode , AL_TestNode , NS_TestNode ) : NEW_LINE INDENT model . load_bulk ( BASE_DATA ) NEW_LINE for node in model . get_root_nodes ( ) : NEW_LINE INDENT model . load_bulk ( BASE_DATA , node ) NEW_LINE DEDENT model . add_root ( desc = '5' ) NEW_LINE DEDENT DEDENT def _multi_descendants_group_count_root ( self ) : NEW_LINE INDENT expected = [ ( o . desc , o . get_descendant_count ( ) ) for o in self . model . get_root_nodes ( ) ] NEW_LINE got = [ ( o . desc , o . descendants_count ) for o in self . model . get_descendants_group_count ( ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT def _multi_descendants_group_count_node ( self ) : NEW_LINE INDENT parent = self . model . get_root_nodes ( ) . get ( desc = '2' ) NEW_LINE expected = [ ( o . desc , o . get_descendant_count ( ) ) for o in parent . get_children ( ) ] NEW_LINE got = [ ( o . desc , o . descendants_count ) for o in self . model . get_descendants_group_count ( parent ) ] NEW_LINE self . assertEqual ( got , expected ) NEW_LINE DEDENT DEDENT class TestMP_TreeSortedAutoNow ( TestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ sorting ▁ mechanism ▁ used ▁ by ▁ treebeard ▁ when ▁ adding ▁ a ▁ node ▁ can ▁ fail ▁ if ▁ the STRNEWLINE ▁ ordering ▁ is ▁ using ▁ an ▁ " auto _ now " ▁ field STRNEWLINE ▁ """ NEW_LINE def test_sorted_by_autonow_workaround ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ workaround STRNEWLINE ▁ """ NEW_LINE import datetime NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT MP_TestNodeSortedAutoNow . add_root ( desc = ' node % d ' % ( i , ) , created = datetime . datetime . now ( ) ) NEW_LINE DEDENT DEDENT def test_sorted_by_autonow_FAIL ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ test ▁ asserts ▁ that ▁ we ▁ have ▁ a ▁ problem . STRNEWLINE ▁ fix ▁ this , ▁ somehow STRNEWLINE ▁ """ NEW_LINE MP_TestNodeSortedAutoNow . add_root ( desc = ' node1' ) NEW_LINE self . assertRaises ( ValueError , MP_TestNodeSortedAutoNow . add_root , desc = ' node2' ) NEW_LINE DEDENT DEDENT class TestMP_TreeStepOverflow ( TestCase ) : NEW_LINE INDENT def test_add_root ( self ) : NEW_LINE INDENT method = MP_TestNodeSmallStep . add_root NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT method ( ) NEW_LINE DEDENT self . assertRaises ( PathOverflow , method ) NEW_LINE DEDENT def test_add_child ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE method = root . add_child NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT method ( ) NEW_LINE DEDENT self . assertRaises ( PathOverflow , method ) NEW_LINE DEDENT def test_add_sibling ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT root . add_child ( ) NEW_LINE DEDENT method = root . get_last_child ( ) . add_sibling NEW_LINE positions = ( ' first - sibling ' , ' left ' , ' right ' , ' last - sibling ' ) NEW_LINE for pos in positions : NEW_LINE INDENT self . assertRaises ( PathOverflow , method , pos ) NEW_LINE DEDENT DEDENT def test_move ( self ) : NEW_LINE INDENT root = MP_TestNodeSmallStep . add_root ( ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT root . add_child ( ) NEW_LINE DEDENT newroot = MP_TestNodeSmallStep . add_root ( ) NEW_LINE targets = [ ( root , [ ' first - child ' , ' last - child ' ] ) , ( root . get_first_child ( ) , [ ' first - sibling ' , ' left ' , ' right ' , ' last - sibling ' ] ) ] NEW_LINE for target , positions in targets : NEW_LINE INDENT for pos in positions : NEW_LINE INDENT self . assertRaises ( PathOverflow , newroot . move , target , pos ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class TestMP_TreeShortPath ( TestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Here ▁ we ▁ test ▁ a ▁ tree ▁ with ▁ a ▁ very ▁ small ▁ path ▁ field ▁ ( max _ length = 4 ) ▁ and ▁ a STRNEWLINE ▁ steplen ▁ of ▁ 1 STRNEWLINE ▁ """ NEW_LINE def test_short_path ( self ) : NEW_LINE INDENT obj = MP_TestNodeShortPath . add_root ( ) NEW_LINE obj = obj . add_child ( ) . add_child ( ) . add_child ( ) NEW_LINE self . assertRaises ( PathOverflow , obj . add_child ) NEW_LINE DEDENT DEDENT class TestMP_TreeFindProblems ( TestTreeBase ) : NEW_LINE INDENT def test_find_problems ( self ) : NEW_LINE INDENT model = MP_TestNodeAlphabet NEW_LINE model . alphabet = '01234' NEW_LINE model ( path = '01' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '1' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '111' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = ' abcd ' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = ' qa # $ % ! ' , depth = 1 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0201' , depth = 2 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '020201' , depth = 3 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '03' , depth = 1 , numchild = 2 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0301' , depth = 2 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE model ( path = '030102' , depth = 3 , numchild = 10 , numval = 0 ) . save ( ) NEW_LINE model ( path = '04' , depth = 10 , numchild = 1 , numval = 0 ) . save ( ) NEW_LINE model ( path = '0401' , depth = 20 , numchild = 0 , numval = 0 ) . save ( ) NEW_LINE evil_chars , bad_steplen , orphans , wrong_depth , wrong_numchild = model . find_problems ( ) NEW_LINE self . assertEqual ( [ ' abcd ' , ' qa # $ % ! ' ] , [ o . path for o in model . objects . filter ( id__in = evil_chars ) ] ) NEW_LINE self . assertEqual ( [ '1' , '111' ] , [ o . path for o in model . objects . filter ( id__in = bad_steplen ) ] ) NEW_LINE self . assertEqual ( [ '0201' , '020201' ] , [ o . path for o in model . objects . filter ( id__in = orphans ) ] ) NEW_LINE self . assertEqual ( [ '03' , '0301' , '030102' ] , [ o . path for o in model . objects . filter ( id__in = wrong_numchild ) ] ) NEW_LINE self . assertEqual ( [ '04' , '0401' ] , [ o . path for o in model . objects . filter ( id__in = wrong_depth ) ] ) NEW_LINE DEDENT DEDENT class TestMP_TreeFix ( TestTreeBase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT super ( TestMP_TreeFix , self ) . setUp ( ) NEW_LINE self . expected_no_holes = { MP_TestNodeShortPath : [ ( u ' 1' , u ' b ' , 1 , 2 ) , ( u ' 11' , u ' u ' , 2 , 1 ) , ( u ' 111' , u ' i ' , 3 , 1 ) , ( u ' 1111' , u ' e ' , 4 , 0 ) , ( u ' 12' , u ' o ' , 2 , 0 ) , ( u ' 2' , u ' d ' , 1 , 0 ) , ( u ' 3' , u ' g ' , 1 , 0 ) , ( u ' 4' , u ' a ' , 1 , 4 ) , ( u ' 41' , u ' a ' , 2 , 0 ) , ( u ' 42' , u ' a ' , 2 , 0 ) , ( u ' 43' , u ' u ' , 2 , 1 ) , ( u ' 431' , u ' i ' , 3 , 1 ) , ( u ' 4311' , u ' e ' , 4 , 0 ) , ( u ' 44' , u ' o ' , 2 , 0 ) ] , MP_TestSortedNodeShortPath : [ ( u ' 1' , u ' a ' , 1 , 4 ) , ( u ' 11' , u ' a ' , 2 , 0 ) , ( u ' 12' , u ' a ' , 2 , 0 ) , ( u ' 13' , u ' o ' , 2 , 0 ) , ( u ' 14' , u ' u ' , 2 , 1 ) , ( u ' 141' , u ' i ' , 3 , 1 ) , ( u ' 1411' , u ' e ' , 4 , 0 ) , ( u ' 2' , u ' b ' , 1 , 2 ) , ( u ' 21' , u ' o ' , 2 , 0 ) , ( u ' 22' , u ' u ' , 2 , 1 ) , ( u ' 221' , u ' i ' , 3 , 1 ) , ( u ' 2211' , u ' e ' , 4 , 0 ) , ( u ' 3' , u ' d ' , 1 , 0 ) , ( u ' 4' , u ' g ' , 1 , 0 ) ] } NEW_LINE self . expected_with_holes = { MP_TestNodeShortPath : [ ( u ' 1' , u ' b ' , 1 L , 2 L ) , ( u ' 13' , u ' u ' , 2 L , 1 L ) , ( u ' 134' , u ' i ' , 3 L , 1 L ) , ( u ' 1343' , u ' e ' , 4 L , 0 L ) , ( u ' 14' , u ' o ' , 2 L , 0 L ) , ( u ' 2' , u ' d ' , 1 L , 0 L ) , ( u ' 3' , u ' g ' , 1 L , 0 L ) , ( u ' 4' , u ' a ' , 1 L , 4 L ) , ( u ' 41' , u ' a ' , 2 L , 0 L ) , ( u ' 42' , u ' a ' , 2 L , 0 L ) , ( u ' 43' , u ' u ' , 2 L , 1 L ) , ( u ' 434' , u ' i ' , 3 L , 1 L ) , ( u ' 4343' , u ' e ' , 4 L , 0 L ) , ( u ' 44' , u ' o ' , 2 L , 0 L ) ] , MP_TestSortedNodeShortPath : [ ( u ' 1' , u ' b ' , 1 L , 2 L ) , ( u ' 13' , u ' u ' , 2 L , 1 L ) , ( u ' 134' , u ' i ' , 3 L , 1 L ) , ( u ' 1343' , u ' e ' , 4 L , 0 L ) , ( u ' 14' , u ' o ' , 2 L , 0 L ) , ( u ' 2' , u ' d ' , 1 L , 0 L ) , ( u ' 3' , u ' g ' , 1 L , 0 L ) , ( u ' 4' , u ' a ' , 1 L , 4 L ) , ( u ' 41' , u ' a ' , 2 L , 0 L ) , ( u ' 42' , u ' a ' , 2 L , 0 L ) , ( u ' 43' , u ' u ' , 2 L , 1 L ) , ( u ' 434' , u ' i ' , 3 L , 1 L ) , ( u ' 4343' , u ' e ' , 4 L , 0 L ) , ( u ' 44' , u ' o ' , 2 L , 0 L ) ] } NEW_LINE DEDENT def got ( self , model ) : NEW_LINE INDENT return [ ( o . path , o . desc , o . get_depth ( ) , o . get_children_count ( ) ) for o in model . get_tree ( ) ] NEW_LINE DEDENT def add_broken_test_data ( self , model ) : NEW_LINE INDENT model ( path = '4' , depth = 2 , numchild = 2 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '13' , depth = 1000 , numchild = 0 , desc = ' u ' ) . save ( ) NEW_LINE model ( path = '14' , depth = 4 , numchild = 500 , desc = ' o ' ) . save ( ) NEW_LINE model ( path = '134' , depth = 321 , numchild = 543 , desc = ' i ' ) . save ( ) NEW_LINE model ( path = '1343' , depth = 321 , numchild = 543 , desc = ' e ' ) . save ( ) NEW_LINE model ( path = '42' , depth = 1 , numchild = 1 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '43' , depth = 1000 , numchild = 0 , desc = ' u ' ) . save ( ) NEW_LINE model ( path = '44' , depth = 4 , numchild = 500 , desc = ' o ' ) . save ( ) NEW_LINE model ( path = '434' , depth = 321 , numchild = 543 , desc = ' i ' ) . save ( ) NEW_LINE model ( path = '4343' , depth = 321 , numchild = 543 , desc = ' e ' ) . save ( ) NEW_LINE model ( path = '41' , depth = 1 , numchild = 1 , desc = ' a ' ) . save ( ) NEW_LINE model ( path = '3' , depth = 221 , numchild = 322 , desc = ' g ' ) . save ( ) NEW_LINE model ( path = '1' , depth = 10 , numchild = 3 , desc = ' b ' ) . save ( ) NEW_LINE model ( path = '2' , depth = 10 , numchild = 3 , desc = ' d ' ) . save ( ) NEW_LINE DEDENT def test_fix_tree_non_destructive ( self ) : NEW_LINE INDENT for model in ( MP_TestNodeShortPath , MP_TestSortedNodeShortPath ) : NEW_LINE INDENT self . add_broken_test_data ( model ) NEW_LINE model . fix_tree ( destructive = False ) NEW_LINE self . assertEqual ( self . got ( model ) , self . expected_with_holes [ model ] ) NEW_LINE model . find_problems ( ) NEW_LINE DEDENT DEDENT def test_fix_tree_destructive ( self ) : NEW_LINE INDENT for model in ( MP_TestNodeShortPath , MP_TestSortedNodeShortPath ) : NEW_LINE INDENT self . add_broken_test_data ( model ) NEW_LINE model . fix_tree ( destructive = True ) NEW_LINE self . assertEqual ( self . got ( model ) , self . expected_no_holes [ model ] ) NEW_LINE model . find_problems ( ) NEW_LINE DEDENT DEDENT DEDENT class TestIssues ( TestCase ) : NEW_LINE INDENT " test ▁ for ▁ http : / / code . google . com / p / django - treebeard / issues / detail ? id = 14" NEW_LINE def test_many_to_many_django_user_anonymous ( self ) : NEW_LINE INDENT if not HAS_DJANGO_AUTH : # ▁ pragma : ▁ no ▁ cover ENDCOM NEW_LINE INDENT self . fail ( ' this ▁ test ▁ needs ▁ django . contrib . auth ▁ in ▁ INSTALLED _ APPS ' ) NEW_LINE # ▁ Using ▁ AnonymousUser ( ) ▁ in ▁ the ▁ querysets ▁ will ▁ expose ▁ non - treebeard ENDCOM # ▁ related ▁ problems ▁ in ▁ Django ▁ 1.0 ENDCOM # ▁ Postgres : ENDCOM # ▁ ProgrammingError : ▁ can ' t ▁ adapt ENDCOM # ▁ SQLite : ENDCOM # ▁ InterfaceError : ▁ Error ▁ binding ▁ parameter ▁ 4 ▁ - ▁ probably ▁ unsupported ENDCOM # ▁ type . ENDCOM # ▁ MySQL ▁ compared ▁ a ▁ string ▁ to ▁ an ▁ integer ▁ field : ENDCOM # ▁ ` treebeard _ mp _ testissue14 _ users ` . ` user _ id ` ▁ = ▁ ' AnonymousUser ' ENDCOM # ▁ Using ▁ a ▁ None ▁ field ▁ instead ▁ works ▁ ( will ▁ be ▁ translated ▁ to ▁ IS ▁ NULL ) . ENDCOM # ▁ anonuserobj ▁ = ▁ AnonymousUser ( ) ENDCOM DEDENT anonuserobj = None NEW_LINE def qs_check ( qs , expected ) : NEW_LINE INDENT self . assertEqual ( [ o . name for o in qs ] , expected ) NEW_LINE DEDENT user = User . objects . create_user ( ' test _ user ' , ' test @ example . com ' , ' testpasswd ' ) NEW_LINE user . save ( ) NEW_LINE root = MP_TestIssue14 . add_root ( name = " the ▁ root ▁ node " ) NEW_LINE root . add_child ( name = " first " ) NEW_LINE second = root . add_child ( name = " second " ) NEW_LINE qs_check ( root . get_children ( ) , [ ' first ' , ' second ' ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) ) , [ ' first ' ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( users = user ) ) , [ ] ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' ] ) NEW_LINE user = anonuserobj NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' , ' second ' ] ) NEW_LINE user = User . objects . get ( username = " test _ user " ) NEW_LINE second . users . add ( user ) NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' , ' second ' ] ) NEW_LINE user = anonuserobj NEW_LINE qs_check ( root . get_children ( ) . filter ( Q ( name = " first " ) | Q ( users = user ) ) , [ ' first ' ] ) NEW_LINE DEDENT DEDENT class TestModelAdmin ( ModelAdmin ) : NEW_LINE INDENT form = MoveNodeForm NEW_LINE DEDENT class TestMoveNodeForm ( TestTreeBase ) : NEW_LINE INDENT tpl = ( u ' < tr > < th > < label ▁ for = " id _ _ position " > Position : < / label > < / th > ' ' < td > < select ▁ name = " _ position " ▁ id = " id _ _ position " > \n ' ' < option ▁ value = " first - child " > First ▁ child ▁ of < / option > \n ' ' < option ▁ value = " left " > Before < / option > \n ' ' < option ▁ value = " right " > After < / option > \n ' ' < / select > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ ref _ node _ id " > Relative ▁ to : < / label > ' ' < / th > < td > < select ▁ name = " _ ref _ node _ id " ▁ id = " id _ _ ref _ node _ id " > \n ' ' < option ▁ value = " 0 " > - - ▁ root ▁ - - < / option > \n ' ) NEW_LINE def _multi_form_html_root_node ( self ) : NEW_LINE INDENT self . model . load_bulk ( BASE_DATA ) NEW_LINE node = self . model . get_tree ( ) [ 0 ] NEW_LINE form = MoveNodeForm ( instance = node ) NEW_LINE rtpl = self . tpl NEW_LINE self . assertEqual ( [ ' _ position ' , ' _ ref _ node _ id ' ] , form . base_fields . keys ( ) ) NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT if node != obj or obj . is_descendant_of ( node ) : NEW_LINE INDENT rtpl += ' < option ▁ value = " % d " > % sNode ▁ % d < / option > \n ' % ( obj . id , ' . ▁ . ▁ ' * ( obj . get_depth ( ) - 1 ) , obj . id ) NEW_LINE DEDENT DEDENT rtpl += ' < / select > < / td > < / tr > ' NEW_LINE formstr = unicode ( form ) . replace ( u ' ▁ selected = " selected " ' , u ' ' ) NEW_LINE self . assertEqual ( rtpl , formstr ) NEW_LINE DEDENT def _multi_form_html_leaf_node ( self ) : NEW_LINE INDENT self . model . load_bulk ( BASE_DATA ) NEW_LINE nodes = list ( self . model . get_tree ( ) ) NEW_LINE node = nodes [ - 1 ] NEW_LINE form = MoveNodeForm ( instance = node ) NEW_LINE rtpl = self . tpl NEW_LINE self . assertEqual ( [ ' _ position ' , ' _ ref _ node _ id ' ] , form . base_fields . keys ( ) ) NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT if node != obj or obj . is_descendant_of ( node ) : NEW_LINE INDENT rtpl += ' < option ▁ value = " % d " > % sNode ▁ % d < / option > \n ' % ( obj . id , ' . ▁ . ▁ ' * ( obj . get_depth ( ) - 1 ) , obj . id ) NEW_LINE DEDENT DEDENT rtpl += ' < / select > < / td > < / tr > ' NEW_LINE formstr = unicode ( form ) . replace ( u ' ▁ selected = " selected " ' , u ' ' ) NEW_LINE self . assertEqual ( rtpl , formstr ) NEW_LINE DEDENT def _multi_admin_html ( self ) : NEW_LINE INDENT tpl = ( ' < tr > < th > < label ▁ for = " id _ desc " > Desc : < / label > ' ' < / th > < td > < input ▁ id = " id _ desc " ▁ type = " text " ▁ class = " vTextField " ▁ ' ' name = " desc " ▁ maxlength = " 255 " ▁ / > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ position " > Position : < / label > < / th > ' ' < td > < select ▁ name = " _ position " ▁ id = " id _ _ position " > \n ' ' < option ▁ value = " first - child " > First ▁ child ▁ of < / option > \n ' ' < option ▁ value = " left " > Before < / option > \n ' ' < option ▁ value = " right " > After < / option > \n ' ' < / select > < / td > < / tr > \n ' ' < tr > < th > < label ▁ for = " id _ _ ref _ node _ id " > Relative ▁ to : < / label > ' ' < / th > < td > < select ▁ name = " _ ref _ node _ id " ▁ id = " id _ _ ref _ node _ id " > \n ' ' < option ▁ value = " 0 " > - - ▁ root ▁ - - < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > Node ▁ % d < / option > \n ' ' < option ▁ value = " % d " > . ▁ . ▁ Node ▁ % d < / option > \n ' ' < / select > < / td > < / tr > ' ) NEW_LINE request = None NEW_LINE self . model . load_bulk ( BASE_DATA ) NEW_LINE for node in self . model . objects . all ( ) : NEW_LINE INDENT site = AdminSite ( ) NEW_LINE ma = TestModelAdmin ( self . model , site ) NEW_LINE self . assertEqual ( [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] , ma . get_form ( request ) . base_fields . keys ( ) ) NEW_LINE self . assertEqual ( [ ( None , { ' fields ' : [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] } ) ] , ma . get_fieldsets ( request ) ) NEW_LINE self . assertEqual ( [ ( None , { ' fields ' : [ ' desc ' , ' _ position ' , ' _ ref _ node _ id ' ] } ) ] , ma . get_fieldsets ( request , node ) ) NEW_LINE form = ma . get_form ( request ) ( ) NEW_LINE ids = [ ] NEW_LINE for obj in self . model . get_tree ( ) : NEW_LINE INDENT ids . extend ( [ obj . id ] * 2 ) NEW_LINE DEDENT self . assertEqual ( tpl % tuple ( ids ) , unicode ( form ) ) NEW_LINE DEDENT DEDENT DEDENT _load_test_methods ( TestMoveNodeForm ) NEW_LINE _load_test_methods ( TestEmptyTree ) NEW_LINE _load_test_methods ( TestClassMethods ) NEW_LINE _load_test_methods ( TestSimpleNodeMethods ) NEW_LINE _load_test_methods ( TestAddChild ) NEW_LINE _load_test_methods ( TestAddSibling ) NEW_LINE _load_test_methods ( TestDelete ) NEW_LINE _load_test_methods ( TestMoveErrors ) NEW_LINE _load_test_methods ( TestMoveLeafRoot ) NEW_LINE _load_test_methods ( TestMoveLeaf ) NEW_LINE _load_test_methods ( TestMoveBranchRoot ) NEW_LINE _load_test_methods ( TestMoveBranch ) NEW_LINE _load_test_methods ( TestHelpers ) NEW_LINE # ▁ we ▁ didn ' t ▁ create ▁ extra ▁ sorted - proxy ▁ models ENDCOM _load_test_methods ( TestMoveSortedErrors , proxy = False ) NEW_LINE _load_test_methods ( TestTreeSorted , proxy = False ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="jonathonwalz/ansible/tree/master/test/units/modules/network/f5/test_bigip_iapp_service.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ Copyright ▁ 2017 ▁ F5 ▁ Networks ▁ Inc . ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Ansible ENDCOM # ▁ Ansible ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ Ansible ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ Ansible . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM from __future__ import ( absolute_import , division , print_function ) NEW_LINE __metaclass__ = type NEW_LINE import os NEW_LINE import json NEW_LINE import sys NEW_LINE from nose . plugins . skip import SkipTest NEW_LINE if sys . version_info < ( 2 , 7 ) : NEW_LINE INDENT raise SkipTest ( " F5 ▁ Ansible ▁ modules ▁ require ▁ Python ▁ > = ▁ 2.7" ) NEW_LINE DEDENT from ansible . compat . tests import unittest NEW_LINE from ansible . compat . tests . mock import patch , Mock NEW_LINE from ansible . module_utils import basic NEW_LINE from ansible . module_utils . _text import to_bytes NEW_LINE from ansible . module_utils . f5_utils import AnsibleF5Client NEW_LINE try : NEW_LINE INDENT from library . bigip_iapp_service import Parameters NEW_LINE from library . bigip_iapp_service import ModuleManager NEW_LINE from library . bigip_iapp_service import ArgumentSpec NEW_LINE DEDENT except ImportError : NEW_LINE INDENT try : NEW_LINE INDENT from ansible . modules . network . f5 . bigip_iapp_service import Parameters NEW_LINE from ansible . modules . network . f5 . bigip_iapp_service import ModuleManager NEW_LINE from ansible . modules . network . f5 . bigip_iapp_service import ArgumentSpec NEW_LINE DEDENT except ImportError : NEW_LINE INDENT raise SkipTest ( " F5 ▁ Ansible ▁ modules ▁ require ▁ the ▁ f5 - sdk ▁ Python ▁ library " ) NEW_LINE DEDENT DEDENT fixture_path = os . path . join ( os . path . dirname ( __file__ ) , ' fixtures ' ) NEW_LINE fixture_data = { } NEW_LINE def set_module_args ( args ) : NEW_LINE INDENT args = json . dumps ( { ' ANSIBLE _ MODULE _ ARGS ' : args } ) NEW_LINE basic . _ANSIBLE_ARGS = to_bytes ( args ) NEW_LINE DEDENT def load_fixture ( name ) : NEW_LINE INDENT path = os . path . join ( fixture_path , name ) NEW_LINE if path in fixture_data : NEW_LINE INDENT return fixture_data [ path ] NEW_LINE DEDENT with open ( path ) as f : NEW_LINE INDENT data = f . read ( ) NEW_LINE DEDENT try : NEW_LINE INDENT data = json . loads ( data ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT fixture_data [ path ] = data NEW_LINE return data NEW_LINE DEDENT class TestParameters ( unittest . TestCase ) : NEW_LINE INDENT def test_module_parameters_keys ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE # ▁ Assert ▁ the ▁ top - level ▁ keys ENDCOM assert p . name == ' http _ example ' NEW_LINE assert p . partition == ' Common ' NEW_LINE assert p . template == ' / Common / f5 . http ' NEW_LINE DEDENT def test_module_parameters_lists ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert ' lists ' in p . _values NEW_LINE assert p . lists [ 0 ] [ ' name ' ] == ' irules _ _ irules ' NEW_LINE assert p . lists [ 0 ] [ ' encrypted ' ] == ' no ' NEW_LINE assert len ( p . lists [ 0 ] [ ' value ' ] ) == 1 NEW_LINE assert p . lists [ 0 ] [ ' value ' ] [ 0 ] == ' / Common / lgyft ' NEW_LINE assert p . lists [ 1 ] [ ' name ' ] == ' net _ _ client _ vlan ' NEW_LINE assert p . lists [ 1 ] [ ' encrypted ' ] == ' no ' NEW_LINE assert len ( p . lists [ 1 ] [ ' value ' ] ) == 1 NEW_LINE assert p . lists [ 1 ] [ ' value ' ] [ 0 ] == ' / Common / net2' NEW_LINE DEDENT def test_module_parameters_tables ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert ' tables ' in p . _values NEW_LINE assert ' columnNames ' in p . tables [ 0 ] NEW_LINE assert len ( p . tables [ 0 ] [ ' columnNames ' ] ) == 1 NEW_LINE assert p . tables [ 0 ] [ ' columnNames ' ] [ 0 ] == ' name ' NEW_LINE assert ' name ' in p . tables [ 0 ] NEW_LINE assert p . tables [ 0 ] [ ' name ' ] == ' pool _ _ hosts ' NEW_LINE assert ' rows ' in p . tables [ 0 ] NEW_LINE assert len ( p . tables [ 0 ] [ ' rows ' ] ) == 1 NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 0 ] NEW_LINE assert len ( p . tables [ 0 ] [ ' rows ' ] [ 0 ] [ ' row ' ] ) == 1 NEW_LINE assert p . tables [ 0 ] [ ' rows ' ] [ 0 ] [ ' row ' ] [ 0 ] == ' demo . example . com ' NEW_LINE assert len ( p . tables [ 1 ] [ ' rows ' ] ) == 2 NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 0 ] NEW_LINE assert len ( p . tables [ 1 ] [ ' rows ' ] [ 0 ] [ ' row ' ] ) == 2 NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 0 ] [ ' row ' ] [ 0 ] == '10.1.1.1' NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 0 ] [ ' row ' ] [ 1 ] == '0' NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 1 ] [ ' row ' ] [ 0 ] == '10.1.1.2' NEW_LINE assert p . tables [ 1 ] [ ' rows ' ] [ 1 ] [ ' row ' ] [ 1 ] == '0' NEW_LINE DEDENT def test_module_parameters_variables ( self ) : NEW_LINE INDENT args = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert ' variables ' in p . _values NEW_LINE assert len ( p . variables ) == 34 NEW_LINE # ▁ Assert ▁ one ▁ configuration ▁ value ENDCOM assert ' name ' in p . variables [ 0 ] NEW_LINE assert ' value ' in p . variables [ 0 ] NEW_LINE assert p . variables [ 0 ] [ ' name ' ] == ' afm _ _ dos _ security _ profile ' NEW_LINE assert p . variables [ 0 ] [ ' value ' ] == ' / # do _ not _ use # ' NEW_LINE # ▁ Assert ▁ a ▁ second ▁ configuration ▁ value ENDCOM assert ' name ' in p . variables [ 1 ] NEW_LINE assert ' value ' in p . variables [ 1 ] NEW_LINE assert p . variables [ 1 ] [ ' name ' ] == ' afm _ _ policy ' NEW_LINE assert p . variables [ 1 ] [ ' value ' ] == ' / # do _ not _ use # ' NEW_LINE DEDENT def test_api_parameters_variables ( self ) : NEW_LINE INDENT args = dict ( variables = [ dict ( name = " client _ _ http _ compression " , encrypted = " no " , value = " / # create _ new # " ) ] ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . variables [ 0 ] [ ' name ' ] == ' client _ _ http _ compression ' NEW_LINE DEDENT def test_api_parameters_tables ( self ) : NEW_LINE INDENT args = dict ( tables = [ { " name " : " pool _ _ members " , " columnNames " : [ " addr " , " port " , " connection _ limit " ] , " rows " : [ { " row " : [ "12.12.12.12" , "80" , ] } , { " row " : [ "13.13.13.13" , "443" , 10 ] } ] } ] ) p = Parameters ( args ) NEW_LINE assert p . tables [ 0 ] [ ' name ' ] == ' pool _ _ members ' NEW_LINE assert p . tables [ 0 ] [ ' columnNames ' ] == [ ' addr ' , ' port ' , ' connection _ limit ' ] NEW_LINE assert len ( p . tables [ 0 ] [ ' rows ' ] ) == 2 NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 0 ] NEW_LINE assert ' row ' in p . tables [ 0 ] [ ' rows ' ] [ 1 ] NEW_LINE assert p . tables [ 0 ] [ ' rows ' ] [ 0 ] [ ' row ' ] == [ '12.12.12.12' , '80' , '0' ] NEW_LINE assert p . tables [ 0 ] [ ' rows ' ] [ 1 ] [ ' row ' ] == [ '13.13.13.13' , '443' , '10' ] NEW_LINE DEDENT def test_module_template_same_partition ( self ) : NEW_LINE INDENT args = dict ( template = ' foo ' , partition = ' bar ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . template == ' / bar / foo ' NEW_LINE DEDENT def test_module_template_same_partition_full_path ( self ) : NEW_LINE INDENT args = dict ( template = ' / bar / foo ' , partition = ' bar ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . template == ' / bar / foo ' NEW_LINE DEDENT def test_module_template_different_partition_full_path ( self ) : NEW_LINE INDENT args = dict ( template = ' / Common / foo ' , partition = ' bar ' ) NEW_LINE p = Parameters ( args ) NEW_LINE assert p . template == ' / Common / foo ' NEW_LINE DEDENT DEDENT @ patch ( ' ansible . module _ utils . f5 _ utils . AnsibleF5Client . _ get _ mgmt _ root ' , return_value = True ) NEW_LINE class TestManager ( unittest . TestCase ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT self . spec = ArgumentSpec ( ) NEW_LINE DEDENT def test_create_service ( self , * args ) : NEW_LINE INDENT parameters = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE set_module_args ( dict ( name = ' foo ' , template = ' f5 . http ' , parameters = parameters , state = ' present ' , password = ' passsword ' , server = ' localhost ' , user = ' admin ' ) ) NEW_LINE client = AnsibleF5Client ( argument_spec = self . spec . argument_spec , supports_check_mode = self . spec . supports_check_mode , f5_product_name = self . spec . f5_product_name ) NEW_LINE mm = ModuleManager ( client ) NEW_LINE # ▁ Override ▁ methods ▁ to ▁ force ▁ specific ▁ logic ▁ in ▁ the ▁ module ▁ to ▁ happen ENDCOM mm . exists = Mock ( return_value = False ) NEW_LINE mm . create_on_device = Mock ( return_value = True ) NEW_LINE results = mm . exec_module ( ) NEW_LINE assert results [ ' changed ' ] is True NEW_LINE DEDENT def test_update_agent_status_traps ( self , * args ) : NEW_LINE INDENT parameters = load_fixture ( ' update _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE set_module_args ( dict ( name = ' foo ' , template = ' f5 . http ' , parameters = parameters , state = ' present ' , password = ' passsword ' , server = ' localhost ' , user = ' admin ' ) ) NEW_LINE # ▁ Configure ▁ the ▁ parameters ▁ that ▁ would ▁ be ▁ returned ▁ by ▁ querying ▁ the ENDCOM # ▁ remote ▁ device ENDCOM parameters = load_fixture ( ' create _ iapp _ service _ parameters _ f5 _ http . json ' ) NEW_LINE current = Parameters ( parameters ) NEW_LINE client = AnsibleF5Client ( argument_spec = self . spec . argument_spec , supports_check_mode = self . spec . supports_check_mode , f5_product_name = self . spec . f5_product_name ) NEW_LINE mm = ModuleManager ( client ) NEW_LINE # ▁ Override ▁ methods ▁ to ▁ force ▁ specific ▁ logic ▁ in ▁ the ▁ module ▁ to ▁ happen ENDCOM mm . exists = Mock ( return_value = True ) NEW_LINE mm . update_on_device = Mock ( return_value = True ) NEW_LINE mm . read_current_from_device = Mock ( return_value = current ) NEW_LINE results = mm . exec_module ( ) NEW_LINE assert results [ ' changed ' ] is True NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="anas-taji/knowledge/tree/master/attachment_edit/models/ir_attachment.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM # ▁ © ▁ 2015 ▁ Therp ▁ BV ▁ < http : / / therp . nl > ENDCOM # ▁ License ▁ AGPL - 3.0 ▁ or ▁ later ▁ ( http : / / www . gnu . org / licenses / agpl . html ) . ENDCOM # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM from openerp import models , fields , api NEW_LINE class IrAttachment ( models . Model ) : NEW_LINE INDENT _inherit = ' ir . attachment ' NEW_LINE res_reference = fields . Reference ( selection = ' _ selection _ res _ reference ' , string = ' Resource ▁ reference ' , compute = ' _ compute _ res _ reference ' , inverse = ' _ inverse _ res _ reference ' ) NEW_LINE @ api . one NEW_LINE @ api . depends ( ' res _ id ' , ' res _ model ' ) NEW_LINE def _compute_res_reference ( self ) : NEW_LINE INDENT if self . res_model and self . res_id : NEW_LINE INDENT self . res_reference = ' % s , % s ' % ( self . res_model , self . res_id ) NEW_LINE DEDENT DEDENT @ api . one NEW_LINE def _inverse_res_reference ( self ) : NEW_LINE INDENT if self . res_reference : NEW_LINE INDENT self . write ( { ' res _ model ' : self . res_reference . _model . _model , ' res _ id ' : self . res_reference . id , } ) NEW_LINE DEDENT else : NEW_LINE INDENT self . write ( { ' res _ model ' : False , ' res _ id ' : False } ) NEW_LINE DEDENT DEDENT @ api . model NEW_LINE def _selection_res_reference ( self ) : NEW_LINE INDENT return self . env [ ' ir . model ' ] . search ( [ ( ' osv _ memory ' , ' = ' , False ) , ( ' access _ ids . group _ id . users ' , ' = ' , self . env . uid ) ] ) . mapped ( lambda rec : ( rec . model , rec . name ) ) NEW_LINE DEDENT DEDENT </DOCUMENT>
