def missing_function ( name , requires = None , suggestions = None ) : NEW_LINE INDENT def MissingFunction ( * args , ** kwargs ) : NEW_LINE INDENT raise MissingFunctionException ( name , requires , suggestions ) NEW_LINE DEDENT return MissingFunction NEW_LINE DEDENT
def errcheck_glbegin ( result , func , arguments ) : NEW_LINE INDENT from pyglet import gl NEW_LINE context = gl . current_context NEW_LINE if not context : NEW_LINE INDENT raise GLException ( ' No ▁ GL ▁ context ; ▁ create ▁ a ▁ Window ▁ first ' ) NEW_LINE DEDENT context . _gl_begin = True NEW_LINE return result NEW_LINE DEDENT
def errcheck_glend ( result , func , arguments ) : NEW_LINE INDENT from pyglet import gl NEW_LINE context = gl . current_context NEW_LINE if not context : NEW_LINE INDENT raise GLException ( ' No ▁ GL ▁ context ; ▁ create ▁ a ▁ Window ▁ first ' ) NEW_LINE DEDENT context . _gl_begin = False NEW_LINE return errcheck ( result , func , arguments ) NEW_LINE DEDENT
def decorate_function ( func , name ) : NEW_LINE INDENT if _debug_gl : NEW_LINE INDENT if name == ' glBegin ' : NEW_LINE INDENT func . errcheck = errcheck_glbegin NEW_LINE DEDENT elif name == ' glEnd ' : NEW_LINE INDENT func . errcheck = errcheck_glend NEW_LINE DEDENT elif name not in ( ' glGetError ' , ' gluErrorString ' ) and name [ : 3 ] not in ( ' glX ' , ' agl ' , ' wgl ' ) : NEW_LINE INDENT func . errcheck = errcheck NEW_LINE DEDENT DEDENT DEDENT
def parseEntity ( entityLine ) : NEW_LINE INDENT """ ▁ parse ▁ entity ▁ line ▁ """ NEW_LINE result = entityLine . split ( ) NEW_LINE # entity _ ID ▁ = ▁ result [ 0 ] + ' _ ' + result [ 1 ] ENDCOM entity_name = result [ 1 ] NEW_LINE # particle ▁ = ▁ ' - ' ENDCOM particle = ' GenericParticle ' NEW_LINE if len ( result ) == 3 : NEW_LINE INDENT attributes = result [ 2 ] NEW_LINE # attributes ▁ = ▁ attributes . lower ( ) ENDCOM attributes = attributes . replace ( ' gender ' , ' color ' ) NEW_LINE attributes = attributes . replace ( ' female ' , ' pink ' ) NEW_LINE attributes = attributes . replace ( ' male ' , ' blue ' ) NEW_LINE attributes = attributes . replace ( ' photo ' , ' pic ' ) NEW_LINE attributes = attributes + ' , type = ' + result [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT attributes = ' type = ' + result [ 0 ] NEW_LINE DEDENT return " ADD ▁ NODE ▁ % s ▁ % s ▁ auto ▁ % s ▁ % s " % ( entity_name , entity_name , particle , attributes ) NEW_LINE DEDENT
def parseUpdatedEntity ( entityLine ) : NEW_LINE INDENT """ ▁ parse ▁ entity ▁ line ▁ """ NEW_LINE result = entityLine . split ( ) NEW_LINE # entity _ ID ▁ = ▁ result [ 0 ] + ' _ ' + result [ 1 ] ENDCOM entity_name = result [ 1 ] NEW_LINE # particle ▁ = ▁ ' - ' ENDCOM # particle ▁ = ▁ ' GenericParticle ' ENDCOM if len ( result ) == 3 : NEW_LINE INDENT attributes = result [ 2 ] NEW_LINE # attributes ▁ = ▁ attributes . lower ( ) ENDCOM attributes = attributes . replace ( ' gender ' , ' color ' ) NEW_LINE attributes = attributes . replace ( ' female ' , ' pink ' ) NEW_LINE attributes = attributes . replace ( ' male ' , ' blue ' ) NEW_LINE attributes = attributes . replace ( ' photo ' , ' pic ' ) NEW_LINE attributes = attributes . replace ( ' name ' , ' label ' ) NEW_LINE DEDENT else : NEW_LINE INDENT attributes = ' label = ' + entity_name NEW_LINE DEDENT return " UPDATE ▁ NODE ▁ % s ▁ % s " % ( entity_name , attributes ) NEW_LINE DEDENT
def parseRelation ( relationLine ) : NEW_LINE INDENT """ ▁ parse ▁ relation ▁ line ▁ """ NEW_LINE result = relationLine . split ( ' ( ' ) NEW_LINE relation = result [ 0 ] . strip ( ) NEW_LINE entities_str = result [ 1 ] . rstrip ( ' ) ' ) NEW_LINE entities_list = entities_str . split ( ' , ' ) NEW_LINE src = entities_list [ 0 ] . strip ( ) NEW_LINE dst = entities_list [ 1 ] . strip ( ) NEW_LINE return " ADD ▁ LINK ▁ % s ▁ % s ▁ % s " % ( src , dst , relation ) NEW_LINE DEDENT
def dialog_ok ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_ok ( * args , ** kwargs ) NEW_LINE DEDENT
def dialog_notification ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_notification ( * args , ** kwargs ) NEW_LINE DEDENT
def dialog_yesno ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_yesno ( * args , ** kwargs ) NEW_LINE DEDENT
def dialog_select ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_select ( * args , ** kwargs ) NEW_LINE DEDENT
def dialog_progress ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_progress ( * args , ** kwargs ) NEW_LINE DEDENT
def dialog_progress_bg ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_progress_bg ( * args , ** kwargs ) NEW_LINE DEDENT
def dialog_input ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_input ( * args , ** kwargs ) NEW_LINE DEDENT
def dialog_numeric ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . dialog_numeric ( * args , ** kwargs ) NEW_LINE DEDENT
def itemlist_refresh ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . itemlist_refresh ( * args , ** kwargs ) NEW_LINE DEDENT
def itemlist_update ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . itemlist_update ( * args , ** kwargs ) NEW_LINE DEDENT
def render_items ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . render_items ( * args , ** kwargs ) NEW_LINE DEDENT
def is_playing ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . is_playing ( * args , ** kwargs ) NEW_LINE DEDENT
def play_video ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . play_video ( * args , ** kwargs ) NEW_LINE DEDENT
def open_settings ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . open_settings ( * args , ** kwargs ) NEW_LINE DEDENT
def show_channel_settings ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . show_channel_settings ( * args , ** kwargs ) NEW_LINE DEDENT
def show_video_info ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . show_video_info ( * args , ** kwargs ) NEW_LINE DEDENT
def show_recaptcha ( * args , ** kwargs ) : NEW_LINE INDENT id = threading . current_thread ( ) . name NEW_LINE return controllers [ id ] . show_recaptcha ( * args , ** kwargs ) NEW_LINE DEDENT
def enum ( typename , field_names ) : NEW_LINE INDENT """ STRNEWLINE ▁ Create ▁ a ▁ new ▁ enumeration ▁ type . STRNEWLINE ▁ STRNEWLINE ▁ Code ▁ is ▁ copyright ▁ ( c ) ▁ Gabriel ▁ Genellina , ▁ 2010 , ▁ MIT ▁ License . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE STRNEWLINE ▁ typename ▁ - ▁ Name ▁ of ▁ the ▁ enumerated ▁ type STRNEWLINE ▁ field _ names ▁ - ▁ Names ▁ of ▁ the ▁ fields ▁ of ▁ the ▁ enumerated ▁ type STRNEWLINE ▁ """ NEW_LINE if isinstance ( field_names , str ) : NEW_LINE INDENT field_names = field_names . replace ( ' , ' , ' ▁ ' ) . split ( ) NEW_LINE DEDENT d = dict ( ( reversed ( nv ) for nv in enumerate ( field_names ) ) , __slots__ = ( ) ) NEW_LINE return type ( typename , ( object , ) , d ) ( ) NEW_LINE DEDENT
def degreesToRadians ( angle ) : NEW_LINE INDENT """ STRNEWLINE ▁ Convert ▁ from ▁ degrees ▁ to ▁ radians . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE STRNEWLINE ▁ angle ▁ - ▁ angle ▁ in ▁ degrees STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE STRNEWLINE ▁ Angle ▁ in ▁ radians . STRNEWLINE ▁ """ NEW_LINE return angle / 180.0 * np . pi NEW_LINE DEDENT
def radiansToDegrees ( angle ) : NEW_LINE INDENT """ STRNEWLINE ▁ Convert ▁ from ▁ radians ▁ to ▁ degrees . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE STRNEWLINE ▁ angle ▁ - ▁ angle ▁ in ▁ radians . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ STRNEWLINE ▁ Angle ▁ in ▁ degrees . STRNEWLINE ▁ """ NEW_LINE return angle / np . pi * 180.0 NEW_LINE DEDENT
def construct_covariance_matrix ( cvec , parallax , radial_velocity , radial_velocity_error ) : NEW_LINE INDENT """ STRNEWLINE ▁ Take ▁ the ▁ astrometric ▁ parameter ▁ standard ▁ uncertainties ▁ and ▁ the ▁ uncertainty ▁ correlations ▁ as ▁ quoted ▁ in STRNEWLINE ▁ the ▁ Gaia ▁ catalogue ▁ and ▁ construct ▁ the ▁ covariance ▁ matrix . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE STRNEWLINE ▁ cvec ▁ : ▁ array _ like STRNEWLINE ▁ Array ▁ of ▁ shape ▁ ( 15 , ) ▁ ( 1 ▁ source ) ▁ or ▁ ( n , 15 ) ▁ ( n ▁ sources ) ▁ for ▁ the ▁ astrometric ▁ parameter ▁ standard STRNEWLINE ▁ uncertainties ▁ and ▁ their ▁ correlations , ▁ as ▁ listed ▁ in ▁ the ▁ Gaia ▁ catalogue ▁ [ ra _ error , ▁ dec _ error , STRNEWLINE ▁ parallax _ error , ▁ pmra _ error , ▁ pmdec _ error , ▁ ra _ dec _ corr , ▁ ra _ parallax _ corr , ▁ ra _ pmra _ corr , STRNEWLINE ▁ ra _ pmdec _ corr , ▁ dec _ parallax _ corr , ▁ dec _ pmra _ corr , ▁ dec _ pmdec _ corr , ▁ parallax _ pmra _ corr , STRNEWLINE ▁ parallax _ pmdec _ corr , ▁ pmra _ pmdec _ corr ] . ▁ Units ▁ are ▁ ( mas ^ 2 , ▁ mas ^ 2 / yr , ▁ mas ^ 2 / yr ^ 2 ) . STRNEWLINE ▁ STRNEWLINE ▁ parallax ▁ : ▁ array _ like ▁ ( n ▁ elements ) STRNEWLINE ▁ Source ▁ parallax ▁ ( mas ) . STRNEWLINE ▁ STRNEWLINE ▁ radial _ velocity ▁ : ▁ array _ like ▁ ( n ▁ elements ) STRNEWLINE ▁ Source ▁ radial ▁ velocity ▁ ( km / s , ▁ does ▁ not ▁ have ▁ to ▁ be ▁ from ▁ Gaia ▁ RVS ! ) . ▁ If ▁ the ▁ radial ▁ velocity ▁ is ▁ not STRNEWLINE ▁ known ▁ it ▁ can ▁ be ▁ set ▁ to ▁ zero . STRNEWLINE STRNEWLINE ▁ radial _ velocity _ error ▁ : ▁ array _ like ▁ ( n ▁ elements ) STRNEWLINE ▁ Source ▁ radial ▁ velocity ▁ uncertainty ▁ ( km / s ) . ▁ If ▁ the ▁ radial ▁ velocity ▁ is ▁ not ▁ know ▁ this ▁ can ▁ be ▁ set ▁ to STRNEWLINE ▁ the ▁ radial ▁ velocity ▁ dispersion ▁ for ▁ the ▁ population ▁ the ▁ source ▁ was ▁ drawn ▁ from . STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE STRNEWLINE ▁ Covariance ▁ matrix ▁ as ▁ a ▁ 6x6 ▁ array . STRNEWLINE ▁ """ NEW_LINE if np . ndim ( cvec ) == 1 : NEW_LINE INDENT cmat = np . zeros ( ( 1 , 6 , 6 ) ) NEW_LINE nsources = 1 NEW_LINE cv = np . atleast_2d ( cvec ) NEW_LINE DEDENT else : NEW_LINE INDENT nsources = cvec . shape [ 0 ] NEW_LINE cmat = np . zeros ( ( nsources , 6 , 6 ) ) NEW_LINE cv = cvec NEW_LINE DEDENT for k in range ( nsources ) : NEW_LINE INDENT cmat [ k , 0 : 5 , 0 : 5 ] = cv [ k , 0 : 5 ] ** 2 NEW_LINE DEDENT iu = np . triu_indices ( 5 , k = 1 ) NEW_LINE for k in range ( 10 ) : NEW_LINE INDENT i = iu [ 0 ] [ k ] NEW_LINE j = iu [ 1 ] [ k ] NEW_LINE cmat [ : , i , j ] = cv [ : , i ] * cv [ : , j ] * cv [ : , k + 5 ] NEW_LINE cmat [ : , j , i ] = cmat [ : , i , j ] NEW_LINE DEDENT for k in range ( nsources ) : NEW_LINE INDENT cmat [ k , 0 : 5 , 5 ] = cmat [ k , 0 : 5 , 2 ] * np . atleast_1d ( radial_velocity ) [ k ] / auKmYearPerSec NEW_LINE DEDENT cmat [ : , 5 , 0 : 5 ] = cmat [ : , 0 : 5 , 5 ] NEW_LINE cmat [ : , 5 , 5 ] = cmat [ : , 2 , 2 ] * ( radial_velocity ** 2 + radial_velocity_error ** 2 ) / auKmYearPerSec ** 2 + ( parallax * radial_velocity_error / auKmYearPerSec ) ** 2 NEW_LINE return np . squeeze ( cmat ) NEW_LINE DEDENT
def flag ( request , comment_id , next = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Flags ▁ a ▁ comment . ▁ Confirmation ▁ on ▁ GET , ▁ action ▁ on ▁ POST . STRNEWLINE STRNEWLINE ▁ Templates : ▁ : template : ` comments / flag . html ` , STRNEWLINE ▁ Context : STRNEWLINE ▁ comment STRNEWLINE ▁ the ▁ flagged ▁ ` comments . comment ` ▁ object STRNEWLINE ▁ """ NEW_LINE comment = get_object_or_404 ( comments . get_model ( ) , pk = comment_id , site__pk = settings . SITE_ID ) NEW_LINE # ▁ Flag ▁ on ▁ POST ENDCOM if request . method == ' POST ' : NEW_LINE INDENT perform_flag ( request , comment ) NEW_LINE return next_redirect ( request , fallback = next or ' comments - flag - done ' , c = comment . pk ) NEW_LINE # ▁ Render ▁ a ▁ form ▁ on ▁ GET ENDCOM DEDENT else : NEW_LINE INDENT return render_to_response ( ' comments / flag . html ' , { ' comment ' : comment , " next " : next } , template . RequestContext ( request ) ) NEW_LINE DEDENT DEDENT
def delete ( request , comment_id , next = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Deletes ▁ a ▁ comment . ▁ Confirmation ▁ on ▁ GET , ▁ action ▁ on ▁ POST . ▁ Requires ▁ the ▁ " can STRNEWLINE ▁ moderate ▁ comments " ▁ permission . STRNEWLINE STRNEWLINE ▁ Templates : ▁ : template : ` comments / delete . html ` , STRNEWLINE ▁ Context : STRNEWLINE ▁ comment STRNEWLINE ▁ the ▁ flagged ▁ ` comments . comment ` ▁ object STRNEWLINE ▁ """ NEW_LINE comment = get_object_or_404 ( comments . get_model ( ) , pk = comment_id , site__pk = settings . SITE_ID ) NEW_LINE # ▁ Delete ▁ on ▁ POST ENDCOM if request . method == ' POST ' : NEW_LINE # ▁ Flag ▁ the ▁ comment ▁ as ▁ deleted ▁ instead ▁ of ▁ actually ▁ deleting ▁ it . ENDCOM INDENT perform_delete ( request , comment ) NEW_LINE return next_redirect ( request , fallback = next or ' comments - delete - done ' , c = comment . pk ) NEW_LINE # ▁ Render ▁ a ▁ form ▁ on ▁ GET ENDCOM DEDENT else : NEW_LINE INDENT return render_to_response ( ' comments / delete . html ' , { ' comment ' : comment , " next " : next } , template . RequestContext ( request ) ) NEW_LINE DEDENT DEDENT
def approve ( request , comment_id , next = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ Approve ▁ a ▁ comment ▁ ( that ▁ is , ▁ mark ▁ it ▁ as ▁ public ▁ and ▁ non - removed ) . ▁ Confirmation STRNEWLINE ▁ on ▁ GET , ▁ action ▁ on ▁ POST . ▁ Requires ▁ the ▁ " can ▁ moderate ▁ comments " ▁ permission . STRNEWLINE STRNEWLINE ▁ Templates : ▁ : template : ` comments / approve . html ` , STRNEWLINE ▁ Context : STRNEWLINE ▁ comment STRNEWLINE ▁ the ▁ ` comments . comment ` ▁ object ▁ for ▁ approval STRNEWLINE ▁ """ NEW_LINE comment = get_object_or_404 ( comments . get_model ( ) , pk = comment_id , site__pk = settings . SITE_ID ) NEW_LINE # ▁ Delete ▁ on ▁ POST ENDCOM if request . method == ' POST ' : NEW_LINE # ▁ Flag ▁ the ▁ comment ▁ as ▁ approved . ENDCOM INDENT perform_approve ( request , comment ) NEW_LINE return next_redirect ( request , fallback = next or ' comments - approve - done ' , c = comment . pk ) NEW_LINE # ▁ Render ▁ a ▁ form ▁ on ▁ GET ENDCOM DEDENT else : NEW_LINE INDENT return render_to_response ( ' comments / approve . html ' , { ' comment ' : comment , " next " : next } , template . RequestContext ( request ) ) NEW_LINE # ▁ The ▁ following ▁ functions ▁ actually ▁ perform ▁ the ▁ various ▁ flag / aprove / delete ENDCOM # ▁ actions . ▁ They ' ve ▁ been ▁ broken ▁ out ▁ into ▁ separate ▁ functions ▁ to ▁ that ▁ they ENDCOM # ▁ may ▁ be ▁ called ▁ from ▁ admin ▁ actions . ENDCOM DEDENT DEDENT
def perform_flag ( request , comment ) : NEW_LINE INDENT """ STRNEWLINE ▁ Actually ▁ perform ▁ the ▁ flagging ▁ of ▁ a ▁ comment ▁ from ▁ a ▁ request . STRNEWLINE ▁ """ NEW_LINE flag , created = comments . models . CommentFlag . objects . get_or_create ( comment = comment , user = request . user , flag = comments . models . CommentFlag . SUGGEST_REMOVAL ) NEW_LINE signals . comment_was_flagged . send ( sender = comment . __class__ , comment = comment , flag = flag , created = created , request = request , ) NEW_LINE DEDENT
def perform_delete ( request , comment ) : NEW_LINE INDENT flag , created = comments . models . CommentFlag . objects . get_or_create ( comment = comment , user = request . user , flag = comments . models . CommentFlag . MODERATOR_DELETION ) NEW_LINE comment . is_removed = True NEW_LINE comment . save ( ) NEW_LINE signals . comment_was_flagged . send ( sender = comment . __class__ , comment = comment , flag = flag , created = created , request = request , ) NEW_LINE DEDENT
def perform_approve ( request , comment ) : NEW_LINE INDENT flag , created = comments . models . CommentFlag . objects . get_or_create ( comment = comment , user = request . user , flag = comments . models . CommentFlag . MODERATOR_APPROVAL , ) NEW_LINE comment . is_removed = False NEW_LINE comment . is_public = True NEW_LINE comment . save ( ) NEW_LINE signals . comment_was_flagged . send ( sender = comment . __class__ , comment = comment , flag = flag , created = created , request = request , ) NEW_LINE # ▁ Confirmation ▁ views . ENDCOM DEDENT
def main ( ) : NEW_LINE INDENT """ ▁ elasticache ▁ ansible ▁ module ▁ """ NEW_LINE argument_spec = ec2_argument_spec ( ) NEW_LINE argument_spec . update ( dict ( state = dict ( required = True , choices = [ ' present ' , ' absent ' , ' rebooted ' ] ) , name = dict ( required = True ) , engine = dict ( default = ' memcached ' ) , cache_engine_version = dict ( default = " " ) , node_type = dict ( default = ' cache . t2 . small ' ) , num_nodes = dict ( default = 1 , type = ' int ' ) , # ▁ alias ▁ for ▁ compat ▁ with ▁ the ▁ original ▁ PR ▁ 1950 ENDCOM cache_parameter_group = dict ( default = " " , aliases = [ ' parameter _ group ' ] ) , cache_port = dict ( type = ' int ' ) , cache_subnet_group = dict ( default = " " ) , cache_security_groups = dict ( default = [ ] , type = ' list ' ) , security_group_ids = dict ( default = [ ] , type = ' list ' ) , zone = dict ( ) , wait = dict ( default = True , type = ' bool ' ) , hard_modify = dict ( type = ' bool ' ) ) ) NEW_LINE module = AnsibleModule ( argument_spec = argument_spec , ) NEW_LINE if not HAS_BOTO3 : NEW_LINE INDENT module . fail_json ( msg = ' boto3 ▁ required ▁ for ▁ this ▁ module ' ) NEW_LINE DEDENT region , ec2_url , aws_connect_kwargs = get_aws_connection_info ( module ) NEW_LINE name = module . params [ ' name ' ] NEW_LINE state = module . params [ ' state ' ] NEW_LINE engine = module . params [ ' engine ' ] NEW_LINE cache_engine_version = module . params [ ' cache _ engine _ version ' ] NEW_LINE node_type = module . params [ ' node _ type ' ] NEW_LINE num_nodes = module . params [ ' num _ nodes ' ] NEW_LINE cache_port = module . params [ ' cache _ port ' ] NEW_LINE cache_subnet_group = module . params [ ' cache _ subnet _ group ' ] NEW_LINE cache_security_groups = module . params [ ' cache _ security _ groups ' ] NEW_LINE security_group_ids = module . params [ ' security _ group _ ids ' ] NEW_LINE zone = module . params [ ' zone ' ] NEW_LINE wait = module . params [ ' wait ' ] NEW_LINE hard_modify = module . params [ ' hard _ modify ' ] NEW_LINE cache_parameter_group = module . params [ ' cache _ parameter _ group ' ] NEW_LINE if cache_subnet_group and cache_security_groups : NEW_LINE INDENT module . fail_json ( msg = " Can ' t ▁ specify ▁ both ▁ cache _ subnet _ group ▁ and ▁ cache _ security _ groups " ) NEW_LINE DEDENT if state == ' present ' and not num_nodes : NEW_LINE INDENT module . fail_json ( msg = " ' num _ nodes ' ▁ is ▁ a ▁ required ▁ parameter . ▁ Please ▁ specify ▁ num _ nodes ▁ > ▁ 0" ) NEW_LINE DEDENT elasticache_manager = ElastiCacheManager ( module , name , engine , cache_engine_version , node_type , num_nodes , cache_port , cache_parameter_group , cache_subnet_group , cache_security_groups , security_group_ids , zone , wait , hard_modify , region , ** aws_connect_kwargs ) NEW_LINE if state == ' present ' : NEW_LINE INDENT elasticache_manager . ensure_present ( ) NEW_LINE DEDENT elif state == ' absent ' : NEW_LINE INDENT elasticache_manager . ensure_absent ( ) NEW_LINE DEDENT elif state == ' rebooted ' : NEW_LINE INDENT elasticache_manager . ensure_rebooted ( ) NEW_LINE DEDENT facts_result = dict ( changed = elasticache_manager . changed , elasticache = elasticache_manager . get_info ( ) ) NEW_LINE module . exit_json ( ** facts_result ) NEW_LINE DEDENT
def suite ( ) : NEW_LINE INDENT s = unittest . TestSuite ( ) NEW_LINE s . addTest ( unittest . makeSuite ( GEOSTest ) ) NEW_LINE return s NEW_LINE DEDENT
def run ( verbosity = 2 ) : NEW_LINE INDENT unittest . TextTestRunner ( verbosity = verbosity ) . run ( suite ( ) ) NEW_LINE DEDENT
def hidden_prompt_func ( prompt ) : NEW_LINE INDENT import getpass NEW_LINE return getpass . getpass ( prompt ) NEW_LINE DEDENT
def _build_prompt ( text , suffix , show_default = False , default = None ) : NEW_LINE INDENT prompt = text NEW_LINE if default is not None and show_default : NEW_LINE INDENT prompt = ' % s ▁ [ % s ] ' % ( prompt , default ) NEW_LINE DEDENT return prompt + suffix NEW_LINE DEDENT
def confirm ( text , default = False , abort = False , prompt_suffix = ' : ▁ ' , show_default = True , err = False ) : NEW_LINE INDENT """ Prompts ▁ for ▁ confirmation ▁ ( yes / no ▁ question ) . STRNEWLINE STRNEWLINE ▁ If ▁ the ▁ user ▁ aborts ▁ the ▁ input ▁ by ▁ sending ▁ a ▁ interrupt ▁ signal ▁ this STRNEWLINE ▁ function ▁ will ▁ catch ▁ it ▁ and ▁ raise ▁ a ▁ : exc : ` Abort ` ▁ exception . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 4.0 STRNEWLINE ▁ Added ▁ the ▁ ` err ` ▁ parameter . STRNEWLINE STRNEWLINE ▁ : param ▁ text : ▁ the ▁ question ▁ to ▁ ask . STRNEWLINE ▁ : param ▁ default : ▁ the ▁ default ▁ for ▁ the ▁ prompt . STRNEWLINE ▁ : param ▁ abort : ▁ if ▁ this ▁ is ▁ set ▁ to ▁ ` True ` ▁ a ▁ negative ▁ answer ▁ aborts ▁ the STRNEWLINE ▁ exception ▁ by ▁ raising ▁ : exc : ` Abort ` . STRNEWLINE ▁ : param ▁ prompt _ suffix : ▁ a ▁ suffix ▁ that ▁ should ▁ be ▁ added ▁ to ▁ the ▁ prompt . STRNEWLINE ▁ : param ▁ show _ default : ▁ shows ▁ or ▁ hides ▁ the ▁ default ▁ value ▁ in ▁ the ▁ prompt . STRNEWLINE ▁ : param ▁ err : ▁ if ▁ set ▁ to ▁ true ▁ the ▁ file ▁ defaults ▁ to ▁ ` ` stderr ` ` ▁ instead ▁ of STRNEWLINE ▁ ` ` stdout ` ` , ▁ the ▁ same ▁ as ▁ with ▁ echo . STRNEWLINE ▁ """ NEW_LINE prompt = _build_prompt ( text , prompt_suffix , show_default , default and ' Y / n ' or ' y / N ' ) NEW_LINE while 1 : NEW_LINE INDENT try : NEW_LINE # ▁ Write ▁ the ▁ prompt ▁ separately ▁ so ▁ that ▁ we ▁ get ▁ nice ENDCOM # ▁ coloring ▁ through ▁ colorama ▁ on ▁ Windows ENDCOM INDENT echo ( prompt , nl = False , err = err ) NEW_LINE value = visible_prompt_func ( ' ' ) . lower ( ) . strip ( ) NEW_LINE DEDENT except ( KeyboardInterrupt , EOFError ) : NEW_LINE INDENT raise Abort ( ) NEW_LINE DEDENT if value in ( ' y ' , ' yes ' ) : NEW_LINE INDENT rv = True NEW_LINE DEDENT elif value in ( ' n ' , ' no ' ) : NEW_LINE INDENT rv = False NEW_LINE DEDENT elif value == ' ' : NEW_LINE INDENT rv = default NEW_LINE DEDENT else : NEW_LINE INDENT echo ( ' Error : ▁ invalid ▁ input ' , err = err ) NEW_LINE continue NEW_LINE DEDENT break NEW_LINE DEDENT if abort and not rv : NEW_LINE INDENT raise Abort ( ) NEW_LINE DEDENT return rv NEW_LINE DEDENT
def get_terminal_size ( ) : NEW_LINE INDENT """ Returns ▁ the ▁ current ▁ size ▁ of ▁ the ▁ terminal ▁ as ▁ tuple ▁ in ▁ the ▁ form STRNEWLINE ▁ ` ` ( width , ▁ height ) ` ` ▁ in ▁ columns ▁ and ▁ rows . STRNEWLINE ▁ """ NEW_LINE # ▁ If ▁ shutil ▁ has ▁ get _ terminal _ size ( ) ▁ ( Python ▁ 3.3 ▁ and ▁ later ) ▁ use ▁ that ENDCOM if sys . version_info >= ( 3 , 3 ) : NEW_LINE INDENT import shutil NEW_LINE shutil_get_terminal_size = getattr ( shutil , ' get _ terminal _ size ' , None ) NEW_LINE if shutil_get_terminal_size : NEW_LINE INDENT sz = shutil_get_terminal_size ( ) NEW_LINE return sz . columns , sz . lines NEW_LINE DEDENT DEDENT if get_winterm_size is not None : NEW_LINE INDENT return get_winterm_size ( ) NEW_LINE DEDENT def ioctl_gwinsz ( fd ) : NEW_LINE INDENT try : NEW_LINE INDENT import fcntl NEW_LINE import termios NEW_LINE cr = struct . unpack ( ' hh ' , fcntl . ioctl ( fd , termios . TIOCGWINSZ , '1234' ) ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT return NEW_LINE DEDENT return cr NEW_LINE DEDENT cr = ioctl_gwinsz ( 0 ) or ioctl_gwinsz ( 1 ) or ioctl_gwinsz ( 2 ) NEW_LINE if not cr : NEW_LINE INDENT try : NEW_LINE INDENT fd = os . open ( os . ctermid ( ) , os . O_RDONLY ) NEW_LINE try : NEW_LINE INDENT cr = ioctl_gwinsz ( fd ) NEW_LINE DEDENT finally : NEW_LINE INDENT os . close ( fd ) NEW_LINE DEDENT DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if not cr or not cr [ 0 ] or not cr [ 1 ] : NEW_LINE INDENT cr = ( os . environ . get ( ' LINES ' , 25 ) , os . environ . get ( ' COLUMNS ' , DEFAULT_COLUMNS ) ) NEW_LINE DEDENT return int ( cr [ 1 ] ) , int ( cr [ 0 ] ) NEW_LINE DEDENT
def echo_via_pager ( text , color = None ) : NEW_LINE INDENT """ This ▁ function ▁ takes ▁ a ▁ text ▁ and ▁ shows ▁ it ▁ via ▁ an ▁ environment ▁ specific STRNEWLINE ▁ pager ▁ on ▁ stdout . STRNEWLINE STRNEWLINE ▁ . . ▁ versionchanged : : ▁ 3.0 STRNEWLINE ▁ Added ▁ the ▁ ` color ` ▁ flag . STRNEWLINE STRNEWLINE ▁ : param ▁ text : ▁ the ▁ text ▁ to ▁ page . STRNEWLINE ▁ : param ▁ color : ▁ controls ▁ if ▁ the ▁ pager ▁ supports ▁ ANSI ▁ colors ▁ or ▁ not . ▁ The STRNEWLINE ▁ default ▁ is ▁ autodetection . STRNEWLINE ▁ """ NEW_LINE color = resolve_color_default ( color ) NEW_LINE if not isinstance ( text , string_types ) : NEW_LINE INDENT text = text_type ( text ) NEW_LINE DEDENT from . _termui_impl import pager NEW_LINE return pager ( text + ' \n ' , color ) NEW_LINE DEDENT
def clear ( ) : NEW_LINE INDENT """ Clears ▁ the ▁ terminal ▁ screen . ▁ This ▁ will ▁ have ▁ the ▁ effect ▁ of ▁ clearing STRNEWLINE ▁ the ▁ whole ▁ visible ▁ space ▁ of ▁ the ▁ terminal ▁ and ▁ moving ▁ the ▁ cursor ▁ to ▁ the STRNEWLINE ▁ top ▁ left . ▁ This ▁ does ▁ not ▁ do ▁ anything ▁ if ▁ not ▁ connected ▁ to ▁ a ▁ terminal . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 2.0 STRNEWLINE ▁ """ NEW_LINE if not isatty ( sys . stdout ) : NEW_LINE INDENT return NEW_LINE # ▁ If ▁ we ' re ▁ on ▁ Windows ▁ and ▁ we ▁ don ' t ▁ have ▁ colorama ▁ available , ▁ then ▁ we ENDCOM # ▁ clear ▁ the ▁ screen ▁ by ▁ shelling ▁ out . ▁ Otherwise ▁ we ▁ can ▁ use ▁ an ▁ escape ENDCOM # ▁ sequence . ENDCOM DEDENT if WIN : NEW_LINE INDENT os . system ( ' cls ' ) NEW_LINE DEDENT else : NEW_LINE INDENT sys . stdout . write ( ' \033[2J\033[1;1H ' ) NEW_LINE DEDENT DEDENT
def style ( text , fg = None , bg = None , bold = None , dim = None , underline = None , blink = None , reverse = None , reset = True ) : NEW_LINE INDENT """ Styles ▁ a ▁ text ▁ with ▁ ANSI ▁ styles ▁ and ▁ returns ▁ the ▁ new ▁ string . ▁ By STRNEWLINE ▁ default ▁ the ▁ styling ▁ is ▁ self ▁ contained ▁ which ▁ means ▁ that ▁ at ▁ the ▁ end STRNEWLINE ▁ of ▁ the ▁ string ▁ a ▁ reset ▁ code ▁ is ▁ issued . ▁ This ▁ can ▁ be ▁ prevented ▁ by STRNEWLINE ▁ passing ▁ ` ` reset = False ` ` . STRNEWLINE STRNEWLINE ▁ Examples : : STRNEWLINE STRNEWLINE ▁ click . echo ( click . style ( ' Hello ▁ World ! ' , ▁ fg = ' green ' ) ) STRNEWLINE ▁ click . echo ( click . style ( ' ATTENTION ! ' , ▁ blink = True ) ) STRNEWLINE ▁ click . echo ( click . style ( ' Some ▁ things ' , ▁ reverse = True , ▁ fg = ' cyan ' ) ) STRNEWLINE STRNEWLINE ▁ Supported ▁ color ▁ names : STRNEWLINE STRNEWLINE ▁ * ▁ ` ` black ` ` ▁ ( might ▁ be ▁ a ▁ gray ) STRNEWLINE ▁ * ▁ ` ` red ` ` STRNEWLINE ▁ * ▁ ` ` green ` ` STRNEWLINE ▁ * ▁ ` ` yellow ` ` ▁ ( might ▁ be ▁ an ▁ orange ) STRNEWLINE ▁ * ▁ ` ` blue ` ` STRNEWLINE ▁ * ▁ ` ` magenta ` ` STRNEWLINE ▁ * ▁ ` ` cyan ` ` STRNEWLINE ▁ * ▁ ` ` white ` ` ▁ ( might ▁ be ▁ light ▁ gray ) STRNEWLINE ▁ * ▁ ` ` reset ` ` ▁ ( reset ▁ the ▁ color ▁ code ▁ only ) STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 2.0 STRNEWLINE STRNEWLINE ▁ : param ▁ text : ▁ the ▁ string ▁ to ▁ style ▁ with ▁ ansi ▁ codes . STRNEWLINE ▁ : param ▁ fg : ▁ if ▁ provided ▁ this ▁ will ▁ become ▁ the ▁ foreground ▁ color . STRNEWLINE ▁ : param ▁ bg : ▁ if ▁ provided ▁ this ▁ will ▁ become ▁ the ▁ background ▁ color . STRNEWLINE ▁ : param ▁ bold : ▁ if ▁ provided ▁ this ▁ will ▁ enable ▁ or ▁ disable ▁ bold ▁ mode . STRNEWLINE ▁ : param ▁ dim : ▁ if ▁ provided ▁ this ▁ will ▁ enable ▁ or ▁ disable ▁ dim ▁ mode . ▁ This ▁ is STRNEWLINE ▁ badly ▁ supported . STRNEWLINE ▁ : param ▁ underline : ▁ if ▁ provided ▁ this ▁ will ▁ enable ▁ or ▁ disable ▁ underline . STRNEWLINE ▁ : param ▁ blink : ▁ if ▁ provided ▁ this ▁ will ▁ enable ▁ or ▁ disable ▁ blinking . STRNEWLINE ▁ : param ▁ reverse : ▁ if ▁ provided ▁ this ▁ will ▁ enable ▁ or ▁ disable ▁ inverse STRNEWLINE ▁ rendering ▁ ( foreground ▁ becomes ▁ background ▁ and ▁ the STRNEWLINE ▁ other ▁ way ▁ round ) . STRNEWLINE ▁ : param ▁ reset : ▁ by ▁ default ▁ a ▁ reset - all ▁ code ▁ is ▁ added ▁ at ▁ the ▁ end ▁ of ▁ the STRNEWLINE ▁ string ▁ which ▁ means ▁ that ▁ styles ▁ do ▁ not ▁ carry ▁ over . ▁ This STRNEWLINE ▁ can ▁ be ▁ disabled ▁ to ▁ compose ▁ styles . STRNEWLINE ▁ """ NEW_LINE bits = [ ] NEW_LINE if fg : NEW_LINE INDENT try : NEW_LINE INDENT bits . append ( ' \033 [ % dm ' % ( _ansi_colors . index ( fg ) + 30 ) ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT raise TypeError ( ' Unknown ▁ color ▁ % r ' % fg ) NEW_LINE DEDENT DEDENT if bg : NEW_LINE INDENT try : NEW_LINE INDENT bits . append ( ' \033 [ % dm ' % ( _ansi_colors . index ( bg ) + 40 ) ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT raise TypeError ( ' Unknown ▁ color ▁ % r ' % bg ) NEW_LINE DEDENT DEDENT if bold is not None : NEW_LINE INDENT bits . append ( ' \033 [ % dm ' % ( 1 if bold else 22 ) ) NEW_LINE DEDENT if dim is not None : NEW_LINE INDENT bits . append ( ' \033 [ % dm ' % ( 2 if dim else 22 ) ) NEW_LINE DEDENT if underline is not None : NEW_LINE INDENT bits . append ( ' \033 [ % dm ' % ( 4 if underline else 24 ) ) NEW_LINE DEDENT if blink is not None : NEW_LINE INDENT bits . append ( ' \033 [ % dm ' % ( 5 if blink else 25 ) ) NEW_LINE DEDENT if reverse is not None : NEW_LINE INDENT bits . append ( ' \033 [ % dm ' % ( 7 if reverse else 27 ) ) NEW_LINE DEDENT bits . append ( text ) NEW_LINE if reset : NEW_LINE INDENT bits . append ( _ansi_reset_all ) NEW_LINE DEDENT return ' ' . join ( bits ) NEW_LINE DEDENT
def unstyle ( text ) : NEW_LINE INDENT """ Removes ▁ ANSI ▁ styling ▁ information ▁ from ▁ a ▁ string . ▁ Usually ▁ it ' s ▁ not STRNEWLINE ▁ necessary ▁ to ▁ use ▁ this ▁ function ▁ as ▁ Click ' s ▁ echo ▁ function ▁ will STRNEWLINE ▁ automatically ▁ remove ▁ styling ▁ if ▁ necessary . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 2.0 STRNEWLINE STRNEWLINE ▁ : param ▁ text : ▁ the ▁ text ▁ to ▁ remove ▁ style ▁ information ▁ from . STRNEWLINE ▁ """ NEW_LINE return strip_ansi ( text ) NEW_LINE DEDENT
def secho ( text , file = None , nl = True , err = False , color = None , ** styles ) : NEW_LINE INDENT """ This ▁ function ▁ combines ▁ : func : ` echo ` ▁ and ▁ : func : ` style ` ▁ into ▁ one STRNEWLINE ▁ call . ▁ As ▁ such ▁ the ▁ following ▁ two ▁ calls ▁ are ▁ the ▁ same : : STRNEWLINE STRNEWLINE ▁ click . secho ( ' Hello ▁ World ! ' , ▁ fg = ' green ' ) STRNEWLINE ▁ click . echo ( click . style ( ' Hello ▁ World ! ' , ▁ fg = ' green ' ) ) STRNEWLINE STRNEWLINE ▁ All ▁ keyword ▁ arguments ▁ are ▁ forwarded ▁ to ▁ the ▁ underlying ▁ functions STRNEWLINE ▁ depending ▁ on ▁ which ▁ one ▁ they ▁ go ▁ with . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 2.0 STRNEWLINE ▁ """ NEW_LINE return echo ( style ( text , ** styles ) , file = file , nl = nl , err = err , color = color ) NEW_LINE DEDENT
def edit ( text = None , editor = None , env = None , require_save = True , extension = ' . txt ' , filename = None ) : NEW_LINE INDENT r """ Edits ▁ the ▁ given ▁ text ▁ in ▁ the ▁ defined ▁ editor . ▁ If ▁ an ▁ editor ▁ is ▁ given STRNEWLINE ▁ ( should ▁ be ▁ the ▁ full ▁ path ▁ to ▁ the ▁ executable ▁ but ▁ the ▁ regular ▁ operating STRNEWLINE ▁ system ▁ search ▁ path ▁ is ▁ used ▁ for ▁ finding ▁ the ▁ executable ) ▁ it ▁ overrides STRNEWLINE ▁ the ▁ detected ▁ editor . ▁ Optionally , ▁ some ▁ environment ▁ variables ▁ can ▁ be STRNEWLINE ▁ used . ▁ If ▁ the ▁ editor ▁ is ▁ closed ▁ without ▁ changes , ▁ ` None ` ▁ is ▁ returned . ▁ In STRNEWLINE ▁ case ▁ a ▁ file ▁ is ▁ edited ▁ directly ▁ the ▁ return ▁ value ▁ is ▁ always ▁ ` None ` ▁ and STRNEWLINE ▁ ` require _ save ` ▁ and ▁ ` extension ` ▁ are ▁ ignored . STRNEWLINE STRNEWLINE ▁ If ▁ the ▁ editor ▁ cannot ▁ be ▁ opened ▁ a ▁ : exc : ` UsageError ` ▁ is ▁ raised . STRNEWLINE STRNEWLINE ▁ Note ▁ for ▁ Windows : ▁ to ▁ simplify ▁ cross - platform ▁ usage , ▁ the ▁ newlines ▁ are STRNEWLINE ▁ automatically ▁ converted ▁ from ▁ POSIX ▁ to ▁ Windows ▁ and ▁ vice ▁ versa . ▁ As ▁ such , STRNEWLINE ▁ the ▁ message ▁ here ▁ will ▁ have ▁ ` ` \n ` ` ▁ as ▁ newline ▁ markers . STRNEWLINE STRNEWLINE ▁ : param ▁ text : ▁ the ▁ text ▁ to ▁ edit . STRNEWLINE ▁ : param ▁ editor : ▁ optionally ▁ the ▁ editor ▁ to ▁ use . ▁ Defaults ▁ to ▁ automatic STRNEWLINE ▁ detection . STRNEWLINE ▁ : param ▁ env : ▁ environment ▁ variables ▁ to ▁ forward ▁ to ▁ the ▁ editor . STRNEWLINE ▁ : param ▁ require _ save : ▁ if ▁ this ▁ is ▁ true , ▁ then ▁ not ▁ saving ▁ in ▁ the ▁ editor STRNEWLINE ▁ will ▁ make ▁ the ▁ return ▁ value ▁ become ▁ ` None ` . STRNEWLINE ▁ : param ▁ extension : ▁ the ▁ extension ▁ to ▁ tell ▁ the ▁ editor ▁ about . ▁ This ▁ defaults STRNEWLINE ▁ to ▁ ` . txt ` ▁ but ▁ changing ▁ this ▁ might ▁ change ▁ syntax STRNEWLINE ▁ highlighting . STRNEWLINE ▁ : param ▁ filename : ▁ if ▁ provided ▁ it ▁ will ▁ edit ▁ this ▁ file ▁ instead ▁ of ▁ the STRNEWLINE ▁ provided ▁ text ▁ contents . ▁ It ▁ will ▁ not ▁ use ▁ a ▁ temporary STRNEWLINE ▁ file ▁ as ▁ an ▁ indirection ▁ in ▁ that ▁ case . STRNEWLINE ▁ """ NEW_LINE from . _termui_impl import Editor NEW_LINE editor = Editor ( editor = editor , env = env , require_save = require_save , extension = extension ) NEW_LINE if filename is None : NEW_LINE INDENT return editor . edit ( text ) NEW_LINE DEDENT editor . edit_file ( filename ) NEW_LINE DEDENT
def launch ( url , wait = False , locate = False ) : NEW_LINE INDENT """ This ▁ function ▁ launches ▁ the ▁ given ▁ URL ▁ ( or ▁ filename ) ▁ in ▁ the ▁ default STRNEWLINE ▁ viewer ▁ application ▁ for ▁ this ▁ file ▁ type . ▁ If ▁ this ▁ is ▁ an ▁ executable , ▁ it STRNEWLINE ▁ might ▁ launch ▁ the ▁ executable ▁ in ▁ a ▁ new ▁ session . ▁ The ▁ return ▁ value ▁ is STRNEWLINE ▁ the ▁ exit ▁ code ▁ of ▁ the ▁ launched ▁ application . ▁ Usually , ▁ ` ` 0 ` ` ▁ indicates STRNEWLINE ▁ success . STRNEWLINE STRNEWLINE ▁ Examples : : STRNEWLINE STRNEWLINE ▁ click . launch ( ' http : / / click . pocoo . org / ' ) STRNEWLINE ▁ click . launch ( ' / my / downloaded / file ' , ▁ locate = True ) STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 2.0 STRNEWLINE STRNEWLINE ▁ : param ▁ url : ▁ URL ▁ or ▁ filename ▁ of ▁ the ▁ thing ▁ to ▁ launch . STRNEWLINE ▁ : param ▁ wait : ▁ waits ▁ for ▁ the ▁ program ▁ to ▁ stop . STRNEWLINE ▁ : param ▁ locate : ▁ if ▁ this ▁ is ▁ set ▁ to ▁ ` True ` ▁ then ▁ instead ▁ of ▁ launching ▁ the STRNEWLINE ▁ application ▁ associated ▁ with ▁ the ▁ URL ▁ it ▁ will ▁ attempt ▁ to STRNEWLINE ▁ launch ▁ a ▁ file ▁ manager ▁ with ▁ the ▁ file ▁ located . ▁ This STRNEWLINE ▁ might ▁ have ▁ weird ▁ effects ▁ if ▁ the ▁ URL ▁ does ▁ not ▁ point ▁ to STRNEWLINE ▁ the ▁ filesystem . STRNEWLINE ▁ """ NEW_LINE from . _termui_impl import open_url NEW_LINE return open_url ( url , wait = wait , locate = locate ) NEW_LINE # ▁ If ▁ this ▁ is ▁ provided , ▁ getchar ( ) ▁ calls ▁ into ▁ this ▁ instead . ▁ This ▁ is ▁ used ENDCOM # ▁ for ▁ unittesting ▁ purposes . ENDCOM DEDENT
def getchar ( echo = False ) : NEW_LINE INDENT """ Fetches ▁ a ▁ single ▁ character ▁ from ▁ the ▁ terminal ▁ and ▁ returns ▁ it . ▁ This STRNEWLINE ▁ will ▁ always ▁ return ▁ a ▁ unicode ▁ character ▁ and ▁ under ▁ certain ▁ rare STRNEWLINE ▁ circumstances ▁ this ▁ might ▁ return ▁ more ▁ than ▁ one ▁ character . ▁ The STRNEWLINE ▁ situations ▁ which ▁ more ▁ than ▁ one ▁ character ▁ is ▁ returned ▁ is ▁ when ▁ for STRNEWLINE ▁ whatever ▁ reason ▁ multiple ▁ characters ▁ end ▁ up ▁ in ▁ the ▁ terminal ▁ buffer ▁ or STRNEWLINE ▁ standard ▁ input ▁ was ▁ not ▁ actually ▁ a ▁ terminal . STRNEWLINE STRNEWLINE ▁ Note ▁ that ▁ this ▁ will ▁ always ▁ read ▁ from ▁ the ▁ terminal , ▁ even ▁ if ▁ something STRNEWLINE ▁ is ▁ piped ▁ into ▁ the ▁ standard ▁ input . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 2.0 STRNEWLINE STRNEWLINE ▁ : param ▁ echo : ▁ if ▁ set ▁ to ▁ ` True ` , ▁ the ▁ character ▁ read ▁ will ▁ also ▁ show ▁ up ▁ on STRNEWLINE ▁ the ▁ terminal . ▁ The ▁ default ▁ is ▁ to ▁ not ▁ show ▁ it . STRNEWLINE ▁ """ NEW_LINE f = _getchar NEW_LINE if f is None : NEW_LINE INDENT from . _termui_impl import getchar as f NEW_LINE DEDENT return f ( echo ) NEW_LINE DEDENT
def __new__ ( cls , name , ndim , shape , upsample , downsample ) : NEW_LINE # ▁ Validations ENDCOM INDENT upsample = _validate_upsample ( upsample ) NEW_LINE downsample = _validate_downsample ( downsample ) NEW_LINE if int ( ndim ) < 0 : NEW_LINE INDENT raise ValueError ( " ndim ▁ must ▁ be ▁ positive ▁ not ▁ { } " . format ( ndim ) ) NEW_LINE DEDENT if shape is not None : NEW_LINE INDENT shape = tuple ( shape ) NEW_LINE DEDENT return super ( ColSpec , cls ) . __new__ ( cls , name , int ( ndim ) , shape , upsample , downsample ) NEW_LINE DEDENT
def _validate_upsample ( input ) : NEW_LINE # ▁ TODO ▁ The ▁ upsampling ▁ method ▁ could ▁ be ▁ any ▁ callable . ENDCOM INDENT if input is None or input == ' None ' : NEW_LINE INDENT return ' None ' NEW_LINE DEDENT if not ( input in ColSpec . upsampling_methods ) : NEW_LINE INDENT raise ValueError ( " { } ▁ is ▁ not ▁ a ▁ valid ▁ upsampling ▁ method . ▁ It ▁ " " must ▁ be ▁ one ▁ of ▁ { } " . format ( input , ColSpec . upsampling_methods ) ) NEW_LINE DEDENT return input . lower ( ) NEW_LINE DEDENT
def _validate_downsample ( input ) : NEW_LINE # ▁ TODO ▁ The ▁ downsampling ▁ methods ▁ could ▁ have ▁ string ▁ aliases ▁ like ▁ ' mean ' . ENDCOM INDENT if ( input is not None ) and ( not ( callable ( input ) or input in ColSpec . downsampling_methods ) ) : NEW_LINE INDENT raise ValueError ( " The ▁ downsampling ▁ method ▁ must ▁ be ▁ a ▁ callable , ▁ None , ▁ " " or ▁ one ▁ of ▁ { } . " . format ( ColSpec . downsampling_methods ) ) NEW_LINE DEDENT if input is None : NEW_LINE INDENT return ' None ' NEW_LINE DEDENT return input NEW_LINE DEDENT
def from_events ( cls , events , verbose = False ) : NEW_LINE INDENT """ STRNEWLINE ▁ Create ▁ a ▁ DataMuxer ▁ from ▁ a ▁ list ▁ of ▁ Events . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ events ▁ : ▁ list STRNEWLINE ▁ list ▁ of ▁ Events ▁ ( any ▁ objects ▁ with ▁ the ▁ expected ▁ attributes ▁ will ▁ do ) STRNEWLINE ▁ """ NEW_LINE instance = cls ( ) NEW_LINE instance . append_events ( events , verbose ) NEW_LINE return instance NEW_LINE DEDENT
def dataframe_to_dict ( df ) : NEW_LINE INDENT """ STRNEWLINE ▁ Turn ▁ a ▁ DataFrame ▁ into ▁ a ▁ dict ▁ of ▁ lists . STRNEWLINE STRNEWLINE ▁ Parameters STRNEWLINE ▁ - - - - - STRNEWLINE ▁ df ▁ : ▁ DataFrame STRNEWLINE STRNEWLINE ▁ Returns STRNEWLINE ▁ - - - - - STRNEWLINE ▁ index ▁ : ▁ ndarray STRNEWLINE ▁ The ▁ index ▁ of ▁ the ▁ data ▁ frame STRNEWLINE ▁ data ▁ : ▁ dict STRNEWLINE ▁ Dictionary ▁ keyed ▁ on ▁ column ▁ name ▁ of ▁ the ▁ column . ▁ The ▁ value ▁ is STRNEWLINE ▁ one ▁ of ▁ ( ndarray , ▁ list , ▁ pd . Series ) STRNEWLINE ▁ """ NEW_LINE dict_of_lists = { col : df [ col ] . to_list ( ) for col in df . columns } NEW_LINE return df . index . values , dict_of_lists NEW_LINE DEDENT
def _build_verified_downsample ( downsample , expected_shape ) : NEW_LINE # ▁ Ensure ▁ two ▁ things : ENDCOM # ▁ 1 . ▁ The ▁ downsampling ▁ function ▁ shouldn ' t ▁ touch ▁ bins ▁ with ▁ only ▁ one ▁ point . ENDCOM # ▁ 2 . ▁ The ▁ result ▁ of ▁ downsample ▁ should ▁ have ▁ the ▁ right ▁ shape . ENDCOM INDENT def _downsample ( data ) : NEW_LINE INDENT if len ( data ) == 1 : NEW_LINE INDENT return data NEW_LINE DEDENT downsampled = downsample ( data ) NEW_LINE if ( expected_shape is None or expected_shape == 0 ) : NEW_LINE INDENT if not np . isscalar ( downsampled ) : NEW_LINE INDENT raise BadDownsamplerError ( " The ▁ ' agg ' ▁ ( downsampling ) ▁ function ▁ " " for ▁ { 0 } ▁ is ▁ expected ▁ to ▁ produce ▁ " " a ▁ scalar ▁ from ▁ the ▁ data ▁ in ▁ each ▁ " " bin . " . format ( downsampled ) ) NEW_LINE DEDENT DEDENT elif downsampled . shape != expected_shape : NEW_LINE INDENT raise BadDownsamplerError ( " An ▁ ' agg ' ▁ ( downsampling ) ▁ function ▁ " " returns ▁ data ▁ shaped ▁ { 0 } ▁ but ▁ the ▁ " " shape ▁ { 1 } ▁ is ▁ expected . " . format ( downsampled . shape , expected_shape ) ) NEW_LINE DEDENT return downsampled NEW_LINE DEDENT return _downsample NEW_LINE DEDENT
def _timestamp_col_name ( source_name ) : NEW_LINE INDENT return ' { 0 } _ timestamp ' . format ( source_name ) NEW_LINE DEDENT
def _normalize_string_none ( val ) : NEW_LINE INDENT " Replay ▁ passes ▁ ' None ' ▁ to ▁ mean ▁ None . " NEW_LINE try : NEW_LINE INDENT lowercase_val = val . lower ( ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT return val NEW_LINE DEDENT if lowercase_val == ' none ' : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT
def _is_resampling_applicable ( counts ) : NEW_LINE INDENT has_no_points = counts == 0 NEW_LINE has_multiple_points = counts > 1 NEW_LINE upsampling_possible = has_no_points . any ( ) NEW_LINE downsampling_needed = has_multiple_points . any ( ) NEW_LINE result = { } NEW_LINE result [ ' upsampling _ possible ' ] = upsampling_possible . to_dict ( ) NEW_LINE result [ ' downsampling _ needed ' ] = downsampling_needed . to_dict ( ) NEW_LINE return result NEW_LINE DEDENT
