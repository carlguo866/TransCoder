def query ( cls , context ) : NEW_LINE INDENT obj = cls ( context ) NEW_LINE obj . foo = 1 NEW_LINE obj . bar = ' bar ' NEW_LINE obj . obj_reset_changes ( ) NEW_LINE return obj NEW_LINE DEDENT
def obj_name ( cls ) : NEW_LINE INDENT return ' MyObj ' NEW_LINE DEDENT
def get ( cls , * args , ** kwargs ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def buildModel ( ) : NEW_LINE INDENT global model NEW_LINE global soma NEW_LINE model = moose . Neutral ( ' / model ' ) NEW_LINE soma = moose . Compartment ( ' / model / soma ' ) NEW_LINE soma . Em = - 60e-3 NEW_LINE soma . Rm = 1e10 NEW_LINE soma . Cm = 1e-10 NEW_LINE return model NEW_LINE DEDENT
def stimulus ( ) : NEW_LINE INDENT global soma NEW_LINE global vmtab NEW_LINE pulse = moose . PulseGen ( ' / model / pulse ' ) NEW_LINE pulse . delay [ 0 ] = 50e-3 NEW_LINE pulse . width [ 0 ] = 100e-3 NEW_LINE pulse . level [ 0 ] = 1e-9 NEW_LINE pulse . delay [ 1 ] = 1e9 NEW_LINE vmtab = moose . Table ( ' / soma _ Vm ' ) NEW_LINE moose . connect ( pulse , ' output ' , soma , ' injectMsg ' ) NEW_LINE moose . connect ( vmtab , ' requestOut ' , soma , ' getVm ' ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT global vmtab NEW_LINE buildModel ( ) NEW_LINE stimulus ( ) NEW_LINE moose . reinit ( ) NEW_LINE t = 500e-2 NEW_LINE moose . start ( t ) NEW_LINE time_vector = pylab . linspace ( 0 , t , len ( vmtab . vector ) ) NEW_LINE pylab . plot ( time_vector , vmtab . vector ) NEW_LINE pylab . show ( ) NEW_LINE # ▁ pylab . savefig ( ' soma _ passive . png ' ) ENDCOM DEDENT
def is_password_usable ( encoded ) : NEW_LINE INDENT if encoded is None or encoded . startswith ( UNUSABLE_PASSWORD_PREFIX ) : NEW_LINE INDENT return False NEW_LINE DEDENT try : NEW_LINE INDENT identify_hasher ( encoded ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def check_password ( password , encoded , setter = None , preferred = ' default ' ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ a ▁ boolean ▁ of ▁ whether ▁ the ▁ raw ▁ password ▁ matches ▁ the ▁ three STRNEWLINE ▁ part ▁ encoded ▁ digest . STRNEWLINE STRNEWLINE ▁ If ▁ setter ▁ is ▁ specified , ▁ it ' ll ▁ be ▁ called ▁ when ▁ you ▁ need ▁ to STRNEWLINE ▁ regenerate ▁ the ▁ password . STRNEWLINE ▁ """ NEW_LINE if password is None or not is_password_usable ( encoded ) : NEW_LINE INDENT return False NEW_LINE DEDENT preferred = get_hasher ( preferred ) NEW_LINE hasher = identify_hasher ( encoded ) NEW_LINE hasher_changed = hasher . algorithm != preferred . algorithm NEW_LINE must_update = hasher_changed or preferred . must_update ( encoded ) NEW_LINE is_correct = hasher . verify ( password , encoded ) NEW_LINE # ▁ If ▁ the ▁ hasher ▁ didn ' t ▁ change ▁ ( we ▁ don ' t ▁ protect ▁ against ▁ enumeration ▁ if ▁ it ENDCOM # ▁ does ) ▁ and ▁ the ▁ password ▁ should ▁ get ▁ updated , ▁ try ▁ to ▁ close ▁ the ▁ timing ▁ gap ENDCOM # ▁ between ▁ the ▁ work ▁ factor ▁ of ▁ the ▁ current ▁ encoded ▁ password ▁ and ▁ the ▁ default ENDCOM # ▁ work ▁ factor . ENDCOM if not is_correct and not hasher_changed and must_update : NEW_LINE INDENT hasher . harden_runtime ( password , encoded ) NEW_LINE DEDENT if setter and is_correct and must_update : NEW_LINE INDENT setter ( password ) NEW_LINE DEDENT return is_correct NEW_LINE DEDENT
def make_password ( password , salt = None , hasher = ' default ' ) : NEW_LINE INDENT """ STRNEWLINE ▁ Turn ▁ a ▁ plain - text ▁ password ▁ into ▁ a ▁ hash ▁ for ▁ database ▁ storage STRNEWLINE STRNEWLINE ▁ Same ▁ as ▁ encode ( ) ▁ but ▁ generate ▁ a ▁ new ▁ random ▁ salt . ▁ If ▁ password ▁ is ▁ None ▁ then STRNEWLINE ▁ return ▁ a ▁ concatenation ▁ of ▁ UNUSABLE _ PASSWORD _ PREFIX ▁ and ▁ a ▁ random ▁ string , STRNEWLINE ▁ which ▁ disallows ▁ logins . ▁ Additional ▁ random ▁ string ▁ reduces ▁ chances ▁ of ▁ gaining STRNEWLINE ▁ access ▁ to ▁ staff ▁ or ▁ superuser ▁ accounts . ▁ See ▁ ticket ▁ # 20079 ▁ for ▁ more ▁ info . STRNEWLINE ▁ """ NEW_LINE if password is None : NEW_LINE INDENT return UNUSABLE_PASSWORD_PREFIX + get_random_string ( UNUSABLE_PASSWORD_SUFFIX_LENGTH ) NEW_LINE DEDENT hasher = get_hasher ( hasher ) NEW_LINE if not salt : NEW_LINE INDENT salt = hasher . salt ( ) NEW_LINE DEDENT return hasher . encode ( password , salt ) NEW_LINE DEDENT
def get_hashers ( ) : NEW_LINE INDENT hashers = [ ] NEW_LINE for hasher_path in settings . PASSWORD_HASHERS : NEW_LINE INDENT hasher_cls = import_string ( hasher_path ) NEW_LINE hasher = hasher_cls ( ) NEW_LINE if not getattr ( hasher , ' algorithm ' ) : NEW_LINE INDENT raise ImproperlyConfigured ( " hasher ▁ doesn ' t ▁ specify ▁ an ▁ " " algorithm ▁ name : ▁ % s " % hasher_path ) NEW_LINE DEDENT hashers . append ( hasher ) NEW_LINE DEDENT return hashers NEW_LINE DEDENT
def get_hashers_by_algorithm ( ) : NEW_LINE INDENT return { hasher . algorithm : hasher for hasher in get_hashers ( ) } NEW_LINE DEDENT
def reset_hashers ( ** kwargs ) : NEW_LINE INDENT if kwargs [ ' setting ' ] == ' PASSWORD _ HASHERS ' : NEW_LINE INDENT get_hashers . cache_clear ( ) NEW_LINE get_hashers_by_algorithm . cache_clear ( ) NEW_LINE DEDENT DEDENT
def get_hasher ( algorithm = ' default ' ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ an ▁ instance ▁ of ▁ a ▁ loaded ▁ password ▁ hasher . STRNEWLINE STRNEWLINE ▁ If ▁ algorithm ▁ is ▁ ' default ' , ▁ return ▁ the ▁ default ▁ hasher . ▁ Lazily ▁ import ▁ hashers STRNEWLINE ▁ specified ▁ in ▁ the ▁ project ' s ▁ settings ▁ file ▁ if ▁ needed . STRNEWLINE ▁ """ NEW_LINE if hasattr ( algorithm , ' algorithm ' ) : NEW_LINE INDENT return algorithm NEW_LINE DEDENT elif algorithm == ' default ' : NEW_LINE INDENT return get_hashers ( ) [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT hashers = get_hashers_by_algorithm ( ) NEW_LINE try : NEW_LINE INDENT return hashers [ algorithm ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise ValueError ( " Unknown ▁ password ▁ hashing ▁ algorithm ▁ ' % s ' . ▁ " " Did ▁ you ▁ specify ▁ it ▁ in ▁ the ▁ PASSWORD _ HASHERS ▁ " " setting ? " % algorithm ) NEW_LINE DEDENT DEDENT DEDENT
def identify_hasher ( encoded ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ an ▁ instance ▁ of ▁ a ▁ loaded ▁ password ▁ hasher . STRNEWLINE STRNEWLINE ▁ Identify ▁ hasher ▁ algorithm ▁ by ▁ examining ▁ encoded ▁ hash , ▁ and ▁ call STRNEWLINE ▁ get _ hasher ( ) ▁ to ▁ return ▁ hasher . ▁ Raise ▁ ValueError ▁ if STRNEWLINE ▁ algorithm ▁ cannot ▁ be ▁ identified , ▁ or ▁ if ▁ hasher ▁ is ▁ not ▁ loaded . STRNEWLINE ▁ """ NEW_LINE # ▁ Ancient ▁ versions ▁ of ▁ Django ▁ created ▁ plain ▁ MD5 ▁ passwords ▁ and ▁ accepted ENDCOM # ▁ MD5 ▁ passwords ▁ with ▁ an ▁ empty ▁ salt . ENDCOM if ( ( len ( encoded ) == 32 and ' $ ' not in encoded ) or ( len ( encoded ) == 37 and encoded . startswith ( ' md5 $ $ ' ) ) ) : NEW_LINE INDENT algorithm = ' unsalted _ md5' NEW_LINE # ▁ Ancient ▁ versions ▁ of ▁ Django ▁ accepted ▁ SHA1 ▁ passwords ▁ with ▁ an ▁ empty ▁ salt . ENDCOM DEDENT elif len ( encoded ) == 46 and encoded . startswith ( ' sha1 $ $ ' ) : NEW_LINE INDENT algorithm = ' unsalted _ sha1' NEW_LINE DEDENT else : NEW_LINE INDENT algorithm = encoded . split ( ' $ ' , 1 ) [ 0 ] NEW_LINE DEDENT return get_hasher ( algorithm ) NEW_LINE DEDENT
def mask_hash ( hash , show = 6 , char = " * " ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ the ▁ given ▁ hash , ▁ with ▁ only ▁ the ▁ first ▁ ` ` show ` ` ▁ number ▁ shown . ▁ The STRNEWLINE ▁ rest ▁ are ▁ masked ▁ with ▁ ` ` char ` ` ▁ for ▁ security ▁ reasons . STRNEWLINE ▁ """ NEW_LINE masked = hash [ : show ] NEW_LINE masked += char * len ( hash [ show : ] ) NEW_LINE return masked NEW_LINE DEDENT
def parse_po ( text ) : NEW_LINE INDENT """ STRNEWLINE ▁ Parse ▁ ' po ' ▁ format ▁ produced ▁ by ▁ xgettext . STRNEWLINE ▁ Return ▁ a ▁ list ▁ of ▁ ( msgid , msgstr ) ▁ tuples . STRNEWLINE ▁ """ NEW_LINE messages = [ ] NEW_LINE msgid = [ ] NEW_LINE msgstr = [ ] NEW_LINE in_msgid = False NEW_LINE in_msgstr = False NEW_LINE for line in text . split ( ' \n ' ) : NEW_LINE INDENT line = line . rstrip ( ' ' ) NEW_LINE if line . startswith ( ' msgid ▁ ' ) : NEW_LINE INDENT if in_msgstr : NEW_LINE INDENT messages . append ( ( msgid , msgstr ) ) NEW_LINE in_msgstr = False NEW_LINE # ▁ message ▁ start ENDCOM DEDENT in_msgid = True NEW_LINE msgid = [ line [ 6 : ] ] NEW_LINE DEDENT elif line . startswith ( ' msgstr ▁ ' ) : NEW_LINE INDENT in_msgid = False NEW_LINE in_msgstr = True NEW_LINE msgstr = [ line [ 7 : ] ] NEW_LINE DEDENT elif line . startswith ( ' " ' ) : NEW_LINE INDENT if in_msgid : NEW_LINE INDENT msgid . append ( line ) NEW_LINE DEDENT if in_msgstr : NEW_LINE INDENT msgstr . append ( line ) NEW_LINE DEDENT DEDENT DEDENT if in_msgstr : NEW_LINE INDENT messages . append ( ( msgid , msgstr ) ) NEW_LINE DEDENT return messages NEW_LINE DEDENT
