<DOCUMENT_ID="odoousers2014/odoo/tree/master/addons/website_sale_delivery/models/sale_order.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM from openerp . osv import orm , fields NEW_LINE from openerp import SUPERUSER_ID NEW_LINE from openerp . addons import decimal_precision NEW_LINE class delivery_carrier ( orm . Model ) : NEW_LINE INDENT _name = ' delivery . carrier ' NEW_LINE _inherit = [ ' delivery . carrier ' , ' website . published . mixin ' ] NEW_LINE _columns = { ' website _ description ' : fields . text ( ' Description ▁ for ▁ the ▁ website ' ) , } NEW_LINE _defaults = { ' website _ published ' : True } NEW_LINE DEDENT class SaleOrder ( orm . Model ) : NEW_LINE INDENT _inherit = ' sale . order ' NEW_LINE def _amount_all_wrapper ( self , cr , uid , ids , field_name , arg , context = None ) : NEW_LINE INDENT """ ▁ Wrapper ▁ because ▁ of ▁ direct ▁ method ▁ passing ▁ as ▁ parameter ▁ for ▁ function ▁ fields ▁ """ NEW_LINE return self . _amount_all ( cr , uid , ids , field_name , arg , context = context ) NEW_LINE DEDENT def _amount_all ( self , cr , uid , ids , field_name , arg , context = None ) : NEW_LINE INDENT res = super ( SaleOrder , self ) . _amount_all ( cr , uid , ids , field_name , arg , context = context ) NEW_LINE currency_pool = self . pool . get ( ' res . currency ' ) NEW_LINE for order in self . browse ( cr , uid , ids , context = context ) : NEW_LINE INDENT line_amount = sum ( [ line . price_subtotal for line in order . order_line if line . is_delivery ] ) NEW_LINE currency = order . pricelist_id . currency_id NEW_LINE res [ order . id ] [ ' amount _ delivery ' ] = currency_pool . round ( cr , uid , currency , line_amount ) NEW_LINE DEDENT return res NEW_LINE DEDENT def _get_order ( self , cr , uid , ids , context = None ) : NEW_LINE INDENT result = { } NEW_LINE for line in self . pool . get ( ' sale . order . line ' ) . browse ( cr , uid , ids , context = context ) : NEW_LINE INDENT result [ line . order_id . id ] = True NEW_LINE DEDENT return result . keys ( ) NEW_LINE DEDENT _columns = { ' amount _ delivery ' : fields . function ( _amount_all_wrapper , type = ' float ' , digits_compute = decimal_precision . get_precision ( ' Account ' ) , string = ' Delivery ▁ Amount ' , store = { ' sale . order ' : ( lambda self , cr , uid , ids , c = { } : ids , [ ' order _ line ' ] , 10 ) , ' sale . order . line ' : ( _get_order , [ ' price _ unit ' , ' tax _ id ' , ' discount ' , ' product _ uom _ qty ' ] , 10 ) , } , multi = ' sums ' , help = " The ▁ amount ▁ without ▁ tax . " , track_visibility = ' always ' ) , ' website _ order _ line ' : fields . one2many ( ' sale . order . line ' , ' order _ id ' , string = ' Order ▁ Lines ▁ displayed ▁ on ▁ Website ' , readonly = True , domain = [ ( ' is _ delivery ' , ' = ' , False ) ] , help = ' Order ▁ Lines ▁ to ▁ be ▁ displayed ▁ on ▁ the ▁ website . ▁ They ▁ should ▁ not ▁ be ▁ used ▁ for ▁ computation ▁ purpose . ' , ) , } NEW_LINE def _check_carrier_quotation ( self , cr , uid , order , force_carrier_id = None , context = None ) : NEW_LINE INDENT carrier_obj = self . pool . get ( ' delivery . carrier ' ) NEW_LINE # ▁ check ▁ to ▁ add ▁ or ▁ remove ▁ carrier _ id ENDCOM if not order : NEW_LINE INDENT return False NEW_LINE DEDENT if all ( line . product_id . type == " service " for line in order . website_order_line ) : NEW_LINE INDENT order . write ( { ' carrier _ id ' : None } ) NEW_LINE self . pool [ ' sale . order ' ] . _delivery_unset ( cr , SUPERUSER_ID , [ order . id ] , context = context ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT carrier_id = force_carrier_id or order . carrier_id . id NEW_LINE carrier_ids = self . _get_delivery_methods ( cr , uid , order , context = context ) NEW_LINE if carrier_id : NEW_LINE INDENT if carrier_id not in carrier_ids : NEW_LINE INDENT carrier_id = False NEW_LINE DEDENT else : NEW_LINE INDENT carrier_ids . remove ( carrier_id ) NEW_LINE carrier_ids . insert ( 0 , carrier_id ) NEW_LINE DEDENT DEDENT if force_carrier_id or not carrier_id or not carrier_id in carrier_ids : NEW_LINE INDENT for delivery_id in carrier_ids : NEW_LINE INDENT grid_id = carrier_obj . grid_get ( cr , SUPERUSER_ID , [ delivery_id ] , order . partner_shipping_id . id ) NEW_LINE if grid_id : NEW_LINE INDENT carrier_id = delivery_id NEW_LINE break NEW_LINE DEDENT DEDENT order . write ( { ' carrier _ id ' : carrier_id } ) NEW_LINE DEDENT if carrier_id : NEW_LINE INDENT order . delivery_set ( ) NEW_LINE DEDENT else : NEW_LINE INDENT order . _delivery_unset ( ) NEW_LINE DEDENT DEDENT return bool ( carrier_id ) NEW_LINE DEDENT def _get_delivery_methods ( self , cr , uid , order , context = None ) : NEW_LINE INDENT carrier_obj = self . pool . get ( ' delivery . carrier ' ) NEW_LINE delivery_ids = carrier_obj . search ( cr , uid , [ ( ' website _ published ' , ' = ' , True ) ] , context = context ) NEW_LINE # ▁ Following ▁ loop ▁ is ▁ done ▁ to ▁ avoid ▁ displaying ▁ delivery ▁ methods ▁ who ▁ are ▁ not ▁ available ▁ for ▁ this ▁ order ENDCOM # ▁ This ▁ can ▁ surely ▁ be ▁ done ▁ in ▁ a ▁ more ▁ efficient ▁ way , ▁ but ▁ at ▁ the ▁ moment , ▁ it ▁ mimics ▁ the ▁ way ▁ it ' s ENDCOM # ▁ done ▁ in ▁ delivery _ set ▁ method ▁ of ▁ sale . py , ▁ from ▁ delivery ▁ module ENDCOM for delivery_id in carrier_obj . browse ( cr , SUPERUSER_ID , delivery_ids , context = dict ( context , order_id = order . id ) ) : NEW_LINE INDENT if not delivery_id . available : NEW_LINE INDENT delivery_ids . remove ( delivery_id . id ) NEW_LINE DEDENT DEDENT return delivery_ids NEW_LINE DEDENT def _get_errors ( self , cr , uid , order , context = None ) : NEW_LINE INDENT errors = super ( SaleOrder , self ) . _get_errors ( cr , uid , order , context = context ) NEW_LINE if not self . _get_delivery_methods ( cr , uid , order , context = context ) : NEW_LINE INDENT errors . append ( ( ' No ▁ delivery ▁ method ▁ available ' , ' There ▁ is ▁ no ▁ available ▁ delivery ▁ method ▁ for ▁ your ▁ order ' ) ) NEW_LINE DEDENT return errors NEW_LINE DEDENT def _get_website_data ( self , cr , uid , order , context = None ) : NEW_LINE INDENT """ ▁ Override ▁ to ▁ add ▁ delivery - related ▁ website ▁ data . ▁ """ NEW_LINE values = super ( SaleOrder , self ) . _get_website_data ( cr , uid , order , context = context ) NEW_LINE # ▁ We ▁ need ▁ a ▁ delivery ▁ only ▁ if ▁ we ▁ have ▁ stockable ▁ products ENDCOM has_stockable_products = False NEW_LINE for line in order . order_line : NEW_LINE INDENT if line . product_id . type in ( ' consu ' , ' product ' ) : NEW_LINE INDENT has_stockable_products = True NEW_LINE DEDENT DEDENT if not has_stockable_products : NEW_LINE INDENT return values NEW_LINE DEDENT delivery_ctx = dict ( context , order_id = order . id ) NEW_LINE DeliveryCarrier = self . pool . get ( ' delivery . carrier ' ) NEW_LINE delivery_ids = self . _get_delivery_methods ( cr , uid , order , context = context ) NEW_LINE values [ ' deliveries ' ] = DeliveryCarrier . browse ( cr , SUPERUSER_ID , delivery_ids , context = delivery_ctx ) NEW_LINE return values NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="vqw/frappe/tree/master/frappe/model/delete_doc.py"> # ▁ Copyright ▁ ( c ) ▁ 2015 , ▁ Frappe ▁ Technologies ▁ Pvt . ▁ Ltd . ▁ and ▁ Contributors ENDCOM # ▁ MIT ▁ License . ▁ See ▁ license . txt ENDCOM from __future__ import unicode_literals NEW_LINE import frappe NEW_LINE import frappe . model . meta NEW_LINE from frappe . model . dynamic_links import get_dynamic_link_map NEW_LINE import frappe . defaults NEW_LINE from frappe . utils . file_manager import remove_all NEW_LINE from frappe . utils . password import delete_all_passwords_for NEW_LINE from frappe import _ NEW_LINE from frappe . model . naming import revert_series_if_last NEW_LINE def delete_doc ( doctype = None , name = None , force = 0 , ignore_doctypes = None , for_reload = False , ignore_permissions = False , flags = None , ignore_on_trash = False ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Deletes ▁ a ▁ doc ( dt , ▁ dn ) ▁ and ▁ validates ▁ if ▁ it ▁ is ▁ not ▁ submitted ▁ and ▁ not ▁ linked ▁ in ▁ a ▁ live ▁ record STRNEWLINE TABSYMBOL """ NEW_LINE if not ignore_doctypes : ignore_doctypes = [ ] NEW_LINE # ▁ get ▁ from ▁ form ENDCOM if not doctype : NEW_LINE INDENT doctype = frappe . form_dict . get ( ' dt ' ) NEW_LINE name = frappe . form_dict . get ( ' dn ' ) NEW_LINE DEDENT names = name NEW_LINE if isinstance ( name , basestring ) : NEW_LINE INDENT names = [ name ] NEW_LINE DEDENT for name in names or [ ] : NEW_LINE # ▁ already ▁ deleted . . ? ENDCOM INDENT if not frappe . db . exists ( doctype , name ) : NEW_LINE INDENT return NEW_LINE # ▁ delete ▁ attachments ENDCOM DEDENT remove_all ( doctype , name ) NEW_LINE # ▁ delete ▁ passwords ENDCOM delete_all_passwords_for ( doctype , name ) NEW_LINE doc = None NEW_LINE if doctype == " DocType " : NEW_LINE INDENT if for_reload : NEW_LINE INDENT try : NEW_LINE INDENT doc = frappe . get_doc ( doctype , name ) NEW_LINE DEDENT except frappe . DoesNotExistError : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT doc . run_method ( " before _ reload " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT doc = frappe . get_doc ( doctype , name ) NEW_LINE update_flags ( doc , flags , ignore_permissions ) NEW_LINE check_permission_and_not_submitted ( doc ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabCustom ▁ Field ` ▁ where ▁ dt ▁ = ▁ % s " , name ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabCustom ▁ Script ` ▁ where ▁ dt ▁ = ▁ % s " , name ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabProperty ▁ Setter ` ▁ where ▁ doc _ type ▁ = ▁ % s " , name ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabReport ` ▁ where ▁ ref _ doctype = % s " , name ) NEW_LINE DEDENT delete_from_table ( doctype , name , ignore_doctypes , None ) NEW_LINE DEDENT else : NEW_LINE INDENT doc = frappe . get_doc ( doctype , name ) NEW_LINE if not for_reload : NEW_LINE INDENT update_flags ( doc , flags , ignore_permissions ) NEW_LINE check_permission_and_not_submitted ( doc ) NEW_LINE if not ignore_on_trash : NEW_LINE INDENT doc . run_method ( " on _ trash " ) NEW_LINE doc . run_method ( ' on _ change ' ) NEW_LINE DEDENT dynamic_linked_doctypes = [ df . parent for df in get_dynamic_link_map ( ) . get ( doc . doctype , [ ] ) ] NEW_LINE if " ToDo " in dynamic_linked_doctypes : NEW_LINE INDENT delete_linked_todos ( doc ) NEW_LINE DEDENT if " Communication " in dynamic_linked_doctypes : NEW_LINE INDENT delete_linked_communications ( doc ) NEW_LINE DEDENT if " DocShare " in dynamic_linked_doctypes : NEW_LINE INDENT delete_shared ( doc ) NEW_LINE DEDENT if " Email ▁ Unsubscribe " in dynamic_linked_doctypes : NEW_LINE INDENT delete_email_subscribe ( doc ) NEW_LINE # ▁ check ▁ if ▁ links ▁ exist ENDCOM DEDENT if not force : NEW_LINE INDENT check_if_doc_is_linked ( doc ) NEW_LINE check_if_doc_is_dynamically_linked ( doc ) NEW_LINE DEDENT DEDENT update_naming_series ( doc ) NEW_LINE delete_from_table ( doctype , name , ignore_doctypes , doc ) NEW_LINE doc . run_method ( " after _ delete " ) NEW_LINE DEDENT if doc and not frappe . flags . in_patch : NEW_LINE INDENT try : NEW_LINE INDENT doc . notify_update ( ) NEW_LINE insert_feed ( doc ) NEW_LINE DEDENT except ImportError : NEW_LINE INDENT pass NEW_LINE # ▁ delete ▁ user _ permissions ENDCOM DEDENT DEDENT frappe . defaults . clear_default ( parenttype = " User ▁ Permission " , key = doctype , value = name ) NEW_LINE DEDENT DEDENT def update_naming_series ( doc ) : NEW_LINE INDENT if doc . meta . autoname : NEW_LINE INDENT if doc . meta . autoname . startswith ( " naming _ series : " ) and getattr ( doc , " naming _ series " , None ) : NEW_LINE INDENT revert_series_if_last ( doc . naming_series , doc . name ) NEW_LINE DEDENT elif doc . meta . autoname . split ( " : " ) [ 0 ] not in ( " Prompt " , " field " , " hash " ) : NEW_LINE INDENT revert_series_if_last ( doc . meta . autoname , doc . name ) NEW_LINE DEDENT DEDENT DEDENT def delete_from_table ( doctype , name , ignore_doctypes , doc ) : NEW_LINE INDENT if doctype != " DocType " and doctype == name : NEW_LINE INDENT frappe . db . sql ( " delete ▁ from ▁ ` tabSingles ` ▁ where ▁ doctype = % s " , name ) NEW_LINE DEDENT else : NEW_LINE INDENT frappe . db . sql ( " delete ▁ from ▁ ` tab % s ` ▁ where ▁ name = % s " % ( frappe . db . escape ( doctype ) , " % s " ) , ( name , ) ) NEW_LINE # ▁ get ▁ child ▁ tables ENDCOM DEDENT if doc : NEW_LINE INDENT tables = [ d . options for d in doc . meta . get_table_fields ( ) ] NEW_LINE DEDENT else : NEW_LINE INDENT def get_table_fields ( field_doctype ) : NEW_LINE INDENT return frappe . db . sql_list ( """ select ▁ options ▁ from ▁ ` tab { } ` ▁ where ▁ fieldtype = ' Table ' STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL and ▁ parent = % s """ . format ( field_doctype ) , doctype ) NEW_LINE DEDENT tables = get_table_fields ( " DocField " ) NEW_LINE if not frappe . flags . in_install == " frappe " : NEW_LINE INDENT tables += get_table_fields ( " Custom ▁ Field " ) NEW_LINE # ▁ delete ▁ from ▁ child ▁ tables ENDCOM DEDENT DEDENT for t in list ( set ( tables ) ) : NEW_LINE INDENT if t not in ignore_doctypes : NEW_LINE INDENT frappe . db . sql ( " delete ▁ from ▁ ` tab % s ` ▁ where ▁ parenttype = % s ▁ and ▁ parent ▁ = ▁ % s " % ( t , ' % s ' , ' % s ' ) , ( doctype , name ) ) NEW_LINE DEDENT DEDENT DEDENT def update_flags ( doc , flags = None , ignore_permissions = False ) : NEW_LINE INDENT if ignore_permissions : NEW_LINE INDENT if not flags : flags = { } NEW_LINE flags [ " ignore _ permissions " ] = ignore_permissions NEW_LINE DEDENT if flags : NEW_LINE INDENT doc . flags . update ( flags ) NEW_LINE DEDENT DEDENT def check_permission_and_not_submitted ( doc ) : NEW_LINE # ▁ permission ENDCOM INDENT if not doc . flags . ignore_permissions and frappe . session . user != " Administrator " and ( not doc . has_permission ( " delete " ) or ( doc . doctype == " DocType " and not doc . custom ) ) : NEW_LINE INDENT frappe . msgprint ( _ ( " User ▁ not ▁ allowed ▁ to ▁ delete ▁ { 0 } : ▁ { 1 } " ) . format ( doc . doctype , doc . name ) , raise_exception = True ) NEW_LINE # ▁ check ▁ if ▁ submitted ENDCOM DEDENT if doc . docstatus == 1 : NEW_LINE INDENT frappe . msgprint ( _ ( " { 0 } ▁ { 1 } : ▁ Submitted ▁ Record ▁ cannot ▁ be ▁ deleted . " ) . format ( doc . doctype , doc . name ) , raise_exception = True ) NEW_LINE DEDENT DEDENT def check_if_doc_is_linked ( doc , method = " Delete " ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Raises ▁ excption ▁ if ▁ the ▁ given ▁ doc ( dt , ▁ dn ) ▁ is ▁ linked ▁ in ▁ another ▁ record . STRNEWLINE TABSYMBOL """ NEW_LINE from frappe . model . rename_doc import get_link_fields NEW_LINE link_fields = get_link_fields ( doc . doctype ) NEW_LINE link_fields = [ [ lf [ ' parent ' ] , lf [ ' fieldname ' ] , lf [ ' issingle ' ] ] for lf in link_fields ] NEW_LINE for link_dt , link_field , issingle in link_fields : NEW_LINE INDENT if not issingle : NEW_LINE INDENT item = frappe . db . get_value ( link_dt , { link_field : doc . name } , [ " name " , " parent " , " parenttype " , " docstatus " ] , as_dict = True ) NEW_LINE if item and ( ( item . parent or item . name ) != doc . name ) and ( ( method == " Delete " and item . docstatus < 2 ) or ( method == " Cancel " and item . docstatus == 1 ) ) : NEW_LINE # ▁ raise ▁ exception ▁ only ▁ if ENDCOM # ▁ linked ▁ to ▁ an ▁ non - cancelled ▁ doc ▁ when ▁ deleting ENDCOM # ▁ or ▁ linked ▁ to ▁ a ▁ submitted ▁ doc ▁ when ▁ cancelling ENDCOM INDENT frappe . throw ( _ ( " Cannot ▁ delete ▁ or ▁ cancel ▁ because ▁ { 0 } ▁ { 1 } ▁ is ▁ linked ▁ with ▁ { 2 } ▁ { 3 } " ) . format ( doc . doctype , doc . name , item . parenttype if item . parent else link_dt , item . parent or item . name ) , frappe . LinkExistsError ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def check_if_doc_is_dynamically_linked ( doc , method = " Delete " ) : NEW_LINE INDENT ''' Raise ▁ ` frappe . LinkExistsError ` ▁ if ▁ the ▁ document ▁ is ▁ dynamically ▁ linked ''' NEW_LINE for df in get_dynamic_link_map ( ) . get ( doc . doctype , [ ] ) : NEW_LINE INDENT if df . parent in ( " Communication " , " ToDo " , " DocShare " , " Email ▁ Unsubscribe " ) : NEW_LINE # ▁ don ' t ▁ check ▁ for ▁ communication ▁ and ▁ todo ! ENDCOM INDENT continue NEW_LINE DEDENT meta = frappe . get_meta ( df . parent ) NEW_LINE if meta . issingle : NEW_LINE # ▁ dynamic ▁ link ▁ in ▁ single ▁ doc ENDCOM INDENT refdoc = frappe . db . get_singles_dict ( df . parent ) NEW_LINE if ( refdoc . get ( df . options ) == doc . doctype and refdoc . get ( df . fieldname ) == doc . name and ( ( method == " Delete " and refdoc . docstatus < 2 ) or ( method == " Cancel " and refdoc . docstatus == 1 ) ) ) : NEW_LINE # ▁ raise ▁ exception ▁ only ▁ if ENDCOM # ▁ linked ▁ to ▁ an ▁ non - cancelled ▁ doc ▁ when ▁ deleting ENDCOM # ▁ or ▁ linked ▁ to ▁ a ▁ submitted ▁ doc ▁ when ▁ cancelling ENDCOM INDENT frappe . throw ( _ ( " Cannot ▁ delete ▁ or ▁ cancel ▁ because ▁ { 0 } ▁ { 1 } ▁ is ▁ linked ▁ with ▁ { 2 } ▁ { 3 } " ) . format ( doc . doctype , doc . name , df . parent , " " ) , frappe . LinkExistsError ) NEW_LINE DEDENT DEDENT else : NEW_LINE # ▁ dynamic ▁ link ▁ in ▁ table ENDCOM INDENT for refdoc in frappe . db . sql ( """ select ▁ name , ▁ docstatus ▁ from ▁ ` tab { parent } ` ▁ where STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL { options } = % s ▁ and ▁ { fieldname } = % s """ . format ( ** df ) , ( doc . doctype , doc . name ) , as_dict = True ) : NEW_LINE INDENT if ( ( method == " Delete " and refdoc . docstatus < 2 ) or ( method == " Cancel " and refdoc . docstatus == 1 ) ) : NEW_LINE # ▁ raise ▁ exception ▁ only ▁ if ENDCOM # ▁ linked ▁ to ▁ an ▁ non - cancelled ▁ doc ▁ when ▁ deleting ENDCOM # ▁ or ▁ linked ▁ to ▁ a ▁ submitted ▁ doc ▁ when ▁ cancelling ENDCOM INDENT frappe . throw ( _ ( " Cannot ▁ delete ▁ or ▁ cancel ▁ because ▁ { 0 } ▁ { 1 } ▁ is ▁ linked ▁ with ▁ { 2 } ▁ { 3 } " ) . format ( doc . doctype , doc . name , df . parent , refdoc . name ) , frappe . LinkExistsError ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def delete_linked_todos ( doc ) : NEW_LINE INDENT delete_doc ( " ToDo " , frappe . db . sql_list ( """ select ▁ name ▁ from ▁ ` tabToDo ` STRNEWLINE TABSYMBOL TABSYMBOL where ▁ reference _ type = % s ▁ and ▁ reference _ name = % s """ , ( doc . doctype , doc . name ) ) , ignore_permissions = True ) NEW_LINE DEDENT def delete_email_subscribe ( doc ) : NEW_LINE INDENT frappe . db . sql ( ''' delete ▁ from ▁ ` tabEmail ▁ Unsubscribe ` STRNEWLINE TABSYMBOL TABSYMBOL where ▁ reference _ doctype = % s ▁ and ▁ reference _ name = % s ''' , ( doc . doctype , doc . name ) ) NEW_LINE DEDENT def delete_linked_communications ( doc ) : NEW_LINE # ▁ delete ▁ comments ENDCOM INDENT frappe . db . sql ( """ delete ▁ from ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL where STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL communication _ type ▁ = ▁ ' Comment ' STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL and ▁ reference _ doctype = % s ▁ and ▁ reference _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE # ▁ make ▁ communications ▁ orphans ENDCOM frappe . db . sql ( """ update ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL set ▁ reference _ doctype = null , ▁ reference _ name = null STRNEWLINE TABSYMBOL TABSYMBOL where STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL communication _ type ▁ = ▁ ' Communication ' STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL and ▁ reference _ doctype = % s STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL and ▁ reference _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE # ▁ make ▁ secondary ▁ references ▁ orphans ENDCOM frappe . db . sql ( """ update ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL set ▁ link _ doctype = null , ▁ link _ name = null STRNEWLINE TABSYMBOL TABSYMBOL where ▁ link _ doctype = % s ▁ and ▁ link _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE frappe . db . sql ( """ update ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL set ▁ timeline _ doctype = null , ▁ timeline _ name = null STRNEWLINE TABSYMBOL TABSYMBOL where ▁ timeline _ doctype = % s ▁ and ▁ timeline _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE DEDENT def insert_feed ( doc ) : NEW_LINE INDENT from frappe . utils import get_fullname NEW_LINE if frappe . flags . in_install or frappe . flags . in_import or getattr ( doc , " no _ feed _ on _ delete " , False ) : NEW_LINE INDENT return NEW_LINE DEDENT frappe . get_doc ( { " doctype " : " Communication " , " communication _ type " : " Comment " , " comment _ type " : " Deleted " , " reference _ doctype " : doc . doctype , " subject " : " { 0 } ▁ { 1 } " . format ( _ ( doc . doctype ) , doc . name ) , " full _ name " : get_fullname ( doc . owner ) } ) . insert ( ignore_permissions = True ) NEW_LINE DEDENT def delete_shared ( doc ) : NEW_LINE INDENT delete_doc ( " DocShare " , frappe . db . sql_list ( """ select ▁ name ▁ from ▁ ` tabDocShare ` STRNEWLINE TABSYMBOL TABSYMBOL where ▁ share _ doctype = % s ▁ and ▁ share _ name = % s """ , ( doc . doctype , doc . name ) ) , ignore_on_trash = True ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="mjtamlyn/django/tree/master/tests/mail/tests.py"> import asyncore NEW_LINE import base64 NEW_LINE import mimetypes NEW_LINE import os NEW_LINE import shutil NEW_LINE import smtpd NEW_LINE import socket NEW_LINE import sys NEW_LINE import tempfile NEW_LINE import threading NEW_LINE from email import message_from_binary_file , message_from_bytes NEW_LINE from email . header import Header NEW_LINE from email . mime . text import MIMEText NEW_LINE from email . utils import parseaddr NEW_LINE from io import StringIO NEW_LINE from smtplib import SMTP , SMTPAuthenticationError , SMTPException NEW_LINE from ssl import SSLError NEW_LINE from django . core import mail NEW_LINE from django . core . mail import ( EmailMessage , EmailMultiAlternatives , mail_admins , mail_managers , send_mail , send_mass_mail , ) NEW_LINE from django . core . mail . backends import console , dummy , filebased , locmem , smtp NEW_LINE from django . core . mail . message import BadHeaderError , sanitize_address NEW_LINE from django . test import SimpleTestCase , override_settings NEW_LINE from django . test . utils import requires_tz_support NEW_LINE from django . utils . encoding import force_bytes , force_text NEW_LINE from django . utils . translation import gettext_lazy NEW_LINE class HeadersCheckMixin : NEW_LINE INDENT def assertMessageHasHeaders ( self , message , headers ) : NEW_LINE INDENT """ STRNEWLINE ▁ Asserts ▁ that ▁ the ▁ ` message ` ▁ has ▁ all ▁ ` headers ` . STRNEWLINE STRNEWLINE ▁ message : ▁ can ▁ be ▁ an ▁ instance ▁ of ▁ an ▁ email . Message ▁ subclass ▁ or ▁ a ▁ string STRNEWLINE ▁ with ▁ the ▁ contents ▁ of ▁ an ▁ email ▁ message . STRNEWLINE ▁ headers : ▁ should ▁ be ▁ a ▁ set ▁ of ▁ ( header - name , ▁ header - value ) ▁ tuples . STRNEWLINE ▁ """ NEW_LINE if isinstance ( message , bytes ) : NEW_LINE INDENT message = message_from_bytes ( message ) NEW_LINE DEDENT msg_headers = set ( message . items ( ) ) NEW_LINE self . assertTrue ( headers . issubset ( msg_headers ) , msg = ' Message ▁ is ▁ missing ▁ ' ' the ▁ following ▁ headers : ▁ % s ' % ( headers - msg_headers ) , ) NEW_LINE DEDENT DEDENT class MailTests ( HeadersCheckMixin , SimpleTestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Non - backend ▁ specific ▁ tests . STRNEWLINE ▁ """ NEW_LINE def get_decoded_attachments ( self , django_message ) : NEW_LINE INDENT """ STRNEWLINE ▁ Encode ▁ the ▁ specified ▁ django . core . mail . message . EmailMessage , ▁ then ▁ decode STRNEWLINE ▁ it ▁ using ▁ Python ' s ▁ email . parser ▁ module ▁ and , ▁ for ▁ each ▁ attachment ▁ of ▁ the STRNEWLINE ▁ message , ▁ return ▁ a ▁ list ▁ of ▁ tuples ▁ with ▁ ( filename , ▁ content , ▁ mimetype ) . STRNEWLINE ▁ """ NEW_LINE msg_bytes = django_message . message ( ) . as_bytes ( ) NEW_LINE email_message = message_from_bytes ( msg_bytes ) NEW_LINE def iter_attachments ( ) : NEW_LINE INDENT for i in email_message . walk ( ) : NEW_LINE # ▁ Once ▁ support ▁ for ▁ Python < 3.5 ▁ has ▁ been ▁ dropped , ▁ we ▁ can ▁ use ENDCOM # ▁ i . get _ content _ disposition ( ) ▁ here ▁ instead . ENDCOM INDENT content_disposition = i . get ( ' content - disposition ' , ' ' ) . split ( ' ; ' ) [ 0 ] . lower ( ) NEW_LINE if content_disposition == ' attachment ' : NEW_LINE INDENT filename = i . get_filename ( ) NEW_LINE content = i . get_payload ( decode = True ) NEW_LINE mimetype = i . get_content_type ( ) NEW_LINE yield filename , content , mimetype NEW_LINE DEDENT DEDENT DEDENT return list ( iter_attachments ( ) ) NEW_LINE DEDENT def test_ascii ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' to @ example . com ' ) NEW_LINE DEDENT def test_multiple_recipients ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' to @ example . com , ▁ other @ example . com ' ) NEW_LINE DEDENT def test_recipients_with_empty_strings ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Empty ▁ strings ▁ in ▁ various ▁ recipient ▁ arguments ▁ are ▁ always ▁ stripped STRNEWLINE ▁ off ▁ the ▁ final ▁ recipient ▁ list . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' ' ] , cc = [ ' cc @ example . com ' , ' ' ] , bcc = [ ' ' , ' bcc @ example . com ' ] , reply_to = [ ' ' , None ] , ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' cc @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT def test_cc ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 7722 """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , cc = [ ' cc @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' cc @ example . com ' ] ) NEW_LINE # ▁ Test ▁ multiple ▁ CC ▁ with ▁ multiple ▁ To ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] , cc = [ ' cc @ example . com ' , ' cc . other @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' ] ) NEW_LINE # ▁ Testing ▁ with ▁ Bcc ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' , ' other @ example . com ' ] , cc = [ ' cc @ example . com ' , ' cc . other @ example . com ' ] , bcc = [ ' bcc @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT def test_reply_to ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' reply _ to @ example . com ' ] , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' reply _ to @ example . com ' ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' reply _ to1 @ example . com ' , ' reply _ to2 @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' reply _ to1 @ example . com , ▁ reply _ to2 @ example . com ' ) NEW_LINE DEDENT def test_recipients_as_tuple ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , ( ' to @ example . com ' , ' other @ example . com ' ) , cc = ( ' cc @ example . com ' , ' cc . other @ example . com ' ) , bcc = ( ' bcc @ example . com ' , ) ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Cc ' ] , ' cc @ example . com , ▁ cc . other @ example . com ' ) NEW_LINE self . assertEqual ( email . recipients ( ) , [ ' to @ example . com ' , ' other @ example . com ' , ' cc @ example . com ' , ' cc . other @ example . com ' , ' bcc @ example . com ' ] ) NEW_LINE DEDENT def test_recipients_as_string ( self ) : NEW_LINE INDENT with self . assertRaisesMessage ( TypeError , ' " to " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( to = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " cc " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( cc = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " bcc " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( bcc = ' foo @ example . com ' ) NEW_LINE DEDENT with self . assertRaisesMessage ( TypeError , ' " reply _ to " ▁ argument ▁ must ▁ be ▁ a ▁ list ▁ or ▁ tuple ' ) : NEW_LINE INDENT EmailMessage ( reply_to = ' reply _ to @ example . com ' ) NEW_LINE DEDENT DEDENT def test_header_injection ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject \n Injection ▁ Test ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT email . message ( ) NEW_LINE DEDENT email = EmailMessage ( gettext_lazy ( ' Subject \n Injection ▁ Test ' ) , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT email . message ( ) NEW_LINE DEDENT DEDENT def test_space_continuation ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ for ▁ space ▁ continuation ▁ character ▁ in ▁ long ▁ ( ASCII ) ▁ subject ▁ headers ▁ ( # 7747 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Long ▁ subject ▁ lines ▁ that ▁ get ▁ wrapped ▁ should ▁ contain ▁ a ▁ space ▁ ' ' continuation ▁ character ▁ to ▁ get ▁ expected ▁ behavior ▁ in ▁ Outlook ▁ and ▁ Thunderbird ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] . encode ( ) , b ' Long ▁ subject ▁ lines ▁ that ▁ get ▁ wrapped ▁ should ▁ contain ▁ a ▁ space ▁ continuation \n ' b ' ▁ character ▁ to ▁ get ▁ expected ▁ behavior ▁ in ▁ Outlook ▁ and ▁ Thunderbird ' ) NEW_LINE DEDENT def test_message_header_overrides ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Specifying ▁ dates ▁ or ▁ message - ids ▁ in ▁ the ▁ extra ▁ headers ▁ overrides ▁ the STRNEWLINE ▁ default ▁ values ▁ ( # 9233 ) STRNEWLINE ▁ """ NEW_LINE headers = { " date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE email = EmailMessage ( ' subject ' , ' content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , headers = headers ) NEW_LINE self . assertMessageHasHeaders ( email . message ( ) , { ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' MIME - Version ' , '1.0' ) , ( ' Message - ID ' , ' foo ' ) , ( ' Subject ' , ' subject ' ) , ( ' To ' , ' to @ example . com ' ) , ( ' date ' , ' Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000' ) , } ) NEW_LINE DEDENT def test_from_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ we ▁ can ▁ manually ▁ set ▁ the ▁ From ▁ header ▁ ( # 9214 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE DEDENT def test_to_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ we ▁ can ▁ manually ▁ set ▁ the ▁ To ▁ header ▁ ( # 17444 ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] , headers = { ' To ' : ' mailing - list @ example . com ' } ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' mailing - list @ example . com ' ) NEW_LINE self . assertEqual ( email . to , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE # ▁ If ▁ we ▁ don ' t ▁ set ▁ the ▁ To ▁ header ▁ manually , ▁ it ▁ should ▁ default ▁ to ▁ the ▁ ` to ` ▁ argument ▁ to ▁ the ▁ constructor ENDCOM email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' To ' ] , ' list - subscriber @ example . com , ▁ list - subscriber2 @ example . com ' ) NEW_LINE self . assertEqual ( email . to , [ ' list - subscriber @ example . com ' , ' list - subscriber2 @ example . com ' ] ) NEW_LINE DEDENT def test_reply_to_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Specifying ▁ ' Reply - To ' ▁ in ▁ headers ▁ should ▁ override ▁ reply _ to . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , reply_to = [ ' foo @ example . com ' ] , headers = { ' Reply - To ' : ' override @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Reply - To ' ] , ' override @ example . com ' ) NEW_LINE DEDENT def test_multiple_message_call ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 13259 ▁ - ▁ Make ▁ sure ▁ that ▁ headers ▁ are ▁ not ▁ changed ▁ when STRNEWLINE ▁ calling ▁ EmailMessage . message ( ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' From ' ] , ' from @ example . com ' ) NEW_LINE DEDENT def test_unicode_address_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 11144 ▁ - ▁ When ▁ a ▁ to / from / cc ▁ header ▁ contains ▁ unicode , STRNEWLINE ▁ make ▁ sure ▁ the ▁ email ▁ addresses ▁ are ▁ parsed ▁ correctly ▁ ( especially ▁ with STRNEWLINE ▁ regards ▁ to ▁ commas ) STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' " Firstname ▁ Sürname " ▁ < to @ example . com > ' , ' other @ example . com ' ] , ) NEW_LINE self . assertEqual ( email . message ( ) [ ' To ' ] , ' = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < to @ example . com > , ▁ other @ example . com ' ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' " Sürname , ▁ Firstname " ▁ < to @ example . com > ' , ' other @ example . com ' ] , ) NEW_LINE self . assertEqual ( email . message ( ) [ ' To ' ] , ' = ? utf - 8 ? q ? S = C3 = BCrname = 2C _ Firstname ? = ▁ < to @ example . com > , ▁ other @ example . com ' ) NEW_LINE DEDENT def test_unicode_headers ( self ) : NEW_LINE INDENT email = EmailMessage ( " Gżegżółka " , " Content " , " from @ example . com " , [ " to @ example . com " ] , headers = { " Sender " : ' " Firstname ▁ Sürname " ▁ < sender @ example . com > ' , " Comments " : ' My ▁ Sürname ▁ is ▁ non - ASCII ' } ) NEW_LINE message = email . message ( ) NEW_LINE self . assertEqual ( message [ ' Subject ' ] , ' = ? utf - 8 ? b ? R8W8ZWfFvMOzxYJrYQ = = ? = ' ) NEW_LINE self . assertEqual ( message [ ' Sender ' ] , ' = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < sender @ example . com > ' ) NEW_LINE self . assertEqual ( message [ ' Comments ' ] , ' = ? utf - 8 ? q ? My _ S = C3 = BCrname _ is _ non - ASCII ? = ' ) NEW_LINE DEDENT def test_safe_mime_multipart ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ headers ▁ can ▁ be ▁ set ▁ with ▁ a ▁ different ▁ encoding ▁ than ▁ utf - 8 ▁ in STRNEWLINE ▁ SafeMIMEMultipart ▁ as ▁ well STRNEWLINE ▁ """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE from_email , to = ' from @ example . com ' , ' " Sürname , ▁ Firstname " ▁ < to @ example . com > ' NEW_LINE text_content = ' This ▁ is ▁ an ▁ important ▁ message . ' NEW_LINE html_content = ' < p > This ▁ is ▁ an ▁ < strong > important < / strong > ▁ message . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( ' Message ▁ from ▁ Firstname ▁ Sürname ' , text_content , from_email , [ to ] , headers = headers ) NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE msg . encoding = ' iso - 8859-1' NEW_LINE self . assertEqual ( msg . message ( ) [ ' To ' ] , ' = ? iso - 8859-1 ? q ? S = FCrname = 2C _ Firstname ? = ▁ < to @ example . com > ' ) NEW_LINE self . assertEqual ( msg . message ( ) [ ' Subject ' ] , ' = ? iso - 8859-1 ? q ? Message _ from _ Firstname _ S = FCrname ? = ' ) NEW_LINE DEDENT def test_encoding ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ for ▁ # 12791 ▁ - ▁ Encode ▁ body ▁ correctly ▁ with ▁ other ▁ encodings STRNEWLINE ▁ than ▁ utf - 8 STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Firstname ▁ Sürname ▁ is ▁ a ▁ great ▁ guy . ' , ' from @ example . com ' , [ ' other @ example . com ' ] ) NEW_LINE email . encoding = ' iso - 8859-1' NEW_LINE message = email . message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' other @ example . com ' ) } ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Firstname ▁ S = FCrname ▁ is ▁ a ▁ great ▁ guy . ' ) NEW_LINE # ▁ Make ▁ sure ▁ MIME ▁ attachments ▁ also ▁ works ▁ correctly ▁ with ▁ other ▁ encodings ▁ than ▁ utf - 8 ENDCOM text_content = ' Firstname ▁ Sürname ▁ is ▁ a ▁ great ▁ guy . ' NEW_LINE html_content = ' < p > Firstname ▁ Sürname ▁ is ▁ a ▁ < strong > great < / strong > ▁ guy . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( ' Subject ' , text_content , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . encoding = ' iso - 8859-1' NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE payload0 = msg . message ( ) . get_payload ( 0 ) NEW_LINE self . assertMessageHasHeaders ( payload0 , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) } ) NEW_LINE self . assertTrue ( payload0 . as_bytes ( ) . endswith ( b ' \n \n Firstname ▁ S = FCrname ▁ is ▁ a ▁ great ▁ guy . ' ) ) NEW_LINE payload1 = msg . message ( ) . get_payload ( 1 ) NEW_LINE self . assertMessageHasHeaders ( payload1 , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / html ; ▁ charset = " iso - 8859-1 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) } ) NEW_LINE self . assertTrue ( payload1 . as_bytes ( ) . endswith ( b ' \n \n < p > Firstname ▁ S = FCrname ▁ is ▁ a ▁ < strong > great < / strong > ▁ guy . < / p > ' ) ) NEW_LINE DEDENT def test_attachments ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 9367 """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE subject , from_email , to = ' hello ' , ' from @ example . com ' , ' to @ example . com ' NEW_LINE text_content = ' This ▁ is ▁ an ▁ important ▁ message . ' NEW_LINE html_content = ' < p > This ▁ is ▁ an ▁ < strong > important < / strong > ▁ message . < / p > ' NEW_LINE msg = EmailMultiAlternatives ( subject , text_content , from_email , [ to ] , headers = headers ) NEW_LINE msg . attach_alternative ( html_content , " text / html " ) NEW_LINE msg . attach ( " an ▁ attachment . pdf " , b " % PDF - 1.4 . % . . . " , mimetype = " application / pdf " ) NEW_LINE msg_bytes = msg . message ( ) . as_bytes ( ) NEW_LINE message = message_from_bytes ( msg_bytes ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( message . get_content_type ( ) , ' multipart / mixed ' ) NEW_LINE self . assertEqual ( message . get_default_type ( ) , ' text / plain ' ) NEW_LINE payload = message . get_payload ( ) NEW_LINE self . assertEqual ( payload [ 0 ] . get_content_type ( ) , ' multipart / alternative ' ) NEW_LINE self . assertEqual ( payload [ 1 ] . get_content_type ( ) , ' application / pdf ' ) NEW_LINE DEDENT def test_non_ascii_attachment_filename ( self ) : NEW_LINE INDENT """ Regression ▁ test ▁ for ▁ # 14964 """ NEW_LINE headers = { " Date " : " Fri , ▁ 09 ▁ Nov ▁ 2001 ▁ 01:08:47 ▁ - 0000" , " Message - ID " : " foo " } NEW_LINE subject , from_email , to = ' hello ' , ' from @ example . com ' , ' to @ example . com ' NEW_LINE content = ' This ▁ is ▁ the ▁ message . ' NEW_LINE msg = EmailMessage ( subject , content , from_email , [ to ] , headers = headers ) NEW_LINE # ▁ Unicode ▁ in ▁ file ▁ name ENDCOM msg . attach ( " une ▁ pièce ▁ jointe . pdf " , b " % PDF - 1.4 . % . . . " , mimetype = " application / pdf " ) NEW_LINE msg_bytes = msg . message ( ) . as_bytes ( ) NEW_LINE message = message_from_bytes ( msg_bytes ) NEW_LINE payload = message . get_payload ( ) NEW_LINE self . assertEqual ( payload [ 1 ] . get_filename ( ) , ' une ▁ pièce ▁ jointe . pdf ' ) NEW_LINE DEDENT def test_attach_file ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ attaching ▁ a ▁ file ▁ against ▁ different ▁ mimetypes ▁ and ▁ make ▁ sure ▁ that STRNEWLINE ▁ a ▁ file ▁ will ▁ be ▁ attached ▁ and ▁ sent ▁ properly ▁ even ▁ if ▁ an ▁ invalid ▁ mimetype STRNEWLINE ▁ is ▁ specified . STRNEWLINE ▁ """ NEW_LINE files = ( # ▁ filename , ▁ actual ▁ mimetype ENDCOM ( ' file . txt ' , ' text / plain ' ) , ( ' file . png ' , ' image / png ' ) , ( ' file _ txt ' , None ) , ( ' file _ png ' , None ) , ( ' file _ txt . png ' , ' image / png ' ) , ( ' file _ png . txt ' , ' text / plain ' ) , ( ' file . eml ' , ' message / rfc822' ) , ) NEW_LINE test_mimetypes = [ ' text / plain ' , ' image / png ' , None ] NEW_LINE for basename , real_mimetype in files : NEW_LINE INDENT for mimetype in test_mimetypes : NEW_LINE INDENT email = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertEqual ( mimetypes . guess_type ( basename ) [ 0 ] , real_mimetype ) NEW_LINE self . assertEqual ( email . attachments , [ ] ) NEW_LINE file_path = os . path . join ( os . path . dirname ( __file__ ) , ' attachments ' , basename ) NEW_LINE email . attach_file ( file_path , mimetype = mimetype ) NEW_LINE self . assertEqual ( len ( email . attachments ) , 1 ) NEW_LINE self . assertIn ( basename , email . attachments [ 0 ] ) NEW_LINE msgs_sent_num = email . send ( ) NEW_LINE self . assertEqual ( msgs_sent_num , 1 ) NEW_LINE DEDENT DEDENT DEDENT def test_attach_text_as_bytes ( self ) : NEW_LINE INDENT msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' file ▁ content ' ) NEW_LINE sent_num = msg . send ( ) NEW_LINE self . assertEqual ( sent_num , 1 ) NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE self . assertEqual ( content , b ' file ▁ content ' ) NEW_LINE self . assertEqual ( mimetype , ' text / plain ' ) NEW_LINE DEDENT def test_attach_utf8_text_as_bytes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Non - ASCII ▁ characters ▁ encoded ▁ as ▁ valid ▁ UTF - 8 ▁ are ▁ correctly ▁ transported STRNEWLINE ▁ and ▁ decoded . STRNEWLINE ▁ """ NEW_LINE msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' \xc3\xa4' ) # ▁ UTF - 8 ▁ encoded ▁ a ▁ umlaut . ENDCOM NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE self . assertEqual ( content , b ' \xc3\xa4' ) NEW_LINE self . assertEqual ( mimetype , ' text / plain ' ) NEW_LINE DEDENT def test_attach_non_utf8_text_as_bytes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Binary ▁ data ▁ that ▁ can ' t ▁ be ▁ decoded ▁ as ▁ UTF - 8 ▁ overrides ▁ the ▁ MIME ▁ type STRNEWLINE ▁ instead ▁ of ▁ decoding ▁ the ▁ data . STRNEWLINE ▁ """ NEW_LINE msg = EmailMessage ( ' subject ' , ' body ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE msg . attach ( ' file . txt ' , b ' \xff ' ) # ▁ Invalid ▁ UTF - 8 . ENDCOM NEW_LINE filename , content , mimetype = self . get_decoded_attachments ( msg ) [ 0 ] NEW_LINE self . assertEqual ( filename , ' file . txt ' ) NEW_LINE # ▁ Content ▁ should ▁ be ▁ passed ▁ through ▁ unmodified . ENDCOM self . assertEqual ( content , b ' \xff ' ) NEW_LINE self . assertEqual ( mimetype , ' application / octet - stream ' ) NEW_LINE DEDENT def test_dummy_backend ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ dummy ▁ backends ▁ returns ▁ correct ▁ number ▁ of ▁ sent ▁ messages STRNEWLINE ▁ """ NEW_LINE connection = dummy . EmailBackend ( ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertEqual ( connection . send_messages ( [ email , email , email ] ) , 3 ) NEW_LINE DEDENT def test_arbitrary_keyword ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ get _ connection ( ) ▁ accepts ▁ arbitrary ▁ keyword ▁ that ▁ might ▁ be STRNEWLINE ▁ used ▁ with ▁ custom ▁ backends . STRNEWLINE ▁ """ NEW_LINE c = mail . get_connection ( fail_silently = True , foo = ' bar ' ) NEW_LINE self . assertTrue ( c . fail_silently ) NEW_LINE DEDENT def test_custom_backend ( self ) : NEW_LINE INDENT """ Test ▁ custom ▁ backend ▁ defined ▁ in ▁ this ▁ suite . """ NEW_LINE conn = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE self . assertTrue ( hasattr ( conn , ' test _ outbox ' ) ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE conn . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( len ( conn . test_outbox ) , 1 ) NEW_LINE DEDENT def test_backend_arg ( self ) : NEW_LINE INDENT """ Test ▁ backend ▁ argument ▁ of ▁ mail . get _ connection ( ) """ NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . smtp . EmailBackend ' ) , smtp . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . locmem . EmailBackend ' ) , locmem . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . dummy . EmailBackend ' ) , dummy . EmailBackend ) NEW_LINE self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . console . EmailBackend ' ) , console . EmailBackend ) NEW_LINE with tempfile . TemporaryDirectory ( ) as tmp_dir : NEW_LINE INDENT self . assertIsInstance ( mail . get_connection ( ' django . core . mail . backends . filebased . EmailBackend ' , file_path = tmp_dir ) , filebased . EmailBackend ) NEW_LINE DEDENT self . assertIsInstance ( mail . get_connection ( ) , locmem . EmailBackend ) NEW_LINE DEDENT @ override_settings ( EMAIL_BACKEND = ' django . core . mail . backends . locmem . EmailBackend ' , ADMINS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] , MANAGERS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] ) NEW_LINE def test_connection_arg ( self ) : NEW_LINE INDENT """ Test ▁ connection ▁ argument ▁ to ▁ send _ mail ( ) , ▁ et . ▁ al . """ NEW_LINE mail . outbox = [ ] NEW_LINE # ▁ Send ▁ using ▁ non - default ▁ connection ENDCOM connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' Subject ' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE send_mass_mail ( [ ( ' Subject1' , ' Content1' , ' from1 @ example . com ' , [ ' to1 @ example . com ' ] ) , ( ' Subject2' , ' Content2' , ' from2 @ example . com ' , [ ' to2 @ example . com ' ] ) , ] , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 2 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' Subject1' ) NEW_LINE self . assertEqual ( connection . test_outbox [ 1 ] . subject , ' Subject2' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE mail_admins ( ' Admin ▁ message ' , ' Content ' , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' [ Django ] ▁ Admin ▁ message ' ) NEW_LINE connection = mail . get_connection ( ' mail . custombackend . EmailBackend ' ) NEW_LINE mail_managers ( ' Manager ▁ message ' , ' Content ' , connection = connection ) NEW_LINE self . assertEqual ( mail . outbox , [ ] ) NEW_LINE self . assertEqual ( len ( connection . test_outbox ) , 1 ) NEW_LINE self . assertEqual ( connection . test_outbox [ 0 ] . subject , ' [ Django ] ▁ Manager ▁ message ' ) NEW_LINE DEDENT def test_dont_mangle_from_in_body ( self ) : NEW_LINE # ▁ Regression ▁ for ▁ # 13433 ▁ - ▁ Make ▁ sure ▁ that ▁ EmailMessage ▁ doesn ' t ▁ mangle ENDCOM # ▁ ' From ▁ ' ▁ in ▁ message ▁ body . ENDCOM INDENT email = EmailMessage ( ' Subject ' , ' From ▁ the ▁ future ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertNotIn ( b ' > From ▁ the ▁ future ' , email . message ( ) . as_bytes ( ) ) NEW_LINE DEDENT def test_dont_base64_encode ( self ) : NEW_LINE # ▁ Ticket ▁ # 3472 ENDCOM # ▁ Shouldn ' t ▁ use ▁ Base64 ▁ encoding ▁ at ▁ all ENDCOM INDENT msg = EmailMessage ( ' Subject ' , ' UTF - 8 ▁ encoded ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 7bit ' , msg . message ( ) . as_bytes ( ) ) NEW_LINE # ▁ Ticket ▁ # 11212 ENDCOM # ▁ Shouldn ' t ▁ use ▁ quoted ▁ printable , ▁ should ▁ detect ▁ it ▁ can ▁ represent ▁ content ▁ with ▁ 7 ▁ bit ▁ data ENDCOM msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ only ▁ ASCII ▁ characters . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 7bit ' , s ) NEW_LINE # ▁ Shouldn ' t ▁ use ▁ quoted ▁ printable , ▁ should ▁ detect ▁ it ▁ can ▁ represent ▁ content ▁ with ▁ 8 ▁ bit ▁ data ENDCOM msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ latin ▁ characters : ▁ àáä . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE s = msg . message ( ) . as_string ( ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE msg = EmailMessage ( ' Subject ' , ' Body ▁ with ▁ non ▁ latin ▁ characters : ▁ А ▁ Б ▁ В ▁ Г ▁ Д ▁ Е ▁ Ж ▁ Ѕ ▁ З ▁ И ▁ І ▁ К ▁ Л ▁ М ▁ Н ▁ О ▁ П . ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE s = msg . message ( ) . as_bytes ( ) NEW_LINE self . assertIn ( b ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE s = msg . message ( ) . as_string ( ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ 8bit ' , s ) NEW_LINE DEDENT def test_dont_base64_encode_message_rfc822 ( self ) : NEW_LINE # ▁ Ticket ▁ # 18967 ENDCOM # ▁ Shouldn ' t ▁ use ▁ base64 ▁ encoding ▁ for ▁ a ▁ child ▁ EmailMessage ▁ attachment . ENDCOM # ▁ Create ▁ a ▁ child ▁ message ▁ first ENDCOM INDENT child_msg = EmailMessage ( ' Child ▁ Subject ' , ' Some ▁ body ▁ of ▁ child ▁ message ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE child_s = child_msg . message ( ) . as_string ( ) NEW_LINE # ▁ Now ▁ create ▁ a ▁ parent ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE # ▁ Attach ▁ to ▁ parent ▁ as ▁ a ▁ string ENDCOM parent_msg . attach ( content = child_s , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE # ▁ Feature ▁ test : ▁ try ▁ attaching ▁ email . Message ▁ object ▁ directly ▁ to ▁ the ▁ mail . ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE parent_msg . attach ( content = child_msg . message ( ) , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE # ▁ Feature ▁ test : ▁ try ▁ attaching ▁ Django ' s ▁ EmailMessage ▁ object ▁ directly ▁ to ▁ the ▁ mail . ENDCOM parent_msg = EmailMessage ( ' Parent ▁ Subject ' , ' Some ▁ parent ▁ body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE parent_msg . attach ( content = child_msg , mimetype = ' message / rfc822' ) NEW_LINE parent_s = parent_msg . message ( ) . as_string ( ) NEW_LINE # ▁ The ▁ child ▁ message ▁ header ▁ is ▁ not ▁ base64 ▁ encoded ENDCOM self . assertIn ( ' Child ▁ Subject ' , parent_s ) NEW_LINE DEDENT def test_sanitize_address ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ addresses ▁ are ▁ properly ▁ sanitized . STRNEWLINE ▁ """ NEW_LINE # ▁ Simple ▁ ASCII ▁ address ▁ - ▁ string ▁ form ENDCOM self . assertEqual ( sanitize_address ( ' to @ example . com ' , ' ascii ' ) , ' to @ example . com ' ) NEW_LINE self . assertEqual ( sanitize_address ( ' to @ example . com ' , ' utf - 8' ) , ' to @ example . com ' ) NEW_LINE # ▁ Simple ▁ ASCII ▁ address ▁ - ▁ tuple ▁ form ENDCOM self . assertEqual ( sanitize_address ( ( ' A ▁ name ' , ' to @ example . com ' ) , ' ascii ' ) , ' A ▁ name ▁ < to @ example . com > ' ) NEW_LINE self . assertEqual ( sanitize_address ( ( ' A ▁ name ' , ' to @ example . com ' ) , ' utf - 8' ) , ' = ? utf - 8 ? q ? A _ name ? = ▁ < to @ example . com > ' ) NEW_LINE # ▁ Unicode ▁ characters ▁ are ▁ are ▁ supported ▁ in ▁ RFC - 6532 . ENDCOM self . assertEqual ( sanitize_address ( ' tó @ example . com ' , ' utf - 8' ) , ' = ? utf - 8 ? b ? dMOz ? = @ example . com ' ) NEW_LINE self . assertEqual ( sanitize_address ( ( ' Tó ▁ Example ' , ' tó @ example . com ' ) , ' utf - 8' ) , ' = ? utf - 8 ? q ? T = C3 = B3 _ Example ? = ▁ < = ? utf - 8 ? b ? dMOz ? = @ example . com > ' ) NEW_LINE DEDENT DEDENT @ requires_tz_support NEW_LINE class MailTimeZoneTests ( SimpleTestCase ) : NEW_LINE INDENT @ override_settings ( EMAIL_USE_LOCALTIME = False , USE_TZ = True , TIME_ZONE = ' Africa / Algiers ' ) NEW_LINE def test_date_header_utc ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ EMAIL _ USE _ LOCALTIME = False ▁ creates ▁ a ▁ datetime ▁ in ▁ UTC . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertTrue ( email . message ( ) [ ' Date ' ] . endswith ( ' - 0000' ) ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_LOCALTIME = True , USE_TZ = True , TIME_ZONE = ' Africa / Algiers ' ) NEW_LINE def test_date_header_localtime ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ EMAIL _ USE _ LOCALTIME = True ▁ creates ▁ a ▁ datetime ▁ in ▁ the ▁ local ▁ time ▁ zone . STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Body ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertTrue ( email . message ( ) [ ' Date ' ] . endswith ( ' + 0100' ) ) # ▁ Africa / Algiers ▁ is ▁ UTC + 1 ENDCOM NEW_LINE DEDENT DEDENT class PythonGlobalState ( SimpleTestCase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Tests ▁ for ▁ # 12422 ▁ - - ▁ Django ▁ smarts ▁ ( # 2472 / # 11212 ) ▁ with ▁ charset ▁ of ▁ utf - 8 ▁ text STRNEWLINE ▁ parts ▁ shouldn ' t ▁ pollute ▁ global ▁ email ▁ Python ▁ package ▁ charset ▁ registry ▁ when STRNEWLINE ▁ django . mail . message ▁ is ▁ imported . STRNEWLINE ▁ """ NEW_LINE def test_utf8 ( self ) : NEW_LINE INDENT txt = MIMEText ( ' UTF - 8 ▁ encoded ▁ body ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT def test_7bit ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ only ▁ ASCII ▁ characters . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT def test_8bit_latin ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ latin ▁ characters : ▁ àáä . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT def test_8bit_non_latin ( self ) : NEW_LINE INDENT txt = MIMEText ( ' Body ▁ with ▁ non ▁ latin ▁ characters : ▁ А ▁ Б ▁ В ▁ Г ▁ Д ▁ Е ▁ Ж ▁ Ѕ ▁ З ▁ И ▁ І ▁ К ▁ Л ▁ М ▁ Н ▁ О ▁ П . ' , ' plain ' , ' utf - 8' ) NEW_LINE self . assertIn ( ' Content - Transfer - Encoding : ▁ base64' , txt . as_string ( ) ) NEW_LINE DEDENT DEDENT class BaseEmailBackendTests ( HeadersCheckMixin ) : NEW_LINE INDENT email_backend = None NEW_LINE def setUp ( self ) : NEW_LINE INDENT self . settings_override = override_settings ( EMAIL_BACKEND = self . email_backend ) NEW_LINE self . settings_override . enable ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT self . settings_override . disable ( ) NEW_LINE DEDENT def assertStartsWith ( self , first , second ) : NEW_LINE INDENT if not first . startswith ( second ) : NEW_LINE INDENT self . longMessage = True NEW_LINE self . assertEqual ( first [ : len ( second ) ] , second , " First ▁ string ▁ doesn ' t ▁ start ▁ with ▁ the ▁ second . " ) NEW_LINE DEDENT DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT raise NotImplementedError ( ' subclasses ▁ of ▁ BaseEmailBackendTests ▁ must ▁ provide ▁ a ▁ get _ mailbox _ content ( ) ▁ method ' ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT raise NotImplementedError ( ' subclasses ▁ of ▁ BaseEmailBackendTests ▁ may ▁ require ▁ a ▁ flush _ mailbox ( ) ▁ method ' ) NEW_LINE DEDENT def get_the_message ( self ) : NEW_LINE INDENT mailbox = self . get_mailbox_content ( ) NEW_LINE self . assertEqual ( len ( mailbox ) , 1 , " Expected ▁ exactly ▁ one ▁ message , ▁ got ▁ % d . \n % r " % ( len ( mailbox ) , [ m . as_string ( ) for m in mailbox ] ) ) NEW_LINE return mailbox [ 0 ] NEW_LINE DEDENT def test_send ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE num_sent = mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( num_sent , 1 ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , " Subject " ) NEW_LINE self . assertEqual ( message . get_payload ( ) , " Content " ) NEW_LINE self . assertEqual ( message [ " from " ] , " from @ example . com " ) NEW_LINE self . assertEqual ( message . get_all ( " to " ) , [ " to @ example . com " ] ) NEW_LINE DEDENT def test_send_unicode ( self ) : NEW_LINE INDENT email = EmailMessage ( ' Chère ▁ maman ' , ' Je ▁ t\ ' aime ▁ très ▁ fort ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE num_sent = mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( num_sent , 1 ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , ' = ? utf - 8 ? q ? Ch = C3 = A8re _ maman ? = ' ) NEW_LINE self . assertEqual ( force_text ( message . get_payload ( decode = True ) ) , ' Je ▁ t\ ' aime ▁ très ▁ fort ' ) NEW_LINE DEDENT def test_send_long_lines ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ line ▁ length ▁ is ▁ limited ▁ to ▁ 998 ▁ chars ▁ by ▁ the ▁ RFC : STRNEWLINE ▁ https : / / tools . ietf . org / html / rfc5322 # section - 2.1.1 STRNEWLINE ▁ Message ▁ body ▁ containing ▁ longer ▁ lines ▁ are ▁ converted ▁ to ▁ Quoted - Printable STRNEWLINE ▁ to ▁ avoid ▁ having ▁ to ▁ insert ▁ newlines , ▁ which ▁ could ▁ be ▁ hairy ▁ to ▁ do ▁ properly . STRNEWLINE ▁ """ NEW_LINE # ▁ Unencoded ▁ body ▁ length ▁ is ▁ < ▁ 998 ▁ ( 840 ) ▁ but ▁ > ▁ 998 ▁ when ▁ utf - 8 ▁ encoded . ENDCOM email = EmailMessage ( ' Subject ' , ' В ▁ южных ▁ морях ▁ ' * 60 , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE email . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , ' quoted - printable ' ) , } ) NEW_LINE DEDENT def test_send_many ( self ) : NEW_LINE INDENT email1 = EmailMessage ( ' Subject ' , ' Content1' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE email2 = EmailMessage ( ' Subject ' , ' Content2' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE # ▁ send _ messages ( ) ▁ may ▁ take ▁ a ▁ list ▁ or ▁ a ▁ generator . ENDCOM emails_lists = ( [ email1 , email2 ] , ( email for email in [ email1 , email2 ] ) ) NEW_LINE for emails_list in emails_lists : NEW_LINE INDENT num_sent = mail . get_connection ( ) . send_messages ( emails_list ) NEW_LINE self . assertEqual ( num_sent , 2 ) NEW_LINE messages = self . get_mailbox_content ( ) NEW_LINE self . assertEqual ( len ( messages ) , 2 ) NEW_LINE self . assertEqual ( messages [ 0 ] . get_payload ( ) , ' Content1' ) NEW_LINE self . assertEqual ( messages [ 1 ] . get_payload ( ) , ' Content2' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE DEDENT DEDENT def test_send_verbose_name ( self ) : NEW_LINE INDENT email = EmailMessage ( " Subject " , " Content " , ' " Firstname ▁ Sürname " ▁ < from @ example . com > ' , [ " to @ example . com " ] ) NEW_LINE email . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message [ " subject " ] , " Subject " ) NEW_LINE self . assertEqual ( message . get_payload ( ) , " Content " ) NEW_LINE self . assertEqual ( message [ " from " ] , " = ? utf - 8 ? q ? Firstname _ S = C3 = BCrname ? = ▁ < from @ example . com > " ) NEW_LINE DEDENT def test_plaintext_send_mail ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ send _ mail ▁ without ▁ the ▁ html _ message STRNEWLINE ▁ regression ▁ test ▁ for ▁ adding ▁ html _ message ▁ parameter ▁ to ▁ send _ mail ( ) STRNEWLINE ▁ """ NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' sender @ example . com ' , [ ' nobody @ example . com ' ] ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertFalse ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( message . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_content_type ( ) , ' text / plain ' ) NEW_LINE DEDENT def test_html_send_mail ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ send _ mail """ NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' sender @ example . com ' , [ ' nobody @ example . com ' ] , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT @ override_settings ( MANAGERS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] ) NEW_LINE def test_html_mail_managers ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ mail _ managers """ NEW_LINE mail_managers ( ' Subject ' , ' Content ' , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT @ override_settings ( ADMINS = [ ( ' nobody ' , ' nobody @ example . com ' ) ] ) NEW_LINE def test_html_mail_admins ( self ) : NEW_LINE INDENT """ Test ▁ html _ message ▁ argument ▁ to ▁ mail _ admins ▁ """ NEW_LINE mail_admins ( ' Subject ' , ' Content ' , html_message = ' HTML ▁ Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . assertEqual ( message . get_all ( ' to ' ) , [ ' nobody @ example . com ' ] ) NEW_LINE self . assertTrue ( message . is_multipart ( ) ) NEW_LINE self . assertEqual ( len ( message . get_payload ( ) ) , 2 ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_payload ( ) , ' Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 0 ) . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_payload ( ) , ' HTML ▁ Content ' ) NEW_LINE self . assertEqual ( message . get_payload ( 1 ) . get_content_type ( ) , ' text / html ' ) NEW_LINE DEDENT @ override_settings ( ADMINS = [ ( ' nobody ' , ' nobody + admin @ example . com ' ) ] , MANAGERS = [ ( ' nobody ' , ' nobody + manager @ example . com ' ) ] ) NEW_LINE def test_manager_and_admin_mail_prefix ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ String ▁ prefix ▁ + ▁ lazy ▁ translated ▁ subject ▁ = ▁ bad ▁ output STRNEWLINE ▁ Regression ▁ for ▁ # 13494 STRNEWLINE ▁ """ NEW_LINE mail_managers ( gettext_lazy ( ' Subject ' ) , ' Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE mail_admins ( gettext_lazy ( ' Subject ' ) , ' Content ' ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' [ Django ] ▁ Subject ' ) NEW_LINE DEDENT @ override_settings ( ADMINS = [ ] , MANAGERS = [ ] ) NEW_LINE def test_empty_admins ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ mail _ admins / mail _ managers ▁ doesn ' t ▁ connect ▁ to ▁ the ▁ mail ▁ server STRNEWLINE ▁ if ▁ there ▁ are ▁ no ▁ recipients ▁ ( # 9383 ) STRNEWLINE ▁ """ NEW_LINE mail_admins ( ' hi ' , ' there ' ) NEW_LINE self . assertEqual ( self . get_mailbox_content ( ) , [ ] ) NEW_LINE mail_managers ( ' hi ' , ' there ' ) NEW_LINE self . assertEqual ( self . get_mailbox_content ( ) , [ ] ) NEW_LINE DEDENT def test_message_cc_header ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 7722 STRNEWLINE ▁ """ NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , cc = [ ' cc @ example . com ' ] ) NEW_LINE mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' to @ example . com ' ) , ( ' Cc ' , ' cc @ example . com ' ) } ) NEW_LINE self . assertIn ( ' \n Date : ▁ ' , message . as_string ( ) ) NEW_LINE DEDENT def test_idn_send ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 14301 STRNEWLINE ▁ """ NEW_LINE self . assertTrue ( send_mail ( ' Subject ' , ' Content ' , ' from @ öäü . com ' , [ ' to @ öäü . com ' ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ xn - -4ca9at . com ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE m = EmailMessage ( ' Subject ' , ' Content ' , ' from @ öäü . com ' , [ ' to @ öäü . com ' ] , cc = [ ' cc @ öäü . com ' ] ) NEW_LINE m . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ xn - -4ca9at . com ' ) NEW_LINE self . assertEqual ( message . get ( ' cc ' ) , ' cc @ xn - -4ca9at . com ' ) NEW_LINE DEDENT def test_recipient_without_domain ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Regression ▁ test ▁ for ▁ # 15042 STRNEWLINE ▁ """ NEW_LINE self . assertTrue ( send_mail ( " Subject " , " Content " , " tester " , [ " django " ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , " tester " ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , " django " ) NEW_LINE DEDENT def test_lazy_addresses ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Email ▁ sending ▁ should ▁ support ▁ lazy ▁ email ▁ addresses ▁ ( # 24416 ) . STRNEWLINE ▁ """ NEW_LINE _ = gettext_lazy NEW_LINE self . assertTrue ( send_mail ( ' Subject ' , ' Content ' , _ ( ' tester ' ) , [ _ ( ' django ' ) ] ) ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' tester ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' django ' ) NEW_LINE self . flush_mailbox ( ) NEW_LINE m = EmailMessage ( ' Subject ' , ' Content ' , _ ( ' tester ' ) , [ _ ( ' to1' ) , _ ( ' to2' ) ] , cc = [ _ ( ' cc1' ) , _ ( ' cc2' ) ] , bcc = [ _ ( ' bcc ' ) ] , reply_to = [ _ ( ' reply ' ) ] , ) NEW_LINE self . assertEqual ( m . recipients ( ) , [ ' to1' , ' to2' , ' cc1' , ' cc2' , ' bcc ' ] ) NEW_LINE m . send ( ) NEW_LINE message = self . get_the_message ( ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' tester ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to1 , ▁ to2' ) NEW_LINE self . assertEqual ( message . get ( ' cc ' ) , ' cc1 , ▁ cc2' ) NEW_LINE self . assertEqual ( message . get ( ' Reply - To ' ) , ' reply ' ) NEW_LINE DEDENT def test_close_connection ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Connection ▁ can ▁ be ▁ closed ▁ ( even ▁ when ▁ not ▁ explicitly ▁ opened ) STRNEWLINE ▁ """ NEW_LINE conn = mail . get_connection ( username = ' ' , password = ' ' ) NEW_LINE conn . close ( ) NEW_LINE DEDENT def test_use_as_contextmanager ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ connection ▁ can ▁ be ▁ used ▁ as ▁ a ▁ contextmanager . STRNEWLINE ▁ """ NEW_LINE opened = [ False ] NEW_LINE closed = [ False ] NEW_LINE conn = mail . get_connection ( username = ' ' , password = ' ' ) NEW_LINE def open ( ) : NEW_LINE INDENT opened [ 0 ] = True NEW_LINE DEDENT conn . open = open NEW_LINE def close ( ) : NEW_LINE INDENT closed [ 0 ] = True NEW_LINE DEDENT conn . close = close NEW_LINE with conn as same_conn : NEW_LINE INDENT self . assertTrue ( opened [ 0 ] ) NEW_LINE self . assertIs ( same_conn , conn ) NEW_LINE self . assertFalse ( closed [ 0 ] ) NEW_LINE DEDENT self . assertTrue ( closed [ 0 ] ) NEW_LINE DEDENT DEDENT class LocmemBackendTests ( BaseEmailBackendTests , SimpleTestCase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . locmem . EmailBackend ' NEW_LINE def get_mailbox_content ( self ) : NEW_LINE INDENT return [ m . message ( ) for m in mail . outbox ] NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT mail . outbox = [ ] NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT super ( ) . tearDown ( ) NEW_LINE mail . outbox = [ ] NEW_LINE DEDENT def test_locmem_shared_messages ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Make ▁ sure ▁ that ▁ the ▁ locmen ▁ backend ▁ populates ▁ the ▁ outbox . STRNEWLINE ▁ """ NEW_LINE connection = locmem . EmailBackend ( ) NEW_LINE connection2 = locmem . EmailBackend ( ) NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE connection . send_messages ( [ email ] ) NEW_LINE connection2 . send_messages ( [ email ] ) NEW_LINE self . assertEqual ( len ( mail . outbox ) , 2 ) NEW_LINE DEDENT def test_validate_multiline_headers ( self ) : NEW_LINE # ▁ Ticket ▁ # 18861 ▁ - ▁ Validate ▁ emails ▁ when ▁ using ▁ the ▁ locmem ▁ backend ENDCOM INDENT with self . assertRaises ( BadHeaderError ) : NEW_LINE INDENT send_mail ( ' Subject \n Multiline ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE DEDENT DEDENT DEDENT class FileBackendTests ( BaseEmailBackendTests , SimpleTestCase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . filebased . EmailBackend ' NEW_LINE def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . tmp_dir = tempfile . mkdtemp ( ) NEW_LINE self . addCleanup ( shutil . rmtree , self . tmp_dir ) NEW_LINE self . _settings_override = override_settings ( EMAIL_FILE_PATH = self . tmp_dir ) NEW_LINE self . _settings_override . enable ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT self . _settings_override . disable ( ) NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT for filename in os . listdir ( self . tmp_dir ) : NEW_LINE INDENT os . unlink ( os . path . join ( self . tmp_dir , filename ) ) NEW_LINE DEDENT DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT messages = [ ] NEW_LINE for filename in os . listdir ( self . tmp_dir ) : NEW_LINE INDENT with open ( os . path . join ( self . tmp_dir , filename ) , ' rb ' ) as fp : NEW_LINE INDENT session = fp . read ( ) . split ( force_bytes ( ' \n ' + ( ' - ' * 79 ) + ' \n ' , encoding = ' ascii ' ) ) NEW_LINE DEDENT messages . extend ( message_from_bytes ( m ) for m in session if m ) NEW_LINE DEDENT return messages NEW_LINE DEDENT def test_file_sessions ( self ) : NEW_LINE INDENT """ Make ▁ sure ▁ opening ▁ a ▁ connection ▁ creates ▁ a ▁ new ▁ file """ NEW_LINE msg = EmailMessage ( ' Subject ' , ' Content ' , ' bounce @ example . com ' , [ ' to @ example . com ' ] , headers = { ' From ' : ' from @ example . com ' } , ) NEW_LINE connection = mail . get_connection ( ) NEW_LINE connection . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 1 ) NEW_LINE with open ( os . path . join ( self . tmp_dir , os . listdir ( self . tmp_dir ) [ 0 ] ) , ' rb ' ) as fp : NEW_LINE INDENT message = message_from_binary_file ( fp ) NEW_LINE DEDENT self . assertEqual ( message . get_content_type ( ) , ' text / plain ' ) NEW_LINE self . assertEqual ( message . get ( ' subject ' ) , ' Subject ' ) NEW_LINE self . assertEqual ( message . get ( ' from ' ) , ' from @ example . com ' ) NEW_LINE self . assertEqual ( message . get ( ' to ' ) , ' to @ example . com ' ) NEW_LINE connection2 = mail . get_connection ( ) NEW_LINE connection2 . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 2 ) NEW_LINE connection . send_messages ( [ msg ] ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 2 ) NEW_LINE msg . connection = mail . get_connection ( ) NEW_LINE self . assertTrue ( connection . open ( ) ) NEW_LINE msg . send ( ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 3 ) NEW_LINE msg . send ( ) NEW_LINE self . assertEqual ( len ( os . listdir ( self . tmp_dir ) ) , 3 ) NEW_LINE connection . close ( ) NEW_LINE DEDENT DEDENT class ConsoleBackendTests ( BaseEmailBackendTests , SimpleTestCase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . console . EmailBackend ' NEW_LINE def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . __stdout = sys . stdout NEW_LINE self . stream = sys . stdout = StringIO ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT del self . stream NEW_LINE sys . stdout = self . __stdout NEW_LINE del self . __stdout NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT self . stream = sys . stdout = StringIO ( ) NEW_LINE DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT messages = self . stream . getvalue ( ) . split ( ' \n ' + ( ' - ' * 79 ) + ' \n ' ) NEW_LINE return [ message_from_bytes ( force_bytes ( m ) ) for m in messages if m ] NEW_LINE DEDENT def test_console_stream_kwarg ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ The ▁ console ▁ backend ▁ can ▁ be ▁ pointed ▁ at ▁ an ▁ arbitrary ▁ stream . STRNEWLINE ▁ """ NEW_LINE s = StringIO ( ) NEW_LINE connection = mail . get_connection ( ' django . core . mail . backends . console . EmailBackend ' , stream = s ) NEW_LINE send_mail ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] , connection = connection ) NEW_LINE message = force_bytes ( s . getvalue ( ) . split ( ' \n ' + ( ' - ' * 79 ) + ' \n ' ) [ 0 ] ) NEW_LINE self . assertMessageHasHeaders ( message , { ( ' MIME - Version ' , '1.0' ) , ( ' Content - Type ' , ' text / plain ; ▁ charset = " utf - 8 " ' ) , ( ' Content - Transfer - Encoding ' , '7bit ' ) , ( ' Subject ' , ' Subject ' ) , ( ' From ' , ' from @ example . com ' ) , ( ' To ' , ' to @ example . com ' ) } ) NEW_LINE self . assertIn ( b ' \n Date : ▁ ' , message ) NEW_LINE DEDENT DEDENT class FakeSMTPChannel ( smtpd . SMTPChannel ) : NEW_LINE INDENT def collect_incoming_data ( self , data ) : NEW_LINE INDENT try : NEW_LINE INDENT smtpd . SMTPChannel . collect_incoming_data ( self , data ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE # ▁ ignore ▁ decode ▁ error ▁ in ▁ SSL / TLS ▁ connection ▁ tests ▁ as ▁ we ▁ only ▁ care ENDCOM # ▁ whether ▁ the ▁ connection ▁ attempt ▁ was ▁ made ENDCOM INDENT pass NEW_LINE DEDENT DEDENT def smtp_AUTH ( self , arg ) : NEW_LINE INDENT if arg == ' CRAM - MD5' : NEW_LINE # ▁ This ▁ is ▁ only ▁ the ▁ first ▁ part ▁ of ▁ the ▁ login ▁ process . ▁ But ▁ it ' s ▁ enough ENDCOM # ▁ for ▁ our ▁ tests . ENDCOM INDENT challenge = base64 . b64encode ( b ' somerandomstring13579' ) NEW_LINE self . push ( '334 ▁ % s ' % challenge . decode ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . push ( '502 ▁ Error : ▁ login ▁ " % s " ▁ not ▁ implemented ' % arg ) NEW_LINE DEDENT DEDENT DEDENT class FakeSMTPServer ( smtpd . SMTPServer , threading . Thread ) : NEW_LINE INDENT """ STRNEWLINE ▁ Asyncore ▁ SMTP ▁ server ▁ wrapped ▁ into ▁ a ▁ thread . ▁ Based ▁ on ▁ DummyFTPServer ▁ from : STRNEWLINE ▁ http : / / svn . python . org / view / python / branches / py3k / Lib / test / test _ ftplib . py ? revision = 86061 & view = markup STRNEWLINE ▁ """ NEW_LINE channel_class = FakeSMTPChannel NEW_LINE def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT threading . Thread . __init__ ( self ) NEW_LINE # ▁ New ▁ kwarg ▁ added ▁ in ▁ Python ▁ 3.5 ; ▁ default ▁ switching ▁ to ▁ False ▁ in ▁ 3.6 . ENDCOM if sys . version_info >= ( 3 , 5 ) : NEW_LINE INDENT kwargs [ ' decode _ data ' ] = True NEW_LINE DEDENT smtpd . SMTPServer . __init__ ( self , * args , ** kwargs ) NEW_LINE self . _sink = [ ] NEW_LINE self . active = False NEW_LINE self . active_lock = threading . Lock ( ) NEW_LINE self . sink_lock = threading . Lock ( ) NEW_LINE DEDENT def process_message ( self , peer , mailfrom , rcpttos , data ) : NEW_LINE INDENT data = data . encode ( ) NEW_LINE m = message_from_bytes ( data ) NEW_LINE maddr = parseaddr ( m . get ( ' from ' ) ) [ 1 ] NEW_LINE if mailfrom != maddr : NEW_LINE # ▁ According ▁ to ▁ the ▁ spec , ▁ mailfrom ▁ does ▁ not ▁ necessarily ▁ match ▁ the ENDCOM # ▁ From ▁ header ▁ - ▁ this ▁ is ▁ the ▁ case ▁ where ▁ the ▁ local ▁ part ▁ isn ' t ENDCOM # ▁ encoded , ▁ so ▁ try ▁ to ▁ correct ▁ that . ENDCOM INDENT lp , domain = mailfrom . split ( ' @ ' , 1 ) NEW_LINE lp = Header ( lp , ' utf - 8' ) . encode ( ) NEW_LINE mailfrom = ' @ ' . join ( [ lp , domain ] ) NEW_LINE DEDENT if mailfrom != maddr : NEW_LINE INDENT return "553 ▁ ' % s ' ▁ ! = ▁ ' % s ' " % ( mailfrom , maddr ) NEW_LINE DEDENT with self . sink_lock : NEW_LINE INDENT self . _sink . append ( m ) NEW_LINE DEDENT DEDENT def get_sink ( self ) : NEW_LINE INDENT with self . sink_lock : NEW_LINE INDENT return self . _sink [ : ] NEW_LINE DEDENT DEDENT def flush_sink ( self ) : NEW_LINE INDENT with self . sink_lock : NEW_LINE INDENT self . _sink [ : ] = [ ] NEW_LINE DEDENT DEDENT def start ( self ) : NEW_LINE INDENT assert not self . active NEW_LINE self . __flag = threading . Event ( ) NEW_LINE threading . Thread . start ( self ) NEW_LINE self . __flag . wait ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT self . active = True NEW_LINE self . __flag . set ( ) NEW_LINE while self . active and asyncore . socket_map : NEW_LINE INDENT with self . active_lock : NEW_LINE INDENT asyncore . loop ( timeout = 0.1 , count = 1 ) NEW_LINE DEDENT DEDENT asyncore . close_all ( ) NEW_LINE DEDENT def stop ( self ) : NEW_LINE INDENT if self . active : NEW_LINE INDENT self . active = False NEW_LINE self . join ( ) NEW_LINE DEDENT DEDENT DEDENT class FakeAUTHSMTPConnection ( SMTP ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ SMTP ▁ connection ▁ pretending ▁ support ▁ for ▁ the ▁ AUTH ▁ command . ▁ It ▁ does ▁ not , ▁ but STRNEWLINE ▁ at ▁ least ▁ this ▁ can ▁ allow ▁ testing ▁ the ▁ first ▁ part ▁ of ▁ the ▁ AUTH ▁ process . STRNEWLINE ▁ """ NEW_LINE def ehlo ( self , name = ' ' ) : NEW_LINE INDENT response = SMTP . ehlo ( self , name = name ) NEW_LINE self . esmtp_features . update ( { ' auth ' : ' CRAM - MD5 ▁ PLAIN ▁ LOGIN ' , } ) NEW_LINE return response NEW_LINE DEDENT DEDENT class SMTPBackendTestsBase ( SimpleTestCase ) : NEW_LINE INDENT @ classmethod NEW_LINE def setUpClass ( cls ) : NEW_LINE INDENT super ( ) . setUpClass ( ) NEW_LINE cls . server = FakeSMTPServer ( ( '127.0.0.1' , 0 ) , None ) NEW_LINE cls . _settings_override = override_settings ( EMAIL_HOST = "127.0.0.1" , EMAIL_PORT = cls . server . socket . getsockname ( ) [ 1 ] ) NEW_LINE cls . _settings_override . enable ( ) NEW_LINE cls . server . start ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def tearDownClass ( cls ) : NEW_LINE INDENT cls . _settings_override . disable ( ) NEW_LINE cls . server . stop ( ) NEW_LINE super ( ) . tearDownClass ( ) NEW_LINE DEDENT DEDENT class SMTPBackendTests ( BaseEmailBackendTests , SMTPBackendTestsBase ) : NEW_LINE INDENT email_backend = ' django . core . mail . backends . smtp . EmailBackend ' NEW_LINE def setUp ( self ) : NEW_LINE INDENT super ( ) . setUp ( ) NEW_LINE self . server . flush_sink ( ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT self . server . flush_sink ( ) NEW_LINE super ( ) . tearDown ( ) NEW_LINE DEDENT def flush_mailbox ( self ) : NEW_LINE INDENT self . server . flush_sink ( ) NEW_LINE DEDENT def get_mailbox_content ( self ) : NEW_LINE INDENT return self . server . get_sink ( ) NEW_LINE DEDENT @ override_settings ( EMAIL_HOST_USER = " not ▁ empty ▁ username " , EMAIL_HOST_PASSWORD = " not ▁ empty ▁ password " ) NEW_LINE def test_email_authentication_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . username , ' not ▁ empty ▁ username ' ) NEW_LINE self . assertEqual ( backend . password , ' not ▁ empty ▁ password ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_HOST_USER = " not ▁ empty ▁ username " , EMAIL_HOST_PASSWORD = " not ▁ empty ▁ password " ) NEW_LINE def test_email_authentication_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( username = ' username ' , password = ' password ' ) NEW_LINE self . assertEqual ( backend . username , ' username ' ) NEW_LINE self . assertEqual ( backend . password , ' password ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_HOST_USER = " not ▁ empty ▁ username " , EMAIL_HOST_PASSWORD = " not ▁ empty ▁ password " ) NEW_LINE def test_email_disabled_authentication ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE self . assertEqual ( backend . username , ' ' ) NEW_LINE self . assertEqual ( backend . password , ' ' ) NEW_LINE DEDENT def test_auth_attempted ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Opening ▁ the ▁ backend ▁ with ▁ non ▁ empty ▁ username / password ▁ tries STRNEWLINE ▁ to ▁ authenticate ▁ against ▁ the ▁ SMTP ▁ server . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( username = ' not ▁ empty ▁ username ' , password = ' not ▁ empty ▁ password ' ) NEW_LINE with self . assertRaisesMessage ( SMTPException , ' SMTP ▁ AUTH ▁ extension ▁ not ▁ supported ▁ by ▁ server . ' ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT def test_server_open ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ open ( ) ▁ returns ▁ whether ▁ it ▁ opened ▁ a ▁ connection . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE self . assertFalse ( backend . connection ) NEW_LINE opened = backend . open ( ) NEW_LINE backend . close ( ) NEW_LINE self . assertTrue ( opened ) NEW_LINE DEDENT def test_server_login ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Even ▁ if ▁ the ▁ Python ▁ SMTP ▁ server ▁ doesn ' t ▁ support ▁ authentication , ▁ the STRNEWLINE ▁ login ▁ process ▁ starts ▁ and ▁ the ▁ appropriate ▁ exception ▁ is ▁ raised . STRNEWLINE ▁ """ NEW_LINE class CustomEmailBackend ( smtp . EmailBackend ) : NEW_LINE INDENT connection_class = FakeAUTHSMTPConnection NEW_LINE DEDENT backend = CustomEmailBackend ( username = ' username ' , password = ' password ' ) NEW_LINE with self . assertRaises ( SMTPAuthenticationError ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT @ override_settings ( EMAIL_USE_TLS = True ) NEW_LINE def test_email_tls_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_tls ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_TLS = True ) NEW_LINE def test_email_tls_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( use_tls = False ) NEW_LINE self . assertFalse ( backend . use_tls ) NEW_LINE DEDENT def test_email_tls_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertFalse ( backend . use_tls ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_SSL = True ) NEW_LINE def test_email_ssl_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_ssl ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_SSL = True ) NEW_LINE def test_email_ssl_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( use_ssl = False ) NEW_LINE self . assertFalse ( backend . use_ssl ) NEW_LINE DEDENT def test_email_ssl_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertFalse ( backend . use_ssl ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_CERTFILE = ' foo ' ) NEW_LINE def test_email_ssl_certfile_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . ssl_certfile , ' foo ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_CERTFILE = ' foo ' ) NEW_LINE def test_email_ssl_certfile_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ssl_certfile = ' bar ' ) NEW_LINE self . assertEqual ( backend . ssl_certfile , ' bar ' ) NEW_LINE DEDENT def test_email_ssl_certfile_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertIsNone ( backend . ssl_certfile ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_KEYFILE = ' foo ' ) NEW_LINE def test_email_ssl_keyfile_use_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . ssl_keyfile , ' foo ' ) NEW_LINE DEDENT @ override_settings ( EMAIL_SSL_KEYFILE = ' foo ' ) NEW_LINE def test_email_ssl_keyfile_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ssl_keyfile = ' bar ' ) NEW_LINE self . assertEqual ( backend . ssl_keyfile , ' bar ' ) NEW_LINE DEDENT def test_email_ssl_keyfile_default_disabled ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertIsNone ( backend . ssl_keyfile ) NEW_LINE DEDENT @ override_settings ( EMAIL_USE_TLS = True ) NEW_LINE def test_email_tls_attempts_starttls ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_tls ) NEW_LINE with self . assertRaisesMessage ( SMTPException , ' STARTTLS ▁ extension ▁ not ▁ supported ▁ by ▁ server . ' ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT @ override_settings ( EMAIL_USE_SSL = True ) NEW_LINE def test_email_ssl_attempts_ssl_connection ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertTrue ( backend . use_ssl ) NEW_LINE with self . assertRaises ( SSLError ) : NEW_LINE INDENT with backend : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT def test_connection_timeout_default ( self ) : NEW_LINE INDENT """ The ▁ connection ' s ▁ timeout ▁ value ▁ is ▁ None ▁ by ▁ default . """ NEW_LINE connection = mail . get_connection ( ' django . core . mail . backends . smtp . EmailBackend ' ) NEW_LINE self . assertIsNone ( connection . timeout ) NEW_LINE DEDENT def test_connection_timeout_custom ( self ) : NEW_LINE INDENT """ The ▁ timeout ▁ parameter ▁ can ▁ be ▁ customized . """ NEW_LINE class MyEmailBackend ( smtp . EmailBackend ) : NEW_LINE INDENT def __init__ ( self , * args , ** kwargs ) : NEW_LINE INDENT kwargs . setdefault ( ' timeout ' , 42 ) NEW_LINE super ( ) . __init__ ( * args , ** kwargs ) NEW_LINE DEDENT DEDENT myemailbackend = MyEmailBackend ( ) NEW_LINE myemailbackend . open ( ) NEW_LINE self . assertEqual ( myemailbackend . timeout , 42 ) NEW_LINE self . assertEqual ( myemailbackend . connection . timeout , 42 ) NEW_LINE myemailbackend . close ( ) NEW_LINE DEDENT @ override_settings ( EMAIL_TIMEOUT = 10 ) NEW_LINE def test_email_timeout_override_settings ( self ) : NEW_LINE INDENT backend = smtp . EmailBackend ( ) NEW_LINE self . assertEqual ( backend . timeout , 10 ) NEW_LINE DEDENT def test_email_msg_uses_crlf ( self ) : NEW_LINE INDENT """ # 23063 ▁ - - ▁ RFC - compliant ▁ messages ▁ are ▁ sent ▁ over ▁ SMTP . """ NEW_LINE send = SMTP . send NEW_LINE try : NEW_LINE INDENT smtp_messages = [ ] NEW_LINE def mock_send ( self , s ) : NEW_LINE INDENT smtp_messages . append ( s ) NEW_LINE return send ( self , s ) NEW_LINE DEDENT SMTP . send = mock_send NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE mail . get_connection ( ) . send_messages ( [ email ] ) NEW_LINE # ▁ Find ▁ the ▁ actual ▁ message ENDCOM msg = None NEW_LINE for i , m in enumerate ( smtp_messages ) : NEW_LINE INDENT if m [ : 4 ] == ' data ' : NEW_LINE INDENT msg = smtp_messages [ i + 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT self . assertTrue ( msg ) NEW_LINE msg = msg . decode ( ) NEW_LINE # ▁ The ▁ message ▁ only ▁ contains ▁ CRLF ▁ and ▁ not ▁ combinations ▁ of ▁ CRLF , ▁ LF , ▁ and ▁ CR . ENDCOM msg = msg . replace ( ' \n ' , ' ' ) NEW_LINE self . assertNotIn ( ' ' , msg ) NEW_LINE self . assertNotIn ( ' \n ' , msg ) NEW_LINE DEDENT finally : NEW_LINE INDENT SMTP . send = send NEW_LINE DEDENT DEDENT def test_send_messages_after_open_failed ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ send _ messages ( ) ▁ shouldn ' t ▁ try ▁ to ▁ send ▁ messages ▁ if ▁ open ( ) ▁ raises ▁ an STRNEWLINE ▁ exception ▁ after ▁ initializing ▁ the ▁ connection . STRNEWLINE ▁ """ NEW_LINE backend = smtp . EmailBackend ( ) NEW_LINE # ▁ Simulate ▁ connection ▁ initialization ▁ success ▁ and ▁ a ▁ subsequent ENDCOM # ▁ connection ▁ exception . ENDCOM backend . connection = True NEW_LINE backend . open = lambda : None NEW_LINE email = EmailMessage ( ' Subject ' , ' Content ' , ' from @ example . com ' , [ ' to @ example . com ' ] ) NEW_LINE self . assertEqual ( backend . send_messages ( [ email ] ) , None ) NEW_LINE DEDENT DEDENT class SMTPBackendStoppedServerTests ( SMTPBackendTestsBase ) : NEW_LINE INDENT """ STRNEWLINE ▁ These ▁ tests ▁ require ▁ a ▁ separate ▁ class , ▁ because ▁ the ▁ FakeSMTPServer ▁ is ▁ shut STRNEWLINE ▁ down ▁ in ▁ setUpClass ( ) , ▁ and ▁ it ▁ cannot ▁ be ▁ restarted ▁ ( " RuntimeError : ▁ threads STRNEWLINE ▁ can ▁ only ▁ be ▁ started ▁ once " ) . STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def setUpClass ( cls ) : NEW_LINE INDENT super ( ) . setUpClass ( ) NEW_LINE cls . backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE cls . server . stop ( ) NEW_LINE DEDENT def test_server_stopped ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Closing ▁ the ▁ backend ▁ while ▁ the ▁ SMTP ▁ server ▁ is ▁ stopped ▁ doesn ' t ▁ raise ▁ an STRNEWLINE ▁ exception . STRNEWLINE ▁ """ NEW_LINE self . backend . close ( ) NEW_LINE DEDENT def test_fail_silently_on_connection_error ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ socket ▁ connection ▁ error ▁ is ▁ silenced ▁ with ▁ fail _ silently = True . STRNEWLINE ▁ """ NEW_LINE with self . assertRaises ( socket . error ) : NEW_LINE INDENT self . backend . open ( ) NEW_LINE DEDENT self . backend . fail_silently = True NEW_LINE self . backend . open ( ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="tommy-u/chaco/tree/master/chaco/base_plot_container.py"> """ ▁ Defines ▁ the ▁ BasePlotContainer ▁ class . STRNEWLINE """ NEW_LINE import warnings NEW_LINE # ▁ Enthought ▁ library ▁ imports ENDCOM from enable . api import Container NEW_LINE from traits . api import Bool , Instance , Property , Str , Tuple NEW_LINE # ▁ Local , ▁ relative ▁ imports ENDCOM from plot_component import DEFAULT_DRAWING_ORDER , PlotComponent NEW_LINE class BasePlotContainer ( Container ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ container ▁ for ▁ PlotComponents ▁ that ▁ conforms ▁ to ▁ being ▁ laid ▁ out ▁ by STRNEWLINE ▁ PlotFrames . ▁ Serves ▁ as ▁ the ▁ base ▁ class ▁ for ▁ other ▁ PlotContainers . STRNEWLINE STRNEWLINE ▁ PlotContainers ▁ define ▁ a ▁ layout , ▁ i . e . , ▁ a ▁ spatial ▁ relationship ▁ between STRNEWLINE ▁ their ▁ contained ▁ components . ▁ ( BasePlotContainer ▁ doesn ' t ▁ define ▁ one , STRNEWLINE ▁ but ▁ its ▁ various ▁ subclasses ▁ do . ) STRNEWLINE STRNEWLINE ▁ BasePlotContainer ▁ is ▁ a ▁ subclass ▁ of ▁ Enable ▁ Container , ▁ so ▁ it ▁ is ▁ possible ▁ to STRNEWLINE ▁ insert ▁ Enable - level ▁ components ▁ into ▁ it . ▁ However , ▁ because ▁ Enable STRNEWLINE ▁ components ▁ don ' t ▁ have ▁ the ▁ correct ▁ interfaces ▁ to ▁ participate ▁ in ▁ layout , STRNEWLINE ▁ the ▁ visual ▁ results ▁ will ▁ probably ▁ be ▁ incorrect . STRNEWLINE ▁ """ NEW_LINE # ▁ Redefine ▁ the ▁ container ▁ layers ▁ to ▁ name ▁ the ▁ main ▁ layer ▁ as ▁ " plot " ▁ instead ENDCOM # ▁ of ▁ the ▁ Enable ▁ default ▁ of ▁ " mainlayer " ENDCOM container_under_layers = Tuple ( " background " , " image " , " underlay " , " plot " ) NEW_LINE # ▁ Duplicate ▁ trait ▁ declarations ▁ from ▁ PlotComponent . ▁ We ▁ don ' t ▁ subclass ENDCOM # ▁ PlotComponent ▁ to ▁ avoid ▁ MRO ▁ complications ▁ with ▁ trait ▁ handlers ▁ and ▁ property ENDCOM # ▁ getters / setters . ENDCOM draw_order = Instance ( list , args = ( DEFAULT_DRAWING_ORDER , ) ) NEW_LINE draw_layer = Str ( " plot " ) NEW_LINE # ▁ Deprecated ▁ traits ENDCOM # ▁ Deprecated ▁ flag ▁ to ▁ indicate ▁ that ▁ a ▁ component ▁ needed ▁ to ▁ do ▁ old - style ENDCOM # ▁ drawing . ▁ Unused ▁ by ▁ any ▁ recent ▁ Chaco ▁ component . ENDCOM use_draw_order = Bool ( True ) NEW_LINE # ▁ Deprecated ▁ property ▁ for ▁ accessing ▁ the ▁ components ▁ in ▁ the ▁ container . ENDCOM plot_components = Property NEW_LINE def _get_plot_components ( self ) : NEW_LINE INDENT warnings . warn ( " Use ▁ of ▁ plot _ components ▁ attribute ▁ deprecated . " " Use ▁ components ▁ attribute ▁ instead . " , DeprecationWarning ) NEW_LINE return self . _components NEW_LINE DEDENT def _set_plot_components ( self , new ) : NEW_LINE INDENT warnings . warn ( " Use ▁ of ▁ plot _ components ▁ attribute ▁ deprecated . " " Use ▁ components ▁ attribute ▁ instead . " , DeprecationWarning ) NEW_LINE self . _components = new NEW_LINE DEDENT def _use_draw_order_changed ( self , old , new ) : NEW_LINE INDENT """ ▁ Handler ▁ to ▁ catch ▁ the ▁ case ▁ when ▁ someone ▁ is ▁ trying ▁ to ▁ use ▁ the STRNEWLINE ▁ old - style ▁ drawing ▁ mechanism , ▁ which ▁ is ▁ now ▁ unsupported . STRNEWLINE ▁ """ NEW_LINE if new == False : NEW_LINE INDENT raise RuntimeError ( " The ▁ old - style ▁ drawing ▁ mechanism ▁ is ▁ no ▁ longer ▁ " " supported ▁ in ▁ Chaco . " ) NEW_LINE # ▁ EOF ENDCOM DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="indevgr/django/tree/master/tests/servers/tests.py"> # ▁ - * - ▁ encoding : ▁ utf - 8 ▁ - * - ENDCOM """ STRNEWLINE Tests ▁ for ▁ django . core . servers . STRNEWLINE """ NEW_LINE from __future__ import unicode_literals NEW_LINE import contextlib NEW_LINE import errno NEW_LINE import os NEW_LINE import socket NEW_LINE from django . core . exceptions import ImproperlyConfigured NEW_LINE from django . test import LiveServerTestCase , override_settings NEW_LINE from django . utils . _os import upath NEW_LINE from django . utils . http import urlencode NEW_LINE from django . utils . six import text_type NEW_LINE from django . utils . six . moves . urllib . error import HTTPError NEW_LINE from django . utils . six . moves . urllib . request import urlopen NEW_LINE from . models import Person NEW_LINE TEST_ROOT = os . path . dirname ( upath ( __file__ ) ) NEW_LINE TEST_SETTINGS = { ' MEDIA _ URL ' : ' / media / ' , ' MEDIA _ ROOT ' : os . path . join ( TEST_ROOT , ' media ' ) , ' STATIC _ URL ' : ' / static / ' , ' STATIC _ ROOT ' : os . path . join ( TEST_ROOT , ' static ' ) , } NEW_LINE @ override_settings ( ROOT_URLCONF = ' servers . urls ' , ** TEST_SETTINGS ) NEW_LINE class LiveServerBase ( LiveServerTestCase ) : NEW_LINE INDENT available_apps = [ ' servers ' , ' django . contrib . auth ' , ' django . contrib . contenttypes ' , ' django . contrib . sessions ' , ] NEW_LINE fixtures = [ ' testdata . json ' ] NEW_LINE def urlopen ( self , url ) : NEW_LINE INDENT return urlopen ( self . live_server_url + url ) NEW_LINE DEDENT DEDENT class LiveServerAddress ( LiveServerBase ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ address ▁ set ▁ in ▁ the ▁ environment ▁ variable ▁ is ▁ valid . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def setUpClass ( cls ) : NEW_LINE # ▁ Backup ▁ original ▁ environment ▁ variable ENDCOM INDENT address_predefined = ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' in os . environ NEW_LINE old_address = os . environ . get ( ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ) NEW_LINE # ▁ Just ▁ the ▁ host ▁ is ▁ not ▁ accepted ENDCOM cls . raises_exception ( ' localhost ' , ImproperlyConfigured ) NEW_LINE # ▁ The ▁ host ▁ must ▁ be ▁ valid ENDCOM cls . raises_exception ( ' blahblahblah : 8081' , socket . error ) NEW_LINE # ▁ The ▁ list ▁ of ▁ ports ▁ must ▁ be ▁ in ▁ a ▁ valid ▁ format ENDCOM cls . raises_exception ( ' localhost : 8081 , ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 , blah ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 - ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 - blah ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081-8082-8083' , ImproperlyConfigured ) NEW_LINE # ▁ Restore ▁ original ▁ environment ▁ variable ENDCOM if address_predefined : NEW_LINE INDENT os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] = old_address NEW_LINE DEDENT else : NEW_LINE INDENT del os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] NEW_LINE # ▁ put ▁ it ▁ in ▁ a ▁ list ▁ to ▁ prevent ▁ descriptor ▁ lookups ▁ in ▁ test ENDCOM DEDENT cls . live_server_url_test = [ cls . live_server_url ] NEW_LINE DEDENT @ classmethod NEW_LINE def tearDownClass ( cls ) : NEW_LINE # ▁ skip ▁ it , ▁ as ▁ setUpClass ▁ doesn ' t ▁ call ▁ its ▁ parent ▁ either ENDCOM INDENT pass NEW_LINE DEDENT @ classmethod NEW_LINE def raises_exception ( cls , address , exception ) : NEW_LINE INDENT os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] = address NEW_LINE try : NEW_LINE INDENT super ( LiveServerAddress , cls ) . setUpClass ( ) NEW_LINE raise Exception ( " The ▁ line ▁ above ▁ should ▁ have ▁ raised ▁ an ▁ exception " ) NEW_LINE DEDENT except exception : NEW_LINE INDENT pass NEW_LINE DEDENT finally : NEW_LINE INDENT super ( LiveServerAddress , cls ) . tearDownClass ( ) NEW_LINE DEDENT DEDENT def test_live_server_url_is_class_property ( self ) : NEW_LINE INDENT self . assertIsInstance ( self . live_server_url_test [ 0 ] , text_type ) NEW_LINE self . assertEqual ( self . live_server_url_test [ 0 ] , self . live_server_url ) NEW_LINE DEDENT DEDENT class LiveServerViews ( LiveServerBase ) : NEW_LINE INDENT def test_404 ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ 404s . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . urlopen ( ' / ' ) NEW_LINE DEDENT except HTTPError as err : NEW_LINE INDENT self . assertEqual ( err . code , 404 , ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT DEDENT def test_view ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ views . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / example _ view / ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) , b ' example ▁ view ' ) NEW_LINE DEDENT DEDENT def test_static_files ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ static ▁ files . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / static / example _ static _ file . txt ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . rstrip ( b ' \n ' ) , b ' example ▁ static ▁ file ' ) NEW_LINE DEDENT DEDENT def test_no_collectstatic_emulation ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Test ▁ that ▁ LiveServerTestCase ▁ reports ▁ a ▁ 404 ▁ status ▁ code ▁ when ▁ HTTP ▁ client STRNEWLINE ▁ tries ▁ to ▁ access ▁ a ▁ static ▁ file ▁ that ▁ isn ' t ▁ explicitly ▁ put ▁ under STRNEWLINE ▁ STATIC _ ROOT . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . urlopen ( ' / static / another _ app / another _ app _ static _ file . txt ' ) NEW_LINE DEDENT except HTTPError as err : NEW_LINE INDENT self . assertEqual ( err . code , 404 , ' Expected ▁ 404 ▁ response ' ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Expected ▁ 404 ▁ response ▁ ( got ▁ % d ) ' % err . code ) NEW_LINE DEDENT DEDENT def test_media_files ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ the ▁ LiveServerTestCase ▁ serves ▁ media ▁ files . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / media / example _ media _ file . txt ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . rstrip ( b ' \n ' ) , b ' example ▁ media ▁ file ' ) NEW_LINE DEDENT DEDENT def test_environ ( self ) : NEW_LINE INDENT with contextlib . closing ( self . urlopen ( ' / environ _ view / ? % s ' % urlencode ( { ' q ' : ' тест ' } ) ) ) as f : NEW_LINE INDENT self . assertIn ( b " QUERY _ STRING : ▁ ' q = % D1%82 % D0 % B5 % D1%81 % D1%82 ' " , f . read ( ) ) NEW_LINE DEDENT DEDENT DEDENT class LiveServerDatabase ( LiveServerBase ) : NEW_LINE INDENT def test_fixtures_loaded ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ fixtures ▁ are ▁ properly ▁ loaded ▁ and ▁ visible ▁ to ▁ the STRNEWLINE ▁ live ▁ server ▁ thread . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE with contextlib . closing ( self . urlopen ( ' / model _ view / ' ) ) as f : NEW_LINE INDENT self . assertEqual ( f . read ( ) . splitlines ( ) , [ b ' jane ' , b ' robert ' ] ) NEW_LINE DEDENT DEDENT def test_database_writes ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Ensure ▁ that ▁ data ▁ written ▁ to ▁ the ▁ database ▁ by ▁ a ▁ view ▁ can ▁ be ▁ read . STRNEWLINE ▁ Refs ▁ # 2879 . STRNEWLINE ▁ """ NEW_LINE self . urlopen ( ' / create _ model _ instance / ' ) NEW_LINE self . assertQuerysetEqual ( Person . objects . all ( ) . order_by ( ' pk ' ) , [ ' jane ' , ' robert ' , ' emily ' ] , lambda b : b . name ) NEW_LINE DEDENT DEDENT class LiveServerPort ( LiveServerBase ) : NEW_LINE INDENT def test_port_bind ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Each ▁ LiveServerTestCase ▁ binds ▁ to ▁ a ▁ unique ▁ port ▁ or ▁ fails ▁ to ▁ start ▁ a STRNEWLINE ▁ server ▁ thread ▁ when ▁ run ▁ concurrently ▁ ( # 26011 ) . STRNEWLINE ▁ """ NEW_LINE TestCase = type ( str ( " TestCase " ) , ( LiveServerBase , ) , { } ) NEW_LINE try : NEW_LINE INDENT TestCase . setUpClass ( ) NEW_LINE DEDENT except socket . error as e : NEW_LINE INDENT if e . errno == errno . EADDRINUSE : NEW_LINE # ▁ We ' re ▁ out ▁ of ▁ ports , ▁ LiveServerTestCase ▁ correctly ▁ fails ▁ with ENDCOM # ▁ a ▁ socket ▁ error . ENDCOM INDENT return NEW_LINE # ▁ Unexpected ▁ error . ENDCOM DEDENT raise NEW_LINE DEDENT try : NEW_LINE # ▁ We ' ve ▁ acquired ▁ a ▁ port , ▁ ensure ▁ our ▁ server ▁ threads ▁ acquired ENDCOM # ▁ different ▁ addresses . ENDCOM INDENT self . assertNotEqual ( self . live_server_url , TestCase . live_server_url , " Acquired ▁ duplicate ▁ server ▁ addresses ▁ for ▁ server ▁ threads : ▁ % s " % self . live_server_url ) NEW_LINE DEDENT finally : NEW_LINE INDENT TestCase . tearDownClass ( ) NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="thierry1985/project-1022/tree/master/MISC/TFD-0.2.2/translate/pddl/parser.py"> __all__ = [ " ParseError " , " parse _ nested _ list " ] NEW_LINE class ParseError ( Exception ) : NEW_LINE INDENT pass NEW_LINE # ▁ Basic ▁ functions ▁ for ▁ parsing ▁ PDDL ▁ ( Lisp ) ▁ files . ENDCOM DEDENT def parse_nested_list ( input_file ) : NEW_LINE INDENT tokens = tokenize ( input_file ) NEW_LINE next_token = tokens . next ( ) NEW_LINE if next_token != " ( " : NEW_LINE INDENT raise ParseError ( " Expected ▁ ' ( ' , ▁ got ▁ % s . " % next_token ) NEW_LINE DEDENT result = list ( parse_list_aux ( tokens ) ) NEW_LINE for tok in tokens : # ▁ Check ▁ that ▁ generator ▁ is ▁ exhausted . ENDCOM NEW_LINE INDENT raise ParseError ( " Unexpected ▁ token : ▁ % s . " % tok ) NEW_LINE DEDENT return result NEW_LINE DEDENT def tokenize ( input ) : NEW_LINE INDENT for line in input : NEW_LINE INDENT line = line . split ( " ; " , 1 ) [ 0 ] # ▁ Strip ▁ comments . ENDCOM NEW_LINE line = line . replace ( " ( " , " ▁ ( ▁ " ) . replace ( " ) " , " ▁ ) ▁ " ) . replace ( " ? " , " ▁ ? " ) NEW_LINE for token in line . split ( ) : NEW_LINE INDENT yield token . lower ( ) NEW_LINE DEDENT DEDENT DEDENT def parse_list_aux ( tokenstream ) : NEW_LINE # ▁ Leading ▁ " ( " ▁ has ▁ already ▁ been ▁ swallowed . ENDCOM INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT token = tokenstream . next ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise ParseError ( ) NEW_LINE DEDENT if token == " ) " : NEW_LINE INDENT return NEW_LINE DEDENT elif token == " ( " : NEW_LINE INDENT yield list ( parse_list_aux ( tokenstream ) ) NEW_LINE DEDENT else : NEW_LINE INDENT yield token NEW_LINE DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="Baumelbi/IntroPython2016/tree/master/Solutions/Session06/test_mailroom2.py"> # ! / usr / bin / env ▁ python ENDCOM """ STRNEWLINE unit ▁ tests ▁ for ▁ the ▁ mailroom ▁ program STRNEWLINE """ NEW_LINE import os NEW_LINE import mailroom2 as mailroom NEW_LINE # ▁ so ▁ that ▁ it ' s ▁ there ▁ for ▁ the ▁ tests ENDCOM mailroom . donor_db = mailroom . get_donor_db ( ) NEW_LINE def test_list_donors ( ) : NEW_LINE INDENT listing = mailroom . list_donors ( ) NEW_LINE # ▁ hard ▁ to ▁ test ▁ this ▁ throughly ▁ - - ▁ better ▁ not ▁ to ▁ hard ▁ code ▁ the ▁ entire ENDCOM # ▁ thing . ▁ But ▁ check ▁ for ▁ a ▁ few ▁ aspects ▁ - - ▁ this ▁ will ▁ catch ▁ the ▁ likely ENDCOM # ▁ errors ENDCOM assert listing . startswith ( " Donor ▁ list : \n " ) NEW_LINE assert " Jeff ▁ Bezos " in listing NEW_LINE assert " William ▁ Gates ▁ III " in listing NEW_LINE assert len ( listing . split ( ' \n ' ) ) == 5 NEW_LINE DEDENT def test_find_donor ( ) : NEW_LINE INDENT """ ▁ checks ▁ a ▁ donor ▁ that ▁ is ▁ there , ▁ but ▁ with ▁ odd ▁ case ▁ and ▁ spaces """ NEW_LINE donor = mailroom . find_donor ( " jefF ▁ beZos ▁ " ) NEW_LINE assert donor [ 0 ] == " Jeff ▁ Bezos " NEW_LINE DEDENT def test_find_donor_not ( ) : NEW_LINE INDENT " test ▁ one ▁ that ' s ▁ not ▁ there " NEW_LINE donor = mailroom . find_donor ( " Jeff ▁ Bzos " ) NEW_LINE assert donor is None NEW_LINE DEDENT def test_gen_letter ( ) : NEW_LINE INDENT """ ▁ test ▁ the ▁ donor ▁ letter ▁ """ NEW_LINE # ▁ create ▁ a ▁ sample ▁ donor ENDCOM donor = ( " Fred ▁ Flintstone " , [ 432.45 , 65.45 , 230.0 ] ) NEW_LINE letter = mailroom . gen_letter ( donor ) NEW_LINE # ▁ what ▁ to ▁ test ? ▁ tricky ! ENDCOM assert letter . startswith ( " Dear ▁ Fred ▁ Flintstone " ) NEW_LINE assert letter . endswith ( " - The ▁ Team \n " ) NEW_LINE assert " donation ▁ of ▁ $ 230.00" in letter NEW_LINE DEDENT def test_add_donor ( ) : NEW_LINE INDENT name = " Fred ▁ Flintstone ▁ ▁ " NEW_LINE donor = mailroom . add_donor ( name ) NEW_LINE donor [ 1 ] . append ( 300 ) NEW_LINE assert donor [ 0 ] == " Fred ▁ Flintstone " NEW_LINE assert donor [ 1 ] == [ 300 ] NEW_LINE assert mailroom . find_donor ( name ) == donor NEW_LINE DEDENT def test_generate_donor_report ( ) : NEW_LINE INDENT report = mailroom . generate_donor_report ( ) NEW_LINE print ( report ) # ▁ printing ▁ so ▁ you ▁ can ▁ see ▁ it ▁ if ▁ it ▁ fails ENDCOM NEW_LINE # ▁ this ▁ is ▁ pretty ▁ tough ▁ to ▁ test ENDCOM # ▁ these ▁ are ▁ not ▁ great , ▁ because ▁ they ▁ will ▁ fail ▁ if ▁ unimportant ▁ parts ▁ of ▁ the ENDCOM # ▁ report ▁ are ▁ changed . ENDCOM # ▁ but ▁ at ▁ least ▁ you ▁ know ▁ that ▁ codes ▁ working ▁ now . ENDCOM assert report . startswith ( " Donor ▁ Name ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ | ▁ Total ▁ Given ▁ | ▁ Num ▁ Gifts ▁ | ▁ Average ▁ Gift " ) NEW_LINE assert " Jeff ▁ Bezos ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ $ ▁ ▁ ▁ ▁ 877.33 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ 1 ▁ ▁ ▁ $ ▁ ▁ ▁ ▁ ▁ 877.33" in report NEW_LINE DEDENT def test_save_letters_to_disk ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ only ▁ tests ▁ that ▁ the ▁ files ▁ get ▁ created , ▁ but ▁ that ' s ▁ a ▁ start STRNEWLINE STRNEWLINE ▁ Note ▁ that ▁ the ▁ contents ▁ of ▁ the ▁ letter ▁ was ▁ already STRNEWLINE ▁ tested ▁ with ▁ test _ gen _ letter STRNEWLINE ▁ """ NEW_LINE mailroom . save_letters_to_disk ( ) NEW_LINE assert os . path . isfile ( ' Jeff _ Bezos . txt ' ) NEW_LINE assert os . path . isfile ( ' William _ Gates _ III . txt ' ) NEW_LINE # ▁ check ▁ that ▁ it ' snot ▁ empty : ENDCOM with open ( ' William _ Gates _ III . txt ' ) as f : NEW_LINE INDENT size = len ( f . read ( ) ) NEW_LINE DEDENT assert size > 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE # ▁ this ▁ is ▁ best ▁ run ▁ with ▁ a ▁ test ▁ runner , ▁ like ▁ pytest ENDCOM # ▁ But ▁ if ▁ not , ▁ at ▁ least ▁ this ▁ will ▁ run ▁ them ▁ all . ENDCOM INDENT test_list_donors ( ) NEW_LINE test_find_donor ( ) NEW_LINE test_find_donor_not ( ) NEW_LINE test_gen_letter ( ) NEW_LINE test_add_donor ( ) NEW_LINE test_generate_donor_report ( ) NEW_LINE test_save_letters_to_disk ( ) NEW_LINE print ( " All ▁ tests ▁ Passed " ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="rpmcpp/Audacity/tree/master/lib-src/lv2/lv2/plugins/eg03-metro.lv2/waflib/Tools/vala.py"> # ! ▁ / usr / bin / env ▁ python ENDCOM # ▁ encoding : ▁ utf - 8 ENDCOM # ▁ WARNING ! ▁ Do ▁ not ▁ edit ! ▁ http : / / waf . googlecode . com / git / docs / wafbook / single . html # _ obtaining _ the _ waf _ file ENDCOM import os . path , shutil , re NEW_LINE from waflib import Context , Task , Utils , Logs , Options , Errors NEW_LINE from waflib . TaskGen import extension , taskgen_method NEW_LINE from waflib . Configure import conf NEW_LINE class valac ( Task . Task ) : NEW_LINE INDENT vars = [ " VALAC " , " VALAC _ VERSION " , " VALAFLAGS " ] NEW_LINE ext_out = [ ' . h ' ] NEW_LINE def run ( self ) : NEW_LINE INDENT cmd = [ self . env [ ' VALAC ' ] ] + self . env [ ' VALAFLAGS ' ] NEW_LINE cmd . extend ( [ a . abspath ( ) for a in self . inputs ] ) NEW_LINE ret = self . exec_command ( cmd , cwd = self . outputs [ 0 ] . parent . abspath ( ) ) NEW_LINE if ret : NEW_LINE INDENT return ret NEW_LINE DEDENT for x in self . outputs : NEW_LINE INDENT if id ( x . parent ) != id ( self . outputs [ 0 ] . parent ) : NEW_LINE INDENT shutil . move ( self . outputs [ 0 ] . parent . abspath ( ) + os . sep + x . name , x . abspath ( ) ) NEW_LINE DEDENT DEDENT if self . generator . dump_deps_node : NEW_LINE INDENT self . generator . dump_deps_node . write ( ' \n ' . join ( self . generator . packages ) ) NEW_LINE DEDENT return ret NEW_LINE DEDENT DEDENT valac = Task . update_outputs ( valac ) NEW_LINE @ taskgen_method NEW_LINE def init_vala_task ( self ) : NEW_LINE INDENT self . profile = getattr ( self , ' profile ' , ' gobject ' ) NEW_LINE if self . profile == ' gobject ' : NEW_LINE INDENT self . uselib = Utils . to_list ( getattr ( self , ' uselib ' , [ ] ) ) NEW_LINE if not ' GOBJECT ' in self . uselib : NEW_LINE INDENT self . uselib . append ( ' GOBJECT ' ) NEW_LINE DEDENT DEDENT def addflags ( flags ) : NEW_LINE INDENT self . env . append_value ( ' VALAFLAGS ' , flags ) NEW_LINE DEDENT if self . profile : NEW_LINE INDENT addflags ( ' - - profile = % s ' % self . profile ) NEW_LINE DEDENT if hasattr ( self , ' threading ' ) : NEW_LINE INDENT if self . profile == ' gobject ' : NEW_LINE INDENT if not ' GTHREAD ' in self . uselib : NEW_LINE INDENT self . uselib . append ( ' GTHREAD ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Logs . warn ( " Profile ▁ % s ▁ means ▁ no ▁ threading ▁ support " % self . profile ) NEW_LINE self . threading = False NEW_LINE DEDENT if self . threading : NEW_LINE INDENT addflags ( ' - - threading ' ) NEW_LINE DEDENT DEDENT valatask = self . valatask NEW_LINE self . is_lib = ' cprogram ' not in self . features NEW_LINE if self . is_lib : NEW_LINE INDENT addflags ( ' - - library = % s ' % self . target ) NEW_LINE h_node = self . path . find_or_declare ( ' % s . h ' % self . target ) NEW_LINE valatask . outputs . append ( h_node ) NEW_LINE addflags ( ' - - header = % s ' % h_node . name ) NEW_LINE valatask . outputs . append ( self . path . find_or_declare ( ' % s . vapi ' % self . target ) ) NEW_LINE if getattr ( self , ' gir ' , None ) : NEW_LINE INDENT gir_node = self . path . find_or_declare ( ' % s . gir ' % self . gir ) NEW_LINE addflags ( ' - - gir = % s ' % gir_node . name ) NEW_LINE valatask . outputs . append ( gir_node ) NEW_LINE DEDENT DEDENT self . vala_target_glib = getattr ( self , ' vala _ target _ glib ' , getattr ( Options . options , ' vala _ target _ glib ' , None ) ) NEW_LINE if self . vala_target_glib : NEW_LINE INDENT addflags ( ' - - target - glib = % s ' % self . vala_target_glib ) NEW_LINE DEDENT addflags ( [ ' - - define = % s ' % x for x in getattr ( self , ' vala _ defines ' , [ ] ) ] ) NEW_LINE packages_private = Utils . to_list ( getattr ( self , ' packages _ private ' , [ ] ) ) NEW_LINE addflags ( [ ' - - pkg = % s ' % x for x in packages_private ] ) NEW_LINE def _get_api_version ( ) : NEW_LINE INDENT api_version = '1.0' NEW_LINE if hasattr ( Context . g_module , ' API _ VERSION ' ) : NEW_LINE INDENT version = Context . g_module . API_VERSION . split ( " . " ) NEW_LINE if version [ 0 ] == "0" : NEW_LINE INDENT api_version = "0 . " + version [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT api_version = version [ 0 ] + " . 0" NEW_LINE DEDENT DEDENT return api_version NEW_LINE DEDENT self . includes = Utils . to_list ( getattr ( self , ' includes ' , [ ] ) ) NEW_LINE self . uselib = self . to_list ( getattr ( self , ' uselib ' , [ ] ) ) NEW_LINE valatask . install_path = getattr ( self , ' install _ path ' , ' ' ) NEW_LINE valatask . vapi_path = getattr ( self , ' vapi _ path ' , ' $ { DATAROOTDIR } / vala / vapi ' ) NEW_LINE valatask . pkg_name = getattr ( self , ' pkg _ name ' , self . env [ ' PACKAGE ' ] ) NEW_LINE valatask . header_path = getattr ( self , ' header _ path ' , ' $ { INCLUDEDIR } / % s - % s ' % ( valatask . pkg_name , _get_api_version ( ) ) ) NEW_LINE valatask . install_binding = getattr ( self , ' install _ binding ' , True ) NEW_LINE self . packages = packages = Utils . to_list ( getattr ( self , ' packages ' , [ ] ) ) NEW_LINE self . vapi_dirs = vapi_dirs = Utils . to_list ( getattr ( self , ' vapi _ dirs ' , [ ] ) ) NEW_LINE includes = [ ] NEW_LINE if hasattr ( self , ' use ' ) : NEW_LINE INDENT local_packages = Utils . to_list ( self . use ) [ : ] NEW_LINE seen = [ ] NEW_LINE while len ( local_packages ) > 0 : NEW_LINE INDENT package = local_packages . pop ( ) NEW_LINE if package in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . append ( package ) NEW_LINE try : NEW_LINE INDENT package_obj = self . bld . get_tgen_by_name ( package ) NEW_LINE DEDENT except Errors . WafError : NEW_LINE INDENT continue NEW_LINE DEDENT package_name = package_obj . target NEW_LINE package_node = package_obj . path NEW_LINE package_dir = package_node . path_from ( self . path ) NEW_LINE for task in package_obj . tasks : NEW_LINE INDENT for output in task . outputs : NEW_LINE INDENT if output . name == package_name + " . vapi " : NEW_LINE INDENT valatask . set_run_after ( task ) NEW_LINE if package_name not in packages : NEW_LINE INDENT packages . append ( package_name ) NEW_LINE DEDENT if package_dir not in vapi_dirs : NEW_LINE INDENT vapi_dirs . append ( package_dir ) NEW_LINE DEDENT if package_dir not in includes : NEW_LINE INDENT includes . append ( package_dir ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if hasattr ( package_obj , ' use ' ) : NEW_LINE INDENT lst = self . to_list ( package_obj . use ) NEW_LINE lst . reverse ( ) NEW_LINE local_packages = [ pkg for pkg in lst if pkg not in seen ] + local_packages NEW_LINE DEDENT DEDENT DEDENT addflags ( [ ' - - pkg = % s ' % p for p in packages ] ) NEW_LINE for vapi_dir in vapi_dirs : NEW_LINE INDENT v_node = self . path . find_dir ( vapi_dir ) NEW_LINE if not v_node : NEW_LINE INDENT Logs . warn ( ' Unable ▁ to ▁ locate ▁ Vala ▁ API ▁ directory : ▁ % r ' % vapi_dir ) NEW_LINE DEDENT else : NEW_LINE INDENT addflags ( ' - - vapidir = % s ' % v_node . abspath ( ) ) NEW_LINE addflags ( ' - - vapidir = % s ' % v_node . get_bld ( ) . abspath ( ) ) NEW_LINE DEDENT DEDENT self . dump_deps_node = None NEW_LINE if self . is_lib and self . packages : NEW_LINE INDENT self . dump_deps_node = self . path . find_or_declare ( ' % s . deps ' % self . target ) NEW_LINE valatask . outputs . append ( self . dump_deps_node ) NEW_LINE DEDENT self . includes . append ( self . bld . srcnode . abspath ( ) ) NEW_LINE self . includes . append ( self . bld . bldnode . abspath ( ) ) NEW_LINE for include in includes : NEW_LINE INDENT try : NEW_LINE INDENT self . includes . append ( self . path . find_dir ( include ) . abspath ( ) ) NEW_LINE self . includes . append ( self . path . find_dir ( include ) . get_bld ( ) . abspath ( ) ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT Logs . warn ( " Unable ▁ to ▁ locate ▁ include ▁ directory : ▁ ' % s ' " % include ) NEW_LINE DEDENT DEDENT if self . is_lib and valatask . install_binding : NEW_LINE INDENT headers_list = [ o for o in valatask . outputs if o . suffix ( ) == " . h " ] NEW_LINE try : NEW_LINE INDENT self . install_vheader . source = headers_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_vheader = self . bld . install_files ( valatask . header_path , headers_list , self . env ) NEW_LINE DEDENT vapi_list = [ o for o in valatask . outputs if ( o . suffix ( ) in ( " . vapi " , " . deps " ) ) ] NEW_LINE try : NEW_LINE INDENT self . install_vapi . source = vapi_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_vapi = self . bld . install_files ( valatask . vapi_path , vapi_list , self . env ) NEW_LINE DEDENT gir_list = [ o for o in valatask . outputs if o . suffix ( ) == ' . gir ' ] NEW_LINE try : NEW_LINE INDENT self . install_gir . source = gir_list NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT self . install_gir = self . bld . install_files ( getattr ( self , ' gir _ path ' , ' $ { DATAROOTDIR } / gir - 1.0' ) , gir_list , self . env ) NEW_LINE DEDENT DEDENT DEDENT @ extension ( ' . vala ' , ' . gs ' ) NEW_LINE def vala_file ( self , node ) : NEW_LINE INDENT try : NEW_LINE INDENT valatask = self . valatask NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT valatask = self . valatask = self . create_task ( ' valac ' ) NEW_LINE self . init_vala_task ( ) NEW_LINE DEDENT valatask . inputs . append ( node ) NEW_LINE c_node = node . change_ext ( ' . c ' ) NEW_LINE valatask . outputs . append ( c_node ) NEW_LINE self . source . append ( c_node ) NEW_LINE DEDENT @ conf NEW_LINE def find_valac ( self , valac_name , min_version ) : NEW_LINE INDENT valac = self . find_program ( valac_name , var = ' VALAC ' ) NEW_LINE try : NEW_LINE INDENT output = self . cmd_and_log ( valac + ' ▁ - - version ' ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT valac_version = None NEW_LINE DEDENT else : NEW_LINE INDENT ver = re . search ( r ' \d + . \d + . \d + ' , output ) . group ( 0 ) . split ( ' . ' ) NEW_LINE valac_version = tuple ( [ int ( x ) for x in ver ] ) NEW_LINE DEDENT self . msg ( ' Checking ▁ for ▁ % s ▁ version ▁ > = ▁ % r ' % ( valac_name , min_version ) , valac_version , valac_version and valac_version >= min_version ) NEW_LINE if valac and valac_version < min_version : NEW_LINE INDENT self . fatal ( " % s ▁ version ▁ % r ▁ is ▁ too ▁ old , ▁ need ▁ > = ▁ % r " % ( valac_name , valac_version , min_version ) ) NEW_LINE DEDENT self . env [ ' VALAC _ VERSION ' ] = valac_version NEW_LINE return valac NEW_LINE DEDENT @ conf NEW_LINE def check_vala ( self , min_version = ( 0 , 8 , 0 ) , branch = None ) : NEW_LINE INDENT if not branch : NEW_LINE INDENT branch = min_version [ : 2 ] NEW_LINE DEDENT try : NEW_LINE INDENT find_valac ( self , ' valac - % d . % d ' % ( branch [ 0 ] , branch [ 1 ] ) , min_version ) NEW_LINE DEDENT except self . errors . ConfigurationError : NEW_LINE INDENT find_valac ( self , ' valac ' , min_version ) NEW_LINE DEDENT DEDENT @ conf NEW_LINE def check_vala_deps ( self ) : NEW_LINE INDENT if not self . env [ ' HAVE _ GOBJECT ' ] : NEW_LINE INDENT pkg_args = { ' package ' : ' gobject - 2.0' , ' uselib _ store ' : ' GOBJECT ' , ' args ' : ' - - cflags ▁ - - libs ' } NEW_LINE if getattr ( Options . options , ' vala _ target _ glib ' , None ) : NEW_LINE INDENT pkg_args [ ' atleast _ version ' ] = Options . options . vala_target_glib NEW_LINE DEDENT self . check_cfg ( ** pkg_args ) NEW_LINE DEDENT if not self . env [ ' HAVE _ GTHREAD ' ] : NEW_LINE INDENT pkg_args = { ' package ' : ' gthread - 2.0' , ' uselib _ store ' : ' GTHREAD ' , ' args ' : ' - - cflags ▁ - - libs ' } NEW_LINE if getattr ( Options . options , ' vala _ target _ glib ' , None ) : NEW_LINE INDENT pkg_args [ ' atleast _ version ' ] = Options . options . vala_target_glib NEW_LINE DEDENT self . check_cfg ( ** pkg_args ) NEW_LINE DEDENT DEDENT def configure ( self ) : NEW_LINE INDENT self . load ( ' gnu _ dirs ' ) NEW_LINE self . check_vala_deps ( ) NEW_LINE self . check_vala ( ) NEW_LINE self . env . VALAFLAGS = [ ' - C ' , ' - - quiet ' ] NEW_LINE DEDENT def options ( opt ) : NEW_LINE INDENT opt . load ( ' gnu _ dirs ' ) NEW_LINE valaopts = opt . add_option_group ( ' Vala ▁ Compiler ▁ Options ' ) NEW_LINE valaopts . add_option ( ' - - vala - target - glib ' , default = None , dest = ' vala _ target _ glib ' , metavar = ' MAJOR . MINOR ' , help = ' Target ▁ version ▁ of ▁ glib ▁ for ▁ Vala ▁ GObject ▁ code ▁ generation ' ) NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="Nirlendu/Dummy-Search-Engine/tree/master/tornado-3.2/build/lib.win32-2.7/tornado/wsgi.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ 2009 ▁ Facebook ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ▁ you ▁ may ENDCOM # ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ▁ You ▁ may ▁ obtain ENDCOM # ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ▁ WITHOUT ENDCOM # ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ▁ See ▁ the ENDCOM # ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ▁ limitations ENDCOM # ▁ under ▁ the ▁ License . ENDCOM """ WSGI ▁ support ▁ for ▁ the ▁ Tornado ▁ web ▁ framework . STRNEWLINE STRNEWLINE WSGI ▁ is ▁ the ▁ Python ▁ standard ▁ for ▁ web ▁ servers , ▁ and ▁ allows ▁ for ▁ interoperability STRNEWLINE between ▁ Tornado ▁ and ▁ other ▁ Python ▁ web ▁ frameworks ▁ and ▁ servers . ▁ This ▁ module STRNEWLINE provides ▁ WSGI ▁ support ▁ in ▁ two ▁ ways : STRNEWLINE STRNEWLINE * ▁ ` WSGIApplication ` ▁ is ▁ a ▁ version ▁ of ▁ ` tornado . web . Application ` ▁ that ▁ can ▁ run STRNEWLINE ▁ inside ▁ a ▁ WSGI ▁ server . ▁ This ▁ is ▁ useful ▁ for ▁ running ▁ a ▁ Tornado ▁ app ▁ on ▁ another STRNEWLINE ▁ HTTP ▁ server , ▁ such ▁ as ▁ Google ▁ App ▁ Engine . ▁ See ▁ the ▁ ` WSGIApplication ` ▁ class STRNEWLINE ▁ documentation ▁ for ▁ limitations ▁ that ▁ apply . STRNEWLINE * ▁ ` WSGIContainer ` ▁ lets ▁ you ▁ run ▁ other ▁ WSGI ▁ applications ▁ and ▁ frameworks ▁ on ▁ the STRNEWLINE ▁ Tornado ▁ HTTP ▁ server . ▁ For ▁ example , ▁ with ▁ this ▁ class ▁ you ▁ can ▁ mix ▁ Django STRNEWLINE ▁ and ▁ Tornado ▁ handlers ▁ in ▁ a ▁ single ▁ server . STRNEWLINE """ NEW_LINE from __future__ import absolute_import , division , print_function , with_statement NEW_LINE import sys NEW_LINE import time NEW_LINE import copy NEW_LINE import tornado NEW_LINE from tornado import escape NEW_LINE from tornado import httputil NEW_LINE from tornado . log import access_log NEW_LINE from tornado import web NEW_LINE from tornado . escape import native_str , parse_qs_bytes NEW_LINE from tornado . util import bytes_type , unicode_type NEW_LINE try : NEW_LINE INDENT from io import BytesIO # ▁ python ▁ 3 ENDCOM NEW_LINE DEDENT except ImportError : NEW_LINE INDENT from cStringIO import StringIO as BytesIO # ▁ python ▁ 2 ENDCOM NEW_LINE DEDENT try : NEW_LINE INDENT import Cookie # ▁ py2 ENDCOM NEW_LINE DEDENT except ImportError : NEW_LINE INDENT import http . cookies as Cookie # ▁ py3 ENDCOM NEW_LINE DEDENT try : NEW_LINE INDENT import urllib . parse as urllib_parse # ▁ py3 ENDCOM NEW_LINE DEDENT except ImportError : NEW_LINE INDENT import urllib as urllib_parse NEW_LINE # ▁ PEP ▁ 3333 ▁ specifies ▁ that ▁ WSGI ▁ on ▁ python ▁ 3 ▁ generally ▁ deals ▁ with ▁ byte ▁ strings ENDCOM # ▁ that ▁ are ▁ smuggled ▁ inside ▁ objects ▁ of ▁ type ▁ unicode ▁ ( via ▁ the ▁ latin1 ▁ encoding ) . ENDCOM # ▁ These ▁ functions ▁ are ▁ like ▁ those ▁ in ▁ the ▁ tornado . escape ▁ module , ▁ but ▁ defined ENDCOM # ▁ here ▁ to ▁ minimize ▁ the ▁ temptation ▁ to ▁ use ▁ them ▁ in ▁ non - wsgi ▁ contexts . ENDCOM DEDENT if str is unicode_type : NEW_LINE INDENT def to_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , bytes_type ) NEW_LINE return s . decode ( ' latin1' ) NEW_LINE DEDENT def from_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , str ) NEW_LINE return s . encode ( ' latin1' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT def to_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , bytes_type ) NEW_LINE return s NEW_LINE DEDENT def from_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , str ) NEW_LINE return s NEW_LINE DEDENT DEDENT class WSGIApplication ( web . Application ) : NEW_LINE INDENT """ A ▁ WSGI ▁ equivalent ▁ of ▁ ` tornado . web . Application ` . STRNEWLINE STRNEWLINE ▁ ` WSGIApplication ` ▁ is ▁ very ▁ similar ▁ to ▁ ` tornado . web . Application ` , STRNEWLINE ▁ except ▁ no ▁ asynchronous ▁ methods ▁ are ▁ supported ▁ ( since ▁ WSGI ▁ does ▁ not STRNEWLINE ▁ support ▁ non - blocking ▁ requests ▁ properly ) . ▁ If ▁ you ▁ call STRNEWLINE ▁ ` ` self . flush ( ) ` ` ▁ or ▁ other ▁ asynchronous ▁ methods ▁ in ▁ your ▁ request STRNEWLINE ▁ handlers ▁ running ▁ in ▁ a ▁ ` WSGIApplication ` , ▁ we ▁ throw ▁ an ▁ exception . STRNEWLINE STRNEWLINE ▁ Example ▁ usage : : STRNEWLINE STRNEWLINE ▁ import ▁ tornado . web STRNEWLINE ▁ import ▁ tornado . wsgi STRNEWLINE ▁ import ▁ wsgiref . simple _ server STRNEWLINE STRNEWLINE ▁ class ▁ MainHandler ( tornado . web . RequestHandler ) : STRNEWLINE ▁ def ▁ get ( self ) : STRNEWLINE ▁ self . write ( " Hello , ▁ world " ) STRNEWLINE STRNEWLINE ▁ if ▁ _ _ name _ _ ▁ = = ▁ " _ _ main _ _ " : STRNEWLINE ▁ application ▁ = ▁ tornado . wsgi . WSGIApplication ( [ STRNEWLINE ▁ ( r " / " , ▁ MainHandler ) , STRNEWLINE ▁ ] ) STRNEWLINE ▁ server ▁ = ▁ wsgiref . simple _ server . make _ server ( ' ' , ▁ 8888 , ▁ application ) STRNEWLINE ▁ server . serve _ forever ( ) STRNEWLINE STRNEWLINE ▁ See ▁ the ▁ ` appengine ▁ demo STRNEWLINE ▁ < https : / / github . com / facebook / tornado / tree / master / demos / appengine > ` _ STRNEWLINE ▁ for ▁ an ▁ example ▁ of ▁ using ▁ this ▁ module ▁ to ▁ run ▁ a ▁ Tornado ▁ app ▁ on ▁ Google STRNEWLINE ▁ App ▁ Engine . STRNEWLINE STRNEWLINE ▁ WSGI ▁ applications ▁ use ▁ the ▁ same ▁ ` . RequestHandler ` ▁ class , ▁ but ▁ not STRNEWLINE ▁ ` ` @ asynchronous ` ` ▁ methods ▁ or ▁ ` ` flush ( ) ` ` . ▁ This ▁ means ▁ that ▁ it ▁ is STRNEWLINE ▁ not ▁ possible ▁ to ▁ use ▁ ` . AsyncHTTPClient ` , ▁ or ▁ the ▁ ` tornado . auth ` ▁ or STRNEWLINE ▁ ` tornado . websocket ` ▁ modules . STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , handlers = None , default_host = " " , ** settings ) : NEW_LINE INDENT web . Application . __init__ ( self , handlers , default_host , transforms = [ ] , wsgi = True , ** settings ) NEW_LINE DEDENT def __call__ ( self , environ , start_response ) : NEW_LINE INDENT handler = web . Application . __call__ ( self , HTTPRequest ( environ ) ) NEW_LINE assert handler . _finished NEW_LINE reason = handler . _reason NEW_LINE status = str ( handler . _status_code ) + " ▁ " + reason NEW_LINE headers = list ( handler . _headers . get_all ( ) ) NEW_LINE if hasattr ( handler , " _ new _ cookie " ) : NEW_LINE INDENT for cookie in handler . _new_cookie . values ( ) : NEW_LINE INDENT headers . append ( ( " Set - Cookie " , cookie . OutputString ( None ) ) ) NEW_LINE DEDENT DEDENT start_response ( status , [ ( native_str ( k ) , native_str ( v ) ) for ( k , v ) in headers ] ) NEW_LINE return handler . _write_buffer NEW_LINE DEDENT DEDENT class HTTPRequest ( object ) : NEW_LINE INDENT """ Mimics ▁ ` tornado . httpserver . HTTPRequest ` ▁ for ▁ WSGI ▁ applications . """ NEW_LINE def __init__ ( self , environ ) : NEW_LINE INDENT """ Parses ▁ the ▁ given ▁ WSGI ▁ environment ▁ to ▁ construct ▁ the ▁ request . """ NEW_LINE self . method = environ [ " REQUEST _ METHOD " ] NEW_LINE self . path = urllib_parse . quote ( from_wsgi_str ( environ . get ( " SCRIPT _ NAME " , " " ) ) ) NEW_LINE self . path += urllib_parse . quote ( from_wsgi_str ( environ . get ( " PATH _ INFO " , " " ) ) ) NEW_LINE self . uri = self . path NEW_LINE self . arguments = { } NEW_LINE self . query_arguments = { } NEW_LINE self . body_arguments = { } NEW_LINE self . query = environ . get ( " QUERY _ STRING " , " " ) NEW_LINE if self . query : NEW_LINE INDENT self . uri += " ? " + self . query NEW_LINE self . arguments = parse_qs_bytes ( native_str ( self . query ) , keep_blank_values = True ) NEW_LINE self . query_arguments = copy . deepcopy ( self . arguments ) NEW_LINE DEDENT self . version = " HTTP / 1.1" NEW_LINE self . headers = httputil . HTTPHeaders ( ) NEW_LINE if environ . get ( " CONTENT _ TYPE " ) : NEW_LINE INDENT self . headers [ " Content - Type " ] = environ [ " CONTENT _ TYPE " ] NEW_LINE DEDENT if environ . get ( " CONTENT _ LENGTH " ) : NEW_LINE INDENT self . headers [ " Content - Length " ] = environ [ " CONTENT _ LENGTH " ] NEW_LINE DEDENT for key in environ : NEW_LINE INDENT if key . startswith ( " HTTP _ " ) : NEW_LINE INDENT self . headers [ key [ 5 : ] . replace ( " _ " , " - " ) ] = environ [ key ] NEW_LINE DEDENT DEDENT if self . headers . get ( " Content - Length " ) : NEW_LINE INDENT self . body = environ [ " wsgi . input " ] . read ( int ( self . headers [ " Content - Length " ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . body = " " NEW_LINE DEDENT self . protocol = environ [ " wsgi . url _ scheme " ] NEW_LINE self . remote_ip = environ . get ( " REMOTE _ ADDR " , " " ) NEW_LINE if environ . get ( " HTTP _ HOST " ) : NEW_LINE INDENT self . host = environ [ " HTTP _ HOST " ] NEW_LINE DEDENT else : NEW_LINE INDENT self . host = environ [ " SERVER _ NAME " ] NEW_LINE # ▁ Parse ▁ request ▁ body ENDCOM DEDENT self . files = { } NEW_LINE httputil . parse_body_arguments ( self . headers . get ( " Content - Type " , " " ) , self . body , self . body_arguments , self . files ) NEW_LINE for k , v in self . body_arguments . items ( ) : NEW_LINE INDENT self . arguments . setdefault ( k , [ ] ) . extend ( v ) NEW_LINE DEDENT self . _start_time = time . time ( ) NEW_LINE self . _finish_time = None NEW_LINE DEDENT def supports_http_1_1 ( self ) : NEW_LINE INDENT """ Returns ▁ True ▁ if ▁ this ▁ request ▁ supports ▁ HTTP / 1.1 ▁ semantics """ NEW_LINE return self . version == " HTTP / 1.1" NEW_LINE DEDENT @ property NEW_LINE def cookies ( self ) : NEW_LINE INDENT """ A ▁ dictionary ▁ of ▁ Cookie . Morsel ▁ objects . """ NEW_LINE if not hasattr ( self , " _ cookies " ) : NEW_LINE INDENT self . _cookies = Cookie . SimpleCookie ( ) NEW_LINE if " Cookie " in self . headers : NEW_LINE INDENT try : NEW_LINE INDENT self . _cookies . load ( native_str ( self . headers [ " Cookie " ] ) ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT self . _cookies = None NEW_LINE DEDENT DEDENT DEDENT return self . _cookies NEW_LINE DEDENT def full_url ( self ) : NEW_LINE INDENT """ Reconstructs ▁ the ▁ full ▁ URL ▁ for ▁ this ▁ request . """ NEW_LINE return self . protocol + " : / / " + self . host + self . uri NEW_LINE DEDENT def request_time ( self ) : NEW_LINE INDENT """ Returns ▁ the ▁ amount ▁ of ▁ time ▁ it ▁ took ▁ for ▁ this ▁ request ▁ to ▁ execute . """ NEW_LINE if self . _finish_time is None : NEW_LINE INDENT return time . time ( ) - self . _start_time NEW_LINE DEDENT else : NEW_LINE INDENT return self . _finish_time - self . _start_time NEW_LINE DEDENT DEDENT DEDENT class WSGIContainer ( object ) : NEW_LINE INDENT r """ Makes ▁ a ▁ WSGI - compatible ▁ function ▁ runnable ▁ on ▁ Tornado ' s ▁ HTTP ▁ server . STRNEWLINE STRNEWLINE ▁ Wrap ▁ a ▁ WSGI ▁ function ▁ in ▁ a ▁ ` WSGIContainer ` ▁ and ▁ pass ▁ it ▁ to ▁ ` . HTTPServer ` ▁ to STRNEWLINE ▁ run ▁ it . ▁ For ▁ example : : STRNEWLINE STRNEWLINE ▁ def ▁ simple _ app ( environ , ▁ start _ response ) : STRNEWLINE ▁ status ▁ = ▁ " 200 ▁ OK " STRNEWLINE ▁ response _ headers ▁ = ▁ [ ( " Content - type " , ▁ " text / plain " ) ] STRNEWLINE ▁ start _ response ( status , ▁ response _ headers ) STRNEWLINE ▁ return ▁ [ " Hello ▁ world ! \n " ] STRNEWLINE STRNEWLINE ▁ container ▁ = ▁ tornado . wsgi . WSGIContainer ( simple _ app ) STRNEWLINE ▁ http _ server ▁ = ▁ tornado . httpserver . HTTPServer ( container ) STRNEWLINE ▁ http _ server . listen ( 8888 ) STRNEWLINE ▁ tornado . ioloop . IOLoop . instance ( ) . start ( ) STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ is ▁ intended ▁ to ▁ let ▁ other ▁ frameworks ▁ ( Django , ▁ web . py , ▁ etc ) STRNEWLINE ▁ run ▁ on ▁ the ▁ Tornado ▁ HTTP ▁ server ▁ and ▁ I / O ▁ loop . STRNEWLINE STRNEWLINE ▁ The ▁ ` tornado . web . FallbackHandler ` ▁ class ▁ is ▁ often ▁ useful ▁ for ▁ mixing STRNEWLINE ▁ Tornado ▁ and ▁ WSGI ▁ apps ▁ in ▁ the ▁ same ▁ server . ▁ See STRNEWLINE ▁ https : / / github . com / bdarnell / django - tornado - demo ▁ for ▁ a ▁ complete ▁ example . STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , wsgi_application ) : NEW_LINE INDENT self . wsgi_application = wsgi_application NEW_LINE DEDENT def __call__ ( self , request ) : NEW_LINE INDENT data = { } NEW_LINE response = [ ] NEW_LINE def start_response ( status , response_headers , exc_info = None ) : NEW_LINE INDENT data [ " status " ] = status NEW_LINE data [ " headers " ] = response_headers NEW_LINE return response . append NEW_LINE DEDENT app_response = self . wsgi_application ( WSGIContainer . environ ( request ) , start_response ) NEW_LINE try : NEW_LINE INDENT response . extend ( app_response ) NEW_LINE body = b " " . join ( response ) NEW_LINE DEDENT finally : NEW_LINE INDENT if hasattr ( app_response , " close " ) : NEW_LINE INDENT app_response . close ( ) NEW_LINE DEDENT DEDENT if not data : NEW_LINE INDENT raise Exception ( " WSGI ▁ app ▁ did ▁ not ▁ call ▁ start _ response " ) NEW_LINE DEDENT status_code = int ( data [ " status " ] . split ( ) [ 0 ] ) NEW_LINE headers = data [ " headers " ] NEW_LINE header_set = set ( k . lower ( ) for ( k , v ) in headers ) NEW_LINE body = escape . utf8 ( body ) NEW_LINE if status_code != 304 : NEW_LINE INDENT if " content - length " not in header_set : NEW_LINE INDENT headers . append ( ( " Content - Length " , str ( len ( body ) ) ) ) NEW_LINE DEDENT if " content - type " not in header_set : NEW_LINE INDENT headers . append ( ( " Content - Type " , " text / html ; ▁ charset = UTF - 8" ) ) NEW_LINE DEDENT DEDENT if " server " not in header_set : NEW_LINE INDENT headers . append ( ( " Server " , " TornadoServer / % s " % tornado . version ) ) NEW_LINE DEDENT parts = [ escape . utf8 ( " HTTP / 1.1 ▁ " + data [ " status " ] + " \n " ) ] NEW_LINE for key , value in headers : NEW_LINE INDENT parts . append ( escape . utf8 ( key ) + b " : ▁ " + escape . utf8 ( value ) + b " \n " ) NEW_LINE DEDENT parts . append ( b " \n " ) NEW_LINE parts . append ( body ) NEW_LINE request . write ( b " " . join ( parts ) ) NEW_LINE request . finish ( ) NEW_LINE self . _log ( status_code , request ) NEW_LINE DEDENT @ staticmethod NEW_LINE def environ ( request ) : NEW_LINE INDENT """ Converts ▁ a ▁ ` tornado . httpserver . HTTPRequest ` ▁ to ▁ a ▁ WSGI ▁ environment . STRNEWLINE ▁ """ NEW_LINE hostport = request . host . split ( " : " ) NEW_LINE if len ( hostport ) == 2 : NEW_LINE INDENT host = hostport [ 0 ] NEW_LINE port = int ( hostport [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT host = request . host NEW_LINE port = 443 if request . protocol == " https " else 80 NEW_LINE DEDENT environ = { " REQUEST _ METHOD " : request . method , " SCRIPT _ NAME " : " " , " PATH _ INFO " : to_wsgi_str ( escape . url_unescape ( request . path , encoding = None , plus = False ) ) , " QUERY _ STRING " : request . query , " REMOTE _ ADDR " : request . remote_ip , " SERVER _ NAME " : host , " SERVER _ PORT " : str ( port ) , " SERVER _ PROTOCOL " : request . version , " wsgi . version " : ( 1 , 0 ) , " wsgi . url _ scheme " : request . protocol , " wsgi . input " : BytesIO ( escape . utf8 ( request . body ) ) , " wsgi . errors " : sys . stderr , " wsgi . multithread " : False , " wsgi . multiprocess " : True , " wsgi . run _ once " : False , } NEW_LINE if " Content - Type " in request . headers : NEW_LINE INDENT environ [ " CONTENT _ TYPE " ] = request . headers . pop ( " Content - Type " ) NEW_LINE DEDENT if " Content - Length " in request . headers : NEW_LINE INDENT environ [ " CONTENT _ LENGTH " ] = request . headers . pop ( " Content - Length " ) NEW_LINE DEDENT for key , value in request . headers . items ( ) : NEW_LINE INDENT environ [ " HTTP _ " + key . replace ( " - " , " _ " ) . upper ( ) ] = value NEW_LINE DEDENT return environ NEW_LINE DEDENT def _log ( self , status_code , request ) : NEW_LINE INDENT if status_code < 400 : NEW_LINE INDENT log_method = access_log . info NEW_LINE DEDENT elif status_code < 500 : NEW_LINE INDENT log_method = access_log . warning NEW_LINE DEDENT else : NEW_LINE INDENT log_method = access_log . error NEW_LINE DEDENT request_time = 1000.0 * request . request_time ( ) NEW_LINE summary = request . method + " ▁ " + request . uri + " ▁ ( " + request . remote_ip + " ) " NEW_LINE log_method ( " % d ▁ % s ▁ % .2fms " , status_code , summary , request_time ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="Affix/CouchPotatoServer/tree/master/couchpotato/core/media/_base/providers/torrent/sceneaccess.py"> import traceback NEW_LINE from bs4 import BeautifulSoup NEW_LINE from couchpotato . core . helpers . encoding import toUnicode NEW_LINE from couchpotato . core . helpers . variable import tryInt NEW_LINE from couchpotato . core . logger import CPLog NEW_LINE from couchpotato . core . media . _base . providers . torrent . base import TorrentProvider NEW_LINE log = CPLog ( __name__ ) NEW_LINE class Base ( TorrentProvider ) : NEW_LINE INDENT urls = { ' test ' : ' https : / / www . sceneaccess . eu / ' , ' login ' : ' https : / / www . sceneaccess . eu / login ' , ' login _ check ' : ' https : / / www . sceneaccess . eu / inbox ' , ' detail ' : ' https : / / www . sceneaccess . eu / details ? id = % s ' , ' search ' : ' https : / / www . sceneaccess . eu / browse ? c % d = % d ' , ' archive ' : ' https : / / www . sceneaccess . eu / archive ? & c % d = % d ' , ' download ' : ' https : / / www . sceneaccess . eu / % s ' , } NEW_LINE http_time_between_calls = 1 # ▁ Seconds ENDCOM NEW_LINE def _searchOnTitle ( self , title , media , quality , results ) : NEW_LINE INDENT url = self . buildUrl ( title , media , quality ) NEW_LINE data = self . getHTMLData ( url ) NEW_LINE if data : NEW_LINE INDENT html = BeautifulSoup ( data ) NEW_LINE try : NEW_LINE INDENT resultsTable = html . find ( ' table ' , attrs = { ' id ' : ' torrents - table ' } ) NEW_LINE if resultsTable is None : NEW_LINE INDENT return NEW_LINE DEDENT entries = resultsTable . find_all ( ' tr ' , attrs = { ' class ' : ' tt _ row ' } ) NEW_LINE for result in entries : NEW_LINE INDENT link = result . find ( ' td ' , attrs = { ' class ' : ' ttr _ name ' } ) . find ( ' a ' ) NEW_LINE url = result . find ( ' td ' , attrs = { ' class ' : ' td _ dl ' } ) . find ( ' a ' ) NEW_LINE leechers = result . find ( ' td ' , attrs = { ' class ' : ' ttr _ leechers ' } ) . find ( ' a ' ) NEW_LINE torrent_id = link [ ' href ' ] . replace ( ' details ? id = ' , ' ' ) NEW_LINE results . append ( { ' id ' : torrent_id , ' name ' : link [ ' title ' ] , ' url ' : self . urls [ ' download ' ] % url [ ' href ' ] , ' detail _ url ' : self . urls [ ' detail ' ] % torrent_id , ' size ' : self . parseSize ( result . find ( ' td ' , attrs = { ' class ' : ' ttr _ size ' } ) . contents [ 0 ] ) , ' seeders ' : tryInt ( result . find ( ' td ' , attrs = { ' class ' : ' ttr _ seeders ' } ) . find ( ' a ' ) . string ) , ' leechers ' : tryInt ( leechers . string ) if leechers else 0 , ' get _ more _ info ' : self . getMoreInfo , } ) NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT log . error ( ' Failed ▁ getting ▁ results ▁ from ▁ % s : ▁ % s ' , ( self . getName ( ) , traceback . format_exc ( ) ) ) NEW_LINE DEDENT DEDENT DEDENT def getMoreInfo ( self , item ) : NEW_LINE INDENT full_description = self . getCache ( ' sceneaccess . % s ' % item [ ' id ' ] , item [ ' detail _ url ' ] , cache_timeout = 25920000 ) NEW_LINE html = BeautifulSoup ( full_description ) NEW_LINE nfo_pre = html . find ( ' div ' , attrs = { ' id ' : ' details _ table ' } ) NEW_LINE description = toUnicode ( nfo_pre . text ) if nfo_pre else ' ' NEW_LINE item [ ' description ' ] = description NEW_LINE return item NEW_LINE # ▁ Login ENDCOM DEDENT def getLoginParams ( self ) : NEW_LINE INDENT return { ' username ' : self . conf ( ' username ' ) , ' password ' : self . conf ( ' password ' ) , ' submit ' : ' come ▁ on ▁ in ' , } NEW_LINE DEDENT def loginSuccess ( self , output ) : NEW_LINE INDENT return ' / inbox ' in output . lower ( ) NEW_LINE DEDENT loginCheckSuccess = loginSuccess NEW_LINE DEDENT config = [ { ' name ' : ' sceneaccess ' , ' groups ' : [ { ' tab ' : ' searcher ' , ' list ' : ' torrent _ providers ' , ' name ' : ' SceneAccess ' , ' description ' : ' < a ▁ href = " https : / / sceneaccess . eu / " > SceneAccess < / a > ' , ' wizard ' : True , ' icon ' : ' iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAABnRSTlMAAAAAAABupgeRAAACT0lEQVR4AYVQS0sbURidO3OTmajJ5FElTTOkPmZ01GhHrIq0aoWAj1Vc + A / cuRMXbl24V9SlCGqrLhVFCrooEhCp2BAx0mobTY2kaR7qmOm87EXL1EWxh29xL + c7nPMdgGHYO5bF / gdbefnr6WlbWRnxluMwAB4Z0uEgXa7nwaDL7 + / RNPzxbYvb / XJ0FBYVfd / ayh0fQ4qCGEHcm0KLRZUk7Pb2YRJPRwcsKMidnKD3t9VVT3s7BDh + z5FOZ3Vfn3h + Hltfx00mRRSRWFcUmmVNhYVqPn8dj3va2oh + txvcQRVF9ebm1fi4k + dRFbosY5rm4Hk7xxULQnJnx93S4g0EIEEQRoDLo6PrWEw8Pc0eHLwYGopMTDirqlJ7eyhYYGHhfgfHCcKYksZGVB / NcXI2mw6HhZERqrjYTNPHi4tFPh8aJIYIhgPlcCRDoZLW1s75 + Z / 7 + 59nZ / OJhLWigqAoKZX6Mjf3dXkZ3pydGYLc4aEoCCkInzQ1fRobS2xuvllaonkedfArnY5OTdGVldBkOADgqq2Nr6z8CIWaJietDHOhKB + HhwFKC6Gnq4ukKJvP9zcSbjYDXbeVlkKzuZBhnnV3e3t6UOmaJO0ODibW1hB1GYkg8R / gup7Z3TVZLJ5AILW9LcZiVpYtYBhw16O3t7cauckyeF9Tgz0ATpL2 + nopmWycmbnY2LiKRjFk6 / d7 + / vRJfl4HGzV1T0UIM43MGBvaIBWK / YvwM5w + IMgGH8tkyEgvIpE7M3Nt6qqZrNyOq1kMmouh455Ggz + BhKY4GEc2CfwAAAAAElFTkSuQmCC ' , ' options ' : [ { ' name ' : ' enabled ' , ' type ' : ' enabler ' , ' default ' : False , } , { ' name ' : ' username ' , ' default ' : ' ' , } , { ' name ' : ' password ' , ' default ' : ' ' , ' type ' : ' password ' , } , { ' name ' : ' seed _ ratio ' , ' label ' : ' Seed ▁ ratio ' , ' type ' : ' float ' , ' default ' : 1 , ' description ' : ' Will ▁ not ▁ be ▁ ( re ) moved ▁ until ▁ this ▁ seed ▁ ratio ▁ is ▁ met . ' , } , { ' name ' : ' seed _ time ' , ' label ' : ' Seed ▁ time ' , ' type ' : ' int ' , ' default ' : 40 , ' description ' : ' Will ▁ not ▁ be ▁ ( re ) moved ▁ until ▁ this ▁ seed ▁ time ▁ ( in ▁ hours ) ▁ is ▁ met . ' , } , { ' name ' : ' extra _ score ' , ' advanced ' : True , ' label ' : ' Extra ▁ Score ' , ' type ' : ' int ' , ' default ' : 20 , ' description ' : ' Starting ▁ score ▁ for ▁ each ▁ release ▁ found ▁ via ▁ this ▁ provider . ' , } ] , } , ] , } ] NEW_LINE </DOCUMENT>
