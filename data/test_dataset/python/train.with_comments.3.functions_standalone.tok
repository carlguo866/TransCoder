def pca_arrests ( ) : NEW_LINE INDENT print ( " Importing ▁ USArrests . csv ▁ data . . . " ) NEW_LINE arrestsH2O = h2o . upload_file ( pyunit_utils . locate ( " smalldata / pca _ test / USArrests . csv " ) ) NEW_LINE print ( " Testing ▁ to ▁ see ▁ whether ▁ the ▁ trained ▁ PCA ▁ are ▁ essentially ▁ the ▁ same ▁ using ▁ different ▁ implementation . . . " ) NEW_LINE eigenvector_standard = None NEW_LINE for impl in [ " MTJ _ EVD _ DENSEMATRIX " , " MTJ _ EVD _ SYMMMATRIX " , " MTJ _ SVD _ DENSEMATRIX " , " JAMA " ] : NEW_LINE INDENT print ( " Run ▁ PCA ▁ with ▁ implementation : ▁ " + impl ) NEW_LINE model = H2OPCA ( k = 4 , pca_impl = impl , seed = 1234 ) NEW_LINE model . train ( x = list ( range ( 4 ) ) , training_frame = arrestsH2O ) NEW_LINE eigenvectors = model . _model_json [ " output " ] [ " eigenvectors " ] NEW_LINE if eigenvector_standard is not None : NEW_LINE # ▁ Compare ▁ to ▁ see ▁ if ▁ they ▁ are ▁ fundamentally ▁ the ▁ same ENDCOM INDENT pyunit_utils . assert_H2OTwoDimTable_equal ( eigenvector_standard , eigenvectors , model . _model_json [ " output " ] [ " names " ] , tolerance = 1e-6 , check_sign = True , check_all = False ) NEW_LINE DEDENT else : NEW_LINE INDENT eigenvector_standard = eigenvectors NEW_LINE DEDENT DEDENT DEDENT
def block_db_access ( ) : NEW_LINE INDENT class NoDB ( object ) : NEW_LINE INDENT def __getattr__ ( self , attr ) : NEW_LINE INDENT return self NEW_LINE DEDENT def __call__ ( self , * args , ** kwargs ) : NEW_LINE INDENT stacktrace = " " . join ( traceback . format_stack ( ) ) NEW_LINE LOG = logging . getLogger ( ' nova . network ' ) NEW_LINE LOG . error ( _ ( ' No ▁ db ▁ access ▁ allowed ▁ in ▁ nova - network : ▁ % s ' ) , stacktrace ) NEW_LINE raise exception . DBNotAllowed ( ' nova - network ' ) NEW_LINE DEDENT DEDENT nova . db . api . IMPL = NoDB ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT config . parse_args ( sys . argv ) NEW_LINE logging . setup ( " nova " ) NEW_LINE utils . monkey_patch ( ) NEW_LINE objects . register_all ( ) NEW_LINE gmr . TextGuruMeditation . setup_autorun ( version ) NEW_LINE if not CONF . conductor . use_local : NEW_LINE INDENT block_db_access ( ) NEW_LINE objects_base . NovaObject . indirection_api = conductor_rpcapi . ConductorAPI ( ) NEW_LINE DEDENT server = service . Service . create ( binary = ' nova - network ' , topic = CONF . network_topic , db_allowed = CONF . conductor . use_local ) NEW_LINE service . serve ( server ) NEW_LINE service . wait ( ) NEW_LINE DEDENT
def my_func ( p1 = 1 ) -> object : NEW_LINE INDENT return p1 NEW_LINE DEDENT
def test_read_inventory_v1 ( ) : NEW_LINE INDENT f = BytesIO ( inventory_v1 ) NEW_LINE f . readline ( ) NEW_LINE invdata = read_inventory_v1 ( f , ' / util ' , posixpath . join ) NEW_LINE assert invdata [ ' py : module ' ] [ ' module ' ] == ( ' foo ' , '1.0' , ' / util / foo . html # module - module ' , ' - ' ) NEW_LINE assert invdata [ ' py : class ' ] [ ' module . cls ' ] == ( ' foo ' , '1.0' , ' / util / foo . html # module . cls ' , ' - ' ) NEW_LINE DEDENT
def test_read_inventory_v2 ( ) : NEW_LINE INDENT f = BytesIO ( inventory_v2 ) NEW_LINE f . readline ( ) NEW_LINE invdata1 = read_inventory_v2 ( f , ' / util ' , posixpath . join ) NEW_LINE # ▁ try ▁ again ▁ with ▁ a ▁ small ▁ buffer ▁ size ▁ to ▁ test ▁ the ▁ chunking ▁ algorithm ENDCOM f = BytesIO ( inventory_v2 ) NEW_LINE f . readline ( ) NEW_LINE invdata2 = read_inventory_v2 ( f , ' / util ' , posixpath . join , bufsize = 5 ) NEW_LINE assert invdata1 == invdata2 NEW_LINE assert len ( invdata1 [ ' py : module ' ] ) == 2 NEW_LINE assert invdata1 [ ' py : module ' ] [ ' module1' ] == ( ' foo ' , '2.0' , ' / util / foo . html # module - module1' , ' Long ▁ Module ▁ desc ' ) NEW_LINE assert invdata1 [ ' py : module ' ] [ ' module2' ] == ( ' foo ' , '2.0' , ' / util / foo . html # module - module2' , ' - ' ) NEW_LINE assert invdata1 [ ' py : function ' ] [ ' module1 . func ' ] [ 2 ] == ' / util / sub / foo . html # module1 . func ' NEW_LINE assert invdata1 [ ' c : function ' ] [ ' CFunc ' ] [ 2 ] == ' / util / cfunc . html # CFunc ' NEW_LINE assert invdata1 [ ' std : term ' ] [ ' a ▁ term ' ] [ 2 ] == ' / util / glossary . html # term - a - term ' NEW_LINE DEDENT
def test_missing_reference ( tempdir , app ) : NEW_LINE INDENT inv_file = tempdir / ' inventory ' NEW_LINE write_file ( inv_file , inventory_v2 ) NEW_LINE app . config . intersphinx_mapping = { ' http : / / docs . python . org / ' : inv_file , ' py3k ' : ( ' http : / / docs . python . org / py3k / ' , inv_file ) , } NEW_LINE app . config . intersphinx_cache_limit = 0 NEW_LINE # ▁ load ▁ the ▁ inventory ▁ and ▁ check ▁ if ▁ it ' s ▁ done ▁ correctly ENDCOM load_mappings ( app ) NEW_LINE inv = app . env . intersphinx_inventory NEW_LINE assert inv [ ' py : module ' ] [ ' module2' ] == ( ' foo ' , '2.0' , ' http : / / docs . python . org / foo . html # module - module2' , ' - ' ) NEW_LINE # ▁ create ▁ fake ▁ nodes ▁ and ▁ check ▁ referencing ENDCOM def fake_node ( domain , type , target , content , ** attrs ) : NEW_LINE INDENT contnode = nodes . emphasis ( content , content ) NEW_LINE node = addnodes . pending_xref ( ' ' ) NEW_LINE node [ ' reftarget ' ] = target NEW_LINE node [ ' reftype ' ] = type NEW_LINE node [ ' refdomain ' ] = domain NEW_LINE node . attributes . update ( attrs ) NEW_LINE node += contnode NEW_LINE return node , contnode NEW_LINE DEDENT def reference_check ( * args , ** kwds ) : NEW_LINE INDENT node , contnode = fake_node ( * args , ** kwds ) NEW_LINE return missing_reference ( app , app . env , node , contnode ) NEW_LINE # ▁ check ▁ resolution ▁ when ▁ a ▁ target ▁ is ▁ found ENDCOM DEDENT rn = reference_check ( ' py ' , ' func ' , ' module1 . func ' , ' foo ' ) NEW_LINE assert isinstance ( rn , nodes . reference ) NEW_LINE assert rn [ ' refuri ' ] == ' http : / / docs . python . org / sub / foo . html # module1 . func ' NEW_LINE assert rn [ ' reftitle ' ] == ' ( in ▁ foo ▁ v2.0 ) ' NEW_LINE assert rn [ 0 ] . astext ( ) == ' foo ' NEW_LINE # ▁ create ▁ unresolvable ▁ nodes ▁ and ▁ check ▁ None ▁ return ▁ value ENDCOM assert reference_check ( ' py ' , ' foo ' , ' module1 . func ' , ' foo ' ) is None NEW_LINE assert reference_check ( ' py ' , ' func ' , ' foo ' , ' foo ' ) is None NEW_LINE assert reference_check ( ' py ' , ' func ' , ' foo ' , ' foo ' ) is None NEW_LINE # ▁ check ▁ handling ▁ of ▁ prefixes ENDCOM # ▁ prefix ▁ given , ▁ target ▁ found : ▁ prefix ▁ is ▁ stripped ENDCOM rn = reference_check ( ' py ' , ' mod ' , ' py3k : module2' , ' py3k : module2' ) NEW_LINE assert rn [ 0 ] . astext ( ) == ' module2' NEW_LINE # ▁ prefix ▁ given , ▁ but ▁ not ▁ in ▁ title : ▁ nothing ▁ stripped ENDCOM rn = reference_check ( ' py ' , ' mod ' , ' py3k : module2' , ' module2' ) NEW_LINE assert rn [ 0 ] . astext ( ) == ' module2' NEW_LINE # ▁ prefix ▁ given , ▁ but ▁ explicit : ▁ nothing ▁ stripped ENDCOM rn = reference_check ( ' py ' , ' mod ' , ' py3k : module2' , ' py3k : module2' , refexplicit = True ) NEW_LINE assert rn [ 0 ] . astext ( ) == ' py3k : module2' NEW_LINE # ▁ prefix ▁ given , ▁ target ▁ not ▁ found ▁ and ▁ nonexplicit ▁ title : ▁ prefix ▁ is ▁ stripped ENDCOM node , contnode = fake_node ( ' py ' , ' mod ' , ' py3k : unknown ' , ' py3k : unknown ' , refexplicit = False ) NEW_LINE rn = missing_reference ( app , app . env , node , contnode ) NEW_LINE assert rn is None NEW_LINE assert contnode [ 0 ] . astext ( ) == ' unknown ' NEW_LINE # ▁ prefix ▁ given , ▁ target ▁ not ▁ found ▁ and ▁ explicit ▁ title : ▁ nothing ▁ is ▁ changed ENDCOM node , contnode = fake_node ( ' py ' , ' mod ' , ' py3k : unknown ' , ' py3k : unknown ' , refexplicit = True ) NEW_LINE rn = missing_reference ( app , app . env , node , contnode ) NEW_LINE assert rn is None NEW_LINE assert contnode [ 0 ] . astext ( ) == ' py3k : unknown ' NEW_LINE DEDENT
def test_load_mappings_warnings ( tempdir , app ) : NEW_LINE INDENT """ STRNEWLINE ▁ load _ mappings ▁ issues ▁ a ▁ warning ▁ if ▁ new - style ▁ mapping STRNEWLINE ▁ identifiers ▁ are ▁ not ▁ alphanumeric STRNEWLINE ▁ """ NEW_LINE inv_file = tempdir / ' inventory ' NEW_LINE write_file ( inv_file , inventory_v2 ) NEW_LINE app . config . intersphinx_mapping = { ' http : / / docs . python . org / ' : inv_file , ' py3k ' : ( ' http : / / docs . python . org / py3k / ' , inv_file ) , ' repoze . workflow ' : ( ' http : / / docs . repoze . org / workflow / ' , inv_file ) , ' django - taggit ' : ( ' http : / / django - taggit . readthedocs . org / en / latest / ' , inv_file ) } NEW_LINE app . config . intersphinx_cache_limit = 0 NEW_LINE # ▁ load ▁ the ▁ inventory ▁ and ▁ check ▁ if ▁ it ' s ▁ done ▁ correctly ENDCOM load_mappings ( app ) NEW_LINE assert len ( app . _warning . content ) == 2 NEW_LINE DEDENT
def delete_selected ( modeladmin , request , queryset ) : NEW_LINE INDENT """ STRNEWLINE ▁ Default ▁ action ▁ which ▁ deletes ▁ the ▁ selected ▁ objects . STRNEWLINE STRNEWLINE ▁ This ▁ action ▁ first ▁ displays ▁ a ▁ confirmation ▁ page ▁ whichs ▁ shows ▁ all ▁ the STRNEWLINE ▁ deleteable ▁ objects , ▁ or , ▁ if ▁ the ▁ user ▁ has ▁ no ▁ permission ▁ one ▁ of ▁ the ▁ related STRNEWLINE ▁ childs ▁ ( foreignkeys ) , ▁ a ▁ " permission ▁ denied " ▁ message . STRNEWLINE STRNEWLINE ▁ Next , ▁ it ▁ deletes ▁ all ▁ selected ▁ objects ▁ and ▁ redirects ▁ back ▁ to ▁ the ▁ change ▁ list . STRNEWLINE ▁ """ NEW_LINE opts = modeladmin . model . _meta NEW_LINE app_label = opts . app_label NEW_LINE # ▁ Check ▁ that ▁ the ▁ user ▁ has ▁ delete ▁ permission ▁ for ▁ the ▁ actual ▁ model ENDCOM if not modeladmin . has_delete_permission ( request ) : NEW_LINE INDENT raise PermissionDenied NEW_LINE DEDENT using = router . db_for_write ( modeladmin . model ) NEW_LINE # ▁ Populate ▁ deletable _ objects , ▁ a ▁ data ▁ structure ▁ of ▁ all ▁ related ▁ objects ▁ that ENDCOM # ▁ will ▁ also ▁ be ▁ deleted . ENDCOM deletable_objects , model_count , perms_needed , protected = get_deleted_objects ( queryset , opts , request . user , modeladmin . admin_site , using ) NEW_LINE # ▁ The ▁ user ▁ has ▁ already ▁ confirmed ▁ the ▁ deletion . ENDCOM # ▁ Do ▁ the ▁ deletion ▁ and ▁ return ▁ a ▁ None ▁ to ▁ display ▁ the ▁ change ▁ list ▁ view ▁ again . ENDCOM if request . POST . get ( ' post ' ) : NEW_LINE INDENT if perms_needed : NEW_LINE INDENT raise PermissionDenied NEW_LINE DEDENT n = queryset . count ( ) NEW_LINE if n : NEW_LINE INDENT for obj in queryset : NEW_LINE INDENT obj_display = force_text ( obj ) NEW_LINE modeladmin . log_deletion ( request , obj , obj_display ) NEW_LINE DEDENT queryset . delete ( ) NEW_LINE modeladmin . message_user ( request , _ ( " Successfully ▁ deleted ▁ % ( count ) d ▁ % ( items ) s . " ) % { " count " : n , " items " : model_ngettext ( modeladmin . opts , n ) } , messages . SUCCESS ) NEW_LINE # ▁ Return ▁ None ▁ to ▁ display ▁ the ▁ change ▁ list ▁ page ▁ again . ENDCOM DEDENT return None NEW_LINE DEDENT if len ( queryset ) == 1 : NEW_LINE INDENT objects_name = force_text ( opts . verbose_name ) NEW_LINE DEDENT else : NEW_LINE INDENT objects_name = force_text ( opts . verbose_name_plural ) NEW_LINE DEDENT if perms_needed or protected : NEW_LINE INDENT title = _ ( " Cannot ▁ delete ▁ % ( name ) s " ) % { " name " : objects_name } NEW_LINE DEDENT else : NEW_LINE INDENT title = _ ( " Are ▁ you ▁ sure ? " ) NEW_LINE DEDENT context = dict ( modeladmin . admin_site . each_context ( request ) , title = title , objects_name = objects_name , deletable_objects = [ deletable_objects ] , model_count = dict ( model_count ) . items ( ) , queryset = queryset , perms_lacking = perms_needed , protected = protected , opts = opts , action_checkbox_name = helpers . ACTION_CHECKBOX_NAME , ) NEW_LINE request . current_app = modeladmin . admin_site . name NEW_LINE # ▁ Display ▁ the ▁ confirmation ▁ page ENDCOM return TemplateResponse ( request , modeladmin . delete_selected_confirmation_template or [ " admin / % s / % s / delete _ selected _ confirmation . html " % ( app_label , opts . model_name ) , " admin / % s / delete _ selected _ confirmation . html " % app_label , " admin / delete _ selected _ confirmation . html " ] , context ) NEW_LINE DEDENT
def _numdiff_2d ( func , x , y , dx = 0 , dy = 0 , eps = 1e-8 ) : NEW_LINE INDENT if dx == 0 and dy == 0 : NEW_LINE INDENT return func ( x , y ) NEW_LINE DEDENT elif dx == 1 and dy == 0 : NEW_LINE INDENT return ( func ( x + eps , y ) - func ( x - eps , y ) ) / ( 2 * eps ) NEW_LINE DEDENT elif dx == 0 and dy == 1 : NEW_LINE INDENT return ( func ( x , y + eps ) - func ( x , y - eps ) ) / ( 2 * eps ) NEW_LINE DEDENT elif dx == 1 and dy == 1 : NEW_LINE INDENT return ( func ( x + eps , y + eps ) - func ( x - eps , y + eps ) - func ( x + eps , y - eps ) + func ( x - eps , y - eps ) ) / ( 2 * eps ) ** 2 NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " invalid ▁ derivative ▁ order " ) NEW_LINE DEDENT DEDENT
def jsescape ( string ) : NEW_LINE INDENT """ ▁ escaping ▁ so ▁ that ▁ javascript ▁ can ▁ be ▁ safely ▁ put ▁ into ▁ json ▁ dicts STRNEWLINE ▁ for ▁ some ▁ reason ▁ json ▁ newline ▁ escaping ▁ isn ' t ▁ enough ? ? STRNEWLINE ▁ """ NEW_LINE return string . replace ( ' < script ' , ' $ BEGINSCRIPT ' ) . replace ( ' < / script > ' , ' $ ENDSCRIPT ' ) . replace ( ' \n ' , ' $ NEWLINE ' ) . replace ( ' ' , ' ' ) NEW_LINE DEDENT
def write_capture ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture ▁ [ filter ] ▁ [ " prototype " ] ▁ [ " widget _ id " ] ▁ % } STRNEWLINE ▁ < script ▁ src = " evil . js " > STRNEWLINE ▁ document . write ( ' this ▁ is ▁ evil ' ) STRNEWLINE ▁ < script > STRNEWLINE ▁ { % ▁ endwritecapture ▁ % } STRNEWLINE STRNEWLINE ▁ Wraps ▁ the ▁ enclosed ▁ HTML ▁ inside ▁ of ▁ a ▁ marimo ▁ writecapture ▁ widget . STRNEWLINE STRNEWLINE ▁ The ▁ ` ` filter ` ` ▁ argument ▁ is ▁ a ▁ boolean ▁ ( default ▁ False ) ▁ that ▁ turns ▁ on ▁ a STRNEWLINE ▁ writecapture ▁ feature ▁ called ▁ writeOnGetElementById . ▁ This ▁ fixes ▁ some STRNEWLINE ▁ extra - bad ▁ scripts . STRNEWLINE STRNEWLINE ▁ The ▁ ` ` prototype ` ` ▁ argument ▁ defaults ▁ to ▁ ' writecapture . ' ▁ You ▁ will ▁ only STRNEWLINE ▁ need ▁ to ▁ use ▁ this ▁ if ▁ you ▁ have ▁ subclassed ▁ marimo ' s ▁ built - in ▁ writecapture STRNEWLINE ▁ widget ▁ and ▁ want ▁ to ▁ use ▁ that ▁ instead . STRNEWLINE STRNEWLINE ▁ The ▁ ` ` widget _ id ` ` ▁ argument ▁ defaults ▁ to ▁ a ▁ ' writecapture _ < randomnumber > . ' STRNEWLINE ▁ Use ▁ this ▁ only ▁ if ▁ you ▁ need ▁ to ▁ specify ▁ an ▁ alternate ▁ element ▁ id ▁ in ▁ the ▁ DOM STRNEWLINE ▁ to ▁ write ▁ to ▁ ( otherwise ▁ one ▁ will ▁ be ▁ created ▁ for ▁ you ▁ at ▁ the ▁ site ▁ of ▁ the STRNEWLINE ▁ { % writecapture % } ▁ invocation ) . . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE # ▁ TODO ▁ should ▁ work ▁ with ▁ marimo ▁ fast ▁ and ▁ widget _ id ▁ should ▁ be ▁ resolved ▁ maybe ENDCOM tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 4 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture ▁ block ▁ takes ▁ at ▁ most ▁ 3 ▁ arguments " ) NEW_LINE DEDENT nodelist = parser . parse ( ( ' endwritecapture ' , ) ) NEW_LINE parser . delete_first_token ( ) NEW_LINE if len ( tokens ) > 1 : NEW_LINE INDENT script_filter = tokens [ 1 ] NEW_LINE if script_filter == ' False ' : NEW_LINE INDENT script_filter = False NEW_LINE DEDENT elif script_filter == ' True ' : NEW_LINE INDENT script_filter = True NEW_LINE DEDENT else : NEW_LINE INDENT script_filter = template . Variable ( script_filter ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT script_filter = False NEW_LINE DEDENT return WriteCaptureNode ( nodelist , script_filter , * tokens [ 2 : ] ) NEW_LINE DEDENT
def write_capture_delay ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture _ delay ▁ [ event _ name ] ▁ % } STRNEWLINE ▁ """ NEW_LINE tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 2 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture _ delay ▁ takes ▁ at ▁ most ▁ 1 ▁ argument " ) NEW_LINE DEDENT if len ( tokens ) == 2 : NEW_LINE INDENT return WriteCaptureDelayNode ( tokens [ 1 ] ) NEW_LINE DEDENT return WriteCaptureDelayNode ( ) NEW_LINE DEDENT
def write_capture_delay ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture _ delay ▁ [ event _ name ] ▁ % } STRNEWLINE ▁ """ NEW_LINE tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 2 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture _ delay ▁ takes ▁ at ▁ most ▁ 1 ▁ argument " ) NEW_LINE DEDENT if len ( tokens ) == 2 : NEW_LINE INDENT return WriteCaptureDelayNode ( tokens [ 1 ] ) NEW_LINE DEDENT return WriteCaptureDelayNode ( ) NEW_LINE DEDENT
def write_capture_delay ( parser , token ) : NEW_LINE INDENT """ STRNEWLINE ▁ Syntax : : STRNEWLINE ▁ { % ▁ writecapture _ delay ▁ [ event _ name ] ▁ % } STRNEWLINE ▁ """ NEW_LINE tokens = token . split_contents ( ) NEW_LINE if len ( tokens ) > 2 : NEW_LINE INDENT raise template . TemplateSyntaxError ( " writecapture _ delay ▁ takes ▁ at ▁ most ▁ 1 ▁ argument " ) NEW_LINE DEDENT if len ( tokens ) == 2 : NEW_LINE INDENT return WriteCaptureDelayNode ( tokens [ 1 ] ) NEW_LINE DEDENT return WriteCaptureDelayNode ( ) NEW_LINE DEDENT
