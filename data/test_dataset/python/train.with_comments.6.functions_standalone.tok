def generate ( bits ) : NEW_LINE INDENT key = PyCrypto_RSAKey ( ) NEW_LINE def f ( numBytes ) : NEW_LINE INDENT return bytesToString ( getRandomBytes ( numBytes ) ) NEW_LINE DEDENT key . rsa = RSA . generate ( bits , f ) NEW_LINE return key NEW_LINE DEDENT
def client ( ) : NEW_LINE INDENT return betfair . Betfair ( app_key = ' test ' , cert_file = ' path / to / cert ' ) NEW_LINE DEDENT
def logged_in_client ( client ) : NEW_LINE INDENT client = betfair . Betfair ( app_key = ' test ' , cert_file = ' path / to / cert ' ) NEW_LINE client . session_token = ' secret ' NEW_LINE return client NEW_LINE DEDENT
def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Hashable : NEW_LINE INDENT for B in C . __mro__ : NEW_LINE INDENT if " _ _ hash _ _ " in B . __dict__ : NEW_LINE INDENT if B . __dict__ [ " _ _ hash _ _ " ] : NEW_LINE INDENT return True NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT return NotImplemented NEW_LINE DEDENT
def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Iterable : NEW_LINE INDENT if any ( " _ _ iter _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT
def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Iterator : NEW_LINE INDENT if ( any ( " _ _ next _ _ " in B . __dict__ for B in C . __mro__ ) and any ( " _ _ iter _ _ " in B . __dict__ for B in C . __mro__ ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT
def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Sized : NEW_LINE INDENT if any ( " _ _ len _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT
def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Container : NEW_LINE INDENT if any ( " _ _ contains _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE DEDENT
def __subclasshook__ ( cls , C ) : NEW_LINE INDENT if cls is Callable : NEW_LINE INDENT if any ( " _ _ call _ _ " in B . __dict__ for B in C . __mro__ ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return NotImplemented NEW_LINE # # # ▁ SETS ▁ # # # ENDCOM DEDENT
def _from_iterable ( cls , it ) : NEW_LINE INDENT ''' Construct ▁ an ▁ instance ▁ of ▁ the ▁ class ▁ from ▁ any ▁ iterable ▁ input . STRNEWLINE STRNEWLINE ▁ Must ▁ override ▁ this ▁ method ▁ if ▁ the ▁ class ▁ constructor ▁ signature STRNEWLINE ▁ does ▁ not ▁ accept ▁ an ▁ iterable ▁ for ▁ an ▁ input . STRNEWLINE ▁ ''' NEW_LINE return cls ( it ) NEW_LINE DEDENT
def update ( * args , ** kwds ) : NEW_LINE INDENT if len ( args ) > 2 : NEW_LINE INDENT raise TypeError ( " update ( ) ▁ takes ▁ at ▁ most ▁ 2 ▁ positional ▁ " " arguments ▁ ( { } ▁ given ) " . format ( len ( args ) ) ) NEW_LINE DEDENT elif not args : NEW_LINE INDENT raise TypeError ( " update ( ) ▁ takes ▁ at ▁ least ▁ 1 ▁ argument ▁ ( 0 ▁ given ) " ) NEW_LINE DEDENT self = args [ 0 ] NEW_LINE other = args [ 1 ] if len ( args ) >= 2 else ( ) NEW_LINE if isinstance ( other , Mapping ) : NEW_LINE INDENT for key in other : NEW_LINE INDENT self [ key ] = other [ key ] NEW_LINE DEDENT DEDENT elif hasattr ( other , " keys " ) : NEW_LINE INDENT for key in other . keys ( ) : NEW_LINE INDENT self [ key ] = other [ key ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for key , value in other : NEW_LINE INDENT self [ key ] = value NEW_LINE DEDENT DEDENT for key , value in kwds . items ( ) : NEW_LINE INDENT self [ key ] = value NEW_LINE DEDENT DEDENT
def is_interface_vlan ( interface ) : NEW_LINE INDENT iface = local ( " sudo ▁ ip ▁ link ▁ show ▁ % s ▁ | ▁ head ▁ - 1" % interface + " | ▁ cut ▁ - f2 ▁ - d ' : ' ▁ | ▁ grep ▁ ' @ ' " , capture = True , warn_only = True ) NEW_LINE if iface . succeeded : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_physical_interface_of_vlan ( interface ) : NEW_LINE INDENT iface = local ( " sudo ▁ ip ▁ link ▁ show ▁ % s ▁ | ▁ head ▁ - 1 ▁ | ▁ cut ▁ - f2 ▁ - d ' : ' " % interface + " | ▁ cut ▁ - f2 ▁ - d ' @ ' " , capture = True ) NEW_LINE return iface NEW_LINE DEDENT
def auth_header ( user , passwd , token ) : NEW_LINE INDENT if token : NEW_LINE INDENT return " Token ▁ token = % s " % token NEW_LINE DEDENT auth = base64 . encodestring ( ' % s : % s ' % ( user , passwd ) ) . replace ( ' \n ' , ' ' ) NEW_LINE return " Basic ▁ % s " % auth NEW_LINE DEDENT
def ongoing ( module , name , user , passwd , token ) : NEW_LINE INDENT url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows / ongoing " NEW_LINE headers = { " Authorization " : auth_header ( user , passwd , token ) } NEW_LINE response , info = fetch_url ( module , url , headers = headers ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ lookup ▁ the ▁ ongoing ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , False NEW_LINE DEDENT
def create ( module , name , user , passwd , token , requester_id , service , hours , minutes , desc ) : NEW_LINE INDENT now = datetime . datetime . utcnow ( ) NEW_LINE later = now + datetime . timedelta ( hours = int ( hours ) , minutes = int ( minutes ) ) NEW_LINE start = now . strftime ( " % Y - % m - % dT % H : % M : % SZ " ) NEW_LINE end = later . strftime ( " % Y - % m - % dT % H : % M : % SZ " ) NEW_LINE url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows " NEW_LINE headers = { ' Authorization ' : auth_header ( user , passwd , token ) , ' Content - Type ' : ' application / json ' , } NEW_LINE request_data = { ' maintenance _ window ' : { ' start _ time ' : start , ' end _ time ' : end , ' description ' : desc , ' service _ ids ' : service } } NEW_LINE if requester_id : NEW_LINE INDENT request_data [ ' requester _ id ' ] = requester_id NEW_LINE DEDENT else : NEW_LINE INDENT if token : NEW_LINE INDENT module . fail_json ( msg = " requester _ id ▁ is ▁ required ▁ when ▁ using ▁ a ▁ token " ) NEW_LINE DEDENT DEDENT data = json . dumps ( request_data ) NEW_LINE response , info = fetch_url ( module , url , data = data , headers = headers , method = ' POST ' ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ create ▁ the ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , True NEW_LINE DEDENT
def absent ( module , name , user , passwd , token , requester_id , service ) : NEW_LINE INDENT url = " https : / / " + name + " . pagerduty . com / api / v1 / maintenance _ windows / " + service [ 0 ] NEW_LINE headers = { ' Authorization ' : auth_header ( user , passwd , token ) , ' Content - Type ' : ' application / json ' , } NEW_LINE request_data = { } NEW_LINE if requester_id : NEW_LINE INDENT request_data [ ' requester _ id ' ] = requester_id NEW_LINE DEDENT else : NEW_LINE INDENT if token : NEW_LINE INDENT module . fail_json ( msg = " requester _ id ▁ is ▁ required ▁ when ▁ using ▁ a ▁ token " ) NEW_LINE DEDENT DEDENT data = json . dumps ( request_data ) NEW_LINE response , info = fetch_url ( module , url , data = data , headers = headers , method = ' DELETE ' ) NEW_LINE if info [ ' status ' ] != 200 : NEW_LINE INDENT module . fail_json ( msg = " failed ▁ to ▁ delete ▁ the ▁ window : ▁ % s " % info [ ' msg ' ] ) NEW_LINE DEDENT try : NEW_LINE INDENT json_out = json . loads ( response . read ( ) ) NEW_LINE DEDENT except : NEW_LINE INDENT json_out = " " NEW_LINE DEDENT return False , json_out , True NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT module = AnsibleModule ( argument_spec = dict ( state = dict ( required = True , choices = [ ' running ' , ' started ' , ' ongoing ' , ' absent ' ] ) , name = dict ( required = True ) , user = dict ( required = False ) , passwd = dict ( required = False ) , token = dict ( required = False ) , service = dict ( required = False , type = ' list ' , aliases = [ " services " ] ) , requester_id = dict ( required = False ) , hours = dict ( default = '1' , required = False ) , minutes = dict ( default = '0' , required = False ) , desc = dict ( default = ' Created ▁ by ▁ Ansible ' , required = False ) , validate_certs = dict ( default = ' yes ' , type = ' bool ' ) , ) ) NEW_LINE state = module . params [ ' state ' ] NEW_LINE name = module . params [ ' name ' ] NEW_LINE user = module . params [ ' user ' ] NEW_LINE passwd = module . params [ ' passwd ' ] NEW_LINE token = module . params [ ' token ' ] NEW_LINE service = module . params [ ' service ' ] NEW_LINE hours = module . params [ ' hours ' ] NEW_LINE minutes = module . params [ ' minutes ' ] NEW_LINE token = module . params [ ' token ' ] NEW_LINE desc = module . params [ ' desc ' ] NEW_LINE requester_id = module . params [ ' requester _ id ' ] NEW_LINE if not token and not ( user or passwd ) : NEW_LINE INDENT module . fail_json ( msg = " neither ▁ user ▁ and ▁ passwd ▁ nor ▁ token ▁ specified " ) NEW_LINE DEDENT if state == " running " or state == " started " : NEW_LINE INDENT if not service : NEW_LINE INDENT module . fail_json ( msg = " service ▁ not ▁ specified " ) NEW_LINE DEDENT ( rc , out , changed ) = create ( module , name , user , passwd , token , requester_id , service , hours , minutes , desc ) NEW_LINE if rc == 0 : NEW_LINE INDENT changed = True NEW_LINE DEDENT DEDENT if state == " ongoing " : NEW_LINE INDENT ( rc , out , changed ) = ongoing ( module , name , user , passwd , token ) NEW_LINE DEDENT if state == " absent " : NEW_LINE INDENT ( rc , out , changed ) = absent ( module , name , user , passwd , token , requester_id , service ) NEW_LINE DEDENT if rc != 0 : NEW_LINE INDENT module . fail_json ( msg = " failed " , result = out ) NEW_LINE DEDENT module . exit_json ( msg = " success " , result = out , changed = changed ) NEW_LINE # ▁ import ▁ module ▁ snippets ENDCOM DEDENT
def set_module_args ( args ) : NEW_LINE INDENT args = json . dumps ( { ' ANSIBLE _ MODULE _ ARGS ' : args } ) NEW_LINE basic . _ANSIBLE_ARGS = to_bytes ( args ) NEW_LINE DEDENT
def load_fixture ( name ) : NEW_LINE INDENT path = os . path . join ( fixture_path , name ) NEW_LINE if path in fixture_data : NEW_LINE INDENT return fixture_data [ path ] NEW_LINE DEDENT with open ( path ) as f : NEW_LINE INDENT data = f . read ( ) NEW_LINE DEDENT try : NEW_LINE INDENT data = json . loads ( data ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT fixture_data [ path ] = data NEW_LINE return data NEW_LINE DEDENT
def testtype ( treetype , proxy ) : NEW_LINE INDENT def decorator ( f ) : NEW_LINE INDENT @ functools . wraps ( f ) NEW_LINE def _testtype ( self ) : NEW_LINE INDENT { ' MP ' : self . set_MP , ' AL ' : self . set_AL , ' NS ' : self . set_NS } [ treetype ] ( proxy ) NEW_LINE try : NEW_LINE INDENT f ( self ) NEW_LINE DEDENT finally : NEW_LINE INDENT transaction . rollback ( ) NEW_LINE self . model = None NEW_LINE self . sorted_model = None NEW_LINE self . dep_model = None NEW_LINE DEDENT DEDENT return _testtype NEW_LINE DEDENT return decorator NEW_LINE DEDENT
def _load_test_methods ( cls , proxy = True ) : NEW_LINE INDENT if proxy and DJANGO_VERSION >= ( 1 , 1 ) : NEW_LINE INDENT proxyopts = ( False , True ) NEW_LINE DEDENT else : NEW_LINE INDENT proxyopts = ( False , ) NEW_LINE DEDENT for m in dir ( cls ) : NEW_LINE INDENT if not m . startswith ( ' _ multi _ ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for t in ( ' MP ' , ' AL ' , ' NS ' ) : NEW_LINE INDENT for p in proxyopts : NEW_LINE INDENT deco = testtype ( t , p ) NEW_LINE name = ' test _ % s % s _ % s ' % ( t . lower ( ) , ' _ proxy ' if p else ' ' , m . split ( ' _ ' , 2 ) [ 2 ] ) NEW_LINE setattr ( cls , name , deco ( getattr ( cls , m ) ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
