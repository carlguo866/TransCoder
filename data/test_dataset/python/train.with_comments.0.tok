<DOCUMENT_ID="carragom/modoboa/tree/master/modoboa/admin/models/domain_alias.py"> """ Models ▁ related ▁ to ▁ domain ▁ aliases ▁ management . """ NEW_LINE from django . db import models NEW_LINE from django . utils . encoding import python_2_unicode_compatible , smart_text NEW_LINE from django . utils . translation import ugettext as _ , ugettext_lazy NEW_LINE from django . contrib . contenttypes . fields import GenericRelation NEW_LINE from reversion import revisions as reversion NEW_LINE from modoboa . core import models as core_models NEW_LINE from modoboa . core import signals as core_signals NEW_LINE from modoboa . lib . exceptions import BadRequest , Conflict NEW_LINE from . base import AdminObject NEW_LINE from . domain import Domain NEW_LINE class DomainAliasManager ( models . Manager ) : NEW_LINE INDENT def get_for_admin ( self , admin ) : NEW_LINE INDENT """ Return ▁ the ▁ domain ▁ aliases ▁ belonging ▁ to ▁ this ▁ admin . STRNEWLINE STRNEWLINE ▁ The ▁ result ▁ is ▁ a ▁ ` ` QuerySet ` ` ▁ object , ▁ so ▁ this ▁ function ▁ can ▁ be ▁ used STRNEWLINE ▁ to ▁ fill ▁ ` ` ModelChoiceField ` ` ▁ objects . STRNEWLINE ▁ """ NEW_LINE if admin . is_superuser : NEW_LINE INDENT return self . get_queryset ( ) NEW_LINE DEDENT return self . get_queryset ( ) . filter ( owners__user = admin ) NEW_LINE DEDENT DEDENT @ python_2_unicode_compatible NEW_LINE class DomainAlias ( AdminObject ) : NEW_LINE INDENT """ Domain ▁ aliases . """ NEW_LINE name = models . CharField ( ugettext_lazy ( " name " ) , max_length = 100 , unique = True , help_text = ugettext_lazy ( " The ▁ alias ▁ name " ) ) NEW_LINE target = models . ForeignKey ( Domain , verbose_name = ugettext_lazy ( ' target ' ) , help_text = ugettext_lazy ( " The ▁ domain ▁ this ▁ alias ▁ points ▁ to " ) ) NEW_LINE enabled = models . BooleanField ( ugettext_lazy ( ' enabled ' ) , help_text = ugettext_lazy ( " Check ▁ to ▁ activate ▁ this ▁ alias " ) , default = True ) NEW_LINE owners = GenericRelation ( core_models . ObjectAccess ) NEW_LINE objects = DomainAliasManager ( ) NEW_LINE class Meta : NEW_LINE INDENT permissions = ( ( " view _ domaliases " , " View ▁ domain ▁ aliases " ) , ) NEW_LINE app_label = " admin " NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return smart_text ( self . name ) NEW_LINE DEDENT def from_csv ( self , user , row ) : NEW_LINE INDENT """ Create ▁ a ▁ domain ▁ alias ▁ from ▁ a ▁ CSV ▁ row STRNEWLINE STRNEWLINE ▁ Expected ▁ format : ▁ [ " domainalias " , ▁ domain ▁ alias ▁ name , ▁ targeted ▁ domain , ▁ enabled ] STRNEWLINE STRNEWLINE ▁ : param ▁ user : ▁ a ▁ ` ` User ` ` ▁ object STRNEWLINE ▁ : param ▁ row : ▁ a ▁ list ▁ containing ▁ the ▁ alias ▁ definition STRNEWLINE ▁ """ NEW_LINE if len ( row ) < 4 : NEW_LINE INDENT raise BadRequest ( _ ( " Invalid ▁ line " ) ) NEW_LINE DEDENT self . name = row [ 1 ] . strip ( ) NEW_LINE for model in [ DomainAlias , Domain ] : NEW_LINE INDENT if model . objects . filter ( name = self . name ) . exists ( ) : NEW_LINE INDENT raise Conflict NEW_LINE DEDENT DEDENT domname = row [ 2 ] . strip ( ) NEW_LINE try : NEW_LINE INDENT self . target = Domain . objects . get ( name = domname ) NEW_LINE DEDENT except Domain . DoesNotExist : NEW_LINE INDENT raise BadRequest ( _ ( " Unknown ▁ domain ▁ % s " ) % domname ) NEW_LINE DEDENT core_signals . can_create_object . send ( sender = " import " , context = self . target , object_type = " domain _ aliases " ) NEW_LINE self . enabled = row [ 3 ] . strip ( ) in [ " True " , "1" , " yes " , " y " ] NEW_LINE self . save ( creator = user ) NEW_LINE DEDENT def to_csv ( self , csvwriter ) : NEW_LINE INDENT """ Export ▁ a ▁ domain ▁ alias ▁ using ▁ CSV ▁ format STRNEWLINE STRNEWLINE ▁ : param ▁ csvwriter : ▁ a ▁ ` ` csv . writer ` ` ▁ object STRNEWLINE ▁ """ NEW_LINE csvwriter . writerow ( [ " domainalias " , self . name , self . target . name , self . enabled ] ) NEW_LINE DEDENT DEDENT reversion . register ( DomainAlias ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="doublebits/osf.io/tree/master/admin_tests/factories.py"> import factory NEW_LINE from admin . common_auth . models import MyUser NEW_LINE class UserFactory ( factory . Factory ) : NEW_LINE INDENT class Meta : NEW_LINE INDENT model = MyUser NEW_LINE DEDENT id = 123 NEW_LINE email = ' cello @ email . org ' NEW_LINE first_name = ' Yo - yo ' NEW_LINE last_name = ' Ma ' NEW_LINE osf_id = ' abc12' NEW_LINE @ classmethod NEW_LINE def is_in_group ( cls , value ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="40223205/w16b_test-/tree/master/static/Brython3.1.1-20150328-091302/Lib/_socket.py"> """ Implementation ▁ module ▁ for ▁ socket ▁ operations . STRNEWLINE STRNEWLINE See ▁ the ▁ socket ▁ module ▁ for ▁ documentation . """ NEW_LINE AF_APPLETALK = 16 NEW_LINE AF_DECnet = 12 NEW_LINE AF_INET = 2 NEW_LINE AF_INET6 = 23 NEW_LINE AF_IPX = 6 NEW_LINE AF_IRDA = 26 NEW_LINE AF_SNA = 11 NEW_LINE AF_UNSPEC = 0 NEW_LINE AI_ADDRCONFIG = 1024 NEW_LINE AI_ALL = 256 NEW_LINE AI_CANONNAME = 2 NEW_LINE AI_NUMERICHOST = 4 NEW_LINE AI_NUMERICSERV = 8 NEW_LINE AI_PASSIVE = 1 NEW_LINE AI_V4MAPPED = 2048 NEW_LINE CAPI = ' < capsule ▁ object ▁ " _ socket . CAPI " ▁ at ▁ 0x00BC4F38 > ' NEW_LINE EAI_AGAIN = 11002 NEW_LINE EAI_BADFLAGS = 10022 NEW_LINE EAI_FAIL = 11003 NEW_LINE EAI_FAMILY = 10047 NEW_LINE EAI_MEMORY = 8 NEW_LINE EAI_NODATA = 11001 NEW_LINE EAI_NONAME = 11001 NEW_LINE EAI_SERVICE = 10109 NEW_LINE EAI_SOCKTYPE = 10044 NEW_LINE INADDR_ALLHOSTS_GROUP = - 536870911 NEW_LINE INADDR_ANY = 0 NEW_LINE INADDR_BROADCAST = - 1 NEW_LINE INADDR_LOOPBACK = 2130706433 NEW_LINE INADDR_MAX_LOCAL_GROUP = - 536870657 NEW_LINE INADDR_NONE = - 1 NEW_LINE INADDR_UNSPEC_GROUP = - 536870912 NEW_LINE IPPORT_RESERVED = 1024 NEW_LINE IPPORT_USERRESERVED = 5000 NEW_LINE IPPROTO_ICMP = 1 NEW_LINE IPPROTO_IP = 0 NEW_LINE IPPROTO_RAW = 255 NEW_LINE IPPROTO_TCP = 6 NEW_LINE IPPROTO_UDP = 17 NEW_LINE IPV6_CHECKSUM = 26 NEW_LINE IPV6_DONTFRAG = 14 NEW_LINE IPV6_HOPLIMIT = 21 NEW_LINE IPV6_HOPOPTS = 1 NEW_LINE IPV6_JOIN_GROUP = 12 NEW_LINE IPV6_LEAVE_GROUP = 13 NEW_LINE IPV6_MULTICAST_HOPS = 10 NEW_LINE IPV6_MULTICAST_IF = 9 NEW_LINE IPV6_MULTICAST_LOOP = 11 NEW_LINE IPV6_PKTINFO = 19 NEW_LINE IPV6_RECVRTHDR = 38 NEW_LINE IPV6_RECVTCLASS = 40 NEW_LINE IPV6_RTHDR = 32 NEW_LINE IPV6_TCLASS = 39 NEW_LINE IPV6_UNICAST_HOPS = 4 NEW_LINE IPV6_V6ONLY = 27 NEW_LINE IP_ADD_MEMBERSHIP = 12 NEW_LINE IP_DROP_MEMBERSHIP = 13 NEW_LINE IP_HDRINCL = 2 NEW_LINE IP_MULTICAST_IF = 9 NEW_LINE IP_MULTICAST_LOOP = 11 NEW_LINE IP_MULTICAST_TTL = 10 NEW_LINE IP_OPTIONS = 1 NEW_LINE IP_RECVDSTADDR = 25 NEW_LINE IP_TOS = 3 NEW_LINE IP_TTL = 4 NEW_LINE MSG_BCAST = 1024 NEW_LINE MSG_CTRUNC = 512 NEW_LINE MSG_DONTROUTE = 4 NEW_LINE MSG_MCAST = 2048 NEW_LINE MSG_OOB = 1 NEW_LINE MSG_PEEK = 2 NEW_LINE MSG_TRUNC = 256 NEW_LINE NI_DGRAM = 16 NEW_LINE NI_MAXHOST = 1025 NEW_LINE NI_MAXSERV = 32 NEW_LINE NI_NAMEREQD = 4 NEW_LINE NI_NOFQDN = 1 NEW_LINE NI_NUMERICHOST = 2 NEW_LINE NI_NUMERICSERV = 8 NEW_LINE RCVALL_MAX = 3 NEW_LINE RCVALL_OFF = 0 NEW_LINE RCVALL_ON = 1 NEW_LINE RCVALL_SOCKETLEVELONLY = 2 NEW_LINE SHUT_RD = 0 NEW_LINE SHUT_RDWR = 2 NEW_LINE SHUT_WR = 1 NEW_LINE SIO_KEEPALIVE_VALS = 2550136836 NEW_LINE SIO_RCVALL = 2550136833 NEW_LINE SOCK_DGRAM = 2 NEW_LINE SOCK_RAW = 3 NEW_LINE SOCK_RDM = 4 NEW_LINE SOCK_SEQPACKET = 5 NEW_LINE SOCK_STREAM = 1 NEW_LINE SOL_IP = 0 NEW_LINE SOL_SOCKET = 65535 NEW_LINE SOL_TCP = 6 NEW_LINE SOL_UDP = 17 NEW_LINE SOMAXCONN = 2147483647 NEW_LINE SO_ACCEPTCONN = 2 NEW_LINE SO_BROADCAST = 32 NEW_LINE SO_DEBUG = 1 NEW_LINE SO_DONTROUTE = 16 NEW_LINE SO_ERROR = 4103 NEW_LINE SO_EXCLUSIVEADDRUSE = - 5 NEW_LINE SO_KEEPALIVE = 8 NEW_LINE SO_LINGER = 128 NEW_LINE SO_OOBINLINE = 256 NEW_LINE SO_RCVBUF = 4098 NEW_LINE SO_RCVLOWAT = 4100 NEW_LINE SO_RCVTIMEO = 4102 NEW_LINE SO_REUSEADDR = 4 NEW_LINE SO_SNDBUF = 4097 NEW_LINE SO_SNDLOWAT = 4099 NEW_LINE SO_SNDTIMEO = 4101 NEW_LINE SO_TYPE = 4104 NEW_LINE SO_USELOOPBACK = 64 NEW_LINE class SocketType : NEW_LINE INDENT pass NEW_LINE DEDENT TCP_MAXSEG = 4 NEW_LINE TCP_NODELAY = 1 NEW_LINE __loader__ = ' < _ frozen _ importlib . ExtensionFileLoader ▁ object ▁ at ▁ 0x00CA2D90 > ' NEW_LINE def dup ( * args , ** kw ) : NEW_LINE INDENT """ dup ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Duplicate ▁ an ▁ integer ▁ socket ▁ file ▁ descriptor . ▁ This ▁ is ▁ like ▁ os . dup ( ) , ▁ but ▁ for STRNEWLINE ▁ sockets ; ▁ on ▁ some ▁ platforms ▁ os . dup ( ) ▁ won ' t ▁ work ▁ for ▁ socket ▁ file ▁ descriptors . """ NEW_LINE pass NEW_LINE DEDENT class error : NEW_LINE INDENT pass NEW_LINE DEDENT class gaierror : NEW_LINE INDENT pass NEW_LINE DEDENT def getaddrinfo ( * args , ** kw ) : NEW_LINE INDENT """ getaddrinfo ( host , ▁ port ▁ [ , ▁ family , ▁ socktype , ▁ proto , ▁ flags ] ) ▁ - > ▁ list ▁ of ▁ ( family , ▁ socktype , ▁ proto , ▁ canonname , ▁ sockaddr ) STRNEWLINE ▁ STRNEWLINE ▁ Resolve ▁ host ▁ and ▁ port ▁ into ▁ addrinfo ▁ struct . """ NEW_LINE pass NEW_LINE DEDENT def getdefaulttimeout ( * args , ** kw ) : NEW_LINE INDENT """ getdefaulttimeout ( ) ▁ - > ▁ timeout ▁ STRNEWLINE ▁ Returns ▁ the ▁ default ▁ timeout ▁ in ▁ seconds ▁ ( float ) ▁ for ▁ new ▁ socket ▁ objects . STRNEWLINE ▁ A ▁ value ▁ of ▁ None ▁ indicates ▁ that ▁ new ▁ socket ▁ objects ▁ have ▁ no ▁ timeout . STRNEWLINE ▁ When ▁ the ▁ socket ▁ module ▁ is ▁ first ▁ imported , ▁ the ▁ default ▁ is ▁ None . """ NEW_LINE pass NEW_LINE DEDENT def gethostbyaddr ( * args , ** kw ) : NEW_LINE INDENT """ gethostbyaddr ( host ) ▁ - > ▁ ( name , ▁ aliaslist , ▁ addresslist ) ▁ STRNEWLINE ▁ Return ▁ the ▁ true ▁ host ▁ name , ▁ a ▁ list ▁ of ▁ aliases , ▁ and ▁ a ▁ list ▁ of ▁ IP ▁ addresses , STRNEWLINE ▁ for ▁ a ▁ host . ▁ The ▁ host ▁ argument ▁ is ▁ a ▁ string ▁ giving ▁ a ▁ host ▁ name ▁ or ▁ IP ▁ number . """ NEW_LINE pass NEW_LINE DEDENT def gethostbyname ( * args , ** kw ) : NEW_LINE INDENT """ gethostbyname ( host ) ▁ - > ▁ address ▁ STRNEWLINE ▁ Return ▁ the ▁ IP ▁ address ▁ ( a ▁ string ▁ of ▁ the ▁ form ▁ ' 255.255.255.255 ' ) ▁ for ▁ a ▁ host . """ NEW_LINE pass NEW_LINE DEDENT def gethostbyname_ex ( * args , ** kw ) : NEW_LINE INDENT """ gethostbyname _ ex ( host ) ▁ - > ▁ ( name , ▁ aliaslist , ▁ addresslist ) ▁ STRNEWLINE ▁ Return ▁ the ▁ true ▁ host ▁ name , ▁ a ▁ list ▁ of ▁ aliases , ▁ and ▁ a ▁ list ▁ of ▁ IP ▁ addresses , STRNEWLINE ▁ for ▁ a ▁ host . ▁ The ▁ host ▁ argument ▁ is ▁ a ▁ string ▁ giving ▁ a ▁ host ▁ name ▁ or ▁ IP ▁ number . """ NEW_LINE pass NEW_LINE DEDENT def gethostname ( * args , ** kw ) : NEW_LINE INDENT """ gethostname ( ) ▁ - > ▁ string ▁ STRNEWLINE ▁ Return ▁ the ▁ current ▁ host ▁ name . """ NEW_LINE pass NEW_LINE DEDENT def getnameinfo ( * args , ** kw ) : NEW_LINE INDENT """ getnameinfo ( sockaddr , ▁ flags ) ▁ - - > ▁ ( host , ▁ port ) ▁ STRNEWLINE ▁ Get ▁ host ▁ and ▁ port ▁ for ▁ a ▁ sockaddr . """ NEW_LINE pass NEW_LINE DEDENT def getprotobyname ( * args , ** kw ) : NEW_LINE INDENT """ getprotobyname ( name ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Return ▁ the ▁ protocol ▁ number ▁ for ▁ the ▁ named ▁ protocol . ▁ ( Rarely ▁ used . ) """ NEW_LINE pass NEW_LINE DEDENT def getservbyname ( * args , ** kw ) : NEW_LINE INDENT """ getservbyname ( servicename [ , ▁ protocolname ] ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Return ▁ a ▁ port ▁ number ▁ from ▁ a ▁ service ▁ name ▁ and ▁ protocol ▁ name . STRNEWLINE ▁ The ▁ optional ▁ protocol ▁ name , ▁ if ▁ given , ▁ should ▁ be ▁ ' tcp ' ▁ or ▁ ' udp ' , STRNEWLINE ▁ otherwise ▁ any ▁ protocol ▁ will ▁ match . """ NEW_LINE pass NEW_LINE DEDENT def getservbyport ( * args , ** kw ) : NEW_LINE INDENT """ getservbyport ( port [ , ▁ protocolname ] ) ▁ - > ▁ string ▁ STRNEWLINE ▁ Return ▁ the ▁ service ▁ name ▁ from ▁ a ▁ port ▁ number ▁ and ▁ protocol ▁ name . STRNEWLINE ▁ The ▁ optional ▁ protocol ▁ name , ▁ if ▁ given , ▁ should ▁ be ▁ ' tcp ' ▁ or ▁ ' udp ' , STRNEWLINE ▁ otherwise ▁ any ▁ protocol ▁ will ▁ match . """ NEW_LINE pass NEW_LINE DEDENT has_ipv6 = True NEW_LINE class herror : NEW_LINE INDENT pass NEW_LINE DEDENT def htonl ( * args , ** kw ) : NEW_LINE INDENT """ htonl ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 32 - bit ▁ integer ▁ from ▁ host ▁ to ▁ network ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def htons ( * args , ** kw ) : NEW_LINE INDENT """ htons ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 16 - bit ▁ integer ▁ from ▁ host ▁ to ▁ network ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def inet_aton ( * args , ** kw ) : NEW_LINE INDENT """ inet _ aton ( string ) ▁ - > ▁ bytes ▁ giving ▁ packed ▁ 32 - bit ▁ IP ▁ representation ▁ STRNEWLINE ▁ Convert ▁ an ▁ IP ▁ address ▁ in ▁ string ▁ format ▁ ( 123.45.67.89 ) ▁ to ▁ the ▁ 32 - bit ▁ packed STRNEWLINE ▁ binary ▁ format ▁ used ▁ in ▁ low - level ▁ network ▁ functions . """ NEW_LINE pass NEW_LINE DEDENT def inet_ntoa ( * args , ** kw ) : NEW_LINE INDENT """ inet _ ntoa ( packed _ ip ) ▁ - > ▁ ip _ address _ string ▁ STRNEWLINE ▁ Convert ▁ an ▁ IP ▁ address ▁ from ▁ 32 - bit ▁ packed ▁ binary ▁ format ▁ to ▁ string ▁ format """ NEW_LINE pass NEW_LINE DEDENT def ntohl ( * args , ** kw ) : NEW_LINE INDENT """ ntohl ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 32 - bit ▁ integer ▁ from ▁ network ▁ to ▁ host ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def ntohs ( * args , ** kw ) : NEW_LINE INDENT """ ntohs ( integer ) ▁ - > ▁ integer ▁ STRNEWLINE ▁ Convert ▁ a ▁ 16 - bit ▁ integer ▁ from ▁ network ▁ to ▁ host ▁ byte ▁ order . """ NEW_LINE pass NEW_LINE DEDENT def setdefaulttimeout ( * args , ** kw ) : NEW_LINE INDENT """ setdefaulttimeout ( timeout ) ▁ STRNEWLINE ▁ Set ▁ the ▁ default ▁ timeout ▁ in ▁ seconds ▁ ( float ) ▁ for ▁ new ▁ socket ▁ objects . STRNEWLINE ▁ A ▁ value ▁ of ▁ None ▁ indicates ▁ that ▁ new ▁ socket ▁ objects ▁ have ▁ no ▁ timeout . STRNEWLINE ▁ When ▁ the ▁ socket ▁ module ▁ is ▁ first ▁ imported , ▁ the ▁ default ▁ is ▁ None . """ NEW_LINE pass NEW_LINE DEDENT class socket : NEW_LINE INDENT def __init__ ( self , * args , ** kw ) : NEW_LINE INDENT pass NEW_LINE DEDENT def bind ( self , * args , ** kw ) : NEW_LINE INDENT pass NEW_LINE DEDENT def close ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT class timeout : NEW_LINE INDENT pass NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="glaubitz/fs-uae-debian/tree/master/launcher/launcher/game_paths.py"> import os NEW_LINE import fsui NEW_LINE from fsbc . paths import Paths NEW_LINE from fsgs . FSGSDirectories import FSGSDirectories NEW_LINE from . launcher_config import LauncherConfig NEW_LINE from . launcher_settings import LauncherSettings NEW_LINE from . ui . Constants import Constants NEW_LINE class GamePaths ( object ) : NEW_LINE INDENT @ staticmethod NEW_LINE def current ( ) : NEW_LINE INDENT model = LauncherConfig . get ( " amiga _ model " ) NEW_LINE if model . startswith ( " CD32" ) : NEW_LINE INDENT platform = " CD32" NEW_LINE DEDENT elif model == " CDTV " : NEW_LINE INDENT platform = " CDTV " NEW_LINE DEDENT else : NEW_LINE INDENT platform = " Amiga " NEW_LINE DEDENT name = LauncherSettings . get ( " config _ name " ) NEW_LINE uuid = LauncherConfig . get ( " x _ game _ uuid " ) NEW_LINE return GamePaths ( name , platform , uuid ) NEW_LINE DEDENT def __init__ ( self , name , platform , uuid ) : NEW_LINE INDENT self . uuid = uuid NEW_LINE self . config_name = name NEW_LINE if " ( " in name : NEW_LINE INDENT parts = name . split ( " ( " , 1 ) NEW_LINE self . name , self . variant = parts NEW_LINE self . name = self . name . strip ( ) NEW_LINE self . variant = self . variant . strip ( ) NEW_LINE if self . variant . endswith ( " ) " ) : NEW_LINE INDENT self . variant = self . variant [ : - 1 ] NEW_LINE DEDENT self . variant = self . variant . replace ( " ) ▁ ( " , " , ▁ " ) NEW_LINE self . variant = self . variant . replace ( " ) ( " , " , ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . name = name NEW_LINE self . variant = " " NEW_LINE DEDENT self . platform = platform NEW_LINE DEDENT def get_name ( self ) : NEW_LINE INDENT return self . name NEW_LINE DEDENT def get_variant ( self ) : NEW_LINE INDENT return self . variant NEW_LINE DEDENT @ staticmethod NEW_LINE def get_override_path ( name ) : NEW_LINE INDENT path = LauncherConfig . get ( name ) NEW_LINE if not path : NEW_LINE INDENT return " " NEW_LINE DEDENT path = Paths . expand_path ( path ) NEW_LINE return path NEW_LINE DEDENT def get_screenshot_path ( self , number ) : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT sha1 = LauncherConfig . get ( " title _ sha1" ) NEW_LINE DEDENT else : NEW_LINE INDENT sha1 = LauncherConfig . get ( " screen { 0 } _ sha1" . format ( number ) ) NEW_LINE DEDENT if sha1 : NEW_LINE INDENT return " sha1 : " + sha1 NEW_LINE DEDENT if number == 0 : NEW_LINE INDENT path = self . get_override_path ( " title _ image " ) NEW_LINE DEDENT else : NEW_LINE INDENT path = self . get_override_path ( " screen { 0 } _ image " . format ( number ) ) NEW_LINE DEDENT if path and os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT if self . uuid : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT name = " title . png " NEW_LINE DEDENT else : NEW_LINE INDENT name = " screen { 0 } . png " . format ( number ) NEW_LINE DEDENT paths = FSGSDirectories . get_images_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT p = os . path . join ( dir_ , self . platform , " Images " , self . uuid [ : 2 ] , self . uuid , name ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT p = os . path . join ( dir_ , self . platform , " Thumbnails " , self . uuid [ : 2 ] , self . uuid , name ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT name = self . name NEW_LINE if number == 0 : NEW_LINE INDENT override_dir = LauncherConfig . get ( " titles _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_titles_dirs ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT override_dir = LauncherConfig . get ( " screenshots _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_screenshots_dirs ( ) NEW_LINE DEDENT DEDENT if number >= 2 : NEW_LINE INDENT name = " { 0 } _ {1 } " . format ( name , number ) NEW_LINE DEDENT for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . gif " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . gif " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def load_screenshot ( self , number ) : NEW_LINE INDENT path = self . get_screenshot_path ( number ) NEW_LINE if path : NEW_LINE INDENT return fsui . Image ( path ) NEW_LINE DEDENT DEDENT def load_screenshot_preview ( self , number ) : NEW_LINE INDENT image = self . load_screenshot ( number ) NEW_LINE if image is None : NEW_LINE INDENT return image NEW_LINE DEDENT if image . size == Constants . SCREEN_SIZE : NEW_LINE INDENT return image NEW_LINE DEDENT if image . size [ 0 ] < 400 : NEW_LINE INDENT image . resize ( ( image . size [ 0 ] * 2 , image . size [ 1 ] * 2 ) , fsui . Image . NEAREST ) NEW_LINE DEDENT image . resize ( Constants . SCREEN_SIZE ) NEW_LINE return image NEW_LINE DEDENT def get_cover_path ( self ) : NEW_LINE INDENT sha1 = LauncherConfig . get ( " front _ sha1" ) NEW_LINE if sha1 : NEW_LINE INDENT return " sha1 : " + sha1 NEW_LINE DEDENT path = self . get_override_path ( " cover _ image " ) NEW_LINE if path and os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT if self . uuid : NEW_LINE INDENT paths = FSGSDirectories . get_images_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT p = os . path . join ( dir_ , self . platform , " Images " , self . uuid [ : 2 ] , self . uuid , " front . png " ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT p = os . path . join ( dir_ , self . platform , " Thumbnails " , self . uuid [ : 2 ] , self . uuid , " front . png " ) NEW_LINE if os . path . exists ( p ) : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT name = self . name NEW_LINE override_dir = LauncherConfig . get ( " covers _ dir " ) NEW_LINE if override_dir : NEW_LINE INDENT paths = [ Paths . expand_path ( override_dir ) ] NEW_LINE DEDENT else : NEW_LINE INDENT paths = FSGSDirectories . get_covers_dirs ( ) NEW_LINE DEDENT for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , name + " . jpg " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , letter , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . jpg " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT path = os . path . join ( dir_ , name + " . png " ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def load_cover ( self ) : NEW_LINE INDENT path = self . get_cover_path ( ) NEW_LINE print ( path ) NEW_LINE if path : NEW_LINE INDENT return fsui . Image ( path ) NEW_LINE DEDENT DEDENT def load_cover_preview ( self ) : NEW_LINE INDENT image = self . load_cover ( ) NEW_LINE if image is None : NEW_LINE INDENT return image NEW_LINE DEDENT image . resize ( Constants . COVER_SIZE ) NEW_LINE return image NEW_LINE DEDENT def get_theme_path ( self ) : NEW_LINE INDENT letter = self . get_letter ( self . name ) NEW_LINE if not letter : NEW_LINE INDENT return None NEW_LINE DEDENT paths = FSGSDirectories . get_themes_dirs ( ) NEW_LINE for dir_ in paths : NEW_LINE INDENT path = os . path . join ( dir_ , letter , self . name ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT def _get_state_dir ( self ) : NEW_LINE INDENT config_name = self . config_name NEW_LINE if not config_name : NEW_LINE INDENT config_name = " Default " NEW_LINE # ▁ use ▁ a ▁ temporary ▁ state ▁ dir , ▁ for ▁ now , ▁ to ▁ avoid ▁ problems ▁ with ENDCOM # ▁ floppy ▁ overlays ▁ etc ▁ interfering ▁ with ▁ net ▁ play ENDCOM DEDENT from . netplay . netplay import Netplay NEW_LINE if Netplay . current ( ) : NEW_LINE # ▁ it ▁ is ▁ possible ▁ to ▁ manually ▁ specify ▁ the ▁ state ▁ dir ENDCOM INDENT config_name = LauncherConfig . get ( " _ _ netplay _ state _ dir _ name " ) NEW_LINE if not config_name : NEW_LINE # ▁ this ▁ is ▁ the ▁ default ▁ behavior , ▁ create ▁ a ▁ clean ▁ state ENDCOM # ▁ dir ▁ for ▁ the ▁ net ▁ play ▁ session ENDCOM INDENT netplay_game = LauncherConfig . get ( " _ _ netplay _ game " ) NEW_LINE if netplay_game : NEW_LINE INDENT config_name = " Net ▁ Play ▁ ( {0 } ) " . format ( netplay_game ) NEW_LINE DEDENT DEDENT DEDENT letter = self . get_letter ( config_name ) NEW_LINE if not letter : NEW_LINE INDENT config_name = " Default " NEW_LINE letter = self . get_letter ( config_name ) NEW_LINE # ▁ we ▁ use ▁ an ▁ existing ▁ state ▁ dir ▁ in ▁ a ▁ " letter " ▁ dir ▁ if ▁ it ▁ exists ENDCOM # ▁ ( legacy ▁ support ) . ENDCOM DEDENT path = os . path . join ( FSGSDirectories . get_save_states_dir ( ) , letter , config_name ) NEW_LINE if os . path . exists ( path ) : NEW_LINE INDENT return path NEW_LINE # ▁ if ▁ not , ▁ we ▁ use ▁ a ▁ direct ▁ sub - folder ▁ of ▁ save ▁ states ▁ dir ENDCOM DEDENT path = os . path . join ( FSGSDirectories . get_save_states_dir ( ) , config_name ) NEW_LINE return path NEW_LINE DEDENT def get_state_dir ( self ) : NEW_LINE INDENT state_dir = self . _get_state_dir ( ) NEW_LINE if not os . path . exists ( state_dir ) : NEW_LINE INDENT os . makedirs ( state_dir ) NEW_LINE DEDENT return state_dir NEW_LINE DEDENT @ staticmethod NEW_LINE def get_letter ( name ) : NEW_LINE INDENT letter_name = name . upper ( ) NEW_LINE if letter_name . startswith ( " THE ▁ " ) : NEW_LINE INDENT letter_name = letter_name [ 4 : ] NEW_LINE DEDENT if letter_name . startswith ( " A ▁ " ) : NEW_LINE INDENT letter_name = letter_name [ 2 : ] NEW_LINE DEDENT for i in range ( len ( letter_name ) ) : NEW_LINE INDENT letter = letter_name [ i ] NEW_LINE if letter in "01234567890" : NEW_LINE INDENT letter = "0" NEW_LINE break NEW_LINE DEDENT if letter in " ABCDEFGHIJKLMNOPQRSTUVWXYZ " : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT return letter NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="bollu/sandhi/tree/master/modules/gr36/grc/gui/Connection.py"> """ STRNEWLINE Copyright ▁ 2007 , ▁ 2008 , ▁ 2009 ▁ Free ▁ Software ▁ Foundation , ▁ Inc . STRNEWLINE This ▁ file ▁ is ▁ part ▁ of ▁ GNU ▁ Radio STRNEWLINE STRNEWLINE GNU ▁ Radio ▁ Companion ▁ is ▁ free ▁ software ; ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or STRNEWLINE modify ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE as ▁ published ▁ by ▁ the ▁ Free ▁ Software ▁ Foundation ; ▁ either ▁ version ▁ 2 STRNEWLINE of ▁ the ▁ License , ▁ or ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . STRNEWLINE STRNEWLINE GNU ▁ Radio ▁ Companion ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , STRNEWLINE but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of STRNEWLINE MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the STRNEWLINE GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . STRNEWLINE STRNEWLINE You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License STRNEWLINE along ▁ with ▁ this ▁ program ; ▁ if ▁ not , ▁ write ▁ to ▁ the ▁ Free ▁ Software STRNEWLINE Foundation , ▁ Inc . , ▁ 51 ▁ Franklin ▁ Street , ▁ Fifth ▁ Floor , ▁ Boston , ▁ MA ▁ 02110-1301 , ▁ USA STRNEWLINE """ NEW_LINE import Utils NEW_LINE from Element import Element NEW_LINE import Colors NEW_LINE from Constants import CONNECTOR_ARROW_BASE , CONNECTOR_ARROW_HEIGHT NEW_LINE class Connection ( Element ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL A ▁ graphical ▁ connection ▁ for ▁ ports . STRNEWLINE TABSYMBOL The ▁ connection ▁ has ▁ 2 ▁ parts , ▁ the ▁ arrow ▁ and ▁ the ▁ wire . STRNEWLINE TABSYMBOL The ▁ coloring ▁ of ▁ the ▁ arrow ▁ and ▁ wire ▁ exposes ▁ the ▁ status ▁ of ▁ 3 ▁ states : STRNEWLINE TABSYMBOL TABSYMBOL enabled / disabled , ▁ valid / invalid , ▁ highlighted / non - highlighted . STRNEWLINE TABSYMBOL The ▁ wire ▁ coloring ▁ exposes ▁ the ▁ enabled ▁ and ▁ highlighted ▁ states . STRNEWLINE TABSYMBOL The ▁ arrow ▁ coloring ▁ exposes ▁ the ▁ enabled ▁ and ▁ valid ▁ states . STRNEWLINE TABSYMBOL """ NEW_LINE def __init__ ( self ) : Element . __init__ ( self ) NEW_LINE def get_coordinate ( self ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Get ▁ the ▁ 0,0 ▁ coordinate . STRNEWLINE TABSYMBOL TABSYMBOL Coordinates ▁ are ▁ irrelevant ▁ in ▁ connection . STRNEWLINE TABSYMBOL TABSYMBOL @ return ▁ 0 , ▁ 0 STRNEWLINE TABSYMBOL TABSYMBOL """ NEW_LINE return ( 0 , 0 ) NEW_LINE DEDENT def get_rotation ( self ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Get ▁ the ▁ 0 ▁ degree ▁ rotation . STRNEWLINE TABSYMBOL TABSYMBOL Rotations ▁ are ▁ irrelevant ▁ in ▁ connection . STRNEWLINE TABSYMBOL TABSYMBOL @ return ▁ 0 STRNEWLINE TABSYMBOL TABSYMBOL """ NEW_LINE return 0 NEW_LINE DEDENT def create_shapes ( self ) : NEW_LINE INDENT """ Precalculate ▁ relative ▁ coordinates . """ NEW_LINE Element . create_shapes ( self ) NEW_LINE self . _sink_rot = None NEW_LINE self . _source_rot = None NEW_LINE self . _sink_coor = None NEW_LINE self . _source_coor = None NEW_LINE # get ▁ the ▁ source ▁ coordinate ENDCOM connector_length = self . get_source ( ) . get_connector_length ( ) NEW_LINE self . x1 , self . y1 = Utils . get_rotated_coordinate ( ( connector_length , 0 ) , self . get_source ( ) . get_rotation ( ) ) NEW_LINE # get ▁ the ▁ sink ▁ coordinate ENDCOM connector_length = self . get_sink ( ) . get_connector_length ( ) + CONNECTOR_ARROW_HEIGHT NEW_LINE self . x2 , self . y2 = Utils . get_rotated_coordinate ( ( - connector_length , 0 ) , self . get_sink ( ) . get_rotation ( ) ) NEW_LINE # build ▁ the ▁ arrow ENDCOM self . arrow = [ ( 0 , 0 ) , Utils . get_rotated_coordinate ( ( - CONNECTOR_ARROW_HEIGHT , - CONNECTOR_ARROW_BASE / 2 ) , self . get_sink ( ) . get_rotation ( ) ) , Utils . get_rotated_coordinate ( ( - CONNECTOR_ARROW_HEIGHT , CONNECTOR_ARROW_BASE / 2 ) , self . get_sink ( ) . get_rotation ( ) ) , ] NEW_LINE self . _update_after_move ( ) NEW_LINE if not self . get_enabled ( ) : self . _arrow_color = Colors . CONNECTION_DISABLED_COLOR NEW_LINE elif not self . is_valid ( ) : self . _arrow_color = Colors . CONNECTION_ERROR_COLOR NEW_LINE else : self . _arrow_color = Colors . CONNECTION_ENABLED_COLOR NEW_LINE DEDENT def _update_after_move ( self ) : NEW_LINE INDENT """ Calculate ▁ coordinates . """ NEW_LINE self . clear ( ) # FIXME ▁ do ▁ i ▁ want ▁ this ▁ here ? ENDCOM NEW_LINE # source ▁ connector ENDCOM source = self . get_source ( ) NEW_LINE X , Y = source . get_connector_coordinate ( ) NEW_LINE x1 , y1 = self . x1 + X , self . y1 + Y NEW_LINE self . add_line ( ( x1 , y1 ) , ( X , Y ) ) NEW_LINE # sink ▁ connector ENDCOM sink = self . get_sink ( ) NEW_LINE X , Y = sink . get_connector_coordinate ( ) NEW_LINE x2 , y2 = self . x2 + X , self . y2 + Y NEW_LINE self . add_line ( ( x2 , y2 ) , ( X , Y ) ) NEW_LINE # adjust ▁ arrow ENDCOM self . _arrow = [ ( x + X , y + Y ) for x , y in self . arrow ] NEW_LINE # add ▁ the ▁ horizontal ▁ and ▁ vertical ▁ lines ▁ in ▁ this ▁ connection ENDCOM if abs ( source . get_connector_direction ( ) - sink . get_connector_direction ( ) ) == 180 : NEW_LINE # 2 ▁ possible ▁ point ▁ sets ▁ to ▁ create ▁ a ▁ 3 - line ▁ connector ENDCOM INDENT mid_x , mid_y = ( x1 + x2 ) / 2.0 , ( y1 + y2 ) / 2.0 NEW_LINE points = [ ( ( mid_x , y1 ) , ( mid_x , y2 ) ) , ( ( x1 , mid_y ) , ( x2 , mid_y ) ) ] NEW_LINE # source ▁ connector ▁ - > ▁ points [ 0 ] [ 0 ] ▁ should ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ▁ ( if ▁ possible ) ENDCOM if Utils . get_angle_from_coordinates ( ( x1 , y1 ) , points [ 0 ] [ 0 ] ) != source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] [ 0 ] ▁ - > ▁ sink ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ sink ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] [ 0 ] , ( x2 , y2 ) ) == sink . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] [ 0 ] ▁ - > ▁ source ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] [ 0 ] , ( x1 , y1 ) ) == source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # create ▁ 3 - line ▁ connector ENDCOM p1 , p2 = map ( int , points [ 0 ] [ 0 ] ) , map ( int , points [ 0 ] [ 1 ] ) NEW_LINE self . add_line ( ( x1 , y1 ) , p1 ) NEW_LINE self . add_line ( p1 , p2 ) NEW_LINE self . add_line ( ( x2 , y2 ) , p2 ) NEW_LINE DEDENT else : NEW_LINE # 2 ▁ possible ▁ points ▁ to ▁ create ▁ a ▁ right - angled ▁ connector ENDCOM INDENT points = [ ( x1 , y2 ) , ( x2 , y1 ) ] NEW_LINE # source ▁ connector ▁ - > ▁ points [ 0 ] ▁ should ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ▁ ( if ▁ possible ) ENDCOM if Utils . get_angle_from_coordinates ( ( x1 , y1 ) , points [ 0 ] ) != source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] ▁ - > ▁ sink ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ sink ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] , ( x2 , y2 ) ) == sink . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # points [ 0 ] ▁ - > ▁ source ▁ connector ▁ should ▁ not ▁ be ▁ in ▁ the ▁ direction ▁ of ▁ source ENDCOM if Utils . get_angle_from_coordinates ( points [ 0 ] , ( x1 , y1 ) ) == source . get_connector_direction ( ) : points . reverse ( ) NEW_LINE # create ▁ right - angled ▁ connector ENDCOM self . add_line ( ( x1 , y1 ) , points [ 0 ] ) NEW_LINE self . add_line ( ( x2 , y2 ) , points [ 0 ] ) NEW_LINE DEDENT DEDENT def draw ( self , gc , window ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Draw ▁ the ▁ connection . STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ gc ▁ the ▁ graphics ▁ context STRNEWLINE TABSYMBOL TABSYMBOL @ param ▁ window ▁ the ▁ gtk ▁ window ▁ to ▁ draw ▁ on STRNEWLINE TABSYMBOL TABSYMBOL """ NEW_LINE sink = self . get_sink ( ) NEW_LINE source = self . get_source ( ) NEW_LINE # check ▁ for ▁ changes ENDCOM if self . _sink_rot != sink . get_rotation ( ) or self . _source_rot != source . get_rotation ( ) : self . create_shapes ( ) NEW_LINE elif self . _sink_coor != sink . get_coordinate ( ) or self . _source_coor != source . get_coordinate ( ) : self . _update_after_move ( ) NEW_LINE # cache ▁ values ENDCOM self . _sink_rot = sink . get_rotation ( ) NEW_LINE self . _source_rot = source . get_rotation ( ) NEW_LINE self . _sink_coor = sink . get_coordinate ( ) NEW_LINE self . _source_coor = source . get_coordinate ( ) NEW_LINE # draw ENDCOM if self . is_highlighted ( ) : border_color = Colors . HIGHLIGHT_COLOR NEW_LINE elif self . get_enabled ( ) : border_color = Colors . CONNECTION_ENABLED_COLOR NEW_LINE else : border_color = Colors . CONNECTION_DISABLED_COLOR NEW_LINE Element . draw ( self , gc , window , bg_color = None , border_color = border_color ) NEW_LINE # draw ▁ arrow ▁ on ▁ sink ▁ port ENDCOM gc . set_foreground ( self . _arrow_color ) NEW_LINE window . draw_polygon ( gc , True , self . _arrow ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="txemi/ansible/tree/master/test/units/parsing/yaml/test_dumper.py"> # ▁ coding : ▁ utf - 8 ENDCOM # ▁ This ▁ file ▁ is ▁ part ▁ of ▁ Ansible ENDCOM # ▁ Ansible ▁ is ▁ free ▁ software : ▁ you ▁ can ▁ redistribute ▁ it ▁ and / or ▁ modify ENDCOM # ▁ it ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ▁ as ▁ published ▁ by ENDCOM # ▁ the ▁ Free ▁ Software ▁ Foundation , ▁ either ▁ version ▁ 3 ▁ of ▁ the ▁ License , ▁ or ENDCOM # ▁ ( at ▁ your ▁ option ) ▁ any ▁ later ▁ version . ENDCOM # ▁ Ansible ▁ is ▁ distributed ▁ in ▁ the ▁ hope ▁ that ▁ it ▁ will ▁ be ▁ useful , ENDCOM # ▁ but ▁ WITHOUT ▁ ANY ▁ WARRANTY ; ▁ without ▁ even ▁ the ▁ implied ▁ warranty ▁ of ENDCOM # ▁ MERCHANTABILITY ▁ or ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE . ▁ See ▁ the ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ for ▁ more ▁ details . ENDCOM # ▁ You ▁ should ▁ have ▁ received ▁ a ▁ copy ▁ of ▁ the ▁ GNU ▁ General ▁ Public ▁ License ENDCOM # ▁ along ▁ with ▁ Ansible . ▁ If ▁ not , ▁ see ▁ < http : / / www . gnu . org / licenses / > . ENDCOM # ▁ Make ▁ coding ▁ more ▁ python3 - ish ENDCOM from __future__ import ( absolute_import , division , print_function ) NEW_LINE __metaclass__ = type NEW_LINE import io NEW_LINE import yaml NEW_LINE try : NEW_LINE INDENT from _yaml import ParserError NEW_LINE DEDENT except ImportError : NEW_LINE INDENT from yaml . parser import ParserError NEW_LINE DEDENT from ansible . parsing . yaml import dumper NEW_LINE from ansible . parsing . yaml . loader import AnsibleLoader NEW_LINE from ansible . compat . tests import unittest NEW_LINE from ansible . parsing . yaml import objects NEW_LINE from ansible . parsing import vault NEW_LINE from units . mock . yaml_helper import YamlTestUtils NEW_LINE class TestAnsibleDumper ( unittest . TestCase , YamlTestUtils ) : NEW_LINE INDENT def setUp ( self ) : NEW_LINE INDENT self . vault_password = " hunter42" NEW_LINE self . good_vault = vault . VaultLib ( self . vault_password ) NEW_LINE self . vault = self . good_vault NEW_LINE self . stream = self . _build_stream ( ) NEW_LINE self . dumper = dumper . AnsibleDumper NEW_LINE DEDENT def _build_stream ( self , yaml_text = None ) : NEW_LINE INDENT text = yaml_text or u ' ' NEW_LINE stream = io . StringIO ( text ) NEW_LINE return stream NEW_LINE DEDENT def _loader ( self , stream ) : NEW_LINE INDENT return AnsibleLoader ( stream , vault_password = self . vault_password ) NEW_LINE DEDENT def test ( self ) : NEW_LINE INDENT plaintext = ' This ▁ is ▁ a ▁ string ▁ we ▁ are ▁ going ▁ to ▁ encrypt . ' NEW_LINE avu = objects . AnsibleVaultEncryptedUnicode . from_plaintext ( plaintext , vault = self . vault ) NEW_LINE yaml_out = self . _dump_string ( avu , dumper = self . dumper ) NEW_LINE stream = self . _build_stream ( yaml_out ) NEW_LINE loader = self . _loader ( stream ) NEW_LINE data_from_yaml = loader . get_single_data ( ) NEW_LINE self . assertEquals ( plaintext , data_from_yaml . data ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="andybab/Impala/tree/master/tests/util/hdfs_util.py"> # ! / usr / bin / env ▁ python ENDCOM # ▁ Copyright ▁ ( c ) ▁ 2012 ▁ Cloudera , ▁ Inc . ▁ All ▁ rights ▁ reserved . ENDCOM # ▁ Licensed ▁ under ▁ the ▁ Apache ▁ License , ▁ Version ▁ 2.0 ▁ ( the ▁ " License " ) ; ENDCOM # ▁ you ▁ may ▁ not ▁ use ▁ this ▁ file ▁ except ▁ in ▁ compliance ▁ with ▁ the ▁ License . ENDCOM # ▁ You ▁ may ▁ obtain ▁ a ▁ copy ▁ of ▁ the ▁ License ▁ at ENDCOM # ▁ http : / / www . apache . org / licenses / LICENSE - 2.0 ENDCOM # ▁ Unless ▁ required ▁ by ▁ applicable ▁ law ▁ or ▁ agreed ▁ to ▁ in ▁ writing , ▁ software ENDCOM # ▁ distributed ▁ under ▁ the ▁ License ▁ is ▁ distributed ▁ on ▁ an ▁ " AS ▁ IS " ▁ BASIS , ENDCOM # ▁ WITHOUT ▁ WARRANTIES ▁ OR ▁ CONDITIONS ▁ OF ▁ ANY ▁ KIND , ▁ either ▁ express ▁ or ▁ implied . ENDCOM # ▁ See ▁ the ▁ License ▁ for ▁ the ▁ specific ▁ language ▁ governing ▁ permissions ▁ and ENDCOM # ▁ limitations ▁ under ▁ the ▁ License . ENDCOM # ▁ Hdfs ▁ access ▁ utilities ENDCOM from xml . etree . ElementTree import parse NEW_LINE from pywebhdfs . webhdfs import PyWebHdfsClient , errors , _raise_pywebhdfs_exception NEW_LINE import getpass NEW_LINE import types NEW_LINE import requests , httplib NEW_LINE class PyWebHdfsClientWithChmod ( PyWebHdfsClient ) : NEW_LINE INDENT def chmod ( self , path , permission ) : NEW_LINE INDENT """ Set ▁ the ▁ permission ▁ of ▁ ' path ' ▁ to ▁ ' permission ' ▁ ( specified ▁ as ▁ an ▁ octal ▁ string , ▁ e . g . STRNEWLINE ▁ ' 775 ' """ NEW_LINE uri = self . _create_uri ( path , " SETPERMISSION " , permission = permission ) NEW_LINE response = requests . put ( uri , allow_redirects = True ) NEW_LINE if not response . status_code == httplib . OK : NEW_LINE INDENT _raise_pywebhdfs_exception ( response . status_code , response . text ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT class HdfsConfig ( object ) : NEW_LINE INDENT """ Reads ▁ an ▁ XML ▁ configuration ▁ file ▁ ( produced ▁ by ▁ a ▁ mini - cluster ) ▁ into ▁ a ▁ dictionary STRNEWLINE ▁ accessible ▁ via ▁ get ( ) """ NEW_LINE def __init__ ( self , filename ) : NEW_LINE INDENT self . conf = { } NEW_LINE tree = parse ( filename ) NEW_LINE for property in tree . getroot ( ) . getiterator ( ' property ' ) : NEW_LINE INDENT self . conf [ property . find ( ' name ' ) . text ] = property . find ( ' value ' ) . text NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT return self . conf . get ( key ) NEW_LINE DEDENT DEDENT def get_hdfs_client_from_conf ( conf ) : NEW_LINE INDENT """ Returns ▁ a ▁ new ▁ HTTP ▁ client ▁ for ▁ an ▁ HDFS ▁ cluster ▁ using ▁ an ▁ HdfsConfig ▁ object """ NEW_LINE hostport = conf . get ( ' dfs . namenode . http - address ' ) NEW_LINE if hostport is None : NEW_LINE INDENT raise Exception ( " dfs . namenode . http - address ▁ not ▁ found ▁ in ▁ config " ) NEW_LINE DEDENT host , port = hostport . split ( " : " ) NEW_LINE return get_hdfs_client ( host = host , port = port ) NEW_LINE DEDENT def __pyweb_hdfs_client_exists ( self , path ) : NEW_LINE INDENT """ The ▁ PyWebHdfsClient ▁ doesn ' t ▁ provide ▁ an ▁ API ▁ to ▁ cleanly ▁ detect ▁ if ▁ a ▁ file ▁ or ▁ directory STRNEWLINE ▁ exists . ▁ This ▁ method ▁ is ▁ bound ▁ to ▁ each ▁ client ▁ that ▁ is ▁ created ▁ so ▁ tests ▁ can ▁ simply ▁ call STRNEWLINE ▁ hdfs _ client . exists ( ' path ' ) ▁ and ▁ get ▁ back ▁ a ▁ bool . STRNEWLINE ▁ """ NEW_LINE try : NEW_LINE INDENT self . get_file_dir_status ( path ) NEW_LINE DEDENT except errors . FileNotFound : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def get_hdfs_client ( host , port , user_name = getpass . getuser ( ) ) : NEW_LINE INDENT """ Returns ▁ a ▁ new ▁ HTTP ▁ client ▁ for ▁ an ▁ HDFS ▁ cluster ▁ using ▁ an ▁ explict ▁ host : port ▁ pair """ NEW_LINE hdfs_client = PyWebHdfsClientWithChmod ( host = host , port = port , user_name = user_name ) NEW_LINE # ▁ Bind ▁ our ▁ " exists " ▁ method ▁ to ▁ hdfs _ client . exists ENDCOM hdfs_client . exists = types . MethodType ( __pyweb_hdfs_client_exists , hdfs_client ) NEW_LINE return hdfs_client NEW_LINE DEDENT </DOCUMENT>
<DOCUMENT_ID="jasonseminara/OpenSourceFinal/tree/master/myvenv/lib/python3.5/site-packages/django/template/smartif.py"> """ STRNEWLINE Parser ▁ and ▁ utilities ▁ for ▁ the ▁ smart ▁ ' if ' ▁ tag STRNEWLINE """ NEW_LINE import warnings NEW_LINE from django . utils . deprecation import RemovedInDjango110Warning NEW_LINE # ▁ Using ▁ a ▁ simple ▁ top ▁ down ▁ parser , ▁ as ▁ described ▁ here : ENDCOM # ▁ http : / / effbot . org / zone / simple - top - down - parsing . htm . ENDCOM # ▁ ' led ' ▁ = ▁ left ▁ denotation ENDCOM # ▁ ' nud ' ▁ = ▁ null ▁ denotation ENDCOM # ▁ ' bp ' ▁ = ▁ binding ▁ power ▁ ( left ▁ = ▁ lbp , ▁ right ▁ = ▁ rbp ) ENDCOM class TokenBase ( object ) : NEW_LINE INDENT """ STRNEWLINE ▁ Base ▁ class ▁ for ▁ operators ▁ and ▁ literals , ▁ mainly ▁ for ▁ debugging ▁ and ▁ for ▁ throwing STRNEWLINE ▁ syntax ▁ errors . STRNEWLINE ▁ """ NEW_LINE id = None # ▁ node / token ▁ type ▁ name ENDCOM NEW_LINE value = None # ▁ used ▁ by ▁ literals ENDCOM NEW_LINE first = second = None # ▁ used ▁ by ▁ tree ▁ nodes ENDCOM NEW_LINE def nud ( self , parser ) : NEW_LINE # ▁ Null ▁ denotation ▁ - ▁ called ▁ in ▁ prefix ▁ context ENDCOM INDENT raise parser . error_class ( " Not ▁ expecting ▁ ' % s ' ▁ in ▁ this ▁ position ▁ in ▁ if ▁ tag . " % self . id ) NEW_LINE DEDENT def led ( self , left , parser ) : NEW_LINE # ▁ Left ▁ denotation ▁ - ▁ called ▁ in ▁ infix ▁ context ENDCOM INDENT raise parser . error_class ( " Not ▁ expecting ▁ ' % s ' ▁ as ▁ infix ▁ operator ▁ in ▁ if ▁ tag . " % self . id ) NEW_LINE DEDENT def display ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ what ▁ to ▁ display ▁ in ▁ error ▁ messages ▁ for ▁ this ▁ node STRNEWLINE ▁ """ NEW_LINE return self . id NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT out = [ str ( x ) for x in [ self . id , self . first , self . second ] if x is not None ] NEW_LINE return " ( " + " ▁ " . join ( out ) + " ) " NEW_LINE DEDENT DEDENT def infix ( bp , func ) : NEW_LINE INDENT """ STRNEWLINE ▁ Creates ▁ an ▁ infix ▁ operator , ▁ given ▁ a ▁ binding ▁ power ▁ and ▁ a ▁ function ▁ that STRNEWLINE ▁ evaluates ▁ the ▁ node STRNEWLINE ▁ """ NEW_LINE class Operator ( TokenBase ) : NEW_LINE INDENT lbp = bp NEW_LINE def led ( self , left , parser ) : NEW_LINE INDENT self . first = left NEW_LINE self . second = parser . expression ( bp ) NEW_LINE return self NEW_LINE DEDENT def eval ( self , context ) : NEW_LINE INDENT try : NEW_LINE INDENT return func ( context , self . first , self . second ) NEW_LINE DEDENT except Exception : NEW_LINE # ▁ Templates ▁ shouldn ' t ▁ throw ▁ exceptions ▁ when ▁ rendering . ▁ We ▁ are ENDCOM # ▁ most ▁ likely ▁ to ▁ get ▁ exceptions ▁ for ▁ things ▁ like ▁ { % ▁ if ▁ foo ▁ in ▁ bar ENDCOM # ▁ % } ▁ where ▁ ' bar ' ▁ does ▁ not ▁ support ▁ ' in ' , ▁ so ▁ default ▁ to ▁ False ENDCOM INDENT return False NEW_LINE DEDENT DEDENT DEDENT return Operator NEW_LINE DEDENT def prefix ( bp , func ) : NEW_LINE INDENT """ STRNEWLINE ▁ Creates ▁ a ▁ prefix ▁ operator , ▁ given ▁ a ▁ binding ▁ power ▁ and ▁ a ▁ function ▁ that STRNEWLINE ▁ evaluates ▁ the ▁ node . STRNEWLINE ▁ """ NEW_LINE class Operator ( TokenBase ) : NEW_LINE INDENT lbp = bp NEW_LINE def nud ( self , parser ) : NEW_LINE INDENT self . first = parser . expression ( bp ) NEW_LINE self . second = None NEW_LINE return self NEW_LINE DEDENT def eval ( self , context ) : NEW_LINE INDENT try : NEW_LINE INDENT return func ( context , self . first ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return Operator NEW_LINE # ▁ Operator ▁ precedence ▁ follows ▁ Python . ENDCOM # ▁ NB ▁ - ▁ we ▁ can ▁ get ▁ slightly ▁ more ▁ accurate ▁ syntax ▁ error ▁ messages ▁ by ▁ not ▁ using ▁ the ENDCOM # ▁ same ▁ object ▁ for ▁ ' = = ' ▁ and ▁ ' = ' . ENDCOM # ▁ We ▁ defer ▁ variable ▁ evaluation ▁ to ▁ the ▁ lambda ▁ to ▁ ensure ▁ that ▁ terms ▁ are ENDCOM # ▁ lazily ▁ evaluated ▁ using ▁ Python ' s ▁ boolean ▁ parsing ▁ logic . ENDCOM DEDENT OPERATORS = { ' or ' : infix ( 6 , lambda context , x , y : x . eval ( context ) or y . eval ( context ) ) , ' and ' : infix ( 7 , lambda context , x , y : x . eval ( context ) and y . eval ( context ) ) , ' not ' : prefix ( 8 , lambda context , x : not x . eval ( context ) ) , ' in ' : infix ( 9 , lambda context , x , y : x . eval ( context ) in y . eval ( context ) ) , ' not ▁ in ' : infix ( 9 , lambda context , x , y : x . eval ( context ) not in y . eval ( context ) ) , # ▁ This ▁ should ▁ be ▁ removed ▁ in ▁ Django ▁ 1.10 : ENDCOM ' = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) , ' = = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) , ' ! = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) != y . eval ( context ) ) , ' > ' : infix ( 10 , lambda context , x , y : x . eval ( context ) > y . eval ( context ) ) , ' > = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) >= y . eval ( context ) ) , ' < ' : infix ( 10 , lambda context , x , y : x . eval ( context ) < y . eval ( context ) ) , ' < = ' : infix ( 10 , lambda context , x , y : x . eval ( context ) <= y . eval ( context ) ) , } NEW_LINE # ▁ Assign ▁ ' id ' ▁ to ▁ each : ENDCOM for key , op in OPERATORS . items ( ) : NEW_LINE INDENT op . id = key NEW_LINE DEDENT class Literal ( TokenBase ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ basic ▁ self - resolvable ▁ object ▁ similar ▁ to ▁ a ▁ Django ▁ template ▁ variable . STRNEWLINE ▁ """ NEW_LINE # ▁ IfParser ▁ uses ▁ Literal ▁ in ▁ create _ var , ▁ but ▁ TemplateIfParser ▁ overrides ENDCOM # ▁ create _ var ▁ so ▁ that ▁ a ▁ proper ▁ implementation ▁ that ▁ actually ▁ resolves ENDCOM # ▁ variables , ▁ filters ▁ etc ▁ is ▁ used . ENDCOM id = " literal " NEW_LINE lbp = 0 NEW_LINE def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE DEDENT def display ( self ) : NEW_LINE INDENT return repr ( self . value ) NEW_LINE DEDENT def nud ( self , parser ) : NEW_LINE INDENT return self NEW_LINE DEDENT def eval ( self , context ) : NEW_LINE INDENT return self . value NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " ( % s ▁ % r ) " % ( self . id , self . value ) NEW_LINE DEDENT DEDENT class EndToken ( TokenBase ) : NEW_LINE INDENT lbp = 0 NEW_LINE def nud ( self , parser ) : NEW_LINE INDENT raise parser . error_class ( " Unexpected ▁ end ▁ of ▁ expression ▁ in ▁ if ▁ tag . " ) NEW_LINE DEDENT DEDENT EndToken = EndToken ( ) NEW_LINE class IfParser ( object ) : NEW_LINE INDENT error_class = ValueError NEW_LINE def __init__ ( self , tokens ) : NEW_LINE # ▁ pre - pass ▁ necessary ▁ to ▁ turn ▁ ' not ' , ' in ' ▁ into ▁ single ▁ token ENDCOM INDENT l = len ( tokens ) NEW_LINE mapped_tokens = [ ] NEW_LINE i = 0 NEW_LINE while i < l : NEW_LINE INDENT token = tokens [ i ] NEW_LINE if token == " not " and i + 1 < l and tokens [ i + 1 ] == " in " : NEW_LINE INDENT token = " not ▁ in " NEW_LINE i += 1 # ▁ skip ▁ ' in ' ENDCOM NEW_LINE DEDENT mapped_tokens . append ( self . translate_token ( token ) ) NEW_LINE i += 1 NEW_LINE DEDENT self . tokens = mapped_tokens NEW_LINE self . pos = 0 NEW_LINE self . current_token = self . next_token ( ) NEW_LINE DEDENT def translate_token ( self , token ) : NEW_LINE INDENT try : NEW_LINE INDENT op = OPERATORS [ token ] NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT return self . create_var ( token ) NEW_LINE DEDENT else : NEW_LINE INDENT if token == ' = ' : NEW_LINE INDENT warnings . warn ( " Operator ▁ ' = ' ▁ is ▁ deprecated ▁ and ▁ will ▁ be ▁ removed ▁ in ▁ Django ▁ 1.10 . ▁ Use ▁ ' = = ' ▁ instead . " , RemovedInDjango110Warning , stacklevel = 2 ) NEW_LINE DEDENT return op ( ) NEW_LINE DEDENT DEDENT def next_token ( self ) : NEW_LINE INDENT if self . pos >= len ( self . tokens ) : NEW_LINE INDENT return EndToken NEW_LINE DEDENT else : NEW_LINE INDENT retval = self . tokens [ self . pos ] NEW_LINE self . pos += 1 NEW_LINE return retval NEW_LINE DEDENT DEDENT def parse ( self ) : NEW_LINE INDENT retval = self . expression ( ) NEW_LINE # ▁ Check ▁ that ▁ we ▁ have ▁ exhausted ▁ all ▁ the ▁ tokens ENDCOM if self . current_token is not EndToken : NEW_LINE INDENT raise self . error_class ( " Unused ▁ ' % s ' ▁ at ▁ end ▁ of ▁ if ▁ expression . " % self . current_token . display ( ) ) NEW_LINE DEDENT return retval NEW_LINE DEDENT def expression ( self , rbp = 0 ) : NEW_LINE INDENT t = self . current_token NEW_LINE self . current_token = self . next_token ( ) NEW_LINE left = t . nud ( self ) NEW_LINE while rbp < self . current_token . lbp : NEW_LINE INDENT t = self . current_token NEW_LINE self . current_token = self . next_token ( ) NEW_LINE left = t . led ( left , self ) NEW_LINE DEDENT return left NEW_LINE DEDENT def create_var ( self , value ) : NEW_LINE INDENT return Literal ( value ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="sbstp/streamlink/tree/master/src/streamlink/plugins/alieztv.py"> import re NEW_LINE from os . path import splitext NEW_LINE from streamlink . compat import urlparse , unquote NEW_LINE from streamlink . plugin import Plugin NEW_LINE from streamlink . plugin . api import http , validate NEW_LINE from streamlink . stream import HTTPStream , RTMPStream NEW_LINE _url_re = re . compile ( """ STRNEWLINE ▁ ▁ ▁ ▁ http ( s ) ? : / / ( \w + \ . ) ? aliez . tv STRNEWLINE ▁ ▁ ▁ ▁ ( ? : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ / live / [ ^ / ] + STRNEWLINE ▁ ▁ ▁ ▁ ) ? STRNEWLINE ▁ ▁ ▁ ▁ ( ? : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ / video / \d + / [ ^ / ] + STRNEWLINE ▁ ▁ ▁ ▁ ) ? STRNEWLINE """ , re . VERBOSE ) NEW_LINE _file_re = re . compile ( " \ " ? file\ " ? : \s + [ ' \ " ] ( [ ^ ' \ " ] + ) [ ' \ " ] " ) NEW_LINE _swf_url_re = re . compile ( " swfobject . embedSWF\ ( \ " ( [ ^ \ " ] + ) \ " , " ) NEW_LINE _schema = validate . Schema ( validate . union ( { " urls " : validate . all ( validate . transform ( _file_re . findall ) , validate . map ( unquote ) , [ validate . url ( ) ] ) , " swf " : validate . all ( validate . transform ( _swf_url_re . search ) , validate . any ( None , validate . all ( validate . get ( 1 ) , validate . url ( scheme = " http " , path = validate . endswith ( " swf " ) ) ) ) ) } ) ) NEW_LINE class Aliez ( Plugin ) : NEW_LINE INDENT @ classmethod NEW_LINE def can_handle_url ( self , url ) : NEW_LINE INDENT return _url_re . match ( url ) NEW_LINE DEDENT def _get_streams ( self ) : NEW_LINE INDENT res = http . get ( self . url , schema = _schema ) NEW_LINE streams = { } NEW_LINE for url in res [ " urls " ] : NEW_LINE INDENT parsed = urlparse ( url ) NEW_LINE if parsed . scheme . startswith ( " rtmp " ) : NEW_LINE INDENT params = { " rtmp " : url , " pageUrl " : self . url , " live " : True } NEW_LINE if res [ " swf " ] : NEW_LINE INDENT params [ " swfVfy " ] = res [ " swf " ] NEW_LINE DEDENT stream = RTMPStream ( self . session , params ) NEW_LINE streams [ " live " ] = stream NEW_LINE DEDENT elif parsed . scheme . startswith ( " http " ) : NEW_LINE INDENT name = splitext ( parsed . path ) [ 1 ] [ 1 : ] NEW_LINE stream = HTTPStream ( self . session , url ) NEW_LINE streams [ name ] = stream NEW_LINE DEDENT DEDENT return streams NEW_LINE DEDENT DEDENT __plugin__ = Aliez NEW_LINE </DOCUMENT>
<DOCUMENT_ID="thomasgilgenast/gilgistatus-nonrel/tree/master/django/db/backends/creation.py"> import sys NEW_LINE import time NEW_LINE from django . conf import settings NEW_LINE from django . utils . datastructures import DictWrapper NEW_LINE # ▁ The ▁ prefix ▁ to ▁ put ▁ on ▁ the ▁ default ▁ database ▁ name ▁ when ▁ creating ENDCOM # ▁ the ▁ test ▁ database . ENDCOM TEST_DATABASE_PREFIX = ' test _ ' NEW_LINE class BaseDatabaseCreation ( object ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ class ▁ encapsulates ▁ all ▁ backend - specific ▁ differences ▁ that ▁ pertain ▁ to STRNEWLINE ▁ database ▁ * creation * , ▁ such ▁ as ▁ the ▁ column ▁ types ▁ to ▁ use ▁ for ▁ particular ▁ Django STRNEWLINE ▁ Fields , ▁ the ▁ SQL ▁ used ▁ to ▁ create ▁ and ▁ destroy ▁ tables , ▁ and ▁ the ▁ creation ▁ and STRNEWLINE ▁ destruction ▁ of ▁ test ▁ databases . STRNEWLINE ▁ """ NEW_LINE data_types = { } NEW_LINE def __init__ ( self , connection ) : NEW_LINE INDENT self . connection = connection NEW_LINE DEDENT def _digest ( self , * args ) : NEW_LINE INDENT """ STRNEWLINE ▁ Generates ▁ a ▁ 32 - bit ▁ digest ▁ of ▁ a ▁ set ▁ of ▁ arguments ▁ that ▁ can ▁ be ▁ used ▁ to STRNEWLINE ▁ shorten ▁ identifying ▁ names . STRNEWLINE ▁ """ NEW_LINE return ' % x ' % ( abs ( hash ( args ) ) % 4294967296 L ) # ▁ 2 * * 32 ENDCOM NEW_LINE DEDENT def db_type ( self , field ) : NEW_LINE INDENT return self . _db_type ( field , field . get_internal_type ( ) ) NEW_LINE DEDENT def related_db_type ( self , field ) : NEW_LINE INDENT return self . _db_type ( field , field . get_related_internal_type ( ) ) NEW_LINE DEDENT def _db_type ( self , field , internal_type ) : NEW_LINE INDENT data = DictWrapper ( field . __dict__ , self . connection . ops . quote_name , " qn _ " ) NEW_LINE try : NEW_LINE INDENT return self . connection . creation . data_types [ internal_type ] % data NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT def sql_create_model ( self , model , style , known_models = set ( ) ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ the ▁ SQL ▁ required ▁ to ▁ create ▁ a ▁ single ▁ model , ▁ as ▁ a ▁ tuple ▁ of : STRNEWLINE ▁ ( list _ of _ sql , ▁ pending _ references _ dict ) STRNEWLINE ▁ """ NEW_LINE opts = model . _meta NEW_LINE if not opts . managed or opts . proxy : NEW_LINE INDENT return [ ] , { } NEW_LINE DEDENT final_output = [ ] NEW_LINE table_output = [ ] NEW_LINE pending_references = { } NEW_LINE qn = self . connection . ops . quote_name NEW_LINE for f in opts . local_fields : NEW_LINE INDENT col_type = f . db_type ( connection = self . connection ) NEW_LINE tablespace = f . db_tablespace or opts . db_tablespace NEW_LINE if col_type is None : NEW_LINE # ▁ Skip ▁ ManyToManyFields , ▁ because ▁ they ' re ▁ not ▁ represented ▁ as ENDCOM # ▁ database ▁ columns ▁ in ▁ this ▁ table . ENDCOM INDENT continue NEW_LINE # ▁ Make ▁ the ▁ definition ▁ ( e . g . ▁ ' foo ▁ VARCHAR ( 30 ) ' ) ▁ for ▁ this ▁ field . ENDCOM DEDENT field_output = [ style . SQL_FIELD ( qn ( f . column ) ) , style . SQL_COLTYPE ( col_type ) ] NEW_LINE if not f . null : NEW_LINE INDENT field_output . append ( style . SQL_KEYWORD ( ' NOT ▁ NULL ' ) ) NEW_LINE DEDENT if f . primary_key : NEW_LINE INDENT field_output . append ( style . SQL_KEYWORD ( ' PRIMARY ▁ KEY ' ) ) NEW_LINE DEDENT elif f . unique : NEW_LINE INDENT field_output . append ( style . SQL_KEYWORD ( ' UNIQUE ' ) ) NEW_LINE DEDENT if tablespace and f . unique : NEW_LINE # ▁ We ▁ must ▁ specify ▁ the ▁ index ▁ tablespace ▁ inline , ▁ because ▁ we ENDCOM # ▁ won ' t ▁ be ▁ generating ▁ a ▁ CREATE ▁ INDEX ▁ statement ▁ for ▁ this ▁ field . ENDCOM INDENT field_output . append ( self . connection . ops . tablespace_sql ( tablespace , inline = True ) ) NEW_LINE DEDENT if f . rel : NEW_LINE INDENT ref_output , pending = self . sql_for_inline_foreign_key_references ( f , known_models , style ) NEW_LINE if pending : NEW_LINE INDENT pr = pending_references . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) ) NEW_LINE DEDENT else : NEW_LINE INDENT field_output . extend ( ref_output ) NEW_LINE DEDENT DEDENT table_output . append ( ' ▁ ' . join ( field_output ) ) NEW_LINE DEDENT for field_constraints in opts . unique_together : NEW_LINE INDENT table_output . append ( style . SQL_KEYWORD ( ' UNIQUE ' ) + ' ▁ ( % s ) ' % " , ▁ " . join ( [ style . SQL_FIELD ( qn ( opts . get_field ( f ) . column ) ) for f in field_constraints ] ) ) NEW_LINE DEDENT full_statement = [ style . SQL_KEYWORD ( ' CREATE ▁ TABLE ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( opts . db_table ) ) + ' ▁ ( ' ] NEW_LINE for i , line in enumerate ( table_output ) : # ▁ Combine ▁ and ▁ add ▁ commas . ENDCOM NEW_LINE INDENT full_statement . append ( ' ▁ ▁ ▁ ▁ % s % s ' % ( line , i < len ( table_output ) - 1 and ' , ' or ' ' ) ) NEW_LINE DEDENT full_statement . append ( ' ) ' ) NEW_LINE if opts . db_tablespace : NEW_LINE INDENT full_statement . append ( self . connection . ops . tablespace_sql ( opts . db_tablespace ) ) NEW_LINE DEDENT full_statement . append ( ' ; ' ) NEW_LINE final_output . append ( ' \n ' . join ( full_statement ) ) NEW_LINE if opts . has_auto_field : NEW_LINE # ▁ Add ▁ any ▁ extra ▁ SQL ▁ needed ▁ to ▁ support ▁ auto - incrementing ▁ primary ▁ keys . ENDCOM INDENT auto_column = opts . auto_field . db_column or opts . auto_field . name NEW_LINE autoinc_sql = self . connection . ops . autoinc_sql ( opts . db_table , auto_column ) NEW_LINE if autoinc_sql : NEW_LINE INDENT for stmt in autoinc_sql : NEW_LINE INDENT final_output . append ( stmt ) NEW_LINE DEDENT DEDENT DEDENT return final_output , pending_references NEW_LINE DEDENT def sql_for_inline_foreign_key_references ( self , field , known_models , style ) : NEW_LINE INDENT " Return ▁ the ▁ SQL ▁ snippet ▁ defining ▁ the ▁ foreign ▁ key ▁ reference ▁ for ▁ a ▁ field " NEW_LINE qn = self . connection . ops . quote_name NEW_LINE if field . rel . to in known_models : NEW_LINE INDENT output = [ style . SQL_KEYWORD ( ' REFERENCES ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( field . rel . to . _meta . db_table ) ) + ' ▁ ( ' + style . SQL_FIELD ( qn ( field . rel . to . _meta . get_field ( field . rel . field_name ) . column ) ) + ' ) ' + self . connection . ops . deferrable_sql ( ) ] NEW_LINE pending = False NEW_LINE DEDENT else : NEW_LINE # ▁ We ▁ haven ' t ▁ yet ▁ created ▁ the ▁ table ▁ to ▁ which ▁ this ▁ field ENDCOM # ▁ is ▁ related , ▁ so ▁ save ▁ it ▁ for ▁ later . ENDCOM INDENT output = [ ] NEW_LINE pending = True NEW_LINE DEDENT return output , pending NEW_LINE DEDENT def sql_for_pending_references ( self , model , style , pending_references ) : NEW_LINE INDENT " Returns ▁ any ▁ ALTER ▁ TABLE ▁ statements ▁ to ▁ add ▁ constraints ▁ after ▁ the ▁ fact . " NEW_LINE from django . db . backends . util import truncate_name NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE DEDENT qn = self . connection . ops . quote_name NEW_LINE final_output = [ ] NEW_LINE opts = model . _meta NEW_LINE if model in pending_references : NEW_LINE INDENT for rel_class , f in pending_references [ model ] : NEW_LINE INDENT rel_opts = rel_class . _meta NEW_LINE r_table = rel_opts . db_table NEW_LINE r_col = f . column NEW_LINE table = opts . db_table NEW_LINE col = opts . get_field ( f . rel . field_name ) . column NEW_LINE # ▁ For ▁ MySQL , ▁ r _ name ▁ must ▁ be ▁ unique ▁ in ▁ the ▁ first ▁ 64 ▁ characters . ENDCOM # ▁ So ▁ we ▁ are ▁ careful ▁ with ▁ character ▁ usage ▁ here . ENDCOM r_name = ' % s _ refs _ % s _ % s ' % ( r_col , col , self . _digest ( r_table , table ) ) NEW_LINE final_output . append ( style . SQL_KEYWORD ( ' ALTER ▁ TABLE ' ) + ' ▁ % s ▁ ADD ▁ CONSTRAINT ▁ % s ▁ FOREIGN ▁ KEY ▁ ( % s ) ▁ REFERENCES ▁ % s ▁ ( % s ) % s ; ' % ( qn ( r_table ) , qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) , qn ( r_col ) , qn ( table ) , qn ( col ) , self . connection . ops . deferrable_sql ( ) ) ) NEW_LINE DEDENT del pending_references [ model ] NEW_LINE DEDENT return final_output NEW_LINE DEDENT def sql_for_many_to_many ( self , model , style ) : NEW_LINE INDENT " Return ▁ the ▁ CREATE ▁ TABLE ▁ statments ▁ for ▁ all ▁ the ▁ many - to - many ▁ tables ▁ defined ▁ on ▁ a ▁ model " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE output = [ ] NEW_LINE for f in model . _meta . local_many_to_many : NEW_LINE INDENT if model . _meta . managed or f . rel . to . _meta . managed : NEW_LINE INDENT output . extend ( self . sql_for_many_to_many_field ( model , f , style ) ) NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT def sql_for_many_to_many_field ( self , model , f , style ) : NEW_LINE INDENT " Return ▁ the ▁ CREATE ▁ TABLE ▁ statements ▁ for ▁ a ▁ single ▁ m2m ▁ field " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE from django . db import models NEW_LINE from django . db . backends . util import truncate_name NEW_LINE output = [ ] NEW_LINE if f . auto_created : NEW_LINE INDENT opts = model . _meta NEW_LINE qn = self . connection . ops . quote_name NEW_LINE tablespace = f . db_tablespace or opts . db_tablespace NEW_LINE if tablespace : NEW_LINE INDENT sql = self . connection . ops . tablespace_sql ( tablespace , inline = True ) NEW_LINE if sql : NEW_LINE INDENT tablespace_sql = ' ▁ ' + sql NEW_LINE DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT table_output = [ style . SQL_KEYWORD ( ' CREATE ▁ TABLE ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( f . m2m_db_table ( ) ) ) + ' ▁ ( ' ] NEW_LINE table_output . append ( ' ▁ ▁ ▁ ▁ % s ▁ % s ▁ % s % s , ' % ( style . SQL_FIELD ( qn ( ' id ' ) ) , style . SQL_COLTYPE ( models . AutoField ( primary_key = True ) . db_type ( connection = self . connection ) ) , style . SQL_KEYWORD ( ' NOT ▁ NULL ▁ PRIMARY ▁ KEY ' ) , tablespace_sql ) ) NEW_LINE deferred = [ ] NEW_LINE inline_output , deferred = self . sql_for_inline_many_to_many_references ( model , f , style ) NEW_LINE table_output . extend ( inline_output ) NEW_LINE table_output . append ( ' ▁ ▁ ▁ ▁ % s ▁ ( % s , ▁ % s ) % s ' % ( style . SQL_KEYWORD ( ' UNIQUE ' ) , style . SQL_FIELD ( qn ( f . m2m_column_name ( ) ) ) , style . SQL_FIELD ( qn ( f . m2m_reverse_name ( ) ) ) , tablespace_sql ) ) NEW_LINE table_output . append ( ' ) ' ) NEW_LINE if opts . db_tablespace : NEW_LINE # ▁ f . db _ tablespace ▁ is ▁ only ▁ for ▁ indices , ▁ so ▁ ignore ▁ its ▁ value ▁ here . ENDCOM INDENT table_output . append ( self . connection . ops . tablespace_sql ( opts . db_tablespace ) ) NEW_LINE DEDENT table_output . append ( ' ; ' ) NEW_LINE output . append ( ' \n ' . join ( table_output ) ) NEW_LINE for r_table , r_col , table , col in deferred : NEW_LINE INDENT r_name = ' % s _ refs _ % s _ % s ' % ( r_col , col , self . _digest ( r_table , table ) ) NEW_LINE output . append ( style . SQL_KEYWORD ( ' ALTER ▁ TABLE ' ) + ' ▁ % s ▁ ADD ▁ CONSTRAINT ▁ % s ▁ FOREIGN ▁ KEY ▁ ( % s ) ▁ REFERENCES ▁ % s ▁ ( % s ) % s ; ' % ( qn ( r_table ) , qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) , qn ( r_col ) , qn ( table ) , qn ( col ) , self . connection . ops . deferrable_sql ( ) ) ) NEW_LINE # ▁ Add ▁ any ▁ extra ▁ SQL ▁ needed ▁ to ▁ support ▁ auto - incrementing ▁ PKs ENDCOM DEDENT autoinc_sql = self . connection . ops . autoinc_sql ( f . m2m_db_table ( ) , ' id ' ) NEW_LINE if autoinc_sql : NEW_LINE INDENT for stmt in autoinc_sql : NEW_LINE INDENT output . append ( stmt ) NEW_LINE DEDENT DEDENT DEDENT return output NEW_LINE DEDENT def sql_for_inline_many_to_many_references ( self , model , field , style ) : NEW_LINE INDENT " Create ▁ the ▁ references ▁ to ▁ other ▁ tables ▁ required ▁ by ▁ a ▁ many - to - many ▁ table " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE from django . db import models NEW_LINE opts = model . _meta NEW_LINE qn = self . connection . ops . quote_name NEW_LINE table_output = [ ' ▁ ▁ ▁ ▁ % s ▁ % s ▁ % s ▁ % s ▁ ( % s ) % s , ' % ( style . SQL_FIELD ( qn ( field . m2m_column_name ( ) ) ) , style . SQL_COLTYPE ( models . ForeignKey ( model ) . db_type ( connection = self . connection ) ) , style . SQL_KEYWORD ( ' NOT ▁ NULL ▁ REFERENCES ' ) , style . SQL_TABLE ( qn ( opts . db_table ) ) , style . SQL_FIELD ( qn ( opts . pk . column ) ) , self . connection . ops . deferrable_sql ( ) ) , ' ▁ ▁ ▁ ▁ % s ▁ % s ▁ % s ▁ % s ▁ ( % s ) % s , ' % ( style . SQL_FIELD ( qn ( field . m2m_reverse_name ( ) ) ) , style . SQL_COLTYPE ( models . ForeignKey ( field . rel . to ) . db_type ( connection = self . connection ) ) , style . SQL_KEYWORD ( ' NOT ▁ NULL ▁ REFERENCES ' ) , style . SQL_TABLE ( qn ( field . rel . to . _meta . db_table ) ) , style . SQL_FIELD ( qn ( field . rel . to . _meta . pk . column ) ) , self . connection . ops . deferrable_sql ( ) ) ] NEW_LINE deferred = [ ] NEW_LINE return table_output , deferred NEW_LINE DEDENT def sql_indexes_for_model ( self , model , style ) : NEW_LINE INDENT " Returns ▁ the ▁ CREATE ▁ INDEX ▁ SQL ▁ statements ▁ for ▁ a ▁ single ▁ model " NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE DEDENT output = [ ] NEW_LINE for f in model . _meta . local_fields : NEW_LINE INDENT output . extend ( self . sql_indexes_for_field ( model , f , style ) ) NEW_LINE DEDENT return output NEW_LINE DEDENT def sql_indexes_for_field ( self , model , f , style ) : NEW_LINE INDENT " Return ▁ the ▁ CREATE ▁ INDEX ▁ SQL ▁ statements ▁ for ▁ a ▁ single ▁ model ▁ field " NEW_LINE from django . db . backends . util import truncate_name NEW_LINE if f . db_index and not f . unique : NEW_LINE INDENT qn = self . connection . ops . quote_name NEW_LINE tablespace = f . db_tablespace or model . _meta . db_tablespace NEW_LINE if tablespace : NEW_LINE INDENT sql = self . connection . ops . tablespace_sql ( tablespace ) NEW_LINE if sql : NEW_LINE INDENT tablespace_sql = ' ▁ ' + sql NEW_LINE DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT tablespace_sql = ' ' NEW_LINE DEDENT i_name = ' % s _ % s ' % ( model . _meta . db_table , self . _digest ( f . column ) ) NEW_LINE output = [ style . SQL_KEYWORD ( ' CREATE ▁ INDEX ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( truncate_name ( i_name , self . connection . ops . max_name_length ( ) ) ) ) + ' ▁ ' + style . SQL_KEYWORD ( ' ON ' ) + ' ▁ ' + style . SQL_TABLE ( qn ( model . _meta . db_table ) ) + ' ▁ ' + " ( % s ) " % style . SQL_FIELD ( qn ( f . column ) ) + " % s ; " % tablespace_sql ] NEW_LINE DEDENT else : NEW_LINE INDENT output = [ ] NEW_LINE DEDENT return output NEW_LINE DEDENT def sql_destroy_model ( self , model , references_to_delete , style ) : NEW_LINE INDENT " Return ▁ the ▁ DROP ▁ TABLE ▁ and ▁ restraint ▁ dropping ▁ statements ▁ for ▁ a ▁ single ▁ model " NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE # ▁ Drop ▁ the ▁ table ▁ now ENDCOM DEDENT qn = self . connection . ops . quote_name NEW_LINE output = [ ' % s ▁ % s ; ' % ( style . SQL_KEYWORD ( ' DROP ▁ TABLE ' ) , style . SQL_TABLE ( qn ( model . _meta . db_table ) ) ) ] NEW_LINE if model in references_to_delete : NEW_LINE INDENT output . extend ( self . sql_remove_table_constraints ( model , references_to_delete , style ) ) NEW_LINE DEDENT if model . _meta . has_auto_field : NEW_LINE INDENT ds = self . connection . ops . drop_sequence_sql ( model . _meta . db_table ) NEW_LINE if ds : NEW_LINE INDENT output . append ( ds ) NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT def sql_remove_table_constraints ( self , model , references_to_delete , style ) : NEW_LINE INDENT from django . db . backends . util import truncate_name NEW_LINE if not model . _meta . managed or model . _meta . proxy : NEW_LINE INDENT return [ ] NEW_LINE DEDENT output = [ ] NEW_LINE qn = self . connection . ops . quote_name NEW_LINE for rel_class , f in references_to_delete [ model ] : NEW_LINE INDENT table = rel_class . _meta . db_table NEW_LINE col = f . column NEW_LINE r_table = model . _meta . db_table NEW_LINE r_col = model . _meta . get_field ( f . rel . field_name ) . column NEW_LINE r_name = ' % s _ refs _ % s _ % s ' % ( col , r_col , self . _digest ( table , r_table ) ) NEW_LINE output . append ( ' % s ▁ % s ▁ % s ▁ % s ; ' % ( style . SQL_KEYWORD ( ' ALTER ▁ TABLE ' ) , style . SQL_TABLE ( qn ( table ) ) , style . SQL_KEYWORD ( self . connection . ops . drop_foreignkey_sql ( ) ) , style . SQL_FIELD ( qn ( truncate_name ( r_name , self . connection . ops . max_name_length ( ) ) ) ) ) ) NEW_LINE DEDENT del references_to_delete [ model ] NEW_LINE return output NEW_LINE DEDENT def sql_destroy_many_to_many ( self , model , f , style ) : NEW_LINE INDENT " Returns ▁ the ▁ DROP ▁ TABLE ▁ statements ▁ for ▁ a ▁ single ▁ m2m ▁ field " NEW_LINE import warnings NEW_LINE warnings . warn ( ' Database ▁ creation ▁ API ▁ for ▁ m2m ▁ tables ▁ has ▁ been ▁ deprecated . ▁ M2M ▁ models ▁ are ▁ now ▁ automatically ▁ generated ' , DeprecationWarning ) NEW_LINE qn = self . connection . ops . quote_name NEW_LINE output = [ ] NEW_LINE if f . auto_created : NEW_LINE INDENT output . append ( " % s ▁ % s ; " % ( style . SQL_KEYWORD ( ' DROP ▁ TABLE ' ) , style . SQL_TABLE ( qn ( f . m2m_db_table ( ) ) ) ) ) NEW_LINE ds = self . connection . ops . drop_sequence_sql ( " % s _ % s " % ( model . _meta . db_table , f . column ) ) NEW_LINE if ds : NEW_LINE INDENT output . append ( ds ) NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT def create_test_db ( self , verbosity = 1 , autoclobber = False ) : NEW_LINE INDENT """ STRNEWLINE ▁ Creates ▁ a ▁ test ▁ database , ▁ prompting ▁ the ▁ user ▁ for ▁ confirmation ▁ if ▁ the STRNEWLINE ▁ database ▁ already ▁ exists . ▁ Returns ▁ the ▁ name ▁ of ▁ the ▁ test ▁ database ▁ created . STRNEWLINE ▁ """ NEW_LINE # ▁ Don ' t ▁ import ▁ django . core . management ▁ if ▁ it ▁ isn ' t ▁ needed . ENDCOM from django . core . management import call_command NEW_LINE test_database_name = self . _get_test_db_name ( ) NEW_LINE if verbosity >= 1 : NEW_LINE INDENT test_db_repr = ' ' NEW_LINE if verbosity >= 2 : NEW_LINE INDENT test_db_repr = " ▁ ( ' % s ' ) " % test_database_name NEW_LINE DEDENT print " Creating ▁ test ▁ database ▁ for ▁ alias ▁ ' % s ' % s . . . " % ( self . connection . alias , test_db_repr ) NEW_LINE DEDENT self . _create_test_db ( verbosity , autoclobber ) NEW_LINE self . connection . close ( ) NEW_LINE self . connection . settings_dict [ " NAME " ] = test_database_name NEW_LINE # ▁ Confirm ▁ the ▁ feature ▁ set ▁ of ▁ the ▁ test ▁ database ENDCOM self . connection . features . confirm ( ) NEW_LINE # ▁ Report ▁ syncdb ▁ messages ▁ at ▁ one ▁ level ▁ lower ▁ than ▁ that ▁ requested . ENDCOM # ▁ This ▁ ensures ▁ we ▁ don ' t ▁ get ▁ flooded ▁ with ▁ messages ▁ during ▁ testing ENDCOM # ▁ ( unless ▁ you ▁ really ▁ ask ▁ to ▁ be ▁ flooded ) ENDCOM call_command ( ' syncdb ' , verbosity = max ( verbosity - 1 , 0 ) , interactive = False , database = self . connection . alias , load_initial_data = False ) NEW_LINE # ▁ We ▁ need ▁ to ▁ then ▁ do ▁ a ▁ flush ▁ to ▁ ensure ▁ that ▁ any ▁ data ▁ installed ▁ by ENDCOM # ▁ custom ▁ SQL ▁ has ▁ been ▁ removed . ▁ The ▁ only ▁ test ▁ data ▁ should ▁ come ▁ from ENDCOM # ▁ test ▁ fixtures , ▁ or ▁ autogenerated ▁ from ▁ post _ syncdb ▁ triggers . ENDCOM # ▁ This ▁ has ▁ the ▁ side ▁ effect ▁ of ▁ loading ▁ initial ▁ data ▁ ( which ▁ was ENDCOM # ▁ intentionally ▁ skipped ▁ in ▁ the ▁ syncdb ) . ENDCOM call_command ( ' flush ' , verbosity = max ( verbosity - 1 , 0 ) , interactive = False , database = self . connection . alias ) NEW_LINE from django . core . cache import get_cache NEW_LINE from django . core . cache . backends . db import BaseDatabaseCache NEW_LINE for cache_alias in settings . CACHES : NEW_LINE INDENT cache = get_cache ( cache_alias ) NEW_LINE if isinstance ( cache , BaseDatabaseCache ) : NEW_LINE INDENT from django . db import router NEW_LINE if router . allow_syncdb ( self . connection . alias , cache . cache_model_class ) : NEW_LINE INDENT call_command ( ' createcachetable ' , cache . _table , database = self . connection . alias ) NEW_LINE # ▁ Get ▁ a ▁ cursor ▁ ( even ▁ though ▁ we ▁ don ' t ▁ need ▁ one ▁ yet ) . ▁ This ▁ has ENDCOM # ▁ the ▁ side ▁ effect ▁ of ▁ initializing ▁ the ▁ test ▁ database . ENDCOM DEDENT DEDENT DEDENT cursor = self . connection . cursor ( ) NEW_LINE return test_database_name NEW_LINE DEDENT def _get_test_db_name ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Internal ▁ implementation ▁ - ▁ returns ▁ the ▁ name ▁ of ▁ the ▁ test ▁ DB ▁ that ▁ will ▁ be STRNEWLINE ▁ created . ▁ Only ▁ useful ▁ when ▁ called ▁ from ▁ create _ test _ db ( ) ▁ and STRNEWLINE ▁ _ create _ test _ db ( ) ▁ and ▁ when ▁ no ▁ external ▁ munging ▁ is ▁ done ▁ with ▁ the ▁ ' NAME ' STRNEWLINE ▁ or ▁ ' TEST _ NAME ' ▁ settings . STRNEWLINE ▁ """ NEW_LINE if self . connection . settings_dict [ ' TEST _ NAME ' ] : NEW_LINE INDENT return self . connection . settings_dict [ ' TEST _ NAME ' ] NEW_LINE DEDENT return TEST_DATABASE_PREFIX + self . connection . settings_dict [ ' NAME ' ] NEW_LINE DEDENT def _create_test_db ( self , verbosity , autoclobber ) : NEW_LINE INDENT " Internal ▁ implementation ▁ - ▁ creates ▁ the ▁ test ▁ db ▁ tables . " NEW_LINE suffix = self . sql_table_creation_suffix ( ) NEW_LINE test_database_name = self . _get_test_db_name ( ) NEW_LINE qn = self . connection . ops . quote_name NEW_LINE # ▁ Create ▁ the ▁ test ▁ database ▁ and ▁ connect ▁ to ▁ it . ▁ We ▁ need ▁ to ▁ autocommit ENDCOM # ▁ if ▁ the ▁ database ▁ supports ▁ it ▁ because ▁ PostgreSQL ▁ doesn ' t ▁ allow ENDCOM # ▁ CREATE / DROP ▁ DATABASE ▁ statements ▁ within ▁ transactions . ENDCOM cursor = self . connection . cursor ( ) NEW_LINE self . set_autocommit ( ) NEW_LINE try : NEW_LINE INDENT cursor . execute ( " CREATE ▁ DATABASE ▁ % s ▁ % s " % ( qn ( test_database_name ) , suffix ) ) NEW_LINE DEDENT except Exception , e : NEW_LINE INDENT sys . stderr . write ( " Got ▁ an ▁ error ▁ creating ▁ the ▁ test ▁ database : ▁ % s \n " % e ) NEW_LINE if not autoclobber : NEW_LINE INDENT confirm = raw_input ( " Type ▁ ' yes ' ▁ if ▁ you ▁ would ▁ like ▁ to ▁ try ▁ deleting ▁ the ▁ test ▁ database ▁ ' % s ' , ▁ or ▁ ' no ' ▁ to ▁ cancel : ▁ " % test_database_name ) NEW_LINE DEDENT if autoclobber or confirm == ' yes ' : NEW_LINE INDENT try : NEW_LINE INDENT if verbosity >= 1 : NEW_LINE INDENT print " Destroying ▁ old ▁ test ▁ database ▁ ' % s ' . . . " % self . connection . alias NEW_LINE DEDENT cursor . execute ( " DROP ▁ DATABASE ▁ % s " % qn ( test_database_name ) ) NEW_LINE cursor . execute ( " CREATE ▁ DATABASE ▁ % s ▁ % s " % ( qn ( test_database_name ) , suffix ) ) NEW_LINE DEDENT except Exception , e : NEW_LINE INDENT sys . stderr . write ( " Got ▁ an ▁ error ▁ recreating ▁ the ▁ test ▁ database : ▁ % s \n " % e ) NEW_LINE sys . exit ( 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " Tests ▁ cancelled . " NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT DEDENT return test_database_name NEW_LINE DEDENT def destroy_test_db ( self , old_database_name , verbosity = 1 ) : NEW_LINE INDENT """ STRNEWLINE ▁ Destroy ▁ a ▁ test ▁ database , ▁ prompting ▁ the ▁ user ▁ for ▁ confirmation ▁ if ▁ the STRNEWLINE ▁ database ▁ already ▁ exists . ▁ Returns ▁ the ▁ name ▁ of ▁ the ▁ test ▁ database ▁ created . STRNEWLINE ▁ """ NEW_LINE self . connection . close ( ) NEW_LINE test_database_name = self . connection . settings_dict [ ' NAME ' ] NEW_LINE if verbosity >= 1 : NEW_LINE INDENT test_db_repr = ' ' NEW_LINE if verbosity >= 2 : NEW_LINE INDENT test_db_repr = " ▁ ( ' % s ' ) " % test_database_name NEW_LINE DEDENT print " Destroying ▁ test ▁ database ▁ for ▁ alias ▁ ' % s ' % s . . . " % ( self . connection . alias , test_db_repr ) NEW_LINE DEDENT self . connection . settings_dict [ ' NAME ' ] = old_database_name NEW_LINE self . _destroy_test_db ( test_database_name , verbosity ) NEW_LINE DEDENT def _destroy_test_db ( self , test_database_name , verbosity ) : NEW_LINE INDENT " Internal ▁ implementation ▁ - ▁ remove ▁ the ▁ test ▁ db ▁ tables . " NEW_LINE # ▁ Remove ▁ the ▁ test ▁ database ▁ to ▁ clean ▁ up ▁ after ENDCOM # ▁ ourselves . ▁ Connect ▁ to ▁ the ▁ previous ▁ database ▁ ( not ▁ the ▁ test ▁ database ) ENDCOM # ▁ to ▁ do ▁ so , ▁ because ▁ it ' s ▁ not ▁ allowed ▁ to ▁ delete ▁ a ▁ database ▁ while ▁ being ENDCOM # ▁ connected ▁ to ▁ it . ENDCOM cursor = self . connection . cursor ( ) NEW_LINE self . set_autocommit ( ) NEW_LINE time . sleep ( 1 ) # ▁ To ▁ avoid ▁ " database ▁ is ▁ being ▁ accessed ▁ by ▁ other ▁ users " ▁ errors . ENDCOM NEW_LINE cursor . execute ( " DROP ▁ DATABASE ▁ % s " % self . connection . ops . quote_name ( test_database_name ) ) NEW_LINE self . connection . close ( ) NEW_LINE DEDENT def set_autocommit ( self ) : NEW_LINE INDENT " Make ▁ sure ▁ a ▁ connection ▁ is ▁ in ▁ autocommit ▁ mode . " NEW_LINE if hasattr ( self . connection . connection , " autocommit " ) : NEW_LINE INDENT if callable ( self . connection . connection . autocommit ) : NEW_LINE INDENT self . connection . connection . autocommit ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . connection . connection . autocommit = True NEW_LINE DEDENT DEDENT elif hasattr ( self . connection . connection , " set _ isolation _ level " ) : NEW_LINE INDENT self . connection . connection . set_isolation_level ( 0 ) NEW_LINE DEDENT DEDENT def sql_table_creation_suffix ( self ) : NEW_LINE INDENT " SQL ▁ to ▁ append ▁ to ▁ the ▁ end ▁ of ▁ the ▁ test ▁ table ▁ creation ▁ statements " NEW_LINE return ' ' NEW_LINE DEDENT def test_db_signature ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ a ▁ tuple ▁ with ▁ elements ▁ of ▁ self . connection . settings _ dict ▁ ( a STRNEWLINE ▁ DATABASES ▁ setting ▁ value ) ▁ that ▁ uniquely ▁ identify ▁ a ▁ database STRNEWLINE ▁ accordingly ▁ to ▁ the ▁ RDBMS ▁ particularities . STRNEWLINE ▁ """ NEW_LINE settings_dict = self . connection . settings_dict NEW_LINE return ( settings_dict [ ' HOST ' ] , settings_dict [ ' PORT ' ] , settings_dict [ ' ENGINE ' ] , settings_dict [ ' NAME ' ] ) NEW_LINE DEDENT DEDENT </DOCUMENT>
