<DOCUMENT_ID="bdupharm/sqlalchemy/tree/master/lib/sqlalchemy/ext/declarative/api.py"> # ▁ ext / declarative / api . py ENDCOM # ▁ Copyright ▁ ( C ) ▁ 2005-2016 ▁ the ▁ SQLAlchemy ▁ authors ▁ and ▁ contributors ENDCOM # ▁ < see ▁ AUTHORS ▁ file > ENDCOM # ▁ This ▁ module ▁ is ▁ part ▁ of ▁ SQLAlchemy ▁ and ▁ is ▁ released ▁ under ENDCOM # ▁ the ▁ MIT ▁ License : ▁ http : / / www . opensource . org / licenses / mit - license . php ENDCOM """ Public ▁ API ▁ functions ▁ and ▁ helpers ▁ for ▁ declarative . """ NEW_LINE from ... schema import Table , MetaData , Column NEW_LINE from ... orm import synonym as _orm_synonym , comparable_property , interfaces , properties , attributes NEW_LINE from ... orm . util import polymorphic_union NEW_LINE from ... orm . base import _mapper_or_none NEW_LINE from ... util import OrderedDict , hybridmethod , hybridproperty NEW_LINE from ... import util NEW_LINE from ... import exc NEW_LINE import weakref NEW_LINE from . base import _as_declarative , _declarative_constructor , _DeferredMapperConfig , _add_attribute NEW_LINE from . clsregistry import _class_resolver NEW_LINE def instrument_declarative ( cls , registry , metadata ) : NEW_LINE INDENT """ Given ▁ a ▁ class , ▁ configure ▁ the ▁ class ▁ declaratively , STRNEWLINE ▁ using ▁ the ▁ given ▁ registry , ▁ which ▁ can ▁ be ▁ any ▁ dictionary , ▁ and STRNEWLINE ▁ MetaData ▁ object . STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if ' _ decl _ class _ registry ' in cls . __dict__ : NEW_LINE INDENT raise exc . InvalidRequestError ( " Class ▁ % r ▁ already ▁ has ▁ been ▁ " " instrumented ▁ declaratively " % cls ) NEW_LINE DEDENT cls . _decl_class_registry = registry NEW_LINE cls . metadata = metadata NEW_LINE _as_declarative ( cls , cls . __name__ , cls . __dict__ ) NEW_LINE DEDENT def has_inherited_table ( cls ) : NEW_LINE INDENT """ Given ▁ a ▁ class , ▁ return ▁ True ▁ if ▁ any ▁ of ▁ the ▁ classes ▁ it ▁ inherits ▁ from ▁ has ▁ a STRNEWLINE ▁ mapped ▁ table , ▁ otherwise ▁ return ▁ False . STRNEWLINE ▁ """ NEW_LINE for class_ in cls . __mro__ [ 1 : ] : NEW_LINE INDENT if getattr ( class_ , ' _ _ table _ _ ' , None ) is not None : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT class DeclarativeMeta ( type ) : NEW_LINE INDENT def __init__ ( cls , classname , bases , dict_ ) : NEW_LINE INDENT if ' _ decl _ class _ registry ' not in cls . __dict__ : NEW_LINE INDENT _as_declarative ( cls , classname , cls . __dict__ ) NEW_LINE DEDENT type . __init__ ( cls , classname , bases , dict_ ) NEW_LINE DEDENT def __setattr__ ( cls , key , value ) : NEW_LINE INDENT _add_attribute ( cls , key , value ) NEW_LINE DEDENT DEDENT def synonym_for ( name , map_column = False ) : NEW_LINE INDENT """ Decorator , ▁ make ▁ a ▁ Python ▁ @ property ▁ a ▁ query ▁ synonym ▁ for ▁ a ▁ column . STRNEWLINE STRNEWLINE ▁ A ▁ decorator ▁ version ▁ of ▁ : func : ` ~ sqlalchemy . orm . synonym ` . ▁ The ▁ function ▁ being STRNEWLINE ▁ decorated ▁ is ▁ the ▁ ' descriptor ' , ▁ otherwise ▁ passes ▁ its ▁ arguments ▁ through ▁ to STRNEWLINE ▁ synonym ( ) : : STRNEWLINE STRNEWLINE ▁ @ synonym _ for ( ' col ' ) STRNEWLINE ▁ @ property STRNEWLINE ▁ def ▁ prop ( self ) : STRNEWLINE ▁ return ▁ ' special ▁ sauce ' STRNEWLINE STRNEWLINE ▁ The ▁ regular ▁ ` ` synonym ( ) ` ` ▁ is ▁ also ▁ usable ▁ directly ▁ in ▁ a ▁ declarative ▁ setting STRNEWLINE ▁ and ▁ may ▁ be ▁ convenient ▁ for ▁ read / write ▁ properties : : STRNEWLINE STRNEWLINE ▁ prop ▁ = ▁ synonym ( ' col ' , ▁ descriptor = property ( _ read _ prop , ▁ _ write _ prop ) ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( fn ) : NEW_LINE INDENT return _orm_synonym ( name , map_column = map_column , descriptor = fn ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT def comparable_using ( comparator_factory ) : NEW_LINE INDENT """ Decorator , ▁ allow ▁ a ▁ Python ▁ @ property ▁ to ▁ be ▁ used ▁ in ▁ query ▁ criteria . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ a ▁ decorator ▁ front ▁ end ▁ to STRNEWLINE ▁ : func : ` ~ sqlalchemy . orm . comparable _ property ` ▁ that ▁ passes STRNEWLINE ▁ through ▁ the ▁ comparator _ factory ▁ and ▁ the ▁ function ▁ being ▁ decorated : : STRNEWLINE STRNEWLINE ▁ @ comparable _ using ( MyComparatorType ) STRNEWLINE ▁ @ property STRNEWLINE ▁ def ▁ prop ( self ) : STRNEWLINE ▁ return ▁ ' special ▁ sauce ' STRNEWLINE STRNEWLINE ▁ The ▁ regular ▁ ` ` comparable _ property ( ) ` ` ▁ is ▁ also ▁ usable ▁ directly ▁ in ▁ a STRNEWLINE ▁ declarative ▁ setting ▁ and ▁ may ▁ be ▁ convenient ▁ for ▁ read / write ▁ properties : : STRNEWLINE STRNEWLINE ▁ prop ▁ = ▁ comparable _ property ( MyComparatorType ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( fn ) : NEW_LINE INDENT return comparable_property ( comparator_factory , fn ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT class declared_attr ( interfaces . _MappedAttribute , property ) : NEW_LINE INDENT """ Mark ▁ a ▁ class - level ▁ method ▁ as ▁ representing ▁ the ▁ definition ▁ of STRNEWLINE ▁ a ▁ mapped ▁ property ▁ or ▁ special ▁ declarative ▁ member ▁ name . STRNEWLINE STRNEWLINE ▁ @ declared _ attr ▁ turns ▁ the ▁ attribute ▁ into ▁ a ▁ scalar - like STRNEWLINE ▁ property ▁ that ▁ can ▁ be ▁ invoked ▁ from ▁ the ▁ uninstantiated ▁ class . STRNEWLINE ▁ Declarative ▁ treats ▁ attributes ▁ specifically ▁ marked ▁ with STRNEWLINE ▁ @ declared _ attr ▁ as ▁ returning ▁ a ▁ construct ▁ that ▁ is ▁ specific STRNEWLINE ▁ to ▁ mapping ▁ or ▁ declarative ▁ table ▁ configuration . ▁ The ▁ name STRNEWLINE ▁ of ▁ the ▁ attribute ▁ is ▁ that ▁ of ▁ what ▁ the ▁ non - dynamic ▁ version STRNEWLINE ▁ of ▁ the ▁ attribute ▁ would ▁ be . STRNEWLINE STRNEWLINE ▁ @ declared _ attr ▁ is ▁ more ▁ often ▁ than ▁ not ▁ applicable ▁ to ▁ mixins , STRNEWLINE ▁ to ▁ define ▁ relationships ▁ that ▁ are ▁ to ▁ be ▁ applied ▁ to ▁ different STRNEWLINE ▁ implementors ▁ of ▁ the ▁ class : : STRNEWLINE STRNEWLINE ▁ class ▁ ProvidesUser ( object ) : STRNEWLINE ▁ " A ▁ mixin ▁ that ▁ adds ▁ a ▁ ' user ' ▁ relationship ▁ to ▁ classes . " STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ user ( self ) : STRNEWLINE ▁ return ▁ relationship ( " User " ) STRNEWLINE STRNEWLINE ▁ It ▁ also ▁ can ▁ be ▁ applied ▁ to ▁ mapped ▁ classes , ▁ such ▁ as ▁ to ▁ provide STRNEWLINE ▁ a ▁ " polymorphic " ▁ scheme ▁ for ▁ inheritance : : STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( Base ) : STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ type ▁ = ▁ Column ( String ( 50 ) , ▁ nullable = False ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ tablename _ _ ( cls ) : STRNEWLINE ▁ return ▁ cls . _ _ name _ _ . lower ( ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ mapper _ args _ _ ( cls ) : STRNEWLINE ▁ if ▁ cls . _ _ name _ _ ▁ = = ▁ ' Employee ' : STRNEWLINE ▁ return ▁ { STRNEWLINE ▁ " polymorphic _ on " : cls . type , STRNEWLINE ▁ " polymorphic _ identity " : " Employee " STRNEWLINE ▁ } STRNEWLINE ▁ else : STRNEWLINE ▁ return ▁ { " polymorphic _ identity " : cls . _ _ name _ _ } STRNEWLINE STRNEWLINE ▁ . . ▁ versionchanged : : ▁ 0.8 ▁ : class : ` . declared _ attr ` ▁ can ▁ be ▁ used ▁ with STRNEWLINE ▁ non - ORM ▁ or ▁ extension ▁ attributes , ▁ such ▁ as ▁ user - defined ▁ attributes STRNEWLINE ▁ or ▁ : func : ` . association _ proxy ` ▁ objects , ▁ which ▁ will ▁ be ▁ assigned STRNEWLINE ▁ to ▁ the ▁ class ▁ at ▁ class ▁ construction ▁ time . STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , fget , cascading = False ) : NEW_LINE INDENT super ( declared_attr , self ) . __init__ ( fget ) NEW_LINE self . __doc__ = fget . __doc__ NEW_LINE self . _cascading = cascading NEW_LINE DEDENT def __get__ ( desc , self , cls ) : NEW_LINE INDENT reg = cls . __dict__ . get ( ' _ sa _ declared _ attr _ reg ' , None ) NEW_LINE if reg is None : NEW_LINE INDENT manager = attributes . manager_of_class ( cls ) NEW_LINE if manager is None : NEW_LINE INDENT util . warn ( " Unmanaged ▁ access ▁ of ▁ declarative ▁ attribute ▁ % s ▁ from ▁ " " non - mapped ▁ class ▁ % s " % ( desc . fget . __name__ , cls . __name__ ) ) NEW_LINE DEDENT return desc . fget ( cls ) NEW_LINE DEDENT if reg is None : NEW_LINE INDENT return desc . fget ( cls ) NEW_LINE DEDENT elif desc in reg : NEW_LINE INDENT return reg [ desc ] NEW_LINE DEDENT else : NEW_LINE INDENT reg [ desc ] = obj = desc . fget ( cls ) NEW_LINE return obj NEW_LINE DEDENT DEDENT @ hybridmethod NEW_LINE def _stateful ( cls , ** kw ) : NEW_LINE INDENT return _stateful_declared_attr ( ** kw ) NEW_LINE DEDENT @ hybridproperty NEW_LINE def cascading ( cls ) : NEW_LINE INDENT """ Mark ▁ a ▁ : class : ` . declared _ attr ` ▁ as ▁ cascading . STRNEWLINE STRNEWLINE ▁ This ▁ is ▁ a ▁ special - use ▁ modifier ▁ which ▁ indicates ▁ that ▁ a ▁ column STRNEWLINE ▁ or ▁ MapperProperty - based ▁ declared ▁ attribute ▁ should ▁ be ▁ configured STRNEWLINE ▁ distinctly ▁ per ▁ mapped ▁ subclass , ▁ within ▁ a ▁ mapped - inheritance ▁ scenario . STRNEWLINE STRNEWLINE ▁ Below , ▁ both ▁ MyClass ▁ as ▁ well ▁ as ▁ MySubClass ▁ will ▁ have ▁ a ▁ distinct STRNEWLINE ▁ ` ` id ` ` ▁ Column ▁ object ▁ established : : STRNEWLINE STRNEWLINE ▁ class ▁ HasSomeAttribute ( object ) : STRNEWLINE ▁ @ declared _ attr . cascading STRNEWLINE ▁ def ▁ some _ id ( cls ) : STRNEWLINE ▁ if ▁ has _ inherited _ table ( cls ) : STRNEWLINE ▁ return ▁ Column ( STRNEWLINE ▁ ForeignKey ( ' myclass . id ' ) , ▁ primary _ key = True ) STRNEWLINE ▁ else : STRNEWLINE ▁ return ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ return ▁ Column ( ' id ' , ▁ Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ MyClass ( HasSomeAttribute , ▁ Base ) : STRNEWLINE ▁ " " STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ class ▁ MySubClass ( MyClass ) : STRNEWLINE ▁ " " STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ The ▁ behavior ▁ of ▁ the ▁ above ▁ configuration ▁ is ▁ that ▁ ` ` MySubClass ` ` STRNEWLINE ▁ will ▁ refer ▁ to ▁ both ▁ its ▁ own ▁ ` ` id ` ` ▁ column ▁ as ▁ well ▁ as ▁ that ▁ of STRNEWLINE ▁ ` ` MyClass ` ` ▁ underneath ▁ the ▁ attribute ▁ named ▁ ` ` some _ id ` ` . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : ref : ` declarative _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` mixin _ inheritance _ columns ` STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE return cls . _stateful ( cascading = True ) NEW_LINE DEDENT DEDENT class _stateful_declared_attr ( declared_attr ) : NEW_LINE INDENT def __init__ ( self , ** kw ) : NEW_LINE INDENT self . kw = kw NEW_LINE DEDENT def _stateful ( self , ** kw ) : NEW_LINE INDENT new_kw = self . kw . copy ( ) NEW_LINE new_kw . update ( kw ) NEW_LINE return _stateful_declared_attr ( ** new_kw ) NEW_LINE DEDENT def __call__ ( self , fn ) : NEW_LINE INDENT return declared_attr ( fn , ** self . kw ) NEW_LINE DEDENT DEDENT def declarative_base ( bind = None , metadata = None , mapper = None , cls = object , name = ' Base ' , constructor = _declarative_constructor , class_registry = None , metaclass = DeclarativeMeta ) : NEW_LINE INDENT """ Construct ▁ a ▁ base ▁ class ▁ for ▁ declarative ▁ class ▁ definitions . STRNEWLINE STRNEWLINE ▁ The ▁ new ▁ base ▁ class ▁ will ▁ be ▁ given ▁ a ▁ metaclass ▁ that ▁ produces STRNEWLINE ▁ appropriate ▁ : class : ` ~ sqlalchemy . schema . Table ` ▁ objects ▁ and ▁ makes STRNEWLINE ▁ the ▁ appropriate ▁ : func : ` ~ sqlalchemy . orm . mapper ` ▁ calls ▁ based ▁ on ▁ the STRNEWLINE ▁ information ▁ provided ▁ declaratively ▁ in ▁ the ▁ class ▁ and ▁ any ▁ subclasses STRNEWLINE ▁ of ▁ the ▁ class . STRNEWLINE STRNEWLINE ▁ : param ▁ bind : ▁ An ▁ optional STRNEWLINE ▁ : class : ` ~ sqlalchemy . engine . Connectable ` , ▁ will ▁ be ▁ assigned STRNEWLINE ▁ the ▁ ` ` bind ` ` ▁ attribute ▁ on ▁ the ▁ : class : ` ~ sqlalchemy . schema . MetaData ` STRNEWLINE ▁ instance . STRNEWLINE STRNEWLINE ▁ : param ▁ metadata : STRNEWLINE ▁ An ▁ optional ▁ : class : ` ~ sqlalchemy . schema . MetaData ` ▁ instance . ▁ All STRNEWLINE ▁ : class : ` ~ sqlalchemy . schema . Table ` ▁ objects ▁ implicitly ▁ declared ▁ by STRNEWLINE ▁ subclasses ▁ of ▁ the ▁ base ▁ will ▁ share ▁ this ▁ MetaData . ▁ A ▁ MetaData ▁ instance STRNEWLINE ▁ will ▁ be ▁ created ▁ if ▁ none ▁ is ▁ provided . ▁ The STRNEWLINE ▁ : class : ` ~ sqlalchemy . schema . MetaData ` ▁ instance ▁ will ▁ be ▁ available ▁ via ▁ the STRNEWLINE ▁ ` metadata ` ▁ attribute ▁ of ▁ the ▁ generated ▁ declarative ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ : param ▁ mapper : STRNEWLINE ▁ An ▁ optional ▁ callable , ▁ defaults ▁ to ▁ : func : ` ~ sqlalchemy . orm . mapper ` . ▁ Will STRNEWLINE ▁ be ▁ used ▁ to ▁ map ▁ subclasses ▁ to ▁ their ▁ Tables . STRNEWLINE STRNEWLINE ▁ : param ▁ cls : STRNEWLINE ▁ Defaults ▁ to ▁ : class : ` object ` . ▁ A ▁ type ▁ to ▁ use ▁ as ▁ the ▁ base ▁ for ▁ the ▁ generated STRNEWLINE ▁ declarative ▁ base ▁ class . ▁ May ▁ be ▁ a ▁ class ▁ or ▁ tuple ▁ of ▁ classes . STRNEWLINE STRNEWLINE ▁ : param ▁ name : STRNEWLINE ▁ Defaults ▁ to ▁ ` ` Base ` ` . ▁ The ▁ display ▁ name ▁ for ▁ the ▁ generated STRNEWLINE ▁ class . ▁ Customizing ▁ this ▁ is ▁ not ▁ required , ▁ but ▁ can ▁ improve ▁ clarity ▁ in STRNEWLINE ▁ tracebacks ▁ and ▁ debugging . STRNEWLINE STRNEWLINE ▁ : param ▁ constructor : STRNEWLINE ▁ Defaults ▁ to STRNEWLINE ▁ : func : ` ~ sqlalchemy . ext . declarative . _ declarative _ constructor ` , ▁ an STRNEWLINE ▁ _ _ init _ _ ▁ implementation ▁ that ▁ assigns ▁ \ * * kwargs ▁ for ▁ declared STRNEWLINE ▁ fields ▁ and ▁ relationships ▁ to ▁ an ▁ instance . ▁ If ▁ ` ` None ` ` ▁ is ▁ supplied , STRNEWLINE ▁ no ▁ _ _ init _ _ ▁ will ▁ be ▁ provided ▁ and ▁ construction ▁ will ▁ fall ▁ back ▁ to STRNEWLINE ▁ cls . _ _ init _ _ ▁ by ▁ way ▁ of ▁ the ▁ normal ▁ Python ▁ semantics . STRNEWLINE STRNEWLINE ▁ : param ▁ class _ registry : ▁ optional ▁ dictionary ▁ that ▁ will ▁ serve ▁ as ▁ the STRNEWLINE ▁ registry ▁ of ▁ class ▁ names - > ▁ mapped ▁ classes ▁ when ▁ string ▁ names STRNEWLINE ▁ are ▁ used ▁ to ▁ identify ▁ classes ▁ inside ▁ of ▁ : func : ` . relationship ` STRNEWLINE ▁ and ▁ others . ▁ Allows ▁ two ▁ or ▁ more ▁ declarative ▁ base ▁ classes STRNEWLINE ▁ to ▁ share ▁ the ▁ same ▁ registry ▁ of ▁ class ▁ names ▁ for ▁ simplified STRNEWLINE ▁ inter - base ▁ relationships . STRNEWLINE STRNEWLINE ▁ : param ▁ metaclass : STRNEWLINE ▁ Defaults ▁ to ▁ : class : ` . DeclarativeMeta ` . ▁ A ▁ metaclass ▁ or ▁ _ _ metaclass _ _ STRNEWLINE ▁ compatible ▁ callable ▁ to ▁ use ▁ as ▁ the ▁ meta ▁ type ▁ of ▁ the ▁ generated STRNEWLINE ▁ declarative ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : func : ` . as _ declarative ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE lcl_metadata = metadata or MetaData ( ) NEW_LINE if bind : NEW_LINE INDENT lcl_metadata . bind = bind NEW_LINE DEDENT if class_registry is None : NEW_LINE INDENT class_registry = weakref . WeakValueDictionary ( ) NEW_LINE DEDENT bases = not isinstance ( cls , tuple ) and ( cls , ) or cls NEW_LINE class_dict = dict ( _decl_class_registry = class_registry , metadata = lcl_metadata ) NEW_LINE if constructor : NEW_LINE INDENT class_dict [ ' _ _ init _ _ ' ] = constructor NEW_LINE DEDENT if mapper : NEW_LINE INDENT class_dict [ ' _ _ mapper _ cls _ _ ' ] = mapper NEW_LINE DEDENT return metaclass ( name , bases , class_dict ) NEW_LINE DEDENT def as_declarative ( ** kw ) : NEW_LINE INDENT """ STRNEWLINE ▁ Class ▁ decorator ▁ for ▁ : func : ` . declarative _ base ` . STRNEWLINE STRNEWLINE ▁ Provides ▁ a ▁ syntactical ▁ shortcut ▁ to ▁ the ▁ ` ` cls ` ` ▁ argument STRNEWLINE ▁ sent ▁ to ▁ : func : ` . declarative _ base ` , ▁ allowing ▁ the ▁ base ▁ class STRNEWLINE ▁ to ▁ be ▁ converted ▁ in - place ▁ to ▁ a ▁ " declarative " ▁ base : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ as _ declarative STRNEWLINE STRNEWLINE ▁ @ as _ declarative ( ) STRNEWLINE ▁ class ▁ Base ( object ) : STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ _ _ tablename _ _ ( cls ) : STRNEWLINE ▁ return ▁ cls . _ _ name _ _ . lower ( ) STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ MyMappedClass ( Base ) : STRNEWLINE ▁ # ▁ . . . STRNEWLINE STRNEWLINE ▁ All ▁ keyword ▁ arguments ▁ passed ▁ to ▁ : func : ` . as _ declarative ` ▁ are ▁ passed STRNEWLINE ▁ along ▁ to ▁ : func : ` . declarative _ base ` . STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 0.8.3 STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : func : ` . declarative _ base ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE def decorate ( cls ) : NEW_LINE INDENT kw [ ' cls ' ] = cls NEW_LINE kw [ ' name ' ] = cls . __name__ NEW_LINE return declarative_base ( ** kw ) NEW_LINE DEDENT return decorate NEW_LINE DEDENT class ConcreteBase ( object ) : NEW_LINE INDENT """ A ▁ helper ▁ class ▁ for ▁ ' concrete ' ▁ declarative ▁ mappings . STRNEWLINE STRNEWLINE ▁ : class : ` . ConcreteBase ` ▁ will ▁ use ▁ the ▁ : func : ` . polymorphic _ union ` STRNEWLINE ▁ function ▁ automatically , ▁ against ▁ all ▁ tables ▁ mapped ▁ as ▁ a ▁ subclass STRNEWLINE ▁ to ▁ this ▁ class . ▁ The ▁ function ▁ is ▁ called ▁ via ▁ the STRNEWLINE ▁ ` ` _ _ declare _ last _ _ ( ) ` ` ▁ function , ▁ which ▁ is ▁ essentially STRNEWLINE ▁ a ▁ hook ▁ for ▁ the ▁ : meth : ` . after _ configured ` ▁ event . STRNEWLINE STRNEWLINE ▁ : class : ` . ConcreteBase ` ▁ produces ▁ a ▁ mapped STRNEWLINE ▁ table ▁ for ▁ the ▁ class ▁ itself . ▁ Compare ▁ to ▁ : class : ` . AbstractConcreteBase ` , STRNEWLINE ▁ which ▁ does ▁ not . STRNEWLINE STRNEWLINE ▁ Example : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ ConcreteBase STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( ConcreteBase , ▁ Base ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' employee ' STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' employee ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ class ▁ Manager ( Employee ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' manager ' STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ manager _ data ▁ = ▁ Column ( String ( 40 ) ) STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' manager ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : class : ` . AbstractConcreteBase ` STRNEWLINE STRNEWLINE ▁ : ref : ` concrete _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` inheritance _ concrete _ helpers ` STRNEWLINE STRNEWLINE STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def _create_polymorphic_union ( cls , mappers ) : NEW_LINE INDENT return polymorphic_union ( OrderedDict ( ( mp . polymorphic_identity , mp . local_table ) for mp in mappers ) , ' type ' , ' pjoin ' ) NEW_LINE DEDENT @ classmethod NEW_LINE def __declare_first__ ( cls ) : NEW_LINE INDENT m = cls . __mapper__ NEW_LINE if m . with_polymorphic : NEW_LINE INDENT return NEW_LINE DEDENT mappers = list ( m . self_and_descendants ) NEW_LINE pjoin = cls . _create_polymorphic_union ( mappers ) NEW_LINE m . _set_with_polymorphic ( ( " * " , pjoin ) ) NEW_LINE m . _set_polymorphic_on ( pjoin . c . type ) NEW_LINE DEDENT DEDENT class AbstractConcreteBase ( ConcreteBase ) : NEW_LINE INDENT """ A ▁ helper ▁ class ▁ for ▁ ' concrete ' ▁ declarative ▁ mappings . STRNEWLINE STRNEWLINE ▁ : class : ` . AbstractConcreteBase ` ▁ will ▁ use ▁ the ▁ : func : ` . polymorphic _ union ` STRNEWLINE ▁ function ▁ automatically , ▁ against ▁ all ▁ tables ▁ mapped ▁ as ▁ a ▁ subclass STRNEWLINE ▁ to ▁ this ▁ class . ▁ The ▁ function ▁ is ▁ called ▁ via ▁ the STRNEWLINE ▁ ` ` _ _ declare _ last _ _ ( ) ` ` ▁ function , ▁ which ▁ is ▁ essentially STRNEWLINE ▁ a ▁ hook ▁ for ▁ the ▁ : meth : ` . after _ configured ` ▁ event . STRNEWLINE STRNEWLINE ▁ : class : ` . AbstractConcreteBase ` ▁ does ▁ produce ▁ a ▁ mapped ▁ class STRNEWLINE ▁ for ▁ the ▁ base ▁ class , ▁ however ▁ it ▁ is ▁ not ▁ persisted ▁ to ▁ any ▁ table ; ▁ it STRNEWLINE ▁ is ▁ instead ▁ mapped ▁ directly ▁ to ▁ the ▁ " polymorphic " ▁ selectable ▁ directly STRNEWLINE ▁ and ▁ is ▁ only ▁ used ▁ for ▁ selecting . ▁ Compare ▁ to ▁ : class : ` . ConcreteBase ` , STRNEWLINE ▁ which ▁ does ▁ create ▁ a ▁ persisted ▁ table ▁ for ▁ the ▁ base ▁ class . STRNEWLINE STRNEWLINE ▁ Example : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ AbstractConcreteBase STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( AbstractConcreteBase , ▁ Base ) : STRNEWLINE ▁ pass STRNEWLINE STRNEWLINE ▁ class ▁ Manager ( Employee ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' manager ' STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ manager _ data ▁ = ▁ Column ( String ( 40 ) ) STRNEWLINE STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' manager ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ The ▁ abstract ▁ base ▁ class ▁ is ▁ handled ▁ by ▁ declarative ▁ in ▁ a ▁ special ▁ way ; STRNEWLINE ▁ at ▁ class ▁ configuration ▁ time , ▁ it ▁ behaves ▁ like ▁ a ▁ declarative ▁ mixin STRNEWLINE ▁ or ▁ an ▁ ` ` _ _ abstract _ _ ` ` ▁ base ▁ class . ▁ Once ▁ classes ▁ are ▁ configured STRNEWLINE ▁ and ▁ mappings ▁ are ▁ produced , ▁ it ▁ then ▁ gets ▁ mapped ▁ itself , ▁ but STRNEWLINE ▁ after ▁ all ▁ of ▁ its ▁ decscendants . ▁ This ▁ is ▁ a ▁ very ▁ unique ▁ system ▁ of ▁ mapping STRNEWLINE ▁ not ▁ found ▁ in ▁ any ▁ other ▁ SQLAlchemy ▁ system . STRNEWLINE STRNEWLINE ▁ Using ▁ this ▁ approach , ▁ we ▁ can ▁ specify ▁ columns ▁ and ▁ properties STRNEWLINE ▁ that ▁ will ▁ take ▁ place ▁ on ▁ mapped ▁ subclasses , ▁ in ▁ the ▁ way ▁ that STRNEWLINE ▁ we ▁ normally ▁ do ▁ as ▁ in ▁ : ref : ` declarative _ mixins ` : : STRNEWLINE STRNEWLINE ▁ class ▁ Company ( Base ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' company ' STRNEWLINE ▁ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ class ▁ Employee ( AbstractConcreteBase , ▁ Base ) : STRNEWLINE ▁ employee _ id ▁ = ▁ Column ( Integer , ▁ primary _ key = True ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ company _ id ( cls ) : STRNEWLINE ▁ return ▁ Column ( ForeignKey ( ' company . id ' ) ) STRNEWLINE STRNEWLINE ▁ @ declared _ attr STRNEWLINE ▁ def ▁ company ( cls ) : STRNEWLINE ▁ return ▁ relationship ( " Company " ) STRNEWLINE STRNEWLINE ▁ class ▁ Manager ( Employee ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' manager ' STRNEWLINE STRNEWLINE ▁ name ▁ = ▁ Column ( String ( 50 ) ) STRNEWLINE ▁ manager _ data ▁ = ▁ Column ( String ( 40 ) ) STRNEWLINE STRNEWLINE ▁ _ _ mapper _ args _ _ ▁ = ▁ { STRNEWLINE ▁ ' polymorphic _ identity ' : ' manager ' , STRNEWLINE ▁ ' concrete ' : True } STRNEWLINE STRNEWLINE ▁ When ▁ we ▁ make ▁ use ▁ of ▁ our ▁ mappings ▁ however , ▁ both ▁ ` ` Manager ` ` ▁ and STRNEWLINE ▁ ` ` Employee ` ` ▁ will ▁ have ▁ an ▁ independently ▁ usable ▁ ` ` . company ` ` ▁ attribute : : STRNEWLINE STRNEWLINE ▁ session . query ( Employee ) . filter ( Employee . company . has ( id = 5 ) ) STRNEWLINE STRNEWLINE ▁ . . ▁ versionchanged : : ▁ 1.0.0 ▁ - ▁ The ▁ mechanics ▁ of ▁ : class : ` . AbstractConcreteBase ` STRNEWLINE ▁ have ▁ been ▁ reworked ▁ to ▁ support ▁ relationships ▁ established ▁ directly STRNEWLINE ▁ on ▁ the ▁ abstract ▁ base , ▁ without ▁ any ▁ special ▁ configurational ▁ steps . STRNEWLINE STRNEWLINE ▁ . . ▁ seealso : : STRNEWLINE STRNEWLINE ▁ : class : ` . ConcreteBase ` STRNEWLINE STRNEWLINE ▁ : ref : ` concrete _ inheritance ` STRNEWLINE STRNEWLINE ▁ : ref : ` inheritance _ concrete _ helpers ` STRNEWLINE STRNEWLINE ▁ """ NEW_LINE __no_table__ = True NEW_LINE @ classmethod NEW_LINE def __declare_first__ ( cls ) : NEW_LINE INDENT cls . _sa_decl_prepare_nocascade ( ) NEW_LINE DEDENT @ classmethod NEW_LINE def _sa_decl_prepare_nocascade ( cls ) : NEW_LINE INDENT if getattr ( cls , ' _ _ mapper _ _ ' , None ) : NEW_LINE INDENT return NEW_LINE DEDENT to_map = _DeferredMapperConfig . config_for_cls ( cls ) NEW_LINE # ▁ can ' t ▁ rely ▁ on ▁ ' self _ and _ descendants ' ▁ here ENDCOM # ▁ since ▁ technically ▁ an ▁ immediate ▁ subclass ENDCOM # ▁ might ▁ not ▁ be ▁ mapped , ▁ but ▁ a ▁ subclass ENDCOM # ▁ may ▁ be . ENDCOM mappers = [ ] NEW_LINE stack = list ( cls . __subclasses__ ( ) ) NEW_LINE while stack : NEW_LINE INDENT klass = stack . pop ( ) NEW_LINE stack . extend ( klass . __subclasses__ ( ) ) NEW_LINE mn = _mapper_or_none ( klass ) NEW_LINE if mn is not None : NEW_LINE INDENT mappers . append ( mn ) NEW_LINE DEDENT DEDENT pjoin = cls . _create_polymorphic_union ( mappers ) NEW_LINE # ▁ For ▁ columns ▁ that ▁ were ▁ declared ▁ on ▁ the ▁ class , ▁ these ENDCOM # ▁ are ▁ normally ▁ ignored ▁ with ▁ the ▁ " _ _ no _ table _ _ " ▁ mapping , ENDCOM # ▁ unless ▁ they ▁ have ▁ a ▁ different ▁ attribute ▁ key ▁ vs . ▁ col ▁ name ENDCOM # ▁ and ▁ are ▁ in ▁ the ▁ properties ▁ argument . ENDCOM # ▁ In ▁ that ▁ case , ▁ ensure ▁ we ▁ update ▁ the ▁ properties ▁ entry ENDCOM # ▁ to ▁ the ▁ correct ▁ column ▁ from ▁ the ▁ pjoin ▁ target ▁ table . ENDCOM declared_cols = set ( to_map . declared_columns ) NEW_LINE for k , v in list ( to_map . properties . items ( ) ) : NEW_LINE INDENT if v in declared_cols : NEW_LINE INDENT to_map . properties [ k ] = pjoin . c [ v . key ] NEW_LINE DEDENT DEDENT to_map . local_table = pjoin NEW_LINE m_args = to_map . mapper_args_fn or dict NEW_LINE def mapper_args ( ) : NEW_LINE INDENT args = m_args ( ) NEW_LINE args [ ' polymorphic _ on ' ] = pjoin . c . type NEW_LINE return args NEW_LINE DEDENT to_map . mapper_args_fn = mapper_args NEW_LINE m = to_map . map ( ) NEW_LINE for scls in cls . __subclasses__ ( ) : NEW_LINE INDENT sm = _mapper_or_none ( scls ) NEW_LINE if sm and sm . concrete and cls in scls . __bases__ : NEW_LINE INDENT sm . _set_concrete_base ( m ) NEW_LINE DEDENT DEDENT DEDENT DEDENT class DeferredReflection ( object ) : NEW_LINE INDENT """ A ▁ helper ▁ class ▁ for ▁ construction ▁ of ▁ mappings ▁ based ▁ on STRNEWLINE ▁ a ▁ deferred ▁ reflection ▁ step . STRNEWLINE STRNEWLINE ▁ Normally , ▁ declarative ▁ can ▁ be ▁ used ▁ with ▁ reflection ▁ by STRNEWLINE ▁ setting ▁ a ▁ : class : ` . Table ` ▁ object ▁ using ▁ autoload = True STRNEWLINE ▁ as ▁ the ▁ ` ` _ _ table _ _ ` ` ▁ attribute ▁ on ▁ a ▁ declarative ▁ class . STRNEWLINE ▁ The ▁ caveat ▁ is ▁ that ▁ the ▁ : class : ` . Table ` ▁ must ▁ be ▁ fully STRNEWLINE ▁ reflected , ▁ or ▁ at ▁ the ▁ very ▁ least ▁ have ▁ a ▁ primary ▁ key ▁ column , STRNEWLINE ▁ at ▁ the ▁ point ▁ at ▁ which ▁ a ▁ normal ▁ declarative ▁ mapping ▁ is STRNEWLINE ▁ constructed , ▁ meaning ▁ the ▁ : class : ` . Engine ` ▁ must ▁ be ▁ available STRNEWLINE ▁ at ▁ class ▁ declaration ▁ time . STRNEWLINE STRNEWLINE ▁ The ▁ : class : ` . DeferredReflection ` ▁ mixin ▁ moves ▁ the ▁ construction STRNEWLINE ▁ of ▁ mappers ▁ to ▁ be ▁ at ▁ a ▁ later ▁ point , ▁ after ▁ a ▁ specific STRNEWLINE ▁ method ▁ is ▁ called ▁ which ▁ first ▁ reflects ▁ all ▁ : class : ` . Table ` STRNEWLINE ▁ objects ▁ created ▁ so ▁ far . ▁ Classes ▁ can ▁ define ▁ it ▁ as ▁ such : : STRNEWLINE STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ declarative _ base STRNEWLINE ▁ from ▁ sqlalchemy . ext . declarative ▁ import ▁ DeferredReflection STRNEWLINE ▁ Base ▁ = ▁ declarative _ base ( ) STRNEWLINE STRNEWLINE ▁ class ▁ MyClass ( DeferredReflection , ▁ Base ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' mytable ' STRNEWLINE STRNEWLINE ▁ Above , ▁ ` ` MyClass ` ` ▁ is ▁ not ▁ yet ▁ mapped . ▁ After ▁ a ▁ series ▁ of STRNEWLINE ▁ classes ▁ have ▁ been ▁ defined ▁ in ▁ the ▁ above ▁ fashion , ▁ all ▁ tables STRNEWLINE ▁ can ▁ be ▁ reflected ▁ and ▁ mappings ▁ created ▁ using STRNEWLINE ▁ : meth : ` . prepare ` : : STRNEWLINE STRNEWLINE ▁ engine ▁ = ▁ create _ engine ( " someengine : / / . . . " ) STRNEWLINE ▁ DeferredReflection . prepare ( engine ) STRNEWLINE STRNEWLINE ▁ The ▁ : class : ` . DeferredReflection ` ▁ mixin ▁ can ▁ be ▁ applied ▁ to ▁ individual STRNEWLINE ▁ classes , ▁ used ▁ as ▁ the ▁ base ▁ for ▁ the ▁ declarative ▁ base ▁ itself , STRNEWLINE ▁ or ▁ used ▁ in ▁ a ▁ custom ▁ abstract ▁ class . ▁ Using ▁ an ▁ abstract ▁ base STRNEWLINE ▁ allows ▁ that ▁ only ▁ a ▁ subset ▁ of ▁ classes ▁ to ▁ be ▁ prepared ▁ for ▁ a STRNEWLINE ▁ particular ▁ prepare ▁ step , ▁ which ▁ is ▁ necessary ▁ for ▁ applications STRNEWLINE ▁ that ▁ use ▁ more ▁ than ▁ one ▁ engine . ▁ For ▁ example , ▁ if ▁ an ▁ application STRNEWLINE ▁ has ▁ two ▁ engines , ▁ you ▁ might ▁ use ▁ two ▁ bases , ▁ and ▁ prepare ▁ each STRNEWLINE ▁ separately , ▁ e . g . : : STRNEWLINE STRNEWLINE ▁ class ▁ ReflectedOne ( DeferredReflection , ▁ Base ) : STRNEWLINE ▁ _ _ abstract _ _ ▁ = ▁ True STRNEWLINE STRNEWLINE ▁ class ▁ ReflectedTwo ( DeferredReflection , ▁ Base ) : STRNEWLINE ▁ _ _ abstract _ _ ▁ = ▁ True STRNEWLINE STRNEWLINE ▁ class ▁ MyClass ( ReflectedOne ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' mytable ' STRNEWLINE STRNEWLINE ▁ class ▁ MyOtherClass ( ReflectedOne ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' myothertable ' STRNEWLINE STRNEWLINE ▁ class ▁ YetAnotherClass ( ReflectedTwo ) : STRNEWLINE ▁ _ _ tablename _ _ ▁ = ▁ ' yetanothertable ' STRNEWLINE STRNEWLINE ▁ # ▁ . . . ▁ etc . STRNEWLINE STRNEWLINE ▁ Above , ▁ the ▁ class ▁ hierarchies ▁ for ▁ ` ` ReflectedOne ` ` ▁ and STRNEWLINE ▁ ` ` ReflectedTwo ` ` ▁ can ▁ be ▁ configured ▁ separately : : STRNEWLINE STRNEWLINE ▁ ReflectedOne . prepare ( engine _ one ) STRNEWLINE ▁ ReflectedTwo . prepare ( engine _ two ) STRNEWLINE STRNEWLINE ▁ . . ▁ versionadded : : ▁ 0.8 STRNEWLINE STRNEWLINE ▁ """ NEW_LINE @ classmethod NEW_LINE def prepare ( cls , engine ) : NEW_LINE INDENT """ Reflect ▁ all ▁ : class : ` . Table ` ▁ objects ▁ for ▁ all ▁ current STRNEWLINE ▁ : class : ` . DeferredReflection ` ▁ subclasses """ NEW_LINE to_map = _DeferredMapperConfig . classes_for_base ( cls ) NEW_LINE for thingy in to_map : NEW_LINE INDENT cls . _sa_decl_prepare ( thingy . local_table , engine ) NEW_LINE thingy . map ( ) NEW_LINE mapper = thingy . cls . __mapper__ NEW_LINE metadata = mapper . class_ . metadata NEW_LINE for rel in mapper . _props . values ( ) : NEW_LINE INDENT if isinstance ( rel , properties . RelationshipProperty ) and rel . secondary is not None : NEW_LINE INDENT if isinstance ( rel . secondary , Table ) : NEW_LINE INDENT cls . _reflect_table ( rel . secondary , engine ) NEW_LINE DEDENT elif isinstance ( rel . secondary , _class_resolver ) : NEW_LINE INDENT rel . secondary . _resolvers += ( cls . _sa_deferred_table_resolver ( engine , metadata ) , ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT @ classmethod NEW_LINE def _sa_deferred_table_resolver ( cls , engine , metadata ) : NEW_LINE INDENT def _resolve ( key ) : NEW_LINE INDENT t1 = Table ( key , metadata ) NEW_LINE cls . _reflect_table ( t1 , engine ) NEW_LINE return t1 NEW_LINE DEDENT return _resolve NEW_LINE DEDENT @ classmethod NEW_LINE def _sa_decl_prepare ( cls , local_table , engine ) : NEW_LINE # ▁ autoload ▁ Table , ▁ which ▁ is ▁ already ENDCOM # ▁ present ▁ in ▁ the ▁ metadata . ▁ This ENDCOM # ▁ will ▁ fill ▁ in ▁ db - loaded ▁ columns ENDCOM # ▁ into ▁ the ▁ existing ▁ Table ▁ object . ENDCOM INDENT if local_table is not None : NEW_LINE INDENT cls . _reflect_table ( local_table , engine ) NEW_LINE DEDENT DEDENT @ classmethod NEW_LINE def _reflect_table ( cls , table , engine ) : NEW_LINE INDENT Table ( table . name , table . metadata , extend_existing = True , autoload_replace = False , autoload = True , autoload_with = engine , schema = table . schema ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="xboxfanj/android_kernel_htc_msm8974/tree/master/tools/perf/scripts/python/check-perf-trace.py"> # ▁ perf ▁ script ▁ event ▁ handlers , ▁ generated ▁ by ▁ perf ▁ script ▁ - g ▁ python ENDCOM # ▁ ( c ) ▁ 2010 , ▁ Tom ▁ Zanussi ▁ < tzanussi @ gmail . com > ENDCOM # ▁ Licensed ▁ under ▁ the ▁ terms ▁ of ▁ the ▁ GNU ▁ GPL ▁ License ▁ version ▁ 2 ENDCOM # ▁ This ▁ script ▁ tests ▁ basic ▁ functionality ▁ such ▁ as ▁ flag ▁ and ▁ symbol ENDCOM # ▁ strings , ▁ common _ xxx ( ) ▁ calls ▁ back ▁ into ▁ perf , ▁ begin , ▁ end , ▁ unhandled ENDCOM # ▁ events , ▁ etc . ▁ Basically , ▁ if ▁ this ▁ script ▁ runs ▁ successfully ▁ and ENDCOM # ▁ displays ▁ expected ▁ results , ▁ Python ▁ scripting ▁ support ▁ should ▁ be ▁ ok . ENDCOM import os NEW_LINE import sys NEW_LINE sys . path . append ( os . environ [ ' PERF _ EXEC _ PATH ' ] + ' / scripts / python / Perf - Trace - Util / lib / Perf / Trace ' ) NEW_LINE from Core import * NEW_LINE from perf_trace_context import * NEW_LINE unhandled = autodict ( ) NEW_LINE def trace_begin ( ) : NEW_LINE INDENT print " trace _ begin " NEW_LINE pass NEW_LINE DEDENT def trace_end ( ) : NEW_LINE INDENT print_unhandled ( ) NEW_LINE DEDENT def irq__softirq_entry ( event_name , context , common_cpu , common_secs , common_nsecs , common_pid , common_comm , vec ) : NEW_LINE INDENT print_header ( event_name , common_cpu , common_secs , common_nsecs , common_pid , common_comm ) NEW_LINE print_uncommon ( context ) NEW_LINE print " vec = % s \n " % ( symbol_str ( " irq _ _ softirq _ entry " , " vec " , vec ) ) , NEW_LINE DEDENT def kmem__kmalloc ( event_name , context , common_cpu , common_secs , common_nsecs , common_pid , common_comm , call_site , ptr , bytes_req , bytes_alloc , gfp_flags ) : NEW_LINE INDENT print_header ( event_name , common_cpu , common_secs , common_nsecs , common_pid , common_comm ) NEW_LINE print_uncommon ( context ) NEW_LINE print " call _ site = % u , ▁ ptr = % u , ▁ bytes _ req = % u , ▁ " " bytes _ alloc = % u , ▁ gfp _ flags = % s \n " % ( call_site , ptr , bytes_req , bytes_alloc , flag_str ( " kmem _ _ kmalloc " , " gfp _ flags " , gfp_flags ) ) , NEW_LINE DEDENT def trace_unhandled ( event_name , context , event_fields_dict ) : NEW_LINE INDENT try : NEW_LINE INDENT unhandled [ event_name ] += 1 NEW_LINE DEDENT except TypeError : NEW_LINE INDENT unhandled [ event_name ] = 1 NEW_LINE DEDENT DEDENT def print_header ( event_name , cpu , secs , nsecs , pid , comm ) : NEW_LINE INDENT print " % -20s ▁ % 5u ▁ % 05u . %09u ▁ % 8u ▁ % -20s ▁ " % ( event_name , cpu , secs , nsecs , pid , comm ) , NEW_LINE # ▁ print ▁ trace ▁ fields ▁ not ▁ included ▁ in ▁ handler ▁ args ENDCOM DEDENT def print_uncommon ( context ) : NEW_LINE INDENT print " common _ preempt _ count = % d , ▁ common _ flags = % s , ▁ common _ lock _ depth = % d , ▁ " % ( common_pc ( context ) , trace_flag_str ( common_flags ( context ) ) , common_lock_depth ( context ) ) NEW_LINE DEDENT def print_unhandled ( ) : NEW_LINE INDENT keys = unhandled . keys ( ) NEW_LINE if not keys : NEW_LINE INDENT return NEW_LINE DEDENT print " \n unhandled ▁ events : \n \n " , NEW_LINE print " % -40s ▁ ▁ % 10s \n " % ( " event " , " count " ) , NEW_LINE print " % -40s ▁ ▁ % 10s \n " % ( " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - - - - - - " ) , NEW_LINE for event_name in keys : NEW_LINE INDENT print " % -40s ▁ ▁ % 10d \n " % ( event_name , unhandled [ event_name ] ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="Syrcon/servo/tree/master/tests/wpt/web-platform-tests/tools/serve/serve.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM import argparse NEW_LINE import json NEW_LINE import os NEW_LINE import signal NEW_LINE import socket NEW_LINE import sys NEW_LINE import threading NEW_LINE import time NEW_LINE import traceback NEW_LINE import urllib2 NEW_LINE import uuid NEW_LINE from collections import defaultdict , OrderedDict NEW_LINE from multiprocessing import Process , Event NEW_LINE from . . import localpaths NEW_LINE import sslutils NEW_LINE from wptserve import server as wptserve , handlers NEW_LINE from wptserve import stash NEW_LINE from wptserve . logger import set_logger NEW_LINE from mod_pywebsocket import standalone as pywebsocket NEW_LINE repo_root = localpaths . repo_root NEW_LINE class WorkersHandler ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . handler = handlers . handler ( self . handle_request ) NEW_LINE DEDENT def __call__ ( self , request , response ) : NEW_LINE INDENT return self . handler ( request , response ) NEW_LINE DEDENT def handle_request ( self , request , response ) : NEW_LINE INDENT worker_path = request . url_parts . path . replace ( " . worker " , " . worker . js " ) NEW_LINE return """ < ! doctype ▁ html > STRNEWLINE < meta ▁ charset = utf - 8 > STRNEWLINE < script ▁ src = " / resources / testharness . js " > < / script > STRNEWLINE < script ▁ src = " / resources / testharnessreport . js " > < / script > STRNEWLINE < div ▁ id = log > < / div > STRNEWLINE < script > STRNEWLINE fetch _ tests _ from _ worker ( new ▁ Worker ( " % s " ) ) ; STRNEWLINE < / script > STRNEWLINE """ % ( worker_path , ) NEW_LINE DEDENT DEDENT rewrites = [ ( " GET " , " / resources / WebIDLParser . js " , " / resources / webidl2 / lib / webidl2 . js " ) ] NEW_LINE subdomains = [ u " www " , u " www1" , u " www2" , u " 天気の良い日 " , u " élève " ] NEW_LINE class RoutesBuilder ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . forbidden_override = [ ( " GET " , " / tools / runner / * " , handlers . file_handler ) , ( " POST " , " / tools / runner / update _ manifest . py " , handlers . python_script_handler ) ] NEW_LINE self . forbidden = [ ( " * " , " / _ certs / * " , handlers . ErrorHandler ( 404 ) ) , ( " * " , " / tools / * " , handlers . ErrorHandler ( 404 ) ) , ( " * " , " { spec } / tools / * " , handlers . ErrorHandler ( 404 ) ) , ( " * " , " / serve . py " , handlers . ErrorHandler ( 404 ) ) ] NEW_LINE self . static = [ ( " GET " , " * . worker " , WorkersHandler ( ) ) ] NEW_LINE self . mountpoint_routes = OrderedDict ( ) NEW_LINE self . add_mount_point ( " / " , None ) NEW_LINE DEDENT def get_routes ( self ) : NEW_LINE INDENT routes = self . forbidden_override + self . forbidden + self . static NEW_LINE # ▁ Using ▁ reversed ▁ here ▁ means ▁ that ▁ mount ▁ points ▁ that ▁ are ▁ added ▁ later ENDCOM # ▁ get ▁ higher ▁ priority . ▁ This ▁ makes ▁ sense ▁ since ▁ / ▁ is ▁ typically ▁ added ENDCOM # ▁ first . ENDCOM for item in reversed ( self . mountpoint_routes . values ( ) ) : NEW_LINE INDENT routes . extend ( item ) NEW_LINE DEDENT return routes NEW_LINE DEDENT def add_static ( self , path , format_args , content_type , route ) : NEW_LINE INDENT handler = handlers . StaticHandler ( path , format_args , content_type ) NEW_LINE self . static . append ( ( b " GET " , str ( route ) , handler ) ) NEW_LINE DEDENT def add_mount_point ( self , url_base , path ) : NEW_LINE INDENT url_base = " / % s / " % url_base . strip ( " / " ) if url_base != " / " else " / " NEW_LINE self . mountpoint_routes [ url_base ] = [ ] NEW_LINE routes = [ ( " GET " , " * . asis " , handlers . AsIsHandler ) , ( " * " , " * . py " , handlers . PythonScriptHandler ) , ( " GET " , " * " , handlers . FileHandler ) ] NEW_LINE for ( method , suffix , handler_cls ) in routes : NEW_LINE INDENT self . mountpoint_routes [ url_base ] . append ( ( method , b " % s % s " % ( str ( url_base ) if url_base != " / " else " " , str ( suffix ) ) , handler_cls ( base_path = path , url_base = url_base ) ) ) NEW_LINE DEDENT DEDENT DEDENT def default_routes ( ) : NEW_LINE INDENT return RoutesBuilder ( ) . get_routes ( ) NEW_LINE DEDENT def setup_logger ( level ) : NEW_LINE INDENT import logging NEW_LINE global logger NEW_LINE logger = logging . getLogger ( " web - platform - tests " ) NEW_LINE logging . basicConfig ( level = getattr ( logging , level . upper ( ) ) ) NEW_LINE set_logger ( logger ) NEW_LINE DEDENT def open_socket ( port ) : NEW_LINE INDENT sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) NEW_LINE if port != 0 : NEW_LINE INDENT sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) NEW_LINE DEDENT sock . bind ( ( '127.0.0.1' , port ) ) NEW_LINE sock . listen ( 5 ) NEW_LINE return sock NEW_LINE DEDENT def get_port ( ) : NEW_LINE INDENT free_socket = open_socket ( 0 ) NEW_LINE port = free_socket . getsockname ( ) [ 1 ] NEW_LINE logger . debug ( " Going ▁ to ▁ use ▁ port ▁ % s " % port ) NEW_LINE free_socket . close ( ) NEW_LINE return port NEW_LINE DEDENT class ServerProc ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . proc = None NEW_LINE self . daemon = None NEW_LINE self . stop = Event ( ) NEW_LINE DEDENT def start ( self , init_func , host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT self . proc = Process ( target = self . create_daemon , args = ( init_func , host , port , paths , routes , bind_hostname , external_config , ssl_config ) ) NEW_LINE self . proc . daemon = True NEW_LINE self . proc . start ( ) NEW_LINE DEDENT def create_daemon ( self , init_func , host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT try : NEW_LINE INDENT self . daemon = init_func ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) NEW_LINE DEDENT except socket . error : NEW_LINE INDENT print >> sys . stderr , " Socket ▁ error ▁ on ▁ port ▁ % s " % port NEW_LINE raise NEW_LINE DEDENT except : NEW_LINE INDENT print >> sys . stderr , traceback . format_exc ( ) NEW_LINE raise NEW_LINE DEDENT if self . daemon : NEW_LINE INDENT try : NEW_LINE INDENT self . daemon . start ( block = False ) NEW_LINE try : NEW_LINE INDENT self . stop . wait ( ) NEW_LINE DEDENT except KeyboardInterrupt : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT print >> sys . stderr , traceback . format_exc ( ) NEW_LINE raise NEW_LINE DEDENT DEDENT DEDENT def wait ( self ) : NEW_LINE INDENT self . stop . set ( ) NEW_LINE self . proc . join ( ) NEW_LINE DEDENT def kill ( self ) : NEW_LINE INDENT self . stop . set ( ) NEW_LINE self . proc . terminate ( ) NEW_LINE self . proc . join ( ) NEW_LINE DEDENT def is_alive ( self ) : NEW_LINE INDENT return self . proc . is_alive ( ) NEW_LINE DEDENT DEDENT def check_subdomains ( host , paths , bind_hostname , ssl_config ) : NEW_LINE INDENT port = get_port ( ) NEW_LINE subdomains = get_subdomains ( host ) NEW_LINE wrapper = ServerProc ( ) NEW_LINE wrapper . start ( start_http_server , host , port , paths , default_routes ( ) , bind_hostname , None , ssl_config ) NEW_LINE connected = False NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT try : NEW_LINE INDENT urllib2 . urlopen ( " http : / / % s : % d / " % ( host , port ) ) NEW_LINE connected = True NEW_LINE break NEW_LINE DEDENT except urllib2 . URLError : NEW_LINE INDENT time . sleep ( 1 ) NEW_LINE DEDENT DEDENT if not connected : NEW_LINE INDENT logger . critical ( " Failed ▁ to ▁ connect ▁ to ▁ test ▁ server ▁ on ▁ http : / / % s : % s ▁ You ▁ may ▁ need ▁ to ▁ edit ▁ / etc / hosts ▁ or ▁ similar " % ( host , port ) ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT for subdomain , ( punycode , host ) in subdomains . iteritems ( ) : NEW_LINE INDENT domain = " % s . % s " % ( punycode , host ) NEW_LINE try : NEW_LINE INDENT urllib2 . urlopen ( " http : / / % s : % d / " % ( domain , port ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT logger . critical ( " Failed ▁ probing ▁ domain ▁ % s . ▁ You ▁ may ▁ need ▁ to ▁ edit ▁ / etc / hosts ▁ or ▁ similar . " % domain ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT DEDENT wrapper . wait ( ) NEW_LINE DEDENT def get_subdomains ( host ) : NEW_LINE # This ▁ assumes ▁ that ▁ the ▁ tld ▁ is ▁ ascii - only ▁ or ▁ already ▁ in ▁ punycode ENDCOM INDENT return { subdomain : ( subdomain . encode ( " idna " ) , host ) for subdomain in subdomains } NEW_LINE DEDENT def start_servers ( host , ports , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT servers = defaultdict ( list ) NEW_LINE for scheme , ports in ports . iteritems ( ) : NEW_LINE INDENT assert len ( ports ) == { " http " : 2 } . get ( scheme , 1 ) NEW_LINE for port in ports : NEW_LINE INDENT if port is None : NEW_LINE INDENT continue NEW_LINE DEDENT init_func = { " http " : start_http_server , " https " : start_https_server , " ws " : start_ws_server , " wss " : start_wss_server } [ scheme ] NEW_LINE server_proc = ServerProc ( ) NEW_LINE server_proc . start ( init_func , host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) NEW_LINE servers [ scheme ] . append ( ( port , server_proc ) ) NEW_LINE DEDENT DEDENT return servers NEW_LINE DEDENT def start_http_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return wptserve . WebTestHttpd ( host = host , port = port , doc_root = paths [ " doc _ root " ] , routes = routes , rewrites = rewrites , bind_hostname = bind_hostname , config = external_config , use_ssl = False , key_file = None , certificate = None , latency = kwargs . get ( " latency " ) ) NEW_LINE DEDENT def start_https_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return wptserve . WebTestHttpd ( host = host , port = port , doc_root = paths [ " doc _ root " ] , routes = routes , rewrites = rewrites , bind_hostname = bind_hostname , config = external_config , use_ssl = True , key_file = ssl_config [ " key _ path " ] , certificate = ssl_config [ " cert _ path " ] , encrypt_after_connect = ssl_config [ " encrypt _ after _ connect " ] , latency = kwargs . get ( " latency " ) ) NEW_LINE DEDENT class WebSocketDaemon ( object ) : NEW_LINE INDENT def __init__ ( self , host , port , doc_root , handlers_root , log_level , bind_hostname , ssl_config ) : NEW_LINE INDENT self . host = host NEW_LINE cmd_args = [ " - p " , port , " - d " , doc_root , " - w " , handlers_root , " - - log - level " , log_level ] NEW_LINE if ssl_config is not None : NEW_LINE # ▁ This ▁ is ▁ usually ▁ done ▁ through ▁ pywebsocket . main , ▁ however ▁ we ' re ENDCOM # ▁ working ▁ around ▁ that ▁ to ▁ get ▁ the ▁ server ▁ instance ▁ and ▁ manually ENDCOM # ▁ setup ▁ the ▁ wss ▁ server . ENDCOM INDENT if pywebsocket . _import_ssl ( ) : NEW_LINE INDENT tls_module = pywebsocket . _TLS_BY_STANDARD_MODULE NEW_LINE DEDENT elif pywebsocket . _import_pyopenssl ( ) : NEW_LINE INDENT tls_module = pywebsocket . _TLS_BY_PYOPENSSL NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ SSL ▁ module ▁ available " NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT cmd_args += [ " - - tls " , " - - private - key " , ssl_config [ " key _ path " ] , " - - certificate " , ssl_config [ " cert _ path " ] , " - - tls - module " , tls_module ] NEW_LINE DEDENT if ( bind_hostname ) : NEW_LINE INDENT cmd_args = [ " - H " , host ] + cmd_args NEW_LINE DEDENT opts , args = pywebsocket . _parse_args_and_config ( cmd_args ) NEW_LINE opts . cgi_directories = [ ] NEW_LINE opts . is_executable_method = None NEW_LINE self . server = pywebsocket . WebSocketServer ( opts ) NEW_LINE ports = [ item [ 0 ] . getsockname ( ) [ 1 ] for item in self . server . _sockets ] NEW_LINE assert all ( item == ports [ 0 ] for item in ports ) NEW_LINE self . port = ports [ 0 ] NEW_LINE self . started = False NEW_LINE self . server_thread = None NEW_LINE DEDENT def start ( self , block = False ) : NEW_LINE INDENT self . started = True NEW_LINE if block : NEW_LINE INDENT self . server . serve_forever ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . server_thread = threading . Thread ( target = self . server . serve_forever ) NEW_LINE self . server_thread . setDaemon ( True ) # ▁ don ' t ▁ hang ▁ on ▁ exit ENDCOM NEW_LINE self . server_thread . start ( ) NEW_LINE DEDENT DEDENT def stop ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Stops ▁ the ▁ server . STRNEWLINE STRNEWLINE ▁ If ▁ the ▁ server ▁ is ▁ not ▁ running , ▁ this ▁ method ▁ has ▁ no ▁ effect . STRNEWLINE ▁ """ NEW_LINE if self . started : NEW_LINE INDENT try : NEW_LINE INDENT self . server . shutdown ( ) NEW_LINE self . server . server_close ( ) NEW_LINE self . server_thread . join ( ) NEW_LINE self . server_thread = None NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT pass NEW_LINE DEDENT self . started = False NEW_LINE DEDENT self . server = None NEW_LINE DEDENT DEDENT def start_ws_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return WebSocketDaemon ( host , str ( port ) , repo_root , paths [ " ws _ doc _ root " ] , " debug " , bind_hostname , ssl_config = None ) NEW_LINE DEDENT def start_wss_server ( host , port , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) : NEW_LINE INDENT return WebSocketDaemon ( host , str ( port ) , repo_root , paths [ " ws _ doc _ root " ] , " debug " , bind_hostname , ssl_config ) NEW_LINE DEDENT def get_ports ( config , ssl_environment ) : NEW_LINE INDENT rv = defaultdict ( list ) NEW_LINE for scheme , ports in config [ " ports " ] . iteritems ( ) : NEW_LINE INDENT for i , port in enumerate ( ports ) : NEW_LINE INDENT if scheme in [ " wss " , " https " ] and not ssl_environment . ssl_enabled : NEW_LINE INDENT port = None NEW_LINE DEDENT if port == " auto " : NEW_LINE INDENT port = get_port ( ) NEW_LINE DEDENT else : NEW_LINE INDENT port = port NEW_LINE DEDENT rv [ scheme ] . append ( port ) NEW_LINE DEDENT DEDENT return rv NEW_LINE DEDENT def normalise_config ( config , ports ) : NEW_LINE INDENT host = config [ " external _ host " ] if config [ " external _ host " ] else config [ " host " ] NEW_LINE domains = get_subdomains ( host ) NEW_LINE ports_ = { } NEW_LINE for scheme , ports_used in ports . iteritems ( ) : NEW_LINE INDENT ports_ [ scheme ] = ports_used NEW_LINE DEDENT for key , value in domains . iteritems ( ) : NEW_LINE INDENT domains [ key ] = " . " . join ( value ) NEW_LINE DEDENT domains [ " " ] = host NEW_LINE ports_ = { } NEW_LINE for scheme , ports_used in ports . iteritems ( ) : NEW_LINE INDENT ports_ [ scheme ] = ports_used NEW_LINE DEDENT return { " host " : host , " domains " : domains , " ports " : ports_ } NEW_LINE DEDENT def get_ssl_config ( config , external_domains , ssl_environment ) : NEW_LINE INDENT key_path , cert_path = ssl_environment . host_cert_path ( external_domains ) NEW_LINE return { " key _ path " : key_path , " cert _ path " : cert_path , " encrypt _ after _ connect " : config [ " ssl " ] [ " encrypt _ after _ connect " ] } NEW_LINE DEDENT def start ( config , ssl_environment , routes , ** kwargs ) : NEW_LINE INDENT host = config [ " host " ] NEW_LINE domains = get_subdomains ( host ) NEW_LINE ports = get_ports ( config , ssl_environment ) NEW_LINE bind_hostname = config [ " bind _ hostname " ] NEW_LINE paths = { " doc _ root " : config [ " doc _ root " ] , " ws _ doc _ root " : config [ " ws _ doc _ root " ] } NEW_LINE external_config = normalise_config ( config , ports ) NEW_LINE ssl_config = get_ssl_config ( config , external_config [ " domains " ] . values ( ) , ssl_environment ) NEW_LINE if config [ " check _ subdomains " ] : NEW_LINE INDENT check_subdomains ( host , paths , bind_hostname , ssl_config ) NEW_LINE DEDENT servers = start_servers ( host , ports , paths , routes , bind_hostname , external_config , ssl_config , ** kwargs ) NEW_LINE return external_config , servers NEW_LINE DEDENT def iter_procs ( servers ) : NEW_LINE INDENT for servers in servers . values ( ) : NEW_LINE INDENT for port , server in servers : NEW_LINE INDENT yield server . proc NEW_LINE DEDENT DEDENT DEDENT def value_set ( config , key ) : NEW_LINE INDENT return key in config and config [ key ] is not None NEW_LINE DEDENT def get_value_or_default ( config , key , default = None ) : NEW_LINE INDENT return config [ key ] if value_set ( config , key ) else default NEW_LINE DEDENT def set_computed_defaults ( config ) : NEW_LINE INDENT if not value_set ( config , " doc _ root " ) : NEW_LINE INDENT config [ " doc _ root " ] = repo_root NEW_LINE DEDENT if not value_set ( config , " ws _ doc _ root " ) : NEW_LINE INDENT root = get_value_or_default ( config , " doc _ root " , default = repo_root ) NEW_LINE config [ " ws _ doc _ root " ] = os . path . join ( root , " websockets " , " handlers " ) NEW_LINE DEDENT DEDENT def merge_json ( base_obj , override_obj ) : NEW_LINE INDENT rv = { } NEW_LINE for key , value in base_obj . iteritems ( ) : NEW_LINE INDENT if key not in override_obj : NEW_LINE INDENT rv [ key ] = value NEW_LINE DEDENT else : NEW_LINE INDENT if isinstance ( value , dict ) : NEW_LINE INDENT rv [ key ] = merge_json ( value , override_obj [ key ] ) NEW_LINE DEDENT else : NEW_LINE INDENT rv [ key ] = override_obj [ key ] NEW_LINE DEDENT DEDENT DEDENT return rv NEW_LINE DEDENT def get_ssl_environment ( config ) : NEW_LINE INDENT implementation_type = config [ " ssl " ] [ " type " ] NEW_LINE cls = sslutils . environments [ implementation_type ] NEW_LINE try : NEW_LINE INDENT kwargs = config [ " ssl " ] [ implementation_type ] . copy ( ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise ValueError ( " % s ▁ is ▁ not ▁ a ▁ vaid ▁ ssl ▁ type . " % implementation_type ) NEW_LINE DEDENT return cls ( logger , ** kwargs ) NEW_LINE DEDENT def load_config ( default_path , override_path = None , ** kwargs ) : NEW_LINE INDENT if os . path . exists ( default_path ) : NEW_LINE INDENT with open ( default_path ) as f : NEW_LINE INDENT base_obj = json . load ( f ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT raise ValueError ( " Config ▁ path ▁ % s ▁ does ▁ not ▁ exist " % default_path ) NEW_LINE DEDENT if os . path . exists ( override_path ) : NEW_LINE INDENT with open ( override_path ) as f : NEW_LINE INDENT override_obj = json . load ( f ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT override_obj = { } NEW_LINE DEDENT rv = merge_json ( base_obj , override_obj ) NEW_LINE if kwargs . get ( " config _ path " ) : NEW_LINE INDENT other_path = os . path . abspath ( os . path . expanduser ( kwargs . get ( " config _ path " ) ) ) NEW_LINE if os . path . exists ( other_path ) : NEW_LINE INDENT base_obj = rv NEW_LINE with open ( other_path ) as f : NEW_LINE INDENT override_obj = json . load ( f ) NEW_LINE DEDENT rv = merge_json ( base_obj , override_obj ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " Config ▁ path ▁ % s ▁ does ▁ not ▁ exist " % other_path ) NEW_LINE DEDENT DEDENT overriding_path_args = [ ( " doc _ root " , " Document ▁ root " ) , ( " ws _ doc _ root " , " WebSockets ▁ document ▁ root " ) ] NEW_LINE for key , title in overriding_path_args : NEW_LINE INDENT value = kwargs . get ( key ) NEW_LINE if value is None : NEW_LINE INDENT continue NEW_LINE DEDENT value = os . path . abspath ( os . path . expanduser ( value ) ) NEW_LINE if not os . path . exists ( value ) : NEW_LINE INDENT raise ValueError ( " % s ▁ path ▁ % s ▁ does ▁ not ▁ exist " % ( title , value ) ) NEW_LINE DEDENT rv [ key ] = value NEW_LINE DEDENT set_computed_defaults ( rv ) NEW_LINE return rv NEW_LINE DEDENT def get_parser ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( ) NEW_LINE parser . add_argument ( " - - latency " , type = int , help = " Artificial ▁ latency ▁ to ▁ add ▁ before ▁ sending ▁ http ▁ responses , ▁ in ▁ ms " ) NEW_LINE parser . add_argument ( " - - config " , action = " store " , dest = " config _ path " , help = " Path ▁ to ▁ external ▁ config ▁ file " ) NEW_LINE parser . add_argument ( " - - doc _ root " , action = " store " , dest = " doc _ root " , help = " Path ▁ to ▁ document ▁ root . ▁ Overrides ▁ config . " ) NEW_LINE parser . add_argument ( " - - ws _ doc _ root " , action = " store " , dest = " ws _ doc _ root " , help = " Path ▁ to ▁ WebSockets ▁ document ▁ root . ▁ Overrides ▁ config . " ) NEW_LINE return parser NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT kwargs = vars ( get_parser ( ) . parse_args ( ) ) NEW_LINE config = load_config ( " config . default . json " , " config . json " , ** kwargs ) NEW_LINE setup_logger ( config [ " log _ level " ] ) NEW_LINE with stash . StashServer ( ( config [ " host " ] , get_port ( ) ) , authkey = str ( uuid . uuid4 ( ) ) ) : NEW_LINE INDENT with get_ssl_environment ( config ) as ssl_env : NEW_LINE INDENT config_ , servers = start ( config , ssl_env , default_routes ( ) , ** kwargs ) NEW_LINE try : NEW_LINE INDENT while any ( item . is_alive ( ) for item in iter_procs ( servers ) ) : NEW_LINE INDENT for item in iter_procs ( servers ) : NEW_LINE INDENT item . join ( 1 ) NEW_LINE DEDENT DEDENT DEDENT except KeyboardInterrupt : NEW_LINE INDENT logger . info ( " Shutting ▁ down " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="ryfeus/lambda-packs/tree/master/Skimage_numpy/source/PIL/JpegImagePlugin.py"> # ▁ The ▁ Python ▁ Imaging ▁ Library . ENDCOM # ▁ $ Id $ ENDCOM # ▁ JPEG ▁ ( JFIF ) ▁ file ▁ handling ENDCOM # ▁ See ▁ " Digital ▁ Compression ▁ and ▁ Coding ▁ of ▁ Continuous - Tone ▁ Still ▁ Images , ENDCOM # ▁ Part ▁ 1 , ▁ Requirements ▁ and ▁ Guidelines " ▁ ( CCITT ▁ T . 81 ▁ / ▁ ISO ▁ 10918-1 ) ENDCOM # ▁ History : ENDCOM # ▁ 1995-09-09 ▁ fl ▁ Created ENDCOM # ▁ 1995-09-13 ▁ fl ▁ Added ▁ full ▁ parser ENDCOM # ▁ 1996-03-25 ▁ fl ▁ Added ▁ hack ▁ to ▁ use ▁ the ▁ IJG ▁ command ▁ line ▁ utilities ENDCOM # ▁ 1996-05-05 ▁ fl ▁ Workaround ▁ Photoshop ▁ 2.5 ▁ CMYK ▁ polarity ▁ bug ENDCOM # ▁ 1996-05-28 ▁ fl ▁ Added ▁ draft ▁ support , ▁ JFIF ▁ version ▁ ( 0.1 ) ENDCOM # ▁ 1996-12-30 ▁ fl ▁ Added ▁ encoder ▁ options , ▁ added ▁ progression ▁ property ▁ ( 0.2 ) ENDCOM # ▁ 1997-08-27 ▁ fl ▁ Save ▁ mode ▁ 1 ▁ images ▁ as ▁ BW ▁ ( 0.3 ) ENDCOM # ▁ 1998-07-12 ▁ fl ▁ Added ▁ YCbCr ▁ to ▁ draft ▁ and ▁ save ▁ methods ▁ ( 0.4 ) ENDCOM # ▁ 1998-10-19 ▁ fl ▁ Don ' t ▁ hang ▁ on ▁ files ▁ using ▁ 16 - bit ▁ DQT ' s ▁ ( 0.4.1 ) ENDCOM # ▁ 2001-04-16 ▁ fl ▁ Extract ▁ DPI ▁ settings ▁ from ▁ JFIF ▁ files ▁ ( 0.4.2 ) ENDCOM # ▁ 2002-07-01 ▁ fl ▁ Skip ▁ pad ▁ bytes ▁ before ▁ markers ; ▁ identify ▁ Exif ▁ files ▁ ( 0.4.3 ) ENDCOM # ▁ 2003-04-25 ▁ fl ▁ Added ▁ experimental ▁ EXIF ▁ decoder ▁ ( 0.5 ) ENDCOM # ▁ 2003-06-06 ▁ fl ▁ Added ▁ experimental ▁ EXIF ▁ GPSinfo ▁ decoder ENDCOM # ▁ 2003-09-13 ▁ fl ▁ Extract ▁ COM ▁ markers ENDCOM # ▁ 2009-09-06 ▁ fl ▁ Added ▁ icc _ profile ▁ support ▁ ( from ▁ Florian ▁ Hoech ) ENDCOM # ▁ 2009-03-06 ▁ fl ▁ Changed ▁ CMYK ▁ handling ; ▁ always ▁ use ▁ Adobe ▁ polarity ▁ ( 0.6 ) ENDCOM # ▁ 2009-03-08 ▁ fl ▁ Added ▁ subsampling ▁ support ▁ ( from ▁ Justin ▁ Huff ) . ENDCOM # ▁ Copyright ▁ ( c ) ▁ 1997-2003 ▁ by ▁ Secret ▁ Labs ▁ AB . ENDCOM # ▁ Copyright ▁ ( c ) ▁ 1995-1996 ▁ by ▁ Fredrik ▁ Lundh . ENDCOM # ▁ See ▁ the ▁ README ▁ file ▁ for ▁ information ▁ on ▁ usage ▁ and ▁ redistribution . ENDCOM from __future__ import print_function NEW_LINE import array NEW_LINE import struct NEW_LINE import io NEW_LINE import warnings NEW_LINE from struct import unpack_from NEW_LINE from PIL import Image , ImageFile , TiffImagePlugin , _binary NEW_LINE from PIL . JpegPresets import presets NEW_LINE from PIL . _util import isStringType NEW_LINE i8 = _binary . i8 NEW_LINE o8 = _binary . o8 NEW_LINE i16 = _binary . i16be NEW_LINE i32 = _binary . i32be NEW_LINE __version__ = "0.6" NEW_LINE # ▁ Parser ENDCOM def Skip ( self , marker ) : NEW_LINE INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE ImageFile . _safe_read ( self . fp , n ) NEW_LINE DEDENT def APP ( self , marker ) : NEW_LINE # ▁ Application ▁ marker . ▁ Store ▁ these ▁ in ▁ the ▁ APP ▁ dictionary . ENDCOM # ▁ Also ▁ look ▁ for ▁ well - known ▁ application ▁ markers . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE app = " APP % d " % ( marker & 15 ) NEW_LINE self . app [ app ] = s # ▁ compatibility ENDCOM NEW_LINE self . applist . append ( ( app , s ) ) NEW_LINE if marker == 0xFFE0 and s [ : 4 ] == b " JFIF " : NEW_LINE # ▁ extract ▁ JFIF ▁ information ENDCOM INDENT self . info [ " jfif " ] = version = i16 ( s , 5 ) # ▁ version ENDCOM NEW_LINE self . info [ " jfif _ version " ] = divmod ( version , 256 ) NEW_LINE # ▁ extract ▁ JFIF ▁ properties ENDCOM try : NEW_LINE INDENT jfif_unit = i8 ( s [ 7 ] ) NEW_LINE jfif_density = i16 ( s , 8 ) , i16 ( s , 10 ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT if jfif_unit == 1 : NEW_LINE INDENT self . info [ " dpi " ] = jfif_density NEW_LINE DEDENT self . info [ " jfif _ unit " ] = jfif_unit NEW_LINE self . info [ " jfif _ density " ] = jfif_density NEW_LINE DEDENT DEDENT elif marker == 0xFFE1 and s [ : 5 ] == b " Exif\0" : NEW_LINE # ▁ extract ▁ Exif ▁ information ▁ ( incomplete ) ENDCOM INDENT self . info [ " exif " ] = s # ▁ FIXME : ▁ value ▁ will ▁ change ENDCOM NEW_LINE DEDENT elif marker == 0xFFE2 and s [ : 5 ] == b " FPXR\0" : NEW_LINE # ▁ extract ▁ FlashPix ▁ information ▁ ( incomplete ) ENDCOM INDENT self . info [ " flashpix " ] = s # ▁ FIXME : ▁ value ▁ will ▁ change ENDCOM NEW_LINE DEDENT elif marker == 0xFFE2 and s [ : 12 ] == b " ICC _ PROFILE\0" : NEW_LINE # ▁ Since ▁ an ▁ ICC ▁ profile ▁ can ▁ be ▁ larger ▁ than ▁ the ▁ maximum ▁ size ▁ of ENDCOM # ▁ a ▁ JPEG ▁ marker ▁ ( 64K ) , ▁ we ▁ need ▁ provisions ▁ to ▁ split ▁ it ▁ into ENDCOM # ▁ multiple ▁ markers . ▁ The ▁ format ▁ defined ▁ by ▁ the ▁ ICC ▁ specifies ENDCOM # ▁ one ▁ or ▁ more ▁ APP2 ▁ markers ▁ containing ▁ the ▁ following ▁ data : ENDCOM # ▁ Identifying ▁ string ▁ ASCII ▁ " ICC _ PROFILE\0 " ▁ ( 12 ▁ bytes ) ENDCOM # ▁ Marker ▁ sequence ▁ number ▁ 1 , ▁ 2 , ▁ etc ▁ ( 1 ▁ byte ) ENDCOM # ▁ Number ▁ of ▁ markers ▁ Total ▁ of ▁ APP2 ' s ▁ used ▁ ( 1 ▁ byte ) ENDCOM # ▁ Profile ▁ data ▁ ( remainder ▁ of ▁ APP2 ▁ data ) ENDCOM # ▁ Decoders ▁ should ▁ use ▁ the ▁ marker ▁ sequence ▁ numbers ▁ to ENDCOM # ▁ reassemble ▁ the ▁ profile , ▁ rather ▁ than ▁ assuming ▁ that ▁ the ▁ APP2 ENDCOM # ▁ markers ▁ appear ▁ in ▁ the ▁ correct ▁ sequence . ENDCOM INDENT self . icclist . append ( s ) NEW_LINE DEDENT elif marker == 0xFFEE and s [ : 5 ] == b " Adobe " : NEW_LINE INDENT self . info [ " adobe " ] = i16 ( s , 5 ) NEW_LINE # ▁ extract ▁ Adobe ▁ custom ▁ properties ENDCOM try : NEW_LINE INDENT adobe_transform = i8 ( s [ 1 ] ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT self . info [ " adobe _ transform " ] = adobe_transform NEW_LINE DEDENT DEDENT elif marker == 0xFFE2 and s [ : 4 ] == b " MPF\0" : NEW_LINE # ▁ extract ▁ MPO ▁ information ENDCOM INDENT self . info [ " mp " ] = s [ 4 : ] NEW_LINE # ▁ offset ▁ is ▁ current ▁ location ▁ minus ▁ buffer ▁ size ENDCOM # ▁ plus ▁ constant ▁ header ▁ size ENDCOM self . info [ " mpoffset " ] = self . fp . tell ( ) - n + 4 NEW_LINE DEDENT DEDENT def COM ( self , marker ) : NEW_LINE # ▁ Comment ▁ marker . ▁ Store ▁ these ▁ in ▁ the ▁ APP ▁ dictionary . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE self . app [ " COM " ] = s # ▁ compatibility ENDCOM NEW_LINE self . applist . append ( ( " COM " , s ) ) NEW_LINE DEDENT def SOF ( self , marker ) : NEW_LINE # ▁ Start ▁ of ▁ frame ▁ marker . ▁ Defines ▁ the ▁ size ▁ and ▁ mode ▁ of ▁ the ENDCOM # ▁ image . ▁ JPEG ▁ is ▁ colour ▁ blind , ▁ so ▁ we ▁ use ▁ some ▁ simple ENDCOM # ▁ heuristics ▁ to ▁ map ▁ the ▁ number ▁ of ▁ layers ▁ to ▁ an ▁ appropriate ENDCOM # ▁ mode . ▁ Note ▁ that ▁ this ▁ could ▁ be ▁ made ▁ a ▁ bit ▁ brighter , ▁ by ENDCOM # ▁ looking ▁ for ▁ JFIF ▁ and ▁ Adobe ▁ APP ▁ markers . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE self . size = i16 ( s [ 3 : ] ) , i16 ( s [ 1 : ] ) NEW_LINE self . bits = i8 ( s [ 0 ] ) NEW_LINE if self . bits != 8 : NEW_LINE INDENT raise SyntaxError ( " cannot ▁ handle ▁ % d - bit ▁ layers " % self . bits ) NEW_LINE DEDENT self . layers = i8 ( s [ 5 ] ) NEW_LINE if self . layers == 1 : NEW_LINE INDENT self . mode = " L " NEW_LINE DEDENT elif self . layers == 3 : NEW_LINE INDENT self . mode = " RGB " NEW_LINE DEDENT elif self . layers == 4 : NEW_LINE INDENT self . mode = " CMYK " NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " cannot ▁ handle ▁ % d - layer ▁ images " % self . layers ) NEW_LINE DEDENT if marker in [ 0xFFC2 , 0xFFC6 , 0xFFCA , 0xFFCE ] : NEW_LINE INDENT self . info [ " progressive " ] = self . info [ " progression " ] = 1 NEW_LINE DEDENT if self . icclist : NEW_LINE # ▁ fixup ▁ icc ▁ profile ENDCOM INDENT self . icclist . sort ( ) # ▁ sort ▁ by ▁ sequence ▁ number ENDCOM NEW_LINE if i8 ( self . icclist [ 0 ] [ 13 ] ) == len ( self . icclist ) : NEW_LINE INDENT profile = [ ] NEW_LINE for p in self . icclist : NEW_LINE INDENT profile . append ( p [ 14 : ] ) NEW_LINE DEDENT icc_profile = b " " . join ( profile ) NEW_LINE DEDENT else : NEW_LINE INDENT icc_profile = None # ▁ wrong ▁ number ▁ of ▁ fragments ENDCOM NEW_LINE DEDENT self . info [ " icc _ profile " ] = icc_profile NEW_LINE self . icclist = None NEW_LINE DEDENT for i in range ( 6 , len ( s ) , 3 ) : NEW_LINE INDENT t = s [ i : i + 3 ] NEW_LINE # ▁ 4 - tuples : ▁ id , ▁ vsamp , ▁ hsamp , ▁ qtable ENDCOM self . layer . append ( ( t [ 0 ] , i8 ( t [ 1 ] ) // 16 , i8 ( t [ 1 ] ) & 15 , i8 ( t [ 2 ] ) ) ) NEW_LINE DEDENT DEDENT def DQT ( self , marker ) : NEW_LINE # ▁ Define ▁ quantization ▁ table . ▁ Support ▁ baseline ▁ 8 - bit ▁ tables ENDCOM # ▁ only . ▁ Note ▁ that ▁ there ▁ might ▁ be ▁ more ▁ than ▁ one ▁ table ▁ in ENDCOM # ▁ each ▁ marker . ENDCOM # ▁ FIXME : ▁ The ▁ quantization ▁ tables ▁ can ▁ be ▁ used ▁ to ▁ estimate ▁ the ENDCOM # ▁ compression ▁ quality . ENDCOM INDENT n = i16 ( self . fp . read ( 2 ) ) - 2 NEW_LINE s = ImageFile . _safe_read ( self . fp , n ) NEW_LINE while len ( s ) : NEW_LINE INDENT if len ( s ) < 65 : NEW_LINE INDENT raise SyntaxError ( " bad ▁ quantization ▁ table ▁ marker " ) NEW_LINE DEDENT v = i8 ( s [ 0 ] ) NEW_LINE if v // 16 == 0 : NEW_LINE INDENT self . quantization [ v & 15 ] = array . array ( " B " , s [ 1 : 65 ] ) NEW_LINE s = s [ 65 : ] NEW_LINE DEDENT else : NEW_LINE INDENT return # ▁ FIXME : ▁ add ▁ code ▁ to ▁ read ▁ 16 - bit ▁ tables ! ENDCOM NEW_LINE # ▁ raise ▁ SyntaxError , ▁ " bad ▁ quantization ▁ table ▁ element ▁ size " ENDCOM # ▁ JPEG ▁ marker ▁ table ENDCOM DEDENT DEDENT DEDENT MARKER = { 0xFFC0 : ( " SOF0" , " Baseline ▁ DCT " , SOF ) , 0xFFC1 : ( " SOF1" , " Extended ▁ Sequential ▁ DCT " , SOF ) , 0xFFC2 : ( " SOF2" , " Progressive ▁ DCT " , SOF ) , 0xFFC3 : ( " SOF3" , " Spatial ▁ lossless " , SOF ) , 0xFFC4 : ( " DHT " , " Define ▁ Huffman ▁ table " , Skip ) , 0xFFC5 : ( " SOF5" , " Differential ▁ sequential ▁ DCT " , SOF ) , 0xFFC6 : ( " SOF6" , " Differential ▁ progressive ▁ DCT " , SOF ) , 0xFFC7 : ( " SOF7" , " Differential ▁ spatial " , SOF ) , 0xFFC8 : ( " JPG " , " Extension " , None ) , 0xFFC9 : ( " SOF9" , " Extended ▁ sequential ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCA : ( " SOF10" , " Progressive ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCB : ( " SOF11" , " Spatial ▁ lossless ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCC : ( " DAC " , " Define ▁ arithmetic ▁ coding ▁ conditioning " , Skip ) , 0xFFCD : ( " SOF13" , " Differential ▁ sequential ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCE : ( " SOF14" , " Differential ▁ progressive ▁ DCT ▁ ( AC ) " , SOF ) , 0xFFCF : ( " SOF15" , " Differential ▁ spatial ▁ ( AC ) " , SOF ) , 0xFFD0 : ( " RST0" , " Restart ▁ 0" , None ) , 0xFFD1 : ( " RST1" , " Restart ▁ 1" , None ) , 0xFFD2 : ( " RST2" , " Restart ▁ 2" , None ) , 0xFFD3 : ( " RST3" , " Restart ▁ 3" , None ) , 0xFFD4 : ( " RST4" , " Restart ▁ 4" , None ) , 0xFFD5 : ( " RST5" , " Restart ▁ 5" , None ) , 0xFFD6 : ( " RST6" , " Restart ▁ 6" , None ) , 0xFFD7 : ( " RST7" , " Restart ▁ 7" , None ) , 0xFFD8 : ( " SOI " , " Start ▁ of ▁ image " , None ) , 0xFFD9 : ( " EOI " , " End ▁ of ▁ image " , None ) , 0xFFDA : ( " SOS " , " Start ▁ of ▁ scan " , Skip ) , 0xFFDB : ( " DQT " , " Define ▁ quantization ▁ table " , DQT ) , 0xFFDC : ( " DNL " , " Define ▁ number ▁ of ▁ lines " , Skip ) , 0xFFDD : ( " DRI " , " Define ▁ restart ▁ interval " , Skip ) , 0xFFDE : ( " DHP " , " Define ▁ hierarchical ▁ progression " , SOF ) , 0xFFDF : ( " EXP " , " Expand ▁ reference ▁ component " , Skip ) , 0xFFE0 : ( " APP0" , " Application ▁ segment ▁ 0" , APP ) , 0xFFE1 : ( " APP1" , " Application ▁ segment ▁ 1" , APP ) , 0xFFE2 : ( " APP2" , " Application ▁ segment ▁ 2" , APP ) , 0xFFE3 : ( " APP3" , " Application ▁ segment ▁ 3" , APP ) , 0xFFE4 : ( " APP4" , " Application ▁ segment ▁ 4" , APP ) , 0xFFE5 : ( " APP5" , " Application ▁ segment ▁ 5" , APP ) , 0xFFE6 : ( " APP6" , " Application ▁ segment ▁ 6" , APP ) , 0xFFE7 : ( " APP7" , " Application ▁ segment ▁ 7" , APP ) , 0xFFE8 : ( " APP8" , " Application ▁ segment ▁ 8" , APP ) , 0xFFE9 : ( " APP9" , " Application ▁ segment ▁ 9" , APP ) , 0xFFEA : ( " APP10" , " Application ▁ segment ▁ 10" , APP ) , 0xFFEB : ( " APP11" , " Application ▁ segment ▁ 11" , APP ) , 0xFFEC : ( " APP12" , " Application ▁ segment ▁ 12" , APP ) , 0xFFED : ( " APP13" , " Application ▁ segment ▁ 13" , APP ) , 0xFFEE : ( " APP14" , " Application ▁ segment ▁ 14" , APP ) , 0xFFEF : ( " APP15" , " Application ▁ segment ▁ 15" , APP ) , 0xFFF0 : ( " JPG0" , " Extension ▁ 0" , None ) , 0xFFF1 : ( " JPG1" , " Extension ▁ 1" , None ) , 0xFFF2 : ( " JPG2" , " Extension ▁ 2" , None ) , 0xFFF3 : ( " JPG3" , " Extension ▁ 3" , None ) , 0xFFF4 : ( " JPG4" , " Extension ▁ 4" , None ) , 0xFFF5 : ( " JPG5" , " Extension ▁ 5" , None ) , 0xFFF6 : ( " JPG6" , " Extension ▁ 6" , None ) , 0xFFF7 : ( " JPG7" , " Extension ▁ 7" , None ) , 0xFFF8 : ( " JPG8" , " Extension ▁ 8" , None ) , 0xFFF9 : ( " JPG9" , " Extension ▁ 9" , None ) , 0xFFFA : ( " JPG10" , " Extension ▁ 10" , None ) , 0xFFFB : ( " JPG11" , " Extension ▁ 11" , None ) , 0xFFFC : ( " JPG12" , " Extension ▁ 12" , None ) , 0xFFFD : ( " JPG13" , " Extension ▁ 13" , None ) , 0xFFFE : ( " COM " , " Comment " , COM ) } NEW_LINE def _accept ( prefix ) : NEW_LINE INDENT return prefix [ 0 : 1 ] == b " \377" NEW_LINE # ▁ Image ▁ plugin ▁ for ▁ JPEG ▁ and ▁ JFIF ▁ images . ENDCOM DEDENT class JpegImageFile ( ImageFile . ImageFile ) : NEW_LINE INDENT format = " JPEG " NEW_LINE format_description = " JPEG ▁ ( ISO ▁ 10918 ) " NEW_LINE def _open ( self ) : NEW_LINE INDENT s = self . fp . read ( 1 ) NEW_LINE if i8 ( s ) != 255 : NEW_LINE INDENT raise SyntaxError ( " not ▁ a ▁ JPEG ▁ file " ) NEW_LINE # ▁ Create ▁ attributes ENDCOM DEDENT self . bits = self . layers = 0 NEW_LINE # ▁ JPEG ▁ specifics ▁ ( internal ) ENDCOM self . layer = [ ] NEW_LINE self . huffman_dc = { } NEW_LINE self . huffman_ac = { } NEW_LINE self . quantization = { } NEW_LINE self . app = { } # ▁ compatibility ENDCOM NEW_LINE self . applist = [ ] NEW_LINE self . icclist = [ ] NEW_LINE while True : NEW_LINE INDENT i = i8 ( s ) NEW_LINE if i == 0xFF : NEW_LINE INDENT s = s + self . fp . read ( 1 ) NEW_LINE i = i16 ( s ) NEW_LINE DEDENT else : NEW_LINE # ▁ Skip ▁ non - 0xFF ▁ junk ENDCOM INDENT s = self . fp . read ( 1 ) NEW_LINE continue NEW_LINE DEDENT if i in MARKER : NEW_LINE INDENT name , description , handler = MARKER [ i ] NEW_LINE # ▁ print ( hex ( i ) , ▁ name , ▁ description ) ENDCOM if handler is not None : NEW_LINE INDENT handler ( self , i ) NEW_LINE DEDENT if i == 0xFFDA : # ▁ start ▁ of ▁ scan ENDCOM NEW_LINE INDENT rawmode = self . mode NEW_LINE if self . mode == " CMYK " : NEW_LINE INDENT rawmode = " CMYK ; I " # ▁ assume ▁ adobe ▁ conventions ENDCOM NEW_LINE DEDENT self . tile = [ ( " jpeg " , ( 0 , 0 ) + self . size , 0 , ( rawmode , " " ) ) ] NEW_LINE # ▁ self . _ _ offset ▁ = ▁ self . fp . tell ( ) ENDCOM break NEW_LINE DEDENT s = self . fp . read ( 1 ) NEW_LINE DEDENT elif i == 0 or i == 0xFFFF : NEW_LINE # ▁ padded ▁ marker ▁ or ▁ junk ; ▁ move ▁ on ENDCOM INDENT s = b " \xff " NEW_LINE DEDENT elif i == 0xFF00 : # ▁ Skip ▁ extraneous ▁ data ▁ ( escaped ▁ 0xFF ) ENDCOM NEW_LINE INDENT s = self . fp . read ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " no ▁ marker ▁ found " ) NEW_LINE DEDENT DEDENT DEDENT def draft ( self , mode , size ) : NEW_LINE INDENT if len ( self . tile ) != 1 : NEW_LINE INDENT return NEW_LINE # ▁ Protect ▁ from ▁ second ▁ call ENDCOM DEDENT if self . decoderconfig : NEW_LINE INDENT return NEW_LINE DEDENT d , e , o , a = self . tile [ 0 ] NEW_LINE scale = 0 NEW_LINE if a [ 0 ] == " RGB " and mode in [ " L " , " YCbCr " ] : NEW_LINE INDENT self . mode = mode NEW_LINE a = mode , " " NEW_LINE DEDENT if size : NEW_LINE INDENT scale = min ( self . size [ 0 ] // size [ 0 ] , self . size [ 1 ] // size [ 1 ] ) NEW_LINE for s in [ 8 , 4 , 2 , 1 ] : NEW_LINE INDENT if scale >= s : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT e = e [ 0 ] , e [ 1 ] , ( e [ 2 ] - e [ 0 ] + s - 1 ) // s + e [ 0 ] , ( e [ 3 ] - e [ 1 ] + s - 1 ) // s + e [ 1 ] NEW_LINE self . size = ( ( self . size [ 0 ] + s - 1 ) // s , ( self . size [ 1 ] + s - 1 ) // s ) NEW_LINE scale = s NEW_LINE DEDENT self . tile = [ ( d , e , o , a ) ] NEW_LINE self . decoderconfig = ( scale , 0 ) NEW_LINE return self NEW_LINE DEDENT def load_djpeg ( self ) : NEW_LINE # ▁ ALTERNATIVE : ▁ handle ▁ JPEGs ▁ via ▁ the ▁ IJG ▁ command ▁ line ▁ utilities ENDCOM INDENT import subprocess NEW_LINE import tempfile NEW_LINE import os NEW_LINE f , path = tempfile . mkstemp ( ) NEW_LINE os . close ( f ) NEW_LINE if os . path . exists ( self . filename ) : NEW_LINE INDENT subprocess . check_call ( [ " djpeg " , " - outfile " , path , self . filename ] ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( " Invalid ▁ Filename " ) NEW_LINE DEDENT try : NEW_LINE INDENT _im = Image . open ( path ) NEW_LINE _im . load ( ) NEW_LINE self . im = _im . im NEW_LINE DEDENT finally : NEW_LINE INDENT try : NEW_LINE INDENT os . unlink ( path ) NEW_LINE DEDENT except OSError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT self . mode = self . im . mode NEW_LINE self . size = self . im . size NEW_LINE self . tile = [ ] NEW_LINE DEDENT def _getexif ( self ) : NEW_LINE INDENT return _getexif ( self ) NEW_LINE DEDENT def _getmp ( self ) : NEW_LINE INDENT return _getmp ( self ) NEW_LINE DEDENT DEDENT def _fixup_dict ( src_dict ) : NEW_LINE # ▁ Helper ▁ function ▁ for ▁ _ getexif ( ) ENDCOM # ▁ returns ▁ a ▁ dict ▁ with ▁ any ▁ single ▁ item ▁ tuples / lists ▁ as ▁ individual ▁ values ENDCOM INDENT def _fixup ( value ) : NEW_LINE INDENT try : NEW_LINE INDENT if len ( value ) == 1 and not isinstance ( value , dict ) : NEW_LINE INDENT return value [ 0 ] NEW_LINE DEDENT DEDENT except : pass NEW_LINE return value NEW_LINE DEDENT return { k : _fixup ( v ) for k , v in src_dict . items ( ) } NEW_LINE DEDENT def _getexif ( self ) : NEW_LINE # ▁ Extract ▁ EXIF ▁ information . ▁ This ▁ method ▁ is ▁ highly ▁ experimental , ENDCOM # ▁ and ▁ is ▁ likely ▁ to ▁ be ▁ replaced ▁ with ▁ something ▁ better ▁ in ▁ a ▁ future ENDCOM # ▁ version . ENDCOM # ▁ The ▁ EXIF ▁ record ▁ consists ▁ of ▁ a ▁ TIFF ▁ file ▁ embedded ▁ in ▁ a ▁ JPEG ENDCOM # ▁ application ▁ marker ▁ ( ! ) . ENDCOM INDENT try : NEW_LINE INDENT data = self . info [ " exif " ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT file = io . BytesIO ( data [ 6 : ] ) NEW_LINE head = file . read ( 8 ) NEW_LINE # ▁ process ▁ dictionary ENDCOM info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif = dict ( _fixup_dict ( info ) ) NEW_LINE # ▁ get ▁ exif ▁ extension ENDCOM try : NEW_LINE # ▁ exif ▁ field ▁ 0x8769 ▁ is ▁ an ▁ offset ▁ pointer ▁ to ▁ the ▁ location ENDCOM # ▁ of ▁ the ▁ nested ▁ embedded ▁ exif ▁ ifd . ENDCOM # ▁ It ▁ should ▁ be ▁ a ▁ long , ▁ but ▁ may ▁ be ▁ corrupted . ENDCOM INDENT file . seek ( exif [ 0x8769 ] ) NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif . update ( _fixup_dict ( info ) ) NEW_LINE # ▁ get ▁ gpsinfo ▁ extension ENDCOM DEDENT try : NEW_LINE # ▁ exif ▁ field ▁ 0x8825 ▁ is ▁ an ▁ offset ▁ pointer ▁ to ▁ the ▁ location ENDCOM # ▁ of ▁ the ▁ nested ▁ embedded ▁ gps ▁ exif ▁ ifd . ENDCOM # ▁ It ▁ should ▁ be ▁ a ▁ long , ▁ but ▁ may ▁ be ▁ corrupted . ENDCOM INDENT file . seek ( exif [ 0x8825 ] ) NEW_LINE DEDENT except ( KeyError , TypeError ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v1 ( head ) NEW_LINE info . load ( file ) NEW_LINE exif [ 0x8825 ] = _fixup_dict ( info ) NEW_LINE DEDENT return exif NEW_LINE DEDENT def _getmp ( self ) : NEW_LINE # ▁ Extract ▁ MP ▁ information . ▁ This ▁ method ▁ was ▁ inspired ▁ by ▁ the ▁ " highly ENDCOM # ▁ experimental " ▁ _ getexif ▁ version ▁ that ' s ▁ been ▁ in ▁ use ▁ for ▁ years ▁ now , ENDCOM # ▁ itself ▁ based ▁ on ▁ the ▁ ImageFileDirectory ▁ class ▁ in ▁ the ▁ TIFF ▁ plug - in . ENDCOM # ▁ The ▁ MP ▁ record ▁ essentially ▁ consists ▁ of ▁ a ▁ TIFF ▁ file ▁ embedded ▁ in ▁ a ▁ JPEG ENDCOM # ▁ application ▁ marker . ENDCOM INDENT try : NEW_LINE INDENT data = self . info [ " mp " ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT return None NEW_LINE DEDENT file_contents = io . BytesIO ( data ) NEW_LINE head = file_contents . read ( 8 ) NEW_LINE endianness = ' > ' if head [ : 4 ] == b ' \x4d\x4d\x00\x2a ' else ' < ' NEW_LINE # ▁ process ▁ dictionary ENDCOM try : NEW_LINE INDENT info = TiffImagePlugin . ImageFileDirectory_v2 ( head ) NEW_LINE info . load ( file_contents ) NEW_LINE mp = dict ( info ) NEW_LINE DEDENT except : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( unreadable ▁ directory ) " ) NEW_LINE # ▁ it ' s ▁ an ▁ error ▁ not ▁ to ▁ have ▁ a ▁ number ▁ of ▁ images ENDCOM DEDENT try : NEW_LINE INDENT quant = mp [ 0xB001 ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( no ▁ number ▁ of ▁ images ) " ) NEW_LINE # ▁ get ▁ MP ▁ entries ENDCOM DEDENT mpentries = [ ] NEW_LINE try : NEW_LINE INDENT rawmpentries = mp [ 0xB002 ] NEW_LINE for entrynum in range ( 0 , quant ) : NEW_LINE INDENT unpackedentry = unpack_from ( ' { } LLLHH ' . format ( endianness ) , rawmpentries , entrynum * 16 ) NEW_LINE labels = ( ' Attribute ' , ' Size ' , ' DataOffset ' , ' EntryNo1' , ' EntryNo2' ) NEW_LINE mpentry = dict ( zip ( labels , unpackedentry ) ) NEW_LINE mpentryattr = { ' DependentParentImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 31 ) ) , ' DependentChildImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 30 ) ) , ' RepresentativeImageFlag ' : bool ( mpentry [ ' Attribute ' ] & ( 1 << 29 ) ) , ' Reserved ' : ( mpentry [ ' Attribute ' ] & ( 3 << 27 ) ) >> 27 , ' ImageDataFormat ' : ( mpentry [ ' Attribute ' ] & ( 7 << 24 ) ) >> 24 , ' MPType ' : mpentry [ ' Attribute ' ] & 0x00FFFFFF } NEW_LINE if mpentryattr [ ' ImageDataFormat ' ] == 0 : NEW_LINE INDENT mpentryattr [ ' ImageDataFormat ' ] = ' JPEG ' NEW_LINE DEDENT else : NEW_LINE INDENT raise SyntaxError ( " unsupported ▁ picture ▁ format ▁ in ▁ MPO " ) NEW_LINE DEDENT mptypemap = { 0x000000 : ' Undefined ' , 0x010001 : ' Large ▁ Thumbnail ▁ ( VGA ▁ Equivalent ) ' , 0x010002 : ' Large ▁ Thumbnail ▁ ( Full ▁ HD ▁ Equivalent ) ' , 0x020001 : ' Multi - Frame ▁ Image ▁ ( Panorama ) ' , 0x020002 : ' Multi - Frame ▁ Image : ▁ ( Disparity ) ' , 0x020003 : ' Multi - Frame ▁ Image : ▁ ( Multi - Angle ) ' , 0x030000 : ' Baseline ▁ MP ▁ Primary ▁ Image ' } NEW_LINE mpentryattr [ ' MPType ' ] = mptypemap . get ( mpentryattr [ ' MPType ' ] , ' Unknown ' ) NEW_LINE mpentry [ ' Attribute ' ] = mpentryattr NEW_LINE mpentries . append ( mpentry ) NEW_LINE DEDENT mp [ 0xB002 ] = mpentries NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise SyntaxError ( " malformed ▁ MP ▁ Index ▁ ( bad ▁ MP ▁ Entry ) " ) NEW_LINE # ▁ Next ▁ we ▁ should ▁ try ▁ and ▁ parse ▁ the ▁ individual ▁ image ▁ unique ▁ ID ▁ list ; ENDCOM # ▁ we ▁ don ' t ▁ because ▁ I ' ve ▁ never ▁ seen ▁ this ▁ actually ▁ used ▁ in ▁ a ▁ real ▁ MPO ENDCOM # ▁ file ▁ and ▁ so ▁ can ' t ▁ test ▁ it . ENDCOM DEDENT return mp NEW_LINE # ▁ stuff ▁ to ▁ save ▁ JPEG ▁ files ENDCOM DEDENT RAWMODE = { "1" : " L " , " L " : " L " , " RGB " : " RGB " , " RGBA " : " RGB " , " RGBX " : " RGB " , " CMYK " : " CMYK ; I " , # ▁ assume ▁ adobe ▁ conventions ENDCOM " YCbCr " : " YCbCr " , } NEW_LINE zigzag_index = ( 0 , 1 , 5 , 6 , 14 , 15 , 27 , 28 , 2 , 4 , 7 , 13 , 16 , 26 , 29 , 42 , 3 , 8 , 12 , 17 , 25 , 30 , 41 , 43 , 9 , 11 , 18 , 24 , 31 , 40 , 44 , 53 , 10 , 19 , 23 , 32 , 39 , 45 , 52 , 54 , 20 , 22 , 33 , 38 , 46 , 51 , 55 , 60 , 21 , 34 , 37 , 47 , 50 , 56 , 59 , 61 , 35 , 36 , 48 , 49 , 57 , 58 , 62 , 63 ) NEW_LINE samplings = { ( 1 , 1 , 1 , 1 , 1 , 1 ) : 0 , ( 2 , 1 , 1 , 1 , 1 , 1 ) : 1 , ( 2 , 2 , 1 , 1 , 1 , 1 ) : 2 , } NEW_LINE def convert_dict_qtables ( qtables ) : NEW_LINE INDENT qtables = [ qtables [ key ] for key in range ( len ( qtables ) ) if key in qtables ] NEW_LINE for idx , table in enumerate ( qtables ) : NEW_LINE INDENT qtables [ idx ] = [ table [ i ] for i in zigzag_index ] NEW_LINE DEDENT return qtables NEW_LINE DEDENT def get_sampling ( im ) : NEW_LINE # ▁ There ' s ▁ no ▁ subsampling ▁ when ▁ image ▁ have ▁ only ▁ 1 ▁ layer ENDCOM # ▁ ( grayscale ▁ images ) ▁ or ▁ when ▁ they ▁ are ▁ CMYK ▁ ( 4 ▁ layers ) , ENDCOM # ▁ so ▁ set ▁ subsampling ▁ to ▁ default ▁ value . ENDCOM # ▁ NOTE : ▁ currently ▁ Pillow ▁ can ' t ▁ encode ▁ JPEG ▁ to ▁ YCCK ▁ format . ENDCOM # ▁ If ▁ YCCK ▁ support ▁ is ▁ added ▁ in ▁ the ▁ future , ▁ subsampling ▁ code ▁ will ▁ have ENDCOM # ▁ to ▁ be ▁ updated ▁ ( here ▁ and ▁ in ▁ JpegEncode . c ) ▁ to ▁ deal ▁ with ▁ 4 ▁ layers . ENDCOM INDENT if not hasattr ( im , ' layers ' ) or im . layers in ( 1 , 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sampling = im . layer [ 0 ] [ 1 : 3 ] + im . layer [ 1 ] [ 1 : 3 ] + im . layer [ 2 ] [ 1 : 3 ] NEW_LINE return samplings . get ( sampling , - 1 ) NEW_LINE DEDENT def _save ( im , fp , filename ) : NEW_LINE INDENT try : NEW_LINE INDENT rawmode = RAWMODE [ im . mode ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise IOError ( " cannot ▁ write ▁ mode ▁ % s ▁ as ▁ JPEG " % im . mode ) NEW_LINE DEDENT if im . mode == ' RGBA ' : NEW_LINE INDENT warnings . warn ( ' You ▁ are ▁ saving ▁ RGBA ▁ image ▁ as ▁ JPEG . ▁ The ▁ alpha ▁ channel ▁ will ▁ be ▁ ' ' discarded . ▁ This ▁ conversion ▁ is ▁ deprecated ▁ and ▁ will ▁ be ▁ disabled ▁ ' ' in ▁ Pillow ▁ 3.7 . ▁ Please , ▁ convert ▁ the ▁ image ▁ to ▁ RGB ▁ explicitly . ' , DeprecationWarning ) NEW_LINE DEDENT info = im . encoderinfo NEW_LINE dpi = [ int ( round ( x ) ) for x in info . get ( " dpi " , ( 0 , 0 ) ) ] NEW_LINE quality = info . get ( " quality " , 0 ) NEW_LINE subsampling = info . get ( " subsampling " , - 1 ) NEW_LINE qtables = info . get ( " qtables " ) NEW_LINE if quality == " keep " : NEW_LINE INDENT quality = 0 NEW_LINE subsampling = " keep " NEW_LINE qtables = " keep " NEW_LINE DEDENT elif quality in presets : NEW_LINE INDENT preset = presets [ quality ] NEW_LINE quality = 0 NEW_LINE subsampling = preset . get ( ' subsampling ' , - 1 ) NEW_LINE qtables = preset . get ( ' quantization ' ) NEW_LINE DEDENT elif not isinstance ( quality , int ) : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quality ▁ setting " ) NEW_LINE DEDENT else : NEW_LINE INDENT if subsampling in presets : NEW_LINE INDENT subsampling = presets [ subsampling ] . get ( ' subsampling ' , - 1 ) NEW_LINE DEDENT if isStringType ( qtables ) and qtables in presets : NEW_LINE INDENT qtables = presets [ qtables ] . get ( ' quantization ' ) NEW_LINE DEDENT DEDENT if subsampling == "4:4:4" : NEW_LINE INDENT subsampling = 0 NEW_LINE DEDENT elif subsampling == "4:2:2" : NEW_LINE INDENT subsampling = 1 NEW_LINE DEDENT elif subsampling == "4:1:1" : NEW_LINE INDENT subsampling = 2 NEW_LINE DEDENT elif subsampling == " keep " : NEW_LINE INDENT if im . format != " JPEG " : NEW_LINE INDENT raise ValueError ( " Cannot ▁ use ▁ ' keep ' ▁ when ▁ original ▁ image ▁ is ▁ not ▁ a ▁ JPEG " ) NEW_LINE DEDENT subsampling = get_sampling ( im ) NEW_LINE DEDENT def validate_qtables ( qtables ) : NEW_LINE INDENT if qtables is None : NEW_LINE INDENT return qtables NEW_LINE DEDENT if isStringType ( qtables ) : NEW_LINE INDENT try : NEW_LINE INDENT lines = [ int ( num ) for line in qtables . splitlines ( ) for num in line . split ( ' # ' , 1 ) [ 0 ] . split ( ) ] NEW_LINE DEDENT except ValueError : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quantization ▁ table " ) NEW_LINE DEDENT else : NEW_LINE INDENT qtables = [ lines [ s : s + 64 ] for s in range ( 0 , len ( lines ) , 64 ) ] NEW_LINE DEDENT DEDENT if isinstance ( qtables , ( tuple , list , dict ) ) : NEW_LINE INDENT if isinstance ( qtables , dict ) : NEW_LINE INDENT qtables = convert_dict_qtables ( qtables ) NEW_LINE DEDENT elif isinstance ( qtables , tuple ) : NEW_LINE INDENT qtables = list ( qtables ) NEW_LINE DEDENT if not ( 0 < len ( qtables ) < 5 ) : NEW_LINE INDENT raise ValueError ( " None ▁ or ▁ too ▁ many ▁ quantization ▁ tables " ) NEW_LINE DEDENT for idx , table in enumerate ( qtables ) : NEW_LINE INDENT try : NEW_LINE INDENT if len ( table ) != 64 : NEW_LINE INDENT raise NEW_LINE DEDENT table = array . array ( ' B ' , table ) NEW_LINE DEDENT except TypeError : NEW_LINE INDENT raise ValueError ( " Invalid ▁ quantization ▁ table " ) NEW_LINE DEDENT else : NEW_LINE INDENT qtables [ idx ] = list ( table ) NEW_LINE DEDENT DEDENT return qtables NEW_LINE DEDENT DEDENT if qtables == " keep " : NEW_LINE INDENT if im . format != " JPEG " : NEW_LINE INDENT raise ValueError ( " Cannot ▁ use ▁ ' keep ' ▁ when ▁ original ▁ image ▁ is ▁ not ▁ a ▁ JPEG " ) NEW_LINE DEDENT qtables = getattr ( im , " quantization " , None ) NEW_LINE DEDENT qtables = validate_qtables ( qtables ) NEW_LINE extra = b " " NEW_LINE icc_profile = info . get ( " icc _ profile " ) NEW_LINE if icc_profile : NEW_LINE INDENT ICC_OVERHEAD_LEN = 14 NEW_LINE MAX_BYTES_IN_MARKER = 65533 NEW_LINE MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN NEW_LINE markers = [ ] NEW_LINE while icc_profile : NEW_LINE INDENT markers . append ( icc_profile [ : MAX_DATA_BYTES_IN_MARKER ] ) NEW_LINE icc_profile = icc_profile [ MAX_DATA_BYTES_IN_MARKER : ] NEW_LINE DEDENT i = 1 NEW_LINE for marker in markers : NEW_LINE INDENT size = struct . pack ( " > H " , 2 + ICC_OVERHEAD_LEN + len ( marker ) ) NEW_LINE extra += ( b " \xFF\xE2" + size + b " ICC _ PROFILE\0" + o8 ( i ) + o8 ( len ( markers ) ) + marker ) NEW_LINE i += 1 NEW_LINE # ▁ " progressive " ▁ is ▁ the ▁ official ▁ name , ▁ but ▁ older ▁ documentation ENDCOM # ▁ says ▁ " progression " ENDCOM # ▁ FIXME : ▁ issue ▁ a ▁ warning ▁ if ▁ the ▁ wrong ▁ form ▁ is ▁ used ▁ ( post - 1.1.7 ) ENDCOM DEDENT DEDENT progressive = info . get ( " progressive " , False ) or info . get ( " progression " , False ) NEW_LINE optimize = info . get ( " optimize " , False ) NEW_LINE # ▁ get ▁ keyword ▁ arguments ENDCOM im . encoderconfig = ( quality , progressive , info . get ( " smooth " , 0 ) , optimize , info . get ( " streamtype " , 0 ) , dpi [ 0 ] , dpi [ 1 ] , subsampling , qtables , extra , info . get ( " exif " , b " " ) ) NEW_LINE # ▁ if ▁ we ▁ optimize , ▁ libjpeg ▁ needs ▁ a ▁ buffer ▁ big ▁ enough ▁ to ▁ hold ▁ the ▁ whole ▁ image ENDCOM # ▁ in ▁ a ▁ shot . ▁ Guessing ▁ on ▁ the ▁ size , ▁ at ▁ im . size ▁ bytes . ▁ ( raw ▁ pizel ▁ size ▁ is ENDCOM # ▁ channels * size , ▁ this ▁ is ▁ a ▁ value ▁ that ' s ▁ been ▁ used ▁ in ▁ a ▁ django ▁ patch . ENDCOM # ▁ https : / / github . com / matthewwithanm / django - imagekit / issues / 50 ENDCOM bufsize = 0 NEW_LINE if optimize or progressive : NEW_LINE # ▁ CMYK ▁ can ▁ be ▁ bigger ENDCOM INDENT if im . mode == ' CMYK ' : NEW_LINE INDENT bufsize = 4 * im . size [ 0 ] * im . size [ 1 ] NEW_LINE # ▁ keep ▁ sets ▁ quality ▁ to ▁ 0 , ▁ but ▁ the ▁ actual ▁ value ▁ may ▁ be ▁ high . ENDCOM DEDENT elif quality >= 95 or quality == 0 : NEW_LINE INDENT bufsize = 2 * im . size [ 0 ] * im . size [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT bufsize = im . size [ 0 ] * im . size [ 1 ] NEW_LINE # ▁ The ▁ exif ▁ info ▁ needs ▁ to ▁ be ▁ written ▁ as ▁ one ▁ block , ▁ + ▁ APP1 , ▁ + ▁ one ▁ spare ▁ byte . ENDCOM # ▁ Ensure ▁ that ▁ our ▁ buffer ▁ is ▁ big ▁ enough ENDCOM DEDENT DEDENT bufsize = max ( ImageFile . MAXBLOCK , bufsize , len ( info . get ( " exif " , b " " ) ) + 5 ) NEW_LINE ImageFile . _save ( im , fp , [ ( " jpeg " , ( 0 , 0 ) + im . size , 0 , rawmode ) ] , bufsize ) NEW_LINE DEDENT def _save_cjpeg ( im , fp , filename ) : NEW_LINE # ▁ ALTERNATIVE : ▁ handle ▁ JPEGs ▁ via ▁ the ▁ IJG ▁ command ▁ line ▁ utilities . ENDCOM INDENT import os NEW_LINE import subprocess NEW_LINE tempfile = im . _dump ( ) NEW_LINE subprocess . check_call ( [ " cjpeg " , " - outfile " , filename , tempfile ] ) NEW_LINE try : NEW_LINE INDENT os . unlink ( tempfile ) NEW_LINE DEDENT except OSError : NEW_LINE INDENT pass NEW_LINE # ▁ Factory ▁ for ▁ making ▁ JPEG ▁ and ▁ MPO ▁ instances ENDCOM DEDENT DEDENT def jpeg_factory ( fp = None , filename = None ) : NEW_LINE INDENT im = JpegImageFile ( fp , filename ) NEW_LINE try : NEW_LINE INDENT mpheader = im . _getmp ( ) NEW_LINE if mpheader [ 45057 ] > 1 : NEW_LINE # ▁ It ' s ▁ actually ▁ an ▁ MPO ENDCOM INDENT from . MpoImagePlugin import MpoImageFile NEW_LINE im = MpoImageFile ( fp , filename ) NEW_LINE DEDENT DEDENT except ( TypeError , IndexError ) : NEW_LINE # ▁ It ▁ is ▁ really ▁ a ▁ JPEG ENDCOM INDENT pass NEW_LINE DEDENT except SyntaxError : NEW_LINE INDENT warnings . warn ( " Image ▁ appears ▁ to ▁ be ▁ a ▁ malformed ▁ MPO ▁ file , ▁ it ▁ will ▁ be ▁ " " interpreted ▁ as ▁ a ▁ base ▁ JPEG ▁ file " ) NEW_LINE DEDENT return im NEW_LINE # ▁ Registry ▁ stuff ENDCOM DEDENT Image . register_open ( JpegImageFile . format , jpeg_factory , _accept ) NEW_LINE Image . register_save ( JpegImageFile . format , _save ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jfif " ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jpe " ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jpg " ) NEW_LINE Image . register_extension ( JpegImageFile . format , " . jpeg " ) NEW_LINE Image . register_mime ( JpegImageFile . format , " image / jpeg " ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="s40523220/2016fallcp_hw/tree/master/plugin/liquid_tags/test_generation.py"> # ▁ - * - ▁ coding : ▁ utf - 8 ▁ - * - ENDCOM from __future__ import print_function NEW_LINE import filecmp NEW_LINE import os NEW_LINE import unittest NEW_LINE from shutil import rmtree NEW_LINE from tempfile import mkdtemp NEW_LINE import pytest NEW_LINE from pelican import Pelican NEW_LINE from pelican . settings import read_settings NEW_LINE from . notebook import IPYTHON_VERSION NEW_LINE PLUGIN_DIR = os . path . dirname ( __file__ ) NEW_LINE TEST_DATA_DIR = os . path . join ( PLUGIN_DIR , ' test _ data ' ) NEW_LINE class TestFullRun ( unittest . TestCase ) : NEW_LINE INDENT ''' Test ▁ running ▁ Pelican ▁ with ▁ the ▁ Plugin ''' NEW_LINE def setUp ( self ) : NEW_LINE INDENT ''' Create ▁ temporary ▁ output ▁ and ▁ cache ▁ folders ''' NEW_LINE self . temp_path = mkdtemp ( prefix = ' pelicantests . ' ) NEW_LINE self . temp_cache = mkdtemp ( prefix = ' pelican _ cache . ' ) NEW_LINE os . chdir ( TEST_DATA_DIR ) NEW_LINE DEDENT def tearDown ( self ) : NEW_LINE INDENT ''' Remove ▁ output ▁ and ▁ cache ▁ folders ''' NEW_LINE rmtree ( self . temp_path ) NEW_LINE rmtree ( self . temp_cache ) NEW_LINE os . chdir ( PLUGIN_DIR ) NEW_LINE DEDENT @ pytest . mark . skipif ( IPYTHON_VERSION >= 3 , reason = " output ▁ must ▁ be ▁ created ▁ with ▁ ipython ▁ version ▁ 2" ) NEW_LINE def test_generate_with_ipython3 ( self ) : NEW_LINE INDENT ''' Test ▁ generation ▁ of ▁ site ▁ with ▁ the ▁ plugin . ''' NEW_LINE base_path = os . path . dirname ( os . path . abspath ( __file__ ) ) NEW_LINE base_path = os . path . join ( base_path , ' test _ data ' ) NEW_LINE content_path = os . path . join ( base_path , ' content ' ) NEW_LINE output_path = os . path . join ( base_path , ' output ' ) NEW_LINE settings_path = os . path . join ( base_path , ' pelicanconf . py ' ) NEW_LINE settings = read_settings ( path = settings_path , override = { ' PATH ' : content_path , ' OUTPUT _ PATH ' : self . temp_path , ' CACHE _ PATH ' : self . temp_cache , } ) NEW_LINE pelican = Pelican ( settings ) NEW_LINE pelican . run ( ) NEW_LINE # ▁ test ▁ existence ENDCOM assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 3 . html ' ) ) NEW_LINE assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 4 . html ' ) ) NEW_LINE # ▁ test ▁ differences ENDCOM # assert ▁ filecmp . cmp ( os . path . join ( output _ path , ENDCOM # ▁ ' test - ipython - notebook - v2 . html ' ) , ENDCOM # ▁ os . path . join ( self . temp _ path , ENDCOM # ▁ ' test - ipython - notebook . html ' ) ) ENDCOM DEDENT @ pytest . mark . skipif ( IPYTHON_VERSION < 3 , reason = " output ▁ must ▁ be ▁ created ▁ with ▁ ipython ▁ version ▁ 3" ) NEW_LINE def test_generate_with_ipython2 ( self ) : NEW_LINE INDENT ''' Test ▁ generation ▁ of ▁ site ▁ with ▁ the ▁ plugin . ''' NEW_LINE base_path = os . path . dirname ( os . path . abspath ( __file__ ) ) NEW_LINE base_path = os . path . join ( base_path , ' test _ data ' ) NEW_LINE content_path = os . path . join ( base_path , ' content ' ) NEW_LINE output_path = os . path . join ( base_path , ' output ' ) NEW_LINE settings_path = os . path . join ( base_path , ' pelicanconf . py ' ) NEW_LINE settings = read_settings ( path = settings_path , override = { ' PATH ' : content_path , ' OUTPUT _ PATH ' : self . temp_path , ' CACHE _ PATH ' : self . temp_cache , } ) NEW_LINE pelican = Pelican ( settings ) NEW_LINE pelican . run ( ) NEW_LINE # ▁ test ▁ existence ENDCOM assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 3 . html ' ) ) NEW_LINE assert os . path . exists ( os . path . join ( self . temp_path , ' test - ipython - notebook - nb - format - 4 . html ' ) ) NEW_LINE # ▁ test ▁ differences ENDCOM # assert ▁ filecmp . cmp ( os . path . join ( output _ path , ENDCOM # ▁ ' test - ipython - notebook - v3 . html ' ) , ENDCOM # ▁ os . path . join ( self . temp _ path , ENDCOM # ▁ ' test - ipython - notebook . html ' ) ) ENDCOM DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="achoy/cwapi/tree/master/backend/py-server/flask/lib/python3.6/site-packages/six.py"> """ Utilities ▁ for ▁ writing ▁ code ▁ that ▁ runs ▁ on ▁ Python ▁ 2 ▁ and ▁ 3 """ NEW_LINE # ▁ Copyright ▁ ( c ) ▁ 2010-2015 ▁ Benjamin ▁ Peterson ENDCOM # ▁ Permission ▁ is ▁ hereby ▁ granted , ▁ free ▁ of ▁ charge , ▁ to ▁ any ▁ person ▁ obtaining ▁ a ▁ copy ENDCOM # ▁ of ▁ this ▁ software ▁ and ▁ associated ▁ documentation ▁ files ▁ ( the ▁ " Software " ) , ▁ to ▁ deal ENDCOM # ▁ in ▁ the ▁ Software ▁ without ▁ restriction , ▁ including ▁ without ▁ limitation ▁ the ▁ rights ENDCOM # ▁ to ▁ use , ▁ copy , ▁ modify , ▁ merge , ▁ publish , ▁ distribute , ▁ sublicense , ▁ and / or ▁ sell ENDCOM # ▁ copies ▁ of ▁ the ▁ Software , ▁ and ▁ to ▁ permit ▁ persons ▁ to ▁ whom ▁ the ▁ Software ▁ is ENDCOM # ▁ furnished ▁ to ▁ do ▁ so , ▁ subject ▁ to ▁ the ▁ following ▁ conditions : ENDCOM # ▁ The ▁ above ▁ copyright ▁ notice ▁ and ▁ this ▁ permission ▁ notice ▁ shall ▁ be ▁ included ▁ in ▁ all ENDCOM # ▁ copies ▁ or ▁ substantial ▁ portions ▁ of ▁ the ▁ Software . ENDCOM # ▁ THE ▁ SOFTWARE ▁ IS ▁ PROVIDED ▁ " AS ▁ IS " , ▁ WITHOUT ▁ WARRANTY ▁ OF ▁ ANY ▁ KIND , ▁ EXPRESS ▁ OR ENDCOM # ▁ IMPLIED , ▁ INCLUDING ▁ BUT ▁ NOT ▁ LIMITED ▁ TO ▁ THE ▁ WARRANTIES ▁ OF ▁ MERCHANTABILITY , ENDCOM # ▁ FITNESS ▁ FOR ▁ A ▁ PARTICULAR ▁ PURPOSE ▁ AND ▁ NONINFRINGEMENT . ▁ IN ▁ NO ▁ EVENT ▁ SHALL ▁ THE ENDCOM # ▁ AUTHORS ▁ OR ▁ COPYRIGHT ▁ HOLDERS ▁ BE ▁ LIABLE ▁ FOR ▁ ANY ▁ CLAIM , ▁ DAMAGES ▁ OR ▁ OTHER ENDCOM # ▁ LIABILITY , ▁ WHETHER ▁ IN ▁ AN ▁ ACTION ▁ OF ▁ CONTRACT , ▁ TORT ▁ OR ▁ OTHERWISE , ▁ ARISING ▁ FROM , ENDCOM # ▁ OUT ▁ OF ▁ OR ▁ IN ▁ CONNECTION ▁ WITH ▁ THE ▁ SOFTWARE ▁ OR ▁ THE ▁ USE ▁ OR ▁ OTHER ▁ DEALINGS ▁ IN ▁ THE ENDCOM # ▁ SOFTWARE . ENDCOM from __future__ import absolute_import NEW_LINE import functools NEW_LINE import itertools NEW_LINE import operator NEW_LINE import sys NEW_LINE import types NEW_LINE __author__ = " Benjamin ▁ Peterson ▁ < benjamin @ python . org > " NEW_LINE __version__ = "1.10.0" NEW_LINE # ▁ Useful ▁ for ▁ very ▁ coarse ▁ version ▁ differentiation . ENDCOM PY2 = sys . version_info [ 0 ] == 2 NEW_LINE PY3 = sys . version_info [ 0 ] == 3 NEW_LINE PY34 = sys . version_info [ 0 : 2 ] >= ( 3 , 4 ) NEW_LINE if PY3 : NEW_LINE INDENT string_types = str , NEW_LINE integer_types = int , NEW_LINE class_types = type , NEW_LINE text_type = str NEW_LINE binary_type = bytes NEW_LINE MAXSIZE = sys . maxsize NEW_LINE DEDENT else : NEW_LINE INDENT string_types = basestring , NEW_LINE integer_types = ( int , long ) NEW_LINE class_types = ( type , types . ClassType ) NEW_LINE text_type = unicode NEW_LINE binary_type = str NEW_LINE if sys . platform . startswith ( " java " ) : NEW_LINE # ▁ Jython ▁ always ▁ uses ▁ 32 ▁ bits . ENDCOM INDENT MAXSIZE = int ( ( 1 << 31 ) - 1 ) NEW_LINE DEDENT else : NEW_LINE # ▁ It ' s ▁ possible ▁ to ▁ have ▁ sizeof ( long ) ▁ ! = ▁ sizeof ( Py _ ssize _ t ) . ENDCOM INDENT class X ( object ) : NEW_LINE INDENT def __len__ ( self ) : NEW_LINE INDENT return 1 << 31 NEW_LINE DEDENT DEDENT try : NEW_LINE INDENT len ( X ( ) ) NEW_LINE DEDENT except OverflowError : NEW_LINE # ▁ 32 - bit ENDCOM INDENT MAXSIZE = int ( ( 1 << 31 ) - 1 ) NEW_LINE DEDENT else : NEW_LINE # ▁ 64 - bit ENDCOM INDENT MAXSIZE = int ( ( 1 << 63 ) - 1 ) NEW_LINE DEDENT del X NEW_LINE DEDENT DEDENT def _add_doc ( func , doc ) : NEW_LINE INDENT """ Add ▁ documentation ▁ to ▁ a ▁ function . """ NEW_LINE func . __doc__ = doc NEW_LINE DEDENT def _import_module ( name ) : NEW_LINE INDENT """ Import ▁ module , ▁ returning ▁ the ▁ module ▁ after ▁ the ▁ last ▁ dot . """ NEW_LINE __import__ ( name ) NEW_LINE return sys . modules [ name ] NEW_LINE DEDENT class _LazyDescr ( object ) : NEW_LINE INDENT def __init__ ( self , name ) : NEW_LINE INDENT self . name = name NEW_LINE DEDENT def __get__ ( self , obj , tp ) : NEW_LINE INDENT result = self . _resolve ( ) NEW_LINE setattr ( obj , self . name , result ) # ▁ Invokes ▁ _ _ set _ _ . ENDCOM NEW_LINE try : NEW_LINE # ▁ This ▁ is ▁ a ▁ bit ▁ ugly , ▁ but ▁ it ▁ avoids ▁ running ▁ this ▁ again ▁ by ENDCOM # ▁ removing ▁ this ▁ descriptor . ENDCOM INDENT delattr ( obj . __class__ , self . name ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT pass NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT class MovedModule ( _LazyDescr ) : NEW_LINE INDENT def __init__ ( self , name , old , new = None ) : NEW_LINE INDENT super ( MovedModule , self ) . __init__ ( name ) NEW_LINE if PY3 : NEW_LINE INDENT if new is None : NEW_LINE INDENT new = name NEW_LINE DEDENT self . mod = new NEW_LINE DEDENT else : NEW_LINE INDENT self . mod = old NEW_LINE DEDENT DEDENT def _resolve ( self ) : NEW_LINE INDENT return _import_module ( self . mod ) NEW_LINE DEDENT def __getattr__ ( self , attr ) : NEW_LINE INDENT _module = self . _resolve ( ) NEW_LINE value = getattr ( _module , attr ) NEW_LINE setattr ( self , attr , value ) NEW_LINE return value NEW_LINE DEDENT DEDENT class _LazyModule ( types . ModuleType ) : NEW_LINE INDENT def __init__ ( self , name ) : NEW_LINE INDENT super ( _LazyModule , self ) . __init__ ( name ) NEW_LINE self . __doc__ = self . __class__ . __doc__ NEW_LINE DEDENT def __dir__ ( self ) : NEW_LINE INDENT attrs = [ " _ _ doc _ _ " , " _ _ name _ _ " ] NEW_LINE attrs += [ attr . name for attr in self . _moved_attributes ] NEW_LINE return attrs NEW_LINE # ▁ Subclasses ▁ should ▁ override ▁ this ENDCOM DEDENT _moved_attributes = [ ] NEW_LINE DEDENT class MovedAttribute ( _LazyDescr ) : NEW_LINE INDENT def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) : NEW_LINE INDENT super ( MovedAttribute , self ) . __init__ ( name ) NEW_LINE if PY3 : NEW_LINE INDENT if new_mod is None : NEW_LINE INDENT new_mod = name NEW_LINE DEDENT self . mod = new_mod NEW_LINE if new_attr is None : NEW_LINE INDENT if old_attr is None : NEW_LINE INDENT new_attr = name NEW_LINE DEDENT else : NEW_LINE INDENT new_attr = old_attr NEW_LINE DEDENT DEDENT self . attr = new_attr NEW_LINE DEDENT else : NEW_LINE INDENT self . mod = old_mod NEW_LINE if old_attr is None : NEW_LINE INDENT old_attr = name NEW_LINE DEDENT self . attr = old_attr NEW_LINE DEDENT DEDENT def _resolve ( self ) : NEW_LINE INDENT module = _import_module ( self . mod ) NEW_LINE return getattr ( module , self . attr ) NEW_LINE DEDENT DEDENT class _SixMetaPathImporter ( object ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ meta ▁ path ▁ importer ▁ to ▁ import ▁ six . moves ▁ and ▁ its ▁ submodules . STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ implements ▁ a ▁ PEP302 ▁ finder ▁ and ▁ loader . ▁ It ▁ should ▁ be ▁ compatible STRNEWLINE ▁ with ▁ Python ▁ 2.5 ▁ and ▁ all ▁ existing ▁ versions ▁ of ▁ Python3 STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , six_module_name ) : NEW_LINE INDENT self . name = six_module_name NEW_LINE self . known_modules = { } NEW_LINE DEDENT def _add_module ( self , mod , * fullnames ) : NEW_LINE INDENT for fullname in fullnames : NEW_LINE INDENT self . known_modules [ self . name + " . " + fullname ] = mod NEW_LINE DEDENT DEDENT def _get_module ( self , fullname ) : NEW_LINE INDENT return self . known_modules [ self . name + " . " + fullname ] NEW_LINE DEDENT def find_module ( self , fullname , path = None ) : NEW_LINE INDENT if fullname in self . known_modules : NEW_LINE INDENT return self NEW_LINE DEDENT return None NEW_LINE DEDENT def __get_module ( self , fullname ) : NEW_LINE INDENT try : NEW_LINE INDENT return self . known_modules [ fullname ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise ImportError ( " This ▁ loader ▁ does ▁ not ▁ know ▁ module ▁ " + fullname ) NEW_LINE DEDENT DEDENT def load_module ( self , fullname ) : NEW_LINE INDENT try : NEW_LINE # ▁ in ▁ case ▁ of ▁ a ▁ reload ENDCOM INDENT return sys . modules [ fullname ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT pass NEW_LINE DEDENT mod = self . __get_module ( fullname ) NEW_LINE if isinstance ( mod , MovedModule ) : NEW_LINE INDENT mod = mod . _resolve ( ) NEW_LINE DEDENT else : NEW_LINE INDENT mod . __loader__ = self NEW_LINE DEDENT sys . modules [ fullname ] = mod NEW_LINE return mod NEW_LINE DEDENT def is_package ( self , fullname ) : NEW_LINE INDENT """ STRNEWLINE ▁ Return ▁ true , ▁ if ▁ the ▁ named ▁ module ▁ is ▁ a ▁ package . STRNEWLINE STRNEWLINE ▁ We ▁ need ▁ this ▁ method ▁ to ▁ get ▁ correct ▁ spec ▁ objects ▁ with STRNEWLINE ▁ Python ▁ 3.4 ▁ ( see ▁ PEP451 ) STRNEWLINE ▁ """ NEW_LINE return hasattr ( self . __get_module ( fullname ) , " _ _ path _ _ " ) NEW_LINE DEDENT def get_code ( self , fullname ) : NEW_LINE INDENT """ Return ▁ None STRNEWLINE STRNEWLINE ▁ Required , ▁ if ▁ is _ package ▁ is ▁ implemented """ NEW_LINE self . __get_module ( fullname ) # ▁ eventually ▁ raises ▁ ImportError ENDCOM NEW_LINE return None NEW_LINE DEDENT get_source = get_code # ▁ same ▁ as ▁ get _ code ENDCOM NEW_LINE DEDENT _importer = _SixMetaPathImporter ( __name__ ) NEW_LINE class _MovedItems ( _LazyModule ) : NEW_LINE INDENT """ Lazy ▁ loading ▁ of ▁ moved ▁ objects """ NEW_LINE __path__ = [ ] # ▁ mark ▁ as ▁ package ENDCOM NEW_LINE DEDENT _moved_attributes = [ MovedAttribute ( " cStringIO " , " cStringIO " , " io " , " StringIO " ) , MovedAttribute ( " filter " , " itertools " , " builtins " , " ifilter " , " filter " ) , MovedAttribute ( " filterfalse " , " itertools " , " itertools " , " ifilterfalse " , " filterfalse " ) , MovedAttribute ( " input " , " _ _ builtin _ _ " , " builtins " , " raw _ input " , " input " ) , MovedAttribute ( " intern " , " _ _ builtin _ _ " , " sys " ) , MovedAttribute ( " map " , " itertools " , " builtins " , " imap " , " map " ) , MovedAttribute ( " getcwd " , " os " , " os " , " getcwdu " , " getcwd " ) , MovedAttribute ( " getcwdb " , " os " , " os " , " getcwd " , " getcwdb " ) , MovedAttribute ( " range " , " _ _ builtin _ _ " , " builtins " , " xrange " , " range " ) , MovedAttribute ( " reload _ module " , " _ _ builtin _ _ " , " importlib " if PY34 else " imp " , " reload " ) , MovedAttribute ( " reduce " , " _ _ builtin _ _ " , " functools " ) , MovedAttribute ( " shlex _ quote " , " pipes " , " shlex " , " quote " ) , MovedAttribute ( " StringIO " , " StringIO " , " io " ) , MovedAttribute ( " UserDict " , " UserDict " , " collections " ) , MovedAttribute ( " UserList " , " UserList " , " collections " ) , MovedAttribute ( " UserString " , " UserString " , " collections " ) , MovedAttribute ( " xrange " , " _ _ builtin _ _ " , " builtins " , " xrange " , " range " ) , MovedAttribute ( " zip " , " itertools " , " builtins " , " izip " , " zip " ) , MovedAttribute ( " zip _ longest " , " itertools " , " itertools " , " izip _ longest " , " zip _ longest " ) , MovedModule ( " builtins " , " _ _ builtin _ _ " ) , MovedModule ( " configparser " , " ConfigParser " ) , MovedModule ( " copyreg " , " copy _ reg " ) , MovedModule ( " dbm _ gnu " , " gdbm " , " dbm . gnu " ) , MovedModule ( " _ dummy _ thread " , " dummy _ thread " , " _ dummy _ thread " ) , MovedModule ( " http _ cookiejar " , " cookielib " , " http . cookiejar " ) , MovedModule ( " http _ cookies " , " Cookie " , " http . cookies " ) , MovedModule ( " html _ entities " , " htmlentitydefs " , " html . entities " ) , MovedModule ( " html _ parser " , " HTMLParser " , " html . parser " ) , MovedModule ( " http _ client " , " httplib " , " http . client " ) , MovedModule ( " email _ mime _ multipart " , " email . MIMEMultipart " , " email . mime . multipart " ) , MovedModule ( " email _ mime _ nonmultipart " , " email . MIMENonMultipart " , " email . mime . nonmultipart " ) , MovedModule ( " email _ mime _ text " , " email . MIMEText " , " email . mime . text " ) , MovedModule ( " email _ mime _ base " , " email . MIMEBase " , " email . mime . base " ) , MovedModule ( " BaseHTTPServer " , " BaseHTTPServer " , " http . server " ) , MovedModule ( " CGIHTTPServer " , " CGIHTTPServer " , " http . server " ) , MovedModule ( " SimpleHTTPServer " , " SimpleHTTPServer " , " http . server " ) , MovedModule ( " cPickle " , " cPickle " , " pickle " ) , MovedModule ( " queue " , " Queue " ) , MovedModule ( " reprlib " , " repr " ) , MovedModule ( " socketserver " , " SocketServer " ) , MovedModule ( " _ thread " , " thread " , " _ thread " ) , MovedModule ( " tkinter " , " Tkinter " ) , MovedModule ( " tkinter _ dialog " , " Dialog " , " tkinter . dialog " ) , MovedModule ( " tkinter _ filedialog " , " FileDialog " , " tkinter . filedialog " ) , MovedModule ( " tkinter _ scrolledtext " , " ScrolledText " , " tkinter . scrolledtext " ) , MovedModule ( " tkinter _ simpledialog " , " SimpleDialog " , " tkinter . simpledialog " ) , MovedModule ( " tkinter _ tix " , " Tix " , " tkinter . tix " ) , MovedModule ( " tkinter _ ttk " , " ttk " , " tkinter . ttk " ) , MovedModule ( " tkinter _ constants " , " Tkconstants " , " tkinter . constants " ) , MovedModule ( " tkinter _ dnd " , " Tkdnd " , " tkinter . dnd " ) , MovedModule ( " tkinter _ colorchooser " , " tkColorChooser " , " tkinter . colorchooser " ) , MovedModule ( " tkinter _ commondialog " , " tkCommonDialog " , " tkinter . commondialog " ) , MovedModule ( " tkinter _ tkfiledialog " , " tkFileDialog " , " tkinter . filedialog " ) , MovedModule ( " tkinter _ font " , " tkFont " , " tkinter . font " ) , MovedModule ( " tkinter _ messagebox " , " tkMessageBox " , " tkinter . messagebox " ) , MovedModule ( " tkinter _ tksimpledialog " , " tkSimpleDialog " , " tkinter . simpledialog " ) , MovedModule ( " urllib _ parse " , __name__ + " . moves . urllib _ parse " , " urllib . parse " ) , MovedModule ( " urllib _ error " , __name__ + " . moves . urllib _ error " , " urllib . error " ) , MovedModule ( " urllib " , __name__ + " . moves . urllib " , __name__ + " . moves . urllib " ) , MovedModule ( " urllib _ robotparser " , " robotparser " , " urllib . robotparser " ) , MovedModule ( " xmlrpc _ client " , " xmlrpclib " , " xmlrpc . client " ) , MovedModule ( " xmlrpc _ server " , " SimpleXMLRPCServer " , " xmlrpc . server " ) , ] NEW_LINE # ▁ Add ▁ windows ▁ specific ▁ modules . ENDCOM if sys . platform == " win32" : NEW_LINE INDENT _moved_attributes += [ MovedModule ( " winreg " , " _ winreg " ) , ] NEW_LINE DEDENT for attr in _moved_attributes : NEW_LINE INDENT setattr ( _MovedItems , attr . name , attr ) NEW_LINE if isinstance ( attr , MovedModule ) : NEW_LINE INDENT _importer . _add_module ( attr , " moves . " + attr . name ) NEW_LINE DEDENT DEDENT del attr NEW_LINE _MovedItems . _moved_attributes = _moved_attributes NEW_LINE moves = _MovedItems ( __name__ + " . moves " ) NEW_LINE _importer . _add_module ( moves , " moves " ) NEW_LINE class Module_six_moves_urllib_parse ( _LazyModule ) : NEW_LINE INDENT """ Lazy ▁ loading ▁ of ▁ moved ▁ objects ▁ in ▁ six . moves . urllib _ parse """ NEW_LINE DEDENT _urllib_parse_moved_attributes = [ MovedAttribute ( " ParseResult " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " SplitResult " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " parse _ qs " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " parse _ qsl " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " urldefrag " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " urljoin " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " urlparse " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " urlsplit " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " urlunparse " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " urlunsplit " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " quote " , " urllib " , " urllib . parse " ) , MovedAttribute ( " quote _ plus " , " urllib " , " urllib . parse " ) , MovedAttribute ( " unquote " , " urllib " , " urllib . parse " ) , MovedAttribute ( " unquote _ plus " , " urllib " , " urllib . parse " ) , MovedAttribute ( " urlencode " , " urllib " , " urllib . parse " ) , MovedAttribute ( " splitquery " , " urllib " , " urllib . parse " ) , MovedAttribute ( " splittag " , " urllib " , " urllib . parse " ) , MovedAttribute ( " splituser " , " urllib " , " urllib . parse " ) , MovedAttribute ( " uses _ fragment " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " uses _ netloc " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " uses _ params " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " uses _ query " , " urlparse " , " urllib . parse " ) , MovedAttribute ( " uses _ relative " , " urlparse " , " urllib . parse " ) , ] NEW_LINE for attr in _urllib_parse_moved_attributes : NEW_LINE INDENT setattr ( Module_six_moves_urllib_parse , attr . name , attr ) NEW_LINE DEDENT del attr NEW_LINE Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes NEW_LINE _importer . _add_module ( Module_six_moves_urllib_parse ( __name__ + " . moves . urllib _ parse " ) , " moves . urllib _ parse " , " moves . urllib . parse " ) NEW_LINE class Module_six_moves_urllib_error ( _LazyModule ) : NEW_LINE INDENT """ Lazy ▁ loading ▁ of ▁ moved ▁ objects ▁ in ▁ six . moves . urllib _ error """ NEW_LINE DEDENT _urllib_error_moved_attributes = [ MovedAttribute ( " URLError " , " urllib2" , " urllib . error " ) , MovedAttribute ( " HTTPError " , " urllib2" , " urllib . error " ) , MovedAttribute ( " ContentTooShortError " , " urllib " , " urllib . error " ) , ] NEW_LINE for attr in _urllib_error_moved_attributes : NEW_LINE INDENT setattr ( Module_six_moves_urllib_error , attr . name , attr ) NEW_LINE DEDENT del attr NEW_LINE Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes NEW_LINE _importer . _add_module ( Module_six_moves_urllib_error ( __name__ + " . moves . urllib . error " ) , " moves . urllib _ error " , " moves . urllib . error " ) NEW_LINE class Module_six_moves_urllib_request ( _LazyModule ) : NEW_LINE INDENT """ Lazy ▁ loading ▁ of ▁ moved ▁ objects ▁ in ▁ six . moves . urllib _ request """ NEW_LINE DEDENT _urllib_request_moved_attributes = [ MovedAttribute ( " urlopen " , " urllib2" , " urllib . request " ) , MovedAttribute ( " install _ opener " , " urllib2" , " urllib . request " ) , MovedAttribute ( " build _ opener " , " urllib2" , " urllib . request " ) , MovedAttribute ( " pathname2url " , " urllib " , " urllib . request " ) , MovedAttribute ( " url2pathname " , " urllib " , " urllib . request " ) , MovedAttribute ( " getproxies " , " urllib " , " urllib . request " ) , MovedAttribute ( " Request " , " urllib2" , " urllib . request " ) , MovedAttribute ( " OpenerDirector " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPDefaultErrorHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPRedirectHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPCookieProcessor " , " urllib2" , " urllib . request " ) , MovedAttribute ( " ProxyHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " BaseHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPPasswordMgr " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPPasswordMgrWithDefaultRealm " , " urllib2" , " urllib . request " ) , MovedAttribute ( " AbstractBasicAuthHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPBasicAuthHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " ProxyBasicAuthHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " AbstractDigestAuthHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPDigestAuthHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " ProxyDigestAuthHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPSHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " FileHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " FTPHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " CacheFTPHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " UnknownHandler " , " urllib2" , " urllib . request " ) , MovedAttribute ( " HTTPErrorProcessor " , " urllib2" , " urllib . request " ) , MovedAttribute ( " urlretrieve " , " urllib " , " urllib . request " ) , MovedAttribute ( " urlcleanup " , " urllib " , " urllib . request " ) , MovedAttribute ( " URLopener " , " urllib " , " urllib . request " ) , MovedAttribute ( " FancyURLopener " , " urllib " , " urllib . request " ) , MovedAttribute ( " proxy _ bypass " , " urllib " , " urllib . request " ) , ] NEW_LINE for attr in _urllib_request_moved_attributes : NEW_LINE INDENT setattr ( Module_six_moves_urllib_request , attr . name , attr ) NEW_LINE DEDENT del attr NEW_LINE Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes NEW_LINE _importer . _add_module ( Module_six_moves_urllib_request ( __name__ + " . moves . urllib . request " ) , " moves . urllib _ request " , " moves . urllib . request " ) NEW_LINE class Module_six_moves_urllib_response ( _LazyModule ) : NEW_LINE INDENT """ Lazy ▁ loading ▁ of ▁ moved ▁ objects ▁ in ▁ six . moves . urllib _ response """ NEW_LINE DEDENT _urllib_response_moved_attributes = [ MovedAttribute ( " addbase " , " urllib " , " urllib . response " ) , MovedAttribute ( " addclosehook " , " urllib " , " urllib . response " ) , MovedAttribute ( " addinfo " , " urllib " , " urllib . response " ) , MovedAttribute ( " addinfourl " , " urllib " , " urllib . response " ) , ] NEW_LINE for attr in _urllib_response_moved_attributes : NEW_LINE INDENT setattr ( Module_six_moves_urllib_response , attr . name , attr ) NEW_LINE DEDENT del attr NEW_LINE Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes NEW_LINE _importer . _add_module ( Module_six_moves_urllib_response ( __name__ + " . moves . urllib . response " ) , " moves . urllib _ response " , " moves . urllib . response " ) NEW_LINE class Module_six_moves_urllib_robotparser ( _LazyModule ) : NEW_LINE INDENT """ Lazy ▁ loading ▁ of ▁ moved ▁ objects ▁ in ▁ six . moves . urllib _ robotparser """ NEW_LINE DEDENT _urllib_robotparser_moved_attributes = [ MovedAttribute ( " RobotFileParser " , " robotparser " , " urllib . robotparser " ) , ] NEW_LINE for attr in _urllib_robotparser_moved_attributes : NEW_LINE INDENT setattr ( Module_six_moves_urllib_robotparser , attr . name , attr ) NEW_LINE DEDENT del attr NEW_LINE Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes NEW_LINE _importer . _add_module ( Module_six_moves_urllib_robotparser ( __name__ + " . moves . urllib . robotparser " ) , " moves . urllib _ robotparser " , " moves . urllib . robotparser " ) NEW_LINE class Module_six_moves_urllib ( types . ModuleType ) : NEW_LINE INDENT """ Create ▁ a ▁ six . moves . urllib ▁ namespace ▁ that ▁ resembles ▁ the ▁ Python ▁ 3 ▁ namespace """ NEW_LINE __path__ = [ ] # ▁ mark ▁ as ▁ package ENDCOM NEW_LINE parse = _importer . _get_module ( " moves . urllib _ parse " ) NEW_LINE error = _importer . _get_module ( " moves . urllib _ error " ) NEW_LINE request = _importer . _get_module ( " moves . urllib _ request " ) NEW_LINE response = _importer . _get_module ( " moves . urllib _ response " ) NEW_LINE robotparser = _importer . _get_module ( " moves . urllib _ robotparser " ) NEW_LINE def __dir__ ( self ) : NEW_LINE INDENT return [ ' parse ' , ' error ' , ' request ' , ' response ' , ' robotparser ' ] NEW_LINE DEDENT DEDENT _importer . _add_module ( Module_six_moves_urllib ( __name__ + " . moves . urllib " ) , " moves . urllib " ) NEW_LINE def add_move ( move ) : NEW_LINE INDENT """ Add ▁ an ▁ item ▁ to ▁ six . moves . """ NEW_LINE setattr ( _MovedItems , move . name , move ) NEW_LINE DEDENT def remove_move ( name ) : NEW_LINE INDENT """ Remove ▁ item ▁ from ▁ six . moves . """ NEW_LINE try : NEW_LINE INDENT delattr ( _MovedItems , name ) NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT try : NEW_LINE INDENT del moves . __dict__ [ name ] NEW_LINE DEDENT except KeyError : NEW_LINE INDENT raise AttributeError ( " no ▁ such ▁ move , ▁ % r " % ( name , ) ) NEW_LINE DEDENT DEDENT DEDENT if PY3 : NEW_LINE INDENT _meth_func = " _ _ func _ _ " NEW_LINE _meth_self = " _ _ self _ _ " NEW_LINE _func_closure = " _ _ closure _ _ " NEW_LINE _func_code = " _ _ code _ _ " NEW_LINE _func_defaults = " _ _ defaults _ _ " NEW_LINE _func_globals = " _ _ globals _ _ " NEW_LINE DEDENT else : NEW_LINE INDENT _meth_func = " im _ func " NEW_LINE _meth_self = " im _ self " NEW_LINE _func_closure = " func _ closure " NEW_LINE _func_code = " func _ code " NEW_LINE _func_defaults = " func _ defaults " NEW_LINE _func_globals = " func _ globals " NEW_LINE DEDENT try : NEW_LINE INDENT advance_iterator = next NEW_LINE DEDENT except NameError : NEW_LINE INDENT def advance_iterator ( it ) : NEW_LINE INDENT return it . next ( ) NEW_LINE DEDENT DEDENT next = advance_iterator NEW_LINE try : NEW_LINE INDENT callable = callable NEW_LINE DEDENT except NameError : NEW_LINE INDENT def callable ( obj ) : NEW_LINE INDENT return any ( " _ _ call _ _ " in klass . __dict__ for klass in type ( obj ) . __mro__ ) NEW_LINE DEDENT DEDENT if PY3 : NEW_LINE INDENT def get_unbound_function ( unbound ) : NEW_LINE INDENT return unbound NEW_LINE DEDENT create_bound_method = types . MethodType NEW_LINE def create_unbound_method ( func , cls ) : NEW_LINE INDENT return func NEW_LINE DEDENT Iterator = object NEW_LINE DEDENT else : NEW_LINE INDENT def get_unbound_function ( unbound ) : NEW_LINE INDENT return unbound . im_func NEW_LINE DEDENT def create_bound_method ( func , obj ) : NEW_LINE INDENT return types . MethodType ( func , obj , obj . __class__ ) NEW_LINE DEDENT def create_unbound_method ( func , cls ) : NEW_LINE INDENT return types . MethodType ( func , None , cls ) NEW_LINE DEDENT class Iterator ( object ) : NEW_LINE INDENT def next ( self ) : NEW_LINE INDENT return type ( self ) . __next__ ( self ) NEW_LINE DEDENT DEDENT callable = callable NEW_LINE DEDENT _add_doc ( get_unbound_function , """ Get ▁ the ▁ function ▁ out ▁ of ▁ a ▁ possibly ▁ unbound ▁ function """ ) NEW_LINE get_method_function = operator . attrgetter ( _meth_func ) NEW_LINE get_method_self = operator . attrgetter ( _meth_self ) NEW_LINE get_function_closure = operator . attrgetter ( _func_closure ) NEW_LINE get_function_code = operator . attrgetter ( _func_code ) NEW_LINE get_function_defaults = operator . attrgetter ( _func_defaults ) NEW_LINE get_function_globals = operator . attrgetter ( _func_globals ) NEW_LINE if PY3 : NEW_LINE INDENT def iterkeys ( d , ** kw ) : NEW_LINE INDENT return iter ( d . keys ( ** kw ) ) NEW_LINE DEDENT def itervalues ( d , ** kw ) : NEW_LINE INDENT return iter ( d . values ( ** kw ) ) NEW_LINE DEDENT def iteritems ( d , ** kw ) : NEW_LINE INDENT return iter ( d . items ( ** kw ) ) NEW_LINE DEDENT def iterlists ( d , ** kw ) : NEW_LINE INDENT return iter ( d . lists ( ** kw ) ) NEW_LINE DEDENT viewkeys = operator . methodcaller ( " keys " ) NEW_LINE viewvalues = operator . methodcaller ( " values " ) NEW_LINE viewitems = operator . methodcaller ( " items " ) NEW_LINE DEDENT else : NEW_LINE INDENT def iterkeys ( d , ** kw ) : NEW_LINE INDENT return d . iterkeys ( ** kw ) NEW_LINE DEDENT def itervalues ( d , ** kw ) : NEW_LINE INDENT return d . itervalues ( ** kw ) NEW_LINE DEDENT def iteritems ( d , ** kw ) : NEW_LINE INDENT return d . iteritems ( ** kw ) NEW_LINE DEDENT def iterlists ( d , ** kw ) : NEW_LINE INDENT return d . iterlists ( ** kw ) NEW_LINE DEDENT viewkeys = operator . methodcaller ( " viewkeys " ) NEW_LINE viewvalues = operator . methodcaller ( " viewvalues " ) NEW_LINE viewitems = operator . methodcaller ( " viewitems " ) NEW_LINE DEDENT _add_doc ( iterkeys , " Return ▁ an ▁ iterator ▁ over ▁ the ▁ keys ▁ of ▁ a ▁ dictionary . " ) NEW_LINE _add_doc ( itervalues , " Return ▁ an ▁ iterator ▁ over ▁ the ▁ values ▁ of ▁ a ▁ dictionary . " ) NEW_LINE _add_doc ( iteritems , " Return ▁ an ▁ iterator ▁ over ▁ the ▁ ( key , ▁ value ) ▁ pairs ▁ of ▁ a ▁ dictionary . " ) NEW_LINE _add_doc ( iterlists , " Return ▁ an ▁ iterator ▁ over ▁ the ▁ ( key , ▁ [ values ] ) ▁ pairs ▁ of ▁ a ▁ dictionary . " ) NEW_LINE if PY3 : NEW_LINE INDENT def b ( s ) : NEW_LINE INDENT return s . encode ( " latin - 1" ) NEW_LINE DEDENT def u ( s ) : NEW_LINE INDENT return s NEW_LINE DEDENT unichr = chr NEW_LINE import struct NEW_LINE int2byte = struct . Struct ( " > B " ) . pack NEW_LINE del struct NEW_LINE byte2int = operator . itemgetter ( 0 ) NEW_LINE indexbytes = operator . getitem NEW_LINE iterbytes = iter NEW_LINE import io NEW_LINE StringIO = io . StringIO NEW_LINE BytesIO = io . BytesIO NEW_LINE _assertCountEqual = " assertCountEqual " NEW_LINE if sys . version_info [ 1 ] <= 1 : NEW_LINE INDENT _assertRaisesRegex = " assertRaisesRegexp " NEW_LINE _assertRegex = " assertRegexpMatches " NEW_LINE DEDENT else : NEW_LINE INDENT _assertRaisesRegex = " assertRaisesRegex " NEW_LINE _assertRegex = " assertRegex " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT def b ( s ) : NEW_LINE INDENT return s NEW_LINE # ▁ Workaround ▁ for ▁ standalone ▁ backslash ENDCOM DEDENT def u ( s ) : NEW_LINE INDENT return unicode ( s . replace ( r ' \\ ' , r ' \\\\ ' ) , " unicode _ escape " ) NEW_LINE DEDENT unichr = unichr NEW_LINE int2byte = chr NEW_LINE def byte2int ( bs ) : NEW_LINE INDENT return ord ( bs [ 0 ] ) NEW_LINE DEDENT def indexbytes ( buf , i ) : NEW_LINE INDENT return ord ( buf [ i ] ) NEW_LINE DEDENT iterbytes = functools . partial ( itertools . imap , ord ) NEW_LINE import StringIO NEW_LINE StringIO = BytesIO = StringIO . StringIO NEW_LINE _assertCountEqual = " assertItemsEqual " NEW_LINE _assertRaisesRegex = " assertRaisesRegexp " NEW_LINE _assertRegex = " assertRegexpMatches " NEW_LINE DEDENT _add_doc ( b , """ Byte ▁ literal """ ) NEW_LINE _add_doc ( u , """ Text ▁ literal """ ) NEW_LINE def assertCountEqual ( self , * args , ** kwargs ) : NEW_LINE INDENT return getattr ( self , _assertCountEqual ) ( * args , ** kwargs ) NEW_LINE DEDENT def assertRaisesRegex ( self , * args , ** kwargs ) : NEW_LINE INDENT return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs ) NEW_LINE DEDENT def assertRegex ( self , * args , ** kwargs ) : NEW_LINE INDENT return getattr ( self , _assertRegex ) ( * args , ** kwargs ) NEW_LINE DEDENT if PY3 : NEW_LINE INDENT exec_ = getattr ( moves . builtins , " exec " ) NEW_LINE def reraise ( tp , value , tb = None ) : NEW_LINE INDENT if value is None : NEW_LINE INDENT value = tp ( ) NEW_LINE DEDENT if value . __traceback__ is not tb : NEW_LINE INDENT raise value . with_traceback ( tb ) NEW_LINE DEDENT raise value NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT def exec_ ( _code_ , _globs_ = None , _locs_ = None ) : NEW_LINE INDENT """ Execute ▁ code ▁ in ▁ a ▁ namespace . """ NEW_LINE if _globs_ is None : NEW_LINE INDENT frame = sys . _getframe ( 1 ) NEW_LINE _globs_ = frame . f_globals NEW_LINE if _locs_ is None : NEW_LINE INDENT _locs_ = frame . f_locals NEW_LINE DEDENT del frame NEW_LINE DEDENT elif _locs_ is None : NEW_LINE INDENT _locs_ = _globs_ NEW_LINE DEDENT exec ( """ exec ▁ _ code _ ▁ in ▁ _ globs _ , ▁ _ locs _ """ ) NEW_LINE DEDENT exec_ ( """ def ▁ reraise ( tp , ▁ value , ▁ tb = None ) : STRNEWLINE ▁ ▁ ▁ ▁ raise ▁ tp , ▁ value , ▁ tb STRNEWLINE """ ) NEW_LINE DEDENT if sys . version_info [ : 2 ] == ( 3 , 2 ) : NEW_LINE INDENT exec_ ( """ def ▁ raise _ from ( value , ▁ from _ value ) : STRNEWLINE ▁ ▁ ▁ ▁ if ▁ from _ value ▁ is ▁ None : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ raise ▁ value STRNEWLINE ▁ ▁ ▁ ▁ raise ▁ value ▁ from ▁ from _ value STRNEWLINE """ ) NEW_LINE DEDENT elif sys . version_info [ : 2 ] > ( 3 , 2 ) : NEW_LINE INDENT exec_ ( """ def ▁ raise _ from ( value , ▁ from _ value ) : STRNEWLINE ▁ ▁ ▁ ▁ raise ▁ value ▁ from ▁ from _ value STRNEWLINE """ ) NEW_LINE DEDENT else : NEW_LINE INDENT def raise_from ( value , from_value ) : NEW_LINE INDENT raise value NEW_LINE DEDENT DEDENT print_ = getattr ( moves . builtins , " print " , None ) NEW_LINE if print_ is None : NEW_LINE INDENT def print_ ( * args , ** kwargs ) : NEW_LINE INDENT """ The ▁ new - style ▁ print ▁ function ▁ for ▁ Python ▁ 2.4 ▁ and ▁ 2.5 . """ NEW_LINE fp = kwargs . pop ( " file " , sys . stdout ) NEW_LINE if fp is None : NEW_LINE INDENT return NEW_LINE DEDENT def write ( data ) : NEW_LINE INDENT if not isinstance ( data , basestring ) : NEW_LINE INDENT data = str ( data ) NEW_LINE # ▁ If ▁ the ▁ file ▁ has ▁ an ▁ encoding , ▁ encode ▁ unicode ▁ with ▁ it . ENDCOM DEDENT if ( isinstance ( fp , file ) and isinstance ( data , unicode ) and fp . encoding is not None ) : NEW_LINE INDENT errors = getattr ( fp , " errors " , None ) NEW_LINE if errors is None : NEW_LINE INDENT errors = " strict " NEW_LINE DEDENT data = data . encode ( fp . encoding , errors ) NEW_LINE DEDENT fp . write ( data ) NEW_LINE DEDENT want_unicode = False NEW_LINE sep = kwargs . pop ( " sep " , None ) NEW_LINE if sep is not None : NEW_LINE INDENT if isinstance ( sep , unicode ) : NEW_LINE INDENT want_unicode = True NEW_LINE DEDENT elif not isinstance ( sep , str ) : NEW_LINE INDENT raise TypeError ( " sep ▁ must ▁ be ▁ None ▁ or ▁ a ▁ string " ) NEW_LINE DEDENT DEDENT end = kwargs . pop ( " end " , None ) NEW_LINE if end is not None : NEW_LINE INDENT if isinstance ( end , unicode ) : NEW_LINE INDENT want_unicode = True NEW_LINE DEDENT elif not isinstance ( end , str ) : NEW_LINE INDENT raise TypeError ( " end ▁ must ▁ be ▁ None ▁ or ▁ a ▁ string " ) NEW_LINE DEDENT DEDENT if kwargs : NEW_LINE INDENT raise TypeError ( " invalid ▁ keyword ▁ arguments ▁ to ▁ print ( ) " ) NEW_LINE DEDENT if not want_unicode : NEW_LINE INDENT for arg in args : NEW_LINE INDENT if isinstance ( arg , unicode ) : NEW_LINE INDENT want_unicode = True NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if want_unicode : NEW_LINE INDENT newline = unicode ( " \n " ) NEW_LINE space = unicode ( " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT newline = " \n " NEW_LINE space = " ▁ " NEW_LINE DEDENT if sep is None : NEW_LINE INDENT sep = space NEW_LINE DEDENT if end is None : NEW_LINE INDENT end = newline NEW_LINE DEDENT for i , arg in enumerate ( args ) : NEW_LINE INDENT if i : NEW_LINE INDENT write ( sep ) NEW_LINE DEDENT write ( arg ) NEW_LINE DEDENT write ( end ) NEW_LINE DEDENT DEDENT if sys . version_info [ : 2 ] < ( 3 , 3 ) : NEW_LINE INDENT _print = print_ NEW_LINE def print_ ( * args , ** kwargs ) : NEW_LINE INDENT fp = kwargs . get ( " file " , sys . stdout ) NEW_LINE flush = kwargs . pop ( " flush " , False ) NEW_LINE _print ( * args , ** kwargs ) NEW_LINE if flush and fp is not None : NEW_LINE INDENT fp . flush ( ) NEW_LINE DEDENT DEDENT DEDENT _add_doc ( reraise , """ Reraise ▁ an ▁ exception . """ ) NEW_LINE if sys . version_info [ 0 : 2 ] < ( 3 , 4 ) : NEW_LINE INDENT def wraps ( wrapped , assigned = functools . WRAPPER_ASSIGNMENTS , updated = functools . WRAPPER_UPDATES ) : NEW_LINE INDENT def wrapper ( f ) : NEW_LINE INDENT f = functools . wraps ( wrapped , assigned , updated ) ( f ) NEW_LINE f . __wrapped__ = wrapped NEW_LINE return f NEW_LINE DEDENT return wrapper NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT wraps = functools . wraps NEW_LINE DEDENT def with_metaclass ( meta , * bases ) : NEW_LINE INDENT """ Create ▁ a ▁ base ▁ class ▁ with ▁ a ▁ metaclass . """ NEW_LINE # ▁ This ▁ requires ▁ a ▁ bit ▁ of ▁ explanation : ▁ the ▁ basic ▁ idea ▁ is ▁ to ▁ make ▁ a ▁ dummy ENDCOM # ▁ metaclass ▁ for ▁ one ▁ level ▁ of ▁ class ▁ instantiation ▁ that ▁ replaces ▁ itself ▁ with ENDCOM # ▁ the ▁ actual ▁ metaclass . ENDCOM class metaclass ( meta ) : NEW_LINE INDENT def __new__ ( cls , name , this_bases , d ) : NEW_LINE INDENT return meta ( name , bases , d ) NEW_LINE DEDENT DEDENT return type . __new__ ( metaclass , ' temporary _ class ' , ( ) , { } ) NEW_LINE DEDENT def add_metaclass ( metaclass ) : NEW_LINE INDENT """ Class ▁ decorator ▁ for ▁ creating ▁ a ▁ class ▁ with ▁ a ▁ metaclass . """ NEW_LINE def wrapper ( cls ) : NEW_LINE INDENT orig_vars = cls . __dict__ . copy ( ) NEW_LINE slots = orig_vars . get ( ' _ _ slots _ _ ' ) NEW_LINE if slots is not None : NEW_LINE INDENT if isinstance ( slots , str ) : NEW_LINE INDENT slots = [ slots ] NEW_LINE DEDENT for slots_var in slots : NEW_LINE INDENT orig_vars . pop ( slots_var ) NEW_LINE DEDENT DEDENT orig_vars . pop ( ' _ _ dict _ _ ' , None ) NEW_LINE orig_vars . pop ( ' _ _ weakref _ _ ' , None ) NEW_LINE return metaclass ( cls . __name__ , cls . __bases__ , orig_vars ) NEW_LINE DEDENT return wrapper NEW_LINE DEDENT def python_2_unicode_compatible ( klass ) : NEW_LINE INDENT """ STRNEWLINE ▁ A ▁ decorator ▁ that ▁ defines ▁ _ _ unicode _ _ ▁ and ▁ _ _ str _ _ ▁ methods ▁ under ▁ Python ▁ 2 . STRNEWLINE ▁ Under ▁ Python ▁ 3 ▁ it ▁ does ▁ nothing . STRNEWLINE STRNEWLINE ▁ To ▁ support ▁ Python ▁ 2 ▁ and ▁ 3 ▁ with ▁ a ▁ single ▁ code ▁ base , ▁ define ▁ a ▁ _ _ str _ _ ▁ method STRNEWLINE ▁ returning ▁ text ▁ and ▁ apply ▁ this ▁ decorator ▁ to ▁ the ▁ class . STRNEWLINE ▁ """ NEW_LINE if PY2 : NEW_LINE INDENT if ' _ _ str _ _ ' not in klass . __dict__ : NEW_LINE INDENT raise ValueError ( " @ python _ 2 _ unicode _ compatible ▁ cannot ▁ be ▁ applied ▁ " " to ▁ % s ▁ because ▁ it ▁ doesn ' t ▁ define ▁ _ _ str _ _ ( ) . " % klass . __name__ ) NEW_LINE DEDENT klass . __unicode__ = klass . __str__ NEW_LINE klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( ' utf - 8' ) NEW_LINE DEDENT return klass NEW_LINE # ▁ Complete ▁ the ▁ moves ▁ implementation . ENDCOM # ▁ This ▁ code ▁ is ▁ at ▁ the ▁ end ▁ of ▁ this ▁ module ▁ to ▁ speed ▁ up ▁ module ▁ loading . ENDCOM # ▁ Turn ▁ this ▁ module ▁ into ▁ a ▁ package . ENDCOM DEDENT __path__ = [ ] # ▁ required ▁ for ▁ PEP ▁ 302 ▁ and ▁ PEP ▁ 451 ENDCOM NEW_LINE __package__ = __name__ # ▁ see ▁ PEP ▁ 366 ▁ @ ReservedAssignment ENDCOM NEW_LINE if globals ( ) . get ( " _ _ spec _ _ " ) is not None : NEW_LINE INDENT __spec__ . submodule_search_locations = [ ] # ▁ PEP ▁ 451 ▁ @ UndefinedVariable ENDCOM NEW_LINE # ▁ Remove ▁ other ▁ six ▁ meta ▁ path ▁ importers , ▁ since ▁ they ▁ cause ▁ problems . ▁ This ▁ can ENDCOM # ▁ happen ▁ if ▁ six ▁ is ▁ removed ▁ from ▁ sys . modules ▁ and ▁ then ▁ reloaded . ▁ ( Setuptools ▁ does ENDCOM # ▁ this ▁ for ▁ some ▁ reason . ) ENDCOM DEDENT if sys . meta_path : NEW_LINE INDENT for i , importer in enumerate ( sys . meta_path ) : NEW_LINE # ▁ Here ' s ▁ some ▁ real ▁ nastiness : ▁ Another ▁ " instance " ▁ of ▁ the ▁ six ▁ module ▁ might ENDCOM # ▁ be ▁ floating ▁ around . ▁ Therefore , ▁ we ▁ can ' t ▁ use ▁ isinstance ( ) ▁ to ▁ check ▁ for ENDCOM # ▁ the ▁ six ▁ meta ▁ path ▁ importer , ▁ since ▁ the ▁ other ▁ six ▁ instance ▁ will ▁ have ENDCOM # ▁ inserted ▁ an ▁ importer ▁ with ▁ different ▁ class . ENDCOM INDENT if ( type ( importer ) . __name__ == " _ SixMetaPathImporter " and importer . name == __name__ ) : NEW_LINE INDENT del sys . meta_path [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT del i , importer NEW_LINE # ▁ Finally , ▁ add ▁ the ▁ importer ▁ to ▁ the ▁ meta ▁ path ▁ import ▁ hook . ENDCOM DEDENT sys . meta_path . append ( _importer ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="Thraxis/pymedusa/tree/master/lib/html5lib/treewalkers/etree.py"> from __future__ import absolute_import , division , unicode_literals NEW_LINE try : NEW_LINE INDENT from collections import OrderedDict NEW_LINE DEDENT except ImportError : NEW_LINE INDENT try : NEW_LINE INDENT from ordereddict import OrderedDict NEW_LINE DEDENT except ImportError : NEW_LINE INDENT OrderedDict = dict NEW_LINE DEDENT DEDENT import re NEW_LINE from six import string_types NEW_LINE from . import _base NEW_LINE from . . utils import moduleFactoryFactory NEW_LINE tag_regexp = re . compile ( " { ( [ ^ } ] * ) } ( . * ) " ) NEW_LINE def getETreeBuilder ( ElementTreeImplementation ) : NEW_LINE INDENT ElementTree = ElementTreeImplementation NEW_LINE ElementTreeCommentType = ElementTree . Comment ( " asd " ) . tag NEW_LINE class TreeWalker ( _base . NonRecursiveTreeWalker ) : NEW_LINE INDENT """ Given ▁ the ▁ particular ▁ ElementTree ▁ representation , ▁ this ▁ implementation , STRNEWLINE ▁ to ▁ avoid ▁ using ▁ recursion , ▁ returns ▁ " nodes " ▁ as ▁ tuples ▁ with ▁ the ▁ following STRNEWLINE ▁ content : STRNEWLINE STRNEWLINE ▁ 1 . ▁ The ▁ current ▁ element STRNEWLINE STRNEWLINE ▁ 2 . ▁ The ▁ index ▁ of ▁ the ▁ element ▁ relative ▁ to ▁ its ▁ parent STRNEWLINE STRNEWLINE ▁ 3 . ▁ A ▁ stack ▁ of ▁ ancestor ▁ elements STRNEWLINE STRNEWLINE ▁ 4 . ▁ A ▁ flag ▁ " text " , ▁ " tail " ▁ or ▁ None ▁ to ▁ indicate ▁ if ▁ the ▁ current ▁ node ▁ is ▁ a STRNEWLINE ▁ text ▁ node ; ▁ either ▁ the ▁ text ▁ or ▁ tail ▁ of ▁ the ▁ current ▁ element ▁ ( 1 ) STRNEWLINE ▁ """ NEW_LINE def getNodeDetails ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : # ▁ It ▁ might ▁ be ▁ the ▁ root ▁ Element ENDCOM NEW_LINE INDENT elt , key , parents , flag = node NEW_LINE if flag in ( " text " , " tail " ) : NEW_LINE INDENT return _base . TEXT , getattr ( elt , flag ) NEW_LINE DEDENT else : NEW_LINE INDENT node = elt NEW_LINE DEDENT DEDENT if not ( hasattr ( node , " tag " ) ) : NEW_LINE INDENT node = node . getroot ( ) NEW_LINE DEDENT if node . tag in ( " DOCUMENT _ ROOT " , " DOCUMENT _ FRAGMENT " ) : NEW_LINE INDENT return ( _base . DOCUMENT , ) NEW_LINE DEDENT elif node . tag == " < ! DOCTYPE > " : NEW_LINE INDENT return ( _base . DOCTYPE , node . text , node . get ( " publicId " ) , node . get ( " systemId " ) ) NEW_LINE DEDENT elif node . tag == ElementTreeCommentType : NEW_LINE INDENT return _base . COMMENT , node . text NEW_LINE DEDENT else : NEW_LINE INDENT assert isinstance ( node . tag , string_types ) , type ( node . tag ) NEW_LINE # ▁ This ▁ is ▁ assumed ▁ to ▁ be ▁ an ▁ ordinary ▁ element ENDCOM match = tag_regexp . match ( node . tag ) NEW_LINE if match : NEW_LINE INDENT namespace , tag = match . groups ( ) NEW_LINE DEDENT else : NEW_LINE INDENT namespace = None NEW_LINE tag = node . tag NEW_LINE DEDENT attrs = OrderedDict ( ) NEW_LINE for name , value in list ( node . attrib . items ( ) ) : NEW_LINE INDENT match = tag_regexp . match ( name ) NEW_LINE if match : NEW_LINE INDENT attrs [ ( match . group ( 1 ) , match . group ( 2 ) ) ] = value NEW_LINE DEDENT else : NEW_LINE INDENT attrs [ ( None , name ) ] = value NEW_LINE DEDENT DEDENT return ( _base . ELEMENT , namespace , tag , attrs , len ( node ) or node . text ) NEW_LINE DEDENT DEDENT def getFirstChild ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : NEW_LINE INDENT element , key , parents , flag = node NEW_LINE DEDENT else : NEW_LINE INDENT element , key , parents , flag = node , None , [ ] , None NEW_LINE DEDENT if flag in ( " text " , " tail " ) : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT if element . text : NEW_LINE INDENT return element , key , parents , " text " NEW_LINE DEDENT elif len ( element ) : NEW_LINE INDENT parents . append ( element ) NEW_LINE return element [ 0 ] , 0 , parents , None NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT DEDENT def getNextSibling ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : NEW_LINE INDENT element , key , parents , flag = node NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT if flag == " text " : NEW_LINE INDENT if len ( element ) : NEW_LINE INDENT parents . append ( element ) NEW_LINE return element [ 0 ] , 0 , parents , None NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if element . tail and flag != " tail " : NEW_LINE INDENT return element , key , parents , " tail " NEW_LINE DEDENT elif key < len ( parents [ - 1 ] ) - 1 : NEW_LINE INDENT return parents [ - 1 ] [ key + 1 ] , key + 1 , parents , None NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT DEDENT def getParentNode ( self , node ) : NEW_LINE INDENT if isinstance ( node , tuple ) : NEW_LINE INDENT element , key , parents , flag = node NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT if flag == " text " : NEW_LINE INDENT if not parents : NEW_LINE INDENT return element NEW_LINE DEDENT else : NEW_LINE INDENT return element , key , parents , None NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT parent = parents . pop ( ) NEW_LINE if not parents : NEW_LINE INDENT return parent NEW_LINE DEDENT else : NEW_LINE INDENT return parent , list ( parents [ - 1 ] ) . index ( parent ) , parents , None NEW_LINE DEDENT DEDENT DEDENT DEDENT return locals ( ) NEW_LINE DEDENT getETreeModule = moduleFactoryFactory ( getETreeBuilder ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="coronary/RandomEpisode/tree/master/depends/Lib/encodings/cp1006.py"> """ ▁ Python ▁ Character ▁ Mapping ▁ Codec ▁ cp1006 ▁ generated ▁ from ▁ ' MAPPINGS / VENDORS / MISC / CP1006 . TXT ' ▁ with ▁ gencodec . py . STRNEWLINE STRNEWLINE """ NEW_LINE import codecs NEW_LINE # # # ▁ Codec ▁ APIs ENDCOM class Codec ( codecs . Codec ) : NEW_LINE INDENT def encode ( self , input , errors = ' strict ' ) : NEW_LINE INDENT return codecs . charmap_encode ( input , errors , encoding_table ) NEW_LINE DEDENT def decode ( self , input , errors = ' strict ' ) : NEW_LINE INDENT return codecs . charmap_decode ( input , errors , decoding_table ) NEW_LINE DEDENT DEDENT class IncrementalEncoder ( codecs . IncrementalEncoder ) : NEW_LINE INDENT def encode ( self , input , final = False ) : NEW_LINE INDENT return codecs . charmap_encode ( input , self . errors , encoding_table ) [ 0 ] NEW_LINE DEDENT DEDENT class IncrementalDecoder ( codecs . IncrementalDecoder ) : NEW_LINE INDENT def decode ( self , input , final = False ) : NEW_LINE INDENT return codecs . charmap_decode ( input , self . errors , decoding_table ) [ 0 ] NEW_LINE DEDENT DEDENT class StreamWriter ( Codec , codecs . StreamWriter ) : NEW_LINE INDENT pass NEW_LINE DEDENT class StreamReader ( Codec , codecs . StreamReader ) : NEW_LINE INDENT pass NEW_LINE # # # ▁ encodings ▁ module ▁ API ENDCOM DEDENT def getregentry ( ) : NEW_LINE INDENT return codecs . CodecInfo ( name = ' cp1006' , encode = Codec ( ) . encode , decode = Codec ( ) . decode , incrementalencoder = IncrementalEncoder , incrementaldecoder = IncrementalDecoder , streamreader = StreamReader , streamwriter = StreamWriter , ) NEW_LINE # # # ▁ Decoding ▁ Table ENDCOM DEDENT decoding_table = ( ' \x00' # ▁ 0x00 ▁ - > ▁ NULL ENDCOM ' \x01' # ▁ 0x01 ▁ - > ▁ START ▁ OF ▁ HEADING ENDCOM ' \x02' # ▁ 0x02 ▁ - > ▁ START ▁ OF ▁ TEXT ENDCOM ' \x03' # ▁ 0x03 ▁ - > ▁ END ▁ OF ▁ TEXT ENDCOM ' \x04' # ▁ 0x04 ▁ - > ▁ END ▁ OF ▁ TRANSMISSION ENDCOM ' \x05' # ▁ 0x05 ▁ - > ▁ ENQUIRY ENDCOM ' \x06' # ▁ 0x06 ▁ - > ▁ ACKNOWLEDGE ENDCOM ' \x07' # ▁ 0x07 ▁ - > ▁ BELL ENDCOM ' \x08' # ▁ 0x08 ▁ - > ▁ BACKSPACE ENDCOM ' \t ' # ▁ 0x09 ▁ - > ▁ HORIZONTAL ▁ TABULATION ENDCOM ' \n ' # ▁ 0x0A ▁ - > ▁ LINE ▁ FEED ENDCOM ' \x0b ' # ▁ 0x0B ▁ - > ▁ VERTICAL ▁ TABULATION ENDCOM ' \x0c ' # ▁ 0x0C ▁ - > ▁ FORM ▁ FEED ENDCOM ' ' # ▁ 0x0D ▁ - > ▁ CARRIAGE ▁ RETURN ENDCOM ' \x0e ' # ▁ 0x0E ▁ - > ▁ SHIFT ▁ OUT ENDCOM ' \x0f ' # ▁ 0x0F ▁ - > ▁ SHIFT ▁ IN ENDCOM ' \x10' # ▁ 0x10 ▁ - > ▁ DATA ▁ LINK ▁ ESCAPE ENDCOM ' \x11' # ▁ 0x11 ▁ - > ▁ DEVICE ▁ CONTROL ▁ ONE ENDCOM ' \x12' # ▁ 0x12 ▁ - > ▁ DEVICE ▁ CONTROL ▁ TWO ENDCOM ' \x13' # ▁ 0x13 ▁ - > ▁ DEVICE ▁ CONTROL ▁ THREE ENDCOM ' \x14' # ▁ 0x14 ▁ - > ▁ DEVICE ▁ CONTROL ▁ FOUR ENDCOM ' \x15' # ▁ 0x15 ▁ - > ▁ NEGATIVE ▁ ACKNOWLEDGE ENDCOM ' \x16' # ▁ 0x16 ▁ - > ▁ SYNCHRONOUS ▁ IDLE ENDCOM ' \x17' # ▁ 0x17 ▁ - > ▁ END ▁ OF ▁ TRANSMISSION ▁ BLOCK ENDCOM ' \x18' # ▁ 0x18 ▁ - > ▁ CANCEL ENDCOM ' \x19' # ▁ 0x19 ▁ - > ▁ END ▁ OF ▁ MEDIUM ENDCOM ' \x1a ' # ▁ 0x1A ▁ - > ▁ SUBSTITUTE ENDCOM ' \x1b ' # ▁ 0x1B ▁ - > ▁ ESCAPE ENDCOM ' \x1c ' # ▁ 0x1C ▁ - > ▁ FILE ▁ SEPARATOR ENDCOM ' \x1d ' # ▁ 0x1D ▁ - > ▁ GROUP ▁ SEPARATOR ENDCOM ' \x1e ' # ▁ 0x1E ▁ - > ▁ RECORD ▁ SEPARATOR ENDCOM ' \x1f ' # ▁ 0x1F ▁ - > ▁ UNIT ▁ SEPARATOR ENDCOM ' ▁ ' # ▁ 0x20 ▁ - > ▁ SPACE ENDCOM ' ! ' # ▁ 0x21 ▁ - > ▁ EXCLAMATION ▁ MARK ENDCOM ' " ' # ▁ 0x22 ▁ - > ▁ QUOTATION ▁ MARK ENDCOM ' # ' # ▁ 0x23 ▁ - > ▁ NUMBER ▁ SIGN ENDCOM ' $ ' # ▁ 0x24 ▁ - > ▁ DOLLAR ▁ SIGN ENDCOM ' % ' # ▁ 0x25 ▁ - > ▁ PERCENT ▁ SIGN ENDCOM ' & ' # ▁ 0x26 ▁ - > ▁ AMPERSAND ENDCOM " ' " # ▁ 0x27 ▁ - > ▁ APOSTROPHE ENDCOM ' ( ' # ▁ 0x28 ▁ - > ▁ LEFT ▁ PARENTHESIS ENDCOM ' ) ' # ▁ 0x29 ▁ - > ▁ RIGHT ▁ PARENTHESIS ENDCOM ' * ' # ▁ 0x2A ▁ - > ▁ ASTERISK ENDCOM ' + ' # ▁ 0x2B ▁ - > ▁ PLUS ▁ SIGN ENDCOM ' , ' # ▁ 0x2C ▁ - > ▁ COMMA ENDCOM ' - ' # ▁ 0x2D ▁ - > ▁ HYPHEN - MINUS ENDCOM ' . ' # ▁ 0x2E ▁ - > ▁ FULL ▁ STOP ENDCOM ' / ' # ▁ 0x2F ▁ - > ▁ SOLIDUS ENDCOM '0' # ▁ 0x30 ▁ - > ▁ DIGIT ▁ ZERO ENDCOM '1' # ▁ 0x31 ▁ - > ▁ DIGIT ▁ ONE ENDCOM '2' # ▁ 0x32 ▁ - > ▁ DIGIT ▁ TWO ENDCOM '3' # ▁ 0x33 ▁ - > ▁ DIGIT ▁ THREE ENDCOM '4' # ▁ 0x34 ▁ - > ▁ DIGIT ▁ FOUR ENDCOM '5' # ▁ 0x35 ▁ - > ▁ DIGIT ▁ FIVE ENDCOM '6' # ▁ 0x36 ▁ - > ▁ DIGIT ▁ SIX ENDCOM '7' # ▁ 0x37 ▁ - > ▁ DIGIT ▁ SEVEN ENDCOM '8' # ▁ 0x38 ▁ - > ▁ DIGIT ▁ EIGHT ENDCOM '9' # ▁ 0x39 ▁ - > ▁ DIGIT ▁ NINE ENDCOM ' : ' # ▁ 0x3A ▁ - > ▁ COLON ENDCOM ' ; ' # ▁ 0x3B ▁ - > ▁ SEMICOLON ENDCOM ' < ' # ▁ 0x3C ▁ - > ▁ LESS - THAN ▁ SIGN ENDCOM ' = ' # ▁ 0x3D ▁ - > ▁ EQUALS ▁ SIGN ENDCOM ' > ' # ▁ 0x3E ▁ - > ▁ GREATER - THAN ▁ SIGN ENDCOM ' ? ' # ▁ 0x3F ▁ - > ▁ QUESTION ▁ MARK ENDCOM ' @ ' # ▁ 0x40 ▁ - > ▁ COMMERCIAL ▁ AT ENDCOM ' A ' # ▁ 0x41 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ A ENDCOM ' B ' # ▁ 0x42 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ B ENDCOM ' C ' # ▁ 0x43 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ C ENDCOM ' D ' # ▁ 0x44 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ D ENDCOM ' E ' # ▁ 0x45 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ E ENDCOM ' F ' # ▁ 0x46 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ F ENDCOM ' G ' # ▁ 0x47 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ G ENDCOM ' H ' # ▁ 0x48 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ H ENDCOM ' I ' # ▁ 0x49 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ I ENDCOM ' J ' # ▁ 0x4A ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ J ENDCOM ' K ' # ▁ 0x4B ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ K ENDCOM ' L ' # ▁ 0x4C ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ L ENDCOM ' M ' # ▁ 0x4D ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ M ENDCOM ' N ' # ▁ 0x4E ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ N ENDCOM ' O ' # ▁ 0x4F ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ O ENDCOM ' P ' # ▁ 0x50 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ P ENDCOM ' Q ' # ▁ 0x51 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ Q ENDCOM ' R ' # ▁ 0x52 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ R ENDCOM ' S ' # ▁ 0x53 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ S ENDCOM ' T ' # ▁ 0x54 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ T ENDCOM ' U ' # ▁ 0x55 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ U ENDCOM ' V ' # ▁ 0x56 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ V ENDCOM ' W ' # ▁ 0x57 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ W ENDCOM ' X ' # ▁ 0x58 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ X ENDCOM ' Y ' # ▁ 0x59 ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ Y ENDCOM ' Z ' # ▁ 0x5A ▁ - > ▁ LATIN ▁ CAPITAL ▁ LETTER ▁ Z ENDCOM ' [ ' # ▁ 0x5B ▁ - > ▁ LEFT ▁ SQUARE ▁ BRACKET ENDCOM ' \\ ' # ▁ 0x5C ▁ - > ▁ REVERSE ▁ SOLIDUS ENDCOM ' ] ' # ▁ 0x5D ▁ - > ▁ RIGHT ▁ SQUARE ▁ BRACKET ENDCOM ' ^ ' # ▁ 0x5E ▁ - > ▁ CIRCUMFLEX ▁ ACCENT ENDCOM ' _ ' # ▁ 0x5F ▁ - > ▁ LOW ▁ LINE ENDCOM ' ` ' # ▁ 0x60 ▁ - > ▁ GRAVE ▁ ACCENT ENDCOM ' a ' # ▁ 0x61 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ A ENDCOM ' b ' # ▁ 0x62 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ B ENDCOM ' c ' # ▁ 0x63 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ C ENDCOM ' d ' # ▁ 0x64 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ D ENDCOM ' e ' # ▁ 0x65 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ E ENDCOM ' f ' # ▁ 0x66 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ F ENDCOM ' g ' # ▁ 0x67 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ G ENDCOM ' h ' # ▁ 0x68 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ H ENDCOM ' i ' # ▁ 0x69 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ I ENDCOM ' j ' # ▁ 0x6A ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ J ENDCOM ' k ' # ▁ 0x6B ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ K ENDCOM ' l ' # ▁ 0x6C ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ L ENDCOM ' m ' # ▁ 0x6D ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ M ENDCOM ' n ' # ▁ 0x6E ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ N ENDCOM ' o ' # ▁ 0x6F ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ O ENDCOM ' p ' # ▁ 0x70 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ P ENDCOM ' q ' # ▁ 0x71 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ Q ENDCOM ' r ' # ▁ 0x72 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ R ENDCOM ' s ' # ▁ 0x73 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ S ENDCOM ' t ' # ▁ 0x74 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ T ENDCOM ' u ' # ▁ 0x75 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ U ENDCOM ' v ' # ▁ 0x76 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ V ENDCOM ' w ' # ▁ 0x77 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ W ENDCOM ' x ' # ▁ 0x78 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ X ENDCOM ' y ' # ▁ 0x79 ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ Y ENDCOM ' z ' # ▁ 0x7A ▁ - > ▁ LATIN ▁ SMALL ▁ LETTER ▁ Z ENDCOM ' { ' # ▁ 0x7B ▁ - > ▁ LEFT ▁ CURLY ▁ BRACKET ENDCOM ' | ' # ▁ 0x7C ▁ - > ▁ VERTICAL ▁ LINE ENDCOM ' } ' # ▁ 0x7D ▁ - > ▁ RIGHT ▁ CURLY ▁ BRACKET ENDCOM ' ~ ' # ▁ 0x7E ▁ - > ▁ TILDE ENDCOM ' \x7f ' # ▁ 0x7F ▁ - > ▁ DELETE ENDCOM ' \x80' # ▁ 0x80 ▁ - > ▁ < control > ENDCOM ' \x81' # ▁ 0x81 ▁ - > ▁ < control > ENDCOM ' \x82' # ▁ 0x82 ▁ - > ▁ < control > ENDCOM ' \x83' # ▁ 0x83 ▁ - > ▁ < control > ENDCOM ' \x84' # ▁ 0x84 ▁ - > ▁ < control > ENDCOM ' \x85' # ▁ 0x85 ▁ - > ▁ < control > ENDCOM ' \x86' # ▁ 0x86 ▁ - > ▁ < control > ENDCOM ' \x87' # ▁ 0x87 ▁ - > ▁ < control > ENDCOM ' \x88' # ▁ 0x88 ▁ - > ▁ < control > ENDCOM ' \x89' # ▁ 0x89 ▁ - > ▁ < control > ENDCOM ' \x8a ' # ▁ 0x8A ▁ - > ▁ < control > ENDCOM ' \x8b ' # ▁ 0x8B ▁ - > ▁ < control > ENDCOM ' \x8c ' # ▁ 0x8C ▁ - > ▁ < control > ENDCOM ' \x8d ' # ▁ 0x8D ▁ - > ▁ < control > ENDCOM ' \x8e ' # ▁ 0x8E ▁ - > ▁ < control > ENDCOM ' \x8f ' # ▁ 0x8F ▁ - > ▁ < control > ENDCOM ' \x90' # ▁ 0x90 ▁ - > ▁ < control > ENDCOM ' \x91' # ▁ 0x91 ▁ - > ▁ < control > ENDCOM ' \x92' # ▁ 0x92 ▁ - > ▁ < control > ENDCOM ' \x93' # ▁ 0x93 ▁ - > ▁ < control > ENDCOM ' \x94' # ▁ 0x94 ▁ - > ▁ < control > ENDCOM ' \x95' # ▁ 0x95 ▁ - > ▁ < control > ENDCOM ' \x96' # ▁ 0x96 ▁ - > ▁ < control > ENDCOM ' \x97' # ▁ 0x97 ▁ - > ▁ < control > ENDCOM ' \x98' # ▁ 0x98 ▁ - > ▁ < control > ENDCOM ' \x99' # ▁ 0x99 ▁ - > ▁ < control > ENDCOM ' \x9a ' # ▁ 0x9A ▁ - > ▁ < control > ENDCOM ' \x9b ' # ▁ 0x9B ▁ - > ▁ < control > ENDCOM ' \x9c ' # ▁ 0x9C ▁ - > ▁ < control > ENDCOM ' \x9d ' # ▁ 0x9D ▁ - > ▁ < control > ENDCOM ' \x9e ' # ▁ 0x9E ▁ - > ▁ < control > ENDCOM ' \x9f ' # ▁ 0x9F ▁ - > ▁ < control > ENDCOM ' \xa0' # ▁ 0xA0 ▁ - > ▁ NO - BREAK ▁ SPACE ENDCOM ' \u06f0' # ▁ 0xA1 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ ZERO ENDCOM ' \u06f1' # ▁ 0xA2 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ ONE ENDCOM ' \u06f2' # ▁ 0xA3 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ TWO ENDCOM ' \u06f3' # ▁ 0xA4 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ THREE ENDCOM ' \u06f4' # ▁ 0xA5 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ FOUR ENDCOM ' \u06f5' # ▁ 0xA6 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ FIVE ENDCOM ' \u06f6' # ▁ 0xA7 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ SIX ENDCOM ' \u06f7' # ▁ 0xA8 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ SEVEN ENDCOM ' \u06f8' # ▁ 0xA9 ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ EIGHT ENDCOM ' \u06f9' # ▁ 0xAA ▁ - > ▁ EXTENDED ▁ ARABIC - INDIC ▁ DIGIT ▁ NINE ENDCOM ' \u060c ' # ▁ 0xAB ▁ - > ▁ ARABIC ▁ COMMA ENDCOM ' \u061b ' # ▁ 0xAC ▁ - > ▁ ARABIC ▁ SEMICOLON ENDCOM ' \xad ' # ▁ 0xAD ▁ - > ▁ SOFT ▁ HYPHEN ENDCOM ' \u061f ' # ▁ 0xAE ▁ - > ▁ ARABIC ▁ QUESTION ▁ MARK ENDCOM ' \ufe81' # ▁ 0xAF ▁ - > ▁ ARABIC ▁ LETTER ▁ ALEF ▁ WITH ▁ MADDA ▁ ABOVE ▁ ISOLATED ▁ FORM ENDCOM ' \ufe8d ' # ▁ 0xB0 ▁ - > ▁ ARABIC ▁ LETTER ▁ ALEF ▁ ISOLATED ▁ FORM ENDCOM ' \ufe8e ' # ▁ 0xB1 ▁ - > ▁ ARABIC ▁ LETTER ▁ ALEF ▁ FINAL ▁ FORM ENDCOM ' \ufe8e ' # ▁ 0xB2 ▁ - > ▁ ARABIC ▁ LETTER ▁ ALEF ▁ FINAL ▁ FORM ENDCOM ' \ufe8f ' # ▁ 0xB3 ▁ - > ▁ ARABIC ▁ LETTER ▁ BEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufe91' # ▁ 0xB4 ▁ - > ▁ ARABIC ▁ LETTER ▁ BEH ▁ INITIAL ▁ FORM ENDCOM ' \ufb56' # ▁ 0xB5 ▁ - > ▁ ARABIC ▁ LETTER ▁ PEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufb58' # ▁ 0xB6 ▁ - > ▁ ARABIC ▁ LETTER ▁ PEH ▁ INITIAL ▁ FORM ENDCOM ' \ufe93' # ▁ 0xB7 ▁ - > ▁ ARABIC ▁ LETTER ▁ TEH ▁ MARBUTA ▁ ISOLATED ▁ FORM ENDCOM ' \ufe95' # ▁ 0xB8 ▁ - > ▁ ARABIC ▁ LETTER ▁ TEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufe97' # ▁ 0xB9 ▁ - > ▁ ARABIC ▁ LETTER ▁ TEH ▁ INITIAL ▁ FORM ENDCOM ' \ufb66' # ▁ 0xBA ▁ - > ▁ ARABIC ▁ LETTER ▁ TTEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufb68' # ▁ 0xBB ▁ - > ▁ ARABIC ▁ LETTER ▁ TTEH ▁ INITIAL ▁ FORM ENDCOM ' \ufe99' # ▁ 0xBC ▁ - > ▁ ARABIC ▁ LETTER ▁ THEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufe9b ' # ▁ 0xBD ▁ - > ▁ ARABIC ▁ LETTER ▁ THEH ▁ INITIAL ▁ FORM ENDCOM ' \ufe9d ' # ▁ 0xBE ▁ - > ▁ ARABIC ▁ LETTER ▁ JEEM ▁ ISOLATED ▁ FORM ENDCOM ' \ufe9f ' # ▁ 0xBF ▁ - > ▁ ARABIC ▁ LETTER ▁ JEEM ▁ INITIAL ▁ FORM ENDCOM ' \ufb7a ' # ▁ 0xC0 ▁ - > ▁ ARABIC ▁ LETTER ▁ TCHEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufb7c ' # ▁ 0xC1 ▁ - > ▁ ARABIC ▁ LETTER ▁ TCHEH ▁ INITIAL ▁ FORM ENDCOM ' \ufea1' # ▁ 0xC2 ▁ - > ▁ ARABIC ▁ LETTER ▁ HAH ▁ ISOLATED ▁ FORM ENDCOM ' \ufea3' # ▁ 0xC3 ▁ - > ▁ ARABIC ▁ LETTER ▁ HAH ▁ INITIAL ▁ FORM ENDCOM ' \ufea5' # ▁ 0xC4 ▁ - > ▁ ARABIC ▁ LETTER ▁ KHAH ▁ ISOLATED ▁ FORM ENDCOM ' \ufea7' # ▁ 0xC5 ▁ - > ▁ ARABIC ▁ LETTER ▁ KHAH ▁ INITIAL ▁ FORM ENDCOM ' \ufea9' # ▁ 0xC6 ▁ - > ▁ ARABIC ▁ LETTER ▁ DAL ▁ ISOLATED ▁ FORM ENDCOM ' \ufb84' # ▁ 0xC7 ▁ - > ▁ ARABIC ▁ LETTER ▁ DAHAL ▁ ISOLATED ▁ FORMN ENDCOM ' \ufeab ' # ▁ 0xC8 ▁ - > ▁ ARABIC ▁ LETTER ▁ THAL ▁ ISOLATED ▁ FORM ENDCOM ' \ufead ' # ▁ 0xC9 ▁ - > ▁ ARABIC ▁ LETTER ▁ REH ▁ ISOLATED ▁ FORM ENDCOM ' \ufb8c ' # ▁ 0xCA ▁ - > ▁ ARABIC ▁ LETTER ▁ RREH ▁ ISOLATED ▁ FORM ENDCOM ' \ufeaf ' # ▁ 0xCB ▁ - > ▁ ARABIC ▁ LETTER ▁ ZAIN ▁ ISOLATED ▁ FORM ENDCOM ' \ufb8a ' # ▁ 0xCC ▁ - > ▁ ARABIC ▁ LETTER ▁ JEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufeb1' # ▁ 0xCD ▁ - > ▁ ARABIC ▁ LETTER ▁ SEEN ▁ ISOLATED ▁ FORM ENDCOM ' \ufeb3' # ▁ 0xCE ▁ - > ▁ ARABIC ▁ LETTER ▁ SEEN ▁ INITIAL ▁ FORM ENDCOM ' \ufeb5' # ▁ 0xCF ▁ - > ▁ ARABIC ▁ LETTER ▁ SHEEN ▁ ISOLATED ▁ FORM ENDCOM ' \ufeb7' # ▁ 0xD0 ▁ - > ▁ ARABIC ▁ LETTER ▁ SHEEN ▁ INITIAL ▁ FORM ENDCOM ' \ufeb9' # ▁ 0xD1 ▁ - > ▁ ARABIC ▁ LETTER ▁ SAD ▁ ISOLATED ▁ FORM ENDCOM ' \ufebb ' # ▁ 0xD2 ▁ - > ▁ ARABIC ▁ LETTER ▁ SAD ▁ INITIAL ▁ FORM ENDCOM ' \ufebd ' # ▁ 0xD3 ▁ - > ▁ ARABIC ▁ LETTER ▁ DAD ▁ ISOLATED ▁ FORM ENDCOM ' \ufebf ' # ▁ 0xD4 ▁ - > ▁ ARABIC ▁ LETTER ▁ DAD ▁ INITIAL ▁ FORM ENDCOM ' \ufec1' # ▁ 0xD5 ▁ - > ▁ ARABIC ▁ LETTER ▁ TAH ▁ ISOLATED ▁ FORM ENDCOM ' \ufec5' # ▁ 0xD6 ▁ - > ▁ ARABIC ▁ LETTER ▁ ZAH ▁ ISOLATED ▁ FORM ENDCOM ' \ufec9' # ▁ 0xD7 ▁ - > ▁ ARABIC ▁ LETTER ▁ AIN ▁ ISOLATED ▁ FORM ENDCOM ' \ufeca ' # ▁ 0xD8 ▁ - > ▁ ARABIC ▁ LETTER ▁ AIN ▁ FINAL ▁ FORM ENDCOM ' \ufecb ' # ▁ 0xD9 ▁ - > ▁ ARABIC ▁ LETTER ▁ AIN ▁ INITIAL ▁ FORM ENDCOM ' \ufecc ' # ▁ 0xDA ▁ - > ▁ ARABIC ▁ LETTER ▁ AIN ▁ MEDIAL ▁ FORM ENDCOM ' \ufecd ' # ▁ 0xDB ▁ - > ▁ ARABIC ▁ LETTER ▁ GHAIN ▁ ISOLATED ▁ FORM ENDCOM ' \ufece ' # ▁ 0xDC ▁ - > ▁ ARABIC ▁ LETTER ▁ GHAIN ▁ FINAL ▁ FORM ENDCOM ' \ufecf ' # ▁ 0xDD ▁ - > ▁ ARABIC ▁ LETTER ▁ GHAIN ▁ INITIAL ▁ FORM ENDCOM ' \ufed0' # ▁ 0xDE ▁ - > ▁ ARABIC ▁ LETTER ▁ GHAIN ▁ MEDIAL ▁ FORM ENDCOM ' \ufed1' # ▁ 0xDF ▁ - > ▁ ARABIC ▁ LETTER ▁ FEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufed3' # ▁ 0xE0 ▁ - > ▁ ARABIC ▁ LETTER ▁ FEH ▁ INITIAL ▁ FORM ENDCOM ' \ufed5' # ▁ 0xE1 ▁ - > ▁ ARABIC ▁ LETTER ▁ QAF ▁ ISOLATED ▁ FORM ENDCOM ' \ufed7' # ▁ 0xE2 ▁ - > ▁ ARABIC ▁ LETTER ▁ QAF ▁ INITIAL ▁ FORM ENDCOM ' \ufed9' # ▁ 0xE3 ▁ - > ▁ ARABIC ▁ LETTER ▁ KAF ▁ ISOLATED ▁ FORM ENDCOM ' \ufedb ' # ▁ 0xE4 ▁ - > ▁ ARABIC ▁ LETTER ▁ KAF ▁ INITIAL ▁ FORM ENDCOM ' \ufb92' # ▁ 0xE5 ▁ - > ▁ ARABIC ▁ LETTER ▁ GAF ▁ ISOLATED ▁ FORM ENDCOM ' \ufb94' # ▁ 0xE6 ▁ - > ▁ ARABIC ▁ LETTER ▁ GAF ▁ INITIAL ▁ FORM ENDCOM ' \ufedd ' # ▁ 0xE7 ▁ - > ▁ ARABIC ▁ LETTER ▁ LAM ▁ ISOLATED ▁ FORM ENDCOM ' \ufedf ' # ▁ 0xE8 ▁ - > ▁ ARABIC ▁ LETTER ▁ LAM ▁ INITIAL ▁ FORM ENDCOM ' \ufee0' # ▁ 0xE9 ▁ - > ▁ ARABIC ▁ LETTER ▁ LAM ▁ MEDIAL ▁ FORM ENDCOM ' \ufee1' # ▁ 0xEA ▁ - > ▁ ARABIC ▁ LETTER ▁ MEEM ▁ ISOLATED ▁ FORM ENDCOM ' \ufee3' # ▁ 0xEB ▁ - > ▁ ARABIC ▁ LETTER ▁ MEEM ▁ INITIAL ▁ FORM ENDCOM ' \ufb9e ' # ▁ 0xEC ▁ - > ▁ ARABIC ▁ LETTER ▁ NOON ▁ GHUNNA ▁ ISOLATED ▁ FORM ENDCOM ' \ufee5' # ▁ 0xED ▁ - > ▁ ARABIC ▁ LETTER ▁ NOON ▁ ISOLATED ▁ FORM ENDCOM ' \ufee7' # ▁ 0xEE ▁ - > ▁ ARABIC ▁ LETTER ▁ NOON ▁ INITIAL ▁ FORM ENDCOM ' \ufe85' # ▁ 0xEF ▁ - > ▁ ARABIC ▁ LETTER ▁ WAW ▁ WITH ▁ HAMZA ▁ ABOVE ▁ ISOLATED ▁ FORM ENDCOM ' \ufeed ' # ▁ 0xF0 ▁ - > ▁ ARABIC ▁ LETTER ▁ WAW ▁ ISOLATED ▁ FORM ENDCOM ' \ufba6' # ▁ 0xF1 ▁ - > ▁ ARABIC ▁ LETTER ▁ HEH ▁ GOAL ▁ ISOLATED ▁ FORM ENDCOM ' \ufba8' # ▁ 0xF2 ▁ - > ▁ ARABIC ▁ LETTER ▁ HEH ▁ GOAL ▁ INITIAL ▁ FORM ENDCOM ' \ufba9' # ▁ 0xF3 ▁ - > ▁ ARABIC ▁ LETTER ▁ HEH ▁ GOAL ▁ MEDIAL ▁ FORM ENDCOM ' \ufbaa ' # ▁ 0xF4 ▁ - > ▁ ARABIC ▁ LETTER ▁ HEH ▁ DOACHASHMEE ▁ ISOLATED ▁ FORM ENDCOM ' \ufe80' # ▁ 0xF5 ▁ - > ▁ ARABIC ▁ LETTER ▁ HAMZA ▁ ISOLATED ▁ FORM ENDCOM ' \ufe89' # ▁ 0xF6 ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ WITH ▁ HAMZA ▁ ABOVE ▁ ISOLATED ▁ FORM ENDCOM ' \ufe8a ' # ▁ 0xF7 ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ WITH ▁ HAMZA ▁ ABOVE ▁ FINAL ▁ FORM ENDCOM ' \ufe8b ' # ▁ 0xF8 ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ WITH ▁ HAMZA ▁ ABOVE ▁ INITIAL ▁ FORM ENDCOM ' \ufef1' # ▁ 0xF9 ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ ISOLATED ▁ FORM ENDCOM ' \ufef2' # ▁ 0xFA ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ FINAL ▁ FORM ENDCOM ' \ufef3' # ▁ 0xFB ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ INITIAL ▁ FORM ENDCOM ' \ufbb0' # ▁ 0xFC ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ BARREE ▁ WITH ▁ HAMZA ▁ ABOVE ▁ ISOLATED ▁ FORM ENDCOM ' \ufbae ' # ▁ 0xFD ▁ - > ▁ ARABIC ▁ LETTER ▁ YEH ▁ BARREE ▁ ISOLATED ▁ FORM ENDCOM ' \ufe7c ' # ▁ 0xFE ▁ - > ▁ ARABIC ▁ SHADDA ▁ ISOLATED ▁ FORM ENDCOM ' \ufe7d ' # ▁ 0xFF ▁ - > ▁ ARABIC ▁ SHADDA ▁ MEDIAL ▁ FORM ENDCOM ) NEW_LINE # # # ▁ Encoding ▁ table ENDCOM encoding_table = codecs . charmap_build ( decoding_table ) NEW_LINE </DOCUMENT>
<DOCUMENT_ID="alokotosh/mm-master/tree/master/mm/commands/misc.py"> import os NEW_LINE import json NEW_LINE import mm . util as util NEW_LINE import mm . config as config NEW_LINE from mm . exceptions import * NEW_LINE from mm . basecommand import Command NEW_LINE from mm . sfdc_client import MavensMateClient NEW_LINE class GetActiveSessionCommand ( Command ) : NEW_LINE INDENT def execute ( self ) : NEW_LINE INDENT if ' username ' not in self . params or self . params [ ' username ' ] == None or self . params [ ' username ' ] == ' ' : NEW_LINE INDENT raise MMException ( ' Please ▁ enter ▁ a ▁ Salesforce . com ▁ username ' ) NEW_LINE DEDENT if ' password ' not in self . params or self . params [ ' password ' ] == None or self . params [ ' password ' ] == ' ' : NEW_LINE INDENT raise MMException ( ' Please ▁ enter ▁ a ▁ Salesforce . com ▁ password ' ) NEW_LINE DEDENT if ' org _ type ' not in self . params or self . params [ ' org _ type ' ] == None or self . params [ ' org _ type ' ] == ' ' : NEW_LINE INDENT raise MMException ( ' Please ▁ select ▁ an ▁ org ▁ type ' ) NEW_LINE DEDENT if ' org _ type ' in self . params and self . params [ ' org _ type ' ] == " custom " and " org _ url " not in self . params : NEW_LINE INDENT raise MMException ( ' To ▁ use ▁ a ▁ custom ▁ org ▁ type , ▁ please ▁ include ▁ a ▁ org _ url ▁ parameter ' ) NEW_LINE DEDENT if ' org _ type ' in self . params and self . params [ ' org _ type ' ] == " custom " and " org _ url " in self . params and self . params [ " org _ url " ] == " " : NEW_LINE INDENT raise MMException ( ' Please ▁ specify ▁ the ▁ org ▁ url ' ) NEW_LINE DEDENT config . logger . debug ( ' = = = = = = = = = = = = = = = = = > ' ) NEW_LINE config . logger . debug ( self . params ) NEW_LINE client = MavensMateClient ( credentials = { " username " : self . params [ ' username ' ] , " password " : self . params [ ' password ' ] , " org _ type " : self . params [ ' org _ type ' ] , " org _ url " : self . params . get ( ' org _ url ' , None ) } ) NEW_LINE response = { " sid " : client . sid , " user _ id " : client . user_id , " metadata _ server _ url " : client . metadata_server_url , " server _ url " : client . server_url , " metadata " : client . get_org_metadata ( subscription = self . params . get ( ' subscription ' , None ) ) , " org _ metadata _ types " : util . metadata_types ( ) , " success " : True } NEW_LINE return util . generate_response ( response ) NEW_LINE DEDENT DEDENT class IndexApexSymbolsCommand ( Command ) : NEW_LINE INDENT aliases = [ " index _ apex " , " index _ apex _ file _ properties " ] NEW_LINE """ STRNEWLINE ▁ Updates ▁ symbol ▁ index ▁ for ▁ one ▁ or ▁ more ▁ Apex ▁ Classes . ▁ If ▁ files ▁ is ▁ not ▁ included ▁ or ▁ empty , ▁ will ▁ force ▁ a ▁ full ▁ refresh STRNEWLINE ▁ """ NEW_LINE def execute ( self ) : NEW_LINE INDENT return config . project . index_apex_symbols ( self . params . get ( " files " , None ) ) NEW_LINE DEDENT DEDENT class ResetMetadataContainerCommand ( Command ) : NEW_LINE INDENT def execute ( self ) : NEW_LINE INDENT return config . project . reset_metadata_container ( accept = " json " ) NEW_LINE DEDENT DEDENT class OpenFileInClientCommand ( Command ) : NEW_LINE INDENT """ STRNEWLINE ▁ Opens ▁ the ▁ requested ▁ files ▁ in ▁ the ▁ plugin ▁ client ▁ ( Sublime ▁ Text , ▁ etc . ) STRNEWLINE ▁ """ NEW_LINE def execute ( self ) : NEW_LINE INDENT file_name = self . params [ " file _ name " ] NEW_LINE extension = util . get_file_extension_no_period ( file_name ) NEW_LINE mtype = util . get_meta_type_by_suffix ( extension ) NEW_LINE full_file_path = os . path . join ( config . project . location , " src " , mtype [ " directoryName " ] , file_name ) NEW_LINE params = { " project _ name " : config . project . project_name , " file _ name " : full_file_path , " line _ number " : self . params . get ( " line _ number " , 0 ) } NEW_LINE config . connection . run_subl_command ( " open _ file _ in _ project " , json . dumps ( params ) ) NEW_LINE return util . generate_success_response ( " ok " ) NEW_LINE DEDENT DEDENT class ExecuteApexCommand ( Command ) : NEW_LINE INDENT aliases = [ " run _ apex _ script " ] NEW_LINE """ STRNEWLINE ▁ executes ▁ a ▁ string ▁ of ▁ apex STRNEWLINE ▁ """ NEW_LINE def execute ( self ) : NEW_LINE INDENT if ' script _ name ' in self . params : # running ▁ an ▁ apex ▁ script ENDCOM NEW_LINE INDENT self . params [ " body " ] = util . get_file_as_string ( os . path . join ( config . project . location , " apex - scripts " , self . params [ " script _ name " ] ) ) NEW_LINE DEDENT if ' debug _ categories ' not in self . params and not os . path . isfile ( os . path . join ( config . project . location , " config " , " . apex _ script " ) ) : NEW_LINE INDENT self . params [ " debug _ categories " ] = [ { " category " : " Apex _ code " , " level " : " DEBUG " } ] NEW_LINE DEDENT elif os . path . isfile ( os . path . join ( config . project . location , " config " , " . apex _ script " ) ) : NEW_LINE INDENT log_settings = util . parse_json_from_file ( os . path . join ( config . project . location , " config " , " . apex _ script " ) ) NEW_LINE categories = [ ] NEW_LINE levels = log_settings [ " levels " ] NEW_LINE for category in levels . keys ( ) : NEW_LINE INDENT categories . append ( { " category " : category , " level " : levels [ category ] } ) NEW_LINE DEDENT self . params [ " debug _ categories " ] = categories NEW_LINE DEDENT elif ' debug _ categories ' not in self . params : NEW_LINE INDENT self . params [ " debug _ categories " ] = [ { " category " : " Apex _ code " , " level " : " DEBUG " } ] NEW_LINE DEDENT return_log = self . params . get ( " return _ log " , True ) NEW_LINE execute_result = config . sfdc_client . execute_apex ( self . params ) NEW_LINE result = { ' column ' : execute_result [ ' column ' ] , ' compileProblem ' : execute_result [ ' compileProblem ' ] , ' compiled ' : execute_result [ ' compiled ' ] , ' exceptionMessage ' : execute_result [ ' exceptionMessage ' ] , ' exceptionStackTrace ' : execute_result [ ' exceptionStackTrace ' ] , ' line ' : execute_result [ ' line ' ] , ' success ' : execute_result [ ' success ' ] , } NEW_LINE if ' log ' in execute_result and return_log : NEW_LINE INDENT result [ ' log ' ] = execute_result [ ' log ' ] NEW_LINE DEDENT if result [ ' success ' ] : NEW_LINE INDENT log_apex = config . connection . get_plugin_client_setting ( ' mm _ log _ anonymous _ apex ' , False ) NEW_LINE if log_apex : NEW_LINE INDENT location = config . project . log_anonymous_apex ( self . params [ ' body ' ] , execute_result [ ' log ' ] , self . params . get ( " script _ name " , None ) ) NEW_LINE result [ " log _ location " ] = location NEW_LINE DEDENT DEDENT return util . generate_response ( result ) NEW_LINE DEDENT DEDENT class SignInWithGithubCommand ( Command ) : NEW_LINE INDENT def execute ( self ) : NEW_LINE INDENT return config . connection . sign_in_with_github ( self . params ) NEW_LINE DEDENT DEDENT </DOCUMENT>
<DOCUMENT_ID="srvg/ansible/tree/master/lib/ansible/modules/network/netvisor/pn_vtep.py"> # ! / usr / bin / python ENDCOM # ▁ Copyright : ▁ ( c ) ▁ 2018 , ▁ Pluribus ▁ Networks ENDCOM # ▁ GNU ▁ General ▁ Public ▁ License ▁ v3.0 + ▁ ( see ▁ COPYING ▁ or ▁ https : / / www . gnu . org / licenses / gpl - 3.0 . txt ) ENDCOM from __future__ import absolute_import , division , print_function NEW_LINE __metaclass__ = type NEW_LINE ANSIBLE_METADATA = { ' metadata _ version ' : '1.1' , ' status ' : [ ' preview ' ] , ' supported _ by ' : ' community ' } NEW_LINE DOCUMENTATION = """ STRNEWLINE - - - STRNEWLINE module : ▁ pn _ vtep STRNEWLINE author : ▁ " Pluribus ▁ Networks ▁ ( @ rajaspachipulusu17 ) " STRNEWLINE version _ added : ▁ " 2.9 " STRNEWLINE short _ description : ▁ CLI ▁ command ▁ to ▁ create / delete ▁ vtep STRNEWLINE description : STRNEWLINE ▁ ▁ - ▁ This ▁ module ▁ can ▁ be ▁ used ▁ to ▁ create ▁ a ▁ vtep ▁ and ▁ delete ▁ a ▁ vtep . STRNEWLINE options : STRNEWLINE ▁ ▁ pn _ cliswitch : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Target ▁ switch ▁ to ▁ run ▁ the ▁ CLI ▁ on . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ state : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ vtep ▁ configuration ▁ command . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ choices : ▁ [ ' present ' , ▁ ' absent ' ] STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ ' present ' STRNEWLINE ▁ ▁ pn _ name : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ vtep ▁ name . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ ip : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Primary ▁ IP ▁ address . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ vrouter _ name : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ name ▁ of ▁ the ▁ vrouter ▁ service . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ virtual _ ip : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Virtual / Secondary ▁ IP ▁ address . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ location : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ switch ▁ name . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ str STRNEWLINE ▁ ▁ pn _ switch _ in _ cluster : STRNEWLINE ▁ ▁ ▁ ▁ description : STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ - ▁ Tells ▁ whether ▁ switch ▁ in ▁ cluster ▁ or ▁ not . STRNEWLINE ▁ ▁ ▁ ▁ required : ▁ false STRNEWLINE ▁ ▁ ▁ ▁ type : ▁ bool STRNEWLINE ▁ ▁ ▁ ▁ default : ▁ True STRNEWLINE """ NEW_LINE EXAMPLES = """ STRNEWLINE - ▁ name : ▁ create ▁ vtep STRNEWLINE ▁ ▁ pn _ vtep : STRNEWLINE ▁ ▁ ▁ ▁ pn _ cliswitch : ▁ ' sw01 ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ name : ▁ ' foo ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ vrouter _ name : ▁ ' foo - vrouter ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ ip : ▁ ' 22.22.22.2 ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ location : ▁ ' sw01 ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ virtual _ ip : ▁ " 22.22.22.1 " STRNEWLINE STRNEWLINE - ▁ name : ▁ delete ▁ vtep STRNEWLINE ▁ ▁ pn _ vtep : STRNEWLINE ▁ ▁ ▁ ▁ pn _ cliswitch : ▁ ' sw01 ' STRNEWLINE ▁ ▁ ▁ ▁ state : ▁ ' absent ' STRNEWLINE ▁ ▁ ▁ ▁ pn _ name : ▁ ' foo ' STRNEWLINE """ NEW_LINE RETURN = """ STRNEWLINE command : STRNEWLINE ▁ ▁ description : ▁ the ▁ CLI ▁ command ▁ run ▁ on ▁ the ▁ target ▁ node . STRNEWLINE ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ type : ▁ str STRNEWLINE stdout : STRNEWLINE ▁ ▁ description : ▁ set ▁ of ▁ responses ▁ from ▁ the ▁ vtep ▁ command . STRNEWLINE ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ type : ▁ list STRNEWLINE stderr : STRNEWLINE ▁ ▁ description : ▁ set ▁ of ▁ error ▁ responses ▁ from ▁ the ▁ vtep ▁ command . STRNEWLINE ▁ ▁ returned : ▁ on ▁ error STRNEWLINE ▁ ▁ type : ▁ list STRNEWLINE changed : STRNEWLINE ▁ ▁ description : ▁ indicates ▁ whether ▁ the ▁ CLI ▁ caused ▁ changes ▁ on ▁ the ▁ target . STRNEWLINE ▁ ▁ returned : ▁ always STRNEWLINE ▁ ▁ type : ▁ bool STRNEWLINE """ NEW_LINE from ansible . module_utils . basic import AnsibleModule NEW_LINE from ansible . module_utils . network . netvisor . pn_nvos import pn_cli , run_cli NEW_LINE from ansible . module_utils . network . netvisor . netvisor import run_commands NEW_LINE def check_cli ( module , cli ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ method ▁ checks ▁ for ▁ idempotency ▁ using ▁ the ▁ vtep - show ▁ command . STRNEWLINE ▁ If ▁ a ▁ name ▁ exists , ▁ return ▁ True ▁ if ▁ name ▁ exists ▁ else ▁ False . STRNEWLINE ▁ : param ▁ module : ▁ The ▁ Ansible ▁ module ▁ to ▁ fetch ▁ input ▁ parameters STRNEWLINE ▁ : param ▁ cli : ▁ The ▁ CLI ▁ string STRNEWLINE ▁ """ NEW_LINE name = module . params [ ' pn _ name ' ] NEW_LINE cli += ' ▁ vtep - show ▁ format ▁ name ▁ no - show - headers ' NEW_LINE out = run_commands ( module , cli ) [ 1 ] NEW_LINE if out : NEW_LINE INDENT out = out . split ( ) NEW_LINE DEDENT return True if name in out else False NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT """ ▁ This ▁ section ▁ is ▁ for ▁ arguments ▁ parsing ▁ """ NEW_LINE state_map = dict ( present = ' vtep - create ' , absent = ' vtep - delete ' ) NEW_LINE argument_spec = dict ( pn_cliswitch = dict ( required = False , type = ' str ' ) , state = dict ( required = False , type = ' str ' , choices = state_map . keys ( ) , default = ' present ' ) , pn_name = dict ( required = False , type = ' str ' ) , pn_ip = dict ( required = False , type = ' str ' ) , pn_vrouter_name = dict ( required = False , type = ' str ' ) , pn_virtual_ip = dict ( required = False , type = ' str ' ) , pn_location = dict ( required = False , type = ' str ' ) , pn_switch_in_cluster = dict ( required = False , type = ' bool ' , default = ' True ' ) ) NEW_LINE module = AnsibleModule ( argument_spec = argument_spec , required_if = ( [ " state " , " present " , [ " pn _ name " , " pn _ ip " , " pn _ vrouter _ name " , " pn _ location " ] ] , [ " state " , " absent " , [ " pn _ name " ] ] , ) , ) NEW_LINE # ▁ Accessing ▁ the ▁ arguments ENDCOM cliswitch = module . params [ ' pn _ cliswitch ' ] NEW_LINE state = module . params [ ' state ' ] NEW_LINE name = module . params [ ' pn _ name ' ] NEW_LINE ip = module . params [ ' pn _ ip ' ] NEW_LINE vrouter_name = module . params [ ' pn _ vrouter _ name ' ] NEW_LINE virtual_ip = module . params [ ' pn _ virtual _ ip ' ] NEW_LINE location = module . params [ ' pn _ location ' ] NEW_LINE switch_in_cluster = module . params [ ' pn _ switch _ in _ cluster ' ] NEW_LINE if switch_in_cluster and not virtual_ip and state == ' present ' : NEW_LINE INDENT module . exit_json ( failed = True , msg = ' virtual ▁ ip ▁ is ▁ required ▁ when ▁ switch ▁ is ▁ in ▁ cluster ' ) NEW_LINE DEDENT command = state_map [ state ] NEW_LINE # ▁ Building ▁ the ▁ CLI ▁ command ▁ string ENDCOM cli = pn_cli ( module , cliswitch ) NEW_LINE NAME_EXISTS = check_cli ( module , cli ) NEW_LINE cli += ' ▁ % s ▁ name ▁ % s ▁ ' % ( command , name ) NEW_LINE if command == ' vtep - delete ' : NEW_LINE INDENT if NAME_EXISTS is False : NEW_LINE INDENT module . exit_json ( skipped = True , msg = ' vtep ▁ with ▁ name ▁ % s ▁ does ▁ not ▁ exist ' % name ) NEW_LINE DEDENT DEDENT if command == ' vtep - create ' : NEW_LINE INDENT if NAME_EXISTS is True : NEW_LINE INDENT module . exit_json ( skipped = True , msg = ' vtpe ▁ with ▁ name ▁ % s ▁ already ▁ exists ' % name ) NEW_LINE DEDENT cli += ' vrouter - name ▁ % s ▁ ' % vrouter_name NEW_LINE cli += ' ip ▁ % s ▁ ' % ip NEW_LINE cli += ' location ▁ % s ▁ ' % location NEW_LINE if virtual_ip : NEW_LINE INDENT cli += ' virtual - ip ▁ % s ▁ ' % virtual_ip NEW_LINE DEDENT DEDENT run_cli ( module , cli , state_map ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT </DOCUMENT>
