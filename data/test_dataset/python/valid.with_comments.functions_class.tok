def __str__ ( self ) : NEW_LINE INDENT return " project ▁ { 0 } ▁ - ▁ { 1 } " . format ( self . project_id , self . slug ) NEW_LINE DEDENT
def save ( self , * args , ** kwargs ) : NEW_LINE INDENT if not self . _importing or not self . modified_date : NEW_LINE INDENT self . modified_date = timezone . now ( ) NEW_LINE DEDENT return super ( ) . save ( * args , ** kwargs ) NEW_LINE DEDENT
def __str__ ( self ) : NEW_LINE INDENT return self . title NEW_LINE DEDENT
def __init__ ( self ) : NEW_LINE INDENT self . parser = argparse . ArgumentParser ( description = __doc__ ) NEW_LINE self . parser . add_argument ( ' - r ' , ' - - revision ' , dest = ' revision ' , default = ' ' , help = ' RPi ▁ revision . ▁ Default ▁ is ▁ to ▁ autodetect ▁ revision ▁ of ▁ current ▁ device ' ) NEW_LINE self . parser . add_argument ( ' - c ' , ' - - color ' , action = " store _ true " , default = None , help = ' Force ▁ colored ▁ output ▁ ( by ▁ default , ▁ the ▁ output ▁ will ▁ include ▁ ANSI ' ' color ▁ codes ▁ if ▁ run ▁ in ▁ a ▁ color - capable ▁ terminal ) . ▁ See ▁ also ▁ - - monochrome ' ) NEW_LINE self . parser . add_argument ( ' - m ' , ' - - monochrome ' , dest = ' color ' , action = ' store _ false ' , help = ' Force ▁ monochrome ▁ output . ▁ See ▁ also ▁ - - color ' ) NEW_LINE self . parser . add_argument ( ' - x ' , ' - - xyz ' , dest = ' xyz ' , action = ' store _ true ' , help = ' Open ▁ pinout . xyz ▁ in ▁ the ▁ default ▁ web ▁ browser ' ) NEW_LINE DEDENT
def main ( self , args ) : NEW_LINE INDENT warnings . simplefilter ( ' ignore ' ) NEW_LINE if args . xyz : NEW_LINE INDENT webbrowser . open ( ' https : / / pinout . xyz ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if args . revision == ' ' : NEW_LINE INDENT try : NEW_LINE INDENT pi_info ( ) . pprint ( color = args . color ) NEW_LINE DEDENT except ImportError : NEW_LINE INDENT formatter = self . parser . _get_formatter ( ) NEW_LINE formatter . add_text ( " Unable ▁ to ▁ initialize ▁ GPIO ▁ Zero . ▁ This ▁ usually ▁ means ▁ " " that ▁ you ▁ are ▁ not ▁ running ▁ % ( prog ) s ▁ on ▁ a ▁ Raspberry ▁ Pi . ▁ " " If ▁ you ▁ still ▁ wish ▁ to ▁ run ▁ % ( prog ) s , ▁ set ▁ the ▁ " " GPIOZERO _ PIN _ FACTORY ▁ environment ▁ variable ▁ to ▁ ' mock ' ▁ " " and ▁ retry , ▁ or ▁ refer ▁ to ▁ the ▁ Remote ▁ GPIO ▁ section ▁ of ▁ " " the ▁ manual * ▁ to ▁ configure ▁ your ▁ environment ▁ to ▁ " " remotely ▁ access ▁ your ▁ Pi . " ) NEW_LINE formatter . add_text ( " * ▁ https : / / gpiozero . readthedocs . io / en / stable / " " remote _ gpio . html " ) NEW_LINE sys . stderr . write ( formatter . format_help ( ) ) NEW_LINE DEDENT except IOError : NEW_LINE INDENT raise IOError ( ' This ▁ device ▁ is ▁ not ▁ a ▁ Raspberry ▁ Pi ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pi_info ( args . revision ) . pprint ( color = args . color ) NEW_LINE DEDENT formatter = self . parser . _get_formatter ( ) NEW_LINE formatter . add_text ( " For ▁ further ▁ information , ▁ please ▁ refer ▁ to ▁ " " https : / / pinout . xyz / " ) NEW_LINE sys . stdout . write ( ' \n ' ) NEW_LINE sys . stdout . write ( formatter . format_help ( ) ) NEW_LINE DEDENT DEDENT
def test_display ( self ) : NEW_LINE INDENT a = Person . objects . create ( name = ' Adrian ' , gender = ' M ' ) NEW_LINE s = Person . objects . create ( name = ' Sara ' , gender = ' F ' ) NEW_LINE self . assertEqual ( a . gender , ' M ' ) NEW_LINE self . assertEqual ( s . gender , ' F ' ) NEW_LINE self . assertEqual ( a . get_gender_display ( ) , ' Male ' ) NEW_LINE self . assertEqual ( s . get_gender_display ( ) , ' Female ' ) NEW_LINE # ▁ If ▁ the ▁ value ▁ for ▁ the ▁ field ▁ doesn ' t ▁ correspond ▁ to ▁ a ▁ valid ▁ choice , ENDCOM # ▁ the ▁ value ▁ itself ▁ is ▁ provided ▁ as ▁ a ▁ display ▁ value . ENDCOM a . gender = ' ' NEW_LINE self . assertEqual ( a . get_gender_display ( ) , ' ' ) NEW_LINE a . gender = ' U ' NEW_LINE self . assertEqual ( a . get_gender_display ( ) , ' U ' ) NEW_LINE DEDENT
def __init__ ( self ) : NEW_LINE INDENT self . symTree = emptyOrderedDict ( ) NEW_LINE DEDENT
def cmdForFile ( self , f ) : NEW_LINE INDENT suffix_cmd_map = [ ] NEW_LINE custom_map = os . getenv ( ' SEASCOPE _ CTAGS _ SUFFIX _ CMD _ MAP ' ) NEW_LINE if custom_map : NEW_LINE INDENT custom_map = eval ( custom_map ) NEW_LINE suffix_cmd_map += custom_map NEW_LINE # args ▁ = ▁ ' ctags ▁ - n ▁ - u ▁ - - fields = + K ▁ - f ▁ - ▁ - - extra = + q ' ENDCOM # args ▁ = ▁ ' ctags ▁ - n ▁ - u ▁ - - fields = + Ki ▁ - f ▁ - ' ENDCOM DEDENT args = ' ctags ▁ - n ▁ - u ▁ - - fields = + K - f - t ▁ - f ▁ - ' NEW_LINE suffix_cmd_map . append ( [ ' ' , args ] ) NEW_LINE for ( suffix , cmd ) in suffix_cmd_map : NEW_LINE INDENT if f . endswith ( suffix ) : NEW_LINE INDENT return cmd NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def runCtags ( self , f ) : NEW_LINE INDENT args = self . cmdForFile ( f ) NEW_LINE args = args . split ( ) NEW_LINE args . append ( f ) NEW_LINE # ▁ In ▁ python ▁ > = ▁ 2.7 ▁ can ▁ use ▁ subprocess . check _ output ENDCOM # ▁ output ▁ = ▁ subprocess . check _ output ( args ) ENDCOM # ▁ return ▁ output ENDCOM proc = subprocess . Popen ( args , stdout = subprocess . PIPE ) NEW_LINE ( out_data , err_data ) = proc . communicate ( ) NEW_LINE return out_data NEW_LINE DEDENT
def addToSymLayout ( self , sc ) : NEW_LINE INDENT t = self . symTree NEW_LINE if sc and sc != ' ' : NEW_LINE INDENT for s in re . split ( ' : : | \ . ' , sc ) : NEW_LINE INDENT if s not in t : NEW_LINE INDENT t [ s ] = emptyOrderedDict ( ) NEW_LINE DEDENT t = t [ s ] NEW_LINE DEDENT DEDENT DEDENT
def setUp ( self ) : NEW_LINE INDENT GoGridNodeDriver . connectionCls . conn_classes = ( None , GoGridMockHttp ) NEW_LINE GoGridMockHttp . type = None NEW_LINE self . driver = GoGridNodeDriver ( " foo " , " bar " ) NEW_LINE DEDENT
def _get_test_512Mb_node_size ( self ) : NEW_LINE INDENT return NodeSize ( id = '512Mb ' , name = None , ram = None , disk = None , bandwidth = None , price = None , driver = self . driver ) NEW_LINE DEDENT
def test_create_node ( self ) : NEW_LINE INDENT image = NodeImage ( 1531 , None , self . driver ) NEW_LINE node = self . driver . create_node ( name = ' test1' , image = image , size = self . _get_test_512Mb_node_size ( ) ) NEW_LINE self . assertEqual ( node . name , ' test1' ) NEW_LINE self . assertTrue ( node . id is not None ) NEW_LINE self . assertEqual ( node . extra [ ' password ' ] , ' bebebe ' ) NEW_LINE DEDENT
def test_list_nodes ( self ) : NEW_LINE INDENT node = self . driver . list_nodes ( ) [ 0 ] NEW_LINE self . assertEqual ( node . id , '90967' ) NEW_LINE self . assertEqual ( node . extra [ ' password ' ] , ' bebebe ' ) NEW_LINE self . assertEqual ( node . extra [ ' description ' ] , ' test ▁ server ' ) NEW_LINE DEDENT
def test_reboot_node ( self ) : NEW_LINE INDENT node = Node ( 90967 , None , None , None , None , self . driver ) NEW_LINE ret = self . driver . reboot_node ( node ) NEW_LINE self . assertTrue ( ret ) NEW_LINE DEDENT
def test_reboot_node_not_successful ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' FAIL ' NEW_LINE node = Node ( 90967 , None , None , None , None , self . driver ) NEW_LINE try : NEW_LINE INDENT self . driver . reboot_node ( node ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( ' Exception ▁ was ▁ not ▁ thrown ' ) NEW_LINE DEDENT DEDENT
def test_destroy_node ( self ) : NEW_LINE INDENT node = Node ( 90967 , None , None , None , None , self . driver ) NEW_LINE ret = self . driver . destroy_node ( node ) NEW_LINE self . assertTrue ( ret ) NEW_LINE DEDENT
def test_list_images ( self ) : NEW_LINE INDENT images = self . driver . list_images ( ) NEW_LINE image = images [ 0 ] NEW_LINE self . assertEqual ( len ( images ) , 4 ) NEW_LINE self . assertEqual ( image . name , ' CentOS ▁ 5.3 ▁ ( 32 - bit ) ▁ w / ▁ None ' ) NEW_LINE self . assertEqual ( image . id , '1531' ) NEW_LINE location = NodeLocation ( id = ' gogrid / GSI - 939ef909-84b8-4a2f - ad56-02ccd7da05ff . img ' , name = ' test ▁ location ' , country = ' Slovenia ' , driver = self . driver ) NEW_LINE images = self . driver . list_images ( location = location ) NEW_LINE image = images [ 0 ] NEW_LINE self . assertEqual ( len ( images ) , 4 ) NEW_LINE self . assertEqual ( image . name , ' CentOS ▁ 5.3 ▁ ( 32 - bit ) ▁ w / ▁ None ' ) NEW_LINE self . assertEqual ( image . id , '1531' ) NEW_LINE DEDENT
def test_malformed_reply ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' FAIL ' NEW_LINE try : NEW_LINE INDENT self . driver . list_images ( ) NEW_LINE DEDENT except LibcloudError : NEW_LINE INDENT e = sys . exc_info ( ) [ 1 ] NEW_LINE self . assertTrue ( isinstance ( e , LibcloudError ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( " test ▁ should ▁ have ▁ thrown " ) NEW_LINE DEDENT DEDENT
def test_invalid_creds ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' FAIL ' NEW_LINE try : NEW_LINE INDENT self . driver . list_nodes ( ) NEW_LINE DEDENT except InvalidCredsError : NEW_LINE INDENT e = sys . exc_info ( ) [ 1 ] NEW_LINE self . assertTrue ( e . driver is not None ) NEW_LINE self . assertEqual ( e . driver . name , self . driver . name ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( " test ▁ should ▁ have ▁ thrown " ) NEW_LINE DEDENT DEDENT
def test_node_creation_without_free_public_ips ( self ) : NEW_LINE INDENT GoGridMockHttp . type = ' NOPUBIPS ' NEW_LINE try : NEW_LINE INDENT image = NodeImage ( 1531 , None , self . driver ) NEW_LINE self . driver . create_node ( name = ' test1' , image = image , size = self . _get_test_512Mb_node_size ( ) ) NEW_LINE DEDENT except LibcloudError : NEW_LINE INDENT e = sys . exc_info ( ) [ 1 ] NEW_LINE self . assertTrue ( isinstance ( e , LibcloudError ) ) NEW_LINE self . assertTrue ( e . driver is not None ) NEW_LINE self . assertEqual ( e . driver . name , self . driver . name ) NEW_LINE DEDENT else : NEW_LINE INDENT self . fail ( " test ▁ should ▁ have ▁ thrown " ) NEW_LINE DEDENT DEDENT
def test_list_locations ( self ) : NEW_LINE INDENT locations = self . driver . list_locations ( ) NEW_LINE location_names = [ location . name for location in locations ] NEW_LINE self . assertEqual ( len ( locations ) , 2 ) NEW_LINE for i in 0 , 1 : NEW_LINE INDENT self . assertTrue ( isinstance ( locations [ i ] , NodeLocation ) ) NEW_LINE DEDENT self . assertTrue ( " US - West - 1" in location_names ) NEW_LINE self . assertTrue ( " US - East - 1" in location_names ) NEW_LINE DEDENT
def test_ex_save_image ( self ) : NEW_LINE INDENT node = self . driver . list_nodes ( ) [ 0 ] NEW_LINE image = self . driver . ex_save_image ( node , " testimage " ) NEW_LINE self . assertEqual ( image . name , " testimage " ) NEW_LINE DEDENT
def test_ex_edit_image ( self ) : NEW_LINE INDENT image = self . driver . list_images ( ) [ 0 ] NEW_LINE ret = self . driver . ex_edit_image ( image = image , public = False , ex_description = " test " , name = " testname " ) NEW_LINE self . assertTrue ( isinstance ( ret , NodeImage ) ) NEW_LINE DEDENT
def test_ex_edit_node ( self ) : NEW_LINE INDENT node = Node ( id = 90967 , name = None , state = None , public_ips = None , private_ips = None , driver = self . driver ) NEW_LINE ret = self . driver . ex_edit_node ( node = node , size = self . _get_test_512Mb_node_size ( ) ) NEW_LINE self . assertTrue ( isinstance ( ret , Node ) ) NEW_LINE DEDENT
def test_ex_list_ips ( self ) : NEW_LINE INDENT ips = self . driver . ex_list_ips ( ) NEW_LINE expected_ips = { "192.168.75.66" : GoGridIpAddress ( id = "5348099" , ip = "192.168.75.66" , public = True , state = " Unassigned " , subnet = "192.168.75.64/255.255.255.240" ) , "192.168.75.67" : GoGridIpAddress ( id = "5348100" , ip = "192.168.75.67" , public = True , state = " Assigned " , subnet = "192.168.75.64/255.255.255.240" ) , "192.168.75.68" : GoGridIpAddress ( id = "5348101" , ip = "192.168.75.68" , public = False , state = " Unassigned " , subnet = "192.168.75.64/255.255.255.240" ) } NEW_LINE self . assertEqual ( len ( expected_ips ) , 3 ) NEW_LINE for ip in ips : NEW_LINE INDENT self . assertTrue ( ip . ip in expected_ips ) NEW_LINE self . assertEqual ( ip . public , expected_ips [ ip . ip ] . public ) NEW_LINE self . assertEqual ( ip . state , expected_ips [ ip . ip ] . state ) NEW_LINE self . assertEqual ( ip . subnet , expected_ips [ ip . ip ] . subnet ) NEW_LINE del expected_ips [ ip . ip ] NEW_LINE DEDENT self . assertEqual ( len ( expected_ips ) , 0 ) NEW_LINE DEDENT
def test_get_state_invalid ( self ) : NEW_LINE INDENT state = self . driver . _get_state ( ' invalid ' ) NEW_LINE self . assertEqual ( state , NodeState . UNKNOWN ) NEW_LINE DEDENT
def _api_grid_image_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' image _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_image_list_FAIL ( self , method , url , body , headers ) : NEW_LINE INDENT body = " < h3 > some ▁ non ▁ valid ▁ json ▁ here < / h3 > " NEW_LINE return ( httplib . SERVICE_UNAVAILABLE , body , { } , httplib . responses [ httplib . SERVICE_UNAVAILABLE ] ) NEW_LINE DEDENT
def _api_grid_server_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_server_list_FAIL ( self , method , url , body , headers ) : NEW_LINE INDENT return ( httplib . FORBIDDEN , "123" , { } , httplib . responses [ httplib . FORBIDDEN ] ) NEW_LINE DEDENT
def _api_grid_ip_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' ip _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_ip_list_NOPUBIPS ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' ip _ list _ empty . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_server_power ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ power . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_server_power_FAIL ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ power _ fail . json ' ) NEW_LINE return ( httplib . NOT_FOUND , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_server_add ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ add . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_server_delete ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ delete . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_server_edit ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' server _ edit . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_support_password_list ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' password _ list . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_image_save ( self , method , url , body , headers ) : NEW_LINE INDENT body = self . fixtures . load ( ' image _ save . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_grid_image_edit ( self , method , url , body , headers ) : NEW_LINE # ▁ edit ▁ method ▁ is ▁ quite ▁ similar ▁ to ▁ save ▁ method ▁ from ▁ the ▁ response ENDCOM # ▁ perspective ENDCOM INDENT body = self . fixtures . load ( ' image _ save . json ' ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def _api_common_lookup_list ( self , method , url , body , headers ) : NEW_LINE INDENT _valid_lookups = ( " ip . datacenter " , ) NEW_LINE lookup = parse_qs ( urlparse . urlparse ( url ) . query ) [ " lookup " ] [ 0 ] NEW_LINE if lookup in _valid_lookups : NEW_LINE INDENT fixture_path = " lookup _ list _ % s . json " % ( lookup . replace ( " . " , " _ " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT raise NotImplementedError NEW_LINE DEDENT body = self . fixtures . load ( fixture_path ) NEW_LINE return ( httplib . OK , body , { } , httplib . responses [ httplib . OK ] ) NEW_LINE DEDENT
def test_list_containers_with_non_authorized_user ( self ) : NEW_LINE # ▁ list ▁ containers ▁ using ▁ non - authorized ▁ user ENDCOM # ▁ create ▁ user ENDCOM INDENT self . data . setup_test_user ( ) NEW_LINE test_os = clients . Manager ( self . data . test_credentials ) NEW_LINE test_auth_provider = test_os . auth_provider NEW_LINE # ▁ Get ▁ auth ▁ for ▁ the ▁ test ▁ user ENDCOM test_auth_provider . auth_data NEW_LINE # ▁ Get ▁ fresh ▁ auth ▁ for ▁ test ▁ user ▁ and ▁ set ▁ it ▁ to ▁ next ▁ auth ▁ request ▁ for ENDCOM # ▁ custom _ account _ client ENDCOM delattr ( test_auth_provider , ' auth _ data ' ) NEW_LINE test_auth_new_data = test_auth_provider . auth_data NEW_LINE self . custom_account_client . auth_provider . set_alt_auth_data ( request_part = ' headers ' , auth_data = test_auth_new_data ) NEW_LINE params = { ' format ' : ' json ' } NEW_LINE # ▁ list ▁ containers ▁ with ▁ non - authorized ▁ user ▁ token ENDCOM self . assertRaises ( exceptions . Unauthorized , self . custom_account_client . list_account_containers , params = params ) NEW_LINE DEDENT
def __init__ ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Base ▁ init ▁ function ▁ for ▁ houdini ▁ convert . write ▁ Class . STRNEWLINE ▁ """ NEW_LINE rodin_logger . info ( " kip ▁ houdini ▁ writing ▁ class ▁ initialized " ) NEW_LINE self . houdini_version = " houdini , % s " % hou . applicationVersionString ( ) NEW_LINE self . kip_houdini_version = " kipHoudini % s " % os . getenv ( " DRD _ KIPHOUDINI _ VERSION " ) NEW_LINE DEDENT
def writeOutCurves ( self , nap_file_name = None , houdini_nodes = [ ] , houdini_node_attributes = [ ] , start_frame = None , end_frame = None , write_xml = False , silent = False , left_eyes = [ ] , right_eyes = [ ] , map_file_name = None ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ function ▁ will ▁ create ▁ a ▁ curve ▁ class ▁ object ▁ first ▁ and ▁ then ▁ it ▁ will ▁ write ▁ out ▁ the ▁ napalm ▁ file . STRNEWLINE STRNEWLINE ▁ . . ▁ warning : : STRNEWLINE STRNEWLINE ▁ If ▁ you ▁ are ▁ unable ▁ to ▁ write ▁ out ▁ napalm ▁ file ▁ or ▁ write _ status = False ▁ that ▁ means ▁ napalm ▁ failed ▁ to ▁ write ▁ out . STRNEWLINE STRNEWLINE ▁ : param ▁ nap _ file _ name : ▁ User ▁ must ▁ pass ▁ a ▁ file ▁ where ▁ he ▁ want ▁ to ▁ write ▁ out ▁ curves ▁ and ▁ make ▁ sure ▁ you ▁ supply ▁ a ▁ . nap ▁ or ▁ . xml ▁ file ▁ format ( strict ) STRNEWLINE STRNEWLINE ▁ : type ▁ nap _ file _ name : ▁ string STRNEWLINE STRNEWLINE ▁ : param ▁ houdini _ nodes : ▁ list ▁ of ▁ houdini ▁ objects ( strict ) STRNEWLINE STRNEWLINE ▁ : type ▁ houdini _ nodes : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ houdini _ node _ attribute : ▁ if ▁ you ▁ want ▁ to ▁ replace ▁ attribute ▁ from ▁ the ▁ map ▁ file ▁ then ▁ you ▁ can ▁ specify ▁ the ▁ override ▁ attribute ▁ here STRNEWLINE STRNEWLINE ▁ : type ▁ houdini _ node _ attribute : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ start _ frame : ▁ start ▁ frame ▁ to ▁ capture STRNEWLINE STRNEWLINE ▁ : type ▁ start _ frame : ▁ int STRNEWLINE STRNEWLINE ▁ : param ▁ end _ frame : ▁ end ▁ frame ▁ to ▁ capture STRNEWLINE STRNEWLINE ▁ : type ▁ end _ frame : ▁ int STRNEWLINE STRNEWLINE ▁ : param ▁ write _ xml : ▁ If ▁ you ▁ want ▁ to ▁ write ▁ out ▁ a ▁ xml ▁ file ▁ instead ▁ of ▁ napalm ▁ file ▁ then ▁ this ▁ should ▁ be ▁ true STRNEWLINE STRNEWLINE ▁ : type ▁ end _ frame : ▁ string STRNEWLINE STRNEWLINE ▁ : param ▁ left _ eyes : ▁ Left ▁ eye ▁ objects STRNEWLINE STRNEWLINE ▁ : type ▁ left _ eyes : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ right _ eyes : ▁ Right ▁ eye ▁ objects STRNEWLINE STRNEWLINE ▁ : type ▁ right _ eyes : ▁ list STRNEWLINE STRNEWLINE ▁ : param ▁ map _ file _ name : ▁ Filepath ▁ of ▁ napalm ▁ channel ▁ data STRNEWLINE STRNEWLINE ▁ : type ▁ map _ file _ name : ▁ string STRNEWLINE STRNEWLINE ▁ : return : ▁ Status , channel ▁ file ▁ , ▁ map ▁ file STRNEWLINE STRNEWLINE ▁ : rtype : ▁ boot , string , string STRNEWLINE STRNEWLINE ▁ Example STRNEWLINE STRNEWLINE ▁ > > > ▁ import ▁ kip _ houdini . convert ▁ as ▁ kh STRNEWLINE ▁ > > > ▁ reload ( kh ) STRNEWLINE ▁ > > > ▁ khcw ▁ = ▁ kh . HoudiniWriter ( ) STRNEWLINE ▁ > > > ▁ status , nap _ file , map _ file = khcw . writeOutCurves ( nap _ file _ name ▁ = ▁ " / tmp / houdini _ kip _ test _ s . nap " , map _ file _ name = ▁ " / tmp / houdini _ kip _ test _ m . nap " , houdini _ nodes ▁ = ▁ [ " / obj / geo / xform _ 1 " , " / obj / geo / xform _ 2 " ] , left _ eyes = [ " / obj / geo / xform _ 1 " ] , right _ eyes = [ " / obj / geo / xform _ 2 " ] ) STRNEWLINE STRNEWLINE ▁ """ NEW_LINE if nap_file_name : NEW_LINE INDENT node_curv = node_curves . NodeCurves ( ) NEW_LINE get_all_curves = node_curv . getCurves ( houdini_node_curves = houdini_nodes , houdini_attribute_curves = houdini_node_attributes , start_frame = start_frame , end_frame = end_frame , silent = silent , left_eye_curves = left_eyes , right_eye_curves = right_eyes ) NEW_LINE if write_xml : NEW_LINE INDENT if not nap_file_name . endswith ( " . xml " ) : NEW_LINE INDENT split_base_ext = os . path . splitext ( nap_file_name ) NEW_LINE if split_base_ext [ - 1 ] : NEW_LINE INDENT nap_file_name = " % s / . xml " % ( split_base_ext [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT nap_file_name = " % s / . xml " % ( nap_file_name ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if not nap_file_name . endswith ( " . nap " ) : NEW_LINE INDENT raise KipBaseError ( " Unknown ▁ file ▁ extension ▁ found ▁ in ▁ % s ▁ ! " % nap_file_name ) NEW_LINE DEDENT DEDENT write_status , map_file , nap_file = napalm_func . write ( nap_file_name , get_all_curves , debug = True , map_file_name = map_file_name , software = self . houdini_version , app_version = self . kip_houdini_version ) NEW_LINE rodin_logger . info ( " % s ▁ % s ▁ % s " % ( write_status , map_file , nap_file ) ) NEW_LINE return ( write_status , map_file , nap_file ) NEW_LINE DEDENT else : NEW_LINE INDENT raise KipBaseError ( " Expected ▁ napalm ▁ file ▁ name ▁ for ▁ write ▁ curve ▁ ! " ) NEW_LINE DEDENT DEDENT
def __init__ ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Base ▁ init ▁ function ▁ for ▁ houdini ▁ convert . write ▁ Class . STRNEWLINE ▁ """ NEW_LINE rodin_logger . info ( " kip ▁ houdini ▁ read ▁ class ▁ initialized " ) NEW_LINE self . nuke_tan_types = { " spline " : " spline ( ) " , " linear " : " linear ( ) " , " constant " : " constant ( ) " , " cubic " : " bezier ( ) " } NEW_LINE self . channel_match = { ' translateX ' : ' tx ' , ' translateY ' : ' ty ' , ' translateZ ' : ' tz ' , ' rotateX ' : ' rx ' , ' rotateY ' : ' ry ' , ' rotateZ ' : ' rz ' , ' scaleX ' : ' sx ' , ' scaleY ' : ' sy ' , ' scaleZ ' : ' sz ' } NEW_LINE DEDENT
def __init__ ( self , value ) : NEW_LINE INDENT self . value = value NEW_LINE DEDENT
def __str__ ( self ) : NEW_LINE INDENT return repr ( self . value ) NEW_LINE DEDENT
def __init__ ( self , project , version , location ) : NEW_LINE INDENT self . project = project NEW_LINE self . version = parse_version ( version ) NEW_LINE self . location = location NEW_LINE self . _key = ( self . project , self . version , self . location ) NEW_LINE DEDENT
def __repr__ ( self ) : NEW_LINE INDENT return " < InstallationCandidate ( {0 ! r } , ▁ { 1 ! r } , ▁ { 2 ! r } ) > " . format ( self . project , self . version , self . location , ) NEW_LINE DEDENT
def __hash__ ( self ) : NEW_LINE INDENT return hash ( self . _key ) NEW_LINE DEDENT
def __lt__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s < o ) NEW_LINE DEDENT
def __le__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s <= o ) NEW_LINE DEDENT
def __eq__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s == o ) NEW_LINE DEDENT
def __ge__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s >= o ) NEW_LINE DEDENT
def __gt__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s > o ) NEW_LINE DEDENT
def __ne__ ( self , other ) : NEW_LINE INDENT return self . _compare ( other , lambda s , o : s != o ) NEW_LINE DEDENT
def _compare ( self , other , method ) : NEW_LINE INDENT if not isinstance ( other , InstallationCandidate ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return method ( self . _key , other . _key ) NEW_LINE DEDENT
def __init__ ( self , find_links , index_urls , allow_external = ( ) , allow_unverified = ( ) , allow_all_external = False , allow_all_prereleases = False , trusted_hosts = None , process_dependency_links = False , session = None , format_control = None ) : NEW_LINE INDENT """ Create ▁ a ▁ PackageFinder . STRNEWLINE STRNEWLINE ▁ : param ▁ format _ control : ▁ A ▁ FormatControl ▁ object ▁ or ▁ None . ▁ Used ▁ to ▁ control STRNEWLINE ▁ the ▁ selection ▁ of ▁ source ▁ packages ▁ / ▁ binary ▁ packages ▁ when ▁ consulting STRNEWLINE ▁ the ▁ index ▁ and ▁ links . STRNEWLINE ▁ """ NEW_LINE if session is None : NEW_LINE INDENT raise TypeError ( " PackageFinder ( ) ▁ missing ▁ 1 ▁ required ▁ keyword ▁ argument : ▁ " " ' session ' " ) NEW_LINE # ▁ Build ▁ find _ links . ▁ If ▁ an ▁ argument ▁ starts ▁ with ▁ ~ , ▁ it ▁ may ▁ be ENDCOM # ▁ a ▁ local ▁ file ▁ relative ▁ to ▁ a ▁ home ▁ directory . ▁ So ▁ try ▁ normalizing ENDCOM # ▁ it ▁ and ▁ if ▁ it ▁ exists , ▁ use ▁ the ▁ normalized ▁ version . ENDCOM # ▁ This ▁ is ▁ deliberately ▁ conservative ▁ - ▁ it ▁ might ▁ be ▁ fine ▁ just ▁ to ENDCOM # ▁ blindly ▁ normalize ▁ anything ▁ starting ▁ with ▁ a ▁ ~ . . . ENDCOM DEDENT self . find_links = [ ] NEW_LINE for link in find_links : NEW_LINE INDENT if link . startswith ( ' ~ ' ) : NEW_LINE INDENT new_link = normalize_path ( link ) NEW_LINE if os . path . exists ( new_link ) : NEW_LINE INDENT link = new_link NEW_LINE DEDENT DEDENT self . find_links . append ( link ) NEW_LINE DEDENT self . index_urls = index_urls NEW_LINE self . dependency_links = [ ] NEW_LINE # ▁ These ▁ are ▁ boring ▁ links ▁ that ▁ have ▁ already ▁ been ▁ logged ▁ somehow : ENDCOM self . logged_links = set ( ) NEW_LINE self . format_control = format_control or FormatControl ( set ( ) , set ( ) ) NEW_LINE # ▁ Do ▁ we ▁ allow ▁ ( safe ▁ and ▁ verifiable ) ▁ externally ▁ hosted ▁ files ? ENDCOM self . allow_external = set ( normalize_name ( n ) for n in allow_external ) NEW_LINE # ▁ Which ▁ names ▁ are ▁ allowed ▁ to ▁ install ▁ insecure ▁ and ▁ unverifiable ▁ files ? ENDCOM self . allow_unverified = set ( normalize_name ( n ) for n in allow_unverified ) NEW_LINE # ▁ Anything ▁ that ▁ is ▁ allowed ▁ unverified ▁ is ▁ also ▁ allowed ▁ external ENDCOM self . allow_external |= self . allow_unverified NEW_LINE # ▁ Do ▁ we ▁ allow ▁ all ▁ ( safe ▁ and ▁ verifiable ) ▁ externally ▁ hosted ▁ files ? ENDCOM self . allow_all_external = allow_all_external NEW_LINE # ▁ Domains ▁ that ▁ we ▁ won ' t ▁ emit ▁ warnings ▁ for ▁ when ▁ not ▁ using ▁ HTTPS ENDCOM self . secure_origins = [ ( " * " , host , " * " ) for host in ( trusted_hosts if trusted_hosts else [ ] ) ] NEW_LINE # ▁ Stores ▁ if ▁ we ▁ ignored ▁ any ▁ external ▁ links ▁ so ▁ that ▁ we ▁ can ▁ instruct ENDCOM # ▁ end ▁ users ▁ how ▁ to ▁ install ▁ them ▁ if ▁ no ▁ distributions ▁ are ▁ available ENDCOM self . need_warn_external = False NEW_LINE # ▁ Stores ▁ if ▁ we ▁ ignored ▁ any ▁ unsafe ▁ links ▁ so ▁ that ▁ we ▁ can ▁ instruct ENDCOM # ▁ end ▁ users ▁ how ▁ to ▁ install ▁ them ▁ if ▁ no ▁ distributions ▁ are ▁ available ENDCOM self . need_warn_unverified = False NEW_LINE # ▁ Do ▁ we ▁ want ▁ to ▁ allow ▁ _ all _ ▁ pre - releases ? ENDCOM self . allow_all_prereleases = allow_all_prereleases NEW_LINE # ▁ Do ▁ we ▁ process ▁ dependency ▁ links ? ENDCOM self . process_dependency_links = process_dependency_links NEW_LINE # ▁ The ▁ Session ▁ we ' ll ▁ use ▁ to ▁ make ▁ requests ENDCOM self . session = session NEW_LINE # ▁ If ▁ we ▁ don ' t ▁ have ▁ TLS ▁ enabled , ▁ then ▁ WARN ▁ if ▁ anyplace ▁ we ' re ▁ looking ENDCOM # ▁ relies ▁ on ▁ TLS . ENDCOM if not HAS_TLS : NEW_LINE INDENT for link in itertools . chain ( self . index_urls , self . find_links ) : NEW_LINE INDENT parsed = urllib_parse . urlparse ( link ) NEW_LINE if parsed . scheme == " https " : NEW_LINE INDENT logger . warning ( " pip ▁ is ▁ configured ▁ with ▁ locations ▁ that ▁ require ▁ " " TLS / SSL , ▁ however ▁ the ▁ ssl ▁ module ▁ in ▁ Python ▁ is ▁ not ▁ " " available . " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT
def add_dependency_links ( self , links ) : NEW_LINE # ▁ # ▁ FIXME : ▁ this ▁ shouldn ' t ▁ be ▁ global ▁ list ▁ this , ▁ it ▁ should ▁ only ENDCOM # ▁ # ▁ apply ▁ to ▁ requirements ▁ of ▁ the ▁ package ▁ that ▁ specifies ▁ the ENDCOM # ▁ # ▁ dependency _ links ▁ value ENDCOM # ▁ # ▁ FIXME : ▁ also , ▁ we ▁ should ▁ track ▁ comes _ from ▁ ( i . e . , ▁ use ▁ Link ) ENDCOM INDENT if self . process_dependency_links : NEW_LINE INDENT warnings . warn ( " Dependency ▁ Links ▁ processing ▁ has ▁ been ▁ deprecated ▁ and ▁ will ▁ be ▁ " " removed ▁ in ▁ a ▁ future ▁ release . " , RemovedInPip8Warning , ) NEW_LINE self . dependency_links . extend ( links ) NEW_LINE DEDENT DEDENT
def _candidate_sort_key ( self , candidate ) : NEW_LINE INDENT """ STRNEWLINE ▁ Function ▁ used ▁ to ▁ generate ▁ link ▁ sort ▁ key ▁ for ▁ link ▁ tuples . STRNEWLINE ▁ The ▁ greater ▁ the ▁ return ▁ value , ▁ the ▁ more ▁ preferred ▁ it ▁ is . STRNEWLINE ▁ If ▁ not ▁ finding ▁ wheels , ▁ then ▁ sorted ▁ by ▁ version ▁ only . STRNEWLINE ▁ If ▁ finding ▁ wheels , ▁ then ▁ the ▁ sort ▁ order ▁ is ▁ by ▁ version , ▁ then : STRNEWLINE ▁ 1 . ▁ existing ▁ installs STRNEWLINE ▁ 2 . ▁ wheels ▁ ordered ▁ via ▁ Wheel . support _ index _ min ( ) STRNEWLINE ▁ 3 . ▁ source ▁ archives STRNEWLINE ▁ Note : ▁ it ▁ was ▁ considered ▁ to ▁ embed ▁ this ▁ logic ▁ into ▁ the ▁ Link STRNEWLINE ▁ comparison ▁ operators , ▁ but ▁ then ▁ different ▁ sdist ▁ links STRNEWLINE ▁ with ▁ the ▁ same ▁ version , ▁ would ▁ have ▁ to ▁ be ▁ considered ▁ equal STRNEWLINE ▁ """ NEW_LINE support_num = len ( supported_tags ) NEW_LINE if candidate . location == INSTALLED_VERSION : NEW_LINE INDENT pri = 1 NEW_LINE DEDENT elif candidate . location . is_wheel : NEW_LINE # ▁ can ▁ raise ▁ InvalidWheelFilename ENDCOM INDENT wheel = Wheel ( candidate . location . filename ) NEW_LINE if not wheel . supported ( ) : NEW_LINE INDENT raise UnsupportedWheel ( " % s ▁ is ▁ not ▁ a ▁ supported ▁ wheel ▁ for ▁ this ▁ platform . ▁ It ▁ " " can ' t ▁ be ▁ sorted . " % wheel . filename ) NEW_LINE DEDENT pri = - ( wheel . support_index_min ( ) ) NEW_LINE DEDENT else : # ▁ sdist ENDCOM NEW_LINE INDENT pri = - ( support_num ) NEW_LINE DEDENT return ( candidate . version , pri ) NEW_LINE DEDENT
def _sort_versions ( self , applicable_versions ) : NEW_LINE INDENT """ STRNEWLINE ▁ Bring ▁ the ▁ latest ▁ version ▁ ( and ▁ wheels ) ▁ to ▁ the ▁ front , ▁ but ▁ maintain ▁ the STRNEWLINE ▁ existing ▁ ordering ▁ as ▁ secondary . ▁ See ▁ the ▁ docstring ▁ for ▁ ` _ link _ sort _ key ` STRNEWLINE ▁ for ▁ details . ▁ This ▁ function ▁ is ▁ isolated ▁ for ▁ easier ▁ unit ▁ testing . STRNEWLINE ▁ """ NEW_LINE return sorted ( applicable_versions , key = self . _candidate_sort_key , reverse = True ) NEW_LINE DEDENT
def _validate_secure_origin ( self , logger , location ) : NEW_LINE # ▁ Determine ▁ if ▁ this ▁ url ▁ used ▁ a ▁ secure ▁ transport ▁ mechanism ENDCOM INDENT parsed = urllib_parse . urlparse ( str ( location ) ) NEW_LINE origin = ( parsed . scheme , parsed . hostname , parsed . port ) NEW_LINE # ▁ Determine ▁ if ▁ our ▁ origin ▁ is ▁ a ▁ secure ▁ origin ▁ by ▁ looking ▁ through ▁ our ENDCOM # ▁ hardcoded ▁ list ▁ of ▁ secure ▁ origins , ▁ as ▁ well ▁ as ▁ any ▁ additional ▁ ones ENDCOM # ▁ configured ▁ on ▁ this ▁ PackageFinder ▁ instance . ENDCOM for secure_origin in ( SECURE_ORIGINS + self . secure_origins ) : NEW_LINE # ▁ Check ▁ to ▁ see ▁ if ▁ the ▁ protocol ▁ matches ENDCOM INDENT if origin [ 0 ] != secure_origin [ 0 ] and secure_origin [ 0 ] != " * " : NEW_LINE INDENT continue NEW_LINE DEDENT try : NEW_LINE # ▁ We ▁ need ▁ to ▁ do ▁ this ▁ decode ▁ dance ▁ to ▁ ensure ▁ that ▁ we ▁ have ▁ a ENDCOM # ▁ unicode ▁ object , ▁ even ▁ on ▁ Python ▁ 2 . x . ENDCOM INDENT addr = ipaddress . ip_address ( origin [ 1 ] if ( isinstance ( origin [ 1 ] , six . text_type ) or origin [ 1 ] is None ) else origin [ 1 ] . decode ( " utf8" ) ) NEW_LINE network = ipaddress . ip_network ( secure_origin [ 1 ] if isinstance ( secure_origin [ 1 ] , six . text_type ) else secure_origin [ 1 ] . decode ( " utf8" ) ) NEW_LINE DEDENT except ValueError : NEW_LINE # ▁ We ▁ don ' t ▁ have ▁ both ▁ a ▁ valid ▁ address ▁ or ▁ a ▁ valid ▁ network , ▁ so ENDCOM # ▁ we ' ll ▁ check ▁ this ▁ origin ▁ against ▁ hostnames . ENDCOM INDENT if origin [ 1 ] != secure_origin [ 1 ] and secure_origin [ 1 ] != " * " : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT else : NEW_LINE # ▁ We ▁ have ▁ a ▁ valid ▁ address ▁ and ▁ network , ▁ so ▁ see ▁ if ▁ the ▁ address ENDCOM # ▁ is ▁ contained ▁ within ▁ the ▁ network . ENDCOM INDENT if addr not in network : NEW_LINE INDENT continue NEW_LINE # ▁ Check ▁ to ▁ see ▁ if ▁ the ▁ port ▁ patches ENDCOM DEDENT DEDENT if ( origin [ 2 ] != secure_origin [ 2 ] and secure_origin [ 2 ] != " * " and secure_origin [ 2 ] is not None ) : NEW_LINE INDENT continue NEW_LINE # ▁ If ▁ we ' ve ▁ gotten ▁ here , ▁ then ▁ this ▁ origin ▁ matches ▁ the ▁ current ENDCOM # ▁ secure ▁ origin ▁ and ▁ we ▁ should ▁ return ▁ True ENDCOM DEDENT return True NEW_LINE # ▁ If ▁ we ' ve ▁ gotten ▁ to ▁ this ▁ point , ▁ then ▁ the ▁ origin ▁ isn ' t ▁ secure ▁ and ▁ we ENDCOM # ▁ will ▁ not ▁ accept ▁ it ▁ as ▁ a ▁ valid ▁ location ▁ to ▁ search . ▁ We ▁ will ▁ however ENDCOM # ▁ log ▁ a ▁ warning ▁ that ▁ we ▁ are ▁ ignoring ▁ it . ENDCOM DEDENT logger . warning ( " The ▁ repository ▁ located ▁ at ▁ % s ▁ is ▁ not ▁ a ▁ trusted ▁ or ▁ secure ▁ host ▁ and ▁ " " is ▁ being ▁ ignored . ▁ If ▁ this ▁ repository ▁ is ▁ available ▁ via ▁ HTTPS ▁ it ▁ " " is ▁ recommended ▁ to ▁ use ▁ HTTPS ▁ instead , ▁ otherwise ▁ you ▁ may ▁ silence ▁ " " this ▁ warning ▁ and ▁ allow ▁ it ▁ anyways ▁ with ▁ ' - - trusted - host ▁ % s ' . " , parsed . hostname , parsed . hostname , ) NEW_LINE return False NEW_LINE DEDENT
def _get_index_urls_locations ( self , project_name ) : NEW_LINE INDENT """ Returns ▁ the ▁ locations ▁ found ▁ via ▁ self . index _ urls STRNEWLINE STRNEWLINE ▁ Checks ▁ the ▁ url _ name ▁ on ▁ the ▁ main ▁ ( first ▁ in ▁ the ▁ list ) ▁ index ▁ and STRNEWLINE ▁ use ▁ this ▁ url _ name ▁ to ▁ produce ▁ all ▁ locations STRNEWLINE ▁ """ NEW_LINE def mkurl_pypi_url ( url ) : NEW_LINE INDENT loc = posixpath . join ( url , project_url_name ) NEW_LINE # ▁ For ▁ maximum ▁ compatibility ▁ with ▁ easy _ install , ▁ ensure ▁ the ▁ path ENDCOM # ▁ ends ▁ in ▁ a ▁ trailing ▁ slash . ▁ Although ▁ this ▁ isn ' t ▁ in ▁ the ▁ spec ENDCOM # ▁ ( and ▁ PyPI ▁ can ▁ handle ▁ it ▁ without ▁ the ▁ slash ) ▁ some ▁ other ▁ index ENDCOM # ▁ implementations ▁ might ▁ break ▁ if ▁ they ▁ relied ▁ on ▁ easy _ install ' s ENDCOM # ▁ behavior . ENDCOM if not loc . endswith ( ' / ' ) : NEW_LINE INDENT loc = loc + ' / ' NEW_LINE DEDENT return loc NEW_LINE DEDENT project_url_name = urllib_parse . quote ( project_name . lower ( ) ) NEW_LINE if self . index_urls : NEW_LINE # ▁ Check ▁ that ▁ we ▁ have ▁ the ▁ url _ name ▁ correctly ▁ spelled : ENDCOM # ▁ Only ▁ check ▁ main ▁ index ▁ if ▁ index ▁ URL ▁ is ▁ given ENDCOM INDENT main_index_url = Link ( mkurl_pypi_url ( self . index_urls [ 0 ] ) , trusted = True , ) NEW_LINE page = self . _get_page ( main_index_url ) NEW_LINE if page is None and PyPI . netloc not in str ( main_index_url ) : NEW_LINE INDENT warnings . warn ( " Failed ▁ to ▁ find ▁ % r ▁ at ▁ % s . ▁ It ▁ is ▁ suggested ▁ to ▁ upgrade ▁ " " your ▁ index ▁ to ▁ support ▁ normalized ▁ names ▁ as ▁ the ▁ name ▁ in ▁ " " / simple / { name } . " % ( project_name , main_index_url ) , RemovedInPip8Warning , ) NEW_LINE project_url_name = self . _find_url_name ( Link ( self . index_urls [ 0 ] , trusted = True ) , project_url_name , ) or project_url_name NEW_LINE DEDENT DEDENT if project_url_name is not None : NEW_LINE INDENT return [ mkurl_pypi_url ( url ) for url in self . index_urls ] NEW_LINE DEDENT return [ ] NEW_LINE DEDENT
def _find_all_versions ( self , project_name ) : NEW_LINE INDENT """ Find ▁ all ▁ available ▁ versions ▁ for ▁ project _ name STRNEWLINE STRNEWLINE ▁ This ▁ checks ▁ index _ urls , ▁ find _ links ▁ and ▁ dependency _ links STRNEWLINE ▁ All ▁ versions ▁ found ▁ are ▁ returned STRNEWLINE STRNEWLINE ▁ See ▁ _ link _ package _ versions ▁ for ▁ details ▁ on ▁ which ▁ files ▁ are ▁ accepted STRNEWLINE ▁ """ NEW_LINE index_locations = self . _get_index_urls_locations ( project_name ) NEW_LINE index_file_loc , index_url_loc = self . _sort_locations ( index_locations ) NEW_LINE fl_file_loc , fl_url_loc = self . _sort_locations ( self . find_links , expand_dir = True ) NEW_LINE dep_file_loc , dep_url_loc = self . _sort_locations ( self . dependency_links ) NEW_LINE file_locations = ( Link ( url ) for url in itertools . chain ( index_file_loc , fl_file_loc , dep_file_loc ) ) NEW_LINE # ▁ We ▁ trust ▁ every ▁ url ▁ that ▁ the ▁ user ▁ has ▁ given ▁ us ▁ whether ▁ it ▁ was ▁ given ENDCOM # ▁ via ▁ - - index - url ▁ or ▁ - - find - links ENDCOM # ▁ We ▁ explicitly ▁ do ▁ not ▁ trust ▁ links ▁ that ▁ came ▁ from ▁ dependency _ links ENDCOM # ▁ We ▁ want ▁ to ▁ filter ▁ out ▁ any ▁ thing ▁ which ▁ does ▁ not ▁ have ▁ a ▁ secure ▁ origin . ENDCOM url_locations = [ link for link in itertools . chain ( ( Link ( url , trusted = True ) for url in index_url_loc ) , ( Link ( url , trusted = True ) for url in fl_url_loc ) , ( Link ( url ) for url in dep_url_loc ) , ) if self . _validate_secure_origin ( logger , link ) ] NEW_LINE logger . debug ( ' % d ▁ location ( s ) ▁ to ▁ search ▁ for ▁ versions ▁ of ▁ % s : ' , len ( url_locations ) , project_name ) NEW_LINE for location in url_locations : NEW_LINE INDENT logger . debug ( ' * ▁ % s ' , location ) NEW_LINE DEDENT canonical_name = pkg_resources . safe_name ( project_name ) . lower ( ) NEW_LINE formats = fmt_ctl_formats ( self . format_control , canonical_name ) NEW_LINE search = Search ( project_name . lower ( ) , canonical_name , formats ) NEW_LINE find_links_versions = self . _package_versions ( # ▁ We ▁ trust ▁ every ▁ directly ▁ linked ▁ archive ▁ in ▁ find _ links ENDCOM ( Link ( url , ' - f ' , trusted = True ) for url in self . find_links ) , search ) NEW_LINE page_versions = [ ] NEW_LINE for page in self . _get_pages ( url_locations , project_name ) : NEW_LINE INDENT logger . debug ( ' Analyzing ▁ links ▁ from ▁ page ▁ % s ' , page . url ) NEW_LINE with indent_log ( ) : NEW_LINE INDENT page_versions . extend ( self . _package_versions ( page . links , search ) ) NEW_LINE DEDENT DEDENT dependency_versions = self . _package_versions ( ( Link ( url ) for url in self . dependency_links ) , search ) NEW_LINE if dependency_versions : NEW_LINE INDENT logger . debug ( ' dependency _ links ▁ found : ▁ % s ' , ' , ▁ ' . join ( [ version . location . url for version in dependency_versions ] ) ) NEW_LINE DEDENT file_versions = self . _package_versions ( file_locations , search ) NEW_LINE if file_versions : NEW_LINE INDENT file_versions . sort ( reverse = True ) NEW_LINE logger . debug ( ' Local ▁ files ▁ found : ▁ % s ' , ' , ▁ ' . join ( [ url_to_path ( candidate . location . url ) for candidate in file_versions ] ) ) NEW_LINE # ▁ This ▁ is ▁ an ▁ intentional ▁ priority ▁ ordering ENDCOM DEDENT return ( file_versions + find_links_versions + page_versions + dependency_versions ) NEW_LINE DEDENT
def find_requirement ( self , req , upgrade ) : NEW_LINE INDENT """ Try ▁ to ▁ find ▁ an ▁ InstallationCandidate ▁ for ▁ req STRNEWLINE STRNEWLINE ▁ Expects ▁ req , ▁ an ▁ InstallRequirement ▁ and ▁ upgrade , ▁ a ▁ boolean STRNEWLINE ▁ Returns ▁ an ▁ InstallationCandidate ▁ or ▁ None STRNEWLINE ▁ May ▁ raise ▁ DistributionNotFound ▁ or ▁ BestVersionAlreadyInstalled STRNEWLINE ▁ """ NEW_LINE all_versions = self . _find_all_versions ( req . name ) NEW_LINE # ▁ Filter ▁ out ▁ anything ▁ which ▁ doesn ' t ▁ match ▁ our ▁ specifier ENDCOM _versions = set ( req . specifier . filter ( # ▁ We ▁ turn ▁ the ▁ version ▁ object ▁ into ▁ a ▁ str ▁ here ▁ because ▁ otherwise ENDCOM # ▁ when ▁ we ' re ▁ debundled ▁ but ▁ setuptools ▁ isn ' t , ▁ Python ▁ will ▁ see ENDCOM # ▁ packaging . version . Version ▁ and ENDCOM # ▁ pkg _ resources . _ vendor . packaging . version . Version ▁ as ▁ different ENDCOM # ▁ types . ▁ This ▁ way ▁ we ' ll ▁ use ▁ a ▁ str ▁ as ▁ a ▁ common ▁ data ▁ interchange ENDCOM # ▁ format . ▁ If ▁ we ▁ stop ▁ using ▁ the ▁ pkg _ resources ▁ provided ▁ specifier ENDCOM # ▁ and ▁ start ▁ using ▁ our ▁ own , ▁ we ▁ can ▁ drop ▁ the ▁ cast ▁ to ▁ str ( ) . ENDCOM [ str ( x . version ) for x in all_versions ] , prereleases = ( self . allow_all_prereleases if self . allow_all_prereleases else None ) , ) ) NEW_LINE applicable_versions = [ # ▁ Again , ▁ converting ▁ to ▁ str ▁ to ▁ deal ▁ with ▁ debundling . ENDCOM x for x in all_versions if str ( x . version ) in _versions ] NEW_LINE if req . satisfied_by is not None : NEW_LINE # ▁ Finally ▁ add ▁ our ▁ existing ▁ versions ▁ to ▁ the ▁ front ▁ of ▁ our ▁ versions . ENDCOM INDENT applicable_versions . insert ( 0 , InstallationCandidate ( req . name , req . satisfied_by . version , INSTALLED_VERSION , ) ) NEW_LINE existing_applicable = True NEW_LINE DEDENT else : NEW_LINE INDENT existing_applicable = False NEW_LINE DEDENT applicable_versions = self . _sort_versions ( applicable_versions ) NEW_LINE if not upgrade and existing_applicable : NEW_LINE INDENT if applicable_versions [ 0 ] . location is INSTALLED_VERSION : NEW_LINE INDENT logger . debug ( ' Existing ▁ installed ▁ version ▁ ( % s ) ▁ is ▁ most ▁ up - to - date ▁ and ▁ ' ' satisfies ▁ requirement ' , req . satisfied_by . version , ) NEW_LINE DEDENT else : NEW_LINE INDENT logger . debug ( ' Existing ▁ installed ▁ version ▁ ( % s ) ▁ satisfies ▁ requirement ▁ ' ' ( most ▁ up - to - date ▁ version ▁ is ▁ % s ) ' , req . satisfied_by . version , applicable_versions [ 0 ] [ 2 ] , ) NEW_LINE DEDENT return None NEW_LINE DEDENT if not applicable_versions : NEW_LINE INDENT logger . critical ( ' Could ▁ not ▁ find ▁ a ▁ version ▁ that ▁ satisfies ▁ the ▁ requirement ▁ % s ▁ ' ' ( from ▁ versions : ▁ % s ) ' , req , ' , ▁ ' . join ( sorted ( set ( str ( i . version ) for i in all_versions ) , key = parse_version , ) ) ) NEW_LINE if self . need_warn_external : NEW_LINE INDENT logger . warning ( " Some ▁ externally ▁ hosted ▁ files ▁ were ▁ ignored ▁ as ▁ access ▁ to ▁ " " them ▁ may ▁ be ▁ unreliable ▁ ( use ▁ - - allow - external ▁ % s ▁ to ▁ " " allow ) . " , req . name , ) NEW_LINE DEDENT if self . need_warn_unverified : NEW_LINE INDENT logger . warning ( " Some ▁ insecure ▁ and ▁ unverifiable ▁ files ▁ were ▁ ignored " " ▁ ( use ▁ - - allow - unverified ▁ % s ▁ to ▁ allow ) . " , req . name , ) NEW_LINE DEDENT raise DistributionNotFound ( ' No ▁ matching ▁ distribution ▁ found ▁ for ▁ % s ' % req ) NEW_LINE DEDENT if applicable_versions [ 0 ] . location is INSTALLED_VERSION : NEW_LINE # ▁ We ▁ have ▁ an ▁ existing ▁ version , ▁ and ▁ its ▁ the ▁ best ▁ version ENDCOM INDENT logger . debug ( ' Installed ▁ version ▁ ( % s ) ▁ is ▁ most ▁ up - to - date ▁ ( past ▁ versions : ▁ ' ' % s ) ' , req . satisfied_by . version , ' , ▁ ' . join ( str ( i . version ) for i in applicable_versions [ 1 : ] ) or " none " , ) NEW_LINE raise BestVersionAlreadyInstalled NEW_LINE DEDENT if len ( applicable_versions ) > 1 : NEW_LINE INDENT logger . debug ( ' Using ▁ version ▁ % s ▁ ( newest ▁ of ▁ versions : ▁ % s ) ' , applicable_versions [ 0 ] . version , ' , ▁ ' . join ( str ( i . version ) for i in applicable_versions ) ) NEW_LINE DEDENT selected_version = applicable_versions [ 0 ] . location NEW_LINE if ( selected_version . verifiable is not None and not selected_version . verifiable ) : NEW_LINE INDENT logger . warning ( " % s ▁ is ▁ potentially ▁ insecure ▁ and ▁ unverifiable . " , req . name , ) NEW_LINE DEDENT return selected_version NEW_LINE DEDENT
def _find_url_name ( self , index_url , url_name ) : NEW_LINE INDENT """ STRNEWLINE ▁ Finds ▁ the ▁ true ▁ URL ▁ name ▁ of ▁ a ▁ package , ▁ when ▁ the ▁ given ▁ name ▁ isn ' t ▁ quite STRNEWLINE ▁ correct . STRNEWLINE ▁ This ▁ is ▁ usually ▁ used ▁ to ▁ implement ▁ case - insensitivity . STRNEWLINE ▁ """ NEW_LINE if not index_url . url . endswith ( ' / ' ) : NEW_LINE # ▁ Vaguely ▁ part ▁ of ▁ the ▁ PyPI ▁ API . . . ▁ weird ▁ but ▁ true . ENDCOM # ▁ FIXME : ▁ bad ▁ to ▁ modify ▁ this ? ENDCOM INDENT index_url . url += ' / ' NEW_LINE DEDENT page = self . _get_page ( index_url ) NEW_LINE if page is None : NEW_LINE INDENT logger . critical ( ' Cannot ▁ fetch ▁ index ▁ base ▁ URL ▁ % s ' , index_url ) NEW_LINE return NEW_LINE DEDENT norm_name = normalize_name ( url_name ) NEW_LINE for link in page . links : NEW_LINE INDENT base = posixpath . basename ( link . path . rstrip ( ' / ' ) ) NEW_LINE if norm_name == normalize_name ( base ) : NEW_LINE INDENT logger . debug ( ' Real ▁ name ▁ of ▁ requirement ▁ % s ▁ is ▁ % s ' , url_name , base , ) NEW_LINE return base NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def _get_pages ( self , locations , project_name ) : NEW_LINE INDENT """ STRNEWLINE ▁ Yields ▁ ( page , ▁ page _ url ) ▁ from ▁ the ▁ given ▁ locations , ▁ skipping STRNEWLINE ▁ locations ▁ that ▁ have ▁ errors , ▁ and ▁ adding ▁ download / homepage ▁ links STRNEWLINE ▁ """ NEW_LINE all_locations = list ( locations ) NEW_LINE seen = set ( ) NEW_LINE normalized = normalize_name ( project_name ) NEW_LINE while all_locations : NEW_LINE INDENT location = all_locations . pop ( 0 ) NEW_LINE if location in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . add ( location ) NEW_LINE page = self . _get_page ( location ) NEW_LINE if page is None : NEW_LINE INDENT continue NEW_LINE DEDENT yield page NEW_LINE for link in page . rel_links ( ) : NEW_LINE INDENT if ( normalized not in self . allow_external and not self . allow_all_external ) : NEW_LINE INDENT self . need_warn_external = True NEW_LINE logger . debug ( " Not ▁ searching ▁ % s ▁ for ▁ files ▁ because ▁ external ▁ " " urls ▁ are ▁ disallowed . " , link , ) NEW_LINE continue NEW_LINE DEDENT if ( link . trusted is not None and not link . trusted and normalized not in self . allow_unverified ) : NEW_LINE INDENT logger . debug ( " Not ▁ searching ▁ % s ▁ for ▁ urls , ▁ it ▁ is ▁ an ▁ " " untrusted ▁ link ▁ and ▁ cannot ▁ produce ▁ safe ▁ or ▁ " " verifiable ▁ files . " , link , ) NEW_LINE self . need_warn_unverified = True NEW_LINE continue NEW_LINE DEDENT all_locations . append ( link ) NEW_LINE DEDENT DEDENT DEDENT
def _sort_links ( self , links ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ elements ▁ of ▁ links ▁ in ▁ order , ▁ non - egg ▁ links ▁ first , ▁ egg ▁ links STRNEWLINE ▁ second , ▁ while ▁ eliminating ▁ duplicates STRNEWLINE ▁ """ NEW_LINE eggs , no_eggs = [ ] , [ ] NEW_LINE seen = set ( ) NEW_LINE for link in links : NEW_LINE INDENT if link not in seen : NEW_LINE INDENT seen . add ( link ) NEW_LINE if link . egg_fragment : NEW_LINE INDENT eggs . append ( link ) NEW_LINE DEDENT else : NEW_LINE INDENT no_eggs . append ( link ) NEW_LINE DEDENT DEDENT DEDENT return no_eggs + eggs NEW_LINE DEDENT
def _package_versions ( self , links , search ) : NEW_LINE INDENT result = [ ] NEW_LINE for link in self . _sort_links ( links ) : NEW_LINE INDENT v = self . _link_package_versions ( link , search ) NEW_LINE if v is not None : NEW_LINE INDENT result . append ( v ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def _log_skipped_link ( self , link , reason ) : NEW_LINE INDENT if link not in self . logged_links : NEW_LINE INDENT logger . debug ( ' Skipping ▁ link ▁ % s ; ▁ % s ' , link , reason ) NEW_LINE self . logged_links . add ( link ) NEW_LINE DEDENT DEDENT
def _link_package_versions ( self , link , search ) : NEW_LINE INDENT """ Return ▁ an ▁ InstallationCandidate ▁ or ▁ None """ NEW_LINE platform = get_platform ( ) NEW_LINE version = None NEW_LINE if link . egg_fragment : NEW_LINE INDENT egg_info = link . egg_fragment NEW_LINE ext = link . ext NEW_LINE DEDENT else : NEW_LINE INDENT egg_info , ext = link . splitext ( ) NEW_LINE if not ext : NEW_LINE INDENT self . _log_skipped_link ( link , ' not ▁ a ▁ file ' ) NEW_LINE return NEW_LINE DEDENT if ext not in SUPPORTED_EXTENSIONS : NEW_LINE INDENT self . _log_skipped_link ( link , ' unsupported ▁ archive ▁ format : ▁ % s ' % ext ) NEW_LINE return NEW_LINE DEDENT if " binary " not in search . formats and ext == wheel_ext : NEW_LINE INDENT self . _log_skipped_link ( link , ' No ▁ binaries ▁ permitted ▁ for ▁ % s ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if " macosx10" in link . path and ext == ' . zip ' : NEW_LINE INDENT self . _log_skipped_link ( link , ' macosx10 ▁ one ' ) NEW_LINE return NEW_LINE DEDENT if ext == wheel_ext : NEW_LINE INDENT try : NEW_LINE INDENT wheel = Wheel ( link . filename ) NEW_LINE DEDENT except InvalidWheelFilename : NEW_LINE INDENT self . _log_skipped_link ( link , ' invalid ▁ wheel ▁ filename ' ) NEW_LINE return NEW_LINE DEDENT if ( pkg_resources . safe_name ( wheel . name ) . lower ( ) != search . canonical ) : NEW_LINE INDENT self . _log_skipped_link ( link , ' wrong ▁ project ▁ name ▁ ( not ▁ % s ) ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if not wheel . supported ( ) : NEW_LINE INDENT self . _log_skipped_link ( link , ' it ▁ is ▁ not ▁ compatible ▁ with ▁ this ▁ Python ' ) NEW_LINE return NEW_LINE # ▁ This ▁ is ▁ a ▁ dirty ▁ hack ▁ to ▁ prevent ▁ installing ▁ Binary ▁ Wheels ▁ from ENDCOM # ▁ PyPI ▁ unless ▁ it ▁ is ▁ a ▁ Windows ▁ or ▁ Mac ▁ Binary ▁ Wheel . ▁ This ▁ is ENDCOM # ▁ paired ▁ with ▁ a ▁ change ▁ to ▁ PyPI ▁ disabling ▁ uploads ▁ for ▁ the ENDCOM # ▁ same . ▁ Once ▁ we ▁ have ▁ a ▁ mechanism ▁ for ▁ enabling ▁ support ▁ for ENDCOM # ▁ binary ▁ wheels ▁ on ▁ linux ▁ that ▁ deals ▁ with ▁ the ▁ inherent ▁ problems ENDCOM # ▁ of ▁ binary ▁ distribution ▁ this ▁ can ▁ be ▁ removed . ENDCOM DEDENT comes_from = getattr ( link , " comes _ from " , None ) NEW_LINE if ( ( not platform . startswith ( ' win ' ) and not platform . startswith ( ' macosx ' ) and not platform == ' cli ' ) and comes_from is not None and urllib_parse . urlparse ( comes_from . url ) . netloc . endswith ( PyPI . netloc ) ) : NEW_LINE INDENT if not wheel . supported ( tags = supported_tags_noarch ) : NEW_LINE INDENT self . _log_skipped_link ( link , " it ▁ is ▁ a ▁ pypi - hosted ▁ binary ▁ " " Wheel ▁ on ▁ an ▁ unsupported ▁ platform " , ) NEW_LINE return NEW_LINE DEDENT DEDENT version = wheel . version NEW_LINE # ▁ This ▁ should ▁ be ▁ up ▁ by ▁ the ▁ search . ok _ binary ▁ check , ▁ but ▁ see ▁ issue ▁ 2700 . ENDCOM DEDENT DEDENT if " source " not in search . formats and ext != wheel_ext : NEW_LINE INDENT self . _log_skipped_link ( link , ' No ▁ sources ▁ permitted ▁ for ▁ % s ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if not version : NEW_LINE INDENT version = egg_info_matches ( egg_info , search . supplied , link ) NEW_LINE DEDENT if version is None : NEW_LINE INDENT self . _log_skipped_link ( link , ' wrong ▁ project ▁ name ▁ ( not ▁ % s ) ' % search . supplied ) NEW_LINE return NEW_LINE DEDENT if ( link . internal is not None and not link . internal and not normalize_name ( search . supplied ) . lower ( ) in self . allow_external and not self . allow_all_external ) : NEW_LINE # ▁ We ▁ have ▁ a ▁ link ▁ that ▁ we ▁ are ▁ sure ▁ is ▁ external , ▁ so ▁ we ▁ should ▁ skip ENDCOM # ▁ it ▁ unless ▁ we ▁ are ▁ allowing ▁ externals ENDCOM INDENT self . _log_skipped_link ( link , ' it ▁ is ▁ externally ▁ hosted ' ) NEW_LINE self . need_warn_external = True NEW_LINE return NEW_LINE DEDENT if ( link . verifiable is not None and not link . verifiable and not ( normalize_name ( search . supplied ) . lower ( ) in self . allow_unverified ) ) : NEW_LINE # ▁ We ▁ have ▁ a ▁ link ▁ that ▁ we ▁ are ▁ sure ▁ we ▁ cannot ▁ verify ▁ its ▁ integrity , ENDCOM # ▁ so ▁ we ▁ should ▁ skip ▁ it ▁ unless ▁ we ▁ are ▁ allowing ▁ unsafe ▁ installs ENDCOM # ▁ for ▁ this ▁ requirement . ENDCOM INDENT self . _log_skipped_link ( link , ' it ▁ is ▁ an ▁ insecure ▁ and ▁ unverifiable ▁ file ' ) NEW_LINE self . need_warn_unverified = True NEW_LINE return NEW_LINE DEDENT match = self . _py_version_re . search ( version ) NEW_LINE if match : NEW_LINE INDENT version = version [ : match . start ( ) ] NEW_LINE py_version = match . group ( 1 ) NEW_LINE if py_version != sys . version [ : 3 ] : NEW_LINE INDENT self . _log_skipped_link ( link , ' Python ▁ version ▁ is ▁ incorrect ' ) NEW_LINE return NEW_LINE DEDENT DEDENT logger . debug ( ' Found ▁ link ▁ % s , ▁ version : ▁ % s ' , link , version ) NEW_LINE return InstallationCandidate ( search . supplied , version , link ) NEW_LINE DEDENT
def _get_page ( self , link ) : NEW_LINE INDENT return HTMLPage . get_page ( link , session = self . session ) NEW_LINE DEDENT
def __init__ ( self , content , url , headers = None , trusted = None ) : NEW_LINE # ▁ Determine ▁ if ▁ we ▁ have ▁ any ▁ encoding ▁ information ▁ in ▁ our ▁ headers ENDCOM INDENT encoding = None NEW_LINE if headers and " Content - Type " in headers : NEW_LINE INDENT content_type , params = cgi . parse_header ( headers [ " Content - Type " ] ) NEW_LINE if " charset " in params : NEW_LINE INDENT encoding = params [ ' charset ' ] NEW_LINE DEDENT DEDENT self . content = content NEW_LINE self . parsed = html5lib . parse ( self . content , encoding = encoding , namespaceHTMLElements = False , ) NEW_LINE self . url = url NEW_LINE self . headers = headers NEW_LINE self . trusted = trusted NEW_LINE DEDENT
def __str__ ( self ) : NEW_LINE INDENT return self . url NEW_LINE DEDENT
def api_version ( self ) : NEW_LINE INDENT metas = [ x for x in self . parsed . findall ( " . / / meta " ) if x . get ( " name " , " " ) . lower ( ) == " api - version " ] NEW_LINE if metas : NEW_LINE INDENT try : NEW_LINE INDENT return int ( metas [ 0 ] . get ( " value " , None ) ) NEW_LINE DEDENT except ( TypeError , ValueError ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def base_url ( self ) : NEW_LINE INDENT bases = [ x for x in self . parsed . findall ( " . / / base " ) if x . get ( " href " ) is not None ] NEW_LINE if bases and bases [ 0 ] . get ( " href " ) : NEW_LINE INDENT return bases [ 0 ] . get ( " href " ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . url NEW_LINE DEDENT DEDENT
def links ( self ) : NEW_LINE INDENT """ Yields ▁ all ▁ links ▁ in ▁ the ▁ page """ NEW_LINE for anchor in self . parsed . findall ( " . / / a " ) : NEW_LINE INDENT if anchor . get ( " href " ) : NEW_LINE INDENT href = anchor . get ( " href " ) NEW_LINE url = self . clean_link ( urllib_parse . urljoin ( self . base_url , href ) ) NEW_LINE # ▁ Determine ▁ if ▁ this ▁ link ▁ is ▁ internal . ▁ If ▁ that ▁ distinction ENDCOM # ▁ doesn ' t ▁ make ▁ sense ▁ in ▁ this ▁ context , ▁ then ▁ we ▁ don ' t ▁ make ENDCOM # ▁ any ▁ distinction . ENDCOM internal = None NEW_LINE if self . api_version and self . api_version >= 2 : NEW_LINE # ▁ Only ▁ api _ versions ▁ > = ▁ 2 ▁ have ▁ a ▁ distinction ▁ between ENDCOM # ▁ external ▁ and ▁ internal ▁ links ENDCOM INDENT internal = bool ( anchor . get ( " rel " ) and " internal " in anchor . get ( " rel " ) . split ( ) ) NEW_LINE DEDENT yield Link ( url , self , internal = internal ) NEW_LINE DEDENT DEDENT DEDENT
def rel_links ( self , rels = ( ' homepage ' , ' download ' ) ) : NEW_LINE INDENT """ Yields ▁ all ▁ links ▁ with ▁ the ▁ given ▁ relations """ NEW_LINE rels = set ( rels ) NEW_LINE for anchor in self . parsed . findall ( " . / / a " ) : NEW_LINE INDENT if anchor . get ( " rel " ) and anchor . get ( " href " ) : NEW_LINE INDENT found_rels = set ( anchor . get ( " rel " ) . split ( ) ) NEW_LINE # ▁ Determine ▁ the ▁ intersection ▁ between ▁ what ▁ rels ▁ were ▁ found ▁ and ENDCOM # ▁ what ▁ rels ▁ were ▁ being ▁ looked ▁ for ENDCOM if found_rels & rels : NEW_LINE INDENT href = anchor . get ( " href " ) NEW_LINE url = self . clean_link ( urllib_parse . urljoin ( self . base_url , href ) ) NEW_LINE yield Link ( url , self , trusted = False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def clean_link ( self , url ) : NEW_LINE INDENT """ Makes ▁ sure ▁ a ▁ link ▁ is ▁ fully ▁ encoded . ▁ That ▁ is , ▁ if ▁ a ▁ ' ▁ ' ▁ shows ▁ up ▁ in STRNEWLINE ▁ the ▁ link , ▁ it ▁ will ▁ be ▁ rewritten ▁ to ▁ % 20 ▁ ( while ▁ not ▁ over - quoting STRNEWLINE ▁ % ▁ or ▁ other ▁ characters ) . """ NEW_LINE return self . _clean_re . sub ( lambda match : ' % % % 2x ' % ord ( match . group ( 0 ) ) , url ) NEW_LINE DEDENT
def __init__ ( self , url , comes_from = None , internal = None , trusted = None ) : NEW_LINE # ▁ url ▁ can ▁ be ▁ a ▁ UNC ▁ windows ▁ share ENDCOM INDENT if url != Inf and url . startswith ( ' \\\\ ' ) : NEW_LINE INDENT url = path_to_url ( url ) NEW_LINE DEDENT self . url = url NEW_LINE self . comes_from = comes_from NEW_LINE self . internal = internal NEW_LINE self . trusted = trusted NEW_LINE DEDENT
def __str__ ( self ) : NEW_LINE INDENT if self . comes_from : NEW_LINE INDENT return ' % s ▁ ( from ▁ % s ) ' % ( self . url , self . comes_from ) NEW_LINE DEDENT else : NEW_LINE INDENT return str ( self . url ) NEW_LINE DEDENT DEDENT
def __repr__ ( self ) : NEW_LINE INDENT return ' < Link ▁ % s > ' % self NEW_LINE DEDENT
def __eq__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url == other . url NEW_LINE DEDENT
def __ne__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url != other . url NEW_LINE DEDENT
def __lt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url < other . url NEW_LINE DEDENT
def __le__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url <= other . url NEW_LINE DEDENT
def __gt__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url > other . url NEW_LINE DEDENT
def __ge__ ( self , other ) : NEW_LINE INDENT if not isinstance ( other , Link ) : NEW_LINE INDENT return NotImplemented NEW_LINE DEDENT return self . url >= other . url NEW_LINE DEDENT
def __hash__ ( self ) : NEW_LINE INDENT return hash ( self . url ) NEW_LINE DEDENT
def filename ( self ) : NEW_LINE INDENT _ , netloc , path , _ , _ = urllib_parse . urlsplit ( self . url ) NEW_LINE name = posixpath . basename ( path . rstrip ( ' / ' ) ) or netloc NEW_LINE name = urllib_parse . unquote ( name ) NEW_LINE assert name , ( ' URL ▁ % r ▁ produced ▁ no ▁ filename ' % self . url ) NEW_LINE return name NEW_LINE DEDENT
def scheme ( self ) : NEW_LINE INDENT return urllib_parse . urlsplit ( self . url ) [ 0 ] NEW_LINE DEDENT
def netloc ( self ) : NEW_LINE INDENT return urllib_parse . urlsplit ( self . url ) [ 1 ] NEW_LINE DEDENT
def path ( self ) : NEW_LINE INDENT return urllib_parse . unquote ( urllib_parse . urlsplit ( self . url ) [ 2 ] ) NEW_LINE DEDENT
def splitext ( self ) : NEW_LINE INDENT return splitext ( posixpath . basename ( self . path . rstrip ( ' / ' ) ) ) NEW_LINE DEDENT
def ext ( self ) : NEW_LINE INDENT return self . splitext ( ) [ 1 ] NEW_LINE DEDENT
def url_without_fragment ( self ) : NEW_LINE INDENT scheme , netloc , path , query , fragment = urllib_parse . urlsplit ( self . url ) NEW_LINE return urllib_parse . urlunsplit ( ( scheme , netloc , path , query , None ) ) NEW_LINE DEDENT
def egg_fragment ( self ) : NEW_LINE INDENT match = self . _egg_fragment_re . search ( self . url ) NEW_LINE if not match : NEW_LINE INDENT return None NEW_LINE DEDENT return match . group ( 1 ) NEW_LINE DEDENT
def hash ( self ) : NEW_LINE INDENT match = self . _hash_re . search ( self . url ) NEW_LINE if match : NEW_LINE INDENT return match . group ( 2 ) NEW_LINE DEDENT return None NEW_LINE DEDENT
def hash_name ( self ) : NEW_LINE INDENT match = self . _hash_re . search ( self . url ) NEW_LINE if match : NEW_LINE INDENT return match . group ( 1 ) NEW_LINE DEDENT return None NEW_LINE DEDENT
def show_url ( self ) : NEW_LINE INDENT return posixpath . basename ( self . url . split ( ' # ' , 1 ) [ 0 ] . split ( ' ? ' , 1 ) [ 0 ] ) NEW_LINE DEDENT
def verifiable ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Returns ▁ True ▁ if ▁ this ▁ link ▁ can ▁ be ▁ verified ▁ after ▁ download , ▁ False ▁ if ▁ it STRNEWLINE ▁ cannot , ▁ and ▁ None ▁ if ▁ we ▁ cannot ▁ determine . STRNEWLINE ▁ """ NEW_LINE trusted = self . trusted or getattr ( self . comes_from , " trusted " , None ) NEW_LINE if trusted is not None and trusted : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ a ▁ trusted ▁ source . ▁ It ▁ * may * ▁ be ▁ verifiable ▁ but ENDCOM # ▁ first ▁ we ▁ need ▁ to ▁ see ▁ if ▁ this ▁ page ▁ is ▁ operating ▁ under ▁ the ▁ new ENDCOM # ▁ API ▁ version . ENDCOM INDENT try : NEW_LINE INDENT api_version = getattr ( self . comes_from , " api _ version " , None ) NEW_LINE api_version = int ( api_version ) NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT api_version = None NEW_LINE DEDENT if api_version is None or api_version <= 1 : NEW_LINE # ▁ This ▁ link ▁ is ▁ either ▁ trusted , ▁ or ▁ it ▁ came ▁ from ▁ a ▁ trusted , ENDCOM # ▁ however ▁ it ▁ is ▁ not ▁ operating ▁ under ▁ the ▁ API ▁ version ▁ 2 ▁ so ENDCOM # ▁ we ▁ can ' t ▁ make ▁ any ▁ claims ▁ about ▁ if ▁ it ' s ▁ safe ▁ or ▁ not ENDCOM INDENT return NEW_LINE DEDENT if self . hash : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ a ▁ trusted ▁ source ▁ and ▁ it ▁ has ▁ a ▁ hash , ▁ so ▁ we ENDCOM # ▁ can ▁ consider ▁ it ▁ safe . ENDCOM INDENT return True NEW_LINE DEDENT else : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ a ▁ trusted ▁ source , ▁ using ▁ the ▁ new ▁ API ENDCOM # ▁ version , ▁ and ▁ it ▁ does ▁ not ▁ have ▁ a ▁ hash . ▁ It ▁ is ▁ NOT ▁ verifiable ENDCOM INDENT return False NEW_LINE DEDENT DEDENT elif trusted is not None : NEW_LINE # ▁ This ▁ link ▁ came ▁ from ▁ an ▁ untrusted ▁ source ▁ and ▁ we ▁ cannot ▁ trust ▁ it ENDCOM INDENT return False NEW_LINE DEDENT DEDENT
def is_wheel ( self ) : NEW_LINE INDENT return self . ext == wheel_ext NEW_LINE DEDENT
def is_artifact ( self ) : NEW_LINE INDENT """ STRNEWLINE ▁ Determines ▁ if ▁ this ▁ points ▁ to ▁ an ▁ actual ▁ artifact ▁ ( e . g . ▁ a ▁ tarball ) ▁ or ▁ if STRNEWLINE ▁ it ▁ points ▁ to ▁ an ▁ " abstract " ▁ thing ▁ like ▁ a ▁ path ▁ or ▁ a ▁ VCS ▁ location . STRNEWLINE ▁ """ NEW_LINE from pip . vcs import vcs NEW_LINE if self . scheme in vcs . all_schemes : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE # ▁ An ▁ object ▁ to ▁ represent ▁ the ▁ " link " ▁ for ▁ the ▁ installed ▁ version ▁ of ▁ a ▁ requirement . ENDCOM # ▁ Using ▁ Inf ▁ as ▁ the ▁ url ▁ makes ▁ it ▁ sort ▁ higher . ENDCOM DEDENT
def __init__ ( self , session , bouquets , selectedFunc , enableWrapAround = True ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . setTitle ( _ ( " Choose ▁ bouquet " ) ) NEW_LINE self . selectedFunc = selectedFunc NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " ] , { " ok " : self . okbuttonClick , " cancel " : self . cancelClick } ) NEW_LINE entrys = [ ( x [ 0 ] , x [ 1 ] ) for x in bouquets ] NEW_LINE self [ " menu " ] = MenuList ( entrys , enableWrapAround ) NEW_LINE DEDENT
def getCurrent ( self ) : NEW_LINE INDENT cur = self [ " menu " ] . getCurrent ( ) NEW_LINE return cur and cur [ 1 ] NEW_LINE DEDENT
def okbuttonClick ( self ) : NEW_LINE INDENT self . selectedFunc ( self . getCurrent ( ) ) NEW_LINE DEDENT
def up ( self ) : NEW_LINE INDENT self [ " menu " ] . up ( ) NEW_LINE DEDENT
def down ( self ) : NEW_LINE INDENT self [ " menu " ] . down ( ) NEW_LINE DEDENT
def cancelClick ( self ) : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT
def __init__ ( self , bouquets , enableWrapAround = False , current = 0 ) : NEW_LINE INDENT self . bouquets = [ b [ 1 ] for b in bouquets ] NEW_LINE self . pos = current NEW_LINE self . count = len ( bouquets ) NEW_LINE self . enableWrapAround = enableWrapAround NEW_LINE DEDENT
def up ( self ) : NEW_LINE INDENT if self . pos > 0 or self . enableWrapAround : NEW_LINE INDENT self . pos = ( self . pos - 1 ) % self . count NEW_LINE DEDENT DEDENT
def down ( self ) : NEW_LINE INDENT if self . pos < ( self . count - 1 ) or self . enableWrapAround : NEW_LINE INDENT self . pos = ( self . pos + 1 ) % self . count NEW_LINE DEDENT DEDENT
def getCurrent ( self ) : NEW_LINE INDENT return self . bouquets [ self . pos ] NEW_LINE # ▁ csel . bouquet _ mark _ edit ▁ values ENDCOM DEDENT
def __init__ ( self , session , csel ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . csel = csel NEW_LINE self . bsel = None NEW_LINE if self . isProtected ( ) : NEW_LINE INDENT self . onFirstExecBegin . append ( boundFunction ( self . session . openWithCallback , self . protectResult , PinInput , pinList = [ x . value for x in config . ParentalControl . servicepin ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Please ▁ enter ▁ the ▁ correct ▁ pin ▁ code " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) ) NEW_LINE DEDENT self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " ColorActions " , " NumberActions " , " MenuActions " ] , { " ok " : self . okbuttonClick , " cancel " : self . cancelClick , " blue " : self . showServiceInPiP , " red " : self . playMain , " menu " : self . openSetup , "2" : self . renameEntry , "3" : self . findCurrentlyPlayed , "5" : self . addServiceToBouquetOrAlternative , "6" : self . toggleMoveModeSelect , "8" : self . removeEntry } ) NEW_LINE menu = [ ] NEW_LINE self . removeFunction = False NEW_LINE self . addFunction = False NEW_LINE current = csel . getCurrentSelection ( ) NEW_LINE current_root = csel . getRoot ( ) NEW_LINE current_sel_path = current . getPath ( ) NEW_LINE current_sel_flags = current . flags NEW_LINE inBouquetRootList = current_root and ' FROM ▁ BOUQUET ▁ " bouquets . ' in current_root . getPath ( ) # FIXME ▁ HACK ENDCOM NEW_LINE inAlternativeList = current_root and ' FROM ▁ BOUQUET ▁ " alternatives ' in current_root . getPath ( ) NEW_LINE self . inBouquet = csel . getMutableList ( ) is not None NEW_LINE haveBouquets = config . usage . multibouquet . value NEW_LINE from Components . ParentalControl import parentalControl NEW_LINE self . parentalControl = parentalControl NEW_LINE self . parentalControlEnabled = config . ParentalControl . servicepin [ 0 ] . value and config . ParentalControl . servicepinactive . value NEW_LINE if not ( current_sel_path or current_sel_flags & ( eServiceReference . isDirectory | eServiceReference . isMarker ) ) or current_sel_flags & eServiceReference . isGroup : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " show ▁ transponder ▁ info " ) , self . showServiceInformations ) , level = 2 ) NEW_LINE DEDENT if csel . bouquet_mark_edit == OFF and not csel . entry_marked : NEW_LINE INDENT if not inBouquetRootList : NEW_LINE INDENT isPlayable = not ( current_sel_flags & ( eServiceReference . isMarker | eServiceReference . isDirectory ) ) NEW_LINE if isPlayable : NEW_LINE INDENT for p in plugins . getPlugins ( PluginDescriptor . WHERE_CHANNEL_CONTEXT_MENU ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( p . name , boundFunction ( self . runPlugin , p ) ) , key = " bullet " ) NEW_LINE DEDENT if config . servicelist . startupservice . value == current . toString ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " stop ▁ using ▁ as ▁ startup ▁ service " ) , self . unsetStartupService ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " set ▁ as ▁ startup ▁ service " ) , self . setStartupService ) , level = 0 ) NEW_LINE DEDENT if self . parentalControlEnabled : NEW_LINE INDENT if self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ to ▁ parental ▁ protection " ) , boundFunction ( self . addParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if self . parentalControl . isServiceProtectionBouquet ( current . toCompareString ( ) ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " service ▁ is ▁ in ▁ bouquet ▁ parental ▁ protection " ) , self . cancelClick ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ from ▁ parental ▁ protection " ) , boundFunction ( self . removeParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT DEDENT if config . ParentalControl . hideBlacklist . value and not parentalControl . sessionPinCached and config . ParentalControl . storeservicepin . value != " never " : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Unhide ▁ parental ▁ control ▁ services " ) , self . unhideParentalServices ) , level = 0 , key = "1" ) NEW_LINE DEDENT DEDENT if SystemInfo [ "3DMode " ] and fileExists ( " / usr / lib / enigma2 / python / Plugins / SystemPlugins / OSD3DSetup / plugin . py " ) : NEW_LINE INDENT if eDVBDB . getInstance ( ) . getFlag ( eServiceReference ( current . toString ( ) ) ) & FLAG_IS_DEDICATED_3D : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Unmark ▁ service ▁ as ▁ dedicated ▁ 3D ▁ service " ) , self . removeDedicated3DFlag ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Mark ▁ service ▁ as ▁ dedicated ▁ 3D ▁ service " ) , self . addDedicated3DFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT if not ( current_sel_path ) : NEW_LINE INDENT if eDVBDB . getInstance ( ) . getFlag ( eServiceReference ( current . toString ( ) ) ) & FLAG_HIDE_VBI : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Uncover ▁ dashed ▁ flickering ▁ line ▁ for ▁ this ▁ service " ) , self . removeHideVBIFlag ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " Cover ▁ dashed ▁ flickering ▁ line ▁ for ▁ this ▁ service " ) , self . addHideVBIFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT if haveBouquets : NEW_LINE INDENT bouquets = self . csel . getBouquetList ( ) NEW_LINE if bouquets is None : NEW_LINE INDENT bouquetCnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT bouquetCnt = len ( bouquets ) NEW_LINE DEDENT if not self . inBouquet or bouquetCnt > 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ service ▁ to ▁ bouquet " ) , self . addServiceToBouquetSelected ) , level = 0 , key = "5" ) NEW_LINE self . addFunction = self . addServiceToBouquetSelected NEW_LINE DEDENT if not self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeSatelliteService NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ service ▁ to ▁ favourites " ) , self . addServiceToBouquetSelected ) , level = 0 , key = "5" ) NEW_LINE self . addFunction = self . addServiceToBouquetSelected NEW_LINE DEDENT DEDENT if SystemInfo [ " PIPAvailable " ] : NEW_LINE INDENT if not self . parentalControlEnabled or self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT if self . csel . dopipzap : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " play ▁ in ▁ mainwindow " ) , self . playMain ) , level = 0 , key = " red " ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " play ▁ as ▁ picture ▁ in ▁ picture " ) , self . showServiceInPiP ) , level = 0 , key = " blue " ) NEW_LINE DEDENT DEDENT DEDENT append_when_current_valid ( current , menu , ( _ ( " find ▁ currently ▁ played ▁ service " ) , self . findCurrentlyPlayed ) , level = 0 , key = "3" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ' FROM ▁ SATELLITES ' in current_root . getPath ( ) and current and _ ( " Services " ) in eServiceCenter . getInstance ( ) . info ( current ) . getName ( current ) : NEW_LINE INDENT unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ cable ▁ services " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ terrestrial ▁ services " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ selected ▁ satellite " ) , self . removeSatelliteServices ) , level = 0 ) NEW_LINE DEDENT DEDENT if haveBouquets : NEW_LINE INDENT if not self . inBouquet and not " PROVIDERS " in current_sel_path : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " copy ▁ to ▁ bouquets " ) , self . copyCurrentToBouquetList ) , level = 0 ) NEW_LINE DEDENT DEDENT if ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in current_sel_path : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ all ▁ new ▁ found ▁ flags " ) , self . removeAllNewFoundFlags ) , level = 0 ) NEW_LINE DEDENT DEDENT if self . inBouquet : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE if not inAlternativeList : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeCurrentService NEW_LINE DEDENT DEDENT if current_root and ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in current_root . getPath ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ new ▁ found ▁ flag " ) , self . removeNewFoundFlag ) , level = 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . parentalControlEnabled : NEW_LINE INDENT if self . parentalControl . getProtectionLevel ( current . toCompareString ( ) ) == - 1 : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ bouquet ▁ to ▁ parental ▁ protection " ) , boundFunction ( self . addParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " remove ▁ bouquet ▁ from ▁ parental ▁ protection " ) , boundFunction ( self . removeParentalProtection , current ) ) , level = 0 ) NEW_LINE DEDENT DEDENT menu . append ( ChoiceEntryComponent ( text = ( _ ( " add ▁ bouquet " ) , self . showBouquetInputBox ) ) ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeBouquet NEW_LINE if removed_userbouquets_available ( ) : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " purge ▁ deleted ▁ userbouquets " ) , self . purgeDeletedBouquets ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " restore ▁ deleted ▁ userbouquets " ) , self . restoreDeletedBouquets ) , level = 0 ) NEW_LINE DEDENT DEDENT DEDENT if self . inBouquet : # ▁ current ▁ list ▁ is ▁ editable ? ENDCOM NEW_LINE INDENT if csel . bouquet_mark_edit == OFF : NEW_LINE INDENT if csel . movemode : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " disable ▁ move ▁ mode " ) , self . toggleMoveMode ) , level = 0 , key = "6" ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ move ▁ mode " ) , self . toggleMoveMode ) , level = 1 , key = "6" ) NEW_LINE DEDENT if not csel . entry_marked and not inBouquetRootList and current_root and not ( current_root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT if current . type != - 1 : NEW_LINE INDENT menu . append ( ChoiceEntryComponent ( text = ( _ ( " add ▁ marker " ) , self . showMarkerInputBox ) ) ) NEW_LINE DEDENT if not csel . movemode : NEW_LINE INDENT if haveBouquets : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ bouquet ▁ edit " ) , self . bouquetMarkStart ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " enable ▁ favourite ▁ edit " ) , self . bouquetMarkStart ) , level = 0 ) NEW_LINE DEDENT DEDENT if current_sel_flags & eServiceReference . isGroup : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " edit ▁ alternatives " ) , self . editAlternativeServices ) , level = 2 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " show ▁ alternatives " ) , self . showAlternativeServices ) , level = 2 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ all ▁ alternatives " ) , self . removeAlternativeServices ) , level = 2 ) NEW_LINE DEDENT elif not current_sel_flags & eServiceReference . isMarker : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " add ▁ alternatives " ) , self . addAlternativeServices ) , level = 2 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if csel . bouquet_mark_edit == EDIT_BOUQUET : NEW_LINE INDENT if haveBouquets : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ bouquet ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ bouquet ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ favourites ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ favourites ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT if current_sel_flags & eServiceReference . isMarker : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " rename ▁ entry " ) , self . renameEntry ) , level = 0 , key = "2" ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " remove ▁ entry " ) , self . removeEntry ) , level = 0 , key = "8" ) NEW_LINE self . removeFunction = self . removeCurrentService NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT append_when_current_valid ( current , menu , ( _ ( " end ▁ alternatives ▁ edit " ) , self . bouquetMarkEnd ) , level = 0 ) NEW_LINE append_when_current_valid ( current , menu , ( _ ( " abort ▁ alternatives ▁ edit " ) , self . bouquetMarkAbort ) , level = 0 ) NEW_LINE DEDENT DEDENT DEDENT menu . append ( ChoiceEntryComponent ( " menu " , ( _ ( " Configuration . . . " ) , self . openSetup ) ) ) NEW_LINE self [ " menu " ] = ChoiceList ( menu ) NEW_LINE DEDENT
def set3DMode ( self , value ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE if config . plugins . OSD3DSetup . mode . value == " auto " and ( playingref and playingref == self . csel . getCurrentSelection ( ) ) : NEW_LINE INDENT from Plugins . SystemPlugins . OSD3DSetup . plugin import applySettings NEW_LINE applySettings ( value and " sidebyside " or config . plugins . OSD3DSetup . mode . value ) NEW_LINE DEDENT DEDENT
def addDedicated3DFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . addFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_IS_DEDICATED_3D ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . set3DMode ( True ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def removeDedicated3DFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_IS_DEDICATED_3D ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . set3DMode ( False ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def addHideVBIFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . addFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_HIDE_VBI ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE Screens . InfoBar . InfoBar . instance . showHideVBI ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def removeHideVBIFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( eServiceReference ( self . csel . getCurrentSelection ( ) . toString ( ) ) , FLAG_HIDE_VBI ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE Screens . InfoBar . InfoBar . instance . showHideVBI ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def isProtected ( self ) : NEW_LINE INDENT return self . csel . protectContextMenu and config . ParentalControl . setuppinactive . value and config . ParentalControl . config_sections . context_menus . value NEW_LINE DEDENT
def protectResult ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . csel . protectContextMenu = False NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT
def addServiceToBouquetOrAlternative ( self ) : NEW_LINE INDENT if self . addFunction : NEW_LINE INDENT self . addFunction ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def getCurrentSelectionName ( self ) : NEW_LINE INDENT cur = self . csel . getCurrentSelection ( ) NEW_LINE if cur and cur . valid ( ) : NEW_LINE INDENT name = eServiceCenter . getInstance ( ) . info ( cur ) . getName ( cur ) or ServiceReference ( cur ) . getServiceName ( ) or " " NEW_LINE name = name . replace ( ' \xc2\x86' , ' ' ) . replace ( ' \xc2\x87' , ' ' ) NEW_LINE return name NEW_LINE DEDENT return " " NEW_LINE DEDENT
def removeEntry ( self ) : NEW_LINE INDENT if self . removeFunction and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT if self . csel . confirmRemove : NEW_LINE INDENT list = [ ( _ ( " yes " ) , True ) , ( _ ( " no " ) , False ) , ( _ ( " yes " ) + " ▁ " + _ ( " and ▁ never ▁ ask ▁ again ▁ this ▁ session ▁ again " ) , " never " ) ] NEW_LINE self . session . openWithCallback ( self . removeFunction , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ this ▁ entry ? " ) + " \n % s " % self . getCurrentSelectionName ( ) , list = list ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeFunction ( True ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def removeCurrentService ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . csel . confirmRemove = False NEW_LINE DEDENT self . csel . removeCurrentService ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT
def removeSatelliteService ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . csel . confirmRemove = False NEW_LINE DEDENT self . csel . removeSatelliteService ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT
def removeBouquet ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . csel . removeBouquet ( ) NEW_LINE eDVBDB . getInstance ( ) . reloadBouquets ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT
def purgeDeletedBouquets ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . purgeDeletedBouquetsCallback , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ purge ▁ all ▁ deleted ▁ userbouquets ? " ) ) NEW_LINE DEDENT
def playMain ( self ) : NEW_LINE INDENT sel = self . csel . getCurrentSelection ( ) NEW_LINE if sel and sel . valid ( ) and self . csel . dopipzap and ( not self . parentalControlEnabled or self . parentalControl . getProtectionLevel ( self . csel . getCurrentSelection ( ) . toCompareString ( ) ) == - 1 ) : NEW_LINE INDENT self . csel . zap ( ) NEW_LINE self . csel . setCurrentSelection ( sel ) NEW_LINE self . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def okbuttonClick ( self ) : NEW_LINE INDENT self [ " menu " ] . getCurrent ( ) [ 0 ] [ 1 ] ( ) NEW_LINE DEDENT
def openSetup ( self ) : NEW_LINE INDENT from Screens . Setup import Setup NEW_LINE self . session . openWithCallback ( self . cancelClick , Setup , " userinterface " ) NEW_LINE DEDENT
def cancelClick ( self , dummy = False ) : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT
def showServiceInformations ( self ) : NEW_LINE INDENT current = self . csel . getCurrentSelection ( ) NEW_LINE if current . flags & eServiceReference . isGroup : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref and playingref == current : NEW_LINE INDENT current = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current = eServiceReference ( GetWithAlternative ( current . toString ( ) ) ) NEW_LINE DEDENT DEDENT self . session . open ( ServiceInfo , current ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def setStartupService ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . setStartupServiceCallback , MessageBox , _ ( " Set ▁ startup ▁ service " ) , list = [ ( _ ( " Only ▁ on ▁ startup " ) , " startup " ) , ( _ ( " Also ▁ on ▁ standby " ) , " standby " ) ] ) NEW_LINE DEDENT
def setStartupServiceCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT config . servicelist . startupservice . value = self . csel . getCurrentSelection ( ) . toString ( ) NEW_LINE path = ' ; ' . join ( [ i . toString ( ) for i in self . csel . servicePath ] ) NEW_LINE config . servicelist . startuproot . value = path NEW_LINE config . servicelist . startupmode . value = config . servicelist . lastmode . value NEW_LINE config . servicelist . startupservice_onstandby . value = answer == " standby " NEW_LINE config . servicelist . save ( ) NEW_LINE configfile . save ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT DEDENT
def unsetStartupService ( self ) : NEW_LINE INDENT config . servicelist . startupservice . value = ' ' NEW_LINE config . servicelist . startupservice_onstandby . value = False NEW_LINE config . servicelist . save ( ) NEW_LINE configfile . save ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def showBouquetInputBox ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . bouquetInputCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ a ▁ name ▁ for ▁ the ▁ new ▁ bouquet " ) , text = " bouquetname " , maxSize = False , visible_width = 56 , type = Input . TEXT ) NEW_LINE DEDENT
def bouquetInputCallback ( self , bouquet ) : NEW_LINE INDENT if bouquet is not None : NEW_LINE INDENT self . csel . addBouquet ( bouquet , None ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT
def addParentalProtection ( self , service ) : NEW_LINE INDENT self . parentalControl . protectService ( service . toCompareString ( ) ) NEW_LINE if config . ParentalControl . hideBlacklist . value and not self . parentalControl . sessionPinCached : NEW_LINE INDENT self . csel . servicelist . resetRoot ( ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT
def removeParentalProtection ( self , service ) : NEW_LINE INDENT self . session . openWithCallback ( boundFunction ( self . pinEntered , service . toCompareString ( ) ) , PinInput , pinList = [ config . ParentalControl . servicepin [ 0 ] . value ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Enter ▁ the ▁ service ▁ pin " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) NEW_LINE DEDENT
def pinEntered ( self , service , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . parentalControl . unProtectService ( service ) NEW_LINE self . close ( ) NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT
def unhideParentalServices ( self ) : NEW_LINE INDENT if self . csel . protectContextMenu : NEW_LINE INDENT self . session . openWithCallback ( self . unhideParentalServicesCallback , PinInput , pinList = [ config . ParentalControl . servicepin [ 0 ] . value ] , triesEntry = config . ParentalControl . retries . servicepin , title = _ ( " Enter ▁ the ▁ service ▁ pin " ) , windowTitle = _ ( " Enter ▁ pin ▁ code " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . unhideParentalServicesCallback ( True ) NEW_LINE DEDENT DEDENT
def unhideParentalServicesCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT service = self . csel . servicelist . getCurrent ( ) NEW_LINE self . parentalControl . setSessionPinCached ( ) NEW_LINE self . parentalControl . hideBlacklist ( ) NEW_LINE self . csel . servicelist . resetRoot ( ) NEW_LINE self . csel . servicelist . setCurrent ( service ) NEW_LINE self . close ( ) NEW_LINE DEDENT elif answer is not None : NEW_LINE INDENT self . session . openWithCallback ( self . close , MessageBox , _ ( " The ▁ pin ▁ code ▁ you ▁ entered ▁ is ▁ wrong . " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT
def showServiceInPiP ( self ) : NEW_LINE INDENT if self . csel . dopipzap or ( self . parentalControlEnabled and not self . parentalControl . getProtectionLevel ( self . csel . getCurrentSelection ( ) . toCompareString ( ) ) == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if self . session . pipshown : NEW_LINE INDENT del self . session . pip NEW_LINE DEDENT self . session . pip = self . session . instantiateDialog ( PictureInPicture ) NEW_LINE self . session . pip . show ( ) NEW_LINE newservice = self . csel . servicelist . getCurrent ( ) NEW_LINE currentBouquet = self . csel . servicelist and self . csel . servicelist . getRoot ( ) NEW_LINE if newservice and newservice . valid ( ) : NEW_LINE INDENT if self . session . pip . playService ( newservice ) : NEW_LINE INDENT self . session . pipshown = True NEW_LINE self . session . pip . servicePath = self . csel . getCurrentServicePath ( ) NEW_LINE self . session . pip . servicePath [ 1 ] = currentBouquet NEW_LINE self . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . session . pipshown = False NEW_LINE del self . session . pip NEW_LINE self . session . openWithCallback ( self . close , MessageBox , _ ( " Could ▁ not ▁ open ▁ Picture ▁ in ▁ Picture " ) , MessageBox . TYPE_ERROR ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def addServiceToBouquetSelected ( self ) : NEW_LINE INDENT bouquets = self . csel . getBouquetList ( ) NEW_LINE if bouquets is None : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = len ( bouquets ) NEW_LINE DEDENT if cnt > 1 : # ▁ show ▁ bouquet ▁ list ENDCOM NEW_LINE INDENT self . bsel = self . session . openWithCallback ( self . bouquetSelClosed , BouquetSelector , bouquets , self . addCurrentServiceToBouquet ) NEW_LINE DEDENT elif cnt == 1 : # ▁ add ▁ to ▁ only ▁ one ▁ existing ▁ bouquet ENDCOM NEW_LINE INDENT self . addCurrentServiceToBouquet ( bouquets [ 0 ] [ 1 ] , closeBouquetSelection = False ) NEW_LINE DEDENT DEDENT
def bouquetSelClosed ( self , recursive ) : NEW_LINE INDENT self . bsel = None NEW_LINE if recursive : NEW_LINE INDENT self . close ( False ) NEW_LINE DEDENT DEDENT
def removeSatelliteServices ( self ) : NEW_LINE INDENT self . csel . removeSatelliteServices ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def copyCurrentToBouquetList ( self ) : NEW_LINE INDENT self . csel . copyCurrentToBouquetList ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def showMarkerInputBox ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . markerInputCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ a ▁ name ▁ for ▁ the ▁ new ▁ marker " ) , text = " markername " , maxSize = False , visible_width = 56 , type = Input . TEXT ) NEW_LINE DEDENT
def markerInputCallback ( self , marker ) : NEW_LINE INDENT if marker is not None : NEW_LINE INDENT self . csel . addMarker ( marker ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT
def addCurrentServiceToBouquet ( self , dest , closeBouquetSelection = True ) : NEW_LINE INDENT self . csel . addServiceToBouquet ( dest ) NEW_LINE if self . bsel is not None : NEW_LINE INDENT self . bsel . close ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( closeBouquetSelection ) # ▁ close ▁ bouquet ▁ selection ENDCOM NEW_LINE DEDENT DEDENT
def renameEntry ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) and not self . csel . entry_marked : NEW_LINE INDENT self . csel . renameEntry ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def toggleMoveMode ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT self . csel . toggleMoveMode ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def toggleMoveModeSelect ( self ) : NEW_LINE INDENT if self . inBouquet and self . csel . servicelist . getCurrent ( ) and self . csel . servicelist . getCurrent ( ) . valid ( ) : NEW_LINE INDENT self . csel . toggleMoveMode ( True ) NEW_LINE self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def bouquetMarkStart ( self ) : NEW_LINE INDENT self . csel . startMarkedEdit ( EDIT_BOUQUET ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def bouquetMarkEnd ( self ) : NEW_LINE INDENT self . csel . endMarkedEdit ( abort = False ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def bouquetMarkAbort ( self ) : NEW_LINE INDENT self . csel . endMarkedEdit ( abort = True ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def removeNewFoundFlag ( self ) : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeFlag ( self . csel . getCurrentSelection ( ) , FLAG_SERVICE_NEW_FOUND ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def removeAllNewFoundFlags ( self ) : NEW_LINE INDENT curpath = self . csel . getCurrentSelection ( ) . getPath ( ) NEW_LINE idx = curpath . find ( " satellitePosition ▁ = = ▁ " ) NEW_LINE if idx != - 1 : NEW_LINE INDENT tmp = curpath [ idx + 21 : ] NEW_LINE idx = tmp . find ( ' ) ' ) NEW_LINE if idx != - 1 : NEW_LINE INDENT satpos = int ( tmp [ : idx ] ) NEW_LINE eDVBDB . getInstance ( ) . removeFlags ( FLAG_SERVICE_NEW_FOUND , - 1 , - 1 , - 1 , satpos ) NEW_LINE DEDENT DEDENT self . close ( ) NEW_LINE DEDENT
def editAlternativeServices ( self ) : NEW_LINE INDENT self . csel . startMarkedEdit ( EDIT_ALTERNATIVES ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def showAlternativeServices ( self ) : NEW_LINE INDENT self . csel [ " Service " ] . editmode = True NEW_LINE self . csel . enterPath ( self . csel . getCurrentSelection ( ) ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def removeAlternativeServices ( self ) : NEW_LINE INDENT self . csel . removeAlternativeServices ( ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def addAlternativeServices ( self ) : NEW_LINE INDENT self . csel . addAlternativeServices ( ) NEW_LINE self . csel . startMarkedEdit ( EDIT_ALTERNATIVES ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def findCurrentlyPlayed ( self ) : NEW_LINE INDENT sel = self . csel . getCurrentSelection ( ) NEW_LINE if sel and sel . valid ( ) and not self . csel . entry_marked : NEW_LINE INDENT currentPlayingService = ( hasattr ( self . csel , " dopipzap " ) and self . csel . dopipzap ) and self . session . pip . getCurrentService ( ) or self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE self . csel . servicelist . setCurrent ( currentPlayingService , adjust = False ) NEW_LINE if self . csel . getCurrentSelection ( ) != currentPlayingService : NEW_LINE INDENT self . csel . setCurrentSelection ( sel ) NEW_LINE DEDENT self . close ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def runPlugin ( self , plugin ) : NEW_LINE INDENT plugin ( session = self . session , service = self . csel . getCurrentSelection ( ) ) NEW_LINE self . close ( ) NEW_LINE DEDENT
def __init__ ( self ) : NEW_LINE INDENT self [ " Service " ] = self [ " ServiceEvent " ] = ServiceEvent ( ) NEW_LINE self [ " Event " ] = Event ( ) NEW_LINE self . servicelist . connectSelChanged ( self . __selectionChanged ) NEW_LINE self . timer = eTimer ( ) NEW_LINE self . timer . callback . append ( self . updateEventInfo ) NEW_LINE self . onShown . append ( self . __selectionChanged ) NEW_LINE DEDENT
def __selectionChanged ( self ) : NEW_LINE INDENT if self . execing : NEW_LINE INDENT self . timer . start ( 100 , True ) NEW_LINE DEDENT DEDENT
def updateEventInfo ( self ) : NEW_LINE INDENT cur = self . getCurrentSelection ( ) NEW_LINE service = self [ " Service " ] NEW_LINE service . newService ( cur ) NEW_LINE self [ " Event " ] . newEvent ( service . event ) NEW_LINE DEDENT
def __init__ ( self ) : NEW_LINE INDENT self . hotkeys = [ ( " Info ▁ ( EPG ) " , " info " , " Infobar / openEventView " ) , ( " Info ▁ ( EPG ) " + " ▁ " + _ ( " long " ) , " info _ long " , " Infobar / showEventInfoPlugins " ) , ( " Epg / Guide " , " epg " , " Plugins / Extensions / GraphMultiEPG / 1" ) , ( " Epg / Guide " + " ▁ " + _ ( " long " ) , " epg _ long " , " Infobar / showEventInfoPlugins " ) ] NEW_LINE self [ " ChannelSelectEPGActions " ] = hotkeyActionMap ( [ " ChannelSelectEPGActions " ] , dict ( ( x [ 1 ] , self . hotkeyGlobal ) for x in self . hotkeys ) ) NEW_LINE self . eventViewEPG = self . start_bouquet = self . epg_bouquet = None NEW_LINE self . currentSavedPath = [ ] NEW_LINE DEDENT
def getKeyFunctions ( self , key ) : NEW_LINE INDENT selection = eval ( " config . misc . hotkey . " + key + " . value . split ( ' , ' ) " ) NEW_LINE selected = [ ] NEW_LINE for x in selection : NEW_LINE INDENT function = list ( function for function in getHotkeyFunctions ( ) if function [ 1 ] == x and function [ 2 ] == " EPG " ) NEW_LINE if function : NEW_LINE INDENT selected . append ( function [ 0 ] ) NEW_LINE DEDENT DEDENT return selected NEW_LINE DEDENT
def runPlugin ( self , plugin ) : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . runPlugin ( plugin ) NEW_LINE DEDENT
def getEPGPluginList ( self , getAll = False ) : NEW_LINE INDENT pluginlist = [ ( p . name , boundFunction ( self . runPlugin , p ) , p . path ) for p in plugins . getPlugins ( where = PluginDescriptor . WHERE_EVENTINFO ) if ' selectedevent ' not in p . __call__ . func_code . co_varnames ] or [ ] NEW_LINE from Components . ServiceEventTracker import InfoBarCount NEW_LINE if getAll or InfoBarCount == 1 : NEW_LINE INDENT pluginlist . append ( ( _ ( " Show ▁ EPG ▁ for ▁ current ▁ channel . . . " ) , self . openSingleServiceEPG , " current _ channel " ) ) NEW_LINE DEDENT pluginlist . append ( ( _ ( " Multi ▁ EPG " ) , self . openMultiServiceEPG , " multi _ epg " ) ) NEW_LINE pluginlist . append ( ( _ ( " Current ▁ event ▁ EPG " ) , self . openEventView , " event _ epg " ) ) NEW_LINE return pluginlist NEW_LINE DEDENT
def showEventInfoPlugins ( self ) : NEW_LINE INDENT pluginlist = self . getEPGPluginList ( ) NEW_LINE if pluginlist : NEW_LINE INDENT self . session . openWithCallback ( self . EventInfoPluginChosen , ChoiceBox , title = _ ( " Please ▁ choose ▁ an ▁ extension . . . " ) , list = pluginlist , skin_name = " EPGExtensionsList " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . openSingleServiceEPG ( ) NEW_LINE DEDENT DEDENT
def EventInfoPluginChosen ( self , answer ) : NEW_LINE INDENT if answer is not None : NEW_LINE INDENT answer [ 1 ] ( ) NEW_LINE DEDENT DEDENT
def openEventView ( self ) : NEW_LINE INDENT epglist = [ ] NEW_LINE self . epglist = epglist NEW_LINE ref = self . getCurrentSelection ( ) NEW_LINE epg = eEPGCache . getInstance ( ) NEW_LINE now_event = epg . lookupEventTime ( ref , - 1 , 0 ) NEW_LINE if now_event : NEW_LINE INDENT epglist . append ( now_event ) NEW_LINE next_event = epg . lookupEventTime ( ref , - 1 , 1 ) NEW_LINE if next_event : NEW_LINE INDENT epglist . append ( next_event ) NEW_LINE DEDENT DEDENT if epglist : NEW_LINE INDENT self . eventViewEPG = self . session . openWithCallback ( self . eventViewEPGClosed , EventViewEPGSelect , epglist [ 0 ] , ServiceReference ( ref ) , self . eventViewEPGCallback , self . openSingleServiceEPG , self . openMultiServiceEPG , self . openSimilarList ) NEW_LINE DEDENT DEDENT
def eventViewEPGCallback ( self , setEvent , setService , val ) : NEW_LINE INDENT epglist = self . epglist NEW_LINE if len ( epglist ) > 1 : NEW_LINE INDENT tmp = epglist [ 0 ] NEW_LINE epglist [ 0 ] = epglist [ 1 ] NEW_LINE epglist [ 1 ] = tmp NEW_LINE setEvent ( epglist [ 0 ] ) NEW_LINE DEDENT DEDENT
def eventViewEPGClosed ( self , ret = False ) : NEW_LINE INDENT self . eventViewEPG = None NEW_LINE if ret : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT
def openMultiServiceEPG ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref : NEW_LINE INDENT self . start_bouquet = self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE self . savedService = ref NEW_LINE self . currentSavedPath = self . servicePath [ : ] NEW_LINE services = self . getServicesList ( self . servicelist . getRoot ( ) ) NEW_LINE self . session . openWithCallback ( self . SingleMultiEPGClosed , EPGSelection , services , self . zapToService , None , bouquetChangeCB = self . changeBouquetForMultiEPG ) NEW_LINE DEDENT DEDENT
def openSingleServiceEPG ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref : NEW_LINE INDENT self . start_bouquet = self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE self . savedService = ref NEW_LINE self . currentSavedPath = self . servicePath [ : ] NEW_LINE self . session . openWithCallback ( self . SingleMultiEPGClosed , EPGSelection , ref , self . zapToService , serviceChangeCB = self . changeServiceCB , bouquetChangeCB = self . changeBouquetForSingleEPG ) NEW_LINE DEDENT DEDENT
def openSimilarList ( self , eventid , refstr ) : NEW_LINE INDENT self . session . open ( EPGSelection , refstr , None , eventid ) NEW_LINE DEDENT
def getServicesList ( self , root ) : NEW_LINE INDENT services = [ ] NEW_LINE servicelist = root and eServiceCenter . getInstance ( ) . list ( root ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT service = servicelist . getNext ( ) NEW_LINE if not service . valid ( ) : NEW_LINE INDENT break NEW_LINE DEDENT if service . flags & ( eServiceReference . isDirectory | eServiceReference . isMarker ) : NEW_LINE INDENT continue NEW_LINE DEDENT services . append ( ServiceReference ( service ) ) NEW_LINE DEDENT DEDENT return services NEW_LINE DEDENT
def SingleMultiEPGClosed ( self , ret = False ) : NEW_LINE INDENT if ret : NEW_LINE INDENT service = self . getCurrentSelection ( ) NEW_LINE if self . eventViewEPG : NEW_LINE INDENT self . eventViewEPG . close ( service ) NEW_LINE DEDENT elif service is not None : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . start_bouquet != self . epg_bouquet and len ( self . currentSavedPath ) > 0 : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( self . bouquet_root ) NEW_LINE self . epg_bouquet = self . start_bouquet NEW_LINE self . enterPath ( self . epg_bouquet ) NEW_LINE DEDENT self . setCurrentSelection ( self . savedService ) NEW_LINE DEDENT DEDENT
def changeBouquetForSingleEPG ( self , direction , epg ) : NEW_LINE INDENT if config . usage . multibouquet . value : NEW_LINE INDENT inBouquet = self . getMutableList ( ) is not None NEW_LINE if inBouquet and len ( self . servicePath ) > 1 : NEW_LINE INDENT self . pathUp ( ) NEW_LINE if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( cur ) NEW_LINE self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE epg . setService ( ServiceReference ( self . getCurrentSelection ( ) ) ) NEW_LINE DEDENT DEDENT DEDENT
def changeBouquetForMultiEPG ( self , direction , epg ) : NEW_LINE INDENT if config . usage . multibouquet . value : NEW_LINE INDENT inBouquet = self . getMutableList ( ) is not None NEW_LINE if inBouquet and len ( self . servicePath ) > 1 : NEW_LINE INDENT self . pathUp ( ) NEW_LINE if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( cur ) NEW_LINE self . epg_bouquet = self . servicelist . getRoot ( ) NEW_LINE services = self . getServicesList ( self . epg_bouquet ) NEW_LINE epg . setServices ( services ) NEW_LINE DEDENT DEDENT DEDENT
def changeServiceCB ( self , direction , epg ) : NEW_LINE INDENT beg = self . getCurrentSelection ( ) NEW_LINE while True : NEW_LINE INDENT if direction > 0 : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT cur = self . getCurrentSelection ( ) NEW_LINE if cur == beg or not ( cur . flags & eServiceReference . isMarker ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT epg . setService ( ServiceReference ( self . getCurrentSelection ( ) ) ) NEW_LINE DEDENT
def zapToService ( self , service , preview = False , zapback = False ) : NEW_LINE INDENT if self . startServiceRef is None : NEW_LINE INDENT self . startServiceRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE DEDENT if service is not None : NEW_LINE INDENT if self . servicelist . getRoot ( ) != self . epg_bouquet : NEW_LINE INDENT self . servicelist . clearPath ( ) NEW_LINE if self . servicelist . bouquet_root != self . epg_bouquet : NEW_LINE INDENT self . servicelist . enterPath ( self . servicelist . bouquet_root ) NEW_LINE DEDENT self . servicelist . enterPath ( self . epg_bouquet ) NEW_LINE DEDENT self . servicelist . setCurrent ( service ) NEW_LINE DEDENT if not zapback or preview : NEW_LINE INDENT self . zap ( enable_pipzap = True ) NEW_LINE DEDENT if ( self . dopipzap or zapback ) and not preview : NEW_LINE INDENT self . zapBack ( ) NEW_LINE DEDENT if not preview : NEW_LINE INDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT
def __init__ ( self ) : NEW_LINE INDENT self . entry_marked = False NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE self . mutableList = None NEW_LINE self . __marked = [ ] NEW_LINE self . saved_title = None NEW_LINE self . saved_root = None NEW_LINE self . current_ref = None NEW_LINE self . editMode = False NEW_LINE self . confirmRemove = True NEW_LINE class ChannelSelectionEditActionMap ( ActionMap ) : NEW_LINE INDENT def __init__ ( self , csel , contexts = [ ] , actions = { } , prio = 0 ) : NEW_LINE INDENT ActionMap . __init__ ( self , contexts , actions , prio ) NEW_LINE self . csel = csel NEW_LINE DEDENT def action ( self , contexts , action ) : NEW_LINE INDENT if action == " cancel " : NEW_LINE INDENT self . csel . handleEditCancel ( ) NEW_LINE return 0 # ▁ fall - trough ENDCOM NEW_LINE DEDENT elif action == " ok " : NEW_LINE INDENT return 0 # ▁ fall - trough ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT return ActionMap . action ( self , contexts , action ) NEW_LINE DEDENT DEDENT DEDENT self [ " ChannelSelectEditActions " ] = ChannelSelectionEditActionMap ( self , [ " ChannelSelectEditActions " , " OkCancelActions " ] , { " contextMenu " : self . doContext , } ) NEW_LINE DEDENT
def getMutableList ( self , root = eServiceReference ( ) ) : NEW_LINE INDENT if not self . mutableList is None : NEW_LINE INDENT return self . mutableList NEW_LINE DEDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE if not root . valid ( ) : NEW_LINE INDENT root = self . getRoot ( ) NEW_LINE DEDENT list = root and serviceHandler . list ( root ) NEW_LINE if list is not None : NEW_LINE INDENT return list . startEdit ( ) NEW_LINE DEDENT return None NEW_LINE DEDENT
def buildBouquetID ( self , name ) : NEW_LINE INDENT name = unicodedata . normalize ( ' NFKD ' , unicode ( name , ' utf _ 8' , errors = ' ignore ' ) ) . encode ( ' ASCII ' , ' ignore ' ) . translate ( None , ' < > : " / \ | ? * ( ) ▁ ' ) NEW_LINE while os . path . isfile ( ( self . mode == MODE_TV and " / etc / enigma2 / userbouquet . % s . tv " or " / etc / enigma2 / userbouquet . % s . radio " ) % name ) : NEW_LINE INDENT name = name . rsplit ( " _ " , 1 ) NEW_LINE name = " _ " . join ( ( name [ 0 ] , len ( name ) == 2 and name [ 1 ] . isdigit ( ) and str ( int ( name [ 1 ] ) + 1 ) or "1" ) ) NEW_LINE DEDENT return name NEW_LINE DEDENT
def renameEntry ( self ) : NEW_LINE INDENT self . editMode = True NEW_LINE cur = self . getCurrentSelection ( ) NEW_LINE if cur and cur . valid ( ) : NEW_LINE INDENT name = eServiceCenter . getInstance ( ) . info ( cur ) . getName ( cur ) or ServiceReference ( cur ) . getServiceName ( ) or " " NEW_LINE name = name . replace ( ' \xc2\x86' , ' ' ) . replace ( ' \xc2\x87' , ' ' ) NEW_LINE if name : NEW_LINE INDENT self . session . openWithCallback ( self . renameEntryCallback , VirtualKeyBoard , title = _ ( " Please ▁ enter ▁ new ▁ name : " ) , text = name ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def renameEntryCallback ( self , name ) : NEW_LINE INDENT if name : NEW_LINE INDENT mutableList = self . getMutableList ( ) NEW_LINE if mutableList : NEW_LINE INDENT current = self . servicelist . getCurrent ( ) NEW_LINE current . setName ( name ) NEW_LINE index = self . servicelist . getCurrentIndex ( ) NEW_LINE mutableList . removeService ( current , False ) NEW_LINE mutableList . addService ( current ) NEW_LINE mutableList . moveService ( current , index ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE self . servicelist . addService ( current , True ) NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE if not self . servicelist . atEnd ( ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def addMarker ( self , name ) : NEW_LINE INDENT current = self . servicelist . getCurrent ( ) NEW_LINE mutableList = self . getMutableList ( ) NEW_LINE cnt = 0 NEW_LINE while mutableList : NEW_LINE INDENT str = '1:64 : % d : 0:0:0:0:0:0:0 : : % s ' % ( cnt , name ) NEW_LINE ref = eServiceReference ( str ) NEW_LINE if current and current . valid ( ) : NEW_LINE INDENT if not mutableList . addService ( ref , current ) : NEW_LINE INDENT self . servicelist . addService ( ref , True ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE break NEW_LINE DEDENT DEDENT elif not mutableList . addService ( ref ) : NEW_LINE INDENT self . servicelist . addService ( ref , True ) NEW_LINE mutableList . flushChanges ( ) NEW_LINE break NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT DEDENT
def copyCurrentToBouquetList ( self ) : NEW_LINE INDENT provider = ServiceReference ( self . getCurrentSelection ( ) ) NEW_LINE providerName = provider . getServiceName ( ) NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE services = serviceHandler . list ( provider . ref ) NEW_LINE self . addBouquet ( providerName , services and services . getContent ( ' R ' , True ) ) NEW_LINE DEDENT
def removeSatelliteService ( self ) : NEW_LINE INDENT current = self . getCurrentSelection ( ) NEW_LINE eDVBDB . getInstance ( ) . removeService ( current ) NEW_LINE refreshServiceList ( ) NEW_LINE if not self . atEnd ( ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT DEDENT
def removeSatelliteServices ( self ) : NEW_LINE INDENT current = self . getCurrentSelection ( ) NEW_LINE unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ cable ▁ services ? " ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ terrestrial ▁ services ? " ) NEW_LINE DEDENT else : NEW_LINE INDENT if unsigned_orbpos > 1800 : NEW_LINE INDENT unsigned_orbpos = 3600 - unsigned_orbpos NEW_LINE direction = _ ( " W " ) NEW_LINE DEDENT else : NEW_LINE INDENT direction = _ ( " E " ) NEW_LINE DEDENT messageText = _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ all ▁ % d . % d % s % s ▁ services ? " ) % ( unsigned_orbpos / 10 , unsigned_orbpos % 10 , " \xc2\xb0" , direction ) NEW_LINE DEDENT self . session . openWithCallback ( self . removeSatelliteServicesCallback , MessageBox , messageText ) NEW_LINE DEDENT
def removeSatelliteServicesCallback ( self , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT currentIndex = self . servicelist . getCurrentIndex ( ) NEW_LINE current = self . getCurrentSelection ( ) NEW_LINE unsigned_orbpos = current . getUnsignedData ( 4 ) >> 16 NEW_LINE if unsigned_orbpos == 0xFFFF : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeServices ( int ( "0xFFFF0000" , 16 ) - 0x100000000 ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : NEW_LINE INDENT eDVBDB . getInstance ( ) . removeServices ( int ( "0xEEEE0000" , 16 ) - 0x100000000 ) NEW_LINE DEDENT else : NEW_LINE INDENT curpath = current . getPath ( ) NEW_LINE idx = curpath . find ( " satellitePosition ▁ = = ▁ " ) NEW_LINE if idx != - 1 : NEW_LINE INDENT tmp = curpath [ idx + 21 : ] NEW_LINE idx = tmp . find ( ' ) ' ) NEW_LINE if idx != - 1 : NEW_LINE INDENT satpos = int ( tmp [ : idx ] ) NEW_LINE eDVBDB . getInstance ( ) . removeServices ( - 1 , - 1 , - 1 , satpos ) NEW_LINE DEDENT DEDENT DEDENT refreshServiceList ( ) NEW_LINE if hasattr ( self , ' showSatellites ' ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE self . servicelist . moveToIndex ( currentIndex ) NEW_LINE if currentIndex != self . servicelist . getCurrentIndex ( ) : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . moveEnd ) NEW_LINE # ▁ multiple ▁ marked ▁ entry ▁ stuff ▁ ( ▁ edit ▁ mode , ▁ later ▁ multiepg ▁ selection ▁ ) ENDCOM DEDENT DEDENT DEDENT DEDENT
def startMarkedEdit ( self , type ) : NEW_LINE INDENT self . savedPath = self . servicePath [ : ] NEW_LINE if type == EDIT_ALTERNATIVES : NEW_LINE INDENT self . current_ref = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( self . current_ref ) NEW_LINE DEDENT self . mutableList = self . getMutableList ( ) NEW_LINE # ▁ add ▁ all ▁ services ▁ from ▁ the ▁ current ▁ list ▁ to ▁ internal ▁ marked ▁ set ▁ in ▁ listboxservicecontent ENDCOM self . clearMarks ( ) # ▁ this ▁ clears ▁ the ▁ internal ▁ marked ▁ set ▁ in ▁ the ▁ listboxservicecontent ENDCOM NEW_LINE self . saved_title = self . getTitle ( ) NEW_LINE pos = self . saved_title . find ( ' ) ' ) NEW_LINE new_title = self . saved_title [ : pos + 1 ] NEW_LINE if type == EDIT_ALTERNATIVES : NEW_LINE INDENT self . bouquet_mark_edit = EDIT_ALTERNATIVES NEW_LINE new_title += ' ▁ ' + _ ( " [ alternative ▁ edit ] " ) NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_mark_edit = EDIT_BOUQUET NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT new_title += ' ▁ ' + _ ( " [ bouquet ▁ edit ] " ) NEW_LINE DEDENT else : NEW_LINE INDENT new_title += ' ▁ ' + _ ( " [ favourite ▁ edit ] " ) NEW_LINE DEDENT DEDENT self . setTitle ( new_title ) NEW_LINE self . __marked = self . servicelist . getRootServices ( ) NEW_LINE for x in self . __marked : NEW_LINE INDENT self . servicelist . addMarked ( eServiceReference ( x ) ) NEW_LINE DEDENT self [ " Service " ] . editmode = True NEW_LINE DEDENT
def endMarkedEdit ( self , abort ) : NEW_LINE INDENT if not abort and self . mutableList is not None : NEW_LINE INDENT new_marked = set ( self . servicelist . getMarked ( ) ) NEW_LINE old_marked = set ( self . __marked ) NEW_LINE removed = old_marked - new_marked NEW_LINE added = new_marked - old_marked NEW_LINE changed = False NEW_LINE for x in removed : NEW_LINE INDENT changed = True NEW_LINE self . mutableList . removeService ( eServiceReference ( x ) ) NEW_LINE DEDENT for x in added : NEW_LINE INDENT changed = True NEW_LINE self . mutableList . addService ( eServiceReference ( x ) ) NEW_LINE DEDENT if changed : NEW_LINE INDENT if self . bouquet_mark_edit == EDIT_ALTERNATIVES and not new_marked and self . __marked : NEW_LINE INDENT self . mutableList . addService ( eServiceReference ( self . __marked [ 0 ] ) ) NEW_LINE DEDENT self . mutableList . flushChanges ( ) NEW_LINE DEDENT DEDENT self . __marked = [ ] NEW_LINE self . clearMarks ( ) NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE self . mutableList = None NEW_LINE self . setTitle ( self . saved_title ) NEW_LINE self . saved_title = None NEW_LINE # ▁ self . servicePath ▁ is ▁ just ▁ a ▁ reference ▁ to ▁ servicePathTv ▁ or ▁ Radio . . . ENDCOM # ▁ so ▁ we ▁ never ▁ ever ▁ do ▁ use ▁ the ▁ asignment ▁ operator ▁ in ▁ self . servicePath ENDCOM del self . servicePath [ : ] # ▁ remove ▁ all ▁ elements ENDCOM NEW_LINE self . servicePath += self . savedPath # ▁ add ▁ saved ▁ elements ENDCOM NEW_LINE del self . savedPath NEW_LINE self . setRoot ( self . servicePath [ - 1 ] ) NEW_LINE if self . current_ref : NEW_LINE INDENT self . setCurrentSelection ( self . current_ref ) NEW_LINE self . current_ref = None NEW_LINE DEDENT DEDENT
def clearMarks ( self ) : NEW_LINE INDENT self . servicelist . clearMarks ( ) NEW_LINE DEDENT
def doMark ( self ) : NEW_LINE INDENT ref = self . servicelist . getCurrent ( ) NEW_LINE if self . servicelist . isMarked ( ref ) : NEW_LINE INDENT self . servicelist . removeMarked ( ref ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . addMarked ( ref ) NEW_LINE DEDENT DEDENT
def removeCurrentEntry ( self , bouquet = False ) : NEW_LINE INDENT if self . confirmRemove : NEW_LINE INDENT list = [ ( _ ( " yes " ) , True ) , ( _ ( " no " ) , False ) , ( _ ( " yes " ) + " ▁ " + _ ( " and ▁ never ▁ ask ▁ again ▁ this ▁ session ▁ again " ) , " never " ) ] NEW_LINE self . session . openWithCallback ( boundFunction ( self . removeCurrentEntryCallback , bouquet ) , MessageBox , _ ( " Are ▁ you ▁ sure ▁ to ▁ remove ▁ this ▁ entry ? " ) , list = list ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeCurrentEntryCallback ( bouquet , True ) NEW_LINE DEDENT DEDENT
def removeCurrentEntryCallback ( self , bouquet , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT if answer == " never " : NEW_LINE INDENT self . confirmRemove = False NEW_LINE DEDENT if bouquet : NEW_LINE INDENT self . removeBouquet ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . removeCurrentService ( ) NEW_LINE DEDENT DEDENT DEDENT
def removeCurrentService ( self , bouquet = False ) : NEW_LINE INDENT self . editMode = True NEW_LINE ref = self . servicelist . getCurrent ( ) NEW_LINE mutableList = self . getMutableList ( ) NEW_LINE if ref . valid ( ) and mutableList is not None : NEW_LINE INDENT if not mutableList . removeService ( ref ) : NEW_LINE INDENT mutableList . flushChanges ( ) # FIXME ▁ dont ▁ flush ▁ on ▁ each ▁ single ▁ removed ▁ service ENDCOM NEW_LINE self . servicelist . removeCurrent ( ) NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if not bouquet and playingref and ref == playingref : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def addServiceToBouquet ( self , dest , service = None ) : NEW_LINE INDENT mutableList = self . getMutableList ( dest ) NEW_LINE if not mutableList is None : NEW_LINE INDENT if service is None : # use ▁ current ▁ selected ▁ service ENDCOM NEW_LINE INDENT service = self . servicelist . getCurrent ( ) NEW_LINE DEDENT if not mutableList . addService ( service ) : NEW_LINE INDENT mutableList . flushChanges ( ) NEW_LINE # ▁ do ▁ some ▁ voodoo ▁ to ▁ check ▁ if ▁ current _ root ▁ is ▁ equal ▁ to ▁ dest ENDCOM cur_root = self . getRoot ( ) ; NEW_LINE str1 = cur_root and cur_root . toString ( ) or - 1 NEW_LINE str2 = dest . toString ( ) NEW_LINE pos1 = str1 . find ( " FROM ▁ BOUQUET " ) NEW_LINE pos2 = str2 . find ( " FROM ▁ BOUQUET " ) NEW_LINE if pos1 != - 1 and pos2 != - 1 and str1 [ pos1 : ] == str2 [ pos2 : ] : NEW_LINE INDENT self . servicelist . addService ( service ) NEW_LINE DEDENT self . servicelist . resetRoot ( ) NEW_LINE DEDENT DEDENT DEDENT
def toggleMoveMode ( self , select = False ) : NEW_LINE INDENT self . editMode = True NEW_LINE if self . movemode : NEW_LINE INDENT if self . entry_marked : NEW_LINE INDENT self . toggleMoveMarked ( ) # ▁ unmark ▁ current ▁ entry ENDCOM NEW_LINE DEDENT self . movemode = False NEW_LINE self . mutableList . flushChanges ( ) # ▁ FIXME ▁ add ▁ check ▁ if ▁ changes ▁ was ▁ made ENDCOM NEW_LINE self . mutableList = None NEW_LINE self . setTitle ( self . saved_title ) NEW_LINE self . saved_title = None NEW_LINE self . servicelist . resetRoot ( ) NEW_LINE self . servicelist . l . setHideNumberMarker ( config . usage . hide_number_markers . value ) NEW_LINE self . setCurrentSelection ( self . servicelist . getCurrent ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . mutableList = self . getMutableList ( ) NEW_LINE self . movemode = True NEW_LINE select and self . toggleMoveMarked ( ) NEW_LINE self . saved_title = self . getTitle ( ) NEW_LINE pos = self . saved_title . find ( ' ) ' ) NEW_LINE self . setTitle ( self . saved_title [ : pos + 1 ] + ' ▁ ' + _ ( " [ move ▁ mode ] " ) + self . saved_title [ pos + 1 : ] ) ; NEW_LINE self . servicelist . l . setHideNumberMarker ( False ) NEW_LINE self . setCurrentSelection ( self . servicelist . getCurrent ( ) ) NEW_LINE DEDENT self [ " Service " ] . editmode = True NEW_LINE DEDENT
def handleEditCancel ( self ) : NEW_LINE INDENT if self . movemode : # movemode ▁ active ? ENDCOM NEW_LINE INDENT self . toggleMoveMode ( ) # ▁ disable ▁ move ▁ mode ENDCOM NEW_LINE DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT self . endMarkedEdit ( True ) # ▁ abort ▁ edit ▁ mode ENDCOM NEW_LINE DEDENT DEDENT
def toggleMoveMarked ( self ) : NEW_LINE INDENT if self . entry_marked : NEW_LINE INDENT self . servicelist . setCurrentMarked ( False ) NEW_LINE self . entry_marked = False NEW_LINE self . pathChangeDisabled = False # ▁ re - enable ▁ path ▁ change ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . setCurrentMarked ( True ) NEW_LINE self . entry_marked = True NEW_LINE self . pathChangeDisabled = True # ▁ no ▁ path ▁ change ▁ allowed ▁ in ▁ movemod ENDCOM NEW_LINE DEDENT DEDENT
def doContext ( self ) : NEW_LINE INDENT self . session . openWithCallback ( self . exitContext , ChannelContextMenu , self ) NEW_LINE DEDENT
def exitContext ( self , close = False ) : NEW_LINE INDENT if close : NEW_LINE INDENT self . cancel ( ) NEW_LINE DEDENT DEDENT
def __init__ ( self , session ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self . setScreenPathMode ( None ) NEW_LINE self [ " key _ red " ] = Button ( _ ( " All " ) ) NEW_LINE self [ " key _ green " ] = Button ( _ ( " Satellites " ) ) NEW_LINE self [ " key _ yellow " ] = Button ( _ ( " Provider " ) ) NEW_LINE self [ " key _ blue " ] = Button ( _ ( " Favourites " ) ) NEW_LINE self [ " list " ] = ServiceList ( self ) NEW_LINE self . servicelist = self [ " list " ] NEW_LINE self . numericalTextInput = NumericalTextInput ( handleTimeout = False ) NEW_LINE self . numericalTextInput . setUseableChars ( u ' 1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ ' ) NEW_LINE self . servicePathTV = [ ] NEW_LINE self . servicePathRadio = [ ] NEW_LINE self . servicePath = [ ] NEW_LINE self . history = [ ] NEW_LINE self . rootChanged = False NEW_LINE self . startRoot = None NEW_LINE self . selectionNumber = " " NEW_LINE self . clearNumberSelectionNumberTimer = eTimer ( ) NEW_LINE self . clearNumberSelectionNumberTimer . callback . append ( self . clearNumberSelectionNumber ) NEW_LINE self . protectContextMenu = True NEW_LINE self . mode = MODE_TV NEW_LINE self . dopipzap = False NEW_LINE self . pathChangeDisabled = False NEW_LINE self . movemode = False NEW_LINE self . showSatDetails = False NEW_LINE self [ " ChannelSelectBaseActions " ] = NumberActionMap ( [ " ChannelSelectBaseActions " , " NumberActions " , " InputAsciiActions " ] , { " showFavourites " : self . showFavourites , " showAllServices " : self . showAllServices , " showProviders " : self . showProviders , " showSatellites " : boundFunction ( self . showSatellites , changeMode = True ) , " nextBouquet " : self . nextBouquet , " prevBouquet " : self . prevBouquet , " nextMarker " : self . nextMarker , " prevMarker " : self . prevMarker , " gotAsciiCode " : self . keyAsciiCode , " keyLeft " : self . keyLeft , " keyRight " : self . keyRight , " keyRecord " : self . keyRecord , "1" : self . keyNumberGlobal , "2" : self . keyNumberGlobal , "3" : self . keyNumberGlobal , "4" : self . keyNumberGlobal , "5" : self . keyNumberGlobal , "6" : self . keyNumberGlobal , "7" : self . keyNumberGlobal , "8" : self . keyNumberGlobal , "9" : self . keyNumberGlobal , "0" : self . keyNumber0 } , - 2 ) NEW_LINE self . maintitle = _ ( " Channel ▁ selection " ) NEW_LINE self . recallBouquetMode ( ) NEW_LINE DEDENT
def getBouquetNumOffset ( self , bouquet ) : NEW_LINE INDENT if not config . usage . multibouquet . value : NEW_LINE INDENT return 0 NEW_LINE DEDENT str = bouquet . toString ( ) NEW_LINE offset = 0 NEW_LINE if ' userbouquet . ' in bouquet . toCompareString ( ) : NEW_LINE INDENT serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE servicelist = serviceHandler . list ( bouquet ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT serviceIterator = servicelist . getNext ( ) NEW_LINE if not serviceIterator . valid ( ) : # check ▁ if ▁ end ▁ of ▁ list ENDCOM NEW_LINE INDENT break NEW_LINE DEDENT number = serviceIterator . getChannelNum ( ) NEW_LINE if number > 0 : NEW_LINE INDENT offset = number - 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return offset NEW_LINE DEDENT
def recallBouquetMode ( self ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT self . service_types = service_types_tv NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT self . bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " bouquets . tv " ▁ ORDER ▁ BY ▁ bouquet ' NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_rootstr = ' % s ▁ FROM ▁ BOUQUET ▁ " userbouquet . favourites . tv " ▁ ORDER ▁ BY ▁ bouquet ' % ( self . service_types ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . service_types = service_types_radio NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT self . bouquet_rootstr = '1:7:1:0:0:0:0:0:0:0 : FROM ▁ BOUQUET ▁ " bouquets . radio " ▁ ORDER ▁ BY ▁ bouquet ' NEW_LINE DEDENT else : NEW_LINE INDENT self . bouquet_rootstr = ' % s ▁ FROM ▁ BOUQUET ▁ " userbouquet . favourites . radio " ▁ ORDER ▁ BY ▁ bouquet ' % ( self . service_types ) NEW_LINE DEDENT DEDENT self . bouquet_root = eServiceReference ( self . bouquet_rootstr ) NEW_LINE DEDENT
def setTvMode ( self ) : NEW_LINE INDENT self . mode = MODE_TV NEW_LINE self . servicePath = self . servicePathTV NEW_LINE self . recallBouquetMode ( ) NEW_LINE title = self . maintitle NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT title += _ ( " ▁ ( TV ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE DEDENT
def setRadioMode ( self ) : NEW_LINE INDENT self . mode = MODE_RADIO NEW_LINE self . servicePath = self . servicePathRadio NEW_LINE self . recallBouquetMode ( ) NEW_LINE title = self . maintitle NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT title += _ ( " ▁ ( Radio ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE DEDENT
def setRoot ( self , root , justSet = False ) : NEW_LINE INDENT if self . startRoot is None : NEW_LINE INDENT self . startRoot = self . getRoot ( ) NEW_LINE DEDENT path = root . getPath ( ) NEW_LINE isBouquet = ' FROM ▁ BOUQUET ' in path and ( root . flags & eServiceReference . isDirectory ) NEW_LINE inBouquetRootList = ' FROM ▁ BOUQUET ▁ " bouquets . ' in path # FIXME ▁ HACK ENDCOM NEW_LINE if not inBouquetRootList and isBouquet : NEW_LINE INDENT self . servicelist . setMode ( ServiceList . MODE_FAVOURITES ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . setMode ( ServiceList . MODE_NORMAL ) NEW_LINE DEDENT self . servicelist . setRoot ( root , justSet ) NEW_LINE self . rootChanged = True NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT
def removeModeStr ( self , str ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT pos = str . find ( _ ( " ▁ ( TV ) " ) ) NEW_LINE DEDENT else : NEW_LINE INDENT pos = str . find ( _ ( " ▁ ( Radio ) " ) ) NEW_LINE DEDENT if pos != - 1 : NEW_LINE INDENT return str [ : pos ] NEW_LINE DEDENT return str NEW_LINE DEDENT
def getServiceName ( self , ref ) : NEW_LINE INDENT str = self . removeModeStr ( ServiceReference ( ref ) . getServiceName ( ) ) NEW_LINE if ' bouquets ' in str . lower ( ) : NEW_LINE INDENT return _ ( " User ▁ - ▁ bouquets " ) NEW_LINE DEDENT if not str : NEW_LINE INDENT pathstr = ref . getPath ( ) NEW_LINE if ' FROM ▁ PROVIDERS ' in pathstr : NEW_LINE INDENT return _ ( " Provider " ) NEW_LINE DEDENT if ' FROM ▁ SATELLITES ' in pathstr : NEW_LINE INDENT return _ ( " Satellites " ) NEW_LINE DEDENT if ' ) ▁ ORDER ▁ BY ▁ name ' in pathstr : NEW_LINE INDENT return _ ( " All " ) NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT
def buildTitleString ( self ) : NEW_LINE INDENT titleStr = self . getTitle ( ) NEW_LINE pos = titleStr . find ( ' ] ' ) NEW_LINE if pos == - 1 : NEW_LINE INDENT pos = titleStr . find ( ' ) ' ) NEW_LINE DEDENT if pos != - 1 : NEW_LINE INDENT titleStr = titleStr [ : pos + 1 ] NEW_LINE Len = len ( self . servicePath ) NEW_LINE if Len > 0 : NEW_LINE INDENT base_ref = self . servicePath [ 0 ] NEW_LINE if Len > 1 : NEW_LINE INDENT end_ref = self . servicePath [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT end_ref = None NEW_LINE DEDENT nameStr = self . getServiceName ( base_ref ) NEW_LINE titleStr += ' ▁ - ▁ ' + nameStr NEW_LINE if end_ref is not None : NEW_LINE INDENT if Len > 2 : NEW_LINE INDENT titleStr += ' / . . / ' NEW_LINE DEDENT else : NEW_LINE INDENT titleStr += ' / ' NEW_LINE DEDENT nameStr = self . getServiceName ( end_ref ) NEW_LINE titleStr += nameStr NEW_LINE DEDENT self . setTitle ( titleStr ) NEW_LINE DEDENT DEDENT DEDENT
def moveUp ( self ) : NEW_LINE INDENT self . servicelist . moveUp ( ) NEW_LINE DEDENT
def moveDown ( self ) : NEW_LINE INDENT self . servicelist . moveDown ( ) NEW_LINE DEDENT
def clearPath ( self ) : NEW_LINE INDENT del self . servicePath [ : ] NEW_LINE DEDENT
def enterPath ( self , ref , justSet = False ) : NEW_LINE INDENT self . servicePath . append ( ref ) NEW_LINE self . setRoot ( ref , justSet ) NEW_LINE DEDENT
def enterUserbouquet ( self , root , save_root = True ) : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . recallBouquetMode ( ) NEW_LINE if self . bouquet_root : NEW_LINE INDENT self . enterPath ( self . bouquet_root ) NEW_LINE DEDENT self . enterPath ( root ) NEW_LINE self . startRoot = None NEW_LINE if save_root : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE DEDENT DEDENT
def pathUp ( self , justSet = False ) : NEW_LINE INDENT prev = self . servicePath . pop ( ) NEW_LINE if self . servicePath : NEW_LINE INDENT current = self . servicePath [ - 1 ] NEW_LINE self . setRoot ( current , justSet ) NEW_LINE if not justSet : NEW_LINE INDENT self . setCurrentSelection ( prev ) NEW_LINE DEDENT DEDENT return prev NEW_LINE DEDENT
def isBasePathEqual ( self , ref ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 and self . servicePath [ 0 ] == ref : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPrevPathEqual ( self , ref ) : NEW_LINE INDENT length = len ( self . servicePath ) NEW_LINE if length > 1 and self . servicePath [ length - 2 ] == ref : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def preEnterPath ( self , refstr ) : NEW_LINE INDENT return False NEW_LINE DEDENT
def showAllServices ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE playingref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE if playingref : NEW_LINE INDENT self . setCurrentSelectionAlternative ( playingref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def showSatellites ( self , changeMode = False ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE justSet = False NEW_LINE prev = None NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT if self . isPrevPathEqual ( ref ) : NEW_LINE INDENT justSet = True NEW_LINE DEDENT prev = self . pathUp ( justSet ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT justSet = True NEW_LINE self . clearPath ( ) NEW_LINE self . enterPath ( ref , True ) NEW_LINE DEDENT if changeMode and currentRoot and currentRoot == ref : NEW_LINE INDENT self . showSatDetails = not self . showSatDetails NEW_LINE justSet = True NEW_LINE self . clearPath ( ) NEW_LINE self . enterPath ( ref , True ) NEW_LINE DEDENT DEDENT if justSet : NEW_LINE INDENT addCableAndTerrestrialLater = [ ] NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE servicelist = serviceHandler . list ( ref ) NEW_LINE if not servicelist is None : NEW_LINE INDENT while True : NEW_LINE INDENT service = servicelist . getNext ( ) NEW_LINE if not service . valid ( ) : # check ▁ if ▁ end ▁ of ▁ list ENDCOM NEW_LINE INDENT break NEW_LINE DEDENT unsigned_orbpos = service . getUnsignedData ( 4 ) >> 16 NEW_LINE orbpos = service . getData ( 4 ) >> 16 NEW_LINE if orbpos < 0 : NEW_LINE INDENT orbpos += 3600 NEW_LINE DEDENT if " FROM ▁ PROVIDER " in service . getPath ( ) : NEW_LINE INDENT service_type = self . showSatDetails and _ ( " Providers " ) NEW_LINE DEDENT elif ( " flags ▁ = = ▁ % d " % ( FLAG_SERVICE_NEW_FOUND ) ) in service . getPath ( ) : NEW_LINE INDENT service_type = self . showSatDetails and _ ( " New " ) NEW_LINE DEDENT else : NEW_LINE INDENT service_type = _ ( " Services " ) NEW_LINE DEDENT if service_type : NEW_LINE INDENT if unsigned_orbpos == 0xFFFF : # Cable ENDCOM NEW_LINE INDENT service_name = _ ( " Cable " ) NEW_LINE addCableAndTerrestrialLater . append ( ( " % s ▁ - ▁ % s " % ( service_name , service_type ) , service . toString ( ) ) ) NEW_LINE DEDENT elif unsigned_orbpos == 0xEEEE : # Terrestrial ENDCOM NEW_LINE INDENT service_name = _ ( " Terrestrial " ) NEW_LINE addCableAndTerrestrialLater . append ( ( " % s ▁ - ▁ % s " % ( service_name , service_type ) , service . toString ( ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT service_name = str ( nimmanager . getSatDescription ( orbpos ) ) NEW_LINE DEDENT except : NEW_LINE INDENT if orbpos > 1800 : # ▁ west ENDCOM NEW_LINE INDENT orbpos = 3600 - orbpos NEW_LINE h = _ ( " W " ) NEW_LINE DEDENT else : NEW_LINE INDENT h = _ ( " E " ) NEW_LINE DEDENT service_name = ( " % d . % d " + h ) % ( orbpos / 10 , orbpos % 10 ) NEW_LINE DEDENT service . setName ( " % s ▁ - ▁ % s " % ( service_name , service_type ) ) NEW_LINE self . servicelist . addService ( service ) NEW_LINE DEDENT DEDENT DEDENT cur_ref = self . session . nav . getCurrentlyPlayingServiceReference ( ) NEW_LINE self . servicelist . l . sort ( ) NEW_LINE if cur_ref : NEW_LINE INDENT pos = self . service_types . rfind ( ' : ' ) NEW_LINE refstr = ' % s ▁ ( channelID ▁ = = ▁ % 08x % 04x % 04x ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name ' % ( self . service_types [ : pos + 1 ] , cur_ref . getUnsignedData ( 4 ) , # ▁ NAMESPACE ENDCOM cur_ref . getUnsignedData ( 2 ) , # ▁ TSID ENDCOM cur_ref . getUnsignedData ( 3 ) , # ▁ ONID ENDCOM self . service_types [ pos + 1 : ] ) NEW_LINE ref = eServiceReference ( refstr ) NEW_LINE ref . setName ( _ ( " Current ▁ transponder " ) ) NEW_LINE self . servicelist . addService ( ref , beforeCurrent = True ) NEW_LINE DEDENT for ( service_name , service_ref ) in addCableAndTerrestrialLater : NEW_LINE INDENT ref = eServiceReference ( service_ref ) NEW_LINE ref . setName ( service_name ) NEW_LINE self . servicelist . addService ( ref , beforeCurrent = True ) NEW_LINE DEDENT self . servicelist . l . FillFinished ( ) NEW_LINE if prev is not None : NEW_LINE INDENT self . setCurrentSelection ( prev ) NEW_LINE DEDENT elif cur_ref : NEW_LINE INDENT refstr = cur_ref . toString ( ) NEW_LINE op = " " . join ( refstr . split ( ' : ' , 10 ) [ 6 : 7 ] ) NEW_LINE if len ( op ) >= 4 : NEW_LINE INDENT hop = int ( op [ : - 4 ] , 16 ) NEW_LINE if len ( op ) >= 7 and not op . endswith ( '0000' ) : NEW_LINE INDENT op = op [ : - 4 ] + '0000' NEW_LINE DEDENT refstr = '1:7:0:0:0:0 : % s : 0:0:0 : ( satellitePosition ▁ = = ▁ % s ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name ' % ( op , hop , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] ) NEW_LINE self . setCurrentSelectionAlternative ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def showProviders ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT refstr = ' % s ▁ FROM ▁ PROVIDERS ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) NEW_LINE if not self . preEnterPath ( refstr ) : NEW_LINE INDENT ref = eServiceReference ( refstr ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != ref : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT provider = info . getInfoString ( iServiceInformation . sProvider ) NEW_LINE refstr = '1:7:0:0:0:0:0:0:0:0 : ( provider ▁ = = ▁ \ " % s\ " ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name : % s ' % ( provider , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] , provider ) NEW_LINE self . setCurrentSelectionAlternative ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT
def changeBouquet ( self , direction ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT if len ( self . servicePath ) > 1 : NEW_LINE # when ▁ enter ▁ satellite ▁ root ▁ list ▁ we ▁ must ▁ do ▁ some ▁ magic ▁ stuff . . ENDCOM INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT if direction < 0 : NEW_LINE INDENT self . moveUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . moveDown ( ) NEW_LINE DEDENT ref = self . getCurrentSelection ( ) NEW_LINE self . enterPath ( ref ) NEW_LINE DEDENT DEDENT DEDENT
def inBouquet ( self ) : NEW_LINE INDENT if self . servicePath and self . servicePath [ 0 ] == self . bouquet_root : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def atBegin ( self ) : NEW_LINE INDENT return self . servicelist . atBegin ( ) NEW_LINE DEDENT
def atEnd ( self ) : NEW_LINE INDENT return self . servicelist . atEnd ( ) NEW_LINE DEDENT
def nextBouquet ( self ) : NEW_LINE INDENT if self . shown and config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageUp ) NEW_LINE DEDENT elif " reverseB " in config . usage . servicelist_cursor_behavior . value : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT DEDENT
def prevBouquet ( self ) : NEW_LINE INDENT if self . shown and config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageDown ) NEW_LINE DEDENT elif " reverseB " in config . usage . servicelist_cursor_behavior . value : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT DEDENT
def keyLeft ( self ) : NEW_LINE INDENT if config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . changeBouquet ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageUp ) NEW_LINE DEDENT DEDENT
def keyRight ( self ) : NEW_LINE INDENT if config . usage . oldstyle_channel_select_controls . value : NEW_LINE INDENT self . changeBouquet ( + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . servicelist . instance . moveSelection ( self . servicelist . instance . pageDown ) NEW_LINE DEDENT DEDENT
def keyRecord ( self ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ref and not ( ref . flags & ( eServiceReference . isMarker | eServiceReference . isDirectory ) ) : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . instantRecord ( serviceRef = ref ) NEW_LINE DEDENT DEDENT
def showFavourites ( self ) : NEW_LINE INDENT if not self . pathChangeDisabled : NEW_LINE INDENT if not self . preEnterPath ( self . bouquet_rootstr ) : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT self . pathUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT currentRoot = self . getRoot ( ) NEW_LINE if currentRoot is None or currentRoot != self . bouquet_root : NEW_LINE INDENT self . clearPath ( ) NEW_LINE self . enterPath ( self . bouquet_root ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def keyNumber0 ( self , number ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 and not self . selectionNumber : NEW_LINE INDENT self . keyGoUp ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . keyNumberGlobal ( number ) NEW_LINE DEDENT DEDENT
def keyNumberGlobal ( self , number ) : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT if hasattr ( self , " editMode " ) and self . editMode : NEW_LINE INDENT if number == 2 : NEW_LINE INDENT self . renameEntry ( ) NEW_LINE DEDENT if number == 6 : NEW_LINE INDENT self . toggleMoveMode ( select = True ) NEW_LINE DEDENT if number == 8 : NEW_LINE INDENT self . removeCurrentEntry ( bouquet = False ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . numberSelectionActions ( number ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current_root = self . getRoot ( ) NEW_LINE if current_root and ' FROM ▁ BOUQUET ▁ " bouquets . ' in current_root . getPath ( ) : NEW_LINE INDENT if hasattr ( self , " editMode " ) and self . editMode : NEW_LINE INDENT if number == 2 : NEW_LINE INDENT self . renameEntry ( ) NEW_LINE DEDENT if number == 6 : NEW_LINE INDENT self . toggleMoveMode ( select = True ) NEW_LINE DEDENT if number == 8 : NEW_LINE INDENT self . removeCurrentEntry ( bouquet = True ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . numberSelectionActions ( number ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT unichar = self . numericalTextInput . getKey ( number ) NEW_LINE charstr = unichar . encode ( " utf - 8" ) NEW_LINE if len ( charstr ) == 1 : NEW_LINE INDENT self . servicelist . moveToChar ( charstr [ 0 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def numberSelectionActions ( self , number ) : NEW_LINE INDENT if not ( hasattr ( self , " movemode " ) and self . movemode ) : NEW_LINE INDENT if len ( self . selectionNumber ) > 4 : NEW_LINE INDENT self . clearNumberSelectionNumber ( ) NEW_LINE DEDENT self . selectionNumber = self . selectionNumber + str ( number ) NEW_LINE ref , bouquet = Screens . InfoBar . InfoBar . instance . searchNumber ( int ( self . selectionNumber ) , bouquet = self . getRoot ( ) ) NEW_LINE if ref : NEW_LINE INDENT if not ref . flags & eServiceReference . isMarker : NEW_LINE INDENT self . enterUserbouquet ( bouquet , save_root = False ) NEW_LINE self . setCurrentSelection ( ref ) NEW_LINE DEDENT self . clearNumberSelectionNumberTimer . start ( 1000 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT self . clearNumberSelectionNumber ( ) NEW_LINE DEDENT DEDENT DEDENT
def clearNumberSelectionNumber ( self ) : NEW_LINE INDENT self . clearNumberSelectionNumberTimer . stop ( ) NEW_LINE self . selectionNumber = " " NEW_LINE DEDENT
def keyAsciiCode ( self ) : NEW_LINE INDENT unichar = unichr ( getPrevAsciiCode ( ) ) NEW_LINE charstr = unichar . encode ( " utf - 8" ) NEW_LINE if len ( charstr ) == 1 : NEW_LINE INDENT self . servicelist . moveToChar ( charstr [ 0 ] ) NEW_LINE DEDENT DEDENT
def getRoot ( self ) : NEW_LINE INDENT return self . servicelist . getRoot ( ) NEW_LINE DEDENT
def getCurrentSelection ( self ) : NEW_LINE INDENT return self . servicelist . getCurrent ( ) NEW_LINE DEDENT
def setCurrentSelection ( self , service ) : NEW_LINE INDENT if service : NEW_LINE INDENT self . servicelist . setCurrent ( service , adjust = False ) NEW_LINE DEDENT DEDENT
def setCurrentSelectionAlternative ( self , ref ) : NEW_LINE INDENT if self . bouquet_mark_edit == EDIT_ALTERNATIVES and not ( ref . flags & eServiceReference . isDirectory ) : NEW_LINE INDENT for markedService in self . servicelist . getMarked ( ) : NEW_LINE INDENT markedService = eServiceReference ( markedService ) NEW_LINE self . setCurrentSelection ( markedService ) NEW_LINE if markedService == self . getCurrentSelection ( ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT self . setCurrentSelection ( ref ) NEW_LINE DEDENT
def getBouquetList ( self ) : NEW_LINE INDENT bouquets = [ ] NEW_LINE serviceHandler = eServiceCenter . getInstance ( ) NEW_LINE if config . usage . multibouquet . value : NEW_LINE INDENT list = serviceHandler . list ( self . bouquet_root ) NEW_LINE if list : NEW_LINE INDENT while True : NEW_LINE INDENT s = list . getNext ( ) NEW_LINE if not s . valid ( ) : NEW_LINE INDENT break NEW_LINE DEDENT if s . flags & eServiceReference . isDirectory and not s . flags & eServiceReference . isInvisible : NEW_LINE INDENT info = serviceHandler . info ( s ) NEW_LINE if info : NEW_LINE INDENT bouquets . append ( ( info . getName ( s ) , s ) ) NEW_LINE DEDENT DEDENT DEDENT return bouquets NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT info = serviceHandler . info ( self . bouquet_root ) NEW_LINE if info : NEW_LINE INDENT bouquets . append ( ( info . getName ( self . bouquet_root ) , self . bouquet_root ) ) NEW_LINE DEDENT return bouquets NEW_LINE DEDENT return None NEW_LINE DEDENT
def keyGoUp ( self ) : NEW_LINE INDENT if len ( self . servicePath ) > 1 : NEW_LINE INDENT if self . isBasePathEqual ( self . bouquet_root ) : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ SATELLITES ▁ ORDER ▁ BY ▁ satellitePosition ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showSatellites ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ref = eServiceReference ( ' % s ▁ FROM ▁ PROVIDERS ▁ ORDER ▁ BY ▁ name ' % ( self . service_types ) ) NEW_LINE if self . isBasePathEqual ( ref ) : NEW_LINE INDENT self . showProviders ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showAllServices ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def nextMarker ( self ) : NEW_LINE INDENT self . servicelist . moveToNextMarker ( ) NEW_LINE DEDENT
def prevMarker ( self ) : NEW_LINE INDENT self . servicelist . moveToPrevMarker ( ) NEW_LINE DEDENT
def gotoCurrentServiceOrProvider ( self , ref ) : NEW_LINE INDENT str = ref . toString ( ) NEW_LINE if _ ( " Providers " ) in str : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT provider = info . getInfoString ( iServiceInformation . sProvider ) NEW_LINE op = int ( self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) . toString ( ) . split ( ' : ' ) [ 6 ] [ : - 4 ] or "0" , 16 ) NEW_LINE refstr = '1:7:0:0:0:0:0:0:0:0 : ( provider ▁ = = ▁ \ " % s\ " ) ▁ & & ▁ ( satellitePosition ▁ = = ▁ % s ) ▁ & & ▁ % s ▁ ORDER ▁ BY ▁ name : % s ' % ( provider , op , self . service_types [ self . service_types . rfind ( ' : ' ) + 1 : ] , provider ) NEW_LINE self . setCurrentSelection ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT elif not self . isBasePathEqual ( self . bouquet_root ) or self . bouquet_mark_edit == EDIT_ALTERNATIVES : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref : NEW_LINE INDENT self . setCurrentSelectionAlternative ( playingref ) NEW_LINE DEDENT DEDENT DEDENT
def __init__ ( self , session ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE ChannelSelectionEdit . __init__ ( self ) NEW_LINE ChannelSelectionEPG . __init__ ( self ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " cancel " : self . cancel , " ok " : self . channelSelected , " keyRadio " : self . doRadioButton , " keyTV " : self . doTVButton , } ) NEW_LINE self . __event_tracker = ServiceEventTracker ( screen = self , eventmap = { iPlayableService . evStart : self . __evServiceStart , iPlayableService . evEnd : self . __evServiceEnd } ) NEW_LINE self . startServiceRef = None NEW_LINE self . history = [ ] NEW_LINE self . history_pos = 0 NEW_LINE if config . servicelist . startupservice . value and config . servicelist . startuproot . value : NEW_LINE INDENT config . servicelist . lastmode . value = config . servicelist . startupmode . value NEW_LINE if config . servicelist . lastmode . value == " tv " : NEW_LINE INDENT config . tv . lastservice . value = config . servicelist . startupservice . value NEW_LINE config . tv . lastroot . value = config . servicelist . startuproot . value NEW_LINE DEDENT elif config . servicelist . lastmode . value == " radio " : NEW_LINE INDENT config . radio . lastservice . value = config . servicelist . startupservice . value NEW_LINE config . radio . lastroot . value = config . servicelist . startuproot . value NEW_LINE DEDENT DEDENT self . lastservice = config . tv . lastservice NEW_LINE self . lastroot = config . tv . lastroot NEW_LINE self . revertMode = None NEW_LINE config . usage . multibouquet . addNotifier ( self . multibouquet_config_changed ) NEW_LINE self . new_service_played = False NEW_LINE self . dopipzap = False NEW_LINE self . onExecBegin . append ( self . asciiOn ) NEW_LINE self . mainScreenMode = None NEW_LINE self . mainScreenRoot = None NEW_LINE self . lastChannelRootTimer = eTimer ( ) NEW_LINE self . lastChannelRootTimer . callback . append ( self . __onCreate ) NEW_LINE self . lastChannelRootTimer . start ( 100 , True ) NEW_LINE self . pipzaptimer = eTimer ( ) NEW_LINE DEDENT
def asciiOn ( self ) : NEW_LINE INDENT rcinput = eRCInput . getInstance ( ) NEW_LINE rcinput . setKeyboardMode ( rcinput . kmAscii ) NEW_LINE DEDENT
def asciiOff ( self ) : NEW_LINE INDENT rcinput = eRCInput . getInstance ( ) NEW_LINE rcinput . setKeyboardMode ( rcinput . kmNone ) NEW_LINE DEDENT
def multibouquet_config_changed ( self , val ) : NEW_LINE INDENT self . recallBouquetMode ( ) NEW_LINE DEDENT
def __evServiceStart ( self ) : NEW_LINE INDENT if self . dopipzap and hasattr ( self . session , ' pip ' ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( self . session . pip . getCurrentServiceReference ( ) or eServiceReference ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT refstr = info . getInfoString ( iServiceInformation . sServiceref ) NEW_LINE self . servicelist . setPlayableIgnoreService ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def __evServiceEnd ( self ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( eServiceReference ( ) ) NEW_LINE DEDENT
def setMode ( self ) : NEW_LINE INDENT self . rootChanged = True NEW_LINE self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT DEDENT
def doTVButton ( self ) : NEW_LINE INDENT if self . mode == MODE_TV : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT DEDENT
def setModeTv ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . revertMode = self . mode NEW_LINE DEDENT self . lastservice = config . tv . lastservice NEW_LINE self . lastroot = config . tv . lastroot NEW_LINE config . servicelist . lastmode . value = " tv " NEW_LINE self . setTvMode ( ) NEW_LINE self . setMode ( ) NEW_LINE DEDENT
def doRadioButton ( self ) : NEW_LINE INDENT if self . mode == MODE_RADIO : NEW_LINE INDENT self . channelSelected ( doClose = False ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT DEDENT
def setModeRadio ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . revertMode = self . mode NEW_LINE DEDENT if config . usage . e1like_radio_mode . value : NEW_LINE INDENT self . lastservice = config . radio . lastservice NEW_LINE self . lastroot = config . radio . lastroot NEW_LINE config . servicelist . lastmode . value = " radio " NEW_LINE self . setRadioMode ( ) NEW_LINE self . setMode ( ) NEW_LINE DEDENT DEDENT
def __onCreate ( self ) : NEW_LINE INDENT if config . usage . e1like_radio_mode . value : NEW_LINE INDENT if config . servicelist . lastmode . value == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . zap ( ) NEW_LINE DEDENT DEDENT
def channelSelected ( self , doClose = True ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if config . usage . channelselection_preview . value and ( playingref is None or self . getCurrentSelection ( ) and self . getCurrentSelection ( ) != playingref ) : NEW_LINE INDENT doClose = False NEW_LINE DEDENT if not self . startServiceRef and not doClose : NEW_LINE INDENT self . startServiceRef = playingref NEW_LINE DEDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . movemode and ( self . isBasePathEqual ( self . bouquet_root ) or " userbouquet . " in ref . toString ( ) ) : NEW_LINE INDENT self . toggleMoveMarked ( ) NEW_LINE DEDENT elif ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT if Components . ParentalControl . parentalControl . isServicePlayable ( ref , self . bouquetParentalControlCallback , self . session ) : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT if not ( self . bouquet_mark_edit == EDIT_ALTERNATIVES and ref . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . doMark ( ) NEW_LINE DEDENT DEDENT elif not ( ref . flags & eServiceReference . isMarker or ref . type == - 1 ) : NEW_LINE INDENT root = self . getRoot ( ) NEW_LINE if not root or not ( root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . zap ( enable_pipzap = doClose , preview_zap = not doClose ) NEW_LINE self . asciiOff ( ) NEW_LINE if doClose : NEW_LINE INDENT if self . dopipzap : NEW_LINE INDENT self . zapBack ( ) NEW_LINE DEDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE self . correctChannelNumber ( ) NEW_LINE self . movemode and self . toggleMoveMode ( ) NEW_LINE self . editMode = False NEW_LINE self . protectContextMenu = True NEW_LINE self . close ( ref ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def bouquetParentalControlCallback ( self , ref ) : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE self . revertMode = None NEW_LINE DEDENT
def togglePipzap ( self ) : NEW_LINE INDENT assert ( self . session . pip ) NEW_LINE title = self . instance . getTitle ( ) NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE DEDENT if self . dopipzap : NEW_LINE # ▁ Mark ▁ PiP ▁ as ▁ inactive ▁ and ▁ effectively ▁ deactivate ▁ pipzap ENDCOM INDENT self . hidePipzapMessage ( ) NEW_LINE self . dopipzap = False NEW_LINE # ▁ Disable ▁ PiP ▁ if ▁ not ▁ playing ▁ a ▁ service ENDCOM if self . session . pip . pipservice is None : NEW_LINE INDENT self . session . pipshown = False NEW_LINE del self . session . pip NEW_LINE DEDENT self . __evServiceStart ( ) NEW_LINE # ▁ Move ▁ to ▁ playing ▁ service ENDCOM lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE if self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . servicelist . setCurrent ( lastservice ) NEW_LINE DEDENT DEDENT title += _ ( " ▁ ( TV ) " ) NEW_LINE DEDENT else : NEW_LINE # ▁ Mark ▁ PiP ▁ as ▁ active ▁ and ▁ effectively ▁ active ▁ pipzap ENDCOM INDENT self . showPipzapMessage ( ) NEW_LINE self . dopipzap = True NEW_LINE self . __evServiceStart ( ) NEW_LINE # ▁ Move ▁ to ▁ service ▁ playing ▁ in ▁ pip ▁ ( will ▁ not ▁ work ▁ with ▁ subservices ) ENDCOM self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE title += _ ( " ▁ ( PiP ) " ) NEW_LINE DEDENT self . setTitle ( title ) NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT
def showPipzapMessage ( self ) : NEW_LINE INDENT time = config . usage . infobar_timeout . index NEW_LINE if time : NEW_LINE INDENT self . pipzaptimer . callback . append ( self . hidePipzapMessage ) NEW_LINE self . pipzaptimer . startLongTimer ( time ) NEW_LINE DEDENT self . session . pip . active ( ) NEW_LINE DEDENT
def hidePipzapMessage ( self ) : NEW_LINE INDENT if self . pipzaptimer . isActive ( ) : NEW_LINE INDENT self . pipzaptimer . callback . remove ( self . hidePipzapMessage ) NEW_LINE self . pipzaptimer . stop ( ) NEW_LINE DEDENT self . session . pip . inactive ( ) NEW_LINE # called ▁ from ▁ infoBar ▁ and ▁ channelSelected ENDCOM DEDENT
def zap ( self , enable_pipzap = False , preview_zap = False , checkParentalControl = True , ref = None ) : NEW_LINE INDENT self . curRoot = self . startRoot NEW_LINE nref = ref or self . getCurrentSelection ( ) NEW_LINE ref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if enable_pipzap and self . dopipzap : NEW_LINE INDENT ref = self . session . pip . getCurrentService ( ) NEW_LINE if ref is None or ref != nref : NEW_LINE INDENT nref = self . session . pip . resolveAlternatePipService ( nref ) NEW_LINE if nref and ( not checkParentalControl or Components . ParentalControl . parentalControl . isServicePlayable ( nref , boundFunction ( self . zap , enable_pipzap = True , checkParentalControl = False ) ) ) : NEW_LINE INDENT self . session . pip . playService ( nref ) NEW_LINE self . __evServiceStart ( ) NEW_LINE self . showPipzapMessage ( ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setStartRoot ( self . curRoot ) NEW_LINE self . setCurrentSelection ( ref ) NEW_LINE DEDENT DEDENT DEDENT elif ref is None or ref != nref : NEW_LINE INDENT Screens . InfoBar . InfoBar . instance . checkTimeshiftRunning ( boundFunction ( self . zapCheckTimeshiftCallback , enable_pipzap , preview_zap , nref ) ) NEW_LINE DEDENT elif not preview_zap : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE self . saveChannel ( nref ) NEW_LINE config . servicelist . lastmode . save ( ) NEW_LINE self . setCurrentSelection ( nref ) NEW_LINE if self . startServiceRef is None or nref != self . startServiceRef : NEW_LINE INDENT self . addToHistory ( nref ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE self . revertMode = None NEW_LINE DEDENT DEDENT
def zapCheckTimeshiftCallback ( self , enable_pipzap , preview_zap , nref , answer ) : NEW_LINE INDENT if answer : NEW_LINE INDENT self . new_service_played = True NEW_LINE self . session . nav . playService ( nref ) NEW_LINE if not preview_zap : NEW_LINE INDENT self . saveRoot ( ) NEW_LINE self . saveChannel ( nref ) NEW_LINE config . servicelist . lastmode . save ( ) NEW_LINE if self . startServiceRef is None or nref != self . startServiceRef : NEW_LINE INDENT self . addToHistory ( nref ) NEW_LINE DEDENT if self . dopipzap : NEW_LINE INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . mainScreenMode = config . servicelist . lastmode . value NEW_LINE self . mainScreenRoot = self . getRoot ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT else : NEW_LINE INDENT Notifications . RemovePopup ( " Parental ▁ control " ) NEW_LINE self . setCurrentSelection ( nref ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT self . setStartRoot ( self . curRoot ) NEW_LINE self . setCurrentSelection ( self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) ) NEW_LINE DEDENT if not preview_zap : NEW_LINE INDENT self . hide ( ) NEW_LINE DEDENT DEDENT
def newServicePlayed ( self ) : NEW_LINE INDENT ret = self . new_service_played NEW_LINE self . new_service_played = False NEW_LINE return ret NEW_LINE DEDENT
def addToHistory ( self , ref ) : NEW_LINE INDENT if self . servicePath is not None : NEW_LINE INDENT tmp = self . servicePath [ : ] NEW_LINE tmp . append ( ref ) NEW_LINE try : NEW_LINE INDENT del self . history [ self . history_pos + 1 : ] NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT self . history . append ( tmp ) NEW_LINE hlen = len ( self . history ) NEW_LINE if hlen > HISTORYSIZE : NEW_LINE INDENT del self . history [ 0 ] NEW_LINE hlen -= 1 NEW_LINE DEDENT self . history_pos = hlen - 1 NEW_LINE DEDENT DEDENT
def historyBack ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE currentPlayedRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if hlen > 0 and currentPlayedRef and self . history [ self . history_pos ] [ - 1 ] != currentPlayedRef : NEW_LINE INDENT self . addToHistory ( currentPlayedRef ) NEW_LINE hlen = len ( self . history ) NEW_LINE DEDENT if hlen > 1 and self . history_pos > 0 : NEW_LINE INDENT self . history_pos -= 1 NEW_LINE self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT
def historyNext ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE if hlen > 1 and self . history_pos < ( hlen - 1 ) : NEW_LINE INDENT self . history_pos += 1 NEW_LINE self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT
def setHistoryPath ( self , doZap = True ) : NEW_LINE INDENT path = self . history [ self . history_pos ] [ : ] NEW_LINE ref = path . pop ( ) NEW_LINE del self . servicePath [ : ] NEW_LINE self . servicePath += path NEW_LINE self . saveRoot ( ) NEW_LINE root = path [ - 1 ] NEW_LINE cur_root = self . getRoot ( ) NEW_LINE if cur_root and cur_root != root : NEW_LINE INDENT self . setRoot ( root ) NEW_LINE DEDENT if doZap : NEW_LINE INDENT self . session . nav . playService ( ref , adjust = False ) NEW_LINE DEDENT if self . dopipzap : NEW_LINE INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . setCurrentSelection ( ref ) NEW_LINE DEDENT self . saveChannel ( ref ) NEW_LINE DEDENT
def saveRoot ( self ) : NEW_LINE INDENT path = ' ' NEW_LINE for i in self . servicePath : NEW_LINE INDENT path += i . toString ( ) NEW_LINE path += ' ; ' NEW_LINE DEDENT if path and path != self . lastroot . value : NEW_LINE INDENT if self . mode == MODE_RADIO and ' FROM ▁ BOUQUET ▁ " bouquets . tv " ' in path : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . mode == MODE_TV and ' FROM ▁ BOUQUET ▁ " bouquets . radio " ' in path : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . lastroot . value = path NEW_LINE self . lastroot . save ( ) NEW_LINE DEDENT DEDENT
def restoreRoot ( self ) : NEW_LINE INDENT tmp = [ x for x in self . lastroot . value . split ( ' ; ' ) if x != ' ' ] NEW_LINE current = [ x . toString ( ) for x in self . servicePath ] NEW_LINE if tmp != current or self . rootChanged : NEW_LINE INDENT self . clearPath ( ) NEW_LINE cnt = 0 NEW_LINE for i in tmp : NEW_LINE INDENT self . servicePath . append ( eServiceReference ( i ) ) NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt : NEW_LINE INDENT path = self . servicePath . pop ( ) NEW_LINE self . enterPath ( path ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE self . saveRoot ( ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE DEDENT DEDENT
def preEnterPath ( self , refstr ) : NEW_LINE INDENT if self . servicePath and self . servicePath [ 0 ] != eServiceReference ( refstr ) : NEW_LINE INDENT pathstr = self . lastroot . value NEW_LINE if pathstr is not None and refstr in pathstr : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def saveChannel ( self , ref ) : NEW_LINE INDENT if ref is not None : NEW_LINE INDENT refstr = ref . toString ( ) NEW_LINE DEDENT else : NEW_LINE INDENT refstr = " " NEW_LINE DEDENT if refstr != self . lastservice . value and not Components . ParentalControl . parentalControl . isProtected ( ref ) : NEW_LINE INDENT self . lastservice . value = refstr NEW_LINE self . lastservice . save ( ) NEW_LINE DEDENT DEDENT
def setCurrentServicePath ( self , path , doZap = True ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE if not hlen : NEW_LINE INDENT self . history . append ( path ) NEW_LINE self . history_pos = 0 NEW_LINE DEDENT if hlen == 1 : NEW_LINE INDENT self . history [ self . history_pos ] = path NEW_LINE DEDENT else : NEW_LINE INDENT if path in self . history : NEW_LINE INDENT self . history . remove ( path ) NEW_LINE self . history_pos -= 1 NEW_LINE DEDENT tmp = self . history [ self . history_pos ] [ : ] NEW_LINE self . history . append ( tmp ) NEW_LINE self . history_pos += 1 NEW_LINE self . history [ self . history_pos ] = path NEW_LINE DEDENT self . setHistoryPath ( doZap ) NEW_LINE DEDENT
def getCurrentServicePath ( self ) : NEW_LINE INDENT if self . history : NEW_LINE INDENT return self . history [ self . history_pos ] NEW_LINE DEDENT return None NEW_LINE DEDENT
def recallPrevService ( self ) : NEW_LINE INDENT hlen = len ( self . history ) NEW_LINE currentPlayedRef = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if hlen > 0 and currentPlayedRef and self . history [ self . history_pos ] [ - 1 ] != currentPlayedRef : NEW_LINE INDENT self . addToHistory ( currentPlayedRef ) NEW_LINE hlen = len ( self . history ) NEW_LINE DEDENT if hlen > 1 : NEW_LINE INDENT if self . history_pos == hlen - 1 : NEW_LINE INDENT tmp = self . history [ self . history_pos ] NEW_LINE self . history [ self . history_pos ] = self . history [ self . history_pos - 1 ] NEW_LINE self . history [ self . history_pos - 1 ] = tmp NEW_LINE DEDENT else : NEW_LINE INDENT tmp = self . history [ self . history_pos + 1 ] NEW_LINE self . history [ self . history_pos + 1 ] = self . history [ self . history_pos ] NEW_LINE self . history [ self . history_pos ] = tmp NEW_LINE DEDENT self . setHistoryPath ( ) NEW_LINE DEDENT DEDENT
def cancel ( self ) : NEW_LINE INDENT if self . revertMode is None : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE if self . dopipzap : NEW_LINE # ▁ This ▁ unfortunately ▁ won ' t ▁ work ▁ with ▁ subservices ENDCOM INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) != lastservice : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT DEDENT DEDENT self . asciiOff ( ) NEW_LINE self . zapBack ( ) NEW_LINE self . correctChannelNumber ( ) NEW_LINE self . editMode = False NEW_LINE self . protectContextMenu = True NEW_LINE self . close ( None ) NEW_LINE DEDENT
def zapBack ( self ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if self . startServiceRef and ( playingref is None or playingref != self . startServiceRef ) : NEW_LINE INDENT self . setStartRoot ( self . startRoot ) NEW_LINE self . new_service_played = True NEW_LINE self . session . nav . playService ( self . startServiceRef ) NEW_LINE self . saveChannel ( self . startServiceRef ) NEW_LINE DEDENT else : NEW_LINE INDENT self . restoreMode ( ) NEW_LINE DEDENT self . startServiceRef = None NEW_LINE self . startRoot = None NEW_LINE if self . dopipzap : NEW_LINE # ▁ This ▁ unfortunately ▁ won ' t ▁ work ▁ with ▁ subservices ENDCOM INDENT self . setCurrentSelection ( self . session . pip . getCurrentService ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT lastservice = eServiceReference ( self . lastservice . value ) NEW_LINE if lastservice . valid ( ) and self . getCurrentSelection ( ) == lastservice : NEW_LINE INDENT pass # ▁ keep ▁ current ▁ selection ENDCOM NEW_LINE DEDENT else : NEW_LINE INDENT self . setCurrentSelection ( playingref ) NEW_LINE DEDENT DEDENT DEDENT
def setStartRoot ( self , root ) : NEW_LINE INDENT if root : NEW_LINE INDENT if self . revertMode == MODE_TV : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . revertMode == MODE_RADIO : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE self . enterUserbouquet ( root ) NEW_LINE DEDENT DEDENT
def restoreMode ( self ) : NEW_LINE INDENT if self . revertMode == MODE_TV : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . revertMode == MODE_RADIO : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT
def correctChannelNumber ( self ) : NEW_LINE INDENT current_ref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if self . dopipzap : NEW_LINE INDENT tmp_mode = config . servicelist . lastmode . value NEW_LINE tmp_root = self . getRoot ( ) NEW_LINE tmp_ref = self . getCurrentSelection ( ) NEW_LINE pip_ref = self . session . pip . getCurrentService ( ) NEW_LINE if tmp_ref and pip_ref and tmp_ref != pip_ref : NEW_LINE INDENT self . revertMode = None NEW_LINE return NEW_LINE DEDENT if self . mainScreenMode == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif self . mainScreenMode == " radio " : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT if self . mainScreenRoot : NEW_LINE INDENT self . setRoot ( self . mainScreenRoot ) NEW_LINE self . setCurrentSelection ( current_ref ) NEW_LINE DEDENT DEDENT selected_ref = self . getCurrentSelection ( ) NEW_LINE if selected_ref and current_ref and selected_ref . getChannelNum ( ) != current_ref . getChannelNum ( ) : NEW_LINE INDENT oldref = self . session . nav . currentlyPlayingServiceReference NEW_LINE if oldref and selected_ref == oldref or ( oldref != current_ref and selected_ref == current_ref ) : NEW_LINE INDENT self . session . nav . currentlyPlayingServiceOrGroup = selected_ref NEW_LINE self . session . nav . pnav . navEvent ( iPlayableService . evStart ) NEW_LINE DEDENT DEDENT if self . dopipzap : NEW_LINE INDENT if tmp_mode == " tv " : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE DEDENT elif tmp_mode == " radio " : NEW_LINE INDENT self . setModeRadio ( ) NEW_LINE DEDENT self . enterUserbouquet ( tmp_root ) NEW_LINE title = self . instance . getTitle ( ) NEW_LINE pos = title . find ( " ▁ ( " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT title = title [ : pos ] NEW_LINE title += _ ( " ▁ ( PiP ) " ) NEW_LINE self . setTitle ( title ) NEW_LINE self . buildTitleString ( ) NEW_LINE DEDENT if tmp_ref and pip_ref and tmp_ref . getChannelNum ( ) != pip_ref . getChannelNum ( ) : NEW_LINE INDENT self . session . pip . currentService = tmp_ref NEW_LINE DEDENT self . setCurrentSelection ( tmp_ref ) NEW_LINE DEDENT self . revertMode = None NEW_LINE DEDENT
def __init__ ( self , session ) : NEW_LINE INDENT Screen . __init__ ( self , session ) NEW_LINE self [ " RdsDecoder " ] = RdsDecoder ( self . session . nav ) NEW_LINE DEDENT
def __init__ ( self , session , infobar ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE ChannelSelectionEdit . __init__ ( self ) NEW_LINE ChannelSelectionEPG . __init__ ( self ) NEW_LINE InfoBarBase . __init__ ( self ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self . infobar = infobar NEW_LINE self . startServiceRef = None NEW_LINE self . onLayoutFinish . append ( self . onCreate ) NEW_LINE self . info = session . instantiateDialog ( RadioInfoBar ) # ▁ our ▁ simple ▁ infobar ENDCOM NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " keyTV " : self . cancel , " keyRadio " : self . cancel , " cancel " : self . cancel , " ok " : self . channelSelected , } ) NEW_LINE self . __event_tracker = ServiceEventTracker ( screen = self , eventmap = { iPlayableService . evStart : self . __evServiceStart , iPlayableService . evEnd : self . __evServiceEnd } ) NEW_LINE # # # # # ▁ RDS ▁ Radiotext ▁ / ▁ Rass ▁ Support ▁ BEGIN ENDCOM self . infobar = infobar # ▁ reference ▁ to ▁ real ▁ infobar ▁ ( the ▁ one ▁ and ▁ only ) ENDCOM NEW_LINE self [ " RdsDecoder " ] = self . info [ " RdsDecoder " ] NEW_LINE self [ " RdsActions " ] = HelpableActionMap ( self , " InfobarRdsActions " , { " startRassInteractive " : ( self . startRassInteractive , _ ( " View ▁ Rass ▁ interactive . . . " ) ) } , - 1 ) NEW_LINE self [ " RdsActions " ] . setEnabled ( False ) NEW_LINE infobar . rds_display . onRassInteractivePossibilityChanged . append ( self . RassInteractivePossibilityChanged ) NEW_LINE self . onClose . append ( self . __onClose ) NEW_LINE self . onExecBegin . append ( self . __onExecBegin ) NEW_LINE self . onExecEnd . append ( self . __onExecEnd ) NEW_LINE DEDENT
def __onClose ( self ) : NEW_LINE INDENT lastservice = eServiceReference ( config . tv . lastservice . value ) NEW_LINE self . session . nav . playService ( lastservice ) NEW_LINE DEDENT
def startRassInteractive ( self ) : NEW_LINE INDENT self . info . hide ( ) ; NEW_LINE self . infobar . rass_interactive = self . session . openWithCallback ( self . RassInteractiveClosed , RassInteractive ) NEW_LINE DEDENT
def RassInteractiveClosed ( self ) : NEW_LINE INDENT self . info . show ( ) NEW_LINE self . infobar . rass_interactive = None NEW_LINE self . infobar . RassSlidePicChanged ( ) NEW_LINE DEDENT
def RassInteractivePossibilityChanged ( self , state ) : NEW_LINE INDENT self [ " RdsActions " ] . setEnabled ( state ) NEW_LINE # # # # # ▁ RDS ▁ Radiotext ▁ / ▁ Rass ▁ Support ▁ END ENDCOM DEDENT
def __onExecBegin ( self ) : NEW_LINE INDENT self . info . show ( ) NEW_LINE DEDENT
def __onExecEnd ( self ) : NEW_LINE INDENT self . info . hide ( ) NEW_LINE DEDENT
def cancel ( self ) : NEW_LINE INDENT self . infobar . rds_display . onRassInteractivePossibilityChanged . remove ( self . RassInteractivePossibilityChanged ) NEW_LINE self . info . hide ( ) NEW_LINE # set ▁ previous ▁ tv ▁ service ENDCOM self . close ( None ) NEW_LINE DEDENT
def __evServiceStart ( self ) : NEW_LINE INDENT service = self . session . nav . getCurrentService ( ) NEW_LINE if service : NEW_LINE INDENT info = service . info ( ) NEW_LINE if info : NEW_LINE INDENT refstr = info . getInfoString ( iServiceInformation . sServiceref ) NEW_LINE self . servicelist . setPlayableIgnoreService ( eServiceReference ( refstr ) ) NEW_LINE DEDENT DEDENT DEDENT
def __evServiceEnd ( self ) : NEW_LINE INDENT self . servicelist . setPlayableIgnoreService ( eServiceReference ( ) ) NEW_LINE DEDENT
def saveRoot ( self ) : NEW_LINE INDENT path = ' ' NEW_LINE for i in self . servicePathRadio : NEW_LINE INDENT path += i . toString ( ) NEW_LINE path += ' ; ' NEW_LINE DEDENT if path and path != config . radio . lastroot . value : NEW_LINE INDENT config . radio . lastroot . value = path NEW_LINE config . radio . lastroot . save ( ) NEW_LINE DEDENT DEDENT
def restoreRoot ( self ) : NEW_LINE INDENT tmp = [ x for x in config . radio . lastroot . value . split ( ' ; ' ) if x != ' ' ] NEW_LINE current = [ x . toString ( ) for x in self . servicePath ] NEW_LINE if tmp != current or self . rootChanged : NEW_LINE INDENT cnt = 0 NEW_LINE for i in tmp : NEW_LINE INDENT self . servicePathRadio . append ( eServiceReference ( i ) ) NEW_LINE cnt += 1 NEW_LINE DEDENT if cnt : NEW_LINE INDENT path = self . servicePathRadio . pop ( ) NEW_LINE self . enterPath ( path ) NEW_LINE DEDENT else : NEW_LINE INDENT self . showFavourites ( ) NEW_LINE self . saveRoot ( ) NEW_LINE DEDENT self . rootChanged = False NEW_LINE DEDENT DEDENT
def preEnterPath ( self , refstr ) : NEW_LINE INDENT if self . servicePathRadio and self . servicePathRadio [ 0 ] != eServiceReference ( refstr ) : NEW_LINE INDENT pathstr = config . radio . lastroot . value NEW_LINE if pathstr is not None and refstr in pathstr : NEW_LINE INDENT self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( config . radio . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . setCurrentSelection ( lastservice ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def onCreate ( self ) : NEW_LINE INDENT self . setRadioMode ( ) NEW_LINE self . restoreRoot ( ) NEW_LINE lastservice = eServiceReference ( config . radio . lastservice . value ) NEW_LINE if lastservice . valid ( ) : NEW_LINE INDENT self . servicelist . setCurrent ( lastservice ) NEW_LINE self . session . nav . playService ( lastservice ) NEW_LINE DEDENT else : NEW_LINE INDENT self . session . nav . stopService ( ) NEW_LINE DEDENT self . info . show ( ) NEW_LINE DEDENT
def channelSelected ( self , doClose = False ) : # ▁ just ▁ return ▁ selected ▁ service ENDCOM NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . movemode : NEW_LINE INDENT self . toggleMoveMarked ( ) NEW_LINE DEDENT elif ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT elif self . bouquet_mark_edit != OFF : NEW_LINE INDENT if not ( self . bouquet_mark_edit == EDIT_ALTERNATIVES and ref . flags & eServiceReference . isGroup ) : NEW_LINE INDENT self . doMark ( ) NEW_LINE DEDENT DEDENT elif not ( ref . flags & eServiceReference . isMarker ) : # ▁ no ▁ marker ENDCOM NEW_LINE INDENT cur_root = self . getRoot ( ) NEW_LINE if not cur_root or not ( cur_root . flags & eServiceReference . isGroup ) : NEW_LINE INDENT playingref = self . session . nav . getCurrentlyPlayingServiceOrGroup ( ) NEW_LINE if playingref is None or playingref != ref : NEW_LINE INDENT self . session . nav . playService ( ref ) NEW_LINE config . radio . lastservice . value = ref . toString ( ) NEW_LINE config . radio . lastservice . save ( ) NEW_LINE DEDENT self . saveRoot ( ) NEW_LINE DEDENT DEDENT DEDENT
def zapBack ( self ) : NEW_LINE INDENT self . channelSelected ( ) NEW_LINE DEDENT
def __init__ ( self , session , title , currentBouquet = False , returnBouquet = False , setService = None , setBouquet = None ) : NEW_LINE INDENT ChannelSelectionBase . __init__ ( self , session ) NEW_LINE SelectionEventInfo . __init__ ( self ) NEW_LINE self [ " actions " ] = ActionMap ( [ " OkCancelActions " , " TvRadioActions " ] , { " cancel " : self . close , " ok " : self . channelSelected , " keyRadio " : self . setModeRadio , " keyTV " : self . setModeTv , } ) NEW_LINE self . bouquet_mark_edit = OFF NEW_LINE if isinstance ( title , str ) : NEW_LINE INDENT self . maintitle = title NEW_LINE DEDENT self . currentBouquet = currentBouquet NEW_LINE self . returnBouquet = returnBouquet NEW_LINE self . setService = setService NEW_LINE self . setBouquet = setBouquet NEW_LINE self . onLayoutFinish . append ( self . layoutFinished ) NEW_LINE DEDENT
def layoutFinished ( self ) : NEW_LINE INDENT self . setModeTv ( ) NEW_LINE if self . currentBouquet or self . setBouquet : NEW_LINE INDENT ref = self . setBouquet or Screens . InfoBar . InfoBar . instance . servicelist . getRoot ( ) NEW_LINE if ref : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT DEDENT if self . setService : NEW_LINE INDENT self . setCurrentSelection ( self . setService ) NEW_LINE DEDENT DEDENT
def saveRoot ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def keyRecord ( self ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def channelSelected ( self ) : # ▁ just ▁ return ▁ selected ▁ service ENDCOM NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if ( ref . flags & eServiceReference . flagDirectory ) == eServiceReference . flagDirectory : NEW_LINE INDENT self . enterPath ( ref ) NEW_LINE self . gotoCurrentServiceOrProvider ( ref ) NEW_LINE DEDENT elif not ( ref . flags & eServiceReference . isMarker ) : NEW_LINE INDENT ref = self . getCurrentSelection ( ) NEW_LINE if self . returnBouquet and len ( self . servicePath ) : NEW_LINE INDENT self . close ( ref , self . servicePath [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . close ( ref ) NEW_LINE DEDENT DEDENT DEDENT
def setModeTv ( self ) : NEW_LINE INDENT self . setTvMode ( ) NEW_LINE self . showFavourites ( ) NEW_LINE DEDENT
def setModeRadio ( self ) : NEW_LINE INDENT self . setRadioMode ( ) NEW_LINE self . showFavourites ( ) NEW_LINE DEDENT
