def parse_nested_list ( input_file ) : NEW_LINE INDENT tokens = tokenize ( input_file ) NEW_LINE next_token = tokens . next ( ) NEW_LINE if next_token != " ( " : NEW_LINE INDENT raise ParseError ( " Expected ▁ ' ( ' , ▁ got ▁ % s . " % next_token ) NEW_LINE DEDENT result = list ( parse_list_aux ( tokens ) ) NEW_LINE for tok in tokens : # ▁ Check ▁ that ▁ generator ▁ is ▁ exhausted . ENDCOM NEW_LINE INDENT raise ParseError ( " Unexpected ▁ token : ▁ % s . " % tok ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def tokenize ( input ) : NEW_LINE INDENT for line in input : NEW_LINE INDENT line = line . split ( " ; " , 1 ) [ 0 ] # ▁ Strip ▁ comments . ENDCOM NEW_LINE line = line . replace ( " ( " , " ▁ ( ▁ " ) . replace ( " ) " , " ▁ ) ▁ " ) . replace ( " ? " , " ▁ ? " ) NEW_LINE for token in line . split ( ) : NEW_LINE INDENT yield token . lower ( ) NEW_LINE DEDENT DEDENT DEDENT
def parse_list_aux ( tokenstream ) : NEW_LINE # ▁ Leading ▁ " ( " ▁ has ▁ already ▁ been ▁ swallowed . ENDCOM INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT token = tokenstream . next ( ) NEW_LINE DEDENT except StopIteration : NEW_LINE INDENT raise ParseError ( ) NEW_LINE DEDENT if token == " ) " : NEW_LINE INDENT return NEW_LINE DEDENT elif token == " ( " : NEW_LINE INDENT yield list ( parse_list_aux ( tokenstream ) ) NEW_LINE DEDENT else : NEW_LINE INDENT yield token NEW_LINE DEDENT DEDENT DEDENT
def delete_doc ( doctype = None , name = None , force = 0 , ignore_doctypes = None , for_reload = False , ignore_permissions = False , flags = None , ignore_on_trash = False ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Deletes ▁ a ▁ doc ( dt , ▁ dn ) ▁ and ▁ validates ▁ if ▁ it ▁ is ▁ not ▁ submitted ▁ and ▁ not ▁ linked ▁ in ▁ a ▁ live ▁ record STRNEWLINE TABSYMBOL """ NEW_LINE if not ignore_doctypes : ignore_doctypes = [ ] NEW_LINE # ▁ get ▁ from ▁ form ENDCOM if not doctype : NEW_LINE INDENT doctype = frappe . form_dict . get ( ' dt ' ) NEW_LINE name = frappe . form_dict . get ( ' dn ' ) NEW_LINE DEDENT names = name NEW_LINE if isinstance ( name , basestring ) : NEW_LINE INDENT names = [ name ] NEW_LINE DEDENT for name in names or [ ] : NEW_LINE # ▁ already ▁ deleted . . ? ENDCOM INDENT if not frappe . db . exists ( doctype , name ) : NEW_LINE INDENT return NEW_LINE # ▁ delete ▁ attachments ENDCOM DEDENT remove_all ( doctype , name ) NEW_LINE # ▁ delete ▁ passwords ENDCOM delete_all_passwords_for ( doctype , name ) NEW_LINE doc = None NEW_LINE if doctype == " DocType " : NEW_LINE INDENT if for_reload : NEW_LINE INDENT try : NEW_LINE INDENT doc = frappe . get_doc ( doctype , name ) NEW_LINE DEDENT except frappe . DoesNotExistError : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT doc . run_method ( " before _ reload " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT doc = frappe . get_doc ( doctype , name ) NEW_LINE update_flags ( doc , flags , ignore_permissions ) NEW_LINE check_permission_and_not_submitted ( doc ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabCustom ▁ Field ` ▁ where ▁ dt ▁ = ▁ % s " , name ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabCustom ▁ Script ` ▁ where ▁ dt ▁ = ▁ % s " , name ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabProperty ▁ Setter ` ▁ where ▁ doc _ type ▁ = ▁ % s " , name ) NEW_LINE frappe . db . sql ( " delete ▁ from ▁ ` tabReport ` ▁ where ▁ ref _ doctype = % s " , name ) NEW_LINE DEDENT delete_from_table ( doctype , name , ignore_doctypes , None ) NEW_LINE DEDENT else : NEW_LINE INDENT doc = frappe . get_doc ( doctype , name ) NEW_LINE if not for_reload : NEW_LINE INDENT update_flags ( doc , flags , ignore_permissions ) NEW_LINE check_permission_and_not_submitted ( doc ) NEW_LINE if not ignore_on_trash : NEW_LINE INDENT doc . run_method ( " on _ trash " ) NEW_LINE doc . run_method ( ' on _ change ' ) NEW_LINE DEDENT dynamic_linked_doctypes = [ df . parent for df in get_dynamic_link_map ( ) . get ( doc . doctype , [ ] ) ] NEW_LINE if " ToDo " in dynamic_linked_doctypes : NEW_LINE INDENT delete_linked_todos ( doc ) NEW_LINE DEDENT if " Communication " in dynamic_linked_doctypes : NEW_LINE INDENT delete_linked_communications ( doc ) NEW_LINE DEDENT if " DocShare " in dynamic_linked_doctypes : NEW_LINE INDENT delete_shared ( doc ) NEW_LINE DEDENT if " Email ▁ Unsubscribe " in dynamic_linked_doctypes : NEW_LINE INDENT delete_email_subscribe ( doc ) NEW_LINE # ▁ check ▁ if ▁ links ▁ exist ENDCOM DEDENT if not force : NEW_LINE INDENT check_if_doc_is_linked ( doc ) NEW_LINE check_if_doc_is_dynamically_linked ( doc ) NEW_LINE DEDENT DEDENT update_naming_series ( doc ) NEW_LINE delete_from_table ( doctype , name , ignore_doctypes , doc ) NEW_LINE doc . run_method ( " after _ delete " ) NEW_LINE DEDENT if doc and not frappe . flags . in_patch : NEW_LINE INDENT try : NEW_LINE INDENT doc . notify_update ( ) NEW_LINE insert_feed ( doc ) NEW_LINE DEDENT except ImportError : NEW_LINE INDENT pass NEW_LINE # ▁ delete ▁ user _ permissions ENDCOM DEDENT DEDENT frappe . defaults . clear_default ( parenttype = " User ▁ Permission " , key = doctype , value = name ) NEW_LINE DEDENT DEDENT
def update_naming_series ( doc ) : NEW_LINE INDENT if doc . meta . autoname : NEW_LINE INDENT if doc . meta . autoname . startswith ( " naming _ series : " ) and getattr ( doc , " naming _ series " , None ) : NEW_LINE INDENT revert_series_if_last ( doc . naming_series , doc . name ) NEW_LINE DEDENT elif doc . meta . autoname . split ( " : " ) [ 0 ] not in ( " Prompt " , " field " , " hash " ) : NEW_LINE INDENT revert_series_if_last ( doc . meta . autoname , doc . name ) NEW_LINE DEDENT DEDENT DEDENT
def delete_from_table ( doctype , name , ignore_doctypes , doc ) : NEW_LINE INDENT if doctype != " DocType " and doctype == name : NEW_LINE INDENT frappe . db . sql ( " delete ▁ from ▁ ` tabSingles ` ▁ where ▁ doctype = % s " , name ) NEW_LINE DEDENT else : NEW_LINE INDENT frappe . db . sql ( " delete ▁ from ▁ ` tab % s ` ▁ where ▁ name = % s " % ( frappe . db . escape ( doctype ) , " % s " ) , ( name , ) ) NEW_LINE # ▁ get ▁ child ▁ tables ENDCOM DEDENT if doc : NEW_LINE INDENT tables = [ d . options for d in doc . meta . get_table_fields ( ) ] NEW_LINE DEDENT else : NEW_LINE INDENT def get_table_fields ( field_doctype ) : NEW_LINE INDENT return frappe . db . sql_list ( """ select ▁ options ▁ from ▁ ` tab { } ` ▁ where ▁ fieldtype = ' Table ' STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL and ▁ parent = % s """ . format ( field_doctype ) , doctype ) NEW_LINE DEDENT tables = get_table_fields ( " DocField " ) NEW_LINE if not frappe . flags . in_install == " frappe " : NEW_LINE INDENT tables += get_table_fields ( " Custom ▁ Field " ) NEW_LINE # ▁ delete ▁ from ▁ child ▁ tables ENDCOM DEDENT DEDENT for t in list ( set ( tables ) ) : NEW_LINE INDENT if t not in ignore_doctypes : NEW_LINE INDENT frappe . db . sql ( " delete ▁ from ▁ ` tab % s ` ▁ where ▁ parenttype = % s ▁ and ▁ parent ▁ = ▁ % s " % ( t , ' % s ' , ' % s ' ) , ( doctype , name ) ) NEW_LINE DEDENT DEDENT DEDENT
def update_flags ( doc , flags = None , ignore_permissions = False ) : NEW_LINE INDENT if ignore_permissions : NEW_LINE INDENT if not flags : flags = { } NEW_LINE flags [ " ignore _ permissions " ] = ignore_permissions NEW_LINE DEDENT if flags : NEW_LINE INDENT doc . flags . update ( flags ) NEW_LINE DEDENT DEDENT
def check_permission_and_not_submitted ( doc ) : NEW_LINE # ▁ permission ENDCOM INDENT if not doc . flags . ignore_permissions and frappe . session . user != " Administrator " and ( not doc . has_permission ( " delete " ) or ( doc . doctype == " DocType " and not doc . custom ) ) : NEW_LINE INDENT frappe . msgprint ( _ ( " User ▁ not ▁ allowed ▁ to ▁ delete ▁ { 0 } : ▁ { 1 } " ) . format ( doc . doctype , doc . name ) , raise_exception = True ) NEW_LINE # ▁ check ▁ if ▁ submitted ENDCOM DEDENT if doc . docstatus == 1 : NEW_LINE INDENT frappe . msgprint ( _ ( " { 0 } ▁ { 1 } : ▁ Submitted ▁ Record ▁ cannot ▁ be ▁ deleted . " ) . format ( doc . doctype , doc . name ) , raise_exception = True ) NEW_LINE DEDENT DEDENT
def check_if_doc_is_linked ( doc , method = " Delete " ) : NEW_LINE INDENT """ STRNEWLINE TABSYMBOL TABSYMBOL Raises ▁ excption ▁ if ▁ the ▁ given ▁ doc ( dt , ▁ dn ) ▁ is ▁ linked ▁ in ▁ another ▁ record . STRNEWLINE TABSYMBOL """ NEW_LINE from frappe . model . rename_doc import get_link_fields NEW_LINE link_fields = get_link_fields ( doc . doctype ) NEW_LINE link_fields = [ [ lf [ ' parent ' ] , lf [ ' fieldname ' ] , lf [ ' issingle ' ] ] for lf in link_fields ] NEW_LINE for link_dt , link_field , issingle in link_fields : NEW_LINE INDENT if not issingle : NEW_LINE INDENT item = frappe . db . get_value ( link_dt , { link_field : doc . name } , [ " name " , " parent " , " parenttype " , " docstatus " ] , as_dict = True ) NEW_LINE if item and ( ( item . parent or item . name ) != doc . name ) and ( ( method == " Delete " and item . docstatus < 2 ) or ( method == " Cancel " and item . docstatus == 1 ) ) : NEW_LINE # ▁ raise ▁ exception ▁ only ▁ if ENDCOM # ▁ linked ▁ to ▁ an ▁ non - cancelled ▁ doc ▁ when ▁ deleting ENDCOM # ▁ or ▁ linked ▁ to ▁ a ▁ submitted ▁ doc ▁ when ▁ cancelling ENDCOM INDENT frappe . throw ( _ ( " Cannot ▁ delete ▁ or ▁ cancel ▁ because ▁ { 0 } ▁ { 1 } ▁ is ▁ linked ▁ with ▁ { 2 } ▁ { 3 } " ) . format ( doc . doctype , doc . name , item . parenttype if item . parent else link_dt , item . parent or item . name ) , frappe . LinkExistsError ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def check_if_doc_is_dynamically_linked ( doc , method = " Delete " ) : NEW_LINE INDENT ''' Raise ▁ ` frappe . LinkExistsError ` ▁ if ▁ the ▁ document ▁ is ▁ dynamically ▁ linked ''' NEW_LINE for df in get_dynamic_link_map ( ) . get ( doc . doctype , [ ] ) : NEW_LINE INDENT if df . parent in ( " Communication " , " ToDo " , " DocShare " , " Email ▁ Unsubscribe " ) : NEW_LINE # ▁ don ' t ▁ check ▁ for ▁ communication ▁ and ▁ todo ! ENDCOM INDENT continue NEW_LINE DEDENT meta = frappe . get_meta ( df . parent ) NEW_LINE if meta . issingle : NEW_LINE # ▁ dynamic ▁ link ▁ in ▁ single ▁ doc ENDCOM INDENT refdoc = frappe . db . get_singles_dict ( df . parent ) NEW_LINE if ( refdoc . get ( df . options ) == doc . doctype and refdoc . get ( df . fieldname ) == doc . name and ( ( method == " Delete " and refdoc . docstatus < 2 ) or ( method == " Cancel " and refdoc . docstatus == 1 ) ) ) : NEW_LINE # ▁ raise ▁ exception ▁ only ▁ if ENDCOM # ▁ linked ▁ to ▁ an ▁ non - cancelled ▁ doc ▁ when ▁ deleting ENDCOM # ▁ or ▁ linked ▁ to ▁ a ▁ submitted ▁ doc ▁ when ▁ cancelling ENDCOM INDENT frappe . throw ( _ ( " Cannot ▁ delete ▁ or ▁ cancel ▁ because ▁ { 0 } ▁ { 1 } ▁ is ▁ linked ▁ with ▁ { 2 } ▁ { 3 } " ) . format ( doc . doctype , doc . name , df . parent , " " ) , frappe . LinkExistsError ) NEW_LINE DEDENT DEDENT else : NEW_LINE # ▁ dynamic ▁ link ▁ in ▁ table ENDCOM INDENT for refdoc in frappe . db . sql ( """ select ▁ name , ▁ docstatus ▁ from ▁ ` tab { parent } ` ▁ where STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL { options } = % s ▁ and ▁ { fieldname } = % s """ . format ( ** df ) , ( doc . doctype , doc . name ) , as_dict = True ) : NEW_LINE INDENT if ( ( method == " Delete " and refdoc . docstatus < 2 ) or ( method == " Cancel " and refdoc . docstatus == 1 ) ) : NEW_LINE # ▁ raise ▁ exception ▁ only ▁ if ENDCOM # ▁ linked ▁ to ▁ an ▁ non - cancelled ▁ doc ▁ when ▁ deleting ENDCOM # ▁ or ▁ linked ▁ to ▁ a ▁ submitted ▁ doc ▁ when ▁ cancelling ENDCOM INDENT frappe . throw ( _ ( " Cannot ▁ delete ▁ or ▁ cancel ▁ because ▁ { 0 } ▁ { 1 } ▁ is ▁ linked ▁ with ▁ { 2 } ▁ { 3 } " ) . format ( doc . doctype , doc . name , df . parent , refdoc . name ) , frappe . LinkExistsError ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def delete_linked_todos ( doc ) : NEW_LINE INDENT delete_doc ( " ToDo " , frappe . db . sql_list ( """ select ▁ name ▁ from ▁ ` tabToDo ` STRNEWLINE TABSYMBOL TABSYMBOL where ▁ reference _ type = % s ▁ and ▁ reference _ name = % s """ , ( doc . doctype , doc . name ) ) , ignore_permissions = True ) NEW_LINE DEDENT
def delete_email_subscribe ( doc ) : NEW_LINE INDENT frappe . db . sql ( ''' delete ▁ from ▁ ` tabEmail ▁ Unsubscribe ` STRNEWLINE TABSYMBOL TABSYMBOL where ▁ reference _ doctype = % s ▁ and ▁ reference _ name = % s ''' , ( doc . doctype , doc . name ) ) NEW_LINE DEDENT
def delete_linked_communications ( doc ) : NEW_LINE # ▁ delete ▁ comments ENDCOM INDENT frappe . db . sql ( """ delete ▁ from ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL where STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL communication _ type ▁ = ▁ ' Comment ' STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL and ▁ reference _ doctype = % s ▁ and ▁ reference _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE # ▁ make ▁ communications ▁ orphans ENDCOM frappe . db . sql ( """ update ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL set ▁ reference _ doctype = null , ▁ reference _ name = null STRNEWLINE TABSYMBOL TABSYMBOL where STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL communication _ type ▁ = ▁ ' Communication ' STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL and ▁ reference _ doctype = % s STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL and ▁ reference _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE # ▁ make ▁ secondary ▁ references ▁ orphans ENDCOM frappe . db . sql ( """ update ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL set ▁ link _ doctype = null , ▁ link _ name = null STRNEWLINE TABSYMBOL TABSYMBOL where ▁ link _ doctype = % s ▁ and ▁ link _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE frappe . db . sql ( """ update ▁ ` tabCommunication ` STRNEWLINE TABSYMBOL TABSYMBOL set ▁ timeline _ doctype = null , ▁ timeline _ name = null STRNEWLINE TABSYMBOL TABSYMBOL where ▁ timeline _ doctype = % s ▁ and ▁ timeline _ name = % s """ , ( doc . doctype , doc . name ) ) NEW_LINE DEDENT
def insert_feed ( doc ) : NEW_LINE INDENT from frappe . utils import get_fullname NEW_LINE if frappe . flags . in_install or frappe . flags . in_import or getattr ( doc , " no _ feed _ on _ delete " , False ) : NEW_LINE INDENT return NEW_LINE DEDENT frappe . get_doc ( { " doctype " : " Communication " , " communication _ type " : " Comment " , " comment _ type " : " Deleted " , " reference _ doctype " : doc . doctype , " subject " : " { 0 } ▁ { 1 } " . format ( _ ( doc . doctype ) , doc . name ) , " full _ name " : get_fullname ( doc . owner ) } ) . insert ( ignore_permissions = True ) NEW_LINE DEDENT
def delete_shared ( doc ) : NEW_LINE INDENT delete_doc ( " DocShare " , frappe . db . sql_list ( """ select ▁ name ▁ from ▁ ` tabDocShare ` STRNEWLINE TABSYMBOL TABSYMBOL where ▁ share _ doctype = % s ▁ and ▁ share _ name = % s """ , ( doc . doctype , doc . name ) ) , ignore_on_trash = True ) NEW_LINE DEDENT
def setUpClass ( cls ) : NEW_LINE # ▁ Backup ▁ original ▁ environment ▁ variable ENDCOM INDENT address_predefined = ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' in os . environ NEW_LINE old_address = os . environ . get ( ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ) NEW_LINE # ▁ Just ▁ the ▁ host ▁ is ▁ not ▁ accepted ENDCOM cls . raises_exception ( ' localhost ' , ImproperlyConfigured ) NEW_LINE # ▁ The ▁ host ▁ must ▁ be ▁ valid ENDCOM cls . raises_exception ( ' blahblahblah : 8081' , socket . error ) NEW_LINE # ▁ The ▁ list ▁ of ▁ ports ▁ must ▁ be ▁ in ▁ a ▁ valid ▁ format ENDCOM cls . raises_exception ( ' localhost : 8081 , ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 , blah ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 - ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081 - blah ' , ImproperlyConfigured ) NEW_LINE cls . raises_exception ( ' localhost : 8081-8082-8083' , ImproperlyConfigured ) NEW_LINE # ▁ Restore ▁ original ▁ environment ▁ variable ENDCOM if address_predefined : NEW_LINE INDENT os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] = old_address NEW_LINE DEDENT else : NEW_LINE INDENT del os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] NEW_LINE # ▁ put ▁ it ▁ in ▁ a ▁ list ▁ to ▁ prevent ▁ descriptor ▁ lookups ▁ in ▁ test ENDCOM DEDENT cls . live_server_url_test = [ cls . live_server_url ] NEW_LINE DEDENT
def tearDownClass ( cls ) : NEW_LINE # ▁ skip ▁ it , ▁ as ▁ setUpClass ▁ doesn ' t ▁ call ▁ its ▁ parent ▁ either ENDCOM INDENT pass NEW_LINE DEDENT
def raises_exception ( cls , address , exception ) : NEW_LINE INDENT os . environ [ ' DJANGO _ LIVE _ TEST _ SERVER _ ADDRESS ' ] = address NEW_LINE try : NEW_LINE INDENT super ( LiveServerAddress , cls ) . setUpClass ( ) NEW_LINE raise Exception ( " The ▁ line ▁ above ▁ should ▁ have ▁ raised ▁ an ▁ exception " ) NEW_LINE DEDENT except exception : NEW_LINE INDENT pass NEW_LINE DEDENT finally : NEW_LINE INDENT super ( LiveServerAddress , cls ) . tearDownClass ( ) NEW_LINE DEDENT DEDENT
def test_list_donors ( ) : NEW_LINE INDENT listing = mailroom . list_donors ( ) NEW_LINE # ▁ hard ▁ to ▁ test ▁ this ▁ throughly ▁ - - ▁ better ▁ not ▁ to ▁ hard ▁ code ▁ the ▁ entire ENDCOM # ▁ thing . ▁ But ▁ check ▁ for ▁ a ▁ few ▁ aspects ▁ - - ▁ this ▁ will ▁ catch ▁ the ▁ likely ENDCOM # ▁ errors ENDCOM assert listing . startswith ( " Donor ▁ list : \n " ) NEW_LINE assert " Jeff ▁ Bezos " in listing NEW_LINE assert " William ▁ Gates ▁ III " in listing NEW_LINE assert len ( listing . split ( ' \n ' ) ) == 5 NEW_LINE DEDENT
def test_find_donor ( ) : NEW_LINE INDENT """ ▁ checks ▁ a ▁ donor ▁ that ▁ is ▁ there , ▁ but ▁ with ▁ odd ▁ case ▁ and ▁ spaces """ NEW_LINE donor = mailroom . find_donor ( " jefF ▁ beZos ▁ " ) NEW_LINE assert donor [ 0 ] == " Jeff ▁ Bezos " NEW_LINE DEDENT
def test_find_donor_not ( ) : NEW_LINE INDENT " test ▁ one ▁ that ' s ▁ not ▁ there " NEW_LINE donor = mailroom . find_donor ( " Jeff ▁ Bzos " ) NEW_LINE assert donor is None NEW_LINE DEDENT
def test_gen_letter ( ) : NEW_LINE INDENT """ ▁ test ▁ the ▁ donor ▁ letter ▁ """ NEW_LINE # ▁ create ▁ a ▁ sample ▁ donor ENDCOM donor = ( " Fred ▁ Flintstone " , [ 432.45 , 65.45 , 230.0 ] ) NEW_LINE letter = mailroom . gen_letter ( donor ) NEW_LINE # ▁ what ▁ to ▁ test ? ▁ tricky ! ENDCOM assert letter . startswith ( " Dear ▁ Fred ▁ Flintstone " ) NEW_LINE assert letter . endswith ( " - The ▁ Team \n " ) NEW_LINE assert " donation ▁ of ▁ $ 230.00" in letter NEW_LINE DEDENT
def test_add_donor ( ) : NEW_LINE INDENT name = " Fred ▁ Flintstone ▁ ▁ " NEW_LINE donor = mailroom . add_donor ( name ) NEW_LINE donor [ 1 ] . append ( 300 ) NEW_LINE assert donor [ 0 ] == " Fred ▁ Flintstone " NEW_LINE assert donor [ 1 ] == [ 300 ] NEW_LINE assert mailroom . find_donor ( name ) == donor NEW_LINE DEDENT
def test_generate_donor_report ( ) : NEW_LINE INDENT report = mailroom . generate_donor_report ( ) NEW_LINE print ( report ) # ▁ printing ▁ so ▁ you ▁ can ▁ see ▁ it ▁ if ▁ it ▁ fails ENDCOM NEW_LINE # ▁ this ▁ is ▁ pretty ▁ tough ▁ to ▁ test ENDCOM # ▁ these ▁ are ▁ not ▁ great , ▁ because ▁ they ▁ will ▁ fail ▁ if ▁ unimportant ▁ parts ▁ of ▁ the ENDCOM # ▁ report ▁ are ▁ changed . ENDCOM # ▁ but ▁ at ▁ least ▁ you ▁ know ▁ that ▁ codes ▁ working ▁ now . ENDCOM assert report . startswith ( " Donor ▁ Name ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ | ▁ Total ▁ Given ▁ | ▁ Num ▁ Gifts ▁ | ▁ Average ▁ Gift " ) NEW_LINE assert " Jeff ▁ Bezos ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ $ ▁ ▁ ▁ ▁ 877.33 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ 1 ▁ ▁ ▁ $ ▁ ▁ ▁ ▁ ▁ 877.33" in report NEW_LINE DEDENT
def test_save_letters_to_disk ( ) : NEW_LINE INDENT """ STRNEWLINE ▁ This ▁ only ▁ tests ▁ that ▁ the ▁ files ▁ get ▁ created , ▁ but ▁ that ' s ▁ a ▁ start STRNEWLINE STRNEWLINE ▁ Note ▁ that ▁ the ▁ contents ▁ of ▁ the ▁ letter ▁ was ▁ already STRNEWLINE ▁ tested ▁ with ▁ test _ gen _ letter STRNEWLINE ▁ """ NEW_LINE mailroom . save_letters_to_disk ( ) NEW_LINE assert os . path . isfile ( ' Jeff _ Bezos . txt ' ) NEW_LINE assert os . path . isfile ( ' William _ Gates _ III . txt ' ) NEW_LINE # ▁ check ▁ that ▁ it ' snot ▁ empty : ENDCOM with open ( ' William _ Gates _ III . txt ' ) as f : NEW_LINE INDENT size = len ( f . read ( ) ) NEW_LINE DEDENT assert size > 0 NEW_LINE DEDENT
def options ( opt ) : NEW_LINE INDENT opt . load ( ' gnu _ dirs ' ) NEW_LINE valaopts = opt . add_option_group ( ' Vala ▁ Compiler ▁ Options ' ) NEW_LINE valaopts . add_option ( ' - - vala - target - glib ' , default = None , dest = ' vala _ target _ glib ' , metavar = ' MAJOR . MINOR ' , help = ' Target ▁ version ▁ of ▁ glib ▁ for ▁ Vala ▁ GObject ▁ code ▁ generation ' ) NEW_LINE DEDENT
def to_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , bytes_type ) NEW_LINE return s . decode ( ' latin1' ) NEW_LINE DEDENT
def from_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , str ) NEW_LINE return s . encode ( ' latin1' ) NEW_LINE DEDENT
def to_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , bytes_type ) NEW_LINE return s NEW_LINE DEDENT
def from_wsgi_str ( s ) : NEW_LINE INDENT assert isinstance ( s , str ) NEW_LINE return s NEW_LINE DEDENT
def ▁ simple _ app ( environ , ▁ start _ response ) : STRNEWLINE ▁ status ▁ = ▁ " 200 ▁ OK " STRNEWLINE ▁ response _ headers ▁ = ▁ [ ( " Content - type " , ▁ " text / plain " ) ] STRNEWLINE ▁ start _ response ( status , ▁ response _ headers ) STRNEWLINE ▁ return ▁ [ " Hello ▁ world ! \n " ] STRNEWLINE STRNEWLINE ▁ container ▁ = ▁ tornado . wsgi . WSGIContainer ( simple _ app ) STRNEWLINE ▁ http _ server ▁ = ▁ tornado . httpserver . HTTPServer ( container ) STRNEWLINE ▁ http _ server . listen ( 8888 ) STRNEWLINE ▁ tornado . ioloop . IOLoop . instance ( ) . start ( ) STRNEWLINE STRNEWLINE ▁ This ▁ class ▁ is ▁ intended ▁ to ▁ let ▁ other ▁ frameworks ▁ ( Django , ▁ web . py , ▁ etc ) STRNEWLINE ▁ run ▁ on ▁ the ▁ Tornado ▁ HTTP ▁ server ▁ and ▁ I / O ▁ loop . STRNEWLINE STRNEWLINE ▁ The ▁ ` tornado . web . FallbackHandler ` ▁ class ▁ is ▁ often ▁ useful ▁ for ▁ mixing STRNEWLINE ▁ Tornado ▁ and ▁ WSGI ▁ apps ▁ in ▁ the ▁ same ▁ server . ▁ See STRNEWLINE ▁ https : / / github . com / bdarnell / django - tornado - demo ▁ for ▁ a ▁ complete ▁ example . STRNEWLINE ▁ """ NEW_LINE def __init__ ( self , wsgi_application ) : NEW_LINE INDENT self . wsgi_application = wsgi_application NEW_LINE DEDENT
def environ ( request ) : NEW_LINE INDENT """ Converts ▁ a ▁ ` tornado . httpserver . HTTPRequest ` ▁ to ▁ a ▁ WSGI ▁ environment . STRNEWLINE ▁ """ NEW_LINE hostport = request . host . split ( " : " ) NEW_LINE if len ( hostport ) == 2 : NEW_LINE INDENT host = hostport [ 0 ] NEW_LINE port = int ( hostport [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT host = request . host NEW_LINE port = 443 if request . protocol == " https " else 80 NEW_LINE DEDENT environ = { " REQUEST _ METHOD " : request . method , " SCRIPT _ NAME " : " " , " PATH _ INFO " : to_wsgi_str ( escape . url_unescape ( request . path , encoding = None , plus = False ) ) , " QUERY _ STRING " : request . query , " REMOTE _ ADDR " : request . remote_ip , " SERVER _ NAME " : host , " SERVER _ PORT " : str ( port ) , " SERVER _ PROTOCOL " : request . version , " wsgi . version " : ( 1 , 0 ) , " wsgi . url _ scheme " : request . protocol , " wsgi . input " : BytesIO ( escape . utf8 ( request . body ) ) , " wsgi . errors " : sys . stderr , " wsgi . multithread " : False , " wsgi . multiprocess " : True , " wsgi . run _ once " : False , } NEW_LINE if " Content - Type " in request . headers : NEW_LINE INDENT environ [ " CONTENT _ TYPE " ] = request . headers . pop ( " Content - Type " ) NEW_LINE DEDENT if " Content - Length " in request . headers : NEW_LINE INDENT environ [ " CONTENT _ LENGTH " ] = request . headers . pop ( " Content - Length " ) NEW_LINE DEDENT for key , value in request . headers . items ( ) : NEW_LINE INDENT environ [ " HTTP _ " + key . replace ( " - " , " _ " ) . upper ( ) ] = value NEW_LINE DEDENT return environ NEW_LINE DEDENT
def setUpClass ( cls ) : NEW_LINE INDENT super ( ) . setUpClass ( ) NEW_LINE cls . server = FakeSMTPServer ( ( '127.0.0.1' , 0 ) , None ) NEW_LINE cls . _settings_override = override_settings ( EMAIL_HOST = "127.0.0.1" , EMAIL_PORT = cls . server . socket . getsockname ( ) [ 1 ] ) NEW_LINE cls . _settings_override . enable ( ) NEW_LINE cls . server . start ( ) NEW_LINE DEDENT
def tearDownClass ( cls ) : NEW_LINE INDENT cls . _settings_override . disable ( ) NEW_LINE cls . server . stop ( ) NEW_LINE super ( ) . tearDownClass ( ) NEW_LINE DEDENT
def setUpClass ( cls ) : NEW_LINE INDENT super ( ) . setUpClass ( ) NEW_LINE cls . backend = smtp . EmailBackend ( username = ' ' , password = ' ' ) NEW_LINE cls . server . stop ( ) NEW_LINE DEDENT
