<DOCUMENT_ID="ton@@ y--@@ /WinObjC/tree/master/deps/3rdparty/iculegacy/source/@@ i18n/@@ rbtz.cpp"> # include < typeinfo > # include " unicode / utypes . h " # if ! UCONFIG_NO_FORMATTING # include " unicode / rbtz . h " # include " unicode / greg@@ ocal . h " # include " uvector . h " # include " gregoimp . h " # include " cmemory . h " U_NAMESPACE_BEGIN struct Transition { UDate time ; TimeZoneRule * from ; TimeZoneRule * to ; } ; static UBool compareRules ( UVector * rules1 , UVector * rules2 ) { if ( rules1 == NULL && rules2 == NULL ) { return TRUE ; } else if ( rules1 == NULL || rules2 == NULL ) { return FALSE ; } int32_t size = rules1 -> size ( ) ; if ( size != rules2 -> size ( ) ) { return FALSE ; } for ( int32_t i = 0 ; i < size ; i ++ ) { TimeZoneRule * r1 = ( TimeZoneRule * ) rules1 -> elementAt ( i ) ; TimeZoneRule * r2 = ( TimeZoneRule * ) rules2 -> elementAt ( i ) ; if ( * r1 != * r2 ) { return FALSE ; } } return TRUE ; } UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( RuleBasedTimeZone ) RuleBasedTimeZone :: RuleBasedTimeZone ( const UnicodeString & id , InitialTimeZoneRule * initialRule ) : BasicTimeZone ( id ) , fInitialRule ( initialRule ) , fHistoricRules ( NULL ) , fFinalRules ( NULL ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { } RuleBasedTimeZone :: RuleBasedTimeZone ( const RuleBasedTimeZone & source ) : BasicTimeZone ( source ) , fInitialRule ( source . fInitialRule -> clone ( ) ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { fHistoricRules = copyRules ( source . fHistoricRules ) ; fFinalRules = copyRules ( source . fFinalRules ) ; if ( source . fUpToDate ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; } } RuleBasedTimeZone :: ~ RuleBasedTimeZone ( ) { deleteTransitions ( ) ; deleteRules ( ) ; } RuleBasedTimeZone & RuleBasedTimeZone :: operator = ( const RuleBasedTimeZone & right ) { if ( * this != right ) { BasicTimeZone :: operator = ( right ) ; deleteRules ( ) ; fInitialRule = right . fInitialRule -> clone ( ) ; fHistoricRules = copyRules ( right . fHistoricRules ) ; fFinalRules = copyRules ( right . fFinalRules ) ; deleteTransitions ( ) ; fUpToDate = FALSE ; } return * this ; } UBool RuleBasedTimeZone :: operator == ( const TimeZone & that ) const { if ( this == & that ) { return TRUE ; } if ( typeid ( * this ) != typeid ( that ) || BasicTimeZone :: operator == ( that ) == FALSE ) { return FALSE ; } RuleBasedTimeZone * rbtz = ( RuleBasedTimeZone * ) & that ; if ( * fInitialRule != * ( rbtz -> fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , rbtz -> fHistoricRules ) && compareRules ( fFinalRules , rbtz -> fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: operator != ( const TimeZone & that ) const { return ! operator == ( that ) ; } void RuleBasedTimeZone :: addTransition@@ Rule ( TimeZoneRule * rule , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } AnnualTimeZoneRule * atzrule = dynamic_cast < AnnualTimeZoneRule * > ( rule ) ; if ( atzrule != NULL && atzrule -> getEnd@@ Year ( ) == AnnualTimeZoneRule :: MAX_YEAR ) { if ( fFinalRules == NULL ) { fFinalRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } else if ( fFinalRules -> size ( ) >= 2 ) { status = U_INVALID_STATE_ERROR ; return ; } fFinalRules -> addElement ( ( void * ) rule , status ) ; } else { if ( fHistoricRules == NULL ) { fHistoricRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } fHistoricRules -> addElement ( ( void * ) rule , status ) ; } fUpToDate = FALSE ; } void RuleBasedTimeZone :: complete ( UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } if ( fUpToDate ) { return ; } if ( fFinalRules != NULL && fFinalRules -> size ( ) != 2 ) { status = U_INVALID_STATE_ERROR ; return ; } UBool * done = NULL ; if ( fHistoricRules != NULL || fFinalRules != NULL ) { TimeZoneRule * curRule = fInitialRule ; UDate lastTransitionTime = MIN_@@ MILLIS ; if ( fHistoricRules != NULL && fHistoricRules -> size ( ) > 0 ) { int32_t i ; int32_t historicCount = fHistoricRules -> size ( ) ; done = ( UBool * ) uprv_malloc ( sizeof ( UBool ) * historicCount ) ; if ( done == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } for ( i = 0 ; i < historicCount ; i ++ ) { done [ i ] = FALSE ; } while ( TRUE ) { int32_t curStdOffset = curRule -> getRawOffset ( ) ; int32_t curDstSavings = curRule -> getDSTSavings ( ) ; UDate nextTransitionTime = MAX_MILLIS ; TimeZoneRule * nextRule = NULL ; TimeZoneRule * r = NULL ; UBool avail ; UDate tt ; UnicodeString curName , name ; curRule -> getName ( curName ) ; for ( i = 0 ; i < historicCount ; i ++ ) { if ( done [ i ] ) { continue ; } r = ( TimeZoneRule * ) fHistoricRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( ! avail ) { done [ i ] = TRUE ; } else { r -> getName ( name ) ; if ( * r == * curRule || ( name == curName && r -> getRawOffset ( ) == curRule -> getRawOffset ( ) && r -> getDSTSavings ( ) == curRule -> getDSTSavings ( ) ) ) { continue ; } if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } if ( nextRule == NULL ) { UBool bDoneAll = TRUE ; for ( int32_t j = 0 ; j < historicCount ; j ++ ) { if ( ! done [ j ] ) { bDoneAll = FALSE ; break ; } } if ( bDoneAll ) { break ; } } if ( fFinalRules != NULL ) { for ( i = 0 ; i < 2 ; i ++ ) { TimeZoneRule * fr = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; if ( * fr == * curRule ) { continue ; } r = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( avail ) { if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } } if ( nextRule == NULL ) { break ; } if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } Transition * trst = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( trst == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } trst -> time = nextTransitionTime ; trst -> from = curRule ; trst -> to = nextRule ; fHistoricTransitions -> addElement ( trst , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } lastTransitionTime = nextTransitionTime ; curRule = nextRule ; } } if ( fFinalRules != NULL ) { if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } TimeZoneRule * rule0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * rule1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate tt0 , tt1 ; UBool avail0 = rule0 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt0 ) ; UBool avail1 = rule1 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt1 ) ; if ( ! avail0 || ! avail1 ) { status = U_INVALID_STATE_ERROR ; goto cleanup ; } Transition * final0 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final0 == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } Transition * final1 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final1 == NULL ) { uprv_free ( final0 ) ; status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } if ( tt0 < tt1 ) { final0 -> time = tt0 ; final0 -> from = curRule ; final0 -> to = rule0 ; rule1 -> getNextStart ( tt0 , rule0 -> getRawOffset ( ) , rule0 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule0 ; final1 -> to = rule1 ; } else { final0 -> time = tt1 ; final0 -> from = curRule ; final0 -> to = rule1 ; rule0 -> getNextStart ( tt1 , rule1 -> getRawOffset ( ) , rule1 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule1 ; final1 -> to = rule0 ; } fHistoricTransitions -> addElement ( final0 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } fHistoricTransitions -> addElement ( final1 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } } fUpToDate = TRUE ; if ( done != NULL ) { uprv_free ( done ) ; } return ; cleanup : deleteTransitions ( ) ; if ( done != NULL ) { uprv_free ( done ) ; } fUpToDate = FALSE ; } TimeZone * RuleBasedTimeZone :: clone ( void ) const { return new RuleBasedTimeZone ( * this ) ; } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t dayOfWeek , int32_t millis , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( month < UCAL_@@ JAN@@ UAR@@ Y || month > UCAL_@@ DECEMB@@ ER ) { status = U_ILLEGAL_ARGUMENT_ERROR ; return 0 ; } else { return getOffset ( era , year , month , day , dayOfWeek , millis , Grego :: monthLength ( year , month ) , status ) ; } } int32_t RuleBasedTimeZone :: getOffset ( uint8_t era , int32_t year , int32_t month , int32_t day , uint8_t , int32_t millis , int32_t , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return 0 ; } if ( era == Greg@@ orianCalendar :: BC ) { year = 1 - year ; } int32_t rawOffset , dstOffset ; UDate time = ( UDate ) Grego :: fieldsTo@@ Day ( year , month , day ) * U_MILLIS_@@ PER_DAY + millis ; getOffsetInternal ( time , TRUE , kDaylight , kStandard , rawOffset , dstOffset , status ) ; if ( U_FAILURE ( status ) ) { return 0 ; } return ( rawOffset + dstOffset ) ; } void RuleBasedTimeZone :: getOffset ( UDate date , UBool local , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { getOffsetInternal ( date , local , kFormer , kLatter , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffset@@ FromLocal ( UDate date , int32_t nonExistingTimeOpt , int32_t duplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) { getOffsetInternal ( date , TRUE , nonExistingTimeOpt , duplicatedTimeOpt , rawOffset , dstOffset , status ) ; } void RuleBasedTimeZone :: getOffsetInternal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) const { rawOffset = 0 ; dstOffset = 0 ; if ( U_FAILURE ( status ) ) { return ; } if ( ! fUpToDate ) { status = U_INVALID_STATE_ERROR ; return ; } const TimeZoneRule * rule = NULL ; if ( fHistoricTransitions == NULL ) { rule = fInitialRule ; } else { UDate tstart = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date < tstart ) { rule = fInitialRule ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; UDate tend = getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; if ( date > tend ) { if ( fFinalRules != NULL ) { rule = findRuleInFinal ( date , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } else { rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } else { while ( idx >= 0 ) { if ( date >= getTransitionTime ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) , local , NonExistingTimeOpt , DuplicatedTimeOpt ) ) { break ; } idx -- ; } rule = ( ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ) -> to ; } } } if ( rule != NULL ) { rawOffset = rule -> getRawOffset ( ) ; dstOffset = rule -> getDSTSavings ( ) ; } } void RuleBasedTimeZone :: setRaw@@ Offset ( int32_t ) { } int32_t RuleBasedTimeZone :: getRawOffset ( void ) const { UErrorCode status = U_ZERO_ERROR ; int32_t raw , dst ; getOffset ( uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND , FALSE , raw , dst , status ) ; return raw ; } UBool RuleBasedTimeZone :: useDaylightTime ( void ) const { UErrorCode status = U_ZERO_ERROR ; UDate now = uprv_getUTCtime ( ) * U_MILLIS_PER_SECOND ; int32_t raw , dst ; getOffset ( now , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } UDate time ; TimeZoneRule * from , * to ; UBool avail = findNext ( now , FALSE , time , from , to ) ; if ( avail && to -> getDSTSavings ( ) != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: inDaylightTime ( UDate date , UErrorCode & status ) const { if ( U_FAILURE ( status ) ) { return FALSE ; } int32_t raw , dst ; getOffset ( date , FALSE , raw , dst , status ) ; if ( dst != 0 ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: hasSame@@ Rules ( const TimeZone & other ) const { if ( this == & other ) { return TRUE ; } if ( typeid ( * this ) != typeid ( other ) ) { return FALSE ; } const RuleBasedTimeZone & that = ( const RuleBasedTimeZone & ) other ; if ( * fInitialRule != * ( that . fInitialRule ) ) { return FALSE ; } if ( compareRules ( fHistoricRules , that . fHistoricRules ) && compareRules ( fFinalRules , that . fFinalRules ) ) { return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getNextTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findNext ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: getPrevious@@ Transition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findPrev ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; } int32_t RuleBasedTimeZone :: countTransitionRules ( UErrorCode & ) { int32_t count = 0 ; if ( fHistoricRules != NULL ) { count += fHistoricRules -> size ( ) ; } if ( fFinalRules != NULL ) { count += fFinalRules -> size ( ) ; } return count ; } void RuleBasedTimeZone :: getTimeZone@@ Rules ( const InitialTimeZoneRule * & initial , const TimeZoneRule * trsrules [ ] , int32_t & trscount , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } initial = fInitialRule ; int32_t cnt = 0 ; int32_t idx ; if ( fHistoricRules != NULL && cnt < trscount ) { int32_t historicCount = fHistoricRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < historicCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fHistoricRules -> elementAt ( idx ++ ) ; } } if ( fFinalRules != NULL && cnt < trscount ) { int32_t finalCount = fFinalRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < finalCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fFinalRules -> elementAt ( idx ++ ) ; } } trscount = cnt ; } void RuleBasedTimeZone :: deleteRules ( void ) { delete fInitialRule ; fInitialRule = NULL ; if ( fHistoricRules != NULL ) { while ( ! fHistoricRules -> isEmpty ( ) ) { delete ( TimeZoneRule * ) ( fHistoricRules -> orphanElementAt ( 0 ) ) ; } delete fHistoricRules ; fHistoricRules = NULL ; } if ( fFinalRules != NULL ) { while ( ! fFinalRules -> isEmpty ( ) ) { delete ( AnnualTimeZoneRule * ) ( fFinalRules -> orphanElementAt ( 0 ) ) ; } delete fFinalRules ; fFinalRules = NULL ; } } void RuleBasedTimeZone :: deleteTransitions ( void ) { if ( fHistoricTransitions != NULL ) { while ( ! fHistoricTransitions -> isEmpty ( ) ) { Transition * trs = ( Transition * ) fHistoricTransitions -> orphanElementAt ( 0 ) ; uprv_free ( trs ) ; } delete fHistoricTransitions ; } fHistoricTransitions = NULL ; } UVector * RuleBasedTimeZone :: copyRules ( UVector * source ) { if ( source == NULL ) { return NULL ; } UErrorCode ec = U_ZERO_ERROR ; int32_t size = source -> size ( ) ; UVector * rules = new UVector ( size , ec ) ; if ( U_FAILURE ( ec ) ) { return NULL ; } int32_t i ; for ( i = 0 ; i < size ; i ++ ) { rules -> addElement ( ( ( TimeZoneRule * ) source -> elementAt ( i ) ) -> clone ( ) , ec ) ; if ( U_FAILURE ( ec ) ) { break ; } } if ( U_FAILURE ( ec ) ) { for ( i = 0 ; i < rules -> size ( ) ; i ++ ) { TimeZoneRule * rule = ( TimeZoneRule * ) rules -> orphanElementAt ( i ) ; delete rule ; } delete rules ; return NULL ; } return rules ; } TimeZoneRule * RuleBasedTimeZone :: findRuleInFinal ( UDate date , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { if ( fFinalRules == NULL ) { return NULL ; } AnnualTimeZoneRule * fr0 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; AnnualTimeZoneRule * fr1 = ( AnnualTimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; if ( fr0 == NULL || fr1 == NULL ) { return NULL ; } UDate start0 , start1 ; UDate base ; int32_t localDelta ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail0 = fr0 -> getPreviousStart ( base , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , TRUE , start0 ) ; base = date ; if ( local ) { localDelta = getLocalDelta ( fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , fr1 -> getRawOffset ( ) , fr1 -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; base -= localDelta ; } UBool avail1 = fr1 -> getPreviousStart ( base , fr0 -> getRawOffset ( ) , fr0 -> getDSTSavings ( ) , TRUE , start1 ) ; if ( avail0 && ( ! avail1 || start0 > start1 ) ) { return fr0 ; } else if ( avail1 ) { return fr1 ; } return NULL ; } UBool RuleBasedTimeZone :: findNext ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool isFinal = FALSE ; UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( tt > base || ( inclusive && tt == base ) ) { result = * tzt ; found = TRUE ; } else { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt <= base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getNextStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getNextStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 < start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } isFinal = TRUE ; found = TRUE ; } } else { idx -- ; Transition * prev = tzt ; while ( idx > 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( ! inclusive && tt == base ) ) { break ; } idx -- ; prev = tzt ; } result . time = prev -> time ; result . from = prev -> from ; result . to = prev -> to ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { if ( isFinal ) { return FALSE ; } else { return findNext ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UBool RuleBasedTimeZone :: findPrev ( UDate base , UBool inclusive , UDate & transitionTime , TimeZoneRule * & fromRule , TimeZoneRule * & toRule ) const { if ( fHistoricTransitions == NULL ) { return FALSE ; } UBool found = FALSE ; Transition result ; Transition * tzt = ( Transition * ) fHistoricTransitions -> elementAt ( 0 ) ; UDate tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { int32_t idx = fHistoricTransitions -> size ( ) - 1 ; tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( inclusive && tt == base ) { result = * tzt ; found = TRUE ; } else if ( tt < base ) { if ( fFinalRules != NULL ) { TimeZoneRule * r0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * r1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate start0 , start1 ; UBool avail0 = r0 -> getPreviousStart ( base , r1 -> getRawOffset ( ) , r1 -> getDSTSavings ( ) , inclusive , start0 ) ; UBool avail1 = r1 -> getPreviousStart ( base , r0 -> getRawOffset ( ) , r0 -> getDSTSavings ( ) , inclusive , start1 ) ; if ( ! avail0 && ! avail1 ) { return FALSE ; } if ( ! avail1 || start0 > start1 ) { result . time = start0 ; result . from = r1 ; result . to = r0 ; } else { result . time = start1 ; result . from = r0 ; result . to = r1 ; } } else { result = * tzt ; } found = TRUE ; } else { idx -- ; while ( idx >= 0 ) { tzt = ( Transition * ) fHistoricTransitions -> elementAt ( idx ) ; tt = tzt -> time ; if ( tt < base || ( inclusive && tt == base ) ) { break ; } idx -- ; } result = * tzt ; found = TRUE ; } } if ( found ) { if ( result . from -> getRawOffset ( ) == result . to -> getRawOffset ( ) && result . from -> getDSTSavings ( ) == result . to -> getDSTSavings ( ) ) { return findPrev ( result . time , FALSE , transitionTime , fromRule , toRule ) ; } transitionTime = result . time ; fromRule = result . from ; toRule = result . to ; return TRUE ; } return FALSE ; } UDate RuleBasedTimeZone :: getTransitionTime ( Transition * transition , UBool local , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { UDate time = transition -> time ; if ( local ) { time += getLocalDelta ( transition -> from -> getRawOffset ( ) , transition -> from -> getDSTSavings ( ) , transition -> to -> getRawOffset ( ) , transition -> to -> getDSTSavings ( ) , NonExistingTimeOpt , DuplicatedTimeOpt ) ; } return time ; } int32_t RuleBasedTimeZone :: getLocalDelta ( int32_t rawBefore , int32_t dstBefore , int32_t rawAfter , int32_t dstAfter , int32_t NonExistingTimeOpt , int32_t DuplicatedTimeOpt ) const { int32_t delta = 0 ; int32_t offsetBefore = rawBefore + dstBefore ; int32_t offsetAfter = rawAfter + dstAfter ; UBool dstToStd = ( dstBefore != 0 ) && ( dstAfter == 0 ) ; UBool stdToDst = ( dstBefore == 0 ) && ( dstAfter != 0 ) ; if ( offsetAfter - offsetBefore >= 0 ) { if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetBefore ; } else if ( ( ( NonExistingTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( NonExistingTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetAfter ; } else if ( ( NonExistingTimeOpt & kFormerLatterMask ) == kLatter ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } else { if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && dstToStd ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && stdToDst ) ) { delta = offsetAfter ; } else if ( ( ( DuplicatedTimeOpt & kStdDstMask ) == kStandard && stdToDst ) || ( ( DuplicatedTimeOpt & kStdDstMask ) == kDaylight && dstToStd ) ) { delta = offsetBefore ; } else if ( ( DuplicatedTimeOpt & kFormerLatterMask ) == kFormer ) { delta = offsetBefore ; } else { delta = offsetAfter ; } } return delta ; } U_NAMESPACE_END # endif </DOCUMENT>
<DOCUMENT_ID="na@@ wawi/@@ wkh@@ tml@@ topd@@ f/tree/master/@@ webkit/Source/WebCore/@@ bindings/@@ js/@@ JSDocument@@ Cust@@ om.cpp"> # include " config . h " # include " JSDocument . h " # include " ExceptionCode . h " # include " Frame . h " # include " FrameLoader . h " # include " HTMLDocument . h " # include " JSCan@@ vas@@ RenderingContext@@ 2D . h " # if ENABLE ( WEBGL ) # include " JSWeb@@ GLRenderingContext . h " # endif # include " JSDOMWindowCustom . h " # include " JSHTMLDocument . h " # include " JSLocation . h " # include " JSTouch . h " # include " JSTouchList . h " # include " Location . h " # include " ScriptController . h " # include " TouchList . h " # if ENABLE ( SVG ) # include " JSSVGDocument . h " # include " SVGDocument . h " # endif # include < wtf / GetPtr . h > using namespace JSC ; namespace WebCore { JSValue JSDocument :: location ( ExecState * exec ) const { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return jsNull ( ) ; Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ; if ( JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , location ) ) return wrapper ; JSLocation * jsLocation = JSLocation :: create ( getDOM@@ Structure < JSLocation > ( exec , globalObject ( ) ) , globalObject ( ) , location ) ; cacheWrapper ( currentWorld ( exec ) , location , jsLocation ) ; return jsLocation ; } void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> had@@ Exception ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setH@@ ref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; } JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOM@@ Window ( toJS ( exec , domWindow ) ) ; wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; # if ENABLE ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; # endif else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverse@@ NextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> report@@ Extra@@ MemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; } # if ENABLE ( TOUCH_@@ EVENTS ) JSValue JSDocument :: createTouchList ( ExecState * exec ) { RefPtr < TouchList > touchList = TouchList :: create ( ) ; for ( size_t i = 0 ; i < exec -> argument@@ Count ( ) ; i ++ ) touchList -> append ( toTouch ( exec -> argument ( i ) ) ) ; return toJS ( exec , globalObject ( ) , touchList . release ( ) ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="JIg@@ ht@@ use/function@@ al-cpp@@ /tree/master/src/function@@ al_objects/@@ company@@ .cpp"> # include < company . h > # include < algorithm > class lambda_implementation { public : lambda_implementation ( const Company * _this , const std :: string & teamName ) : m_this { _this } , m_teamName { teamName } { } bool operator ( ) ( const Person & employee ) const { return m_this -> teamNameFor ( employee ) == m_teamName ; } private : const Company * m_this ; const std :: string & m_teamName ; } ; int Company :: countTeamMembers ( const std :: string & teamName ) const { return std :: count_if ( m_employees . cbegin ( ) , m_employees . cend ( ) , [ this , & teamName ] ( const Person & p ) { return teamNameFor ( p ) == teamName ; } ) ; } std :: string Company :: teamNameFor ( const Person & ) const { return " some " ; } </DOCUMENT>
<DOCUMENT_ID="verybad@@ soldier/@@ xbmc/tree/master/xbmc/@@ visualization@@ s/Vort@@ ex/angelscript@@ /angelscript@@ /source/@@ as_scriptengine@@ .cpp"> # include < stdlib . h > # include " as _ config . h " # include " as _ scriptengine . h " # include " as _ builder . h " # include " as _ context . h " # include " as _ string _ util . h " # include " as _ tokenizer . h " # include " as _ texts . h " # include " as _ module . h " # include " as _ callfunc . h " # include " as _ arrayobject . h " # include " as _ generic . h " # include " as _ scriptobject . h " # include " as _ compiler . h " BEGIN_AS_NAMESPACE extern " C " { AS_API const char * asGetLibrary@@ Version ( ) { # ifdef _DEBUG return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; # else return ANGELSCRIPT_VERSION_STRING ; # endif } AS_API const char * asGetLibrary@@ Options ( ) { const char * string = " ▁ " # ifdef AS_MAX_PORTABILITY " AS _ MAX _ PORTABILITY ▁ " # endif # ifdef AS_DEBUG " AS _ DEBUG ▁ " # endif # ifdef AS_NO_CLASS_METHODS " AS _ NO _ CLASS _ METHODS ▁ " # endif # ifdef AS_USE_@@ DOUBLE_@@ AS_FLOAT " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " # endif # ifdef AS_64BIT_@@ PTR " AS _ 64BIT _ PTR ▁ " # endif # ifdef AS_NO_THREADS " AS _ NO _ THREADS ▁ " # endif # ifdef AS_NO_ATOMIC " AS _ NO _ ATOMIC ▁ " # endif # ifdef AS_WI@@ N " AS _ WIN ▁ " # endif # ifdef AS_LINUX " AS _ LINUX ▁ " # endif # ifdef AS_MAC " AS _ MAC ▁ " # endif # ifdef AS_BSD " AS _ BSD ▁ " # endif # ifdef AS_XBOX " AS _ XBOX ▁ " # endif # ifdef AS_XBOX360 " AS _ XBOX360 ▁ " # endif # ifdef AS_PS@@ P " AS _ PSP ▁ " # endif # ifdef AS_PS@@ 2 " AS _ PS2 ▁ " # endif # ifdef AS_PS@@ 3 " AS _ PS3 ▁ " # endif # ifdef AS_DC " AS _ DC ▁ " # endif # ifdef AS_GC " AS _ GC ▁ " # endif # ifdef AS_WI@@ I " AS _ WII ▁ " # endif # ifdef AS_IPHONE " AS _ IPHONE ▁ " # endif # ifdef AS_ANDROID " AS _ ANDROID ▁ " # endif # ifdef AS_PPC " AS _ PPC ▁ " # endif # ifdef AS_PP@@ C_64 " AS _ PPC _ 64 ▁ " # endif # ifdef AS_X86 " AS _ X86 ▁ " # endif # ifdef AS_MIPS " AS _ MIPS ▁ " # endif # ifdef AS_SH@@ 4 " AS _ SH4 ▁ " # endif # ifdef AS_XENON " AS _ XEN@@ ON ▁ " # endif # ifdef AS_ARM " AS _ ARM ▁ " # endif ; return string ; } AS_API asIScriptEngine * asCreate@@ ScriptEngine ( asDWORD version ) { if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; asASSERT ( sizeof ( bool ) == AS_SIZEOF_@@ BOOL ) ; asASSERT ( true == VALUE_@@ OF_BOOLEAN_@@ TRUE ) ; # ifdef AS_BIG_EN@@ DIAN asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x000@@ 10203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x000@@ 1020@@ 304050@@ 607 ) ) ; # else asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x07060@@ 504030@@ 20100 ) ) ; # endif return asNEW ( asCScriptEngine ) ( ) ; } int asCScriptEngine :: SetEngineProperty ( asEEngineProp property , asPWORD value ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : ep . allowUnsafeReferences = value ? true : false ; break ; case asEP_OPTIMIZE_BYTECODE : ep . optimizeByteCode = value ? true : false ; break ; case asEP_COPY_SCRIPT_SECTIONS : ep . copyScriptSections = value ? true : false ; break ; case asEP_MAX_STACK_SIZE : ep . maximumContextStackSize = ( int ) value / 4 ; if ( initialContextStackSize > ep . maximumContextStackSize ) initialContextStackSize = ep . maximumContextStackSize ; break ; case asEP_USE_CHARACTER_LITERALS : ep . useCharacterLiterals = value ? true : false ; break ; case asEP_ALLOW_MULTILINE_STRINGS : ep . allowMultilineStrings = value ? true : false ; break ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : ep . allowImplicitHandleTypes = value ? true : false ; break ; case asEP_BUILD_WITHOUT_LINE_CUES : ep . buildWithoutLineCues = value ? true : false ; break ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : ep . initGlobalVarsAfterBuild = value ? true : false ; break ; case asEP_REQUIRE_ENUM_SCOPE : ep . requireEnumScope = value ? true : false ; break ; case asEP_SCRIPT_SCANNER : if ( value <= 1 ) ep . scanner = ( int ) value ; else return asINVALID_ARG ; break ; case asEP_INCLUDE_JIT_INSTRUCTIONS : ep . includeJitInstructions = value ? true : false ; break ; case asEP_STRING_ENCODING : if ( value <= 1 ) ep . stringEncoding = ( int ) value ; else return asINVALID_ARG ; break ; default : return asINVALID_ARG ; } return asSUCCESS ; } asPWORD asCScriptEngine :: GetEngineProperty ( asEEngineProp property ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : return ep . allowUnsafeReferences ; case asEP_OPTIMIZE_BYTECODE : return ep . optimizeByteCode ; case asEP_COPY_SCRIPT_SECTIONS : return ep . copyScriptSections ; case asEP_MAX_STACK_SIZE : return ep . maximumContextStackSize * 4 ; case asEP_USE_CHARACTER_LITERALS : return ep . useCharacterLiterals ; case asEP_ALLOW_MULTILINE_STRINGS : return ep . allowMultilineStrings ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : return ep . allowImplicitHandleTypes ; case asEP_BUILD_WITHOUT_LINE_CUES : return ep . buildWithoutLineCues ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : return ep . initGlobalVarsAfterBuild ; case asEP_REQUIRE_ENUM_SCOPE : return ep . requireEnumScope ; case asEP_SCRIPT_SCANNER : return ep . scanner ; case asEP_INCLUDE_JIT_INSTRUCTIONS : return ep . includeJitInstructions ; case asEP_STRING_ENCODING : return ep . stringEncoding ; } return 0 ; } } asCScriptEngine :: asCScriptEngine ( ) { if ( threadManager == 0 ) threadManager = asNEW ( asCThread@@ Manager ) ; else threadManager -> AddRef ( ) ; ep . allowUnsafeReferences = false ; ep . optimizeByteCode = true ; ep . copyScriptSections = true ; ep . maximumContextStackSize = 0 ; ep . useCharacterLiterals = false ; ep . allowMultilineStrings = false ; ep . allowImplicitHandleTypes = false ; ep . buildWithoutLineCues = false ; ep . initGlobalVarsAfterBuild = true ; ep . requireEnumScope = false ; ep . scanner = 1 ; ep . includeJitInstructions = false ; ep . stringEncoding = 0 ; gc . engine = this ; refCount . set ( 1 ) ; stringFactory = 0 ; configFailed = false ; isPrepared = false ; isBuilding = false ; lastModule = 0 ; userData = 0 ; initialContextStackSize = 1024 ; typeIdSeqNbr = 0 ; currentGroup = & defaultGroup ; msgCallback = 0 ; jitCompiler = 0 ; scriptFunctions . PushLast ( 0 ) ; int id ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ; asASSERT ( id == asTYPEID_VO@@ ID ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ; asASSERT ( id == asTYPEID_BOOL ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt8 , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt16 , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt64 , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt8 , false ) ) ; asASSERT ( id == asTYPEID_UINT@@ 8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt16 , false ) ) ; asASSERT ( id == asTYPEID_UINT@@ 16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt , false ) ) ; asASSERT ( id == asTYPEID_UINT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt64 , false ) ) ; asASSERT ( id == asTYPEID_UINT@@ 64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttFloat , false ) ) ; asASSERT ( id == asTYPE@@ ID_FLOAT ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttDouble , false ) ) ; asASSERT ( id == asTYPEID_DOUBLE ) ; defaultArrayObjectType = 0 ; RegisterArray@@ Object ( this ) ; RegisterScriptObject ( this ) ; RegisterScriptFunction ( this ) ; RegisterObject@@ TypeGC@@ Behaviours ( this ) ; } asCScriptEngine :: ~ asCScriptEngine ( ) { asASSERT ( refCount . get ( ) == 0 ) ; asUINT n ; for ( n = ( asUINT ) scriptModules . GetLength ( ) ; n -- > 0 ; ) { if ( scriptModules [ n ] ) { asDELETE ( scriptModules [ n ] , asCModule ) ; } } scriptModules . SetLength ( 0 ) ; GarbageCollect ( asGC_FULL_CYCLE ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { asUINT f ; for ( f = 0 ; f < templateTypes [ n ] -> beh . factories . GetLength ( ) ; f ++ ) { scriptFunctions [ templateTypes [ n ] -> beh . factories [ f ] ] -> Release ( ) ; } templateTypes [ n ] -> beh . factories . Allocate ( 0 , false ) ; for ( f = 1 ; f < templateTypes [ n ] -> beh . operators . GetLength ( ) ; f += 2 ) { if ( scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> objectType == templateTypes [ n ] ) { scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> Release ( ) ; templateTypes [ n ] -> beh . operators [ f ] = 0 ; } } } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; for ( n = 0 ; n < classTypes . GetLength ( ) ; n ++ ) { if ( classTypes [ n ] ) classTypes [ n ] -> ReleaseAllFunctions ( ) ; if ( classTypes [ n ] -> derivedFrom ) { classTypes [ n ] -> derivedFrom -> Release ( ) ; classTypes [ n ] -> derivedFrom = 0 ; } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; asSMapNode < int , asCDataType * > * cursor = 0 ; while ( mapTypeIdToDataType . MoveFirst ( & cursor ) ) { asDELETE ( mapTypeIdToDataType . GetValue ( cursor ) , asCDataType ) ; mapTypeIdToDataType . Erase ( cursor ) ; } defaultGroup . RemoveConfiguration ( this ) ; while ( configGroups . GetLength ( ) ) { asCConfigGroup * grp = configGroups . PopLast ( ) ; if ( grp ) { asDELETE ( grp , asCConfigGroup ) ; } } for ( n = 0 ; n < registeredGlobalProps . GetLength ( ) ; n ++ ) { if ( registeredGlobalProps [ n ] ) { asDELETE ( registeredGlobalProps [ n ] , asCGlobalProperty ) ; } } registeredGlobalProps . SetLength ( 0 ) ; FreeUnusedGlobalProperties ( ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { templateTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( templateTypes [ n ] , asCObjectType ) ; } } templateTypes . SetLength ( 0 ) ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] ) { objectTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( objectTypes [ n ] , asCObjectType ) ; } } objectTypes . SetLength ( 0 ) ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] ) { asDELETE ( templateSubTypes [ n ] , asCObjectType ) ; } } templateSubTypes . SetLength ( 0 ) ; registeredTypeDefs . SetLength ( 0 ) ; registeredEnums . SetLength ( 0 ) ; registeredObjTypes . SetLength ( 0 ) ; for ( n = 0 ; n < registeredGlobalFuncs . GetLength ( ) ; n ++ ) { if ( registeredGlobalFuncs [ n ] ) registeredGlobalFuncs [ n ] -> Release ( ) ; } registeredGlobalFuncs . SetLength ( 0 ) ; scriptTypeBehaviours . ReleaseAllFunctions ( ) ; functionBehaviours . ReleaseAllFunctions ( ) ; objectTypeBehaviours . ReleaseAllFunctions ( ) ; for ( n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { asDELETE ( stringConstants [ n ] , asCString ) ; } stringConstants . SetLength ( 0 ) ; for ( n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { asDELETE ( scriptSectionNames [ n ] , asCString ) ; } scriptSectionNames . SetLength ( 0 ) ; threadManager -> Release ( ) ; } int asCScriptEngine :: AddRef ( ) { return refCount . atomic@@ Inc ( ) ; } int asCScriptEngine :: Release ( ) { int r = refCount . atomic@@ Dec ( ) ; if ( r == 0 ) { asDELETE ( this , asCScriptEngine ) ; return 0 ; } return r ; } void * asCScriptEngine :: SetUserData ( void * data ) { void * old = userData ; userData = data ; return old ; } void * asCScriptEngine :: GetUserData ( ) { return userData ; } int asCScriptEngine :: SetMessageCallback ( const asSFuncPtr & callback , void * obj , asDWORD callConv ) { msgCallback = true ; msgCallbackObj = obj ; bool isObj = false ; if ( ( unsigned ) callConv == asCALL_GENERIC ) { msgCallback = false ; return asNOT_SUPPORTED ; } if ( ( unsigned ) callConv >= asCALL_THISCALL ) { isObj = true ; if ( obj == 0 ) { msgCallback = false ; return asINVALID_ARG ; } } int r = DetectCallingConvention ( isObj , callback , callConv , & msgCallbackFunc ) ; if ( r < 0 ) msgCallback = false ; return r ; } int asCScriptEngine :: ClearMessageCallback ( ) { msgCallback = false ; return 0 ; } int asCScriptEngine :: WriteMessage ( const char * section , int row , int col , asEMsg@@ Type type , const char * message ) { if ( section == 0 || message == 0 ) return asINVALID_ARG ; if ( ! msgCallback ) return 0 ; asSMessageInfo msg ; msg . section = section ; msg . row = row ; msg . col = col ; msg . type = type ; msg . message = message ; if ( msgCallbackFunc . callConv < ICC_THISCALL ) CallGlobalFunction ( & msg , msgCallbackObj , & msgCallbackFunc , 0 ) ; else CallObjectMethod ( msgCallbackObj , & msg , & msgCallbackFunc , 0 ) ; return 0 ; } int asCScriptEngine :: SetJITCompiler ( asIJITCompiler * compiler ) { jitCompiler = compiler ; return asSUCCESS ; } asIJITCompiler * asCScriptEngine :: GetJITCompiler ( ) { return jitCompiler ; } asETokenClass asCScriptEngine :: ParseToken ( const char * string , size_t stringLength , int * tokenLength ) { if ( stringLength == 0 ) stringLength = strlen ( string ) ; size_t len ; asCTokenizer t ; asETokenClass tc ; t . GetToken ( string , stringLength , & len , & tc ) ; if ( tokenLength ) * tokenLength = ( int ) len ; return tc ; } asIScriptModule * asCScriptEngine :: GetModule ( const char * module , asEGM@@ Flags flag ) { asCModule * mod = GetModule ( module , false ) ; if ( flag == asGM_@@ ALWAYS_CREATE ) { if ( mod != 0 ) { asDELETE ( mod , asCModule ) ; } return GetModule ( module , true ) ; } if ( mod == 0 && flag == asGM_@@ CREATE_IF_NOT_EXI@@ STS ) { return GetModule ( module , true ) ; } return mod ; } int asCScriptEngine :: DiscardModule ( const char * module ) { asCModule * mod = GetModule ( module , false ) ; if ( mod == 0 ) return asNO_@@ MODULE ; asDELETE ( mod , asCModule ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; return 0 ; } void asCScriptEngine :: ClearUnusedTypes ( ) { asCArray < asCObjectType * > types ; types = classTypes ; types . Concat@@ enate ( templateInstanceTypes ) ; asUINT n ; for ( n = 0 ; n < scriptModules . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCModule * mod = scriptModules [ n ] ; if ( mod ) { asUINT m ; for ( m = 0 ; m < mod -> classTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> classTypes [ m ] ) ; for ( m = 0 ; m < mod -> enumTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> enumTypes [ m ] ) ; for ( m = 0 ; m < mod -> typeDefs . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> typeDefs [ m ] ) ; } } for ( n = 0 ; n < scriptFunctions . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCScriptFunction * func = scriptFunctions [ n ] ; if ( func ) { if ( func -> name == " factstub " ) continue ; asCObjectType * ot = func -> returnType . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { ot = func -> parameterTypes [ p ] . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; } } } for ( n = 0 ; n < globalProperties . GetLength ( ) && types . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> type . GetObjectType ( ) ) RemoveTypeAndRelatedFromList ( types , globalProperties [ n ] -> type . GetObjectType ( ) ) ; } for ( ; ; ) { bool didClearTemplateInstanceType = false ; for ( n = 0 ; n < types . GetLength ( ) ; n ++ ) { int refCount = ( ( types [ n ] -> flags & asOBJ_TEMPLATE ) || ( types [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) ? 2 * ( int ) types [ n ] -> beh . factories . GetLength ( ) : 0 ; if ( types [ n ] -> GetRefCount ( ) == refCount ) { if ( types [ n ] -> flags & asOBJ_TEMPLATE ) { didClearTemplateInstanceType = true ; RemoveTemplateInstanceType ( types [ n ] ) ; } else { RemoveFromTypeIdMap ( types [ n ] ) ; asDELETE ( types [ n ] , asCObjectType ) ; int i = classTypes . IndexOf ( types [ n ] ) ; if ( i == ( signed ) classTypes . GetLength ( ) - 1 ) classTypes . PopLast ( ) ; else classTypes [ i ] = classTypes . PopLast ( ) ; } if ( n < types . GetLength ( ) - 1 ) types [ n ] = types . PopLast ( ) ; else types . PopLast ( ) ; n -- ; } } if ( didClearTemplateInstanceType == false ) break ; } } void asCScriptEngine :: RemoveTypeAndRelatedFromList ( asCArray < asCObjectType * > & types , asCObjectType * ot ) { int i = types . IndexOf ( ot ) ; if ( i == - 1 ) return ; if ( i == ( signed ) types . GetLength ( ) - 1 ) types . PopLast ( ) ; else types [ i ] = types . PopLast ( ) ; if ( ot -> templateSubType . GetObjectType ( ) ) { while ( ot -> templateSubType . GetObjectType ( ) ) { ot = ot -> templateSubType . GetObjectType ( ) ; RemoveTypeAndRelatedFromList ( types , ot ) ; } return ; } if ( ot -> properties . GetLength ( ) ) { for ( asUINT n = 0 ; n < ot -> properties . GetLength ( ) ; n ++ ) RemoveTypeAndRelatedFromList ( types , ot -> properties [ n ] -> type . GetObjectType ( ) ) ; } } int asCScriptEngine :: GetFactory@@ IdByDecl ( const asCObjectType * ot , const char * decl ) { asCModule * mod = 0 ; if ( ot -> flags & asOBJ_SCRIPT_OBJECT && ot -> size > 0 ) mod = scriptFunctions [ ot -> beh . factory ] -> module ; asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> beh . factories . GetLength ( ) ; n ++ ) { asCScriptFunction * f = scriptFunctions [ ot -> beh . factories [ n ] ] ; if ( f -> IsSignatureEqual ( & func ) ) { id = ot -> beh . factories [ n ] ; break ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } int asCScriptEngine :: GetMethod@@ IdByDecl ( const asCObjectType * ot , const char * decl , asCModule * mod ) { asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; func . objectType = const_cast < asCObjectType * > ( ot ) ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> methods . GetLength ( ) ; ++ n ) { if ( func . IsSignatureEqual ( scriptFunctions [ ot -> methods [ n ] ] ) ) { if ( id == - 1 ) id = ot -> methods [ n ] ; else return asMULTIP@@ LE_FUNC@@ TIONS ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; } asCString asCScriptEngine :: GetFunctionDeclaration ( int funcID ) { asCString str ; asCScriptFunction * func = GetScriptFunction ( funcID ) ; if ( func ) str = func -> GetDeclar@@ ationStr ( ) ; return str ; } asCScriptFunction * asCScriptEngine :: GetScriptFunction ( int funcId ) { if ( funcId < 0 || funcId >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; return scriptFunctions [ funcId ] ; } asIScriptContext * asCScriptEngine :: CreateContext ( ) { asIScriptContext * ctx = 0 ; CreateContext ( & ctx , false ) ; return ctx ; } int asCScriptEngine :: CreateContext ( asIScriptContext * * context , bool isInternal ) { * context = asNEW ( asCContext ) ( this , ! isInternal ) ; PrepareEngine ( ) ; return 0 ; } int asCScriptEngine :: RegisterObject@@ Property ( const char * obj , const char * declaration , int byteOffset ) { int r ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( currentGroup -> FindType ( dt . GetObjectType ( ) -> name . AddressOf ( ) ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType type ; asCString name ; if ( ( r = bld . VerifyProperty ( & dt , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_OBJECT ) ; asCObjectProperty * prop = asNEW ( asCObjectProperty ) ; prop -> name = name ; prop -> type = type ; prop -> byteOffset = byteOffset ; dt . GetObjectType ( ) -> properties . PushLast ( prop ) ; currentGroup -> RefConfigGroup ( FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterface ( const char * name ) { if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; } asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; st -> flags = asOBJ_REF | asOBJ_SCRIPT_OBJECT ; st -> size = 0 ; st -> name = name ; st -> beh . factory = 0 ; st -> beh . addref = scriptTypeBehaviours . beh . addref ; scriptFunctions [ st -> beh . addref ] -> AddRef ( ) ; st -> beh . release = scriptTypeBehaviours . beh . release ; scriptFunctions [ st -> beh . release ] -> AddRef ( ) ; st -> beh . copy = 0 ; objectTypes . PushLast ( st ) ; registeredObjTypes . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterInterface@@ Method ( const char * intf , const char * declaration ) { if ( currentGroup -> FindType ( intf ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( intf , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_@@ INTERFACE ) ; func -> objectType = dt . GetObjectType ( ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , false ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflictMember ( dt , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; func -> objectType -> methods . PushLast ( func -> id ) ; func -> ComputeSignature@@ Id ( ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: RegisterObjectType ( const char * name , int byteSize , asDWORD flags ) { int r ; isPrepared = false ; if ( flags & asOBJ_REF ) { if ( flags & ~ ( asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_GC ) && ( flags & ( asOBJ_NOHANDLE | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_NOHANDLE ) && ( flags & ( asOBJ_GC | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_SCOPED ) && ( flags & ( asOBJ_GC | asOBJ_NOHANDLE ) ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_VALUE ) { if ( flags & ( asOBJ_REF | asOBJ_GC | asOBJ_SCOPED ) ) return ConfigError ( asINVALID_ARG ) ; if ( flags & asOBJ_APP_CLASS ) { if ( flags & ( asOBJ_APP_PRIMITIVE | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_PRIMITIVE ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_FLOAT ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_PRIMITIVE ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & ( asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT ) ) { return ConfigError ( asINVALID_ARG ) ; } } else return ConfigError ( asINVALID_ARG ) ; if ( flags - ( flags & asOBJ_MAS@@ K_VAL@@ ID_FLA@@ GS ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_VALUE ) && byteSize == 0 ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_VALUE_@@ TYPE_MU@@ ST_HAVE_@@ SIZE ) ; return ConfigError ( asINVALID_ARG ) ; } if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asCString typeName ; asCBuilder bld ( this , 0 ) ; if ( flags & asOBJ_TEMPLATE ) { asCString subtypeName ; r = bld . ParseTemplate@@ Decl ( name , & typeName , & subtypeName ) ; if ( r < 0 ) return r ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; asCObjectType * subtype = 0 ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] -> name == subtypeName ) { subtype = templateSubTypes [ n ] ; break ; } } if ( subtype == 0 ) { subtype = asNEW ( asCObjectType ) ( this ) ; subtype -> name = subtypeName ; subtype -> size = 0 ; subtype -> flags = asOBJ_TEMPLATE_@@ SUBTYPE ; templateSubTypes . PushLast ( subtype ) ; subtype -> AddRef ( ) ; } type -> templateSubType = asCDataType :: CreateObject ( subtype , false ) ; subtype -> AddRef ( ) ; currentGroup -> objTypes . PushLast ( type ) ; if ( defaultArrayObjectType == 0 ) { defaultArrayObjectType = type ; type -> AddRef ( ) ; } else { registeredObjTypes . PushLast ( type ) ; } } else { typeName = name ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * mostRecentTemplateInstanceType = 0 ; if ( templateInstanceTypes . GetLength ( ) ) mostRecentTemplateInstanceType = templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] ; asCDataType dt ; bool oldMsgCallback = msgCallback ; msgCallback = false ; r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r < 0 ) { asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , typeName . GetLength ( ) , & tokenLen ) ; if ( token != ttIdentifier || typeName . GetLength ( ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; int r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; registeredObjTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; } else { if ( dt . GetSubType ( ) . IsTemplate ( ) ) return ConfigError ( asLO@@ WER_ARRAY_@@ DIMENSION_@@ NOT_REGISTERED ) ; if ( dt . IsReadOnly ( ) || dt . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; if ( templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] == mostRecentTemplateInstanceType || mostRecentTemplateInstanceType == dt . GetObjectType ( ) ) return ConfigError ( asNOT_SUPPORTED ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = dt . GetObjectType ( ) -> name ; type -> templateSubType = dt . GetSubType ( ) ; if ( type -> templateSubType . GetObjectType ( ) ) type -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; type -> size = byteSize ; type -> flags = flags ; templateTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; RemoveTemplateInstanceType ( dt . GetObjectType ( ) ) ; } } return asSUCCESS ; } int asCScriptEngine :: RegisterObject@@ Behaviour ( const char * datatype , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( datatype == 0 ) return ConfigError ( asINVALID_ARG ) ; asCBuilder bld ( this , 0 ) ; asCDataType type ; int r = bld . ParseDataType ( datatype , & type ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( type . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_TYPE ) ; if ( type . IsReadOnly ( ) || type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; return RegisterBehaviourToObjectType ( type . GetObjectType ( ) , behaviour , decl , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterBehaviourToObjectType ( asCObjectType * objectType , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; if ( behaviour == asBEHAVE_FACTORY || behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } else { # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } isPrepared = false ; asST@@ ypeBehaviour * beh = & objectType -> beh ; asCScriptFunction func ( this , 0 , - 1 ) ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseFunctionDeclaration ( objectType , decl , & func , true , & internal . paramAutoHandles , & internal . returnAutoHandle ) ; if ( r < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . name . Format ( " _ beh _ % d _ " , behaviour ) ; if ( behaviour != asBEHAVE_FACTORY ) func . objectType = objectType ; if ( objectType -> flags & asOBJ_TEMPLATE ) { if ( func . returnType . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . returnType . IsObjectHandle ( ) ) objectType -> acceptValueSubType = false ; else if ( ! func . returnType . IsReference ( ) ) objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { if ( func . parameterTypes [ n ] . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . parameterTypes [ n ] . IsObjectHandle ( ) || ( func . parameterTypes [ n ] . IsReference ( ) && func . inOutFlags [ n ] == asTM_INOUTREF ) ) objectType -> acceptValueSubType = false ; else if ( ! func . parameterTypes [ n ] . IsReference ( ) ) objectType -> acceptRefSubType = false ; } } } if ( behaviour == asBEHAVE_CONSTR@@ UCT ) { if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( objectType -> flags & asOBJ_SCRIPT_OBJECT ) { asASSERT ( func . parameterTypes . GetLength ( ) == 1 ) ; beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> factory = beh -> construct ; scriptFunctions [ beh -> factory ] -> AddRef ( ) ; beh -> constructors . PushLast ( beh -> construct ) ; beh -> factories . PushLast ( beh -> factory ) ; func . id = beh -> construct ; } else { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . parameterTypes . GetLength ( ) == 0 ) { func . id = beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( beh -> construct ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( func . id ) ; } } } else if ( behaviour == asBEHAVE_DESTRUC@@ T ) { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> destruct ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> destruct = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_FACTORY ) { if ( ! ( objectType -> flags & asOBJ_REF ) || ( objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . returnType != asCDataType :: CreateObjectHandle ( objectType , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( objectType -> flags & asOBJ_TEMPLATE ) && ( func . parameterTypes . GetLength ( ) == 0 || ! func . parameterTypes [ 0 ] . IsReference ( ) ) ) { return ConfigError ( asINVALID_DECLARATION ) ; } if ( ( func . parameterTypes . GetLength ( ) == 0 ) || ( func . parameterTypes . GetLength ( ) == 1 && ( objectType -> flags & asOBJ_TEMPLATE ) ) ) { func . id = beh -> factory = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( beh -> factory ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( func . id ) ; } } else if ( behaviour == asBEHAVE_ADDREF ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) || ( func . objectType -> flags & asOBJ_SCOPED ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> addref ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> addref = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_RELEAS@@ E ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> release ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> release = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { if ( ! ( func . objectType -> flags & asOBJ_TEMPLATE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> templateCallback ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> templateCallback = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_INDEX ) { if ( VerifyVarTypeNotInFunction ( & func ) < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . GetTokenType ( ) == ttVoid ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour >= asBEHAVE_FIRST_@@ GC && behaviour <= asBEHAVE_LAS@@ T_GC ) { if ( ! ( func . objectType -> flags & asOBJ_GC ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( ( behaviour == asBEHAVE_GETREFCOUNT || behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_GETGCFLAG ) && func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT && func . returnType != asCDataType :: CreatePrimitive ( ttInt , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETGCFLAG && func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT ) func . id = beh -> gcGetRefCount = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_SETGCFLAG ) func . id = beh -> gcSetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_GETGCFLAG ) func . id = beh -> gcGetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_ENUMREFS ) func . id = beh -> gcEnumReferences = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_RELEASEREFS ) func . id = beh -> gcReleaseAllReferences = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_IMPLICIT_@@ VALUE_CAST || behaviour == asBEHAVE_VALUE_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ) return ConfigError ( asNOT_SUPPORTED ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour == asBEHAVE_REF_CAST || behaviour == asBEHAVE_IMPLICIT_@@ REF_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ! func . returnType . IsObjectHandle ( ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else { asASSERT ( false ) ; return ConfigError ( asINVALID_ARG ) ; } return func . id ; } int asCScriptEngine :: VerifyVarTypeNotInFunction ( asCScriptFunction * func ) { if ( func -> returnType . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; for ( unsigned int n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) if ( func -> parameterTypes [ n ] . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; return 0 ; } int asCScriptEngine :: AddBehaviourFunction ( asCScriptFunction & func , asSSystemFunctionInterface & internal ) { asUINT n ; int id = GetNextScriptFunctionId ( ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ; newInterface -> func = internal . func ; newInterface -> baseOffset = internal . baseOffset ; newInterface -> callConv = internal . callConv ; newInterface -> scriptReturnSize = internal . scriptReturnSize ; newInterface -> hostReturnInMemory = internal . hostReturnInMemory ; newInterface -> hostReturnFloat = internal . hostReturnFloat ; newInterface -> hostReturnSize = internal . hostReturnSize ; newInterface -> paramSize = internal . paramSize ; newInterface -> takesObjByVal = internal . takesObjByVal ; newInterface -> paramAutoHandles = internal . paramAutoHandles ; newInterface -> returnAutoHandle = internal . returnAutoHandle ; newInterface -> hasAutoHandles = internal . hasAutoHandles ; asCScriptFunction * f = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; asASSERT ( func . name != " " && func . name != " f " ) ; f -> name = func . name ; f -> sysFuncIntf = newInterface ; f -> returnType = func . returnType ; f -> objectType = func . objectType ; f -> id = id ; f -> isReadOnly = func . isReadOnly ; for ( n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { f -> parameterTypes . PushLast ( func . parameterTypes [ n ] ) ; f -> inOutFlags . PushLast ( func . inOutFlags [ n ] ) ; } SetScriptFunction ( f ) ; if ( f -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( n = 0 ; n < f -> parameterTypes . GetLength ( ) ; n ++ ) { if ( f -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return id ; } int asCScriptEngine :: RegisterGlobalProperty ( const char * declaration , void * pointer ) { asCDataType type ; asCString name ; int r ; asCBuilder bld ( this , 0 ) ; if ( ( r = bld . VerifyProperty ( 0 , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; asCGlobalProperty * prop = AllocateGlobalProperty ( ) ; prop -> name = name ; prop -> type = type ; prop -> SetRegister@@ edAddress ( pointer ) ; registeredGlobalProps . PushLast ( prop ) ; currentGroup -> globalProps . PushLast ( prop ) ; if ( type . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } return asSUCCESS ; } asCGlobalProperty * asCScriptEngine :: AllocateGlobalProperty ( ) { asCGlobalProperty * prop = asNEW ( asCGlobalProperty ) ; if ( freeGlobalPropertyIds . GetLength ( ) ) { prop -> id = freeGlobalPropertyIds . PopLast ( ) ; globalProperties [ prop -> id ] = prop ; return prop ; } prop -> id = ( asUINT ) globalProperties . GetLength ( ) ; globalProperties . PushLast ( prop ) ; return prop ; } void asCScriptEngine :: FreeUnusedGlobalProperties ( ) { for ( asUINT n = 0 ; n < globalProperties . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> refCount . get ( ) == 0 ) { freeGlobalPropertyIds . PushLast ( n ) ; asDELETE ( globalProperties [ n ] , asCGlobalProperty ) ; globalProperties [ n ] = 0 ; } } } int asCScriptEngine :: GetGlobalProperty@@ Count ( ) { return ( int ) registeredGlobalProps . GetLength ( ) ; } int asCScriptEngine :: GetGlobalProperty@@ ByIndex ( asUINT index , const char * * name , int * typeId , bool * isConst , const char * * configGroup , void * * pointer ) { if ( index >= registeredGlobalProps . GetLength ( ) ) return asINVALID_ARG ; if ( name ) * name = registeredGlobalProps [ index ] -> name . AddressOf ( ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForGlobalVar ( index ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( typeId ) * typeId = GetTypeIdFromDataType ( registeredGlobalProps [ index ] -> type ) ; if ( isConst ) * isConst = registeredGlobalProps [ index ] -> type . IsReadOnly ( ) ; if ( pointer ) * pointer = registeredGlobalProps [ index ] -> realAddress ; return asSUCCESS ; } int asCScriptEngine :: RegisterObject@@ Method ( const char * obj , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( obj == 0 ) return ConfigError ( asINVALID_ARG ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_ARG ) ; return RegisterMethodToObjectType ( dt . GetObjectType ( ) , declaration , funcPointer , callConv ) ; } int asCScriptEngine :: RegisterMethodToObjectType ( asCObjectType * objectType , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; func -> objectType = objectType ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } asCDataType x = asCDataType :: CreateObject ( objectType , false ) ; r = bld . CheckNameConflictMember ( x , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; func -> objectType -> methods . PushLast ( func -> id ) ; SetScriptFunction ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } if ( func -> objectType -> flags & asOBJ_TEMPLATE ) { if ( func -> returnType . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> returnType . IsObjectHandle ( ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> returnType . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> parameterTypes [ n ] . IsObjectHandle ( ) || ( func -> parameterTypes [ n ] . IsReference ( ) && func -> inOutFlags [ n ] == asTM_INOUTREF ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> parameterTypes [ n ] . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } } } if ( func -> name == " opAssign " && func -> parameterTypes . GetLength ( ) == 1 && func -> isReadOnly == false && ( objectType -> flags & asOBJ_SCRIPT_OBJECT || func -> parameterTypes [ 0 ] . IsEqualExceptRefAndConst ( asCDataType :: CreateObject ( func -> objectType , false ) ) ) ) { func -> objectType -> beh . copy = func -> id ; func -> AddRef ( ) ; } return func -> id ; } int asCScriptEngine :: RegisterGlobalFunction ( const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( 0 , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflict ( func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; currentGroup -> scriptFunctions . PushLast ( func ) ; registeredGlobalFuncs . PushLast ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; } int asCScriptEngine :: GetGlobalFunction@@ Count ( ) { return ( int ) registeredGlobalFuncs . GetLength ( ) ; } int asCScriptEngine :: GetGlobalFunction@@ IdByIndex ( asUINT index ) { if ( index >= registeredGlobalFuncs . GetLength ( ) ) return asINVALID_ARG ; return registeredGlobalFuncs [ index ] -> id ; } asCObjectType * asCScriptEngine :: GetObjectType ( const char * type ) { for ( asUINT n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return objectTypes [ n ] ; return 0 ; } void asCScriptEngine :: PrepareEngine ( ) { if ( isPrepared ) return ; if ( configFailed ) return ; asUINT n ; for ( n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> funcType == asFUNC_SYSTEM ) { if ( scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_FUNC || scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_METHOD ) PrepareSystemFunction@@ Generic ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; else PrepareSystemFunction ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; } } for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && ! ( objectTypes [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) { bool missingBehaviour = false ; const char * infoMsg = 0 ; if ( objectTypes [ n ] -> flags & asOBJ_GC ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 || objectTypes [ n ] -> beh . gcGetRefCount == 0 || objectTypes [ n ] -> beh . gcSetFlag == 0 || objectTypes [ n ] -> beh . gcGetFlag == 0 || objectTypes [ n ] -> beh . gcEnumReferences == 0 || objectTypes [ n ] -> beh . gcReleaseAllReferences == 0 ) { infoMsg = TXT_GC_@@ REQUIRE_ADD_REL_@@ GC_BEHAVIOUR ; missingBehaviour = true ; } } else if ( objectTypes [ n ] -> flags & asOBJ_SCOPED ) { if ( objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_S@@ COPE_REQUIR@@ E_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_REF ) && ! ( objectTypes [ n ] -> flags & asOBJ_NOHANDLE ) ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_REF_@@ REQUIRE_ADD_REL_@@ BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_VALUE ) && ! ( objectTypes [ n ] -> flags & asOBJ_POD ) ) { if ( objectTypes [ n ] -> beh . construct == 0 || objectTypes [ n ] -> beh . destruct == 0 ) { infoMsg = TXT_NON_@@ POD_REQUIRE_@@ CONSTR@@ _DESTR@@ _BEHAVIOUR ; missingBehaviour = true ; } } if ( missingBehaviour ) { asCString str ; str . Format ( TXT_TYPE_s_IS_@@ MISS@@ ING_BEHAVIOUR@@ S , objectTypes [ n ] -> name . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , str . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_INFOR@@ MATION , infoMsg ) ; ConfigError ( asINVALID_CONFIGURATION ) ; } } } isPrepared = true ; } int asCScriptEngine :: ConfigError ( int err ) { configFailed = true ; return err ; } int asCScriptEngine :: RegisterStringFactory ( const char * datatype , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; # ifdef AS_MAX_PORTABILITY if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # else if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; # endif asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> name = " _ string _ factory _ " ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; asCDataType dt ; r = bld . ParseDataType ( datatype , & dt ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_TYPE ) ; } func -> returnType = dt ; func -> parameterTypes . PushLast ( asCDataType :: CreatePrimitive ( ttInt , true ) ) ; asCDataType parm1 = asCDataType :: CreatePrimitive ( ttUInt8 , true ) ; parm1 . MakeReference ( true ) ; func -> parameterTypes . PushLast ( parm1 ) ; func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; stringFactory = func ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; if ( group == 0 ) group = & defaultGroup ; group -> scriptFunctions . PushLast ( func ) ; } return func -> id ; } int asCScriptEngine :: GetStringFactory@@ ReturnTypeId ( ) { if ( stringFactory == 0 ) return asNO_FUNCTION ; return GetTypeIdFromDataType ( stringFactory -> returnType ) ; } asCModule * asCScriptEngine :: GetModule ( const char * _name , bool create ) { const char * name = " " ; if ( _name != 0 ) name = _name ; if ( lastModule && lastModule -> name == name ) return lastModule ; for ( asUINT n = 0 ; n < scriptModules . GetLength ( ) ; ++ n ) if ( scriptModules [ n ] && scriptModules [ n ] -> name == name ) { lastModule = scriptModules [ n ] ; return lastModule ; } if ( create ) { asCModule * module = asNEW ( asCModule ) ( name , this ) ; scriptModules . PushLast ( module ) ; lastModule = module ; return lastModule ; } return 0 ; } asCModule * asCScriptEngine :: GetModule@@ FromFunc@@ Id ( int id ) { if ( id < 0 ) return 0 ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; asCScriptFunction * func = scriptFunctions [ id ] ; if ( func == 0 ) return 0 ; return func -> module ; } int asCScriptEngine :: RequestBuild ( ) { ENTERCRITICAL@@ SECTION ( engineCritical ) ; if ( isBuilding ) { LEAVECRITICALSECTION ( engineCritical ) ; return asBUILD_@@ IN_PROGRESS ; } isBuilding = true ; LEAVECRITICALSECTION ( engineCritical ) ; return 0 ; } void asCScriptEngine :: BuildCompleted ( ) { memory@@ Mgr . FreeUnused@@ Memory ( ) ; isBuilding = false ; } # ifdef AS_DEPRECATED int asCScriptEngine :: ExecuteString ( const char * module , const char * script , asIScriptContext * * ctx , asDWORD flags ) { int r ; if ( ( r = RequestBuild ( ) ) < 0 ) return r ; PrepareEngine ( ) ; if ( configFailed ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_INVALID_CONFIGURATION ) ; isBuilding = false ; return asINVALID_CONFIGURATION ; } asIScriptContext * exec = 0 ; if ( ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { int r = CreateContext ( & exec , false ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; isBuilding = false ; return r ; } if ( ctx ) { * ctx = exec ; exec -> AddRef ( ) ; } } else { if ( * ctx == 0 ) { isBuilding = false ; return asINVALID_ARG ; } exec = * ctx ; exec -> AddRef ( ) ; } exec -> Unprepare ( ) ; asCModule * mod = GetModule ( module , true ) ; asCBuilder builder ( this , mod ) ; asCString str = script ; str = " void ▁ ExecuteString ( ) { \n " + str + " \n ; } " ; r = builder . BuildString ( str . AddressOf ( ) , ( asCContext * ) exec ) ; BuildCompleted ( ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return asERROR ; } r = ( ( asCContext * ) exec ) -> Prepare ( ( ( asCContext * ) exec ) -> stringFunction -> id ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return r ; } if ( flags & asEXECSTRING_@@ ONLY_@@ PREPAR@@ E ) r = asEXECUTION_@@ PREPAR@@ ED ; else r = exec -> Execute ( ) ; exec -> Release ( ) ; return r ; } # endif void asCScriptEngine :: RemoveTemplateInstanceType ( asCObjectType * t ) { int n ; for ( n = 0 ; n < ( int ) t -> beh . factories . GetLength ( ) ; n ++ ) { scriptFunctions [ t -> beh . factories [ n ] ] -> ReleaseAllHandles ( this ) ; scriptFunctions [ t -> beh . factories [ n ] ] -> Release ( ) ; } t -> beh . factories . SetLength ( 0 ) ; for ( n = 1 ; n < ( int ) t -> beh . operators . GetLength ( ) ; n += 2 ) { if ( t -> beh . operators [ n ] && scriptFunctions [ t -> beh . operators [ n ] ] -> objectType == t ) { scriptFunctions [ t -> beh . operators [ n ] ] -> Release ( ) ; } } t -> beh . operators . SetLength ( 0 ) ; for ( n = ( int ) templateTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateTypes [ n ] == t ) { if ( n == ( signed ) templateTypes . GetLength ( ) - 1 ) templateTypes . PopLast ( ) ; else templateTypes [ n ] = templateTypes . PopLast ( ) ; } } for ( n = ( int ) templateInstanceTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateInstanceTypes [ n ] == t ) { if ( n == ( signed ) templateInstanceTypes . GetLength ( ) - 1 ) templateInstanceTypes . PopLast ( ) ; else templateInstanceTypes [ n ] = templateInstanceTypes . PopLast ( ) ; } } asDELETE ( t , asCObjectType ) ; } asCObjectType * asCScriptEngine :: GetTemplateInstanceType ( asCObjectType * templateType , asCDataType & subType ) { asUINT n ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == templateType -> name && templateTypes [ n ] -> templateSubType == subType ) return templateTypes [ n ] ; } if ( ! templateType -> acceptValueSubType && ( subType . IsPrimitive ( ) || ( subType . GetObjectType ( ) -> flags & asOBJ_VALUE ) ) ) return 0 ; if ( ! templateType -> acceptRefSubType && ( subType . IsObject ( ) && ( subType . GetObjectType ( ) -> flags & asOBJ_REF ) ) ) return 0 ; asCObjectType * ot = asNEW ( asCObjectType ) ( this ) ; ot -> templateSubType = subType ; ot -> flags = templateType -> flags ; ot -> size = templateType -> size ; ot -> name = templateType -> name ; if ( templateType -> beh . templateCallback ) { asCScriptFunction * callback = scriptFunctions [ templateType -> beh . templateCallback ] ; if ( ! CallGlobalFunctionRetBool ( ot , 0 , callback -> sysFuncIntf , callback ) ) { ot -> templateSubType = asCDataType ( ) ; asDELETE ( ot , asCObjectType ) ; return 0 ; } } ot -> methods = templateType -> methods ; for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> methods [ n ] ] -> AddRef ( ) ; ot -> beh . construct = templateType -> beh . factory ; ot -> beh . constructors = templateType -> beh . factories ; for ( n = 0 ; n < ot -> beh . constructors . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> beh . constructors [ n ] ] -> AddRef ( ) ; for ( n = 0 ; n < templateType -> beh . factories . GetLength ( ) ; n ++ ) { int factoryId = templateType -> beh . factories [ n ] ; asCScriptFunction * factory = scriptFunctions [ factoryId ] ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SCRIP@@ T ) ; func -> name = " factstub " ; func -> id = GetNextScriptFunctionId ( ) ; func -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; for ( asUINT p = 1 ; p < factory -> parameterTypes . GetLength ( ) ; p ++ ) { func -> parameterTypes . PushLast ( factory -> parameterTypes [ p ] ) ; func -> inOutFlags . PushLast ( factory -> inOutFlags [ p ] ) ; } SetScriptFunction ( func ) ; asCBuilder builder ( this , 0 ) ; asCCompiler compiler ( this ) ; compiler . CompileTemplate@@ Factory@@ Stub ( & builder , factoryId , ot , func ) ; ot -> beh . factories . PushLast ( func -> id ) ; } if ( ot -> beh . factories . GetLength ( ) ) ot -> beh . factory = ot -> beh . factories [ 0 ] ; else { asASSERT ( false ) ; ot -> beh . factory = templateType -> beh . factory ; } ot -> beh . addref = templateType -> beh . addref ; if ( scriptFunctions [ ot -> beh . addref ] ) scriptFunctions [ ot -> beh . addref ] -> AddRef ( ) ; ot -> beh . release = templateType -> beh . release ; if ( scriptFunctions [ ot -> beh . release ] ) scriptFunctions [ ot -> beh . release ] -> AddRef ( ) ; ot -> beh . copy = templateType -> beh . copy ; if ( scriptFunctions [ ot -> beh . copy ] ) scriptFunctions [ ot -> beh . copy ] -> AddRef ( ) ; ot -> beh . operators = templateType -> beh . operators ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> AddRef ( ) ; } ot -> beh . gcGetRefCount = templateType -> beh . gcGetRefCount ; if ( scriptFunctions [ ot -> beh . gcGetRefCount ] ) scriptFunctions [ ot -> beh . gcGetRefCount ] -> AddRef ( ) ; ot -> beh . gcSetFlag = templateType -> beh . gcSetFlag ; if ( scriptFunctions [ ot -> beh . gcSetFlag ] ) scriptFunctions [ ot -> beh . gcSetFlag ] -> AddRef ( ) ; ot -> beh . gcGetFlag = templateType -> beh . gcGetFlag ; if ( scriptFunctions [ ot -> beh . gcGetFlag ] ) scriptFunctions [ ot -> beh . gcGetFlag ] -> AddRef ( ) ; ot -> beh . gcEnumReferences = templateType -> beh . gcEnumReferences ; if ( scriptFunctions [ ot -> beh . gcEnumReferences ] ) scriptFunctions [ ot -> beh . gcEnumReferences ] -> AddRef ( ) ; ot -> beh . gcReleaseAllReferences = templateType -> beh . gcReleaseAllReferences ; if ( scriptFunctions [ ot -> beh . gcReleaseAllReferences ] ) scriptFunctions [ ot -> beh . gcReleaseAllReferences ] -> AddRef ( ) ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { int funcId = ot -> beh . operators [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> Release ( ) ; ot -> beh . operators [ n ] = func -> id ; } } for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) { int funcId = ot -> methods [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> methods [ n ] ] -> Release ( ) ; ot -> methods [ n ] = func -> id ; } } if ( ot -> templateSubType . GetObjectType ( ) ) ot -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; if ( ot -> templateSubType . GetObjectType ( ) && ( ot -> templateSubType . GetObjectType ( ) -> flags & asOBJ_GC ) ) ot -> flags |= asOBJ_GC ; else if ( ot -> name == defaultArrayObjectType -> name ) ot -> flags &= ~ asOBJ_GC ; templateTypes . PushLast ( ot ) ; templateInstanceTypes . PushLast ( ot ) ; return ot ; } bool asCScriptEngine :: GenerateNewTemplateFunction ( asCObjectType * templateType , asCObjectType * ot , asCDataType & subType , asCScriptFunction * func , asCScriptFunction * * newFunc ) { bool needNewFunc = false ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> returnType . GetObjectType ( ) == templateType ) needNewFunc = true ; else { for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { needNewFunc = true ; break ; } } } if ( needNewFunc ) { asCScriptFunction * func2 = asNEW ( asCScriptFunction ) ( this , 0 , func -> funcType ) ; func2 -> name = func -> name ; func2 -> id = GetNextScriptFunctionId ( ) ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> returnType = subType ; if ( func -> returnType . IsObjectHandle ( ) ) func2 -> returnType . MakeHandle ( true , true ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else if ( func -> returnType . GetObjectType ( ) == templateType ) { if ( func2 -> returnType . IsObjectHandle ( ) ) func2 -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> returnType = asCDataType :: CreateObject ( ot , false ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else func2 -> returnType = func -> returnType ; func2 -> parameterTypes . SetLength ( func -> parameterTypes . GetLength ( ) ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> parameterTypes [ p ] = subType ; if ( func -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] . MakeHandle ( true ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReference ( ) ) ; } else if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { if ( func2 -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> parameterTypes [ p ] = asCDataType :: CreateObject ( ot , false ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReadOnly ( ) ) ; } else func2 -> parameterTypes [ p ] = func -> parameterTypes [ p ] ; } func2 -> inOutFlags = func -> inOutFlags ; func2 -> isReadOnly = func -> isReadOnly ; func2 -> objectType = ot ; func2 -> stackNeeded = func -> stackNeeded ; func2 -> sysFuncIntf = asNEW ( asSSystemFunctionInterface ) ( * func -> sysFuncIntf ) ; SetScriptFunction ( func2 ) ; * newFunc = func2 ; } return needNewFunc ; } void asCScriptEngine :: CallObjectMethod ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asPWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = asPWORD ( i -> baseOffset ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } # endif } bool asCScriptEngine :: CallObjectMethodRet@@ Bool ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } int asCScriptEngine :: CallObjectMethodRet@@ Int ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; # ifdef __GNUC__ if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else # endif if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } # endif } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func , void * param1 ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s , param1 ) ; } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( ) = ( void * ( * ) ( ) ) ( i -> func ) ; return f ( ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( ) = ( void * ( STDCALL * ) ( ) ) ( i -> func ) ; return f ( ) ; } else { asCGeneric gen ( this , s , 0 , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s , void * param1 ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( void * ) = ( void * ( * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( void * ) = ( void * ( STDCALL * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , param , s -> sysFuncIntf , s ) ; } void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , asSSystemFunctionInterface * i , asCScriptFunction * s ) { # ifdef __GNUC__ if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # else # ifndef AS_NO_CLASS_METHODS if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( void * ) = ( void ( asCSimpleDummy :: * ) ( void * ) ) ( p . mthd ) ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( param ) ; } else # endif if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } # endif } void asCScriptEngine :: CallGlobalFunction ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void ( STDCALL * f ) ( void * , void * ) = ( void ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } } bool asCScriptEngine :: CallGlobalFunctionRetBool ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { bool ( * f ) ( void * , void * ) = ( bool ( * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { bool ( STDCALL * f ) ( void * , void * ) = ( bool ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } } void * asCScriptEngine :: CallAlloc ( asCObjectType * type ) { # if defined ( AS_DEBUG ) return ( ( asALLO@@ CFUNC@@ DEBUG_t ) ( userAlloc ) ) ( type -> size < 4 ? 4 : type -> size , __FILE__ , __LINE__ ) ; # else return userAlloc ( type -> size < 4 ? 4 : type -> size ) ; # endif } void asCScriptEngine :: CallFree ( void * obj ) { userFree ( obj ) ; } void asCScriptEngine :: NotifyGarbageCollect@@ orOf@@ NewObject ( void * obj , int typeId ) { asCObjectType * objType = GetObjectTypeFromTypeId ( typeId ) ; gc . AddScriptObject@@ ToGC ( obj , objType ) ; } int asCScriptEngine :: GarbageCollect ( asDWORD flags ) { return gc . GarbageCollect ( flags ) ; } void asCScriptEngine :: GetGC@@ Statistics ( asUINT * currentSize , asUINT * totalDestroyed , asUINT * totalDetected ) { gc . GetStatistics ( currentSize , totalDestroyed , totalDetected ) ; } void asCScriptEngine :: GCEnumCallback ( void * reference ) { gc . GCEnumCallback ( reference ) ; } int asCScriptEngine :: GetTypeIdFromDataType ( const asCDataType & dt ) { if ( dt . IsNullHandle ( ) ) return 0 ; asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { if ( mapTypeIdToDataType . GetValue ( cursor ) -> IsEqualExceptRefAndConst ( dt ) ) return mapTypeIdToDataType . GetKey ( cursor ) ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; } int typeId = typeIdSeqNbr ++ ; if ( dt . GetObjectType ( ) ) { if ( dt . GetObjectType ( ) -> flags & asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIP@@ TOBJECT ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIP@@ TARRAY ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_ENUM ) ; else typeId |= asTYPEID_APP@@ OBJECT ; } asCDataType * newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( false ) ; mapTypeIdToDataType . Insert ( typeId , newDt ) ; if ( dt . IsObject ( ) && dt . GetObjectType ( ) -> beh . release ) { newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( false ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE , newDt ) ; newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( true ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE | asTYPEID_HAND@@ LETO@@ CONST , newDt ) ; } return GetTypeIdFromDataType ( dt ) ; } const asCDataType * asCScriptEngine :: GetDataTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) ; return 0 ; } asCObjectType * asCScriptEngine :: GetObjectTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) -> GetObjectType ( ) ; return 0 ; } void asCScriptEngine :: RemoveFromTypeIdMap ( asCObjectType * type ) { asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { asCDataType * dt = mapTypeIdToDataType . GetValue ( cursor ) ; asSMapNode < int , asCDataType * > * old = cursor ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; if ( dt -> GetObjectType ( ) == type ) { asDELETE ( dt , asCDataType ) ; mapTypeIdToDataType . Erase ( old ) ; } } } int asCScriptEngine :: GetTypeIdByDecl ( const char * decl ) { asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( decl , & dt ) ; if ( r < 0 ) return asINVALID_TYPE ; return GetTypeIdFromDataType ( dt ) ; } const char * asCScriptEngine :: GetType@@ Declaration ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; asASSERT ( threadManager ) ; asCString * tempString = & threadManager -> GetLocal@@ Data ( ) -> string ; * tempString = dt -> Format ( ) ; return tempString -> AddressOf ( ) ; } int asCScriptEngine :: GetSize@@ OfPrimit@@ iveType ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; if ( ! dt -> IsPrimitive ( ) ) return 0 ; return dt -> GetSizeInMemoryBytes ( ) ; } void * asCScriptEngine :: CreateScriptObject ( int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return 0 ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return 0 ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; asCObjectType * objType = dt -> GetObjectType ( ) ; void * ptr = 0 ; if ( objType -> flags & asOBJ_SCRIPT_OBJECT ) ptr = ScriptObject@@ Factory ( objType , this ) ; else if ( objType -> flags & asOBJ_TEMPLATE ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . construct , objType ) ; else if ( objType -> flags & asOBJ_REF ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . factory ) ; else { ptr = CallAlloc ( objType ) ; int funcIndex = objType -> beh . construct ; if ( funcIndex ) CallObjectMethod ( ptr , funcIndex ) ; } return ptr ; } void * asCScriptEngine :: CreateScriptObject@@ Copy ( void * origObj , int typeId ) { void * newObj = CreateScriptObject ( typeId ) ; if ( newObj == 0 ) return 0 ; CopyScriptObject ( newObj , origObj , typeId ) ; return newObj ; } void asCScriptEngine :: CopyScriptObject ( void * dstObj , void * srcObj , int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . copy ) { CallObjectMethod ( dstObj , srcObj , objType -> beh . copy ) ; } else if ( objType -> size ) { memcpy ( dstObj , srcObj , objType -> size ) ; } } void asCScriptEngine :: AddRef@@ ScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . addref ) { CallObjectMethod ( obj , objType -> beh . addref ) ; } } void asCScriptEngine :: ReleaseScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . release ) { CallObjectMethod ( obj , objType -> beh . release ) ; } else { if ( objType -> beh . destruct ) CallObjectMethod ( obj , objType -> beh . destruct ) ; CallFree ( obj ) ; } } bool asCScriptEngine :: IsHandle@@ Compatible@@ WithObject ( void * obj , int objTypeId , int handleTypeId ) { if ( objTypeId == handleTypeId ) return true ; const asCDataType * objDt = GetDataTypeFromTypeId ( objTypeId ) ; const asCDataType * hdlDt = GetDataTypeFromTypeId ( handleTypeId ) ; if ( objDt -> IsHandleToConst ( ) && ! hdlDt -> IsHandleToConst ( ) ) return false ; if ( objDt -> GetObjectType ( ) == hdlDt -> GetObjectType ( ) ) { return true ; } else if ( objDt -> IsScriptObject ( ) && obj ) { asCObjectType * objType = ( ( asCScriptObject * ) obj ) -> objType ; if ( objType -> Imple@@ ments ( hdlDt -> GetObjectType ( ) ) ) return true ; } return false ; } int asCScriptEngine :: BeginConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) return asNAME_TAKEN ; } if ( currentGroup != & defaultGroup ) return asNOT_SUPPORTED ; asCConfigGroup * group = asNEW ( asCConfigGroup ) ( ) ; group -> groupName = groupName ; configGroups . PushLast ( group ) ; currentGroup = group ; return 0 ; } int asCScriptEngine :: EndConfigGroup ( ) { if ( currentGroup == & defaultGroup ) return asNOT_SUPPORTED ; currentGroup = & defaultGroup ; return 0 ; } int asCScriptEngine :: RemoveConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { asCConfigGroup * group = configGroups [ n ] ; if ( group -> refCount > 0 ) return asCONFIG_GROUP_IS_IN_USE ; if ( group -> HasLive@@ Objects ( ) ) return asCONFIG_GROUP_IS_IN_USE ; if ( n == configGroups . GetLength ( ) - 1 ) configGroups . PopLast ( ) ; else configGroups [ n ] = configGroups . PopLast ( ) ; group -> RemoveConfiguration ( this ) ; asDELETE ( group , asCConfigGroup ) ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForFunction ( int funcId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { asUINT m ; for ( m = 0 ; m < configGroups [ n ] -> scriptFunctions . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> scriptFunctions [ m ] -> id == funcId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForGlobalVar ( int gvarId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> globalProps . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> globalProps [ m ] -> id == gvarId ) return configGroups [ n ] ; } } return 0 ; } asCConfigGroup * asCScriptEngine :: FindConfigGroupForObjectType ( const asCObjectType * objType ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> objTypes . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> objTypes [ m ] == objType ) return configGroups [ n ] ; } } return 0 ; } int asCScriptEngine :: SetConfigGroup@@ ModuleAccess ( const char * groupName , const char * module , bool hasAccess ) { asCConfigGroup * group = 0 ; for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { group = configGroups [ n ] ; break ; } } if ( group == 0 ) return asWRONG_CONFIG_GROUP ; return group -> SetModuleAccess ( module , hasAccess ) ; } int asCScriptEngine :: GetNextScriptFunctionId ( ) { if ( freeScriptFunctionIds . GetLength ( ) ) return freeScriptFunctionIds . PopLast ( ) ; int id = ( int ) scriptFunctions . GetLength ( ) ; scriptFunctions . PushLast ( 0 ) ; return id ; } void asCScriptEngine :: SetScriptFunction ( asCScriptFunction * func ) { scriptFunctions [ func -> id ] = func ; } void asCScriptEngine :: FreeScriptFunctionId ( int id ) { if ( id < 0 ) return ; id &= 0xFFFF ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return ; if ( scriptFunctions [ id ] ) { asCScriptFunction * func = scriptFunctions [ id ] ; if ( id == ( int ) scriptFunctions . GetLength ( ) - 1 ) { scriptFunctions . PopLast ( ) ; } else { scriptFunctions [ id ] = 0 ; freeScriptFunctionIds . PushLast ( id ) ; } if ( func -> signatureId == id ) { signatureIds . RemoveValue ( func ) ; int newSigId = 0 ; for ( asUINT n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> signatureId == id ) { if ( newSigId == 0 ) { newSigId = scriptFunctions [ n ] -> id ; signatureIds . PushLast ( scriptFunctions [ n ] ) ; } scriptFunctions [ n ] -> signatureId = newSigId ; } } } } } int asCScriptEngine :: RegisterTypedef ( const char * type , const char * decl ) { if ( type == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return asALREADY_REGISTERED ; } asCTokenizer t ; size_t tokenLen ; eTokenType token ; asCDataType dataType ; token = t . GetToken ( decl , strlen ( decl ) , & tokenLen ) ; switch ( token ) { case ttBool : case ttInt : case ttInt8 : case ttInt16 : case ttInt64 : case ttUInt : case ttUInt8 : case ttUInt16 : case ttUInt64 : case ttFloat : case ttDouble : if ( strlen ( decl ) != tokenLen ) { return ConfigError ( asINVALID_TYPE ) ; } break ; default : return ConfigError ( asINVALID_TYPE ) ; } dataType = asCDataType :: CreatePrimitive ( token , false ) ; token = t . GetToken ( type , strlen ( type ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( type ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; asCBuilder bld ( this , 0 ) ; int r = bld . CheckNameConflict ( type , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * object = asNEW ( asCObjectType ) ( this ) ; object -> flags = asOBJ_TYPE@@ DEF ; object -> size = dataType . GetSizeInMemoryBytes ( ) ; object -> name = type ; object -> templateSubType = dataType ; objectTypes . PushLast ( object ) ; registeredTypeDefs . PushLast ( object ) ; currentGroup -> objTypes . PushLast ( object ) ; return asSUCCESS ; } int asCScriptEngine :: GetTypedef@@ Count ( ) { return ( int ) registeredTypeDefs . GetLength ( ) ; } const char * asCScriptEngine :: GetTypedef@@ ByIndex ( asUINT index , int * typeId , const char * * configGroup ) { if ( index >= registeredTypeDefs . GetLength ( ) ) return 0 ; if ( typeId ) * typeId = GetTypeIdByDecl ( registeredTypeDefs [ index ] -> name . AddressOf ( ) ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredTypeDefs [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } return registeredTypeDefs [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: RegisterEnum ( const char * name ) { if ( NULL == name ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; asCDataType dataType ; dataType . CreatePrimitive ( ttInt , false ) ; st -> flags = asOBJ_ENUM ; st -> size = dataType . GetSizeInMemoryBytes ( ) ; st -> name = name ; objectTypes . PushLast ( st ) ; registeredEnums . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; } int asCScriptEngine :: RegisterEnumValue ( const char * typeName , const char * valueName , int value ) { if ( currentGroup -> FindType ( typeName ) == 0 ) return asWRONG_CONFIG_GROUP ; asCDataType dt ; int r ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( typeName , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCObjectType * ot = dt . GetObjectType ( ) ; if ( ot == 0 || ! ( ot -> flags & asOBJ_ENUM ) ) return ConfigError ( asINVALID_TYPE ) ; if ( NULL == valueName ) return ConfigError ( asINVALID_NAME ) ; for ( unsigned int n = 0 ; n < ot -> enumValues . GetLength ( ) ; n ++ ) { if ( ot -> enumValues [ n ] -> name == valueName ) return ConfigError ( asALREADY_REGISTERED ) ; } asSEnumValue * e = asNEW ( asSEnumValue ) ; e -> name = valueName ; e -> value = value ; ot -> enumValues . PushLast ( e ) ; return asSUCCESS ; } int asCScriptEngine :: GetEnum@@ Count ( ) { return ( int ) registeredEnums . GetLength ( ) ; } const char * asCScriptEngine :: GetEnum@@ ByIndex ( asUINT index , int * enumTypeId , const char * * configGroup ) { if ( index >= registeredEnums . GetLength ( ) ) return 0 ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredEnums [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( enumTypeId ) * enumTypeId = GetTypeIdByDecl ( registeredEnums [ index ] -> name . AddressOf ( ) ) ; return registeredEnums [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetEnumValue@@ Count ( int enumTypeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return asINVALID_TYPE ; return ( int ) t -> enumValues . GetLength ( ) ; } const char * asCScriptEngine :: GetEnumValue@@ ByIndex ( int enumTypeId , asUINT index , int * outValue ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return 0 ; if ( index >= t -> enumValues . GetLength ( ) ) return 0 ; if ( outValue ) * outValue = t -> enumValues [ index ] -> value ; return t -> enumValues [ index ] -> name . AddressOf ( ) ; } int asCScriptEngine :: GetObject@@ TypeCount ( ) { return ( int ) registeredObjTypes . GetLength ( ) ; } asIObjectType * asCScriptEngine :: GetObjectType@@ ByIndex ( asUINT index ) { if ( index >= registeredObjTypes . GetLength ( ) ) return 0 ; return registeredObjTypes [ index ] ; } asIObjectType * asCScriptEngine :: GetObjectType@@ ById ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; if ( dt -> GetObjectType ( ) && dt -> GetObjectType ( ) -> GetFlags ( ) & asOBJ_ENUM ) return 0 ; return dt -> GetObjectType ( ) ; } asIScriptFunction * asCScriptEngine :: GetFunction@@ DescriptorById ( int funcId ) { return GetScriptFunction ( funcId ) ; } bool asCScriptEngine :: IsTemplate@@ Type ( const char * name ) { for ( unsigned int n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) { return objectTypes [ n ] -> flags & asOBJ_TEMPLATE ? true : false ; } } return false ; } int asCScriptEngine :: AddConstantString ( const char * str , size_t len ) { for ( size_t n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { if ( stringConstants [ n ] -> Compare ( str , len ) == 0 ) { return ( int ) n ; } } asCString * cstr = asNEW ( asCString ) ( str , len ) ; stringConstants . PushLast ( cstr ) ; asASSERT ( stringConstants . GetLength ( ) <= 65536 ) ; return ( int ) stringConstants . GetLength ( ) - 1 ; } const asCString & asCScriptEngine :: GetConstantString ( int id ) { return * stringConstants [ id ] ; } int asCScriptEngine :: GetScriptSectionNameIndex ( const char * name ) { for ( asUINT n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { if ( scriptSectionNames [ n ] -> Compare ( name ) == 0 ) return n ; } scriptSectionNames . PushLast ( asNEW ( asCString ) ( name ) ) ; return int ( scriptSectionNames . GetLength ( ) - 1 ) ; } END_AS_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="D@@ mitry@@ -Me@@ /coreclr/tree/master/src/@@ jit/lower@@ arm.cpp"> # include " jitpch . h " # ifdef _MSC_VER # pragma hdrstop # endif # ifndef LEGAC@@ Y_BACK@@ END # ifdef _TARGET_@@ ARM@@ _ # include " jit . h " # include " sideeff@@ ects . h " # include " lower . h " # include " lsr@@ a . h " void Lowering :: LowerCast ( GenTree * tree ) { NYI_ARM ( " ARM ▁ Lowering ▁ for ▁ cast " ) ; } void Lowering :: LowerRotate ( GenTreePtr tree ) { NYI_ARM ( " ARM ▁ Lowering ▁ for ▁ ROL ▁ and ▁ ROR " ) ; } void Lowering :: TreeNode@@ InfoInit ( GenTree * stmt ) { NY@@ I ( " ARM ▁ TreeNodInfoInit " ) ; } bool Lowering :: isRM@@ WReg@@ Oper ( GenTreePtr tree ) { return false ; } bool Lowering :: IsCall@@ TargetInRange ( void * addr ) { return comp -> codeGen -> validImm@@ ForBL ( ( ssize_t ) addr ) ; } bool Lowering :: IsContainableImmed ( GenTree * parentNode , GenTree * childNode ) { NYI_ARM ( " ARM ▁ IsContainableImmed " ) ; return false ; } # endif # endif </DOCUMENT>
<DOCUMENT_ID="lassoan/@@ CTK/tree/master/Plugins/org.@@ commont@@ k.plugingener@@ ator.ui@@ /ctkPluginGeneratorUi@@ Plugin.cpp"> # include " ctkPluginGeneratorUiPlugin _ p . h " # include " ctkPluginGeneratorMainExtension . h " # include < ctkPluginConstants . h > # include < QtPlugin > # include < QDebug > void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUi@@ Extension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; } void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; } Q_EXPORT_@@ PLUGIN2 ( org_@@ commont@@ k_plugingener@@ ator_@@ ui , ctkPluginGeneratorUiPlugin ) </DOCUMENT>
<DOCUMENT_ID="p@@ mprog@@ /Tug@@ OfWar@@ /tree/master/Game@@ /gamelobby@@ stage.cpp"> # include " gamelobby@@ stage . h " # include " menu . h " # include " input . h " # include " gamelob@@ by _ addlocal . h " # include " gamestage . h " GameLobbyStage :: GameLobbyStage ( ) { networkconnection = nullptr ; currentinfo = new GameInfo ( true ) ; selection = 0 ; selectionteamisblue = true ; } GameLobbyStage :: GameLobbyStage ( Network * Connection ) { selection = 0 ; networkconnection = Connection ; currentinfo = new GameInfo ( Connection -> IsServer ( ) ) ; if ( ! Connection -> IsServer ( ) ) { } } void GameLobbyStage :: Begin ( ) { optionfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 32 ) ; helpfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 16 ) ; } void GameLobbyStage :: Pause ( ) { } void GameLobbyStage :: Resume ( ) { } void GameLobbyStage :: Finish ( ) { AUDIO -> StopMus@@ ic ( ) ; if ( networkconnection != nullptr ) { delete networkconnection ; networkconnection = nullptr ; } } void GameLobbyStage :: EventOccur@@ red ( Event * e ) { InputItems :: ItemSet inputevent = InputItems :: NONE ; if ( e -> Type == EVENT_KEY_@@ DOWN ) { if ( e -> Data . Keyboard . KeyCode == ALLE@@ GRO_KEY_@@ ESCAPE ) { delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; } inputevent = Input :: GetItemFromEvent ( e ) ; } if ( e -> Type == EVENT_JO@@ YSTIC@@ K_BUTTON_@@ DOWN && inputevent == InputItems :: NONE ) { inputevent = Input :: GetItemFromEvent ( e ) ; } if ( inputevent != InputItems :: NONE ) { InputEvent ( inputevent ) ; } NetworkEvent ( e ) ; } void GameLobbyStage :: InputEvent ( InputItems :: ItemSet inputevent ) { switch ( inputevent ) { case InputItems :: UP : if ( selection > 0 ) { selection -- ; } break ; case InputItems :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case InputItems :: LEFT : selectionteamisblue = true ; break ; case InputItems :: RIGHT : selectionteamisblue = false ; break ; case InputItems :: SELECT : delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; break ; case InputItems :: X : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { currentinfo -> BlueTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> BlueTeam [ selection ] ; } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { currentinfo -> RedTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> RedTeam [ selection ] ; } p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; FRAMEWORK -> ProgramStages -> Push ( new GameLobbyAddLocal@@ Stage ( p ) ) ; } break ; case InputItems :: B : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> BlueTeam [ selection ] = p ; } } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> RedTeam [ selection ] = p ; } } if ( p != nullptr ) { p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; } } break ; case InputItems :: Y : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { p = currentinfo -> BlueTeam [ selection ] ; currentinfo -> BlueTeam [ selection ] = nullptr ; } else { p = currentinfo -> RedTeam [ selection ] ; currentinfo -> RedTeam [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { } delete p ; } } break ; case InputItems :: START : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { GameStage * g = new GameStage ( currentinfo ) ; delete FRAMEWORK -> ProgramStages -> Pop ( ) ; FRAMEWORK -> ProgramStages -> Push ( g ) ; } break ; } } void GameLobbyStage :: NetworkEvent ( Event * e ) { if ( e -> Type == EVENT_NETWORK_@@ CONNECTION_@@ REQUEST ) { bool freeslot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { freeslot = ( currentinfo -> BlueTeam [ i ] == nullptr ? true : freeslot ) ; freeslot = ( currentinfo -> RedTeam [ i ] == nullptr ? true : freeslot ) ; } if ( freeslot ) { } } if ( e -> Type == EVENT_NETWORK_@@ CONNECTED ) { } if ( e -> Type == EVENT_NETWORK_@@ DISCONNECTED ) { } if ( e -> Type == EVENT_NETWORK_@@ PAC@@ KET_RECE@@ IV@@ ED ) { } } void GameLobbyStage :: Update ( ) { } void GameLobbyStage :: Render ( ) { al_clear@@ _to_color ( al_map_rgb ( 255 , 220 , 128 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) + 2 , 12 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) , 10 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 255 , 255 , 0 ) ) ; GameResources :: DrawPanel ( GameResources :: BluePanel , 5 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 15 , 85 , " Blue ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( true , 0 , 15 , 140 ) ; RenderPlayerSlot ( true , 1 , 15 , 192 ) ; RenderPlayerSlot ( true , 2 , 15 , 244 ) ; GameResources :: DrawPanel ( GameResources :: RedPanel , 405 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 415 , 85 , " Red ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( false , 0 , 415 , 140 ) ; RenderPlayerSlot ( false , 1 , 415 , 192 ) ; RenderPlayerSlot ( false , 2 , 415 , 244 ) ; int textoff = ( 50 - helpfont -> GetFontHeight ( ) ) / 2 ; if ( networkconnection == nullptr ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: X ) , 10 , 320 , 0 ) ; helpfont -> DrawString ( 64 , 320 + textoff , " Add ▁ Local ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: B ) , 10 , 370 , 0 ) ; helpfont -> DrawString ( 64 , 370 + textoff , " Add ▁ CPU ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: Y ) , 10 , 420 , 0 ) ; helpfont -> DrawString ( 64 , 420 + textoff , " Kick ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: START ) , 500 , 370 , 0 ) ; helpfont -> DrawString ( 554 , 370 + textoff , " Start " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } al_draw_bitmap ( Input :: GetIcon ( InputItems :: SELECT ) , 500 , 420 , 0 ) ; helpfont -> DrawString ( 554 , 420 + textoff , " Quit " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } bool GameLobbyStage :: IsTransition ( ) { return false ; } void GameLobbyStage :: RenderPlayerSlot ( bool BlueTeam , int Index , int X , int Y ) { ButtonColours :: Colours colour = ButtonColours :: WHITE ; bool btnup = false ; PlayerInfo * p = ( BlueTeam ? currentinfo -> BlueTeam [ Index ] : currentinfo -> RedTeam [ Index ] ) ; if ( p != nullptr ) { colour = ( BlueTeam ? ButtonColours :: BLUE : ButtonColours :: RED ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { if ( selection == Index && selectionteamisblue == BlueTeam ) { colour = ButtonColours :: YEL@@ LOW ; btnup = true ; } } GameResources :: DrawButton ( colour , btnup , X , Y , 23 , 3 ) ; if ( p != nullptr ) { helpfont -> DrawString ( X + 184 , Y + 24 - ( helpfont -> GetFontHeight ( ) / 2 ) + ( ! btnup ? 4 : 0 ) , p -> Name , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="cristal@@ /Patch@@ /tree/master/dep/acelite/ace/@@ Parse_Node.cpp"> # include " ace / Parse _ Node . h " # if ( ACE_USES_@@ CLASSIC_SVC_@@ CONF == 1 ) # include " ace / Service _ Config . h " # include " ace / Service _ Reposit@@ ory . h " # include " ace / Service _ Types . h " # include " ace / Task . h " # include " ace / DLL . h " # include " ace / ACE . h " # include " ace / OS _ NS _ string . h " # include " ace / ARGV . h " # include < list > ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_ALLOC_HOOK_DEFINE ( ACE_Stream_Node ) void ACE_Stream_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Stream _ Node : : dump " ) ; # endif } void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Parse_Node ) void ACE_Parse_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Parse _ Node : : dump " ) ; # endif } const ACE_TCHAR * ACE_Parse_Node :: name ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : name " ) ; return this -> name_ ; } ACE_Parse_Node * ACE_Parse_Node :: link ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; return this -> next_ ; } void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; t -> next_ = n ; } ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; } ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; } void ACE_Parse_Node :: print ( void ) const { ACE_TRACE ( " ACE _ Parse _ Node : : print " ) ; ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " svc ▁ = ▁ % s \n " ) , this -> name ( ) ) ) ; if ( this -> next_ ) this -> next_ -> print ( ) ; } ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Suspend_Node ) void ACE_Suspend_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Suspend _ Node : : dump " ) ; # endif } ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; } ACE_Suspend_Node :: ~ ACE_Suspend_Node ( void ) { } ACE_ALLOC_HOOK_DEFINE ( ACE_Resume_Node ) void ACE_Resume_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Resume _ Node : : dump " ) ; # endif } ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; } ACE_Resume_Node :: ~ ACE_Resume_Node ( void ) { } void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Remove_Node ) void ACE_Remove_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Remove _ Node : : dump " ) ; # endif } ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; } ACE_Remove_Node :: ~ ACE_Remove_Node ( void ) { } void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; } void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_ALLOC_HOOK_DEFINE ( ACE_Dynamic_Node ) void ACE_Dynamic_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dynamic _ Node : : dump " ) ; # endif } ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Node ) void ACE_Static_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Node : : dump " ) ; # endif } ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; } const ACE_Service_Type * ACE_Static_Node :: record ( const ACE_Service_Gestalt * config ) const { ACE_TRACE ( " ACE _ Static _ Node : : record " ) ; ACE_Service_Type * sr = 0 ; if ( config -> find ( this -> name ( ) , ( const ACE_Service_Type * * ) & sr ) == - 1 ) return 0 ; return sr ; } ACE_TCHAR * ACE_Static_Node :: parameters ( void ) const { ACE_TRACE ( " ACE _ Static _ Node : : parameters " ) ; return this -> parameters_ ; } void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; # endif } ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Location_Node ) void ACE_Location_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Location _ Node : : dump " ) ; # endif } ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; } ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; } const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; } const ACE_TCHAR * ACE_Location_Node :: pathname ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; return this -> pathname_ ; } void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; } int ACE_Location_Node :: dispose ( void ) const { ACE_TRACE ( " ACE _ Location _ Node : : dispose " ) ; return this -> must_delete_ ; } int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; # endif if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return - 1 ; } return 0 ; } void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Object_Node ) void ACE_Object_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Object _ Node : : dump " ) ; # endif } ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; } void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } return this -> symbol_ ; } return 0 ; } ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Function_Node ) void ACE_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Function _ Node : : dump " ) ; # endif } ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; } ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { # if defined ( ACE_HAS_VERSIONED_NAMESPACE ) && ACE_HAS_VERSIONED_NAMESPACE == 1 # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # NAME # define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( NAME ) ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL ( NAME ) # define ACE_VERSIONED_NAMESPACE_NAME_STRING ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING ( ACE_VERSIONED_NAMESPACE_@@ NAME ) static ACE_TCHAR const make_prefix [ ] = ACE_TEXT ( " _ make _ " ) ; static size_t const make_prefix_len = sizeof ( make_prefix ) / sizeof ( make_prefix [ 0 ] ) - 1 ; if ( ACE_OS :: strncmp ( make_prefix , func_name , make_prefix_len ) == 0 ) { static ACE_TCHAR const versioned_namespace_name [ ] = ACE_TEXT ( ACE_VERSIONED_NAMESPACE_NAME_STRING ) ACE_TEXT ( " _ " ) ; static size_t const versioned_namespace_name_len = sizeof ( versioned_namespace_name ) / sizeof ( versioned_namespace_name [ 0 ] ) ; size_t const len = ACE_OS :: strlen ( func_name ) + versioned_namespace_name_len ; ACE_TCHAR * mangled_func_name ; ACE_NEW_RETURN ( mangled_func_name , ACE_TCHAR [ len ] , 0 ) ; ACE_Auto@@ _Bas@@ ic_Array_@@ Ptr < ACE_TCHAR > safe ( mangled_func_name ) ; ACE_OS :: snprintf ( mangled_func_name , len , ACE_TEXT ( " % s % s % s " ) , make_prefix , versioned_namespace_name , func_name + make_prefix_len ) ; return safe . release ( ) ; } # endif return ACE :: strnew ( func_name ) ; } void * ACE_Function_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { typedef ACE_Service_Object * ( * ACE_Service_Factory_Ptr ) ( ACE_Service_Object_Exterminator * ) ; ACE_TRACE ( " ACE _ Function _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { this -> symbol_ = 0 ; ACE_TCHAR * const function_name = const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; void * const func_p = this -> dll_ . symbol ( function_name ) ; if ( func_p == 0 ) { ++ yyerrno ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_TCHAR * const errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " DLL : : symbol ▁ failed ▁ for ▁ function ▁ % s : ▁ " ) ACE_TEXT ( " % s \n " ) , function_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } # endif return 0 ; } # if defined ( ACE_OPEN@@ VMS ) && ( ! defined ( __INITIAL_POINTER_SIZE ) || ( __INITIAL_POINTER_SIZE < 64 ) ) int const temp_p = reinterpret_cast < int > ( func_p ) ; # else intptr_t const temp_p = reinterpret_cast < intptr_t > ( func_p ) ; # endif ACE_Service_Factory_Ptr func = reinterpret_cast < ACE_Service_Factory_Ptr > ( temp_p ) ; this -> symbol_ = ( * func ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } } return this -> symbol_ ; } ACE_Function_Node :: ~ ACE_Function_Node ( void ) { ACE_TRACE ( " ACE _ Function _ Node : : ~ ACE _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( function_name_ ) ; delete [ ] const_cast < ACE_TCHAR * > ( pathname_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Dummy_Node ) void ACE_Dummy_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Dummy _ Node : : dump " ) ; # endif } ACE_Dummy_Node :: ACE_Dummy_Node ( const ACE_Static_Node * static_node , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( static_node -> name ( ) ) , node_ ( static_node ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ACE _ Dummy _ Node " ) ; } void ACE_Dummy_Node :: apply ( ACE_Service_Gestalt * , int & yyerrno ) { ACE_TRACE ( " ACE _ Dummy _ Node : : apply " ) ; # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ operations ▁ on ▁ stream ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; # else ACE_UNUSED_@@ ARG ( yyerrno ) ; # endif } ACE_Dummy_Node :: ~ ACE_Dummy_Node ( void ) { ACE_TRACE ( " ACE _ Dummy _ Node : : ~ ACE _ Dummy _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Static_Function_Node ) void ACE_Static_Function_Node :: dump ( void ) const { # if defined ( ACE_HAS_DUMP ) ACE_TRACE ( " ACE _ Static _ Function _ Node : : dump " ) ; # endif } ACE_Static_Function_Node :: ACE_Static_Function_Node ( const ACE_TCHAR * func_name ) : function_name_ ( ACE :: strnew ( func_name ) ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ACE _ Static _ Function _ Node " ) ; this -> must_delete_ = 1 ; } void * ACE_Static_Function_Node :: symbol ( ACE_Service_Gestalt * config , int & yyerrno , ACE_Service_Object_Exterminator * gobbler ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : symbol " ) ; this -> symbol_ = 0 ; ACE_Static_Sv@@ c_Descriptor * ssd = 0 ; if ( config -> find_static_s@@ vc_@@ descriptor ( this -> function_name_ , & ssd ) == - 1 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ " ) ACE_TEXT ( " registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } if ( ssd -> alloc_ == 0 ) { ++ yyerrno ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ( % P | % t ) ▁ No ▁ static ▁ service ▁ factory ▁ " ) ACE_TEXT ( " function ▁ registered ▁ for ▁ function ▁ % s \n " ) , this -> function_name_ ) ) ; } return 0 ; } } this -> symbol_ = ( * ssd -> alloc_ ) ( gobbler ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " % p \n " ) , this -> function_name_ ) ) ; } return 0 ; } return this -> symbol_ ; } ACE_Static_Function_Node :: ~ ACE_Static_Function_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Function _ Node : : ~ ACE _ Static _ Function _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> function_name_ ) ; } ACE_ALLOC_HOOK_DEFINE ( ACE_Service_Type_Factory ) ACE_Service_Type_Factory :: ACE_Service_Type_Factory ( ACE_TCHAR const * name , int type , ACE_Location_Node * location , int active ) : name_ ( name ) , type_ ( type ) , location_ ( location ) , is_active_ ( active ) { } ACE_Service_Type_Factory :: ~ ACE_Service_Type_Factory ( void ) { } ACE_Service_Type * ACE_Service_Type_Factory :: make_servic@@ e_type ( ACE_Service_Gestalt * cfg ) const { ACE_TRACE ( " ACE _ Service _ Type _ Factory : : make _ service _ type " ) ; u_int const flags = ACE_Service_Type :: DELETE_@@ THIS | ( this -> location_ -> dispose ( ) == 0 ? 0 : ACE_Service_Type :: DELETE_@@ OBJ ) ; int yyerrno = 0 ; ACE_Service_Object_Exterminator gobbler = 0 ; void * sym = this -> location_ -> symbol ( cfg , yyerrno , & gobbler ) ; if ( sym != 0 ) { ACE_Service_Type_Impl * stp = ACE_Service_Config :: create_servic@@ e_type_@@ impl ( this -> name ( ) , this -> type_ , sym , flags , gobbler ) ; if ( stp == 0 ) ++ yyerrno ; ACE_Service_Type * tmp = 0 ; ACE_NEW_RETURN ( tmp , ACE_Service_Type ( this -> name ( ) , stp , this -> location_ -> dll ( ) , this -> is_active_ ) , 0 ) ; return tmp ; } # ifndef ACE_NLOGGING if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Unable ▁ to ▁ create ▁ " ) ACE_TEXT ( " service ▁ object ▁ for ▁ % s \n " ) , this -> name ( ) ) ) ; } # endif ++ yyerrno ; return 0 ; } ACE_TCHAR const * ACE_Service_Type_Factory :: name ( void ) const { return name_ . c_str ( ) ; } ACE_END_VERSIONED_NAMESPACE_DECL # endif </DOCUMENT>
<DOCUMENT_ID="next@@ gis@@ /Next@@ GIS_@@ QGIS_@@ open/tree/master/src/gui/@@ qgsfield@@ validator.cpp"> # include " qgsfield@@ validator . h " # include < QValidator > # include < QRegExpValidator > # include < QDate > # include < QVariant > # include < QSettings > # include " qgslogger . h " # include " qgslonglong@@ validator . h " # include " qgsfield . h " QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QInt@@ Validator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDouble@@ Validator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLong@@ LongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; } QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; } QValidator :: State QgsFieldValidator :: validate ( QString & s , int & i ) const { if ( s . isEmpty ( ) && ( mField . type ( ) == QVariant :: Double || mField . type ( ) == QVariant :: Int || mField . type ( ) == QVariant :: LongLong || mField . type ( ) == QVariant :: Date ) ) { return Acceptable ; } if ( mValidator ) { QValidator :: State result = mValidator -> validate ( s , i ) ; return result ; } else if ( mField . type ( ) == QVariant :: String ) { if ( mNullValue . size ( ) > 0 && s . size ( ) > 0 && s . size ( ) < mNullValue . size ( ) && s == mNullValue . left ( s . size ( ) ) ) return Intermediate ; if ( s == mNullValue ) return Acceptable ; if ( mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) return Invalid ; } else if ( mField . type ( ) == QVariant :: Date ) { return QDate :: fromString ( s , mDateFormat ) . isValid ( ) ? Acceptable : Intermediate ; } else { QgsDebug@@ Msg ( QString ( " unsupported ▁ type ▁ % 1 ▁ for ▁ validation " ) . arg ( mField . type ( ) ) ) ; return Invalid ; } return Acceptable ; } void QgsFieldValidator :: fixup ( QString & s ) const { if ( mValidator ) { mValidator -> fixup ( s ) ; } else if ( mField . type ( ) == QVariant :: String && mField . length ( ) > 0 && s . size ( ) > mField . length ( ) ) { s = mNullValue ; } else if ( mField . type ( ) == QVariant :: Date ) { s = " " ; } } </DOCUMENT>
<DOCUMENT_ID="Open@@ DSA@@ /Open@@ DSA@@ -st@@ able/tree/master/@@ SourceCode/@@ C++/@@ Sorting/He@@ apsort@@ .cpp"> # include " Maxheap . cpp " void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; } bool sorttest ( int array [ ] , int n , int thresh@@ old ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; } # include " SortTest . cpp " </DOCUMENT>
<DOCUMENT_ID="phamel@@ in/ardupilot/tree/master/libraries/@@ AP_Frsky_Telem/@@ AP_Frsky_Telem.cpp"> # include " AP _ Frsk@@ y _ Telem . h " # include < AP_InertialSensor / AP_InertialSensor . h > # include < GCS_MAV@@ Link / GCS . h > # include < stdio . h > extern const AP_HAL :: HAL & hal ; ObjectArray < mavlink_statustext_t > AP_Frsky_Telem :: _statustext_queue ( FRSK@@ Y_TELE@@ M_PAY@@ LOAD@@ _STATUS_@@ CAPACITY ) ; AP_Frsky_Telem :: AP_Frsky_Telem ( AP_AHRS & ahrs , const AP_BattMonitor & battery , const Range@@ Finder & rng ) : _ahrs ( ahrs ) , _battery ( battery ) , _rng ( rng ) { } void AP_Frsky_Telem :: init ( const AP_SerialManager & serial_manager , const uint8_t mav_type , const uint32_t * ap_valuep ) { if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_D , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_D ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ; gcs ( ) . register_@@ frsky_@@ telemetry_@@ callback ( this ) ; if ( _frame_string == nullptr ) { queue_message ( MAV_SEVERITY_INFO , AP :: fwversion ( ) . fw_string ) ; } else { char firmware_buf [ MAVLINK_@@ MSG_ST@@ ATUST@@ EXT_@@ FIELD_TEXT_@@ LEN + 1 ] ; snprintf ( firmware_buf , sizeof ( firmware_buf ) , " % s ▁ % s " , AP :: fwversion ( ) . fw_string , _frame_string ) ; queue_message ( MAV_SEVERITY_INFO , firmware_buf ) ; } _params . mav_type = mav_type ; if ( ap_valuep == nullptr ) { _ap . value = 0x2000 ; _ap . valuep = & _ap . value ; } else { _ap . valuep = ap_valuep ; } } if ( _port != nullptr ) { hal . scheduler -> register_@@ io_pro@@ cess ( FUNCTOR_@@ BIND_MEMBER ( & AP_Frsky_Telem :: tick , void ) ) ; _port -> set_flow@@ _control ( AP_HAL :: UAR@@ TDriver :: FLOW_CONTROL_DISABLE ) ; } } void AP_Frsky_Telem :: send_SPort_Passthrough ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } uint8_t prev_byte = 0 ; for ( int16_t i = 0 ; i < numc ; i ++ ) { prev_byte = _passthrough . new_byte ; _passthrough . new_byte = _port -> read ( ) ; } if ( ( prev_byte == START_STOP_SPORT ) && ( _passthrough . new_byte == SENSOR_ID_@@ 28 ) ) { if ( _passthrough . send_attiandrng ) { _passthrough . send_attiandrng = false ; } else { _passthrough . send_attiandrng = true ; uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - _passthrough . params_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 7 , calc_param ( ) ) ; _passthrough . params_timer = AP_HAL :: millis ( ) ; return ; } check_sensor_status_flags ( ) ; check_ekf_status ( ) ; if ( get_next_msg_chunk ( ) ) { send_uint32 ( DIY_FIRST_ID , _msg_chunk . chunk ) ; return ; } if ( ( now - _passthrough . ap_status_timer ) >= 500 ) { if ( ( ( * _ap . valuep ) & AP_INITIALIZ@@ ED_FLAG ) > 0 ) { send_uint32 ( DIY_FIRST_ID + 1 , calc_ap_status ( ) ) ; _passthrough . ap_status_timer = AP_HAL :: millis ( ) ; } return ; } if ( ( now - _passthrough . batt_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 3 , calc_batt ( 0 ) ) ; _passthrough . batt_timer = AP_HAL :: millis ( ) ; return ; } if ( _battery . num_instances ( ) > 1 ) { if ( ( now - _passthrough . batt_timer2 ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 8 , calc_batt ( 1 ) ) ; _passthrough . batt_timer2 = AP_HAL :: millis ( ) ; return ; } } if ( ( now - _passthrough . gps_status_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 2 , calc_gps_status ( ) ) ; _passthrough . gps_status_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . home_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 4 , calc_home ( ) ) ; _passthrough . home_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . velandyaw_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 5 , calc_velandyaw ( ) ) ; _passthrough . velandyaw_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . gps_latlng_timer ) >= 1000 ) { send_uint32 ( GPS_LONG_@@ LATI@@ _FIRST_ID , calc_gps_latlng ( & _passthrough . send_latitude ) ) ; if ( ! _passthrough . send_latitude ) { _passthrough . gps_latlng_timer = AP_HAL :: millis ( ) ; } return ; } } send_uint32 ( DIY_FIRST_ID + 6 , calc_attiandrng ( ) ) ; } } void AP_Frsky_Telem :: send_SPort ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } for ( int16_t i = 0 ; i < numc ; i ++ ) { int16_t readbyte = _port -> read ( ) ; if ( _SPort . sport_status == false ) { if ( readbyte == START_STOP_SPORT ) { _SPort . sport_status = true ; } } else { switch ( readbyte ) { case SENSOR_@@ ID_F@@ AS : switch ( _SPort . fas_call ) { case 0 : send_uint32 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; break ; case 2 : send_uint32 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; break ; } if ( _SPort . fas_call ++ > 2 ) _SPort . fas_call = 0 ; break ; case SENSOR_ID_@@ GPS : switch ( _SPort . gps_call ) { case 0 : calc_gps_position ( ) ; send_uint32 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; break ; case 1 : send_uint32 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; break ; case 2 : send_uint32 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; break ; case 3 : send_uint32 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; break ; case 4 : send_uint32 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; break ; case 5 : send_uint32 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; break ; case 6 : send_uint32 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; break ; case 7 : send_uint32 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; break ; case 8 : send_uint32 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; break ; case 9 : send_uint32 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; break ; case 10 : send_uint32 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; break ; } if ( _SPort . gps_call ++ > 10 ) _SPort . gps_call = 0 ; break ; case SENSOR_ID_@@ VARIO : switch ( _SPort . vario_call ) { case 0 : calc_nav_alt ( ) ; send_uint32 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; break ; case 1 : send_uint32 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; break ; } if ( _SPort . vario_call ++ > 1 ) _SPort . vario_call = 0 ; break ; case SENSOR_@@ ID_SP@@ 2U@@ R : switch ( _SPort . various_call ) { case 0 : send_uint32 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_TEMP1 , _ap . control_mode ) ; break ; } if ( _SPort . various_call ++ > 1 ) _SPort . various_call = 0 ; break ; } _SPort . sport_status = false ; } } } void AP_Frsky_Telem :: send_D ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( now - _D . last_200ms_frame >= 200 ) { _D . last_200ms_frame = now ; send_uint16 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; send_uint16 ( DATA_ID_TEMP1 , _ap . control_mode ) ; send_uint16 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; send_uint16 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; send_uint16 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; calc_nav_alt ( ) ; send_uint16 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; send_uint16 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; } if ( now - _D . last_1000ms_frame >= 1000 ) { _D . last_1000ms_frame = now ; send_uint16 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; calc_gps_position ( ) ; if ( AP :: gps ( ) . status ( ) >= 3 ) { send_uint16 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; send_uint16 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; send_uint16 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; send_uint16 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; send_uint16 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; send_uint16 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; send_uint16 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; send_uint16 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; send_uint16 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; send_uint16 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; } } } void AP_Frsky_Telem :: tick ( void ) { if ( ! _initialised_uart ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { _port -> begin ( AP_SERIALMANAGER_FRSKY_@@ D_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } else { _port -> begin ( AP_SERIALMANAGER_FRSK@@ Y_SP@@ ORT_@@ BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } _initialised_uart = true ; } if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { send_D ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort ) { send_SPort ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ) { send_SPort_Passthrough ( ) ; } } void AP_Frsky_Telem :: calc_crc ( uint8_t byte ) { _crc += byte ; _crc += _crc >> 8 ; _crc &= 0xFF ; } void AP_Frsky_Telem :: send_crc ( void ) { send_byte ( 0xFF - _crc ) ; _crc = 0 ; } void AP_Frsky_Telem :: send_byte ( uint8_t byte ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { if ( byte == START_STOP_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3E ) ; } else if ( byte == BYTESTUFF@@ _D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3D ) ; } else { _port -> write ( byte ) ; } } else { if ( byte == START_STOP_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5E ) ; } else if ( byte == BYTESTUFF@@ _SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5D ) ; } else { _port -> write ( byte ) ; } calc_crc ( byte ) ; } } void AP_Frsky_Telem :: send_uint32 ( uint16_t id , uint32_t data ) { send_byte ( 0x10 ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; send_byte ( bytes [ 2 ] ) ; send_byte ( bytes [ 3 ] ) ; send_crc ( ) ; } void AP_Frsky_Telem :: send_uint16 ( uint16_t id , uint16_t data ) { _port -> write ( START_STOP_D ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; } bool AP_Frsky_Telem :: get_next_msg_chunk ( void ) { if ( _statustext_queue . empty ( ) ) { return false ; } if ( _msg_chunk . repeats == 0 ) { uint8_t character = 0 ; _msg_chunk . chunk = 0 ; for ( int i = 3 ; i > - 1 && _msg_chunk . char_index < sizeof ( _statustext_queue [ 0 ] -> text ) ; i -- ) { character = _statustext_queue [ 0 ] -> text [ _msg_chunk . char_index ++ ] ; if ( ! character ) { break ; } _msg_chunk . chunk |= character << i * 8 ; } if ( ! character || ( _msg_chunk . char_index == sizeof ( _statustext_queue [ 0 ] -> text ) ) ) { _msg_chunk . char_index = 0 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x4 ) << 21 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x2 ) << 14 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x1 ) << 7 ; } } if ( _msg_chunk . repeats ++ > 2 ) { _msg_chunk . repeats = 0 ; if ( _msg_chunk . char_index == 0 ) { _statustext_queue . remove ( 0 ) ; } } return true ; } void AP_Frsky_Telem :: queue_message ( MAV_SEVERITY severity , const char * text ) { mavlink_statustext_t statustext { } ; statustext . severity = severity ; strncpy ( statustext . text , text , sizeof ( statustext . text ) ) ; _statustext_queue . push_for@@ ce ( statustext ) ; } void AP_Frsky_Telem :: check_sensor_status_flags ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_sensor_status_timer ) >= 5000 ) { if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ GPS ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_@@ GYRO ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Gyro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_@@ ACCEL ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Accel ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_@@ MAG ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Compass ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABSOL@@ UTE_PRESSURE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Baro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_LAS@@ ER_POSITION ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ LiDAR ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTICAL@@ _FLOW ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ OptFlow ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ TERRAIN ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ or ▁ No ▁ Terrain ▁ Data " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ GEOF@@ ENCE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Geof@@ ence ▁ Bre@@ ach " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ AHRS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ AHRS " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_@@ RECE@@ IVER ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " No ▁ RC ▁ Receiver " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ LOGGING ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Logging " ) ; check_sensor_status_timer = now ; } } } void AP_Frsky_Telem :: check_ekf_status ( void ) { float velVar , posVar , hgtVar , tasVar ; Vector3f magVar ; Vector2f offset ; if ( _ahrs . get_vari@@ ances ( velVar , posVar , hgtVar , magVar , tasVar , offset ) ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_ekf_status_timer ) >= 10000 ) { if ( velVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ velocity ▁ variance " ) ; check_ekf_status_timer = now ; } if ( posVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ hori@@ z ▁ variance " ) ; check_ekf_status_timer = now ; } if ( hgtVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ vert ▁ variance " ) ; check_ekf_status_timer = now ; } if ( magVar . length ( ) >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ compass ▁ variance " ) ; check_ekf_status_timer = now ; } if ( tasVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ terrain ▁ alt ▁ variance " ) ; check_ekf_status_timer = now ; } } } } uint32_t AP_Frsky_Telem :: calc_param ( void ) { uint32_t param = 0 ; if ( _paramID >= 5 ) { _paramID = 0 ; } _paramID ++ ; switch ( _paramID ) { case 1 : param = _params . mav_type ; break ; case 2 : case 3 : break ; case 4 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 0 ) ) ; break ; case 5 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 1 ) ) ; break ; } param = ( _paramID << PARAM_ID_OFFSET ) | ( param & PARAM_VALUE_@@ LIMIT ) ; return param ; } uint32_t AP_Frsky_Telem :: calc_gps_latlng ( bool * send_latitude ) { uint32_t latlng ; const Location & loc = AP :: gps ( ) . location ( 0 ) ; if ( ( * send_latitude ) == true ) { if ( loc . lat < 0 ) { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) | 0x40000000 ; } else { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) ; } ( * send_latitude ) = false ; } else { if ( loc . lng < 0 ) { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0xC0000000 ; } else { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0x80000000 ; } ( * send_latitude ) = true ; } return latlng ; } uint32_t AP_Frsky_Telem :: calc_gps_status ( void ) { const AP_GPS & gps = AP :: gps ( ) ; uint32_t gps_status ; gps_status = ( gps . num_sats ( ) < GPS_SATS_LIMIT ) ? gps . num_sats ( ) : GPS_SATS_LIMIT ; gps_status |= ( ( gps . status ( ) < GPS_STATUS_LIMIT ) ? gps . status ( ) : GPS_STATUS_LIMIT ) << GPS_STATUS_@@ OFFSET ; gps_status |= prep_number ( roundf ( gps . get_h@@ dop ( ) * 0.1f ) , 2 , 1 ) << GPS_HDO@@ P_OFFSET ; gps_status |= ( ( gps . status ( ) > GPS_STATUS_LIMIT ) ? gps . status ( ) - GPS_STATUS_LIMIT : 0 ) << GPS_ADV@@ STATUS_OFFSET ; const Location & loc = gps . location ( ) ; gps_status |= prep_number ( roundf ( loc . alt * 0.1f ) , 2 , 2 ) << GPS_ALT@@ MSL_OFFSET ; return gps_status ; } uint32_t AP_Frsky_Telem :: calc_batt ( uint8_t instance ) { uint32_t batt ; batt = ( ( ( uint16_t ) roundf ( _battery . voltage ( instance ) * 10.0f ) ) & BATT_VOL@@ TAGE_@@ LIMIT ) ; batt |= prep_number ( roundf ( _battery . current_amps ( instance ) * 10.0f ) , 2 , 1 ) << BATT_@@ CURRENT_@@ OFFSET ; batt |= ( ( _battery . consumed_mah ( instance ) < BATT_TOTALMAH_LIMIT ) ? ( ( uint16_t ) roundf ( _battery . consumed_mah ( instance ) ) & BATT_TOTALMAH_LIMIT ) : BATT_TOTALMAH_LIMIT ) << BATT_TOTALMAH_@@ OFFSET ; return batt ; } uint32_t AP_Frsky_Telem :: calc_ap_status ( void ) { uint32_t ap_status ; uint8_t imu_temp = ( uint8_t ) roundf ( constrain_float ( AP :: ins ( ) . get_temperature ( 0 ) , AP_IMU_TEMP_MIN , AP_IMU_TEMP_@@ MAX ) - AP_IMU_TEMP_MIN ) ; ap_status = ( uint8_t ) ( ( _ap . control_mode + 1 ) & AP_CONTROL_@@ MODE_@@ LIMIT ) ; ap_status |= ( uint8_t ) ( ( * _ap . valuep ) & AP_SSIMPLE_@@ FLAGS ) << AP_SSIMPLE_@@ OFFSET ; ap_status |= ( uint8_t ) ( ( ( * _ap . valuep ) & AP_LANDCOMPLETE_FLAG ) ^ AP_LANDCOMPLETE_FLAG ) ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . arm@@ ed ) << AP_ARMED_@@ OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . fail@@ safe_battery ) << AP_BATT_@@ FS_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . ekf_bad ) << AP_EK@@ F_F@@ S_OFFSET ; ap_status |= imu_temp << AP_IMU_TEMP_@@ OFFSET ; return ap_status ; } uint32_t AP_Frsky_Telem :: calc_home ( void ) { uint32_t home = 0 ; Location loc ; float _relative_home_altitude = 0 ; if ( _ahrs . get_position ( loc ) ) { const Location & home_loc = _ahrs . get_home ( ) ; if ( home_loc . lat != 0 || home_loc . lng != 0 ) { home = prep_number ( roundf ( get_distance ( home_loc , loc ) ) , 3 , 2 ) ; home |= ( ( ( uint8_t ) roundf ( get_bear@@ ing_cd ( loc , home_loc ) * 0.0033@@ 3f ) ) & HOME_BEARING_@@ LIMIT ) << HOME_BEARING_@@ OFFSET ; } _relative_home_altitude = loc . alt ; if ( ! loc . flags . relative_alt ) { _relative_home_altitude -= _ahrs . get_home ( ) . alt ; } } home |= prep_number ( roundf ( _relative_home_altitude * 0.1f ) , 3 , 2 ) << HOME_@@ ALT_OFFSET ; return home ; } uint32_t AP_Frsky_Telem :: calc_velandyaw ( void ) { uint32_t velandyaw ; Vector3f velNED { } ; _ahrs . get_veloc@@ ity_NED ( velNED ) ; velandyaw = prep_number ( roundf ( - velNED . z * 10 ) , 2 , 1 ) ; const AP_Air@@ speed * aspeed = _ahrs . get_airspeed ( ) ; if ( aspeed && aspeed -> enabled ( ) ) { velandyaw |= prep_number ( roundf ( aspeed -> get_airspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } else { velandyaw |= prep_number ( roundf ( _ahrs . groundspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } velandyaw |= ( ( uint16_t ) roundf ( _ahrs . yaw_sensor * 0.05f ) & VELANDYAW_YAW_@@ LIMIT ) << VELANDYAW_YAW_@@ OFFSET ; return velandyaw ; } uint32_t AP_Frsky_Telem :: calc_attiandrng ( void ) { uint32_t attiandrng ; attiandrng = ( ( uint16_t ) roundf ( ( _ahrs . roll_sensor + 18000 ) * 0.05f ) & ATTIANDRNG_@@ ROLL_@@ LIMIT ) ; attiandrng |= ( ( uint16_t ) roundf ( ( _ahrs . pit@@ ch_sensor + 9000 ) * 0.05f ) & ATTIANDRNG_PITCH_@@ LIMIT ) << ATTIANDRNG_PITCH_@@ OFFSET ; attiandrng |= prep_number ( _rng . distan@@ ce_cm_@@ orient ( ROT@@ ATION_PITCH_@@ 270 ) , 3 , 1 ) << ATTIANDRNG_@@ RN@@ GF@@ ND_@@ OFFSET ; return attiandrng ; } uint16_t AP_Frsky_Telem :: prep_number ( int32_t number , uint8_t digits , uint8_t power ) { uint16_t res = 0 ; uint32_t abs_number = abs ( number ) ; if ( ( digits == 2 ) && ( power == 1 ) ) { if ( abs_number < 100 ) { res = abs_number << 1 ; } else if ( abs_number < 1270 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0xFF ; } if ( number < 0 ) { res |= 0x1 << 8 ; } } else if ( ( digits == 2 ) && ( power == 2 ) ) { if ( abs_number < 100 ) { res = abs_number << 2 ; } else if ( abs_number < 1000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 10000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 127000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0x1FF ; } if ( number < 0 ) { res |= 0x1 << 9 ; } } else if ( ( digits == 3 ) && ( power == 1 ) ) { if ( abs_number < 1000 ) { res = abs_number << 1 ; } else if ( abs_number < 10240 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0x7FF ; } if ( number < 0 ) { res |= 0x1 << 11 ; } } else if ( ( digits == 3 ) && ( power == 2 ) ) { if ( abs_number < 1000 ) { res = abs_number << 2 ; } else if ( abs_number < 10000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 100000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 1024@@ 000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0xFFF ; } if ( number < 0 ) { res |= 0x1 << 12 ; } } return res ; } void AP_Frsky_Telem :: calc_nav_alt ( void ) { Location loc ; float current_height = 0 ; if ( _ahrs . get_position ( loc ) ) { current_height = loc . alt * 0.01f ; if ( ! loc . flags . relative_alt ) { current_height -= _ahrs . get_home ( ) . alt * 0.01f ; } } _gps . alt_nav_meters = ( int16_t ) current_height ; _gps . alt_nav_cm = ( current_height - _gps . alt_nav_meters ) * 100 ; } float AP_Frsky_Telem :: format_gps ( float dec ) { uint8_t dm_deg = ( uint8_t ) dec ; return ( dm_deg * 100.0f ) + ( dec - dm_deg ) * 60 ; } void AP_Frsky_Telem :: calc_gps_position ( void ) { float lat ; float lon ; float alt ; float speed ; if ( AP :: gps ( ) . status ( ) >= 3 ) { const Location & loc = AP :: gps ( ) . location ( ) ; lat = format_gps ( fabsf ( loc . lat / 10000000.0f ) ) ; _gps . latdddmm = lat ; _gps . latmmmm = ( lat - _gps . latdddmm ) * 10000 ; _gps . lat_ns = ( loc . lat < 0 ) ? ' S ' : ' N ' ; lon = format_gps ( fabsf ( loc . lng / 10000000.0f ) ) ; _gps . londddmm = lon ; _gps . lonmmmm = ( lon - _gps . londddmm ) * 10000 ; _gps . lon_ew = ( loc . lng < 0 ) ? ' W ' : ' E ' ; alt = loc . alt * 0.01f ; _gps . alt_gps_meters = ( int16_t ) alt ; _gps . alt_gps_cm = ( alt - _gps . alt_gps_meters ) * 100 ; speed = AP :: gps ( ) . ground_speed ( ) ; _gps . speed_in_meter = speed ; _gps . speed_in_centimeter = ( speed - _gps . speed_in_meter ) * 100 ; } else { _gps . latdddmm = 0 ; _gps . latmmmm = 0 ; _gps . lat_ns = 0 ; _gps . londddmm = 0 ; _gps . lonmmmm = 0 ; _gps . alt_gps_meters = 0 ; _gps . alt_gps_cm = 0 ; _gps . speed_in_meter = 0 ; _gps . speed_in_centimeter = 0 ; } } </DOCUMENT>
<DOCUMENT_ID="er@@ iser/@@ Obxd/tree/master/JuceLibraryCode/modules/juce_@@ box2d/@@ box2d/@@ Common/@@ b2StackAllocator@@ .cpp"> # include " b2StackAllocator . h " # include " b2Math . h " b2StackAllocator :: b2StackAllocator ( ) { m_index = 0 ; m_allocation = 0 ; m_maxAllocation = 0 ; m_entryCount = 0 ; } b2StackAllocator :: ~ b2StackAllocator ( ) { b2Assert ( m_index == 0 ) ; b2Assert ( m_entryCount == 0 ) ; } void * b2StackAllocator :: Allocate ( int32 size ) { b2Assert ( m_entryCount < b2_@@ maxStack@@ Entries ) ; b2StackEntry * entry = m_entries + m_entryCount ; entry -> size = size ; if ( m_index + size > b2_@@ stackSize ) { entry -> data = ( char * ) b2Alloc ( size ) ; entry -> usedMalloc = true ; } else { entry -> data = m_data + m_index ; entry -> usedMalloc = false ; m_index += size ; } m_allocation += size ; m_maxAllocation = b2Max ( m_maxAllocation , m_allocation ) ; ++ m_entryCount ; return entry -> data ; } void b2StackAllocator :: Free ( void * p ) { b2Assert ( m_entryCount > 0 ) ; b2StackEntry * entry = m_entries + m_entryCount - 1 ; b2Assert ( p == entry -> data ) ; if ( entry -> usedMalloc ) { b2Free ( p ) ; } else { m_index -= entry -> size ; } m_allocation -= entry -> size ; -- m_entryCount ; p = NULL ; } int32 b2StackAllocator :: GetMax@@ Allocation ( ) const { return m_maxAllocation ; } </DOCUMENT>
<DOCUMENT_ID="relip@@ se/on@@ eth@@ four-ch@@ ess-client@@ /tree/master/src/quaz@@ ip/JlComp@@ ress.cpp"> # include " JlCompress . h " # include < QDebug > static bool copyData ( QIODevice & inFile , QIODevice & outFile ) { while ( ! inFile . atEnd ( ) ) { char buf [ 4096 ] ; qint64 readLen = inFile . read ( buf , 4096 ) ; if ( readLen <= 0 ) return false ; if ( outFile . write ( buf , readLen ) != readLen ) return false ; } return true ; } bool JlCompress :: compressFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QFile inFile ; inFile . setFileName ( fileName ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) ) return false ; QuaZipFile outFile ( zip ) ; if ( ! outFile . open ( QIODevice :: WriteOnly , QuaZip@@ NewInfo ( fileDest , inFile . fileName ( ) ) ) ) return false ; if ( ! copyData ( inFile , outFile ) || outFile . getZipError ( ) != UNZ_OK ) { return false ; } outFile . close ( ) ; if ( outFile . getZipError ( ) != UNZ_OK ) return false ; inFile . close ( ) ; return true ; } bool JlCompress :: compressSubDir ( QuaZip * zip , QString dir , QString origDir , bool recursive ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QDir directory ( dir ) ; if ( ! directory . exists ( ) ) return false ; if ( recursive ) { QFileInfoList files = directory . entryInfoList ( QDir :: AllDirs | QDir :: NoDot@@ AndDot@@ Dot ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! compressSubDir ( zip , file . absoluteFilePath ( ) , origDir , recursive ) ) return false ; } } QFileInfoList files = directory . entryInfoList ( QDir :: Files ) ; QDir origDirectory ( origDir ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! file . isFile ( ) || file . absoluteFilePath ( ) == zip -> getZipName ( ) ) continue ; QString filename = origDirectory . relative@@ FilePath ( file . absoluteFilePath ( ) ) ; if ( ! compressFile ( zip , file . absoluteFilePath ( ) , filename ) ) return false ; } return true ; } bool JlCompress :: extractFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdUnzip ) return false ; if ( ! fileName . isEmpty ( ) ) zip -> setCurrentFile ( fileName ) ; QuaZipFile inFile ( zip ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) || inFile . getZipError ( ) != UNZ_OK ) return false ; QDir curDir ; if ( ! curDir . mkpath ( QFileInfo ( fileDest ) . absolutePath ( ) ) ) { return false ; } if ( QFileInfo ( fileDest ) . isDir ( ) ) return true ; QFile outFile ; outFile . setFileName ( fileDest ) ; if ( ! outFile . open ( QIODevice :: WriteOnly ) ) return false ; if ( ! copyData ( inFile , outFile ) || inFile . getZipError ( ) != UNZ_OK ) { outFile . close ( ) ; removeFile ( QStringList ( fileDest ) ) ; return false ; } outFile . close ( ) ; inFile . close ( ) ; if ( inFile . getZipError ( ) != UNZ_OK ) { removeFile ( QStringList ( fileDest ) ) ; return false ; } return true ; } bool JlCompress :: removeFile ( QStringList listFile ) { bool ret = true ; for ( int i = 0 ; i < listFile . count ( ) ; i ++ ) { ret = ret && QFile :: remove ( listFile . at ( i ) ) ; } return ret ; } bool JlCompress :: compressFile ( QString fileCompressed , QString file ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressFile ( & zip , file , QFileInfo ( file ) . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } bool JlCompress :: compressFiles ( QString fileCompressed , QStringList files ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } QFileInfo info ; Q_FOREACH ( QString file , files ) { info . setFile ( file ) ; if ( ! info . exists ( ) || ! compressFile ( & zip , file , info . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } bool JlCompress :: compressDir ( QString fileCompressed , QString dir , bool recursive ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressSubDir ( & zip , dir , dir , recursive ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; } QString JlCompress :: extractFile ( QString fileCompressed , QString fileName , QString fileDest ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QString ( ) ; } if ( fileDest . isEmpty ( ) ) fileDest = fileName ; if ( ! extractFile ( & zip , fileName , fileDest ) ) { return QString ( ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( QStringList ( fileDest ) ) ; return QString ( ) ; } return QFileInfo ( fileDest ) . absoluteFilePath ( ) ; } QStringList JlCompress :: extractFiles ( QString fileCompressed , QStringList files , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QStringList extracted ; for ( int i = 0 ; i < files . count ( ) ; i ++ ) { QString absPath = QDir ( dir ) . absoluteFilePath ( files . at ( i ) ) ; if ( ! extractFile ( & zip , files . at ( i ) , absPath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absPath ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } QStringList JlCompress :: extractDir ( QString fileCompressed , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QDir directory ( dir ) ; QStringList extracted ; if ( ! zip . goToFirstFile ( ) ) { return QStringList ( ) ; } do { QString name = zip . getCurrentFileName ( ) ; QString absFilePath = directory . absoluteFilePath ( name ) ; if ( ! extractFile ( & zip , " " , absFilePath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absFilePath ) ; } while ( zip . goToNextFile ( ) ) ; zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; } QStringList JlCompress :: getFile@@ List ( QString fileCompressed ) { QuaZip * zip = new QuaZip ( QFileInfo ( fileCompressed ) . absoluteFilePath ( ) ) ; if ( ! zip -> open ( QuaZip :: mdUnzip ) ) { delete zip ; return QStringList ( ) ; } QStringList lst ; QuaZip@@ FileInfo info ; for ( bool more = zip -> goToFirstFile ( ) ; more ; more = zip -> goToNextFile ( ) ) { if ( ! zip -> getCurrentFileInfo ( & info ) ) { delete zip ; return QStringList ( ) ; } lst << info . name ; } zip -> close ( ) ; if ( zip -> getZipError ( ) != 0 ) { delete zip ; return QStringList ( ) ; } delete zip ; return lst ; } </DOCUMENT>
<DOCUMENT_ID="MazZz@@ inat@@ us/@@ storm@@ /tree/master/src/test/@@ storm@@ -par@@ s/util@@ ity/@@ ModelInstantiator@@ Test.cpp"> # include " gtest / gtest . h " # include " storm - config . h " # ifdef STORM_@@ HAVE_@@ CAR@@ L # include " storm / adapt@@ ers / RationalFunctionAdapter . h " # include < carl / numbers / numbers . h > # include < carl / core / VariablePool . h > # include " storm / settings / SettingsManager . h " # include " storm / settings / modules / GeneralSettings . h " # include " storm - pars / utility / ModelInstantiator . h " # include " storm / api / storm . h " # include " storm / models / sparse / Model . h " # include " storm / models / sparse / Dtmc . h " # include " storm / models / sparse / Mdp . h " TEST ( ModelInstantiatorTest , Brp@@ Prob ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.2989@@ 2789@@ 41 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.015880558@@ 32 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasState@@ Rewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransition@@ Rewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308@@ 32449@@ 5 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } } TEST ( ModelInstantiatorTest , Consens@@ us ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finish@@ ed\ " & \ " all _ coins _ equal _ 1\ " ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdp@@ PrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.3526@@ 577219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="cryptomet@@ h/@@ cryptomet@@ h_1/tree/master/src/@@ cryptopp@@ /v@@ mac.cpp"> # include " pch . h " # include " vmac . h " # include " argnames . h " # include " cpu . h " NAMESPACE_BEGIN ( CryptoP@@ P ) # if defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # include < intr@@ in . h > # endif # define VMAC_BOOL_WORD128 ( defined ( CRYPTOPP_WORD128_AVAILABLE ) && ! defined ( CRYPTOPP_X64_ASM_AVAILABLE ) ) # ifdef __BORLANDC__ # define const # endif static const word64 p64 = W64LIT ( 0xffffffffffff@@ feff ) ; static const word64 m62 = W64LIT ( 0x3fffffffffffffff ) ; static const word64 m63 = W64LIT ( 0x7fffffffffffffff ) ; static const word64 m64 = W64LIT ( 0xffffffffffff@@ ffff ) ; static const word64 mpoly = W64LIT ( 0x1fffffff1@@ fffffff ) ; # ifdef __BORLANDC__ # undef const # endif # if VMAC_BOOL_WORD128 # ifdef __power@@ pc_@@ _ # define m126 ( ( word128 ( m62 ) << 64 ) | m64 ) # else static const word128 m126 = ( word128 ( m62 ) << 64 ) | m64 ; # endif # endif void VMAC_Base :: Uncheck@@ edSetKey ( const byte * userKey , unsigned int keylength , const NameValuePai@@ rs & params ) { int digestLength = params . GetIntValueWithDefault ( Name :: DigestSize ( ) , DefaultDigestSize ( ) ) ; if ( digestLength != 8 && digestLength != 16 ) throw InvalidArgument ( " VMAC : ▁ DigestSize ▁ must ▁ be ▁ 8 ▁ or ▁ 16" ) ; m_is128 = digestLength == 16 ; m_L1KeyLength = params . GetIntValueWithDefault ( Name :: L1KeyLength ( ) , 128 ) ; if ( m_L1KeyLength <= 0 || m_L1KeyLength % 128 != 0 ) throw InvalidArgument ( " VMAC : ▁ L1KeyLength ▁ must ▁ be ▁ a ▁ positive ▁ multiple ▁ of ▁ 128" ) ; Allocate@@ Blocks ( ) ; BlockCipher & cipher = AccessCipher ( ) ; cipher . SetKey ( userKey , keylength , params ) ; unsigned int blockSize = cipher . BlockSize ( ) ; unsigned int blockSizeInWords = blockSize / sizeof ( word64 ) ; SecBlock < word64 > out ( blockSizeInWords ) ; SecByteBlock in ; in . Clean@@ New ( blockSize ) ; size_t i ; in [ 0 ] = 0x80 ; cipher . Advanced@@ ProcessBlocks ( in , NULL , ( byte * ) m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) , cipher . BT_@@ InBlock@@ IsCounter ) ; ConditionalByteReverse < word64 > ( BIG_ENDIAN_ORDER , m_nhKey ( ) , m_nhKey ( ) , m_nhKeySize ( ) * sizeof ( word64 ) ) ; in [ 0 ] = 0xC0 ; in [ 15 ] = 0 ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; m_polyState ( ) [ i * 4 + 2 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) & mpoly ; m_polyState ( ) [ i * 4 + 3 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) & mpoly ; in [ 15 ] ++ ; } in [ 0 ] = 0xE0 ; in [ 15 ] = 0 ; word64 * l3Key = m_l3Key ( ) ; for ( i = 0 ; i <= ( size_t ) m_is128 ; i ++ ) do { cipher . ProcessBlock ( in , out . BytePtr ( ) ) ; l3Key [ i * 2 + 0 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) ) ; l3Key [ i * 2 + 1 ] = GetWord < word64 > ( true , BIG_ENDIAN_ORDER , out . BytePtr ( ) + 8 ) ; in [ 15 ] ++ ; } while ( ( l3Key [ i * 2 + 0 ] >= p64 ) || ( l3Key [ i * 2 + 1 ] >= p64 ) ) ; m_padCached = false ; size_t nonceLength ; const byte * nonce = GetIV@@ AndThrowIf@@ Invalid ( params , nonceLength ) ; Resynchronize ( nonce , ( int ) nonceLength ) ; } void VMAC_Base :: GetNextIV ( RandomNumberGenerator & rng , byte * IV ) { SimpleKeyingInterface :: GetNextIV ( rng , IV ) ; IV [ 0 ] &= 0x7f ; } void VMAC_Base :: Resynchronize ( const byte * nonce , int len ) { size_t length = ThrowIf@@ InvalidIV@@ Length ( len ) ; size_t s = IVSize ( ) ; byte * storedNonce = m_nonce ( ) ; if ( m_is128 ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length ) ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; } else { if ( m_padCached && ( storedNonce [ s - 1 ] | 1 ) == ( nonce [ length - 1 ] | 1 ) ) { m_padCached = VerifyBuf@@ sEqual ( storedNonce + s - length , nonce , length - 1 ) ; for ( size_t i = 0 ; m_padCached && i < s - length ; i ++ ) m_padCached = ( storedNonce [ i ] == 0 ) ; } if ( ! m_padCached ) { memset ( storedNonce , 0 , s - length ) ; memcpy ( storedNonce + s - length , nonce , length - 1 ) ; storedNonce [ s - 1 ] = nonce [ length - 1 ] & 0xfe ; AccessCipher ( ) . ProcessBlock ( storedNonce , m_pad ( ) ) ; m_padCached = true ; } storedNonce [ s - 1 ] = nonce [ length - 1 ] ; } m_isFirstBlock = true ; Restart ( ) ; } void VMAC_Base :: HashEndianCor@@ rectedBlock ( const word64 * data ) { assert ( false ) ; throw 0 ; } # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 # pragma warning ( disable : 4731 ) void # ifdef __GNUC__ __attribute__ ( ( noinline ) ) # endif VMAC_Base :: VHASH_Update_SSE2 ( const word64 * data , size_t blocksRemainingInWord64 , int tagPart ) { const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; word32 L1KeyLength = m_L1KeyLength ; # ifdef __GNUC__ word32 temp ; __asm_@@ _ __vola@@ tile_@@ _ ( AS2 ( mov % % ebx , % 0 ) AS2 ( mov % 1 , % % ebx ) " . intel _ syntax ▁ noprefix ; " # else # if _MSC_VER < 1300 || defined ( __INTEL_COMPILER ) char isFirstBlock = m_isFirstBlock ; AS2 ( mov ebx , [ L1KeyLength ] ) AS2 ( mov dl , [ isFirstBlock ] ) # else AS2 ( mov ecx , this ) AS2 ( mov ebx , [ ecx + m_L1KeyLength ] ) AS2 ( mov dl , [ ecx + m_isFirstBlock ] ) # endif AS2 ( mov eax , tagPart ) AS2 ( shl eax , 4 ) AS2 ( mov edi , nhK ) AS2 ( add edi , eax ) AS2 ( add eax , eax ) AS2 ( add eax , polyS ) AS2 ( mov esi , data ) AS2 ( mov ecx , blocksRemainingInWord64 ) # endif AS2 ( shr ebx , 3 ) AS1 ( push ebp ) AS2 ( sub esp , 12 ) ASL ( 4 ) AS2 ( mov ebp , ebx ) AS2 ( cmp ecx , ebx ) AS2 ( cmov@@ l ebp , ecx ) AS2 ( sub ecx , ebp ) AS2 ( lea ebp , [ edi + 8 * ebp ] ) AS2 ( movq mm6 , [ esi ] ) AS2 ( paddq mm6 , [ edi ] ) AS2 ( movq mm5 , [ esi + 8 ] ) AS2 ( paddq mm5 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm6 ) ASS ( pshufw mm2 , mm6 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm6 , mm5 ) ASS ( pshufw mm3 , mm5 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm5 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( pxor mm7 , mm7 ) AS2 ( movd [ esp ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( movd [ esp + 4 ] , mm5 ) AS2 ( psrlq mm5 , 32 ) AS2 ( cmp edi , ebp ) ASJ ( je , 1 , f ) ASL ( 0 ) AS2 ( movq mm0 , [ esi ] ) AS2 ( paddq mm0 , [ edi ] ) AS2 ( movq mm1 , [ esi + 8 ] ) AS2 ( paddq mm1 , [ edi + 8 ] ) AS2 ( add esi , 16 ) AS2 ( add edi , 16 ) AS2 ( movq mm4 , mm0 ) AS2 ( paddq mm5 , mm2 ) ASS ( pshufw mm2 , mm0 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm0 , mm1 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) ASS ( pshufw mm3 , mm1 , 1 , 0 , 3 , 2 ) AS2 ( pmuludq mm1 , mm2 ) AS2 ( pmuludq mm2 , mm3 ) AS2 ( pmuludq mm3 , mm4 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd [ esp ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm0 ) AS2 ( movd [ esp + 4 ] , mm1 ) AS2 ( psrlq mm1 , 32 ) AS2 ( paddq mm5 , mm1 ) AS2 ( cmp edi , ebp ) ASJ ( jne , 0 , b ) ASL ( 1 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd [ esp + 8 ] , mm3 ) AS2 ( psrlq mm3 , 32 ) AS2 ( paddq mm5 , mm3 ) AS2 ( movd mm4 , [ esp ] ) AS2 ( paddq mm7 , mm4 ) AS2 ( movd mm4 , [ esp + 4 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( movd mm4 , [ esp + 8 ] ) AS2 ( paddq mm6 , mm4 ) AS2 ( lea ebp , [ 8 * ebx ] ) AS2 ( sub edi , ebp ) AS2 ( movd [ esp ] , mm7 ) AS2 ( psrlq mm7 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd [ esp + 4 ] , mm6 ) AS2 ( psrlq mm6 , 32 ) AS2 ( paddq mm5 , mm6 ) AS2 ( psllq mm5 , 2 ) AS2 ( psrlq mm5 , 2 ) # define a0 [ eax + 2 * 4 ] # define a1 [ eax + 3 * 4 ] # define a2 [ eax + 0 * 4 ] # define a3 [ eax + 1 * 4 ] # define k0 [ eax + 2 * 8 + 2 * 4 ] # define k1 [ eax + 2 * 8 + 3 * 4 ] # define k2 [ eax + 2 * 8 + 0 * 4 ] # define k3 [ eax + 2 * 8 + 1 * 4 ] AS2 ( test dl , dl ) ASJ ( jz , 2 , f ) AS2 ( movd mm1 , k0 ) AS2 ( movd mm0 , [ esp ] ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( movd mm1 , k1 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( paddq mm1 , mm2 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm5 , k2 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq a2 , mm0 ) AS2 ( xor edx , edx ) ASJ ( jmp , 3 , f ) ASL ( 2 ) AS2 ( movd mm0 , a3 ) AS2 ( movq mm4 , mm0 ) AS2 ( pmuludq mm0 , k3 ) AS2 ( movd mm1 , a0 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( movd mm2 , a1 ) AS2 ( movd mm6 , k1 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( movd mm3 , a2 ) AS2 ( psllq mm0 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( movq mm5 , mm3 ) AS2 ( movd mm7 , k0 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( pmuludq mm4 , mm7 ) AS2 ( pmuludq mm5 , mm6 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a1 ) AS2 ( paddq mm4 , mm5 ) AS2 ( movq mm5 , mm1 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( movd mm2 , a0 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movq mm3 , mm2 ) AS2 ( pmuludq mm2 , k3 ) AS2 ( pmuludq mm3 , mm7 ) AS2 ( movd [ esp + 8 ] , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( pmuludq mm7 , mm5 ) AS2 ( pmuludq mm5 , k3 ) AS2 ( paddq mm0 , mm1 ) AS2 ( movd mm1 , a2 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq mm4 , mm0 ) AS2 ( movd mm2 , a3 ) AS2 ( pmuludq mm2 , mm6 ) AS2 ( pmuludq mm6 , a0 ) AS2 ( psrlq mm0 , 31 ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , [ esp ] ) AS2 ( paddq mm0 , mm3 ) AS2 ( movd mm3 , a2 ) AS2 ( pmuludq mm3 , k3 ) AS2 ( paddq mm5 , mm1 ) AS2 ( movd mm1 , a3 ) AS2 ( pmuludq mm1 , k2 ) AS2 ( paddq mm5 , mm2 ) AS2 ( movd mm2 , [ esp + 4 ] ) AS2 ( psllq mm5 , 1 ) AS2 ( paddq mm0 , mm5 ) AS2 ( psllq mm4 , 33 ) AS2 ( movd a0 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( paddq mm6 , mm7 ) AS2 ( movd mm7 , [ esp + 8 ] ) AS2 ( paddq mm0 , mm6 ) AS2 ( paddq mm0 , mm2 ) AS2 ( paddq mm3 , mm1 ) AS2 ( psllq mm3 , 1 ) AS2 ( paddq mm0 , mm3 ) AS2 ( psrlq mm4 , 1 ) AS2 ( movd a1 , mm0 ) AS2 ( psrlq mm0 , 32 ) AS2 ( por mm4 , mm7 ) AS2 ( paddq mm0 , mm4 ) AS2 ( movq a2 , mm0 ) # undef a0 # undef a1 # undef a2 # undef a3 # undef k0 # undef k1 # undef k2 # undef k3 ASL ( 3 ) AS2 ( test ecx , ecx ) ASJ ( jnz , 4 , b ) AS2 ( add esp , 12 ) AS1 ( pop ebp ) AS1 ( emm@@ s ) # ifdef __GNUC__ " . att _ syntax ▁ prefix ; " AS2 ( mov % 0 , % % ebx ) : " = m " ( temp ) : " m " ( L1KeyLength ) , " c " ( blocksRemainingInWord64 ) , " S " ( data ) , " D " ( nhK + tagPart * 2 ) , " d " ( m_isFirstBlock ) , " a " ( polyS + tagPart * 4 ) : " memory " , " cc " ) ; # endif } # endif # if VMAC_BOOL_WORD128 # define DeclareNH ( a ) word128 a = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word128 p = word128 ( i1 ) * ( i2 ) ; rh = word64 ( p >> 64 ) ; rl = word64 ( p ) ; } # define AccumulateNH ( a , b , c ) a += word128 ( b ) * ( c ) # define Multiply128 ( r , i1 , i2 ) r = word128 ( word64 ( i1 ) ) * word64 ( i2 ) # else # if _MSC_VER >= 1400 && ! defined ( __INTEL_COMPILER ) # define MUL32 ( a , b ) __emul@@ u ( word32 ( a ) , word32 ( b ) ) # else # define MUL32 ( a , b ) ( ( word64 ) ( ( word32 ) ( a ) ) * ( word32 ) ( b ) ) # endif # if defined ( CRYPTOPP_X64_ASM_AVAILABLE ) # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) asm ( " mulq ▁ % 3" : " = a " ( rl ) , " = d " ( rh ) : " a " ( i1 ) , " g " ( i2 ) : " cc " ) ; # define AccumulateNH ( a , b , c ) asm ( " mulq ▁ % 3 ; ▁ addq ▁ % % rax , ▁ % 0 ; ▁ adcq ▁ % % rdx , ▁ % 1" : " + r " ( a ## 0 ) , " + r " ( a ## 1 ) : " a " ( b ) , " g " ( c ) : " % rdx " , " cc " ) ; # define ADD128 ( rh , rl , ih , il ) asm ( " addq ▁ % 3 , ▁ % 1 ; ▁ adcq ▁ % 2 , ▁ % 0" : " + r " ( rh ) , " + r " ( rl ) : " r " ( ih ) , " r " ( il ) : " cc " ) ; # elif defined ( _MSC_VER ) && ! CRYPTOPP_BOOL_SLOW_WORD64 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 # define MUL64 ( rh , rl , i1 , i2 ) ( rl ) = _umul128 ( i1 , i2 , & ( rh ) ) ; # define AccumulateNH ( a , b , c ) { word64 ph , pl ; pl = _umul128 ( b , c , & ph ) ; a ## 0 += pl ; a ## 1 += ph + ( a ## 0 < pl ) ; } # else # define VMAC_BOOL_32BIT 1 # define DeclareNH ( a ) word64 a ## 0 = 0 , a ## 1 = 0 , a ## 2 = 0 # define MUL64 ( rh , rl , i1 , i2 ) { word64 _i1 = ( i1 ) , _i2 = ( i2 ) ; word64 m1 = MUL32 ( _i1 , _i2 >> 32 ) ; word64 m2 = MUL32 ( _i1 >> 32 , _i2 ) ; rh = MUL32 ( _i1 >> 32 , _i2 >> 32 ) ; rl = MUL32 ( _i1 , _i2 ) ; ADD128 ( rh , rl , ( m1 >> 32 ) , ( m1 << 32 ) ) ; ADD128 ( rh , rl , ( m2 >> 32 ) , ( m2 << 32 ) ) ; } # define AccumulateNH ( a , b , c ) { word64 p = MUL32 ( b , c ) ; a ## 1 += word32 ( ( p ) >> 32 ) ; a ## 0 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , c ) ; a ## 2 += word32 ( ( p ) >> 32 ) ; a ## 1 += word32 ( p ) ; p = MUL32 ( ( b ) >> 32 , ( c ) >> 32 ) ; a ## 2 += p ; p = MUL32 ( b , ( c ) >> 32 ) ; a ## 1 += word32 ( p ) ; a ## 2 += word32 ( p >> 32 ) ; } # endif # endif # ifndef VMAC_BOOL_32BIT # define VMAC_BOOL_32BIT 0 # endif # ifndef ADD128 # define ADD128 ( rh , rl , ih , il ) { word64 _il = ( il ) ; ( rl ) += ( _il ) ; ( rh ) += ( ih ) + ( ( rl ) < ( _il ) ) ; } # endif # if ! ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) template < bool T_128BitTag > # endif void VMAC_Base :: VHASH_Update_Template ( const word64 * data , size_t blocksRemainingInWord64 ) { # define INNER_LOOP_ITERATION ( j ) { word64 d0 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 0 ] ) ; word64 d1 = ConditionalByteReverse ( LITTLE_ENDIAN_ORDER , data [ i + 2 * j + 1 ] ) ; AccumulateNH ( nhA , d0 + nhK [ i + 2 * j + 0 ] , d1 + nhK [ i + 2 * j + 1 ] ) ; if ( T_128BitTag ) AccumulateNH ( nhB , d0 + nhK [ i + 2 * j + 2 ] , d1 + nhK [ i + 2 * j + 3 ] ) ; } # if ( defined ( _MSC_VER ) && _MSC_VER < 1300 ) bool T_128BitTag = m_is128 ; # endif size_t L1KeyLengthInWord64 = m_L1KeyLength / 8 ; size_t innerLoopEnd = L1KeyLengthInWord64 ; const word64 * nhK = m_nhKey ( ) ; word64 * polyS = m_polyState ( ) ; bool isFirstBlock = true ; size_t i ; # if ! VMAC_BOOL_32BIT # if VMAC_BOOL_WORD128 word128 a1 , a2 ; # else word64 ah1 , al1 , ah2 , al2 ; # endif word64 kh1 , kl1 , kh2 , kl2 ; kh1 = ( polyS + 0 * 4 + 2 ) [ 0 ] ; kl1 = ( polyS + 0 * 4 + 2 ) [ 1 ] ; if ( T_128BitTag ) { kh2 = ( polyS + 1 * 4 + 2 ) [ 0 ] ; kl2 = ( polyS + 1 * 4 + 2 ) [ 1 ] ; } # endif do { DeclareNH ( nhA ) ; DeclareNH ( nhB ) ; i = 0 ; if ( blocksRemainingInWord64 < L1KeyLengthInWord64 ) { if ( blocksRemainingInWord64 % 8 ) { innerLoopEnd = blocksRemainingInWord64 % 8 ; for ( ; i < innerLoopEnd ; i += 2 ) INNER_LOOP_ITERATION ( 0 ) ; } innerLoopEnd = blocksRemainingInWord64 ; } for ( ; i < innerLoopEnd ; i += 8 ) { INNER_LOOP_ITERATION ( 0 ) ; INNER_LOOP_ITERATION ( 1 ) ; INNER_LOOP_ITERATION ( 2 ) ; INNER_LOOP_ITERATION ( 3 ) ; } blocksRemainingInWord64 -= innerLoopEnd ; data += innerLoopEnd ; # if VMAC_BOOL_32BIT word32 nh0 [ 2 ] , nh1 [ 2 ] ; word64 nh2 [ 2 ] ; nh0 [ 0 ] = word32 ( nhA0 ) ; nhA1 += ( nhA0 >> 32 ) ; nh1 [ 0 ] = word32 ( nhA1 ) ; nh2 [ 0 ] = ( nhA2 + ( nhA1 >> 32 ) ) & m62 ; if ( T_128BitTag ) { nh0 [ 1 ] = word32 ( nhB0 ) ; nhB1 += ( nhB0 >> 32 ) ; nh1 [ 1 ] = word32 ( nhB1 ) ; nh2 [ 1 ] = ( nhB2 + ( nhB1 >> 32 ) ) & m62 ; } # define a0 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define a1 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define a2 ( ( ( word32 * ) ( polyS + i * 4 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define a3 ( * ( ( ( word32 * ) ( polyS + i * 4 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define aHi ( ( polyS + i * 4 ) [ 0 ] ) # define k0 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 2 + NativeByteOrder :: ToEnum ( ) ] ) # define k1 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 3 - NativeByteOrder :: ToEnum ( ) ) ) # define k2 ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) [ 0 + NativeByteOrder :: ToEnum ( ) ] ) # define k3 ( * ( ( ( word32 * ) ( polyS + i * 4 + 2 ) ) + 1 - NativeByteOrder :: ToEnum ( ) ) ) # define kHi ( ( polyS + i * 4 + 2 ) [ 0 ] ) if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 t = ( word64 ) nh0 [ i ] + k0 ; a0 = ( word32 ) t ; t = ( t >> 32 ) + nh1 [ i ] + k1 ; a1 = ( word32 ) t ; aHi = ( t >> 32 ) + nh2 [ i ] + kHi ; } continue ; } } for ( i = 0 ; i <= ( size_t ) T_128BitTag ; i ++ ) { word64 p , t ; word32 t2 ; p = MUL32 ( a3 , 2 * k3 ) ; p += nh2 [ i ] ; p += MUL32 ( a0 , k2 ) ; p += MUL32 ( a1 , k1 ) ; p += MUL32 ( a2 , k0 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += MUL32 ( a0 , k3 ) ; p += MUL32 ( a1 , k2 ) ; p += MUL32 ( a2 , k1 ) ; p += MUL32 ( a3 , k0 ) ; t = ( word64 ( word32 ( p ) & 0x7fffffff ) << 32 ) | t2 ; p >>= 31 ; p += nh0 [ i ] ; p += MUL32 ( a0 , k0 ) ; p += MUL32 ( a1 , 2 * k3 ) ; p += MUL32 ( a2 , 2 * k2 ) ; p += MUL32 ( a3 , 2 * k1 ) ; t2 = ( word32 ) p ; p >>= 32 ; p += nh1 [ i ] ; p += MUL32 ( a0 , k1 ) ; p += MUL32 ( a1 , k0 ) ; p += MUL32 ( a2 , 2 * k3 ) ; p += MUL32 ( a3 , 2 * k2 ) ; a0 = t2 ; a1 = ( word32 ) p ; aHi = ( p >> 32 ) + t ; } # undef a0 # undef a1 # undef a2 # undef a3 # undef aHi # undef k0 # undef k1 # undef k2 # undef k3 # undef kHi # else if ( isFirstBlock ) { isFirstBlock = false ; if ( m_isFirstBlock ) { m_isFirstBlock = false ; # if VMAC_BOOL_WORD128 # define first_poly_step ( a , kh , kl , m ) a = ( m & m126 ) + ( ( word128 ( kh ) << 64 ) | kl ) first_poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) first_poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define first_poly_step ( ah , al , kh , kl , mh , ml ) { mh &= m62 ; ADD128 ( mh , ml , kh , kl ) ; ah = mh ; al = ml ; } first_poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) first_poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif continue ; } else { # if VMAC_BOOL_WORD128 a1 = ( word128 ( ( polyS + 0 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 0 * 4 ) [ 1 ] ; # else ah1 = ( polyS + 0 * 4 ) [ 0 ] ; al1 = ( polyS + 0 * 4 ) [ 1 ] ; # endif if ( T_128BitTag ) { # if VMAC_BOOL_WORD128 a2 = ( word128 ( ( polyS + 1 * 4 ) [ 0 ] ) << 64 ) | ( polyS + 1 * 4 ) [ 1 ] ; # else ah2 = ( polyS + 1 * 4 ) [ 0 ] ; al2 = ( polyS + 1 * 4 ) [ 1 ] ; # endif } } } # if VMAC_BOOL_WORD128 # define poly_step ( a , kh , kl , m ) { word128 t1 , t2 , t3 , t4 ; Multiply128 ( t2 , a >> 64 , kl ) ; Multiply128 ( t3 , a , kh ) ; Multiply128 ( t1 , a , kl ) ; Multiply128 ( t4 , a >> 64 , 2 * kh ) ; t2 += t3 ; t4 += t1 ; t2 += t4 >> 64 ; a = ( word128 ( word64 ( t2 ) & m63 ) << 64 ) | word64 ( t4 ) ; t2 *= 2 ; a += m & m126 ; a += t2 >> 64 ; } poly_step ( a1 , kh1 , kl1 , nhA ) ; if ( T_128BitTag ) poly_step ( a2 , kh2 , kl2 , nhB ) ; # else # define poly_step ( ah , al , kh , kl , mh , ml ) { word64 t1h , t1l , t2h , t2l , t3h , t3l , z = 0 ; MUL64 ( t2h , t2l , ah , kl ) ; MUL64 ( t3h , t3l , al , kh ) ; MUL64 ( t1h , t1l , ah , 2 * kh ) ; MUL64 ( ah , al , al , kl ) ; ADD128 ( t2h , t2l , t3h , t3l ) ; ADD128 ( ah , al , t1h , t1l ) ; ADD128 ( t2h , ah , z , t2l ) ; t2h += t2h + ( ah >> 63 ) ; ah &= m63 ; mh &= m62 ; ADD128 ( ah , al , mh , ml ) ; ADD128 ( ah , al , z , t2h ) ; } poly_step ( ah1 , al1 , kh1 , kl1 , nhA1 , nhA0 ) ; if ( T_128BitTag ) poly_step ( ah2 , al2 , kh2 , kl2 , nhB1 , nhB0 ) ; # endif # endif } while ( blocksRemainingInWord64 ) ; # if VMAC_BOOL_WORD128 ( polyS + 0 * 4 ) [ 0 ] = word64 ( a1 >> 64 ) ; ( polyS + 0 * 4 ) [ 1 ] = word64 ( a1 ) ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = word64 ( a2 >> 64 ) ; ( polyS + 1 * 4 ) [ 1 ] = word64 ( a2 ) ; } # elif ! VMAC_BOOL_32BIT ( polyS + 0 * 4 ) [ 0 ] = ah1 ; ( polyS + 0 * 4 ) [ 1 ] = al1 ; if ( T_128BitTag ) { ( polyS + 1 * 4 ) [ 0 ] = ah2 ; ( polyS + 1 * 4 ) [ 1 ] = al2 ; } # endif } inline void VMAC_Base :: VHASH_Update ( const word64 * data , size_t blocksRemainingInWord64 ) { # if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE && CRYPTOPP_BOOL_X86 if ( HasSSE2 ( ) ) { VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 0 ) ; if ( m_is128 ) VHASH_Update_SSE2 ( data , blocksRemainingInWord64 , 1 ) ; m_isFirstBlock = false ; } else # endif { # if defined ( _MSC_VER ) && _MSC_VER < 1300 VHASH_Update_Template ( data , blocksRemainingInWord64 ) ; # else if ( m_is128 ) VHASH_Update_Template < true > ( data , blocksRemainingInWord64 ) ; else VHASH_Update_Template < false > ( data , blocksRemainingInWord64 ) ; # endif } } size_t VMAC_Base :: HashMultiple@@ Blocks ( const word64 * data , size_t length ) { size_t remaining = ModPowerOf2 ( length , m_L1KeyLength ) ; VHASH_Update ( data , ( length - remaining ) / 8 ) ; return remaining ; } static word64 L3Hash ( const word64 * input , const word64 * l3Key , size_t len ) { word64 rh , rl , t , z = 0 ; word64 p1 = input [ 0 ] , p2 = input [ 1 ] ; word64 k1 = l3Key [ 0 ] , k2 = l3Key [ 1 ] ; t = p1 >> 63 ; p1 &= m63 ; ADD128 ( p1 , p2 , len , t ) ; t = ( p1 > m63 ) + ( ( p1 == m63 ) & ( p2 == m64 ) ) ; ADD128 ( p1 , p2 , z , t ) ; p1 &= m63 ; t = p1 + ( p2 >> 32 ) ; t += ( t >> 32 ) ; t += ( word32 ) t > 0xfffffffe@@ U ; p1 += ( t >> 32 ) ; p2 += ( p1 << 32 ) ; p1 += k1 ; p1 += ( 0 - ( p1 < k1 ) ) & 257 ; p2 += k2 ; p2 += ( 0 - ( p2 < k2 ) ) & 257 ; MUL64 ( rh , rl , p1 , p2 ) ; t = rh >> 56 ; ADD128 ( t , rl , z , rh ) ; rh <<= 8 ; ADD128 ( t , rl , z , rh ) ; t += t << 8 ; rl += t ; rl += ( 0 - ( rl < t ) ) & 257 ; rl += ( 0 - ( rl > p64 - 1 ) ) & 257 ; return rl ; } void VMAC_Base :: Trunc@@ atedFinal ( byte * mac , size_t size ) { size_t len = ModPowerOf2 ( GetBitCountLo ( ) / 8 , m_L1KeyLength ) ; if ( len ) { memset ( m_data ( ) + len , 0 , ( 0 - len ) % 16 ) ; VHASH_Update ( DataBuf ( ) , ( ( len + 15 ) / 16 ) * 2 ) ; len *= 8 ; } else if ( m_isFirstBlock ) { m_polyState ( ) [ 0 ] = m_polyState ( ) [ 2 ] ; m_polyState ( ) [ 1 ] = m_polyState ( ) [ 3 ] ; if ( m_is128 ) { m_polyState ( ) [ 4 ] = m_polyState ( ) [ 6 ] ; m_polyState ( ) [ 5 ] = m_polyState ( ) [ 7 ] ; } } if ( m_is128 ) { word64 t [ 2 ] ; t [ 0 ] = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) ) ; t [ 1 ] = L3Hash ( m_polyState ( ) + 4 , m_l3Key ( ) + 2 , len ) + GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + 8 ) ; if ( size == 16 ) { PutWord ( false , BIG_ENDIAN_ORDER , mac , t [ 0 ] ) ; PutWord ( false , BIG_ENDIAN_ORDER , mac + 8 , t [ 1 ] ) ; } else { t [ 0 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 0 ] ) ; t [ 1 ] = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t [ 1 ] ) ; memcpy ( mac , t , size ) ; } } else { word64 t = L3Hash ( m_polyState ( ) , m_l3Key ( ) , len ) ; t += GetWord < word64 > ( true , BIG_ENDIAN_ORDER , m_pad ( ) + ( m_nonce ( ) [ IVSize ( ) - 1 ] & 1 ) * 8 ) ; if ( size == 8 ) PutWord ( false , BIG_ENDIAN_ORDER , mac , t ) ; else { t = ConditionalByteReverse ( BIG_ENDIAN_ORDER , t ) ; memcpy ( mac , & t , size ) ; } } } NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="b@@ raind@@ x/@@ scummvm@@ /tree/master/engines@@ /titan@@ ic/g@@ fx/icon@@ _nav@@ _receive@@ .cpp"> # include " titanic / gf@@ x / icon _ na@@ v _ receive . h " namespace Titanic { EMP@@ TY_@@ MESSAGE_MAP ( CIconNavReceive , CPetGraphic ) ; void CIconNavReceive :: save ( SimpleFile * file , int indent ) { file -> writeNumber@@ Line ( 1 , indent ) ; CPetGraphic :: save ( file , indent ) ; } void CIconNavReceive :: load ( SimpleFile * file ) { file -> readNumber ( ) ; CPetGraphic :: load ( file ) ; } } </DOCUMENT>
<DOCUMENT_ID="Su@@ perHex@@ /p@@ sychic@@ -aero@@ /tree/master/base/@@ HAL.cpp"> # ifndef __HAL__ # define __HAL__ # include . . / config / config . h # include < avr / io . h > namespace base { template < class init_traits , class rw_traits > struct hal { typedef init_traits I ; typedef rw_traits RW ; public : hal ( ) { I :: init ( ) ; } virtual ~ hal ( ) ; virtual void write ( const unsigned char data ) { RW :: write ( data ) ; } virtual unsigned char read ( ) { return RW :: read ( ) ; } } ; struct skip_init { static void init ( ) { } } ; struct USART_default_init { static void init ( const long baudRate ) { long ubrr = F_CPU / 16 / baudRate - 1 ; UBR@@ R0@@ H = ubrr >> 8 ; UBR@@ R0L = ubrr ; UCSR0@@ B = ( 1 << RXEN@@ 0 ) | ( 1 << TXEN0 ) ; UCSR0@@ C = ( 3 << UCS@@ Z00 ) ; } } ; struct USART_8N1_RW { public : static void write ( const unsigned char data ) { while ( ! ( UCSR0A & ( 1 << UD@@ RE0 ) ) ) ; UDR0 = data ; } static unsigned char read ( ) { while ( ! ( UCSR0A & ( 1 << RXC@@ 0 ) ) ) ; return UDR0 ; } } ; struct SPI_RW { static void write ( unsigned char data ) { SPDR = data ; while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; } static unsigned char read ( ) { while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; return SPDR ; } } ; struct SPI_master_init { static void init ( ) { DDRB |= ( 1 << PB3 ) | ( 1 << PB5 ) | ( 1 << PB2 ) ; SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 ) ; } } ; struct SPI_slave_init { static void init ( ) { DDRB |= ( 1 << PB4 ) ; SPCR = ( 1 << SPE ) ; } } ; template < class T = USART_default_init > struct USART : public hal < skip_init , USART_8N1_RW > { public : USART ( const long Rate ) { T :: init ( Rate ) ; } virtual ~ USART ( ) ; } ; typedef USART < > Serial ; template < class T > struct SPI : public hal < T , SPI_RW > { } ; typedef SPI < SPI_master_init > SPIMaster ; typedef SPI < SPI_slave_init > SPIS@@ lave ; } # endif </DOCUMENT>
<DOCUMENT_ID="Horiz@@ on-Blue@@ /play@@ ground/tree/master/Sol@@ ution@@ s-to-O@@ Js/@@ USACO/@@ Chapter1/1.1/@@ 02_@@ your-ride@@ -is@@ -h@@ ere.cpp"> # include < iostream > # include < fstream > # include < string > using namespace std ; int main ( ) { ofstream fout ( " ride . out " ) ; ifstream fin ( " ride . in " ) ; string a , b ; fin >> a >> b ; int anum = 1 , bnum = 1 ; for ( char c : a ) anum *= c - ' A ' + 1 ; for ( char c : b ) bnum *= c - ' A ' + 1 ; if ( anum % 47 == bnum % 47 ) fout << " GO " << endl ; else fout << " STAY " << endl ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="sys@@ lover@@ 33/ct@@ ank@@ /tree/master/jav@@ a/android@@ -sdk-@@ linu@@ x_r24@@ .4.@@ 1_src/nd@@ k-bund@@ le_r11@@ c/@@ sources/cxx@@ -st@@ l/@@ llvm-@@ libc++@@ /libcxx/test/@@ localization@@ /local@@ es/locale@@ .con@@ ven@@ ience@@ /conversion@@ s/conversion@@ s.buffer@@ /pback@@ fail@@ .pass.cpp"> # include < locale > # include < codecv@@ t > # include < fstream > # include < cassert > struct test_buf : public std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > { typedef std :: wbuffer_convert < std :: codecvt_utf8 < wchar_t > > base ; typedef base :: char_type char_type ; typedef base :: int_type int_type ; typedef base :: traits_type traits_type ; explicit test_buf ( std :: stream@@ buf * sb ) : base ( sb ) { } char_type * eback ( ) const { return base :: eback ( ) ; } char_type * gptr ( ) const { return base :: gptr ( ) ; } char_type * egptr ( ) const { return base :: egptr ( ) ; } void gbump ( int n ) { base :: gbump ( n ) ; } virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; } } ; int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } } </DOCUMENT>
<DOCUMENT_ID="S@@ overance@@ /Ethereal@@ Legend@@ s/tree/master/Ethereal@@ /Priv@@ ate/Ge@@ ar/@@ Weapons/Rang@@ ed/Annihilator@@ .cpp"> # include " Ethereal . h " # include " Annihilator . h " # define LOCTEXT_NAMESPACE " Ethereal@@ Text " AAnnihilator :: AAnnihilator ( const FObjectInitializer & ObjectInitializer ) : Super ( ObjectInitializer ) { static ConstructorHelpers :: FObjectFinder < USkeletalMesh > SkeletalMeshObject ( TEXT ( " SkeletalMesh ' / Game / VFX / sphere _ skeletal . sphere _ skeletal ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > StaticMeshObject ( TEXT ( " StaticMesh ' / Game / Weapons / Ranged / Anni . Anni ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > Offhand@@ MeshObject ( TEXT ( " StaticMesh ' / Game / VFX / sphere . sphere ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > LargeIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator . WeaponIcon _ Annihilator ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > SmallIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator - small . WeaponIcon _ Annihilator - small ' " ) ) ; Name = EMasterGear@@ List :: GL_Annihilator ; NameText = LOCTEXT ( " Annihilator@@ Name " , " Annihilator " ) ; Type = EMasterGear@@ Types :: GT_@@ Ranged ; TypeText = LOCTEXT ( " Annihilator@@ Type " , " Ranged " ) ; Description = " An ▁ embodi@@ ment ▁ of ▁ the ▁ Ethereal ▁ Virt@@ ue : ▁ Wrath . " ; Price = 40000 ; MPCost = 0.0f ; ATK = 50.0f ; DEF = 40.0f ; SPD = 20.0f ; HP = 500.0f ; MP = 250.0f ; Large@@ Icon = LargeIconObject . Object ; SmallIcon = SmallIconObject . Object ; SK_WeaponSkeletalMesh = SkeletalMeshObject . Object ; SM_WeaponStaticMesh = StaticMeshObject . Object ; SM_WeaponOffhandMesh = StaticMeshObject . Object ; WeaponSkeletalMesh -> SetSkeletalMesh ( SK_WeaponSkeletalMesh ) ; WeaponSkeletalMesh -> SetHiddenInGame ( true ) ; WeaponStaticMesh -> SetStaticMesh ( SM_WeaponStaticMesh ) ; WeaponStaticMesh -> SetWorld@@ Scale3D ( FVector ( 0.15f , 0.15f , 0.15f ) ) ; WeaponStaticMesh -> SetRelative@@ Location ( FVector ( 20 , - 2 , - 2 ) ) ; WeaponStaticMesh -> SetRelative@@ Rotation ( FRot@@ ator ( - 12 , - 90 , - 75 ) ) ; WeaponOffhandMesh -> SetStaticMesh ( SM_WeaponOffhandMesh ) ; WeaponOffhandMesh -> SetHiddenInGame ( true ) ; } void AAnnihilator :: BeginPlay ( ) { Super :: BeginPlay ( ) ; OnBind@@ Gear . AddDynamic ( this , & AAnnihilator :: BindWeapon ) ; } void AAnnihilator :: BindWeapon ( ) { if ( IsShown ) { ShowWeapon ( false , true , false ) ; } } # undef LOCTEXT_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="b@@ runola@@ uze@@ /MonoNative@@ /tree/master/MonoNative@@ /mscorlib@@ /System@@ /Runtime@@ /Remo@@ ting/Metadata@@ /W3cXsd200@@ 1/mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_So@@ apNmtoken@@ .cpp"> # include < mscorlib / System / Runtime / Remoting / Metadata / W3cXsd2001 / mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_So@@ apNmtoken . h > # include < mscorlib / System / mscorlib_System_@@ Type . h > namespace mscorlib { namespace System { namespace Runtime { namespace Remoting { namespace Metadata { namespace W3cXsd2001 { Property < mscorlib :: System :: String , mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken > mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: XsdType ( & mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: get_XsdType , & mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken :: set_XsdType ) ; mscorlib :: System :: String SoapNmtoken :: GetXsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " GetXsdType " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; } mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( const char * value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( " mscorlib " , " System " , " String " ) ; __parameters__ [ 0 ] = mono@@ _string_@@ new ( Global :: GetDo@@ main ( ) , value ) ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; } mscorlib :: System :: String SoapNmtoken :: ToString ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " ToString " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } mscorlib :: System :: String SoapNmtoken :: get_Value ( ) const { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ Value " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } void SoapNmtoken :: set_Value ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " set _ Value " , __native_object__ , 1 , __parameter_types__ , __parameters__ , NULL ) ; } mscorlib :: System :: String SoapNmtoken :: get_XsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ XsdType " , NullMonoObject , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; } void SoapNmtoken :: set_XsdType ( mscorlib :: System :: String value ) { throw ; } } } } } } } </DOCUMENT>
<DOCUMENT_ID="reg@@ neq/TrinityCore/tree/master/src/server/game/@@ Miscel@@ lane@@ ous/@@ Common@@ Predicates@@ .cpp"> # include " Common@@ Predicates . h " # include " Common . h " # include " Unit . h " # include " SharedDefin@@ es . h " Trinity :: Predicates :: IsVictimOf :: IsVictimOf ( Unit const * attacker ) : _victim ( attacker ? attacker -> GetVictim ( ) : nullptr ) { } </DOCUMENT>
<DOCUMENT_ID="p@@ ete318/TrinityCore/tree/master/src/server/@@ scripts/Northrend/@@ Fro@@ zen@@ Hall@@ s/HallsOfRef@@ lection/halls_of_ref@@ lect@@ ion.cpp"> # include " halls _ of _ reflection . h " # include " Creature . h " # include " EventProcessor . h " # include " InstanceScript . h " # include " MotionMaster . h " # include " MoveSplineInit . h " # include " ObjectAccessor . h " # include " ObjectGuid . h " # include " Player . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " ScriptMgr . h " # include " Spell . h " # include " SpellInfo . h " # include " SpellScript . h " # include " Temporary@@ Summon . h " # include " Transport . h " # include " Unit . h " enum Text { SAY_JAINA_INTRO_1 = 0 , SAY_JAINA_INTRO_2 = 1 , SAY_JAINA_INTRO_3 = 2 , SAY_JAINA_INTRO_4 = 3 , SAY_JAINA_INTRO_5 = 4 , SAY_JAINA_INTRO_6 = 5 , SAY_JAINA_INTRO_7 = 6 , SAY_JAINA_INTRO_8 = 7 , SAY_JAINA_INTRO_9 = 8 , SAY_JAINA_INTRO_10 = 9 , SAY_JAINA_INTRO_11 = 10 , SAY_JAINA_INTRO_END = 11 , SAY_SYLVANAS_INTRO_1 = 0 , SAY_SYLVANAS_INTRO_2 = 1 , SAY_SYLVANAS_INTRO_3 = 2 , SAY_SYLVANAS_INTRO_4 = 3 , SAY_SYLVANAS_INTRO_5 = 4 , SAY_SYLVANAS_INTRO_6 = 5 , SAY_SYLVANAS_INTRO_7 = 6 , SAY_SYLVANAS_INTRO_8 = 7 , SAY_SYLVANAS_INTRO_END = 8 , SAY_UTHER_INTRO_A2_1 = 0 , SAY_UTHER_INTRO_A2_2 = 1 , SAY_UTHER_INTRO_A2_3 = 2 , SAY_UTHER_INTRO_A2_4 = 3 , SAY_UTHER_INTRO_A2_5 = 4 , SAY_UTHER_INTRO_A2_6 = 5 , SAY_UTHER_INTRO_A2_7 = 6 , SAY_UTHER_INTRO_A2_8 = 7 , SAY_UTHER_INTRO_A2_9 = 8 , SAY_UTHER_INTRO_H2_1 = 9 , SAY_UTHER_INTRO_H2_2 = 10 , SAY_UTHER_INTRO_H2_3 = 11 , SAY_UTHER_INTRO_H2_4 = 12 , SAY_UTHER_INTRO_H2_5 = 13 , SAY_UTHER_INTRO_H2_6 = 14 , SAY_UTHER_INTRO_H2_7 = 15 , SAY_LK_INTRO_1 = 0 , SAY_LK_INTRO_2 = 1 , SAY_LK_INTRO_3 = 2 , SAY_LK_JAINA_INTRO_END = 3 , SAY_LK_SYLVANAS_INTRO_END = 4 , SAY_JAINA_SYLVANAS_ESCAPE_1 = 0 , SAY_JAINA_SYLVANAS_ESCAPE_2 = 1 , SAY_JAINA_SYLVANAS_ESCAPE_3 = 2 , SAY_JAINA_SYLVANAS_ESCAPE_4 = 3 , SAY_JAINA_SYLVANAS_ESCAPE_5 = 4 , SAY_JAINA_SYLVANAS_ESCAPE_6 = 5 , SAY_JAINA_SYLVANAS_ESCAPE_7 = 6 , SAY_JAINA_SYLVANAS_ESCAPE_8 = 7 , SAY_JAINA_ESCAPE_9 = 8 , SAY_JAINA_ESCAPE_10 = 9 , SAY_SYLVANAS_ESCAPE_9 = 8 , SAY_LK_ESCAPE_1 = 0 , SAY_LK_ESCAPE_2 = 1 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 = 2 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 = 3 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 = 4 , SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 = 5 , SAY_LK_ESCAPE_GHOULS = 6 , SAY_LK_ESCAPE_ABOMINATION = 7 , SAY_LK_ESCAPE_WINTER = 8 , SAY_LK_ESCAPE_HARVEST_SOUL = 9 , SAY_FALRIC_INTRO_1 = 5 , SAY_FALRIC_INTRO_2 = 6 , SAY_MARWYN_INTRO_1 = 4 } ; enum Events { EVENT_WALK_INTRO1 = 1 , EVENT_WALK_INTRO2 , EVENT_START_INTRO , EVENT_SKIP_INTRO , EVENT_INTRO_A2_1 , EVENT_INTRO_A2_2 , EVENT_INTRO_A2_3 , EVENT_INTRO_A2_4 , EVENT_INTRO_A2_5 , EVENT_INTRO_A2_6 , EVENT_INTRO_A2_7 , EVENT_INTRO_A2_8 , EVENT_INTRO_A2_9 , EVENT_INTRO_A2_10 , EVENT_INTRO_A2_11 , EVENT_INTRO_A2_12 , EVENT_INTRO_A2_13 , EVENT_INTRO_A2_14 , EVENT_INTRO_A2_15 , EVENT_INTRO_A2_16 , EVENT_INTRO_A2_17 , EVENT_INTRO_A2_18 , EVENT_INTRO_A2_19 , EVENT_INTRO_H2_1 , EVENT_INTRO_H2_2 , EVENT_INTRO_H2_3 , EVENT_INTRO_H2_4 , EVENT_INTRO_H2_5 , EVENT_INTRO_H2_6 , EVENT_INTRO_H2_7 , EVENT_INTRO_H2_8 , EVENT_INTRO_H2_9 , EVENT_INTRO_H2_10 , EVENT_INTRO_H2_11 , EVENT_INTRO_H2_12 , EVENT_INTRO_H2_13 , EVENT_INTRO_H2_14 , EVENT_INTRO_H2_15 , EVENT_INTRO_LK_1 , EVENT_INTRO_LK_2 , EVENT_INTRO_LK_3 , EVENT_INTRO_LK_4 , EVENT_INTRO_LK_5 , EVENT_INTRO_LK_6 , EVENT_INTRO_LK_7 , EVENT_INTRO_LK_8 , EVENT_INTRO_LK_9 , EVENT_INTRO_LK_10 , EVENT_INTRO_LK_11 , EVENT_INTRO_END , EVENT_ESCAPE , EVENT_ESCAPE_1 , EVENT_ESCAPE_2 , EVENT_ESCAPE_3 , EVENT_ESCAPE_4 , EVENT_ESCAPE_5 , EVENT_ESCAPE_6 , EVENT_ESCAPE_7 , EVENT_ESCAPE_8 , EVENT_ESCAPE_9 , EVENT_ESCAPE_10 , EVENT_ESCAPE_11 , EVENT_ESCAPE_12 , EVENT_ESCAPE_13 , EVENT_ESCAPE_14 , EVENT_ESCAPE_15 , EVENT_ESCAPE_16 , EVENT_ESCAPE_17 , EVENT_REMORSELESS_WINTER , EVENT_ESCAPE_SUMMON_GHOULS , EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , EVENT_OPEN_IMPENETRABLE_DOOR , EVENT_CLOSE_IMPENETRABLE_DOOR , EVENT_KORELN_LORALEN_DEATH } ; enum Misc { ACTION_START_@@ INTRO , ACTION@@ _SKIP_INTRO , JAINA_SYLVANAS_MAX_HEALTH = 252000 , POINT_SHADOW_THRONE_DOOR = 1 , POINT_ATTACK_ICEWALL = 2 , POINT_TRAP = 3 , SOUND_LK_SLAY_1 = 172@@ 14 , SOUND_LK_SLAY_2 = 172@@ 15 , SOUND_LK_FURY_OF_FROSTMOURNE = 17224 } ; enum Spells { SPELL_TAKE_FROSTMOURNE = 72729 , SPELL_FROSTMOURNE_@@ DESPAWN = 72726 , SPELL_FROSTMOURNE_VISUAL = 73220 , SPELL_FROSTMOURNE_SOUNDS = 70667 , SPELL_BOSS_SPAWN_AURA = 72712 , SPELL_UTHER_DESPAWN = 706@@ 93 , SPELL_CAST_VISUAL = 656@@ 33 , SPELL_SUMMON@@ _SOULS = 72711 , SPELL_TAUNT_ARTHAS = 69857 , SPELL_JAINA_ICE_BARRIER = 697@@ 87 , SPELL_JAINA_ICE_PRISON = 69708 , SPELL_JAINA_DESTROY_ICE_WALL = 697@@ 84 , SPELL_SYLVANAS_CLOAK_OF_DARKNESS = 70188 , SPELL_SYLVANAS_DARK_BINDING = 70194 , SPELL_SYLVANAS_DESTROY_ICE_WALL = 70224 , SPELL_SYLVANAS_BLINDING_RETREAT = 7019@@ 9 , SPELL_REMORSELESS_WINTER = 697@@ 80 , SPELL_SOUL@@ _RE@@ APER = 69409 , SPELL_FURY_OF_FROSTMOURNE = 70063 , SPELL_RAISE_DEAD = 69818 , SPELL_SUMMON_RISEN_WITCH_DOCTOR = 69836 , SPELL_SUMMON_LUMBERING_ABOMINATION = 69835 , SPELL_SUMMON_ICE_WALL = 69768 , SPELL_PAIN_AND_SUFFERING = 74115 , SPELL_STUN_BREAK_JAINA = 697@@ 64 , SPELL_STUN_BREAK_SYLVANAS = 70200 , SPELL_HARVEST_SOUL = 69866 , SPELL_FEIGN_DEATH = 29266 , SPELL_GHOUL_JUMP = 70150 , SPELL_RAGING_GHOUL_SPAWN = 69636 , SPELL_CURSE_OF_DOOM = 70144 , SPELL_SHADOW_BOLT_VOLLEY = 70145 , SPELL_SHADOW_BOLT = 70080 , SPELL_RISEN_WITCH_DOCTOR_SPAWN = 69639 , SPELL_CLEAVE = 40505 , SPELL_VOMIT_SPRAY = 70176 } ; enum Hor@@ GossipMenu { GOSSIP_MENU_JAINA_FINAL = 109@@ 30 , GOSSIP_MENU_SYLVANAS_FINAL = 109@@ 31 } ; Position const NpcJainaOrSylvanasEscapeRoute [ ] = { { 5601.@@ 217285f , 2207.6@@ 52832f , 731.@@ 541931@@ f , 5.22330@@ 4f } , { 5607@@ .224@@ 375f , 2173.9@@ 13330f , 731.@@ 1260@@ 38f , 2.60872@@ 3f } , { 5583.@@ 427246f , 2138.78@@ 4180f , 731.@@ 150391f , 4.260901f } , { 5560.281@@ 738f , 2104.0@@ 25635@@ f , 731.@@ 410@@ 889f , 4.0@@ 5838@@ 3f } , { 5510.@@ 990@@ 723f , 2000.7722@@ 17f , 734@@ .7@@ 16064f , 3.973213f } , { 545@@ 2.641113f , 1905@@ .76@@ 2329@@ f , 746.5@@ 30579@@ f , 4.1188@@ 34f } , { 5338.1269@@ 53f , 1768.@@ 429810f , 767.@@ 237244f , 3.855189@@ f } , { 5259@@ .06@@ f , 1669@@ .27@@ f , 784.@@ 3008f , 0.0f } , { 5265.@@ 53f , 1681.@@ 6f , 784.@@ 2947@@ f , 4.13643f } } ; Position const LichKingMoveAwayPos = { 5400.0@@ 69824@@ f , 2102.713@@ 1689f , 707.69525f , 0.84@@ 3803@@ f } ; Position const LichKingFirstSummon = { 5600.0@@ 76172f , 2192.270@@ 996f , 731.@@ 750488f , 4.3309@@ 35f } ; Position const JainaSylvanasShadowThrone@@ Door = { 5577@@ .24@@ 3f , 2235@@ .852f , 733@@ .0128f , 2.209562f } ; Position const LichKingFinalPos = { 5283.@@ 74218@@ 8f , 1706@@ .335@@ 693f , 783.@@ 293518@@ f , 4.138510f } ; Position const KorelnOrLoralenPos [ ] = { { 525@@ 3.061f , 1953.6@@ 16f , 707.6948f , 0.8377581f } , { 5283.@@ 226f , 1992.300f , 707.7445f , 0.8377581f } , { 536@@ 0.711f , 2064@@ .79@@ 7f , 707.6948f , 0.0f } } ; Position const SylvanasIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5263.2f , 1950.@@ 96f , 707.6948f , 0.80@@ 28514f } , { 5306@@ .82@@ f , 1998.@@ 17f , 709.34@@ 1f , 1.239@@ 184f } , } ; Position const JainaIntroPosition [ ] = { { 0.0f , 0.0f , 0.0f , 0.0f } , { 5265.@@ 89f , 1952@@ .98@@ f , 707.6978f , 0.0f } , { 5306@@ .9@@ 5f , 1998.@@ 49f , 709.34@@ 14f , 1.277@@ 278f } } ; Position const UtherSpawnPos = { 530@@ 7.814f , 2003.@@ 168f , 709.424@@ 4f , 4.537856@@ f } ; Position const LichKingIntroPosition [ ] = { { 536@@ 2.463f , 2062.693f , 707.7781f , 3.9@@ 44444f } , { 5332.@@ 83f , 2031.24f , 707.6948f , 0.0f } , { 5312.@@ 93f , 2010.@@ 24f , 709.34@@ f , 0.0f } , { 5319.0@@ 28f , 2016.66@@ 2f , 707.6948f , 0.0f } , { 5332.@@ 285f , 2030.@@ 832f , 707.6948f , 0.0f } , { 5355.488f , 2055.149@@ f , 707.6907f , 0.0f } } ; Position const FalricPosition [ ] = { { 5276.58@@ 3f , 2037.45f , 709.4025f , 5.532@@ 694f } , { 5283.@@ 95f , 2030.@@ 53f , 709.3191f , 0.0f } } ; Position const MarwynPosition [ ] = { { 534@@ 2.232f , 1975@@ .696f , 709.4025f , 2.39110@@ 1f } , { 5335.0@@ 1f , 1982@@ .37@@ f , 709.3191f , 0.0f } } ; Position const SylvanasShadowThroneDoorPosition = { 5576@@ .79@@ f , 2235@@ .73@@ f , 733@@ .00@@ 29f , 2.687807f } ; Position const IceWallTargetPosition [ ] = { { 5547@@ .833@@ f , 2083.@@ 701f , 731.@@ 4332@@ f , 1.0@@ 29744@@ f } , { 5503.213@@ f , 1969.547@@ f , 737.@@ 0245f , 1.27@@ 409f } , { 5439.9@@ 76f , 1879@@ .00@@ 5f , 752.@@ 7048f , 1.06@@ 4651f } , { 5318.@@ 289f , 1749.184f , 771.9@@ 423f , 0.872@@ 6646f } } ; class npc_jaina_or_sylvanas_intro_hor : public CreatureScript { public : npc_jaina_or_sylvanas_intro_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ intro _ hor " ) { } struct npc_jaina_or_sylvanas_intro_horAI : public ScriptedAI { npc_jaina_or_sylvanas_intro_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } bool GossipHello ( Player * player ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS || _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == SPECIAL ) { ClearGossipMenuFor ( player ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_START_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case 1 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; _events . ScheduleEvent ( EVENT_SKIP_INTRO , 1s ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } return false ; } void Reset ( ) override { _events . Reset ( ) ; _utherGUID . Clear ( ) ; _lichkingGUID . Clear ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; me -> SetStandState ( UNIT_STAND_STATE_STAND ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO1 , 3000 ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_WALK_INTRO1 : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 0 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 1 ] ) ; Talk ( SAY_JAINA_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 7000 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 1 ] ) ; Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_WALK_INTRO2 , 9000 ) ; } break ; case EVENT_WALK_INTRO2 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_2 ) ; else Talk ( SAY_SYLVANAS_INTRO_2 ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_START_INTRO : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_1 , 0 ) ; } else { me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_1 , 0 ) ; } break ; case EVENT_INTRO_A2_1 : Talk ( SAY_JAINA_INTRO_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_2 , 7000 ) ; break ; case EVENT_INTRO_A2_2 : Talk ( SAY_JAINA_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_3 , 10000 ) ; break ; case EVENT_INTRO_A2_3 : me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_4 , 10000 ) ; break ; case EVENT_INTRO_A2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_5 , 2000 ) ; break ; case EVENT_INTRO_A2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_6 , 3000 ) ; break ; case EVENT_INTRO_A2_6 : Talk ( SAY_JAINA_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_7 , 7000 ) ; break ; case EVENT_INTRO_A2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_8 , 7000 ) ; break ; case EVENT_INTRO_A2_8 : Talk ( SAY_JAINA_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_9 , 1200 ) ; break ; case EVENT_INTRO_A2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_10 , 11000 ) ; break ; case EVENT_INTRO_A2_10 : Talk ( SAY_JAINA_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_11 , 6000 ) ; break ; case EVENT_INTRO_A2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_12 , 12000 ) ; break ; case EVENT_INTRO_A2_12 : Talk ( SAY_JAINA_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_13 , 6000 ) ; break ; case EVENT_INTRO_A2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_14 , 13000 ) ; break ; case EVENT_INTRO_A2_14 : Talk ( SAY_JAINA_INTRO_9 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_15 , 12000 ) ; break ; case EVENT_INTRO_A2_15 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_16 , 25000 ) ; break ; case EVENT_INTRO_A2_16 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_17 , 6000 ) ; break ; case EVENT_INTRO_A2_17 : Talk ( SAY_JAINA_INTRO_10 ) ; _events . ScheduleEvent ( EVENT_INTRO_A2_18 , 5000 ) ; break ; case EVENT_INTRO_A2_18 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_8 ) ; } _events . ScheduleEvent ( EVENT_INTRO_A2_19 , 12000 ) ; break ; case EVENT_INTRO_A2_19 : Talk ( SAY_JAINA_INTRO_11 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 3000 ) ; break ; case EVENT_INTRO_H2_1 : Talk ( SAY_SYLVANAS_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_2 , 8000 ) ; break ; case EVENT_INTRO_H2_2 : Talk ( SAY_SYLVANAS_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_3 , 6000 ) ; break ; case EVENT_INTRO_H2_3 : Talk ( SAY_SYLVANAS_INTRO_3 ) ; me -> CastSpell ( me , SPELL_CAST_VISUAL , false ) ; me -> CastSpell ( me , SPELL_FROSTMOURNE_SOUNDS , true ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_FROSTMOURNE ) , true ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_4 , 6000 ) ; break ; case EVENT_INTRO_H2_4 : if ( Creature * uther = me -> SummonCreature ( NPC_UTHER , UtherSpawnPos , TEMPSUMMON_MANUAL_DESPAWN ) ) _utherGUID = uther -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_5 , 2000 ) ; break ; case EVENT_INTRO_H2_5 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_6 , 11000 ) ; break ; case EVENT_INTRO_H2_6 : Talk ( SAY_SYLVANAS_INTRO_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_7 , 3000 ) ; break ; case EVENT_INTRO_H2_7 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_8 , 6000 ) ; break ; case EVENT_INTRO_H2_8 : Talk ( SAY_SYLVANAS_INTRO_5 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_9 , 5000 ) ; break ; case EVENT_INTRO_H2_9 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_3 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_10 , 19000 ) ; break ; case EVENT_INTRO_H2_10 : Talk ( SAY_SYLVANAS_INTRO_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_11 , 1500 ) ; break ; case EVENT_INTRO_H2_11 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_4 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_12 , 19500 ) ; break ; case EVENT_INTRO_H2_12 : Talk ( SAY_SYLVANAS_INTRO_7 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_13 , 2000 ) ; break ; case EVENT_INTRO_H2_13 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> HandleEmoteCommand ( EMOTE_ONESHOT_NO ) ; uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_5 ) ; } _events . ScheduleEvent ( EVENT_INTRO_H2_14 , 12000 ) ; break ; case EVENT_INTRO_H2_14 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_6 ) ; _events . ScheduleEvent ( EVENT_INTRO_H2_15 , 8000 ) ; break ; case EVENT_INTRO_H2_15 : Talk ( SAY_SYLVANAS_INTRO_8 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_1 , 2000 ) ; break ; case EVENT_INTRO_LK_1 : if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> SetUInt32Value ( UNIT_NPC_EMO@@ TESTATE , EMOTE_STATE_@@ COWER ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_A2_9 ) ; else uther -> AI ( ) -> Talk ( SAY_UTHER_INTRO_H2_7 ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_2 , 10000 ) ; break ; case EVENT_INTRO_LK_2 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_1 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_3 , 1000 ) ; break ; case EVENT_INTRO_LK_3 : if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _utherGUID ) ) { uther -> CastSpell ( uther , SPELL_UTHER_DESPAWN , true ) ; uther -> DespawnOrUnsummon ( 5000 ) ; _utherGUID . Clear ( ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 9000 ) ; break ; case EVENT_INTRO_LK_4 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( GameObject * frostmourne = ObjectAccessor :: GetGameObject ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE ) ) ) frostmourne -> SetPhase@@ Mask ( 2 , true ) ; lichking -> CastSpell ( lichking , SPELL_TAKE_FROSTMOURNE , true ) ; lichking -> CastSpell ( lichking , SPELL_FROSTMOURNE_VISUAL , true ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_5 , 8000 ) ; break ; case EVENT_INTRO_LK_5 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_2 ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_6 , 10000 ) ; break ; case EVENT_INTRO_LK_6 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> AI ( ) -> Talk ( SAY_LK_INTRO_3 ) ; lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_7 , 10000 ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 5s ) ; break ; case EVENT_INTRO_LK_7 : if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> AI ( ) -> Talk ( SAY_MARWYN_INTRO_1 ) ; marwyn -> SetWalk ( true ) ; marwyn -> GetMotionMaster ( ) -> MovePoint ( 0 , MarwynPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_8 , 1000 ) ; break ; case EVENT_INTRO_LK_8 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_1 ) ; falric -> SetWalk ( true ) ; falric -> GetMotionMaster ( ) -> MovePoint ( 0 , FalricPosition [ 1 ] ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_9 , 5000 ) ; break ; case EVENT_INTRO_LK_9 : if ( Creature * falric = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FALRIC ) ) ) falric -> AI ( ) -> Talk ( SAY_FALRIC_INTRO_2 ) ; _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_10 , 4000 ) ; break ; case EVENT_INTRO_LK_10 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_INTRO_END ) ; else Talk ( SAY_SYLVANAS_INTRO_END ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingMoveAwayPos ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 1 , KorelnOrLoralenPos [ 2 ] ) ; _events . ScheduleEvent ( EVENT_INTRO_LK_11 , 5000 ) ; break ; case EVENT_INTRO_LK_11 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_JAINA_INTRO_END ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_SYLVANAS_INTRO_END ) ; } _events . ScheduleEvent ( EVENT_INTRO_END , 5s ) ; break ; case EVENT_INTRO_END : _instance -> SetData ( DATA_INTRO_EVENT , DONE ) ; _events . ScheduleEvent ( EVENT_KORELN_LORALEN_DEATH , 8s ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _lichkingGUID ) ) { lichking -> DespawnOrUnsummon ( 5000 ) ; _lichkingGUID . Clear ( ) ; } me -> DespawnOrUnsummon ( 10000 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 7s ) ; break ; case EVENT_SKIP_INTRO : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> GetMotionMaster ( ) -> MovePoint ( 0 , JainaIntroPosition [ 2 ] ) ; else me -> GetMotionMaster ( ) -> MovePoint ( 0 , SylvanasIntroPosition [ 2 ] ) ; if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> GetMotionMaster ( ) -> MovePoint ( 0 , KorelnOrLoralenPos [ 1 ] ) ; if ( Creature * lichking = me -> SummonCreature ( NPC_THE_LICH_KING_INTRO , LichKingIntroPosition [ 0 ] , TEMPSUMMON_MANUAL_DESPAWN ) ) { lichking -> SetWalk ( true ) ; lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , LichKingIntroPosition [ 2 ] ) ; lichking -> SetReactState ( REACT_PASSIVE ) ; _lichkingGUID = lichking -> GetGUID ( ) ; _events . ScheduleEvent ( EVENT_OPEN_IMPENETRABLE_DOOR , 0 ) ; _events . ScheduleEvent ( EVENT_CLOSE_IMPENETRABLE_DOOR , 4s ) ; } _events . ScheduleEvent ( EVENT_INTRO_LK_4 , 15000 ) ; break ; case EVENT_OPEN_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , true ) ; break ; case EVENT_CLOSE_IMPENETRABLE_DOOR : _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_IMPENETRABLE_DOOR ) , false ) ; break ; case EVENT_KORELN_LORALEN_DEATH : if ( Creature * korelnOrLoralen = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_KORELN_LORALEN ) ) ) korelnOrLoralen -> CastSpell ( korelnOrLoralen , SPELL_FEIGN_DEATH ) ; break ; default : break ; } } private : InstanceScript * _instance ; EventMap _events ; ObjectGuid _utherGUID ; ObjectGuid _lichkingGUID ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_intro_horAI > ( creature ) ; } } ; class HoRGameObjectDeleteDelayEvent : public BasicEvent { public : explicit HoRGameObjectDeleteDelayEvent ( Unit * owner , ObjectGuid gameObjectGUID ) : _owner ( owner ) , _gameObjectGUID ( gameObjectGUID ) { } void DeleteGameObject ( ) { if ( GameObject * go = ObjectAccessor :: GetGameObject ( * _owner , _gameObjectGUID ) ) go -> Delete ( ) ; } bool Execute ( uint64 , uint32 ) override { DeleteGameObject ( ) ; return true ; } void Abort ( uint64 ) override { DeleteGameObject ( ) ; } private : Unit * _owner ; ObjectGuid _gameObjectGUID ; } ; class npc_jaina_or_sylvanas_escape_hor : public CreatureScript { public : npc_jaina_or_sylvanas_escape_hor ( ) : CreatureScript ( " npc _ jaina _ or _ sylvanas _ escape _ hor " ) { } struct npc_jaina_or_sylvanas_escape_horAI : public ScriptedAI { npc_jaina_or_sylvanas_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , _icewall ( 0 ) , _prefight ( false ) , _invincibility ( true ) { } void Reset ( ) override { _events . Reset ( ) ; _icewall = 0 ; _events . ScheduleEvent ( EVENT_ESCAPE , 1s ) ; _instance -> DoStop@@ TimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; } void JustDied ( Unit * ) override { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> AI ( ) -> EnterEvadeMode ( ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) && _invincibility ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 actionId ) override { switch ( actionId ) { case ACTION_START_@@ PREFIG@@ HT : if ( _prefight ) return ; _prefight = true ; _events . ScheduleEvent ( EVENT_ESCAPE_1 , 1000 ) ; break ; case ACTION_WALL_BROKEN : ++ _icewall ; if ( _icewall < 4 ) _events . ScheduleEvent ( EVENT_ESCAPE_13 , 3000 ) ; else _events . ScheduleEvent ( EVENT_ESCAPE_15 , 3000 ) ; break ; case ACTION_GUNSHIP_ARRI@@ VAL : _events . ScheduleEvent ( EVENT_ESCAPE_16 , 5000 ) ; break ; case ACTION_GUNSHIP_ARRI@@ VAL_@@ 2 : _events . ScheduleEvent ( EVENT_ESCAPE_17 , 5000 ) ; break ; default : break ; } } bool GossipHello ( Player * player ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == DONE ) { player -> PrepareGossipMenu ( me , me -> GetEntry ( ) == NPC_JAINA_ESCAPE ? GOSSIP_MENU_JAINA_FINAL : GOSSIP_MENU_SYLVANAS_FINAL , true ) ; player -> SendPrepared@@ Gossip ( me ) ; return true ; } return false ; } bool GossipSelect ( Player * player , uint32 , uint32 gossipListId ) override { ClearGossipMenuFor ( player ) ; switch ( gossipListId ) { case 0 : player -> PlayerTalkClass -> SendCloseGossip ( ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; _events . ScheduleEvent ( EVENT_ESCAPE_6 , 0 ) ; break ; default : break ; } return false ; } void DestroyIceWall ( ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_DESTROY_ICE_WALL ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DESTROY_ICE_WALL ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_ICEWALL ) , true ) ; me -> m_Events . AddEvent ( new HoRGameObjectDeleteDelayEvent ( me , _instance -> GetGuidData ( DATA_ICEWALL ) ) , me -> m_Events . CalculateTime ( 5000 ) ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) wallTarget -> DespawnOrUnsummon ( ) ; } void SummonIceWall ( ) { if ( _icewall < 4 ) { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> StopMoving ( ) ; if ( Creature * wallTarget = me -> SummonCreature ( NPC_ICE_WAL@@ L_TARGET , IceWallTargetPosition [ _icewall ] , TEMPSUMMON_MANUAL_DESPAWN , 720000 ) ) lichking -> CastSpell ( wallTarget , SPELL_SUMMON_ICE_WALL ) ; lichking -> AI ( ) -> SetData ( DATA_ICEWALL , _icewall ) ; } } } void AttackIceWall ( ) { if ( _icewall < 4 ) Talk ( SAY_JAINA_SYLVANAS_ESCAPE_2 + _icewall ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) me -> SetFacingToObject ( wallTarget ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_DESTROY_ICE_WALL , true ) ; else DoCast ( me , SPELL_SYLVANAS_DESTROY_ICE_WALL , true ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != POINT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_SHADOW_THRONE_DOOR : if ( me -> GetEntry ( ) == NPC_JAINA_ESCAPE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_BARRIER ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP ) ; me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> SetFac@@ ingTo ( SylvanasShadowThroneDoorPosition . GetOrientation ( ) ) ; break ; case POINT_ATTACK_ICEWALL : AttackIceWall ( ) ; break ; case POINT_TRAP : Talk ( SAY_JAINA_SYLVANAS_ESCAPE_8 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) me -> SetFacingToObject ( lichking ) ; break ; default : break ; } } void DeleteAllFromThreatList ( Unit * target , ObjectGuid except ) { for ( Threat@@ Reference * ref : target -> GetThreat@@ Manager ( ) . GetModifi@@ ableThreatList ( ) ) if ( ref -> GetVictim ( ) -> GetGUID ( ) != except ) ref -> ClearThreat ( ) ; } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_ESCAPE : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_BARRIER ) ; else DoCast ( me , SPELL_SYLVANAS_CLOAK_OF_DARKNESS ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { me -> CastSpell ( lichking , SPELL_TAUNT_ARTHAS , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUN@@ ITY_ST@@ ATE , SPELL_AURA_@@ MOD_TAUN@@ T , true ) ; lichking -> ApplySpellImmune ( 0 , IMMUN@@ ITY_EFFECT , SPELL_EFFECT_@@ ATTACK_@@ ME , true ) ; AttackStart ( lichking ) ; lichking -> AI ( ) -> AttackStart ( me ) ; } me -> SetHealth ( JAINA_SYLVANAS_MAX_HEALTH ) ; me -> RemoveFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; case EVENT_ESCAPE_1 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_1 ) ; else lichking -> AI ( ) -> Talk ( SAY_LK_ESCAPE_2 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_2 , 8000 ) ; } break ; case EVENT_ESCAPE_2 : me -> AttackStop ( ) ; me -> StopMoving ( ) ; me -> SetReactState ( REACT_PASSIVE ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_ICE_PRISON , false ) ; else DoCast ( me , SPELL_SYLVANAS_BLINDING_RETREAT , true ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetReactState ( REACT_PASSIVE ) ; lichking -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_3 , 1500 ) ; break ; case EVENT_ESCAPE_3 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == HORDE ) DoCastAOE ( SPELL_SYLVANAS_DARK_BINDING , true ) ; _events . ScheduleEvent ( EVENT_ESCAPE_4 , 1000 ) ; break ; case EVENT_ESCAPE_4 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_CREDIT_FIN@@ DING_JAINA ) ; else DoCast ( me , SPELL_CREDIT_FIN@@ DING@@ _SYLVANAS ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_1 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> SetImmuneToPC ( true ) ; lichking -> RemoveAll@@ Attackers ( ) ; DeleteAllFromThreatList ( lichking , me -> GetGUID ( ) ) ; } _events . ScheduleEvent ( EVENT_ESCAPE_5 , 2000 ) ; break ; case EVENT_ESCAPE_5 : me -> GetMotionMaster ( ) -> MovePoint ( POINT_SHADOW_THRONE_DOOR , SylvanasShadowThroneDoorPosition ) ; break ; case EVENT_ESCAPE_6 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_PACIFIED ) ; lichking -> SetImmuneToPC ( false ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_JAINA ) ; lichking -> RemoveAurasDueToSpell ( SPELL_JAINA_ICE_PRISON ) ; } else { lichking -> CastSpell ( lichking , SPELL_STUN_BREAK_SYLVANAS ) ; lichking -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DARK_BINDING ) ; } } _invincibility = false ; _instance -> DoStartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , ACHIEV_NOT_RETREATING_EVENT ) ; _events . ScheduleEvent ( EVENT_ESCAPE_7 , 1000 ) ; break ; case EVENT_ESCAPE_7 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> HandleEmoteCommand ( TEXT_EMOTE_@@ ROAR ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_8 , 3000 ) ; break ; case EVENT_ESCAPE_8 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 0 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_9 , 1000 ) ; break ; case EVENT_ESCAPE_9 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 1 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_10 , 5000 ) ; break ; case EVENT_ESCAPE_10 : me -> GetMotionMaster ( ) -> MovePoint ( 0 , NpcJainaOrSylvanasEscapeRoute [ 2 ] ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> GetMotionMaster ( ) -> MovePoint ( 1 , LichKingFirstSummon ) ; _events . ScheduleEvent ( EVENT_ESCAPE_11 , 6000 ) ; break ; case EVENT_ESCAPE_11 : SummonIceWall ( ) ; _events . ScheduleEvent ( EVENT_ESCAPE_12 , 4000 ) ; break ; case EVENT_ESCAPE_12 : if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) lichking -> CastSpell ( lichking , SPELL_PAIN_AND_SUFFERING , true ) ; me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ 3 ] ) ; break ; case EVENT_ESCAPE_13 : DestroyIceWall ( ) ; if ( _icewall && _icewall < 4 ) me -> GetMotionMaster ( ) -> MovePoint ( POINT_ATTACK_ICEWALL , NpcJainaOrSylvanasEscapeRoute [ _icewall + 3 ] ) ; _events . ScheduleEvent ( EVENT_ESCAPE_14 , 8000 ) ; break ; case EVENT_ESCAPE_14 : SummonIceWall ( ) ; break ; case EVENT_ESCAPE_15 : DestroyIceWall ( ) ; Talk ( SAY_JAINA_SYLVANAS_ESCAPE_6 ) ; if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> GetMotionMaster ( ) -> MovePoint ( 2 , LichKingFinalPos ) ; lichking -> RemoveAurasDueToSpell ( SPELL_REMORSELESS_WINTER ) ; } me -> GetMotionMaster ( ) -> MovePoint ( POINT_TRAP , NpcJainaOrSylvanasEscapeRoute [ 7 ] ) ; break ; case EVENT_ESCAPE_16 : me -> RemoveAurasDueToSpell ( SPELL_HARVEST_SOUL ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_9 ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , DONE ) ; break ; case EVENT_ESCAPE_17 : if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) Talk ( SAY_JAINA_ESCAPE_10 ) ; else Talk ( SAY_SYLVANAS_ESCAPE_9 ) ; DoCast ( me , SPELL_CREDIT_@@ ESCAPING_ARTHAS ) ; me -> SetFlag ( UNIT_NPC_FLAGS , UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : InstanceScript * _instance ; EventMap _events ; uint32 _icewall ; bool _prefight ; bool _invincibility ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_jaina_or_sylvanas_escape_horAI > ( creature ) ; } } ; class npc_the_lich_king_escape_hor : public CreatureScript { public : npc_the_lich_king_escape_hor ( ) : CreatureScript ( " npc _ the _ lich _ king _ escape _ hor " ) { } struct npc_the_lich_king_escape_horAI : public ScriptedAI { npc_the_lich_king_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , NOT_STARTED ) ; _summonsCount = 0 ; _icewall = 0 ; _despawn = false ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type == POINT_MOTION_TYPE ) { switch ( pointId ) { case 1 : if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) me -> GetMotionMaster ( ) -> MoveChase ( target ) ; break ; case 2 : Talk ( SAY_LK_ESCAPE_HARVEST_SOUL ) ; if ( Creature * target = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) DoCast ( target , SPELL_HARVEST_SOUL ) ; if ( Transport * gunship = ObjectAccessor :: GetTransport ( * me , _instance -> GetGuidData ( DATA_GUNSHIP ) ) ) gunship -> EnableMovement ( true ) ; break ; default : break ; } } } void JustSummoned ( Creature * ) override { ++ _summonsCount ; } void SummonedCreature@@ Dies ( Creature * , Unit * ) override { if ( ! _summonsCount ) return ; -- _summonsCount ; if ( ! _summonsCount && _events . Empty ( ) ) { if ( Creature * jainaOrSylvanas = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) jainaOrSylvanas -> AI ( ) -> DoAction ( ACTION_WALL_BROKEN ) ; } } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) DoPlaySoundToSet ( me , RAND ( SOUND_LK_SLAY_1 , SOUND_LK_SLAY_2 ) ) ; } void SetData ( uint32 type , uint32 data ) override { if ( type != DATA_ICEWALL ) return ; _icewall = data ; switch ( _icewall ) { case 0 : DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_REMORSELESS_WINTER , 0 ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_1 ) ; break ; case 1 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 8s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 13s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 18s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_2 ) ; break ; case 2 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 39s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_3 ) ; break ; case 3 : _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 9s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 15s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 19s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 40s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 45s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_GHOULS , 55s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 62s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_WITCH_DOCTOR , 65s ) ; _events . ScheduleEvent ( EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION , 14s ) ; Talk ( SAY_LK_ESCAPE_ICEWALL_SUMMONED_4 ) ; break ; default : break ; } } void EnterEvadeMode ( EvadeReason ) override { if ( _despawn ) return ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , FAIL ) ; me -> StopMoving ( ) ; DoPlaySoundToSet ( me , SOUND_LK_FURY_OF_FROSTMOURNE ) ; DoCastAOE ( SPELL_FURY_OF_FROSTMOURNE ) ; me -> DespawnOrUnsummon ( 12000 ) ; _despawn = true ; } void UpdateAI ( uint32 diff ) override { if ( ! SelectVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_REMORSELESS_WINTER : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_WINTER ) ; DoCast ( me , SPELL_REMORSELESS_WINTER ) ; break ; case EVENT_ESCAPE_SUMMON_GHOULS : me -> StopMoving ( ) ; Talk ( SAY_LK_ESCAPE_GHOULS ) ; DoCast ( me , SPELL_RAISE_DEAD ) ; break ; case EVENT_ESCAPE_SUMMON_WITCH_DOCTOR : DoCast ( me , SPELL_SUMMON_RISEN_WITCH_DOCTOR ) ; break ; case EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION : Talk ( SAY_LK_ESCAPE_ABOMINATION ) ; DoCast ( me , SPELL_SUMMON_LUMBERING_ABOMINATION ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool SelectVictim ( ) { if ( ! me -> IsInCombat ( ) ) return false ; if ( ! me -> HasReactState ( REACT_PASSIVE ) ) { if ( Unit * victim = me -> SelectVictim ( ) ) if ( ! me -> HasSpell@@ Focus ( ) && victim != me -> GetVictim ( ) ) AttackStart ( victim ) ; return me -> GetVictim ( ) != nullptr ; } else if ( me -> GetCombat@@ Manager ( ) . GetPv@@ ECombat@@ Refs ( ) . size ( ) < 2 && me -> HasAura ( SPELL_REMORSELESS_WINTER ) ) { EnterEvadeMode ( EVAD@@ E_REASON_@@ OTH@@ ER ) ; return false ; } return true ; } InstanceScript * _instance ; EventMap _events ; uint8 _icewall ; uint32 _summonsCount ; bool _despawn ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_the_lich_king_escape_horAI > ( creature ) ; } } ; enum TrashSpells { SPELL_SHADOW_WORD_PAIN = 723@@ 18 , SPELL_CIRCLE_OF_DESTRUCTION = 72320 , SPELL_COWER_IN_FEAR = 72321 , SPELL_DARK_MENDING = 7232@@ 2 , SPELL_FIREBALL = 7216@@ 3 , SPELL_FLAMESTRIKE = 72169 , SPELL_FROSTBOLT = 7216@@ 6 , SPELL_CHAINS_OF_ICE = 72121 , SPELL_HALLUCINATION = 723@@ 42 , AURA_HALLUCINATION = 723@@ 43 , SPELL_HALLUCINATION_2 = 723@@ 44 , SPELL_SHADOW_STEP = 72326 , SPELL_DEADLY_POISON = 7232@@ 9 , SPELL_ENVENOMED_DAGGER_THROW = 72333 , SPELL_KIDNEY_SHOT = 72335 , SPELL_SPECTRAL_STRIKE = 72198 , SPELL_SHIELD_BASH = 72194 , SPELL_TORTURED_ENRAGE = 72203 , SPELL_SHOOT = 72208 , SPELL_CURSED_ARROW = 72222 , SPELL_FROST_TRAP = 72215 , SPELL_ICE_SHOT = 72268 } ; enum TrashEvents { EVENT_TRAS@@ H_NONE , EVENT_SHADOW_WORD_PAIN , EVENT_CIRCLE_OF_DESTRUCTION , EVENT_COWER_IN_FEAR , EVENT_DARK_MENDING , EVENT_FIREBALL , EVENT_FLAMESTRIKE , EVENT_FROSTBOLT , EVENT_CHAINS_OF_ICE , EVENT_HALLUCINATION , EVENT_SHADOW_STEP , EVENT_DEADLY_POISON , EVENT_ENVENOMED_DAGGER_THROW , EVENT_KIDNEY_SHOT , EVENT_SPECTRAL_STRIKE , EVENT_SHIELD_BASH , EVENT_TORTURED_ENRAGE , EVENT_SHOOT , EVENT_CURSED_ARROW , EVENT_FROST_TRAP , EVENT_ICE_SHOT } ; struct npc_gauntlet_trash : public ScriptedAI { npc_gauntlet_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) , InternalWaveId ( 0 ) { } void Reset ( ) override { me -> CastSpell ( me , SPELL_WELL_@@ OF_SOULS , true ) ; _events . Reset ( ) ; } void EnterEvadeMode ( EvadeReason ) override { if ( _instance -> GetData ( DATA_WAVE_COUNT ) != NOT_STARTED ) _instance -> SetData ( DATA_WAVE_COUNT , NOT_STARTED ) ; } void SetData ( uint32 type , uint32 value ) override { if ( type ) return ; InternalWaveId = value ; } uint32 GetData ( uint32 type ) const override { if ( type ) return 0 ; return InternalWaveId ; } protected : EventMap _events ; InstanceScript * _instance ; uint32 InternalWaveId ; } ; class npc_ghostly_priest : public CreatureScript { public : npc_ghostly_priest ( ) : CreatureScript ( " npc _ ghost@@ ly _ priest " ) { } struct npc_ghostly_priestAI : public npc_gauntlet_trash { npc_ghostly_priestAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_WORD_PAIN : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHADOW_WORD_PAIN ) ; _events . ScheduleEvent ( EVENT_SHADOW_WORD_PAIN , 6s , 15s ) ; break ; case EVENT_CIRCLE_OF_DESTRUCTION : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 10.0f , true ) ) DoCast ( target , SPELL_CIRCLE_OF_DESTRUCTION ) ; _events . ScheduleEvent ( EVENT_CIRCLE_OF_DESTRUCTION , 12s ) ; break ; case EVENT_COWER_IN_FEAR : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 20.0f , true ) ) DoCast ( target , SPELL_COWER_IN_FEAR ) ; _events . ScheduleEvent ( EVENT_COWER_IN_FEAR , 10s ) ; break ; case EVENT_DARK_MENDING : if ( Unit * target = DoSelect@@ Low@@ estHpF@@ riend@@ ly ( 40 , DUNGEON_@@ MODE ( 30000 , 50000 ) ) ) { DoCast ( target , SPELL_DARK_MENDING ) ; _events . ScheduleEvent ( EVENT_DARK_MENDING , 20s ) ; } else { _events . ScheduleEvent ( EVENT_DARK_MENDING , 5s ) ; } break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_ghostly_priestAI > ( creature ) ; } } ; class npc_phantom_mage : public CreatureScript { public : npc_phantom_mage ( ) : CreatureScript ( " npc _ phantom _ mage " ) { } struct npc_phantom_mageAI : public npc_gauntlet_trash { npc_phantom_mageAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void EnterEvadeMode ( EvadeReason why ) override { if ( ! me -> HasAura ( AURA_HALLUCINATION ) ) npc_gauntlet_trash :: EnterEvadeMode ( why ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_FIREBALL , 3s ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 6s ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 9s ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 12s ) ; _events . ScheduleEvent ( EVENT_HALLUCINATION , 40s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_FIREBALL : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FIREBALL ) ; _events . ScheduleEvent ( EVENT_FIREBALL , 15s ) ; break ; case EVENT_FLAMESTRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FLAMESTRIKE ) ; _events . ScheduleEvent ( EVENT_FLAMESTRIKE , 15s ) ; break ; case EVENT_FROSTBOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_FROSTBOLT ) ; _events . ScheduleEvent ( EVENT_FROSTBOLT , 15s ) ; break ; case EVENT_CHAINS_OF_ICE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM ) ) DoCast ( target , SPELL_CHAINS_OF_ICE ) ; _events . ScheduleEvent ( EVENT_CHAINS_OF_ICE , 15s ) ; break ; case EVENT_HALLUCINATION : me -> RemoveAll@@ Auras ( ) ; DoCast ( me , SPELL_HALLUCINATION ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_mageAI > ( creature ) ; } } ; class npc_phantom_hallucination : public CreatureScript { public : npc_phantom_hallucination ( ) : CreatureScript ( " npc _ phantom _ halluc@@ ination " ) { } struct npc_phantom_hallucinationAI : public npc_phantom_mage :: npc_phantom_mageAI { npc_phantom_hallucinationAI ( Creature * creature ) : npc_phantom_mage :: npc_phantom_mageAI ( creature ) { } void Reset ( ) override { DoZoneInCombat ( me ) ; } void EnterEvadeMode ( EvadeReason why ) override { if ( me -> GetOwner ( ) && ! me -> GetOwner ( ) -> HasAura ( AURA_HALLUCINATION ) ) npc_phantom_mage :: npc_phantom_mageAI :: EnterEvadeMode ( why ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_HALLUCINATION_2 ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_phantom_hallucinationAI > ( creature ) ; } } ; class npc_shadowy_mercenary : public CreatureScript { public : npc_shadowy_mercenary ( ) : CreatureScript ( " npc _ shadowy _ mercenary " ) { } struct npc_shadowy_mercenaryAI : public npc_gauntlet_trash { npc_shadowy_mercenaryAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHADOW_STEP , 23s ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 5s ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 12s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHADOW_STEP : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100.0f , true ) ) DoCast ( target , SPELL_SHADOW_STEP ) ; _events . ScheduleEvent ( EVENT_SHADOW_STEP , 8s ) ; break ; case EVENT_DEADLY_POISON : DoCastVictim ( SPELL_DEADLY_POISON ) ; _events . ScheduleEvent ( EVENT_DEADLY_POISON , 10s ) ; break ; case EVENT_ENVENOMED_DAGGER_THROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ENVENOMED_DAGGER_THROW ) ; _events . ScheduleEvent ( EVENT_ENVENOMED_DAGGER_THROW , 10s ) ; break ; case EVENT_KIDNEY_SHOT : DoCastVictim ( SPELL_KIDNEY_SHOT ) ; _events . ScheduleEvent ( EVENT_KIDNEY_SHOT , 10s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_shadowy_mercenaryAI > ( creature ) ; } } ; class npc_spectral_footman : public CreatureScript { public : npc_spectral_footman ( ) : CreatureScript ( " npc _ spectral _ footman " ) { } struct npc_spectral_footmanAI : public npc_gauntlet_trash { npc_spectral_footmanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 14s ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 10s ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SPECTRAL_STRIKE : DoCastVictim ( SPELL_SPECTRAL_STRIKE ) ; _events . ScheduleEvent ( EVENT_SPECTRAL_STRIKE , 5s ) ; break ; case EVENT_SHIELD_BASH : DoCastVictim ( SPELL_SHIELD_BASH ) ; _events . ScheduleEvent ( EVENT_SHIELD_BASH , 5s ) ; break ; case EVENT_TORTURED_ENRAGE : DoCast ( me , SPELL_TORTURED_ENRAGE ) ; _events . ScheduleEvent ( EVENT_TORTURED_ENRAGE , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spectral_footmanAI > ( creature ) ; } } ; class npc_tortured_rifleman : public CreatureScript { public : npc_tortured_rifleman ( ) : CreatureScript ( " npc _ tortured _ rifleman " ) { } struct npc_tortured_riflemanAI : public npc_gauntlet_trash { npc_tortured_riflemanAI ( Creature * creature ) : npc_gauntlet_trash ( creature ) { } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_SHOOT , 1 ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 7s ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 10s ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_SHOOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_SHOOT ) ; _events . ScheduleEvent ( EVENT_SHOOT , 2s ) ; break ; case EVENT_CURSED_ARROW : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_CURSED_ARROW ) ; _events . ScheduleEvent ( EVENT_CURSED_ARROW , 10s ) ; break ; case EVENT_FROST_TRAP : DoCast ( me , SPELL_FROST_TRAP ) ; _events . ScheduleEvent ( EVENT_FROST_TRAP , 30s ) ; break ; case EVENT_ICE_SHOT : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 40.0f , true ) ) DoCast ( target , SPELL_ICE_SHOT ) ; _events . ScheduleEvent ( EVENT_ICE_SHOT , 15s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_tortured_riflemanAI > ( creature ) ; } } ; enum Fro@@ stswornGener@@ al { EVENT_SHIELD = 1 , EVENT_SPIKE = 2 , EVENT_CLONE = 3 , SAY_AGGRO = 0 , SAY_DEATH = 1 , SPELL_SHIELD_THROWN = 69222 , SPELL_SPIKE = 69184 , SPELL_CLONE = 69828 , SPELL_GHOST_VISUAL = 69861 , EVENT_BALEFUL_STRIKE = 1 , SPELL_BALEFUL_STRIKE = 69933 , SPELL_SPIRIT_BURST = 69900 } ; class npc_frostsworn_general : public CreatureScript { public : npc_frostsworn_general ( ) : CreatureScript ( " npc _ frostsworn _ general " ) { } struct npc_frostsworn_generalAI : public ScriptedAI { npc_frostsworn_generalAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = creature -> GetInstanceScript ( ) ; } void Reset ( ) override { _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , NOT_STARTED ) ; } void JustDied ( Unit * ) override { Talk ( SAY_DEATH ) ; _events . Reset ( ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , DONE ) ; } void JustEngagedWith ( Unit * ) override { Talk ( SAY_AGGRO ) ; DoZoneInCombat ( ) ; _events . ScheduleEvent ( EVENT_SHIELD , 5s ) ; _events . ScheduleEvent ( EVENT_SPIKE , 14s ) ; _events . ScheduleEvent ( EVENT_CLONE , 22s ) ; _instance -> SetData ( DATA_FROSTSWORN_GENERAL , IN_PROGRESS ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 event = _events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SHIELD : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SHIELD_THROWN ) ; _events . ScheduleEvent ( EVENT_SHIELD , 8s , 12s ) ; break ; case EVENT_SPIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 45.0f , true ) ) DoCast ( target , SPELL_SPIKE ) ; _events . ScheduleEvent ( EVENT_SPIKE , 15s , 20s ) ; break ; case EVENT_CLONE : SummonClones ( ) ; _events . ScheduleEvent ( EVENT_CLONE , 1min ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } void SummonClones ( ) { std :: list < Unit * > playerList ; SelectTarget@@ List ( playerList , 5 , SELECT_TARGET_MAXTHREAT , 0 , 0.0f , true ) ; for ( Unit * target : playerList ) { if ( Creature * reflection = me -> SummonCreature ( NPC_REFLECTION , * target , TEMPSUMMON_TIMED_@@ DESPAWN_OUT_@@ OF_COMBAT , 3000 ) ) { reflection -> SetImmuneToPC ( false ) ; target -> CastSpell ( reflection , SPELL_CLONE , true ) ; target -> CastSpell ( reflection , SPELL_GHOST_VISUAL , true ) ; reflection -> AI ( ) -> AttackStart ( target ) ; } } } private : InstanceScript * _instance ; EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_frostsworn_generalAI > ( creature ) ; } } ; class npc_spiritual_reflection : public CreatureScript { public : npc_spiritual_reflection ( ) : CreatureScript ( " npc _ spiritual _ reflection " ) { } struct npc_spiritual_reflectionAI : public ScriptedAI { npc_spiritual_reflectionAI ( Creature * creature ) : ScriptedAI ( creature ) { } void Reset ( ) override { _events . Reset ( ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s ) ; } void JustDied ( Unit * ) override { DoCastAOE ( SPELL_SPIRIT_BURST ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_BALEFUL_STRIKE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 8.0f , true ) ) DoCast ( target , SPELL_BALEFUL_STRIKE ) ; _events . ScheduleEvent ( EVENT_BALEFUL_STRIKE , 3s , 8s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } private : EventMap _events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_spiritual_reflectionAI > ( creature ) ; } } ; class at_hor_intro_start : public AreaTriggerScript { public : at_hor_intro_start ( ) : AreaTriggerScript ( " at _ hor _ intro _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == NOT_STARTED ) _instance -> SetData ( DATA_INTRO_EVENT , IN_PROGRESS ) ; if ( player -> HasAura ( SPELL_QUEL_DELAR_@@ COMPULSION ) && ( player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_@@ ALLIANCE ) == QUEST_STATUS_INCOMPLETE || player -> GetQuestStatus ( QUEST_HALLS_OF_REFLECTION_@@ HORDE ) == QUEST_STATUS_INCOMPLETE ) && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == NOT_STARTED ) { _instance -> SetData ( DATA_QUEL_DELAR_EVENT , IN_PROGRESS ) ; _instance -> SetGuid@@ Data ( DATA_QUEL_DELAR_INVOKER , player -> GetGUID ( ) ) ; } return true ; } } ; class at_hor_waves_restarter : public AreaTriggerScript { public : at_hor_waves_restarter ( ) : AreaTriggerScript ( " at _ hor _ wav@@ es _ restarter " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_WAVE_COUNT ) ) return true ; if ( _instance -> GetData ( DATA_INTRO_EVENT ) == DONE && _instance -> GetBossState ( DATA_MARWYN ) != DONE ) { _instance -> ProcessEvent ( 0 , EVENT_SPAWN_WAVES ) ; if ( Creature * falric = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_FALRIC ) ) ) { falric -> CastSpell ( falric , SPELL_BOSS_SPAWN_AURA , true ) ; falric -> SetVisible ( true ) ; } if ( Creature * marwyn = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_MARWYN ) ) ) { marwyn -> CastSpell ( marwyn , SPELL_BOSS_SPAWN_AURA , true ) ; marwyn -> SetVisible ( true ) ; } } return true ; } } ; class at_hor_impenetrable_door : public AreaTriggerScript { public : at_hor_impenetrable_door ( ) : AreaTriggerScript ( " at _ hor _ impenetr@@ able _ door " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_MARWYN ) == DONE ) return true ; return false ; } } ; class at_hor_shadow_throne : public AreaTriggerScript { public : at_hor_shadow_throne ( ) : AreaTriggerScript ( " at _ hor _ shadow _ throne " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , IN_PROGRESS ) ; return true ; } } ; enum Escape@@ Events { EVENT_RAGING_GHOUL_JUMP = 1 , EVENT_RISEN_WITCH_DOCTOR_CURSE , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , EVENT_LUMBERING_ABOMINATION_CLEAVE } ; class HoRStartMovementEvent : public BasicEvent { public : explicit HoRStartMovementEvent ( Creature * owner ) : _owner ( owner ) { } bool Execute ( uint64 , uint32 ) override { _owner -> SetReactState ( REACT_AGGRES@@ SIVE ) ; if ( Unit * target = _owner -> AI ( ) -> SelectTarget ( SELECT_TARGET_RANDOM , 0 , 0.0f , true ) ) _owner -> AI ( ) -> AttackStart ( target ) ; return true ; } private : Creature * _owner ; } ; struct npc_escape_event_trash : public ScriptedAI { npc_escape_event_trash ( Creature * creature ) : ScriptedAI ( creature ) , _instance ( creature -> GetInstanceScript ( ) ) { } void Reset ( ) override { _events . Reset ( ) ; } void UpdateAI ( uint32 ) override { if ( _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == FAIL || _instance -> GetBossState ( DATA_THE_LICH_KING_ESCAPE ) == NOT_STARTED ) me -> DespawnOrUnsummon ( ) ; } void IsSummonedBy ( WorldObject * ) override { DoZoneInCombat ( me ) ; if ( Creature * leader = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ESCAPE_LEADER ) ) ) { me -> SetImmuneToPC ( false ) ; me -> SetInCombatWith ( leader ) ; leader -> SetInCombatWith ( me ) ; AddThreat ( leader , 0.0f ) ; } } protected : EventMap _events ; InstanceScript * _instance ; } ; class npc_raging_ghoul : public CreatureScript { public : npc_raging_ghoul ( ) : CreatureScript ( " npc _ raging _ ghoul " ) { } struct npc_raging_ghoulAI : public npc_escape_event_trash { npc_raging_ghoulAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 5s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RAGING_GHOUL_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RAGING_GHOUL_JUMP : if ( Unit * victim = me -> GetVictim ( ) ) { if ( me -> IsInRange ( victim , 5.0f , 30.0f ) ) { DoCast ( victim , SPELL_GHOUL_JUMP ) ; return ; } } _events . ScheduleEvent ( EVENT_RAGING_GHOUL_JUMP , 500ms ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_raging_ghoulAI > ( creature ) ; } } ; class npc_risen_witch_doctor : public CreatureScript { public : npc_risen_witch_doctor ( ) : CreatureScript ( " npc _ risen _ witch _ doctor " ) { } struct npc_risen_witch_doctorAI : public npc_escape_event_trash { npc_risen_witch_doctorAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 6s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 7s ) ; } void IsSummonedBy ( WorldObject * summoner ) override { me -> CastSpell ( me , SPELL_RISEN_WITCH_DOCTOR_SPAWN , true ) ; me -> SetReactState ( REACT_PASSIVE ) ; me -> HandleEmoteCommand ( EMOTE_ONESHOT_EMERGE ) ; me -> m_Events . AddEvent ( new HoRStartMovementEvent ( me ) , me -> m_Events . CalculateTime ( 5000 ) ) ; npc_escape_event_trash :: IsSummonedBy ( summoner ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_RISEN_WITCH_DOCTOR_CURSE : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCast ( target , SPELL_CURSE_OF_DOOM ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_CURSE , 10s , 15s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT : if ( Unit * target = SelectTarget ( SELECT_TARGET_MAXTHREAT , 0 , 20.0f , true ) ) DoCast ( target , SPELL_SHADOW_BOLT ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT , 2s , 3s ) ; break ; case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY : if ( SelectTarget ( SELECT_TARGET_RANDOM , 0 , 30.0f , true ) ) DoCastAOE ( SPELL_SHADOW_BOLT_VOLLEY ) ; _events . ScheduleEvent ( EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY , 15s , 22s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_risen_witch_doctorAI > ( creature ) ; } } ; class npc_lumbering_abomination : public CreatureScript { public : npc_lumbering_abomination ( ) : CreatureScript ( " npc _ lumbering _ abomination " ) { } struct npc_lumbering_abominationAI : public npc_escape_event_trash { npc_lumbering_abominationAI ( Creature * creature ) : npc_escape_event_trash ( creature ) { } void Reset ( ) override { npc_escape_event_trash :: Reset ( ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 6s ) ; } void UpdateAI ( uint32 diff ) override { npc_escape_event_trash :: UpdateAI ( diff ) ; if ( ! UpdateVictim ( ) ) return ; _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; switch ( _events . ExecuteEvent ( ) ) { case EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY : DoCastVictim ( SPELL_VOMIT_SPRAY ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY , 15s , 20s ) ; break ; case EVENT_LUMBERING_ABOMINATION_CLEAVE : DoCastVictim ( SPELL_CLEAVE ) ; _events . ScheduleEvent ( EVENT_LUMBERING_ABOMINATION_CLEAVE , 7s , 9s ) ; break ; default : break ; } DoMeleeAttackIfReady ( ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_lumbering_abominationAI > ( creature ) ; } } ; enum QuelDelarUther { ACTION_UTHER_START_SCREAM = 1 , ACTION_UTHER_OUTRO = 2 , EVENT_UTHER_1 = 1 , EVENT_UTHER_2 = 2 , EVENT_UTHER_3 = 3 , EVENT_UTHER_4 = 4 , EVENT_UTHER_5 = 5 , EVENT_UTHER_6 = 6 , EVENT_UTHER_7 = 7 , EVENT_UTHER_8 = 8 , EVENT_UTHER_9 = 9 , EVENT_UTHER_10 = 10 , EVENT_UTHER_11 = 11 , EVENT_UTHER_FACING = 12 , EVENT_UTHER_KNEEL = 13 , SAY_UTHER_QUEL_DELAR_1 = 16 , SAY_UTHER_QUEL_DELAR_2 = 17 , SAY_UTHER_QUEL_DELAR_3 = 18 , SAY_UTHER_QUEL_DELAR_4 = 19 , SAY_UTHER_QUEL_DELAR_5 = 20 , SAY_UTHER_QUEL_DELAR_6 = 21 , SPELL_ESSENCE_OF_CAPTURED_1 = 730@@ 36 } ; enum QuelDelarSword { SPELL_WHIRLWIND_VISUAL = 70300 , SPELL_HEROIC_STRIKE = 29426 , SPELL_WHIRLWIND = 677@@ 16 , SPELL_BLADESTORM = 675@@ 41 , NPC_QUEL_DELAR = 37158 , POINT_TAKE_OFF = 1 , EVENT_QUEL_DELAR_INIT = 1 , EVENT_QUEL_DELAR_FLIGHT_INIT = 2 , EVENT_QUEL_DELAR_FLIGHT = 3 , EVENT_QUEL_DELAR_LAND = 4 , EVENT_QUEL_DELAR_FIGHT = 5 , EVENT_QUEL_DELAR_BLADESTORM = 6 , EVENT_QUEL_DELAR_HEROIC_STRIKE = 7 , EVENT_QUEL_DELAR_WHIRLWIND = 8 , SAY_QUEL_DELAR_SWORD = 0 } ; enum QuelDelarMisc { SAY_FROSTMOURNE_BUNNY = 0 , SPELL_QUEL_DELAR_WILL = 70698 } ; Position const QuelDelarCenterPos = { 5309@@ .259@@ f , 2006.390@@ f , 718.046f , 0.0f } ; Position const QuelDelarSummonPos = { 529@@ 8.47@@ 3f , 1994@@ .852f , 709.424@@ f , 3.9@@ 79351f } ; Position const QuelDelarMovement [ ] = { { 529@@ 2.870@@ f , 1998.@@ 950@@ f , 718.046f , 0.0f } , { 5295.@@ 819f , 1991.9@@ 12f , 707.707f , 0.0f } , { 5295.@@ 301f , 1989@@ .782@@ f , 708.696f , 0.0f } } ; Position const UtherQuelDelarMovement [ ] = { { 5336.830@@ f , 1981.@@ 700f , 709.319@@ f , 0.0f } , { 5314.35@@ 0f , 1993@@ .440@@ f , 707.726f , 0.0f } } ; class npc_uther_quel_delar : public CreatureScript { public : npc_uther_quel_delar ( ) : CreatureScript ( " npc _ uther _ quel _ delar " ) { } struct npc_uther_quel_delarAI : public ScriptedAI { npc_uther_quel_delarAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; } void Reset ( ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Reset ( ) ; _events . ScheduleEvent ( EVENT_UTHER_1 , 1 ) ; } void DamageTaken ( Unit * , uint32 & damage ) override { if ( damage >= me -> GetHealth ( ) ) damage = me -> GetHealth ( ) - 1 ; } void DoAction ( int32 action ) override { switch ( action ) { case ACTION_UTHER_START_SCREAM : _instance -> SetData ( DATA_QUEL_DELAR_EVENT , SPECIAL ) ; _events . ScheduleEvent ( EVENT_UTHER_2 , 0 ) ; break ; case ACTION_UTHER_OUTRO : _events . ScheduleEvent ( EVENT_UTHER_6 , 0 ) ; break ; default : break ; } } void MovementInform ( uint32 , uint32 pointId ) override { switch ( pointId ) { case 1 : _events . ScheduleEvent ( EVENT_UTHER_FACING , 1s ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != IN_PROGRESS && _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) != SPECIAL ) return ; _events . Update ( diff ) ; while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_UTHER_1 : Talk ( SAY_UTHER_QUEL_DELAR_1 ) ; break ; case EVENT_UTHER_2 : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) if ( Unit * target = ObjectAccessor :: GetPlayer ( * me , _instance -> GetGuidData ( DATA_QUEL_DELAR_INVOKER ) ) ) bunny -> CastSpell ( target , SPELL_QUEL_DELAR_WILL , true ) ; _events . ScheduleEvent ( EVENT_UTHER_3 , 2000 ) ; break ; case EVENT_UTHER_3 : me -> SummonCreature ( NPC_QUEL_DELAR , QuelDelarSummonPos ) ; _events . ScheduleEvent ( EVENT_UTHER_4 , 2000 ) ; break ; case EVENT_UTHER_4 : Talk ( SAY_UTHER_QUEL_DELAR_2 ) ; _events . ScheduleEvent ( EVENT_UTHER_5 , 8000 ) ; break ; case EVENT_UTHER_5 : me -> GetMotionMaster ( ) -> MovePoint ( 1 , UtherQuelDelarMovement [ 0 ] ) ; break ; case EVENT_UTHER_6 : me -> SetWalk ( true ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , UtherQuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_UTHER_7 , 5000 ) ; break ; case EVENT_UTHER_7 : Talk ( SAY_UTHER_QUEL_DELAR_3 ) ; _events . ScheduleEvent ( EVENT_UTHER_8 , 12000 ) ; break ; case EVENT_UTHER_8 : Talk ( SAY_UTHER_QUEL_DELAR_4 ) ; _events . ScheduleEvent ( EVENT_UTHER_9 , 7000 ) ; break ; case EVENT_UTHER_9 : Talk ( SAY_UTHER_QUEL_DELAR_5 ) ; _events . ScheduleEvent ( EVENT_UTHER_10 , 10000 ) ; break ; case EVENT_UTHER_10 : Talk ( SAY_UTHER_QUEL_DELAR_6 ) ; _events . ScheduleEvent ( EVENT_UTHER_11 , 5000 ) ; break ; case EVENT_UTHER_11 : DoCast ( me , SPELL_ESSENCE_OF_CAPTURED_1 , true ) ; me -> DespawnOrUnsummon ( 3000 ) ; _instance -> SetData ( DATA_QUEL_DELAR_EVENT , DONE ) ; break ; case EVENT_UTHER_FACING : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) me -> SetFacingToObject ( bunny ) ; _events . ScheduleEvent ( EVENT_UTHER_KNEEL , 1s ) ; break ; case EVENT_UTHER_KNEEL : me -> HandleEmoteCommand ( EMOTE_STATE_@@ KNEEL ) ; break ; default : break ; } } } private : EventMap _events ; InstanceScript * _instance ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_uther_quel_delarAI > ( creature ) ; } } ; class npc_quel_delar_sword : public CreatureScript { public : npc_quel_delar_sword ( ) : CreatureScript ( " npc _ quel _ delar _ sword " ) { } struct npc_quel_delar_swordAI : public ScriptedAI { npc_quel_delar_swordAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; me -> SetDisplay@@ Id ( me -> GetCreature@@ Template ( ) -> Modelid2 ) ; _intro = true ; } void Reset ( ) override { _events . Reset ( ) ; me -> SetSpe@@ edRate ( MOVE_@@ FLIGHT , 4.5f ) ; DoCast ( SPELL_WHIRLWIND_VISUAL ) ; if ( _intro ) _events . ScheduleEvent ( EVENT_QUEL_DELAR_INIT , 0 ) ; else me -> SetImmuneToAll ( false ) ; } void JustEngagedWith ( Unit * ) override { _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 4s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 6s ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 6s ) ; } void JustDied ( Unit * ) override { if ( Creature * uther = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_OUTRO ) ; } void MovementInform ( uint32 type , uint32 pointId ) override { if ( type != EFFECT_MOTION_TYPE ) return ; switch ( pointId ) { case POINT_TAKE_OFF : _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT , 0 ) ; break ; default : break ; } } void UpdateAI ( uint32 diff ) override { _events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; if ( ! UpdateVictim ( ) ) { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_INIT : if ( Creature * bunny = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_FROSTMOURNE_ALTAR_BUNNY ) ) ) bunny -> AI ( ) -> Talk ( SAY_FROSTMOURNE_BUNNY ) ; _intro = false ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FLIGHT_INIT , 2500ms ) ; break ; case EVENT_QUEL_DELAR_FLIGHT_INIT : me -> GetMotionMaster ( ) -> MoveTake@@ off ( POINT_TAKE_OFF , QuelDelarMovement [ 0 ] ) ; break ; case EVENT_QUEL_DELAR_FLIGHT : { me -> GetMotionMaster ( ) -> MoveCir@@ clePath ( QuelDelarCenterPos . GetPositionX ( ) , QuelDelarCenterPos . GetPositionY ( ) , 718.046f , 18.0f , true , 16 ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_LAND , 15s ) ; break ; } case EVENT_QUEL_DELAR_LAND : me -> StopMoving ( ) ; me -> GetMotionMaster ( ) -> Clear ( ) ; me -> GetMotionMaster ( ) -> MoveLand ( 0 , QuelDelarMovement [ 1 ] ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_FIGHT , 6s ) ; break ; case EVENT_QUEL_DELAR_FIGHT : Talk ( SAY_QUEL_DELAR_SWORD ) ; me -> GetMotionMaster ( ) -> MovePoint ( 0 , QuelDelarMovement [ 2 ] ) ; me -> SetImmuneToAll ( false ) ; break ; default : break ; } } } else { while ( uint32 eventId = _events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_QUEL_DELAR_BLADESTORM : DoCast ( me , SPELL_BLADESTORM ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_BLADESTORM , 10s ) ; break ; case EVENT_QUEL_DELAR_HEROIC_STRIKE : DoCastVictim ( SPELL_HEROIC_STRIKE ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_HEROIC_STRIKE , 6s ) ; break ; case EVENT_QUEL_DELAR_WHIRLWIND : DoCastAOE ( SPELL_WHIRLWIND ) ; _events . ScheduleEvent ( EVENT_QUEL_DELAR_WHIRLWIND , 1s ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } } private : EventMap _events ; InstanceScript * _instance ; bool _intro ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetHallsOfReflectionAI < npc_quel_delar_swordAI > ( creature ) ; } } ; class at_hor_uther_quel_delar_start : public AreaTriggerScript { public : at_hor_uther_quel_delar_start ( ) : AreaTriggerScript ( " at _ hor _ uther _ quel _ delar _ start " ) { } bool OnTrigger ( Player * player , AreaTriggerEntry const * ) override { if ( player -> IsGameMaster ( ) ) return true ; InstanceScript * _instance = player -> GetInstanceScript ( ) ; if ( _instance -> GetData ( DATA_QUEL_DELAR_EVENT ) == IN_PROGRESS ) if ( Creature * uther = ObjectAccessor :: GetCreature ( * player , _instance -> GetGuidData ( DATA_UTHER_QUEL_DELAR ) ) ) uther -> AI ( ) -> DoAction ( ACTION_UTHER_START_SCREAM ) ; return true ; } } ; class spell_hor_start_halls_of_reflection_quest_ae : public SpellScriptLoader { public : spell_hor_start_halls_of_reflection_quest_ae ( ) : SpellScriptLoader ( " spell _ hor _ start _ halls _ of _ reflection _ quest _ ae " ) { } class spell_hor_start_halls_of_reflection_quest_ae_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript ) ; void StartQuests ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) { if ( target -> GetTeam ( ) == ALLIANCE ) target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_@@ A , true ) ; else target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_@@ H , true ) ; } } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_start_halls_of_reflection_quest_ae_SpellScript :: StartQuests , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_start_halls_of_reflection_quest_ae_SpellScript ( ) ; } } ; class spell_hor_evasion : public SpellScriptLoader { public : spell_hor_evasion ( ) : SpellScriptLoader ( " spell _ hor _ evasion " ) { } class spell_hor_evasion_SpellScript : public SpellScript { PrepareSpellScript ( spell_hor_evasion_SpellScript ) ; bool Load ( ) override { return GetCaster ( ) -> GetTypeId ( ) == TYPEID_UNIT ; } void SetDest ( SpellDestination & dest ) { WorldObject * target = GetExplTarget@@ WorldObject ( ) ; Position pos ( * target ) ; Position home = GetCaster ( ) -> ToCreature ( ) -> GetHo@@ mePosition ( ) ; if ( pos . IsInDist@@ 2d ( & home , 15.0f ) ) return ; float angle = pos . GetAb@@ soluteAngle ( & home ) ; float dist = GetSpellInfo ( ) -> Effects [ EFFECT_0 ] . Calc@@ Radius ( GetCaster ( ) ) ; target -> MovePosition ( pos , dist , angle ) ; dest . Relocate ( pos ) ; } void Register ( ) override { OnDestinationTarget@@ Select += SpellDestinationTarget@@ SelectFn ( spell_hor_evasion_SpellScript :: SetDest , EFFECT_0 , TARGET_DEST_@@ TARGET_RADIUS ) ; } } ; SpellScript * GetSpellScript ( ) const override { return new spell_hor_evasion_SpellScript ( ) ; } } ; class spell_hor_gunship_cannon_fire : public SpellScriptLoader { public : spell_hor_gunship_cannon_fire ( ) : SpellScriptLoader ( " spell _ hor _ gunship _ cannon _ fire " ) { } class spell_hor_gunship_cannon_fire_AuraScript : public AuraScript { PrepareAuraScript ( spell_hor_gunship_cannon_fire_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { if ( ! urand ( 0 , 2 ) ) { if ( GetTarget ( ) -> GetEntry ( ) == NPC_GUNSHIP_CAN@@ NON_@@ HORDE ) GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_@@ HORDE , true ) ; else GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_@@ ALLIANCE , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_hor_gunship_cannon_fire_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_@@ TRIGGER@@ _SPELL ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_hor_gunship_cannon_fire_AuraScript ( ) ; } } ; class spell_hor_quel_delars_will : public SpellScript { PrepareSpellScript ( spell_hor_quel_delars_will ) ; bool Validate ( SpellInfo const * spellInfo ) override { return ValidateSpellInfo ( { spellInfo -> Effects [ EFFECT_0 ] . TriggerSpell } ) ; } void HandleReagent ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetCaster ( ) , GetSpellInfo ( ) -> Effects [ effIndex ] . TriggerSpell , Trigger@@ CastFlags ( TRIGGERED_@@ FULL_@@ MASK & ~ TRIGGERED_@@ IGNORE_@@ POWER_@@ AND_REAGENT_@@ COST ) ) ; } void Register ( ) override { OnEffectHitTarget += SpellEffectFn ( spell_hor_quel_delars_will :: HandleReagent , EFFECT_0 , SPELL_EFFECT_@@ FORCE_CAST ) ; } } ; void AddSC_@@ halls_of_reflection ( ) { new at_hor_intro_start ( ) ; new at_hor_waves_restarter ( ) ; new at_hor_impenetrable_door ( ) ; new at_hor_shadow_throne ( ) ; new at_hor_uther_quel_delar_start ( ) ; new npc_jaina_or_sylvanas_intro_hor ( ) ; new npc_jaina_or_sylvanas_escape_hor ( ) ; new npc_the_lich_king_escape_hor ( ) ; new npc_ghostly_priest ( ) ; new npc_phantom_mage ( ) ; new npc_phantom_hallucination ( ) ; new npc_shadowy_mercenary ( ) ; new npc_spectral_footman ( ) ; new npc_tortured_rifleman ( ) ; new npc_frostsworn_general ( ) ; new npc_spiritual_reflection ( ) ; new npc_raging_ghoul ( ) ; new npc_risen_witch_doctor ( ) ; new npc_lumbering_abomination ( ) ; new npc_uther_quel_delar ( ) ; new npc_quel_delar_sword ( ) ; new spell_hor_start_halls_of_reflection_quest_ae ( ) ; new spell_hor_evasion ( ) ; new spell_hor_gunship_cannon_fire ( ) ; RegisterSpellScript ( spell_hor_quel_delars_will ) ; } </DOCUMENT>
<DOCUMENT_ID="Thomas@@ XBM@@ C/@@ XC@@ Soar/tree/master/src/@@ Engine/Task@@ /Comput@@ er/DistanceStatComput@@ er.cpp"> # include " DistanceStatComputer . hpp " # include " Task / Stats / DistanceStat . hpp " void DistanceStatComputer :: Calc@@ Speed ( DistanceStat & data , fixed time ) { if ( positive ( time ) && data . IsDefined ( ) ) data . speed = data . GetDi@@ stance ( ) / time ; else data . speed = fixed ( 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="S@@ uslikV@@ /ob@@ s-stu@@ dio/tree/master/plugins/@@ win-capture@@ /graph@@ ics-hook@@ /d3d9@@ -capture@@ .cpp"> # define _CR@@ T_SECURE_@@ NO_WARN@@ INGS # include < d3d9 . h > # include < d3d11 . h > # include < dxgi . h > # include " graphics - hook . h " # include " . . / funcho@@ ok . h " # include " d3d9 - patches . hpp " typedef HRESULT ( STDMETHODCALLTYPE * present_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_ex_t ) ( IDirect3DDevice9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * present_swap_t ) ( IDirect3DSwapChain9 * , CONST RECT * , CONST RECT * , HWND , CONST RGNDATA * , DWORD ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * ) ; typedef HRESULT ( STDMETHODCALLTYPE * reset_ex_t ) ( IDirect3DDevice9 * , D3DPRESENT_PARAMETERS * , D3DDISPLAYMODEEX * ) ; typedef HRESULT ( WINAPI * createfactory1_t ) ( REFI@@ ID , void * * ) ; static struct func_hook present ; static struct func_hook present_ex ; static struct func_hook present_swap ; static struct func_hook reset ; static struct func_hook reset_ex ; struct d3d9_data { HMODULE d3d9 ; IDirect3DDevice9 * device ; uint32_t cx ; uint32_t cy ; D3DFORMAT d3d9_format ; DXGI_FORMAT dxgi_format ; bool using_shtex : 1 ; bool using_scale : 1 ; volatile bool issued_queries [ NUM_BUFFERS ] ; union { struct { IDirect3DSurface9 * d3d9_copytex ; ID3D11@@ Device * d3d11_device ; ID3D11@@ DeviceContext * d3d11_context ; ID3D11@@ Resource * d3d11_tex ; struct shtex_data * shtex_info ; HANDLE handle ; int patch ; } ; struct { IDirect3DSurface9 * copy_surfaces [ NUM_BUFFERS ] ; IDirect3DSurface9 * render_targets [ NUM_BUFFERS ] ; IDirect3DQuery9 * queries [ NUM_BUFFERS ] ; struct shmem_data * shmem_info ; bool texture_mapped [ NUM_BUFFERS ] ; uint32_t pitch ; int cur_tex ; int copy_wait ; } ; } ; } ; static struct d3d9_data data = { } ; static void d3d9_free ( ) { capture_free ( ) ; if ( data . using_shtex ) { if ( data . d3d11_tex ) data . d3d11_tex -> Release ( ) ; if ( data . d3d11_context ) data . d3d11_context -> Release ( ) ; if ( data . d3d11_device ) data . d3d11_device -> Release ( ) ; if ( data . d3d9_copytex ) data . d3d9_copytex -> Release ( ) ; } else { for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( data . copy_surfaces [ i ] ) { if ( data . texture_mapped [ i ] ) data . copy_surfaces [ i ] -> UnlockRect ( ) ; data . copy_surfaces [ i ] -> Release ( ) ; } if ( data . render_targets [ i ] ) data . render_targets [ i ] -> Release ( ) ; if ( data . queries [ i ] ) data . queries [ i ] -> Release ( ) ; } } memset ( & data , 0 , sizeof ( data ) ) ; hlog ( " - - - - - - - - - - - - - - - - - ▁ d3d9 ▁ capture ▁ freed ▁ - - - - - - - - - - - - - - - - - " ) ; } static DXGI_FORMAT d3d9_to_dxgi_format ( D3DFORMAT format ) { switch ( ( unsigned long ) format ) { case D3DFMT_@@ A2B10@@ G10@@ R10 : return DXGI_FORMAT_@@ R10@@ G10@@ B10@@ A2_UNORM ; case D3DFMT_A8R8G8B8 : return DXGI_FORMAT_B8G8R8@@ A8_UNORM ; case D3DFMT_@@ X8R8G8B8 : return DXGI_FORMAT_B8G8R8@@ X8_UNORM ; } return DXGI_FORMAT_@@ UNKNOWN ; } const static D3D_FEATURE_LEVEL feature_levels [ ] = { D3D_FEATURE_LEVEL_@@ 11_0 , D3D_FEATURE_LEVEL_10_@@ 1 , D3D_FEATURE_LEVEL_10_@@ 0 , D3D_FEATURE_LEVEL_@@ 9_@@ 3 , } ; static inline bool shex_init_d3d11 ( ) { PFN_D3D11_CREATE_DEVICE create_device ; createfactory1_t create_factory ; D3D_FEATURE_LEVEL level_used ; IDXGIFact@@ ory * factory ; IDXGI@@ Adapter * adapter ; HMODULE d3d11 ; HMODULE dxgi ; HRESULT hr ; d3d11 = load_system_library ( " d3d11 . dll " ) ; if ( ! d3d11 ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ D3D11" ) ; return false ; } dxgi = load_system_library ( " dxgi . dll " ) ; if ( ! dxgi ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ DXG@@ I " ) ; return false ; } create_factory = ( createfactory1_t ) GetProcAddress ( dxgi , " CreateDXGIFactory@@ 1" ) ; if ( ! create_factory ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ CreateDXGIFactory@@ 1 ▁ address " ) ; return false ; } create_device = ( PFN_D3D11_CREATE_DEVICE ) GetProcAddress ( d3d11 , " D3D11CreateDevice " ) ; if ( ! create_device ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ D3D11CreateDevice ▁ address " ) ; return false ; } hr = create_factory ( __uuidof ( IDXGIFactory@@ 1 ) , ( void * * ) & factory ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ factory ▁ object " , hr ) ; return false ; } hr = factory -> EnumAdapt@@ ers ( 0 , & adapter ) ; factory -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ adapter " , hr ) ; return false ; } hr = create_device ( adapter , D3D_DRI@@ VER_@@ TYPE_UNKNOWN , nullptr , 0 , feature_levels , sizeof ( feature_levels ) / sizeof ( D3D_FEATURE_LEVEL ) , D3D11@@ _SDK_VERSION , & data . d3d11_device , & level_used , & data . d3d11_context ) ; adapter -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ device " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_shtex ( ) { IDXGIResource * res ; HRESULT hr ; D3D11_TEXTURE@@ 2D_@@ DESC desc = { } ; desc . Width = data . cx ; desc . Height = data . cy ; desc . Format = data . dxgi_format ; desc . Mip@@ Levels = 1 ; desc . ArraySize = 1 ; desc . SampleDesc . Count = 1 ; desc . Usa@@ ge = D3D11_USAGE_@@ DEFAULT ; desc . Misc@@ Flags = D3D11_RESOURCE_MI@@ SC_SHAR@@ ED ; desc . BindFlags = D3D11_BIND_RENDER_@@ TARGET | D3D11_BIND_SH@@ ADER_@@ RESOURCE ; hr = data . d3d11_device -> CreateTexture2D ( & desc , nullptr , ( ID3D11@@ Texture2D * * ) & data . d3d11_tex ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ texture " , hr ) ; return false ; } hr = data . d3d11_tex -> QueryInterface ( __uuidof ( IDXGIResource ) , ( void * * ) & res ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ query ▁ IDXGIResource " , hr ) ; return false ; } hr = res -> GetShared@@ Handle ( & data . handle ) ; res -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ get ▁ shared ▁ handle " , hr ) ; return false ; } return true ; } static inline bool d3d9_shtex_init_copytex ( ) { uint8_t * patch_addr = get_d3d9_p@@ atch_addr ( data . d3d9 , data . patch ) ; uint8_t saved_data [ MAX_PAT@@ CH_SIZE ] ; size_t patch_size = 0 ; IDirect3DTexture@@ 9 * tex ; DWORD protect_val ; HRESULT hr ; if ( patch_addr ) { patch_size = patch [ data . patch ] . size ; VirtualProtect ( patch_addr , patch_size , PAGE_EXEC@@ UTE_RE@@ ADWRITE , & protect_val ) ; memcpy ( saved_data , patch_addr , patch_size ) ; memcpy ( patch_addr , patch [ data . patch ] . data , patch_size ) ; } hr = data . device -> CreateTexture ( data . cx , data . cy , 1 , D3DUSAGE_@@ REN@@ DERTARGET , data . d3d9_format , D3DPOO@@ L_DEFAULT , & tex , & data . handle ) ; if ( patch_addr && patch_size ) { memcpy ( patch_addr , saved_data , patch_size ) ; VirtualProtect ( patch_addr , patch_size , protect_val , & protect_val ) ; } if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ create ▁ shared ▁ texture " , hr ) ; return false ; } hr = tex -> GetSurface@@ Level ( 0 , & data . d3d9_copytex ) ; tex -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ get ▁ surface ▁ level " , hr ) ; return false ; } return true ; } static bool d3d9_shtex_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = true ; if ( ! shex_init_d3d11 ( ) ) { return false ; } if ( ! d3d9_shtex_init_shtex ( ) ) { return false ; } if ( ! d3d9_shtex_init_copytex ( ) ) { return false ; } if ( ! capture_init_@@ shtex ( & data . shtex_info , window , cx , cy , data . cx , data . cy , data . dxgi_format , false , ( uintptr_t ) data . handle ) ) { return false ; } hlog ( " d3d9 ▁ shared ▁ texture ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_shmem_init_buffers ( size_t buffer ) { HRESULT hr ; hr = data . device -> CreateOff@@ screen@@ Plain@@ Surface ( data . cx , data . cy , data . d3d9_format , D3DPOO@@ L_SYSTEM@@ MEM , & data . copy_surfaces [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ surface " , hr ) ; return false ; } if ( buffer == 0 ) { D3DLOCKED_RECT rect ; hr = data . copy_surfaces [ buffer ] -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ lock ▁ " " buffer " , hr ) ; return false ; } data . pitch = rect . Pit@@ ch ; data . copy_surfaces [ buffer ] -> UnlockRect ( ) ; } hr = data . device -> CreateRender@@ Target ( data . cx , data . cy , data . d3d9_format , D3DMULTI@@ SAMP@@ LE_NONE , 0 , false , & data . render_targets [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ render ▁ " " target " , hr ) ; return false ; } hr = data . device -> CreateQuery ( D3DQUER@@ YTYPE_EVENT , & data . queries [ buffer ] ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ query " , hr ) ; return false ; } return true ; } static bool d3d9_shmem_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = false ; for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( ! d3d9_shmem_init_buffers ( i ) ) { return false ; } } if ( ! capture_init_@@ shmem ( & data . shmem_info , window , cx , cy , data . cx , data . cy , data . pitch , data . dxgi_format , false ) ) { return false ; } hlog ( " d3d9 ▁ memory ▁ capture ▁ successful " ) ; return true ; } static bool d3d9_get_swap_desc ( D3DPRESENT_PARAMETERS & pp ) { IDirect3DSwapChain9 * swap = nullptr ; HRESULT hr ; hr = data . device -> GetSwapChain ( 0 , & swap ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ swap ▁ chain " , hr ) ; return false ; } hr = swap -> GetPresent@@ Parameters ( & pp ) ; swap -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ " " presentation ▁ parameters " , hr ) ; return false ; } return true ; } static bool d3d9_init_format_backbuffer ( uint32_t & cx , uint32_t & cy , HWND & window ) { IDirect3DSurface9 * back_buffer = nullptr ; D3DPRESENT_PARAMETERS pp ; D3DSUR@@ FACE_@@ DESC desc ; HRESULT hr ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } hr = data . device -> GetRenderTarget ( 0 , & back_buffer ) ; if ( FAILED ( hr ) ) { return false ; } hr = back_buffer -> GetDesc ( & desc ) ; back_buffer -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init _ format _ backbuffer : ▁ Failed ▁ to ▁ get ▁ " " backbuffer ▁ descriptor " , hr ) ; return false ; } data . d3d9_format = desc . Format ; data . dxgi_format = d3d9_to_dxgi_format ( desc . Format ) ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = desc . Width ; cy = desc . Height ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = desc . Width ; data . cy = desc . Height ; } return true ; } static bool d3d9_init_format_swapchain ( uint32_t & cx , uint32_t & cy , HWND & window ) { D3DPRESENT_PARAMETERS pp ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } data . dxgi_format = d3d9_to_dxgi_format ( pp . BackBufferFormat ) ; data . d3d9_format = pp . BackBufferFormat ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = pp . BackBufferWidth ; cy = pp . BackBufferHeight ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = pp . BackBufferWidth ; data . cy = pp . BackBufferHeight ; } return true ; } static void d3d9_init ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; bool success ; uint32_t cx = 0 ; uint32_t cy = 0 ; HWND window = nullptr ; HRESULT hr ; data . d3d9 = get_system_module ( " d3d9 . dll " ) ; data . device = device ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { d3d9ex -> Release ( ) ; data . patch = - 1 ; } else { data . patch = get_d3d9_p@@ atch ( data . d3d9 ) ; } if ( ! d3d9_init_format_backbuffer ( cx , cy , window ) ) { if ( ! d3d9_init_format_swapchain ( cx , cy , window ) ) { return ; } } if ( global_hook_info -> force_shmem || ( ! d3d9ex && data . patch == - 1 ) ) { success = d3d9_shmem_init ( cx , cy , window ) ; } else { success = d3d9_shtex_init ( cx , cy , window ) ; } if ( ! success ) d3d9_free ( ) ; } static inline HRESULT get_backbuffer ( IDirect3DDevice9 * device , IDirect3DSurface9 * * surface ) { static bool use_backbuffer = false ; static bool checked_exceptions = false ; if ( ! checked_exceptions ) { if ( _str@@ cmpi ( get_process_@@ name ( ) , " hotd _ ng . exe " ) == 0 ) use_backbuffer = true ; checked_exceptions = true ; } if ( use_backbuffer ) { return device -> GetBack@@ Buffer ( 0 , 0 , D3DBACK@@ BUFFER_TYPE_MON@@ O , surface ) ; } else { return device -> GetRenderTarget ( 0 , surface ) ; } } static inline void d3d9_shtex_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; HRESULT hr ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; hr = data . device -> StretchRect ( backbuffer , nullptr , data . d3d9_copytex , nullptr , filter ) ; if ( FAILED ( hr ) ) hlog_hr ( " d3d9 _ shtex _ capture : ▁ StretchRect ▁ failed " , hr ) ; } static inline void d3d9_shmem_capture_queue_copy ( ) { for ( int i = 0 ; i < NUM_BUFFERS ; i ++ ) { IDirect3DSurface9 * target = data . copy_surfaces [ i ] ; D3DLOCKED_RECT rect ; HRESULT hr ; if ( ! data . issued_queries [ i ] ) { continue ; } if ( data . queries [ i ] -> GetData ( 0 , 0 , 0 ) != S_OK ) { continue ; } data . issued_queries [ i ] = false ; hr = target -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( SUCCEEDED ( hr ) ) { data . texture_mapped [ i ] = true ; shmem_copy_data ( i , rect . pBits ) ; } break ; } } static inline void d3d9_shmem_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; IDirect3DSurface9 * copy ; int next_tex ; HRESULT hr ; d3d9_shmem_capture_queue_copy ( ) ; next_tex = ( data . cur_tex == NUM_BUFFERS - 1 ) ? 0 : data . cur_tex + 1 ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; copy = data . render_targets [ data . cur_tex ] ; hr = data . device -> StretchRect ( backbuffer , nullptr , copy , nullptr , filter ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ StretchRect ▁ failed " , hr ) ; return ; } if ( data . copy_wait < NUM_BUFFERS - 1 ) { data . copy_wait ++ ; } else { IDirect3DSurface9 * src = data . render_targets [ next_tex ] ; IDirect3DSurface9 * dst = data . copy_surfaces [ next_tex ] ; if ( shmem_texture_data_@@ lock ( next_tex ) ) { dst -> UnlockRect ( ) ; data . texture_mapped [ next_tex ] = false ; shmem_texture_data_@@ unlock ( next_tex ) ; } hr = data . device -> GetRenderTargetData ( src , dst ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ GetRenderTargetData ▁ " " failed " , hr ) ; } data . queries [ next_tex ] -> Issue ( D3DIS@@ SUE_END ) ; data . issued_queries [ next_tex ] = true ; } data . cur_tex = next_tex ; } static void d3d9_capture ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { if ( capture_should_@@ stop ( ) ) { d3d9_free ( ) ; } if ( capture_should_init ( ) ) { d3d9_init ( device ) ; } if ( capture_ready ( ) ) { if ( data . using_shtex ) d3d9_shtex_capture ( backbuffer ) ; else d3d9_shmem_capture ( backbuffer ) ; } } static int present_recurse = 0 ; static inline void present_begin ( IDirect3DDevice9 * device , IDirect3DSurface9 * & backbuffer ) { HRESULT hr ; if ( ! present_recurse ) { hr = get_backbuffer ( device , & backbuffer ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ Failed ▁ to ▁ get ▁ " " backbuffer " , hr ) ; } if ( ! global_hook_info -> capture_overlay ) { d3d9_capture ( device , backbuffer ) ; } } present_recurse ++ ; } static inline void present_end ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { present_recurse -- ; if ( ! present_recurse ) { if ( global_hook_info -> capture_overlay ) { if ( ! present_recurse ) d3d9_capture ( device , backbuffer ) ; } if ( backbuffer ) backbuffer -> Release ( ) ; } } static bool hooked_reset = false ; static void setup_reset_hooks ( IDirect3DDevice9 * device ) ; static HRESULT STDMETHODCALLTYPE hook_present ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present ) ; present_t call = ( present_t ) present . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region ) ; rehook ( & present ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_ex ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present_ex ) ; present_ex_t call = ( present_ex_t ) present_ex . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_ex ) ; present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_present_swap ( IDirect3DSwapChain9 * swap , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; IDirect3DDevice9 * device = nullptr ; HRESULT hr ; if ( ! present_recurse ) { hr = swap -> GetDevice ( & device ) ; if ( SUCCEEDED ( hr ) ) { device -> Release ( ) ; } } if ( device ) { if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; } unhook ( & present_swap ) ; present_swap_t call = ( present_swap_t ) present_swap . call_addr ; hr = call ( swap , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_swap ) ; if ( device ) present_end ( device , backbuffer ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset ) ; reset_t call = ( reset_t ) reset . call_addr ; hr = call ( device , params ) ; rehook ( & reset ) ; return hr ; } static HRESULT STDMETHODCALLTYPE hook_reset_ex ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params , D3DDISPLAYMODEEX * dmex ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset_ex ) ; reset_ex_t call = ( reset_ex_t ) reset_ex . call_addr ; hr = call ( device , params , dmex ) ; rehook ( & reset_ex ) ; return hr ; } static void setup_reset_hooks ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; uintptr_t * vtable = * ( uintptr_t * * ) device ; HRESULT hr ; hook_init ( & reset , ( void * ) vtable [ 16 ] , ( void * ) hook_reset , " IDirect3DDevice9 : : Reset " ) ; rehook ( & reset ) ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { hook_init ( & reset_ex , ( void * ) vtable [ 132 ] , ( void * ) hook_reset_ex , " IDirect3DDevice9Ex : : ResetEx " ) ; rehook ( & reset_ex ) ; d3d9ex -> Release ( ) ; } hooked_reset = true ; } typedef HRESULT ( WINAPI * d3d9create_ex_t ) ( UINT , IDirect3D9Ex * * ) ; static bool manually_get_d3d9_addrs ( HMODULE d3d9_module , void * * present_addr , void * * present_ex_addr , void * * present_swap_addr ) { d3d9create_ex_t create_ex ; D3DPRESENT_PARAMETERS pp ; HRESULT hr ; IDirect3DDevice9Ex * device ; IDirect3D9Ex * d3d9ex ; hlog ( " D3D9 ▁ values ▁ invalid , ▁ manu@@ ally ▁ obtain@@ ing " ) ; create_ex = ( d3d9create_ex_t ) GetProcAddress ( d3d9_module , " Direct3DCreate9Ex " ) ; if ( ! create_ex ) { hlog ( " Failed ▁ to ▁ load ▁ Direct3DCreate9Ex " ) ; return false ; } if ( FAILED ( create_ex ( D3D_SDK_VERSION , & d3d9ex ) ) ) { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ context " ) ; return false ; } memset ( & pp , 0 , sizeof ( pp ) ) ; pp . Windowed = 1 ; pp . SwapEffect = D3DSW@@ APEFFECT_@@ FLIP ; pp . BackBufferFormat = D3DFMT_A8R8G8B8 ; pp . BackBufferCount = 1 ; pp . hDeviceWindow = ( HWND ) dummy_window ; pp . Presentation@@ Interval = D3DPRESENT_INTERVAL_@@ IMMEDIATE ; hr = d3d9ex -> CreateDevice@@ Ex ( D3DADAP@@ TER_DEFAULT , D3DDEV@@ TYPE_HAL , dummy_window , D3DCREATE_@@ HARDWARE_@@ VERTEX@@ PROC@@ ESS@@ ING | D3DCREATE_@@ NOWINDOW@@ CHANGES , & pp , NULL , & device ) ; d3d9ex -> Release ( ) ; if ( SUCCEEDED ( hr ) ) { uintptr_t * vtable = * ( uintptr_t * * ) device ; IDirect3DSwapChain9 * swap ; * present_addr = ( void * ) vtable [ 17 ] ; * present_ex_addr = ( void * ) vtable [ 121 ] ; hr = device -> GetSwapChain ( 0 , & swap ) ; if ( SUCCEEDED ( hr ) ) { vtable = * ( uintptr_t * * ) swap ; * present_swap_addr = ( void * ) vtable [ 3 ] ; swap -> Release ( ) ; } device -> Release ( ) ; } else { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ device " ) ; return false ; } return true ; } bool hook_d3d9 ( void ) { HMODULE d3d9_module = get_system_module ( " d3d9 . dll " ) ; uint32_t d3d9_size ; void * present_addr = nullptr ; void * present_ex_addr = nullptr ; void * present_swap_addr = nullptr ; if ( ! d3d9_module ) { return false ; } d3d9_size = module_size ( d3d9_module ) ; if ( global_hook_info -> offsets . d3d9 . present < d3d9_size && global_hook_info -> offsets . d3d9 . present_ex < d3d9_size && global_hook_info -> offsets . d3d9 . present_swap < d3d9_size ) { present_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present ) ; present_ex_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_ex ) ; present_swap_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_swap ) ; } else { if ( ! dummy_window ) { return false ; } if ( ! manually_get_d3d9_addrs ( d3d9_module , & present_addr , & present_ex_addr , & present_swap_addr ) ) { hlog ( " Failed ▁ to ▁ get ▁ D3D9 ▁ values " ) ; return true ; } } if ( ! present_addr && ! present_ex_addr && ! present_swap_addr ) { hlog ( " Invalid ▁ D3D9 ▁ values " ) ; return true ; } if ( present_swap_addr ) { hook_init ( & present_swap , present_swap_addr , ( void * ) hook_present_swap , " IDirect3DSwapChain9 : : Present " ) ; rehook ( & present_swap ) ; } if ( present_ex_addr ) { hook_init ( & present_ex , present_ex_addr , ( void * ) hook_present_ex , " IDirect3DDevice9Ex : : Present@@ Ex " ) ; rehook ( & present_ex ) ; } if ( present_addr ) { hook_init ( & present , present_addr , ( void * ) hook_present , " IDirect3DDevice9 : : Present " ) ; rehook ( & present ) ; } hlog ( " Hooked ▁ D3D9" ) ; return true ; } </DOCUMENT>
<DOCUMENT_ID="ci@@ rc@@ a-@@ one/Open@@ JK@@ -Alt@@ /tree/master/code/@@ cgame/@@ cg_marks.cpp"> # include " cg _ headers . h " # include " cg _ media . h " markPoly_t cg_activeMarkPolys ; markPoly_t * cg_freeMarkPolys ; markPoly_t cg_markPolys [ MAX_MARK_POLYS ] ; void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } } void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; } markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; } # define MAX_MARK_FRAGMENTS 128 # define MAX_MARK_POINTS 384 void CG_ImpactMark ( qhandle@@ _t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFrag@@ ment_t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } VectorNormal@@ ize2 ( dir , axis [ 0 ] ) ; Perpend@@ icular@@ Vector ( axis [ 1 ] , axis [ 0 ] ) ; Rotate@@ PointAround@@ Vector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; Cross@@ Product ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_@@ CM_MarkFragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; mark -> color [ 1 ] = colors [ 1 ] ; mark -> color [ 2 ] = colors [ 2 ] ; mark -> color [ 3 ] = colors [ 3 ] ; memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } } # define MARK_TOTAL_TIME 10000 # define MARK_FADE_TIME 1000 void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { next = mp -> nextMark ; if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } } </DOCUMENT>
<DOCUMENT_ID="x@@ da@@ jog/@@ sam@@ sung_@@ sources_i9@@ 27/tree/master/external/@@ webkit/Source/WebKit@@ 2/@@ Shared/@@ DictionaryPo@@ pupInfo.cpp"> # include " config . h " # include " DictionaryPopupInfo . h " # include " WebCore@@ ArgumentCo@@ ders . h " # if PLATFORM ( MAC ) # include " ArgumentCo@@ dersCF . h " # endif namespace WebK@@ it { void DictionaryPopupInfo :: encode ( CoreIPC :: ArgumentEncoder * encoder ) const { encoder -> encode ( origin ) ; encoder -> encode ( fontInfo ) ; encoder -> encode@@ Enum ( type ) ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) CoreIPC :: encode ( encoder , options . get ( ) ) ; # endif } bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decode@@ Enum ( result . type ) ) return false ; # if PLATFORM ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; # endif return true ; } } </DOCUMENT>
<DOCUMENT_ID="didout@@ heone@@ /Mang@@ osOne@@ Didou/tree/master/dep@@ /re@@ castnavigation/@@ RecastDemo/Source/@@ CrowdManager.cpp"> # define _USE_@@ MATH_DEFINES # include < math . h > # include < stdio . h > # include < stdlib . h > # include < string . h > # include < float . h > # include " Detour@@ NavMesh . h " # include " Detour@@ NavMeshQuery . h " # include " Detour@@ ObstacleAvoid@@ ance . h " # include " Detour@@ Common . h " # include " CrowdManager . h " # include " SampleInterfaces . h " # include " Detour@@ Assert . h " # include " Detour@@ Alloc . h " static const int VO_ADAPTIVE_DIVS = 7 ; static const int VO_ADAPTIVE_RINGS = 2 ; static const int VO_ADAPTIVE_DEPTH = 5 ; static const int VO_GRID_SIZE = 33 ; inline int hashPos2 ( int x , int y , int n ) { return ( ( x * 73856093 ) ^ ( y * 19349@@ 663 ) ) & ( n - 1 ) ; } ProximityGrid :: ProximityGrid ( ) : m_maxItems ( 0 ) , m_cellSize ( 0 ) , m_pool ( 0 ) , m_poolHead ( 0 ) , m_poolSize ( 0 ) , m_buckets ( 0 ) , m_bucketsSize ( 0 ) { } ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; } bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; m_bucketsSize = dtNext@@ Pow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; } void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; } void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } } int ProximityGrid :: queryItems ( const float minx , const float miny , const float maxx , const float maxy , unsigned short * ids , const int maxIds ) const { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; int n = 0 ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) { const unsigned short * end = ids + n ; unsigned short * i = ids ; while ( i != end && * i != item . id ) ++ i ; if ( i == end ) { if ( n >= maxIds ) return n ; ids [ n ++ ] = item . id ; } } idx = item . next ; } } } return n ; } int ProximityGrid :: getItem@@ CountAt ( const int x , const int y ) const { int n = 0 ; const int h = hashPos2 ( x , y , m_bucketsSize ) ; unsigned short idx = m_buckets [ h ] ; while ( idx != 0xffff ) { Item & item = m_pool [ idx ] ; if ( ( int ) item . x == x && ( int ) item . y == y ) n ++ ; idx = item . next ; } return n ; } PathQueue :: PathQueue ( ) : m_nextHandle ( 1 ) , m_delay ( 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) m_queue [ i ] . ref = PATHQ_INVALID ; } PathQueue :: ~ PathQueue ( ) { } void PathQueue :: update ( dtNavMeshQuery * navquery ) { m_delay ++ ; if ( ( m_delay % 4 ) == 0 ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref == PATHQ_INVALID ) continue ; navquery -> findPath ( q . startRef , q . endRef , q . startPos , q . endPos , q . filter , q . path , & q . npath , PQ_@@ MAX_PATH ) ; q . ready = true ; break ; } } for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { PathQuery & q = m_queue [ i ] ; if ( q . ref != PATHQ_INVALID && q . ready ) { q . keepalive ++ ; if ( q . keepalive > 2 ) q . ref = PATHQ_INVALID ; } } } PathQueueRef PathQueue :: request ( dtPolyRef startRef , dtPolyRef endRef , const float * startPos , const float * endPos , const dtQueryFilter * filter ) { int slot = - 1 ; for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == PATHQ_INVALID ) { slot = i ; break ; } } if ( slot == - 1 ) return PATHQ_INVALID ; PathQueueRef ref = m_nextHandle ++ ; if ( m_nextHandle == PATHQ_INVALID ) m_nextHandle ++ ; PathQuery & q = m_queue [ slot ] ; q . ref = ref ; dtVcopy ( q . startPos , startPos ) ; q . startRef = startRef ; dtVcopy ( q . endPos , endPos ) ; q . endRef = endRef ; q . ready = false ; q . npath = 0 ; q . filter = filter ; q . keepalive = 0 ; return ref ; } int PathQueue :: getRequestState ( PathQueueRef ref ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) return m_queue [ i ] . ready ? PATHQ_STATE_READY : PATHQ_STATE_@@ WORKING ; } return PATHQ_STATE_INVALID ; } int PathQueue :: getPathResult ( PathQueueRef ref , dtPolyRef * path , const int maxPath ) { for ( int i = 0 ; i < MAX_QUEUE ; ++ i ) { if ( m_queue [ i ] . ref == ref ) { PathQuery & q = m_queue [ i ] ; q . ref = PATHQ_INVALID ; int n = 0 ; for ( int j = 0 ; j < q . npath && j < maxPath ; ++ j ) path [ n ++ ] = q . path [ j ] ; return n ; } } return 0 ; } static int fixupCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = nvisited - furthestVisited ; const int orig = dtMin ( furthestPath + 1 , npath ) ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ ( nvisited - 1 ) - i ] ; return req + size ; } static int fixupCorridorEnd ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = 0 ; i < npath ; ++ i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int ppos = furthestPath + 1 ; const int vpos = furthestVisited + 1 ; const int count = dtMin ( nvisited - vpos , maxPath - ppos ) ; dtAssert ( ppos + count <= maxPath ) ; if ( count ) memcpy ( path + ppos , visited + vpos , sizeof ( dtPolyRef ) * count ) ; return ppos + count ; } static int mergeCorridor ( dtPolyRef * path , const int npath , const int maxPath , const dtPolyRef * visited , const int nvisited ) { int furthestPath = - 1 ; int furthestVisited = - 1 ; for ( int i = npath - 1 ; i >= 0 ; -- i ) { bool found = false ; for ( int j = nvisited - 1 ; j >= 0 ; -- j ) { if ( path [ i ] == visited [ j ] ) { furthestPath = i ; furthestVisited = j ; found = true ; } } if ( found ) break ; } if ( furthestPath == - 1 || furthestVisited == - 1 ) return npath ; const int req = furthestVisited ; if ( req <= 0 ) return npath ; const int orig = furthestPath ; int size = dtMax ( 0 , npath - orig ) ; if ( req + size > maxPath ) size = maxPath - req ; if ( size ) memmove ( path + req , path + orig , size * sizeof ( dtPolyRef ) ) ; for ( int i = 0 ; i < req ; ++ i ) path [ i ] = visited [ i ] ; return req + size ; } PathCorridor :: PathCorridor ( ) : m_path ( 0 ) , m_npath ( 0 ) , m_maxPath ( 0 ) { } PathCorridor :: ~ PathCorridor ( ) { dtFree ( m_path ) ; } bool PathCorridor :: init ( const int maxPath ) { dtAssert ( ! m_path ) ; m_path = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * maxPath , DT_ALLOC_PERM ) ; if ( ! m_path ) return false ; m_npath = 0 ; m_maxPath = maxPath ; return true ; } void PathCorridor :: reset ( dtPolyRef ref , const float * pos ) { dtAssert ( m_path ) ; dtVcopy ( m_pos , pos ) ; dtVcopy ( m_target , pos ) ; m_path [ 0 ] = ref ; m_npath = 1 ; } int PathCorridor :: findCorners ( float * cornerVerts , unsigned char * cornerFlags , dtPolyRef * cornerPolys , const int maxCorners , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; static const float MIN_TARGET_DIST = 0.01f ; int ncorners = 0 ; navquery -> findStraight@@ Path ( m_pos , m_target , m_path , m_npath , cornerVerts , cornerFlags , cornerPolys , & ncorners , maxCorners ) ; while ( ncorners ) { if ( ( cornerFlags [ 0 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) || dtVdist2DSqr ( & cornerVerts [ 0 ] , m_pos ) > dtSqr ( MIN_TARGET_DIST ) ) break ; ncorners -- ; if ( ncorners ) { memmove ( cornerFlags , cornerFlags + 1 , sizeof ( unsigned char ) * ncorners ) ; memmove ( cornerPolys , cornerPolys + 1 , sizeof ( dtPolyRef ) * ncorners ) ; memmove ( cornerVerts , cornerVerts + 3 , sizeof ( float ) * 3 * ncorners ) ; } } for ( int i = 0 ; i < ncorners ; ++ i ) { if ( cornerFlags [ i ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) { ncorners = i + 1 ; break ; } } return ncorners ; } void PathCorridor :: optimizePathVisibility ( const float * next , const float pathOptimizationRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; float goal [ 3 ] ; dtVcopy ( goal , next ) ; float dist = dtVdist2D ( m_pos , goal ) ; if ( dist < 0.01f ) return ; dist = dtMin ( dist + 0.01f , pathOptimizationRange ) ; float delta [ 3 ] ; dtVsub ( delta , goal , m_pos ) ; dtVmad ( goal , m_pos , delta , pathOptimizationRange / dist ) ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; float t , norm [ 3 ] ; int nres = 0 ; navquery -> raycast ( m_path [ 0 ] , m_pos , goal , filter , & t , norm , res , & nres , MAX_RES ) ; if ( nres > 1 && t > 0.99@@ f ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; } } bool PathCorridor :: optimizePathTopology ( dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; if ( m_npath < 3 ) return false ; static const int MAX_ITER = 32 ; static const int MAX_RES = 32 ; dtPolyRef res [ MAX_RES ] ; int nres = 0 ; navquery -> initSlicedFindPath ( m_path [ 0 ] , m_path [ m_npath - 1 ] , m_pos , m_target , filter ) ; navquery -> updateSlicedFindPath ( MAX_ITER ) ; dtStatus status = navquery -> finalizeSlicedFind@@ PathPartial ( m_path , m_npath , res , & nres , MAX_RES ) ; if ( status == DT_SUCCESS && nres > 0 ) { m_npath = mergeCorridor ( m_path , m_npath , m_maxPath , res , nres ) ; return true ; } return false ; } void PathCorridor :: movePosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ 0 ] , m_pos , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridor ( m_path , m_npath , m_maxPath , visited , nvisited ) ; float h = m_pos [ 1 ] ; navquery -> getPoly@@ Height ( m_path [ 0 ] , result , & h ) ; result [ 1 ] = h ; dtVcopy ( m_pos , result ) ; } void PathCorridor :: moveTargetPosition ( const float * npos , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { dtAssert ( m_path ) ; dtAssert ( m_npath ) ; float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( m_path [ m_npath - 1 ] , m_target , npos , filter , result , visited , & nvisited , MAX_VISITED ) ; m_npath = fixupCorridorEnd ( m_path , m_npath , m_maxPath , visited , nvisited ) ; dtVcopy ( m_target , result ) ; } void PathCorridor :: setCorridor ( const float * target , const dtPolyRef * path , const int npath ) { dtAssert ( m_path ) ; dtAssert ( npath > 0 ) ; dtAssert ( npath < m_maxPath ) ; dtVcopy ( m_target , target ) ; memcpy ( m_path , path , sizeof ( dtPolyRef ) * npath ) ; m_npath = npath ; } void Agent :: integrate ( const float maxAcc , const float dt ) { const float maxDelta = maxAcc * dt ; float dv [ 3 ] ; dtVsub ( dv , nvel , vel ) ; float ds = dtVlen ( dv ) ; if ( ds > maxDelta ) dtVscale ( dv , dv , maxDelta / ds ) ; dtVadd ( vel , vel , dv ) ; if ( dtVlen ( vel ) > 0.0001f ) dtVmad ( npos , npos , vel , dt ) ; else dtVset ( vel , 0 , 0 , 0 ) ; } float Agent :: getDistanceToGoal ( const float range ) const { if ( ! ncorners ) return range ; const bool endOfPath = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_@@ END ) ? true : false ; const bool offMeshConnection = ( cornerFlags [ ncorners - 1 ] & DT_STRAIGHTPATH_OFFMESH_CONNECTION ) ? true : false ; if ( endOfPath || offMeshConnection ) return dtMin ( dtVdist2D ( npos , & cornerVerts [ ( ncorners - 1 ) * 3 ] ) , range ) ; return range ; } void Agent :: calcSmoothSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } const int ip0 = 0 ; const int ip1 = dtMin ( 1 , ncorners - 1 ) ; const float * p0 = & cornerVerts [ ip0 * 3 ] ; const float * p1 = & cornerVerts [ ip1 * 3 ] ; float dir0 [ 3 ] , dir1 [ 3 ] ; dtVsub ( dir0 , p0 , npos ) ; dtVsub ( dir1 , p1 , npos ) ; dir0 [ 1 ] = 0 ; dir1 [ 1 ] = 0 ; float len0 = dtVlen ( dir0 ) ; float len1 = dtVlen ( dir1 ) ; if ( len1 > 0.001f ) dtVscale ( dir1 , dir1 , 1.0f / len1 ) ; dir [ 0 ] = dir0 [ 0 ] - dir1 [ 0 ] * len0 * 0.5f ; dir [ 1 ] = 0 ; dir [ 2 ] = dir0 [ 2 ] - dir1 [ 2 ] * len0 * 0.5f ; dtVnormalize ( dir ) ; } void Agent :: calcStraightSteerDirection ( float * dir ) { if ( ! ncorners ) { dtVset ( dir , 0 , 0 , 0 ) ; return ; } dtVsub ( dir , & cornerVerts [ 0 ] , npos ) ; dir [ 1 ] = 0 ; dtVnormalize ( dir ) ; } LocalBoundary :: LocalBoundary ( ) : m_nsegs ( 0 ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; } LocalBoundary :: ~ LocalBoundary ( ) { } void LocalBoundary :: reset ( ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; } void LocalBoundary :: addSegment ( const float dist , const float * s ) { Segment * seg = 0 ; if ( ! m_nsegs ) { seg = & m_segs [ 0 ] ; } else if ( dist >= m_segs [ m_nsegs - 1 ] . d ) { if ( m_nsegs >= MAX_SEGS ) return ; seg = & m_segs [ m_nsegs ] ; } else { int i ; for ( i = 0 ; i < m_nsegs ; ++ i ) if ( dist <= m_segs [ i ] . d ) break ; const int tgt = i + 1 ; const int n = dtMin ( m_nsegs - i , MAX_SEGS - tgt ) ; dtAssert ( tgt + n <= MAX_SEGS ) ; if ( n > 0 ) memmove ( & m_segs [ tgt ] , & m_segs [ i ] , sizeof ( Segment ) * n ) ; seg = & m_segs [ i ] ; } seg -> d = dist ; memcpy ( seg -> s , s , sizeof ( float ) * 6 ) ; if ( m_nsegs < MAX_SEGS ) m_nsegs ++ ; } void LocalBoundary :: update ( dtPolyRef ref , const float * pos , const float collisionQueryRange , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { static const int MAX_LOCAL_POLYS = 16 ; static const int MAX_SEGS_PER_POLY = DT_VERTS_@@ PER_POLYG@@ ON * 2 ; if ( ! ref ) { dtVset ( m_center , FLT_MAX , FLT_MAX , FLT_MAX ) ; m_nsegs = 0 ; return ; } dtVcopy ( m_center , pos ) ; dtPolyRef locals [ MAX_LOCAL_POLYS ] ; int nlocals = 0 ; navquery -> findLocal@@ Neighbourho@@ od ( ref , pos , collisionQueryRange , filter , locals , 0 , & nlocals , MAX_LOCAL_POLYS ) ; m_nsegs = 0 ; float segs [ MAX_SEGS_PER_POLY * 6 ] ; int nsegs = 0 ; for ( int j = 0 ; j < nlocals ; ++ j ) { navquery -> getPoly@@ Wall@@ Segments ( locals [ j ] , filter , segs , & nsegs , MAX_SEGS_PER_POLY ) ; for ( int k = 0 ; k < nsegs ; ++ k ) { const float * s = & segs [ k * 6 ] ; float tseg ; const float distSqr = dtDistance@@ PtSeg@@ Sqr2D ( pos , s , s + 3 , tseg ) ; if ( distSqr > dtSqr ( collisionQueryRange ) ) continue ; addSegment ( distSqr , s ) ; } } } CrowdManager :: CrowdManager ( ) : m_obstacleQuery ( 0 ) , m_pathResult ( 0 ) , m_maxPathResult ( 0 ) , m_totalTime ( 0 ) , m_rvoTime ( 0 ) , m_sampleCount ( 0 ) , m_moveRequestCount ( 0 ) { dtVset ( m_ext , 2 , 4 , 2 ) ; m_obstacleQuery = dtAlloc@@ ObstacleAvoidanceQuery ( ) ; m_obstacleQuery -> init ( 6 , 8 ) ; m_obstacleQuery -> setDesired@@ VelocityWeight ( 2.0f ) ; m_obstacleQuery -> setCurrentVelocityWeight ( 0.75f ) ; m_obstacleQuery -> setPre@@ ferred@@ SideWeight ( 0.75f ) ; m_obstacleQuery -> setCollision@@ TimeWeight ( 2.5f ) ; m_obstacleQuery -> setTime@@ Horizon ( 2.5f ) ; m_obstacleQuery -> setVelocity@@ SelectionBias ( 0.4f ) ; memset ( m_vodebug , 0 , sizeof ( m_vodebug ) ) ; const int maxAdaptiveSamples = ( VO_ADAPTIVE_DIVS * VO_ADAPTIVE_RINGS + 1 ) * VO_ADAPTIVE_DEPTH ; const int maxGridSamples = VO_GRID_SIZE * VO_GRID_SIZE ; const int sampleCount = dtMax ( maxAdaptiveSamples , maxGridSamples ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_vodebug [ i ] = dtAlloc@@ ObstacleAvoidanceDebugData ( ) ; m_vodebug [ i ] -> init ( sampleCount ) ; } m_maxPathResult = 256 ; m_pathResult = ( dtPolyRef * ) dtAlloc ( sizeof ( dtPolyRef ) * m_maxPathResult , DT_ALLOC_PERM ) ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { m_agents [ i ] . corridor . init ( m_maxPathResult ) ; } m_grid . init ( 100 , 1.0f ) ; reset ( ) ; } CrowdManager :: ~ CrowdManager ( ) { delete [ ] m_pathResult ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) dtFree@@ ObstacleAvoidanceDebugData ( m_vodebug [ i ] ) ; dtFree@@ ObstacleAvoidanceQuery ( m_obstacleQuery ) ; } void CrowdManager :: reset ( ) { for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) m_agents [ i ] . active = 0 ; } const int CrowdManager :: getAg@@ entCount ( ) const { return MAX_AGENTS ; } const Agent * CrowdManager :: getAgent ( const int idx ) { return & m_agents [ idx ] ; } int CrowdManager :: addAgent ( const float * pos , const float radius , const float height , dtNavMeshQuery * navquery ) { int idx = - 1 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) { idx = i ; break ; } } if ( idx == - 1 ) return - 1 ; Agent * ag = & m_agents [ idx ] ; float nearest [ 3 ] ; dtPolyRef ref ; navquery -> findNearest@@ Poly ( pos , m_ext , & m_filter , & ref , nearest ) ; if ( ! ref ) { return - 1 ; } ag -> corridor . reset ( ref , nearest ) ; ag -> boundary . reset ( ) ; ag -> radius = radius ; ag -> height = height ; ag -> collisionQueryRange = radius * 8 ; ag -> pathOptimizationRange = radius * 30 ; ag -> topologyOptTime = 0 ; ag -> nneis = 0 ; dtVset ( ag -> dvel , 0 , 0 , 0 ) ; dtVset ( ag -> nvel , 0 , 0 , 0 ) ; dtVset ( ag -> vel , 0 , 0 , 0 ) ; dtVcopy ( ag -> npos , nearest ) ; ag -> maxspeed = 0 ; ag -> t = 0 ; dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; ag -> active = 1 ; ag -> var = ( rand ( ) % 10 ) / 9.0f ; for ( int i = 0 ; i < AGENT_MAX_TRAIL ; ++ i ) dtVcopy ( & ag -> trail [ i * 3 ] , ag -> corridor . getPos ( ) ) ; ag -> htrail = 0 ; return idx ; } void CrowdManager :: removeAgent ( const int idx ) { if ( idx >= 0 && idx < MAX_AGENTS ) { m_agents [ idx ] . active = 0 ; } } bool CrowdManager :: requestMoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; } req -> idx = idx ; req -> ref = ref ; dtVcopy ( req -> pos , pos ) ; req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_REQUESTING ; req -> temp [ 0 ] = ref ; req -> ntemp = 1 ; return true ; } bool CrowdManager :: adjust@@ MoveTarget ( const int idx , dtPolyRef ref , const float * pos ) { if ( idx < 0 || idx > MAX_AGENTS ) return false ; if ( ! ref ) return false ; MoveRequest * req = 0 ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { if ( m_moveRequests [ i ] . idx == idx ) { req = & m_moveRequests [ i ] ; break ; } } if ( ! req ) { if ( m_moveRequestCount >= MAX_AGENTS ) return false ; req = & m_moveRequests [ m_moveRequestCount ++ ] ; memset ( req , 0 , sizeof ( MoveRequest ) ) ; req -> state = MR_TARGET_ADJUST ; req -> idx = idx ; } req -> aref = ref ; dtVcopy ( req -> apos , pos ) ; return true ; } int CrowdManager :: getActiveAgents ( Agent * * agents , const int maxAgents ) { int n = 0 ; for ( int i = 0 ; i < MAX_AGENTS ; ++ i ) { if ( ! m_agents [ i ] . active ) continue ; if ( n < maxAgents ) agents [ n ++ ] = & m_agents [ i ] ; } return n ; } static int addNeighbour ( const int idx , const float dist , Neighbour * neis , const int nneis , const int maxNeis ) { Neighbour * nei = 0 ; if ( ! nneis ) { nei = & neis [ nneis ] ; } else if ( dist >= neis [ nneis - 1 ] . dist ) { if ( nneis >= maxNeis ) return nneis ; nei = & neis [ nneis ] ; } else { int i ; for ( i = 0 ; i < nneis ; ++ i ) if ( dist <= neis [ i ] . dist ) break ; const int tgt = i + 1 ; const int n = dtMin ( nneis - i , maxNeis - tgt ) ; dtAssert ( tgt + n <= maxNeis ) ; if ( n > 0 ) memmove ( & neis [ tgt ] , & neis [ i ] , sizeof ( Neighbour ) * n ) ; nei = & neis [ i ] ; } memset ( nei , 0 , sizeof ( Neighbour ) ) ; nei -> idx = idx ; nei -> dist = dist ; return dtMin ( nneis + 1 , maxNeis ) ; } int CrowdManager :: getNeighbours ( const float * pos , const float height , const float range , const Agent * skip , Neighbour * result , const int maxResult ) { int n = 0 ; unsigned short ids [ MAX_AGENTS ] ; int nids = m_grid . queryItems ( pos [ 0 ] - range , pos [ 2 ] - range , pos [ 0 ] + range , pos [ 2 ] + range , ids , MAX_AGENTS ) ; for ( int i = 0 ; i < nids ; ++ i ) { Agent * ag = & m_agents [ ids [ i ] ] ; if ( ag == skip ) continue ; float diff [ 3 ] ; dtVsub ( diff , pos , ag -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( height + ag -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; const float distSqr = dtVlenSqr ( diff ) ; if ( distSqr > dtSqr ( range ) ) continue ; n = addNeighbour ( ids [ i ] , distSqr , result , n , maxResult ) ; } return n ; } void CrowdManager :: updateMoveRequest ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( ! ag -> active ) req -> state = MR_TARGET_FAILED ; if ( req -> aref ) { if ( req -> state == MR_TARGET_ADJUST ) { ag -> corridor . moveTargetPosition ( req -> apos , navquery , filter ) ; req -> state = MR_TARGET_VALID ; } else { float result [ 3 ] ; static const int MAX_VISITED = 16 ; dtPolyRef visited [ MAX_VISITED ] ; int nvisited = 0 ; navquery -> moveAlongSurface ( req -> temp [ req -> ntemp - 1 ] , req -> pos , req -> apos , filter , result , visited , & nvisited , MAX_VISITED ) ; req -> ntemp = fixupCorridorEnd ( req -> temp , req -> ntemp , MAX_TEMP_@@ PATH , visited , nvisited ) ; dtVcopy ( req -> pos , result ) ; dtVset ( req -> apos , 0 , 0 , 0 ) ; req -> aref = 0 ; } } if ( req -> state == MR_TARGET_REQUESTING ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float reqPos [ 3 ] ; dtVcopy ( reqPos , ag -> corridor . getPos ( ) ) ; dtPolyRef reqPath [ 8 ] ; reqPath [ 0 ] = path [ 0 ] ; int reqPathCount = 1 ; req -> pathqRef = m_pathq . request ( reqPath [ reqPathCount - 1 ] , req -> ref , reqPos , req -> pos , & m_filter ) ; if ( req -> pathqRef != PATHQ_INVALID ) { ag -> corridor . setCorridor ( reqPos , reqPath , reqPathCount ) ; req -> state = MR_TARGET_WAITING_FOR_PATH ; } } } m_pathq . update ( navquery ) ; for ( int i = 0 ; i < m_moveRequestCount ; ++ i ) { MoveRequest * req = & m_moveRequests [ i ] ; Agent * ag = & m_agents [ req -> idx ] ; if ( req -> state == MR_TARGET_WAITING_FOR_PATH ) { int state = m_pathq . getRequestState ( req -> pathqRef ) ; if ( state == PATHQ_STATE_INVALID ) { req -> pathqRef = PATHQ_INVALID ; req -> state = MR_TARGET_FAILED ; } else if ( state == PATHQ_STATE_READY ) { const dtPolyRef * path = ag -> corridor . getPath ( ) ; const int npath = ag -> corridor . getPathCount ( ) ; dtAssert ( npath ) ; float targetPos [ 3 ] ; dtVcopy ( targetPos , req -> pos ) ; dtPolyRef * res = m_pathResult ; bool valid = true ; int nres = m_pathq . getPathResult ( req -> pathqRef , res , m_maxPathResult ) ; if ( ! nres ) valid = false ; if ( req -> ntemp > 1 ) { nres = fixupCorridorEnd ( res , nres , m_maxPathResult , req -> temp , req -> ntemp ) ; } if ( valid && path [ npath - 1 ] != res [ 0 ] ) valid = false ; if ( valid ) { if ( npath > 1 ) { if ( ( npath - 1 ) + nres > m_maxPathResult ) nres = m_maxPathResult - ( npath - 1 ) ; memmove ( res + npath - 1 , res , sizeof ( dtPolyRef ) * nres ) ; memcpy ( res , path , sizeof ( dtPolyRef ) * ( npath - 1 ) ) ; nres += npath - 1 ; } if ( res [ nres - 1 ] != req -> ref ) { float nearest [ 3 ] ; if ( navquery -> closestPointOnPoly ( res [ nres - 1 ] , targetPos , nearest ) == DT_SUCCESS ) dtVcopy ( targetPos , nearest ) ; else valid = false ; } } if ( valid ) { ag -> corridor . setCorridor ( targetPos , res , nres ) ; req -> state = MR_TARGET_VALID ; } else { req -> state = MR_TARGET_FAILED ; } } } if ( req -> state == MR_TARGET_VALID || req -> state == MR_TARGET_FAILED ) { m_moveRequestCount -- ; if ( i != m_moveRequestCount ) memcpy ( & m_moveRequests [ i ] , & m_moveRequests [ m_moveRequestCount ] , sizeof ( MoveRequest ) ) ; -- i ; } } } static int addToOptQueue ( Agent * newag , Agent * * agents , const int nagents , const int maxAgents ) { int slot = 0 ; if ( ! nagents ) { slot = nagents ; } else if ( newag -> topologyOptTime <= agents [ nagents - 1 ] -> topologyOptTime ) { if ( nagents >= maxAgents ) return nagents ; slot = nagents ; } else { int i ; for ( i = 0 ; i < nagents ; ++ i ) if ( newag -> topologyOptTime >= agents [ i ] -> topologyOptTime ) break ; const int tgt = i + 1 ; const int n = dtMin ( nagents - i , maxAgents - tgt ) ; dtAssert ( tgt + n <= maxAgents ) ; if ( n > 0 ) memmove ( & agents [ tgt ] , & agents [ i ] , sizeof ( Agent * ) * n ) ; slot = i ; } agents [ slot ] = newag ; return dtMin ( nagents + 1 , maxAgents ) ; } void CrowdManager :: updateTopologyOptimization ( const float dt , dtNavMeshQuery * navquery , const dtQueryFilter * filter ) { Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; if ( ! nagents ) return ; const float OPT_TIME_THR = 0.5f ; const int OPT_MAX_AGENTS = 1 ; Agent * queue [ OPT_MAX_AGENTS ] ; int nqueue = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> topologyOptTime += dt ; if ( ag -> topologyOptTime >= OPT_TIME_THR ) { nqueue = addToOptQueue ( ag , queue , nqueue , OPT_MAX_AGENTS ) ; } } for ( int i = 0 ; i < nqueue ; ++ i ) { Agent * ag = queue [ i ] ; ag -> corridor . optimizePathTopology ( navquery , filter ) ; ag -> topologyOptTime = 0 ; } } void CrowdManager :: update ( const float dt , unsigned int flags , dtNavMeshQuery * navquery ) { m_sampleCount = 0 ; m_totalTime = 0 ; m_rvoTime = 0 ; if ( ! navquery ) return ; TimeVal startTime = getPerfTime ( ) ; Agent * agents [ MAX_AGENTS ] ; int nagents = getActiveAgents ( agents , MAX_AGENTS ) ; static const float MAX_ACC = 8.0f ; static const float MAX_SPEED = 3.5f ; updateMoveRequest ( dt , navquery , & m_filter ) ; if ( flags & CROWDMAN_OPTIMIZE_@@ TOPO ) updateTopologyOptimization ( dt , navquery , & m_filter ) ; m_grid . clear ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; const float * p = ag -> npos ; const float r = ag -> radius ; m_grid . addItem ( ( unsigned short ) i , p [ 0 ] - r , p [ 2 ] - r , p [ 0 ] + r , p [ 2 ] + r ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( dtVdist2DSqr ( ag -> npos , ag -> boundary . getCenter ( ) ) > dtSqr ( ag -> collisionQueryRange * 0.25f ) ) ag -> boundary . update ( ag -> corridor . getFirstPoly ( ) , ag -> npos , ag -> collisionQueryRange , navquery , & m_filter ) ; ag -> nneis = getNeighbours ( ag -> npos , ag -> height , ag -> collisionQueryRange , ag , ag -> neis , AGENT_MAX_@@ NEIG@@ HBO@@ URS ) ; } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> ncorners = ag -> corridor . findCorners ( ag -> cornerVerts , ag -> cornerFlags , ag -> cornerPolys , AGENT_MAX_@@ CORNERS , navquery , & m_filter ) ; if ( ( flags & CROWDMAN_OPTIMIZE_@@ VIS ) && ag -> ncorners > 0 ) { const float * target = & ag -> cornerVerts [ dtMin ( 1 , ag -> ncorners - 1 ) * 3 ] ; dtVcopy ( ag -> opts , ag -> corridor . getPos ( ) ) ; dtVcopy ( ag -> opte , target ) ; ag -> corridor . optimizePathVisibility ( target , ag -> pathOptimizationRange , navquery , & m_filter ) ; } else { dtVset ( ag -> opts , 0 , 0 , 0 ) ; dtVset ( ag -> opte , 0 , 0 , 0 ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; float dvel [ 3 ] = { 0 , 0 , 0 } ; if ( flags & CROWDMAN_@@ ANTI@@ CIPATE_@@ TURNS ) ag -> calcSmoothSteerDirection ( dvel ) ; else ag -> calcStraightSteerDirection ( dvel ) ; const float slowDownRadius = ag -> radius * 2 ; const float speedScale = ag -> getDistanceToGoal ( slowDownRadius ) / slowDownRadius ; if ( flags & CROWDMAN_@@ DRUNK ) { ag -> t += dt * ( 1.0f - ag -> var * 0.25f ) ; ag -> maxspeed = MAX_SPEED * ( 1 + dtSqr ( cosf ( ag -> t * 2.0f ) ) * 0.3f ) ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; const float amp = cosf ( ag -> var * 13.69@@ f + ag -> t * 3.123f ) * 0.2f ; const float nx = - dvel [ 2 ] ; const float nz = dvel [ 0 ] ; dvel [ 0 ] += nx * amp ; dvel [ 2 ] += nz * amp ; } else { ag -> maxspeed = MAX_SPEED ; dtVscale ( dvel , dvel , ag -> maxspeed * speedScale ) ; } dtVcopy ( ag -> dvel , dvel ) ; } TimeVal rvoStartTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_obstacleQuery -> reset ( ) ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; m_obstacleQuery -> addCir@@ cle ( nei -> npos , nei -> radius , nei -> vel , nei -> dvel ) ; } for ( int j = 0 ; j < ag -> boundary . getSegment@@ Count ( ) ; ++ j ) { const float * s = ag -> boundary . getSegment ( j ) ; if ( dtTri@@ Area2D ( ag -> npos , s , s + 3 ) < 0.0f ) continue ; m_obstacleQuery -> addSegment ( s , s + 3 ) ; } bool adaptive = true ; if ( adaptive ) { m_obstacleQuery -> sampleVelocity@@ Adapt@@ ive ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_ADAPTIVE_DIVS , VO_ADAPTIVE_RINGS , VO_ADAPTIVE_DEPTH , m_vodebug [ i ] ) ; } else { m_obstacleQuery -> sampleVeloc@@ ityGrid ( ag -> npos , ag -> radius , ag -> maxspeed , ag -> vel , ag -> dvel , ag -> nvel , VO_GRID_SIZE , m_vodebug [ i ] ) ; } } else { dtVcopy ( ag -> nvel , ag -> dvel ) ; } } TimeVal rvoEndTime = getPerfTime ( ) ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> integrate ( MAX_ACC , dt ) ; } for ( int iter = 0 ; iter < 4 ; ++ iter ) { for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVset ( ag -> disp , 0 , 0 , 0 ) ; float w = 0 ; for ( int j = 0 ; j < ag -> nneis ; ++ j ) { const Agent * nei = & m_agents [ ag -> neis [ j ] . idx ] ; float diff [ 3 ] ; dtVsub ( diff , ag -> npos , nei -> npos ) ; if ( fabsf ( diff [ 1 ] ) >= ( ag -> height + nei -> height ) / 2.0f ) continue ; diff [ 1 ] = 0 ; float dist = dtVlenSqr ( diff ) ; if ( dist > dtSqr ( ag -> radius + nei -> radius ) ) continue ; dist = sqrtf ( dist ) ; float pen = ( ag -> radius + nei -> radius ) - dist ; if ( dist > 0.0001f ) pen = ( 1.0f / dist ) * ( pen * 0.5f ) * 0.7f ; dtVmad ( ag -> disp , ag -> disp , diff , pen ) ; w += 1.0f ; } if ( w > 0.0001f ) { const float iw = 1.0f / w ; dtVscale ( ag -> disp , ag -> disp , iw ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; dtVadd ( ag -> npos , ag -> npos , ag -> disp ) ; } } for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; ag -> corridor . movePosition ( ag -> npos , navquery , & m_filter ) ; dtVcopy ( ag -> npos , ag -> corridor . getPos ( ) ) ; } TimeVal endTime = getPerfTime ( ) ; int ns = 0 ; for ( int i = 0 ; i < nagents ; ++ i ) { Agent * ag = agents [ i ] ; if ( flags & CROWDMAN_USE_VO ) { m_vodebug [ i ] -> normalizeSamples ( ) ; ns += m_vodebug [ i ] -> getSampleCount ( ) ; } ag -> htrail = ( ag -> htrail + 1 ) % AGENT_MAX_TRAIL ; dtVcopy ( & ag -> trail [ ag -> htrail * 3 ] , ag -> npos ) ; } m_sampleCount = ns ; m_rvoTime = getPerfDeltaTimeUsec ( rvoStartTime , rvoEndTime ) ; m_totalTime = getPerfDeltaTimeUsec ( startTime , endTime ) ; } </DOCUMENT>
