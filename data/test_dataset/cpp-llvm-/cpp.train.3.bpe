<DOCUMENT_ID="d@@ grat/ANNet@@ GPGP@@ U/tree/master/@@ example@@ s/de@@ signer/@@ ANNet@@ Designer.cpp"> # include < QApplication > # include " gui / QMainWindow . h " int main ( int argc , char * argv [ ] ) { QApplication a ( argc , argv ) ; MainWindow w ; w . show ( ) ; return a . exec ( ) ; } </DOCUMENT>
<DOCUMENT_ID="bo@@ mbe@@ hub@@ /PP@@ R_PPV@@ /tree/master/Sn@@ ap-3@@ .0/sn@@ ap-exp@@ /test-de@@ v/@@ ExplicitString@@ TableTest2.cpp"> # include " Sn@@ ap . h " # include < cstring > # include " Benchmark@@ Utilities . h " int main ( int argc , char * * argv ) { TBool debug = false ; TStr TagsFnm = " / lfs / madmax4/0 / yonathan / tags " ; if ( debug ) { TagsFnm = " / lfs / madmax4/0 / yonathan / tags _ small " ; } Schema TagS ; TagS . Add ( TPair < TStr , TAttrType > ( " UserId " , atInt ) ) ; TagS . Add ( TPair < TStr , TAttrType > ( " Tag " , atStr ) ) ; float ft_max ; float mu_max ; timeval timer4 ; gettimeofday ( & timer4 , NULL ) ; double t1 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_Tags = ExplicitStringTable :: LoadSS ( TagS , TagsFnm + " . tsv " ) ; gettimeofday ( & timer4 , NULL ) ; double t2 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ load ▁ tags ▁ table : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_Tags -> PrintSize ( ) ; getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer6 ; gettimeofday ( & timer6 , NULL ) ; t1 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_TagsJoinUser = ES_Tags -> Sel@@ fJo@@ in ( " UserId " ) ; gettimeofday ( & timer6 , NULL ) ; t2 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ join ▁ on ▁ user ▁ id ▁ column : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_TagsJoinUser -> PrintSize ( ) ; if ( debug ) { ES_TagsJoinUser -> SaveSS ( TagsFnm + " _ join _ user _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer7 ; gettimeofday ( & timer7 , NULL ) ; t1 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_JavaTags = ExplicitStringTable :: New ( TagS ) ; TInt@@ V SelectedRows1 ; if ( debug ) { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " c # " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } else { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " java " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } gettimeofday ( & timer7 , NULL ) ; t2 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ select ▁ java ▁ users : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_JavaTags -> PrintSize ( ) ; if ( debug ) { ES_JavaTags -> SaveSS ( TagsFnm + " _ select _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="B@@ illHall@@ y/boo/tree/master/lib/@@ antlr@@ -2.7.@@ 5/lib@@ /cpp/src/@@ TreeParser@@ .cpp"> # include < iostream > # include " antlr / TreeParser . hpp " # include " antlr / ASTNULLType . hpp " # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE namespace antlr { # endif RefAST TreeParser :: AST@@ NULL ( new ASTNULLType ) ; void TreeParser :: reportError ( const Reco@@ gnition@@ Exception & ex ) { ANTLR_USE_NAMESPACE ( std ) cerr << ex . toString ( ) . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: reportError ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " error : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: report@@ Warning ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " warning : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceIndent ( ) { for ( int i = 0 ; i < traceDepth ; i ++ ) ANTLR_USE_NAMESPACE ( std ) cout << " ▁ " ; } void TreeParser :: traceIn ( const char * rname , RefAST t ) { traceDepth ++ ; traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " > ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; } void TreeParser :: traceOut ( const char * rname , RefAST t ) { traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " < ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; traceDepth -- ; } # ifdef ANTLR_CXX_SUPPORTS_NAMESPACE } # endif </DOCUMENT>
<DOCUMENT_ID="esqu@@ do/cy@@ mru@@ coin/tree/master/src/qt/@@ about@@ dialog.cpp"> # include " aboutdialog . h " # include " ui _ aboutdialog . h " # include " clientmodel . h " # include " clientversion . h " const int ABOUTDIALOG_COPYRIGHT_YEAR = 2014 ; AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; ui -> copyright@@ Label -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ deve@@ lopers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; } void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFull@@ Version ( ) ) ; } } AboutDialog :: ~ AboutDialog ( ) { delete ui ; } void AboutDialog :: on_b@@ utton@@ Box_@@ accepted ( ) { close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="hk@@ arim/@@ JUC@@ E-Graph@@ -Component@@ /tree/master/JuceLibraryCode/modules/juce_@@ gui_basics/@@ filebrowser@@ /juce_@@ ImagePreviewComponent@@ .cpp"> ImagePreviewComponent :: ImagePreviewComponent ( ) { } ImagePreviewComponent :: ~ ImagePreviewComponent ( ) { } void ImagePreviewComponent :: getThumbSize ( int & w , int & h ) const { const int availableW = propor@@ tionOf@@ Width ( 0.97@@ f ) ; const int availableH = getHeight ( ) - 13 * 4 ; const double scale = jmin ( 1.0 , availableW / ( double ) w , availableH / ( double ) h ) ; w = roundToInt ( scale * w ) ; h = roundToInt ( scale * h ) ; } void ImagePreviewComponent :: selectedFileChanged ( const File & file ) { if ( fileToLoad != file ) { fileToLoad = file ; startTimer ( 100 ) ; } } void ImagePreviewComponent :: timerCallback ( ) { stop@@ Timer ( ) ; currentThumbnail = Image ( ) ; currentDetails . clear ( ) ; repaint ( ) ; ScopedPointer < FileInputStream > in ( fileToLoad . createInputStream ( ) ) ; if ( in != nullptr ) { if ( ImageFileFormat * const format = ImageFileFormat :: findImage@@ FormatForStream ( * in ) ) { currentThumbnail = format -> decode@@ Image ( * in ) ; if ( currentThumbnail . isValid ( ) ) { int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; currentDetails << fileToLoad . getFileName ( ) << " \n " << format -> getFormat@@ Name ( ) << " \n " << w << " ▁ x ▁ " << h << " ▁ pixels \n " << File :: descriptionOf@@ SizeInBytes ( fileToLoad . getSize ( ) ) ; getThumbSize ( w , h ) ; currentThumbnail = currentThumbnail . rescaled ( w , h ) ; } } } } void ImagePreviewComponent :: paint ( Graphics & g ) { if ( currentThumbnail . isValid ( ) ) { g . setFont ( 13.0f ) ; int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; getThumbSize ( w , h ) ; const int numLines = 4 ; const int totalH = 13 * numLines + h + 4 ; const int y = ( getHeight ( ) - totalH ) / 2 ; g . drawImageWithin ( currentThumbnail , ( getWidth ( ) - w ) / 2 , y , w , h , RectanglePlacement :: centred | RectanglePlacement :: onlyReduce@@ InSize , false ) ; g . drawFit@@ tedText ( currentDetails , 0 , y + h + 4 , getWidth ( ) , 100 , Justification :: centred@@ Top , numLines ) ; } } </DOCUMENT>
<DOCUMENT_ID="mapmapteam@@ /map@@ map/tree/master/src/gui/@@ contri@@ b/@@ qtpropertybrowser@@ /src/qtpropertybrowser@@ utils.cpp"> # include " qtpropertybrowser@@ utils _ p . h " # include < QApplication > # include < QPainter > # include < QHBoxLayout > # include < QMouseEvent > # include < QCheckBox > # include < QLineEdit > # include < QMenu > # include < QStyleOption > # if QT_VERSION >= 0x040400 QT_BEGIN_NAMESPACE # endif QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - upar@@ row . png " ) ) ) ; appendCursor ( Qt :: Cross@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBe@@ amCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBe@@ am " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibe@@ am . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHor@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: Blan@@ kCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blan@@ k " ) , QIcon ( ) ) ; appendCursor ( Qt :: Split@@ VCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: Split@@ HCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: Forbidd@@ enCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closed@@ hand . png " ) ) ) ; appendCursor ( Qt :: WhatsThis@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsth@@ is . png " ) ) ) ; appendCursor ( Qt :: Busy@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; } void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; } void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; } QStringList QtCursorDatabase :: cursorShape@@ Names ( ) const { return m_cursorNames ; } QMap < int , QIcon > QtCursorDatabase :: cursorShape@@ Icons ( ) const { return m_cursorIcons ; } QString QtCursorDatabase :: cursorToShape@@ Name ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; if ( val >= 0 ) return m_cursorNames . at ( val ) ; return QString ( ) ; } QIcon QtCursorDatabase :: cursorToShape@@ Icon ( const QCursor & cursor ) const { int val = cursorToValue ( cursor ) ; return m_cursorIcons . value ( val ) ; } int QtCursorDatabase :: cursorToValue ( const QCursor & cursor ) const { # ifndef QT_NO_CURSOR Qt :: CursorShape shape = cursor . shape ( ) ; if ( m_cursorShapeToValue . contains ( shape ) ) return m_cursorShapeToValue [ shape ] ; # endif return - 1 ; } # ifndef QT_NO_CURSOR QCursor QtCursorDatabase :: valueToCursor ( int value ) const { if ( m_valueToCursorShape . contains ( value ) ) return QCursor ( m_valueToCursorShape [ value ] ) ; return QCursor ( ) ; } # endif QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setComposition@@ Mode ( QPainter :: Composition@@ Mode_Sour@@ ce ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: brush@@ ValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; } QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; } QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; } QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; } QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; } QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layout@@ Direction ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; } void QtBoolEdit :: setText@@ Visible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; } Qt :: CheckState QtBoolEdit :: checkState ( ) const { return m_checkBox -> checkState ( ) ; } void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; } bool QtBoolEdit :: isChecked ( ) const { return m_checkBox -> isChecked ( ) ; } void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; } bool QtBoolEdit :: blockCheckBox@@ Signals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; } void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> button@@ s ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } } void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focus@@ Policy ( ) ) ; setAttribute ( Qt :: WA_@@ InputMethod@@ Enabled ) ; } bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandard@@ ContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QList@@ Iterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; } void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_S@@ hift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_S@@ uper@@ _L || nextKey == Qt :: Key_Alt@@ Gr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; } void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; } QKeySequence QtKeySequenceEdit :: keySequence ( ) const { return m_keySequence ; } int QtKeySequenceEdit :: translateModifiers ( Qt :: Keyboard@@ Modifiers state , const QString & text ) const { int result = 0 ; if ( ( state & Qt :: Shift@@ Modifier ) && ( text . size ( ) == 0 || ! text . at ( 0 ) . isPrint ( ) || text . at ( 0 ) . isLet@@ ter ( ) || text . at ( 0 ) . isSpace ( ) ) ) result |= Qt :: SHIFT ; if ( state & Qt :: ControlModifier ) result |= Qt :: CTRL ; if ( state & Qt :: Meta@@ Modifier ) result |= Qt :: META ; if ( state & Qt :: AltModifier ) result |= Qt :: ALT ; return result ; } void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; } void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; } void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; } void QtKeySequenceEdit :: keyRelease@@ Event ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; } void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; } bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: ShortcutOverride || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; } # if QT_VERSION >= 0x040400 QT_END_NAMESPACE # endif </DOCUMENT>
<DOCUMENT_ID="ich@@ u50@@ 1/WinObjC/tree/master/deps/3rdparty/ic@@ u/icu/@@ source/test/intl@@ test/tsm@@ thred@@ .cpp"> # if defined ( hpux ) # ifndef _INCLUDE_POSIX_SOURCE # define _INCLUDE_POSIX_SOURCE # endif # endif # include " simplet@@ hread . h " # include " unicode / utypes . h " # include " unicode / ustring . h " # include " umutex . h " # include " cmemory . h " # include " cstring . h " # include " uparse . h " # include " unicode / localpointer . h " # include " unicode / resbund . h " # include " unicode / udata . h " # include " unicode / uloc . h " # include " unicode / locid . h " # include " putili@@ mp . h " # include " intl@@ test . h " # include " tsm@@ thred . h " # include " unicode / ushape . h " # include " unicode / translit . h " # include " sharedobj@@ ect . h " # include " unified@@ cache . h " # include " uassert . h " # if U_PLATFORM_@@ USES_@@ ONLY_@@ WIN32_@@ API # undef POSIX # elif U_PLATFORM_@@ IMPLE@@ MENTS_@@ POSIX # define POSIX # else # undef POSIX # endif # if U_PLATFORM == U_PF_OS390 # define __DOT@@ 1 1 # define __UU # ifndef _XPG4_2 # define _XPG4_2 # endif # include < unistd . h > # endif # if defined ( POSIX ) # define HAVE_@@ IMP # if ( ICU_USE_THREADS == 1 ) # include < pthread . h > # endif # if defined ( __hpux ) && defined ( HPU@@ X_CM@@ A ) # if defined ( read ) # undef read # endif # endif # ifndef __EXTENSIONS__ # define __EXTENSIONS__ # endif # if U_PLATFORM == U_PF_OS390 # include < sys / types . h > # endif # if U_PLATFORM != U_PF_OS390 # include < signal . h > # endif # ifndef _XPG4_2 # define _XPG4_2 # endif # ifndef __USE_XOPEN_EXTENDED # define __USE_XOPEN_EXTENDED # endif # ifndef _INCLUDE_XOPEN_SOURCE_EXTENDED # define _INCLUDE_XOPEN_SOURCE_EXTENDED # endif # include < unistd . h > # endif # ifdef sleep # undef sleep # endif # define TSMTHREAD_FAIL ( msg ) errln ( " % s ▁ at ▁ file ▁ % s , ▁ line ▁ % d " , msg , __FILE__ , __LINE__ ) # define TSMTHREAD_ASSERT ( expr ) { if ( ! ( expr ) ) { TSMTHREAD_FAIL ( " Fail " ) ; } } MultithreadTest :: MultithreadTest ( ) { } MultithreadTest :: ~ MultithreadTest ( ) { } # if ( ICU_USE_THREADS == 0 ) void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; if ( index == 0 ) name = " NO _ THREADED _ TESTS " ; else name = " " ; if ( exec ) { logln ( " MultithreadTest ▁ - ▁ test ▁ DISABLED . ▁ ▁ ICU _ USE _ THREADS ▁ set ▁ to ▁ 0 , ▁ check ▁ your ▁ configuration ▁ if ▁ this ▁ is ▁ a ▁ proble@@ m . . " ) ; } } # else # include < stdio . h > # include < string . h > # include < ctype . h > # include " unicode / putil . h " # include " unicode / numfmt . h " # include " unicode / choicfmt . h " # include " unicode / msgfmt . h " # include " unicode / locid . h " # include " unicode / coll . h " # include " unicode / calendar . h " # include " uc@@ aconf . h " void SimpleThread :: errorFunc ( ) { } void MultithreadTest :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * ) { if ( exec ) logln ( " TestSuite ▁ MultithreadTest : ▁ " ) ; switch ( index ) { case 0 : name = " TestThreads " ; if ( exec ) TestThreads ( ) ; break ; case 1 : name = " TestMutex " ; if ( exec ) TestMutex ( ) ; break ; case 2 : name = " TestThreadedIntl " ; # if ! UCONFIG_NO_FORMATTING if ( exec ) { TestThreadedIntl ( ) ; } # endif break ; case 3 : name = " TestCollators " ; # if ! UCONFIG_NO_COLLATION if ( exec ) { TestCollators ( ) ; } # endif break ; case 4 : name = " TestString " ; if ( exec ) { TestString ( ) ; } break ; case 5 : name = " TestArabicShapingThreads " ; if ( exec ) { TestArabicShapingThreads ( ) ; } break ; case 6 : name = " TestAnyTranslit " ; if ( exec ) { TestAnyTranslit ( ) ; } break ; case 7 : name = " TestConditionVariables " ; if ( exec ) { TestConditionVariables ( ) ; } break ; case 8 : name = " TestUnifiedCache " ; if ( exec ) { TestUnifiedCache ( ) ; } break ; default : name = " " ; break ; } } # define THREADTEST_NRTHREADS 8 # define ARABICSHAPE_THREADTEST 30 class TestThreadsThread : public SimpleThread { public : TestThreadsThread ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { SimpleThread :: sleep ( 1000 ) ; Mutex m ; * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; } ; class TestArabicShapeThreads : public SimpleThread { public : TestArabicShapeThreads ( char * whatToChange ) { fWhatToChange = whatToChange ; } virtual void run ( ) { if ( doTailTest ( ) == TRUE ) * fWhatToChange = ' * ' ; } private : char * fWhatToChange ; UBool doTailTest ( void ) { static const UChar src [ ] = { 0x0020 , 0x0633 , 0 } ; static const UChar dst_old [ ] = { 0xFEB1 , 0x200@@ B , 0 } ; static const UChar dst_new [ ] = { 0xFEB1 , 0xFE@@ 73 , 0 } ; UChar dst [ 3 ] = { 0x0000 , 0x0000 , 0 } ; int32_t length ; UErrorCode status ; IntlTest inteltst = IntlTest ( ) ; status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_old , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_old [ 0 ] , dst_old [ 1 ] ) ; return FALSE ; } status = U_ZERO_ERROR ; length = u_shapeArabic ( src , - 1 , dst , UPRV_LENGTHOF ( dst ) , U_SHAPE_LETTERS_SHAPE | U_SHAPE_SEEN_TWOCELL_NEAR | U_SHAPE_@@ TAI@@ L_NEW_@@ UNICODE , & status ) ; if ( U_FAILURE ( status ) ) { inteltst . errln ( " Fail : ▁ status ▁ % s \n " , u_errorName ( status ) ) ; return FALSE ; } else if ( length != 2 ) { inteltst . errln ( " Fail : ▁ len ▁ % d ▁ expected ▁ 3 \n " , length ) ; return FALSE ; } else if ( u_strncmp ( dst , dst_new , UPRV_LENGTHOF ( dst ) ) ) { inteltst . errln ( " Fail : ▁ got ▁ U + % 04X ▁ U + % 04X ▁ expected ▁ U + % 04X ▁ U + % 04X \n " , dst [ 0 ] , dst [ 1 ] , dst_new [ 0 ] , dst_new [ 1 ] ) ; return FALSE ; } return TRUE ; } } ; void MultithreadTest :: TestThreads ( ) { char threadTestChars [ THREADTEST_NRTHREADS + 1 ] ; SimpleThread * threads [ THREADTEST_NRTHREADS ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestThreadsThread ( & threadTestChars [ i ] ) ; } threadTestChars [ THREADTEST_NRTHREADS ] = ' \0' ; logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } SimpleThread :: sleep ( 100 ) ; logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 40 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == THREADTEST_NRTHREADS ) { logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > " + UnicodeString ( threadTestChars ) + " < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < THREADTEST_NRTHREADS ; i ++ ) { delete threads [ i ] ; } } void MultithreadTest :: TestArabicShapingThreads ( ) { char threadTestChars [ ARABICSHAPE_THREADTEST + 1 ] ; SimpleThread * threads [ ARABICSHAPE_THREADTEST ] ; int32_t numThreadsStarted = 0 ; int32_t i ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { threadTestChars [ i ] = ' ▁ ' ; threads [ i ] = new TestArabicShapeThreads ( & threadTestChars [ i ] ) ; } threadTestChars [ ARABICSHAPE_THREADTEST ] = ' \0' ; logln ( " - > ▁ do ▁ TestArabicShapingThreads ▁ < - ▁ Firing ▁ off ▁ threads . . ▁ " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } logln ( " ▁ Subthread ▁ started . " ) ; } logln ( " Waiting ▁ for ▁ threads ▁ to ▁ be ▁ set . . " ) ; if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int32_t patience = 100 ; while ( patience -- ) { int32_t count = 0 ; umtx_lock ( NULL ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { if ( threadTestChars [ i ] == ' * ' ) { count ++ ; } } umtx_unlock ( NULL ) ; if ( count == ARABICSHAPE_THREADTEST ) { logln ( " - > TestArabicShapingThreads ▁ < - ▁ Got ▁ all ▁ threads ! ▁ cya " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } return ; } logln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ Waiting . . " ) ; SimpleThread :: sleep ( 500 ) ; } errln ( " - > ▁ TestArabicShapingThreads ▁ < - ▁ PATIENCE ▁ EXCEEDED ! ! ▁ Still ▁ missing ▁ some . " ) ; for ( i = 0 ; i < ARABICSHAPE_THREADTEST ; i ++ ) { delete threads [ i ] ; } } static UMutex gTestMutexA = U_MUTEX_INITIALIZER ; static UMutex gTestMutexB = U_MUTEX_INITIALIZER ; static int gThreadsStarted = 0 ; static int gThreadsInMiddle = 0 ; static int gThreadsDone = 0 ; static const int TESTMUTEX_THREAD_COUNT = 4 ; static int safeIncr ( int & var , int amt ) { Mutex m ; var += amt ; return var ; } class TestMutexThread : public SimpleThread { public : virtual void run ( ) { safeIncr ( gThreadsStarted , 1 ) ; umtx_lock ( & gTestMutexA ) ; umtx_unlock ( & gTestMutexA ) ; safeIncr ( gThreadsInMiddle , 1 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexB ) ; safeIncr ( gThreadsDone , 1 ) ; } } ; void MultithreadTest :: TestMutex ( ) { gThreadsStarted = 0 ; gThreadsInMiddle = 0 ; gThreadsDone = 0 ; umtx_lock ( & gTestMutexA ) ; TestMutexThread * threads [ TESTMUTEX_THREAD_COUNT ] ; int i ; int32_t numThreadsStarted = 0 ; for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { threads [ i ] = new TestMutexThread ; if ( threads [ i ] -> start ( ) != 0 ) { errln ( " Error ▁ starting ▁ thread ▁ % d " , i ) ; } else { numThreadsStarted ++ ; } } if ( numThreadsStarted == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ started ▁ for ▁ testing ! " ) ; return ; } int patience = 0 ; while ( safeIncr ( gThreadsStarted , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsInMiddle == 0 ) ; TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_lock ( & gTestMutexB ) ; umtx_unlock ( & gTestMutexA ) ; patience = 0 ; while ( safeIncr ( gThreadsInMiddle , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } TSMTHREAD_ASSERT ( gThreadsDone == 0 ) ; umtx_unlock ( & gTestMutexB ) ; patience = 0 ; while ( safeIncr ( gThreadsDone , 0 ) != TESTMUTEX_THREAD_COUNT ) { if ( patience ++ > 24 ) { TSMTHREAD_FAIL ( " Patience ▁ Exceeded " ) ; return ; } SimpleThread :: sleep ( 500 ) ; } for ( i = 0 ; i < TESTMUTEX_THREAD_COUNT ; i ++ ) { delete threads [ i ] ; } } class ThreadWithStatus : public SimpleThread { public : UBool getError ( ) { return ( fErrors > 0 ) ; } UBool getError ( UnicodeString & fillinError ) { fillinError = fErrorString ; return ( fErrors > 0 ) ; } virtual ~ ThreadWithStatus ( ) { } protected : ThreadWithStatus ( ) : fErrors ( 0 ) { } void error ( const UnicodeString & error ) { fErrors ++ ; fErrorString = error ; SimpleThread :: errorFunc ( ) ; } void error ( ) { error ( " An ▁ error ▁ occure@@ d . " ) ; } private : int32_t fErrors ; UnicodeString fErrorString ; } ; UnicodeString showDifference ( const UnicodeString & expected , const UnicodeString & result ) { UnicodeString res ; res = expected + " < Expected \n " ; if ( expected . length ( ) != result . length ( ) ) res += " ▁ [ ▁ Different ▁ lengths ▁ ] ▁ \n " ; else { for ( int32_t i = 0 ; i < expected . length ( ) ; i ++ ) { if ( expected [ i ] == result [ i ] ) { res += " ▁ " ; } else { res += " | " ; } } res += " < Differences " ; res += " \n " ; } res += result + " < Result \n " ; return res ; } const int kFormatThreadIterations = 100 ; const int kFormatThreadThreads = 10 ; # if ! UCONFIG_NO_FORMATTING struct FormatThreadTestData { double number ; UnicodeString string ; FormatThreadTestData ( double a , const UnicodeString & b ) : number ( a ) , string ( b ) { } } ; static void formatErrorMessage ( UErrorCode & realStatus , const UnicodeString & pattern , const Locale & theLocale , UErrorCode inStatus0 , const Locale & inCountry2 , double currency3 , UnicodeString & result ) { if ( U_FAILURE ( realStatus ) ) return ; UnicodeString errString1 ( u_errorName ( inStatus0 ) ) ; UnicodeString countryName2 ; inCountry2 . getDisplay@@ Country ( theLocale , countryName2 ) ; Formattable myArgs [ ] = { Formattable ( ( int32_t ) inStatus0 ) , Formattable ( errString1 ) , Formattable ( countryName2 ) , Formattable ( currency3 ) } ; MessageFormat * fmt = new MessageFormat ( " MessageFormat ' s ▁ API ▁ is ▁ bro@@ ken ! ! ! ! ! ! ! ! ! ! ! " , realStatus ) ; fmt -> setLocale ( theLocale ) ; fmt -> applyPattern ( pattern , realStatus ) ; if ( U_FAILURE ( realStatus ) ) { delete fmt ; return ; } FieldPosition ignore = 0 ; fmt -> format ( myArgs , 4 , result , ignore , realStatus ) ; delete fmt ; } class ThreadSafeFormatSharedData { public : ThreadSafeFormatSharedData ( UErrorCode & status ) ; ~ ThreadSafeFormatSharedData ( ) ; LocalPointer < NumberFormat > fFormat ; Formattable fYDDThing ; Formattable fBBDThing ; UnicodeString fYDDStr ; UnicodeString fBBDStr ; } ; const ThreadSafeFormatSharedData * gSharedData = NULL ; ThreadSafeFormatSharedData :: ThreadSafeFormatSharedData ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; static const UChar kYDD [ ] = { 0x59 , 0x44 , 0x44 , 0x00 } ; static const UChar kBBD [ ] = { 0x42 , 0x42 , 0x44 , 0x00 } ; fYDDThing . adoptObject ( new CurrencyAmount ( 123.456 , kYDD , status ) ) ; fBBDThing . adoptObject ( new CurrencyAmount ( 987.6@@ 54 , kBBD , status ) ) ; if ( U_FAILURE ( status ) ) { return ; } fFormat -> format ( fYDDThing , fYDDStr , NULL , status ) ; fFormat -> format ( fBBDThing , fBBDStr , NULL , status ) ; gSharedData = this ; } ThreadSafeFormatSharedData :: ~ ThreadSafeFormatSharedData ( ) { gSharedData = NULL ; } class ThreadSafeFormat { public : ThreadSafeFormat ( UErrorCode & status ) ; UBool doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const ; private : LocalPointer < NumberFormat > fFormat ; } ; ThreadSafeFormat :: ThreadSafeFormat ( UErrorCode & status ) { fFormat . adoptInstead ( NumberFormat :: createCurrencyInstance ( Locale :: getUS ( ) , status ) ) ; } static const UChar kUSD [ ] = { 0x55 , 0x53 , 0x44 , 0x00 } ; UBool ThreadSafeFormat :: doStuff ( int32_t offset , UnicodeString & appendErr , UErrorCode & status ) const { UBool okay = TRUE ; if ( u_strcmp ( fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " fFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } if ( u_strcmp ( gSharedData -> fFormat -> getCurrency ( ) , kUSD ) ) { appendErr . append ( " gFormat ▁ currency ▁ ! = ▁ " ) . append ( kUSD ) . append ( " , ▁ = " ) . append ( gSharedData -> fFormat -> getCurrency ( ) ) . append ( " ! ▁ " ) ; okay = FALSE ; } UnicodeString str ; const UnicodeString * o = NULL ; Formattable f ; const NumberFormat * nf = NULL ; switch ( offset % 4 ) { case 0 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 1 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = gSharedData -> fFormat . getAlias ( ) ; break ; case 2 : f = gSharedData -> fYDDThing ; o = & gSharedData -> fYDDStr ; nf = fFormat . getAlias ( ) ; break ; case 3 : f = gSharedData -> fBBDThing ; o = & gSharedData -> fBBDStr ; nf = fFormat . getAlias ( ) ; break ; } nf -> format ( f , str , NULL , status ) ; if ( * o != str ) { appendErr . append ( showDifference ( * o , str ) ) ; okay = FALSE ; } return okay ; } UBool U_CALL@@ CONV isAcceptable ( void * , const char * , const char * , const UData@@ Info * ) { return TRUE ; } class FormatThreadTest : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; LocalPointer < ThreadSafeFormat > fTSF ; FormatThreadTest ( ) : ThreadWithStatus ( ) , fNum ( 0 ) , fTraceInfo ( 0 ) , fTSF ( NULL ) , fOffset ( 0 ) { UErrorCode status = U_ZERO_ERROR ; fTSF . adoptInstead ( new ThreadSafeFormat ( status ) ) ; static int32_t fgOffset = 0 ; fgOffset += 3 ; fOffset = fgOffset ; } virtual void run ( ) { fTraceInfo = 1 ; LocalPointer < NumberFormat > percentFormatter ; UErrorCode status = U_ZERO_ERROR ; # if 0 for ( int i = 0 ; i < 4000 ; i ++ ) { status = U_ZERO_ERROR ; UDataMemory * data1 = udata_openChoice ( 0 , " res " , " en _ US " , isAcceptable , 0 , & status ) ; UDataMemory * data2 = udata_openChoice ( 0 , " res " , " fr " , isAcceptable , 0 , & status ) ; udata_close ( data1 ) ; udata_close ( data2 ) ; if ( U_FAILURE ( status ) ) { error ( " udata _ openChoice ▁ failed . \n " ) ; break ; } } return ; # endif # if 0 int m ; for ( m = 0 ; m < 4000 ; m ++ ) { status = U_ZERO_ERROR ; UResource@@ Bund@@ le * res = NULL ; const char * localeName = NULL ; Locale loc = Locale :: getEnglish ( ) ; localeName = loc . getName ( ) ; res = ures_@@ open ( NULL , localeName , & status ) ; ures_@@ close ( res ) ; if ( U_FAILURE ( status ) ) { error ( " Resource ▁ bund@@ le ▁ constru@@ ction ▁ failed . \n " ) ; break ; } } return ; # endif FormatThreadTestData kNumberFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , UnicodeString ( "5" , " " ) ) , FormatThreadTestData ( 6.0 , UnicodeString ( "6" , " " ) ) , FormatThreadTestData ( 20.0 , UnicodeString ( "20@@ " , " " ) ) , FormatThreadTestData ( 8.0 , UnicodeString ( "8" , " " ) ) , FormatThreadTestData ( 8.3 , UnicodeString ( "8.@@ 3" , " " ) ) , FormatThreadTestData ( 12345 , UnicodeString ( "12@@ ,345@@ " , " " ) ) , FormatThreadTestData ( 81890.23 , UnicodeString ( "81@@ ,890.@@ 23" , " " ) ) , } ; int32_t kNumberFormatTestDataLength = UPRV_LENGTHOF ( kNumberFormatTestData ) ; FormatThreadTestData kPercentFormatTestData [ ] = { FormatThreadTestData ( ( double ) 5.0 , CharsToUnicodeString ( "500@@ \\u00a0 % " ) ) , FormatThreadTestData ( 1.0 , CharsToUnicodeString ( "100@@ \\u00a0 % " ) ) , FormatThreadTestData ( 0.26 , CharsToUnicodeString ( "26@@ \\u00a0 % " ) ) , FormatThreadTestData ( 1638@@ 4.99 , CharsToUnicodeString ( "1\\u00a@@ 0638\\u00a@@ 0499\\u00a0 % " ) ) , FormatThreadTestData ( 81890.23 , CharsToUnicodeString ( "8\\u00a@@ 0189@@ \\u00a@@ 0023@@ \\u00a0 % " ) ) , } ; int32_t kPercentFormatTestDataLength = UPRV_LENGTHOF ( kPercentFormatTestData ) ; int32_t iteration ; status = U_ZERO_ERROR ; LocalPointer < NumberFormat > formatter ( NumberFormat :: createInstance ( Locale :: getEnglish ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createInstance ( ) . " ) ; goto cleanupAndReturn ; } percentFormatter . adoptInstead ( NumberFormat :: createPercentInstance ( Locale :: getFr@@ ench ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { error ( " Error ▁ on ▁ NumberFormat : : createPercentInstance ( ) . " ) ; goto cleanupAndReturn ; } for ( iteration = 0 ; ! getError ( ) && iteration < kFormatThreadIterations ; iteration ++ ) { int32_t whichLine = ( iteration + fOffset ) % kNumberFormatTestDataLength ; UnicodeString output ; formatter -> format ( kNumberFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kNumberFormatTestData [ whichLine ] . string ) ) { error ( " format ( ) . . ▁ expected ▁ " + kNumberFormatTestData [ whichLine ] . string + " ▁ got ▁ " + output ) ; goto cleanupAndReturn ; } output . remove ( ) ; whichLine = ( iteration + fOffset ) % kPercentFormatTestDataLength ; percentFormatter -> format ( kPercentFormatTestData [ whichLine ] . number , output ) ; if ( 0 != output . compare ( kPercentFormatTestData [ whichLine ] . string ) ) { error ( " percent ▁ format ( ) . . ▁ \n " + showDifference ( kPercentFormatTestData [ whichLine ] . string , output ) ) ; goto cleanupAndReturn ; } const int kNumberOfMessageTests = 3 ; UErrorCode statusToCheck ; UnicodeString patternToCheck ; Locale messageLocale ; Locale countryToCheck ; double currencyToCheck ; UnicodeString expected ; switch ( ( iteration + fOffset ) % kNumberOfMessageTests ) { default : case 0 : statusToCheck = U_FILE_ACCESS_ERROR ; patternToCheck = "0 : Someone ▁ from ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } " " ▁ error ▁ - ▁ { 1 } . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ " " { 3 , number , currency } . " ; messageLocale = Locale ( " en " , " US " ) ; countryToCheck = Locale ( " " , " HR " ) ; currencyToCheck = 8192.77 ; expected = "0 : Someone ▁ from ▁ Croatia ▁ is ▁ receiving ▁ a ▁ # 4 ▁ error ▁ - ▁ " " U _ FILE _ ACCESS _ ERROR . ▁ Their ▁ telephone ▁ call ▁ is ▁ costing ▁ $ 8,@@ 192.77 . " ; break ; case 1 : statusToCheck = U_IND@@ EX_OUTOFBO@@ UND@@ S_ERROR ; patternToCheck = "1 : A ▁ customer ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ { 3 , number , currency } . " ; messageLocale = Locale ( " de " , " DE @ currency = DEM " ) ; countryToCheck = Locale ( " " , " BF " ) ; currencyToCheck = 2.32 ; expected = CharsToUnicodeString ( "1 : A ▁ customer ▁ in ▁ Burk@@ ina ▁ Fas@@ o ▁ is ▁ receiving ▁ a ▁ # 8 ▁ error ▁ - ▁ U _ INDEX _ OUTOFBO@@ UNDS _ ERROR . ▁ " " Their ▁ telephone ▁ call ▁ is ▁ costing ▁ 2,@@ 32\\u00A@@ 0D@@ M . " ) ; break ; case 2 : statusToCheck = U_MEMORY_ALLOCATION_ERROR ; patternToCheck = "2 : user ▁ in ▁ { 2 } ▁ is ▁ receiving ▁ a ▁ # {0 } ▁ error ▁ - ▁ { 1 } . ▁ " " They ▁ insist ▁ they ▁ just ▁ spent ▁ { 3 , number , currency } ▁ " " on ▁ memory . " ; messageLocale = Locale ( " de " , " AT @ currency = ATS " ) ; countryToCheck = Locale ( " " , " US " ) ; currencyToCheck = 4019@@ 3.12 ; expected = CharsToUnicodeString ( "2 : user ▁ in ▁ Verein@@ igte ▁ Staaten ▁ is ▁ receiving ▁ a ▁ # 7 ▁ error " " ▁ - ▁ U _ MEMORY _ ALLOCATION _ ERROR . ▁ They ▁ insist ▁ they ▁ just ▁ spent " " ▁ \\u00f6@@ S\\u00A@@ 040@@ .19@@ 3,@@ 12 ▁ on ▁ memory . " ) ; break ; } UnicodeString result ; UErrorCode status = U_ZERO_ERROR ; formatErrorMessage ( status , patternToCheck , messageLocale , statusToCheck , countryToCheck , currencyToCheck , result ) ; if ( U_FAILURE ( status ) ) { UnicodeString tmp ( u_errorName ( status ) ) ; error ( " Failure ▁ on ▁ message ▁ format , ▁ pattern = " + patternToCheck + " , ▁ error ▁ = ▁ " + tmp ) ; goto cleanupAndReturn ; } if ( result != expected ) { error ( " Patter@@ nFormat : ▁ \n " + showDifference ( expected , result ) ) ; goto cleanupAndReturn ; } UnicodeString appendErr ; if ( ! fTSF -> doStuff ( fNum , appendErr , status ) ) { error ( appendErr ) ; goto cleanupAndReturn ; } } cleanupAndReturn : fTraceInfo = 2 ; } private : int32_t fOffset ; } ; void MultithreadTest :: TestThreadedIntl ( ) { int i ; UnicodeString theErr ; UBool haveDisplayedInfo [ kFormatThreadThreads ] ; static const int32_t PATIENCE_SECONDS = 45 ; UErrorCode threadSafeErr = U_ZERO_ERROR ; ThreadSafeFormatSharedData sharedData ( threadSafeErr ) ; assertSuccess ( " initializing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; logln ( " Spawning : ▁ % d ▁ threads ▁ * ▁ % d ▁ iterations ▁ each . " , kFormatThreadThreads , kFormatThreadIterations ) ; LocalArray < FormatThreadTest > tests ( new FormatThreadTest [ kFormatThreadThreads ] ) ; for ( int32_t j = 0 ; j < kFormatThreadThreads ; j ++ ) { tests [ j ] . fNum = j ; int32_t threadStatus = tests [ j ] . start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; return ; } haveDisplayedInfo [ j ] = FALSE ; } UBool stillRunning ; UDate startTime , endTime ; startTime = Calendar :: getNow ( ) ; double lastComplaint = 0 ; do { stillRunning = FALSE ; endTime = Calendar :: getNow ( ) ; double elapsedSeconds = ( ( int32_t ) ( endTime - startTime ) / U_MILLIS_PER_SECOND ) ; if ( elapsedSeconds > PATIENCE_SECONDS ) { errln ( " Patience ▁ exceeded . ▁ Test ▁ is ▁ taking ▁ too ▁ long . " ) ; return ; } else if ( ( elapsedSeconds - lastComplaint ) > 2.0 ) { infoln ( " % .1f ▁ seconds ▁ elapsed ▁ ( still ▁ waiting . . ) " , elapsedSeconds ) ; lastComplaint = elapsedSeconds ; } SimpleThread :: sleep ( 1 ) ; for ( i = 0 ; i < kFormatThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) ) { stillRunning = TRUE ; } else if ( haveDisplayedInfo [ i ] == FALSE ) { logln ( " Thread ▁ # ▁ % d ▁ is ▁ complete . . " , i ) ; if ( tests [ i ] . getError ( theErr ) ) { dataerrln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; SimpleThread :: errorFunc ( ) ; } haveDisplayedInfo [ i ] = TRUE ; } } } while ( stillRunning ) ; assertSuccess ( " finalizing ▁ ThreadSafeFormat " , threadSafeErr , TRUE ) ; } # endif # if ! UCONFIG_NO_COLLATION # define kCollatorThreadThreads 10 # define kCollatorThreadPatience kCollatorThreadThreads * 30 struct Line { UChar buff [ 25 ] ; int32_t buflen ; } ; static UBool skipLineBecauseOfBug ( const UChar * s , int32_t length ) { if ( length >= 3 && ( s [ 0 ] == 0xfb@@ 2 || s [ 0 ] == 0xfb@@ 3 ) && s [ 1 ] == 0x334 && ( s [ 2 ] == 0xf73 || s [ 2 ] == 0xf75 || s [ 2 ] == 0xf81 ) ) { return TRUE ; } return FALSE ; } static UCollation@@ Result normalizeResult ( int32_t result ) { return result < 0 ? UCOL_LESS : result == 0 ? UCOL_EQUAL : UCOL_GRE@@ ATER ; } class CollatorThreadTest : public ThreadWithStatus { private : const Collator * coll ; const Line * lines ; int32_t noLines ; UBool isAtLeastUCA62 ; public : CollatorThreadTest ( ) : ThreadWithStatus ( ) , coll ( NULL ) , lines ( NULL ) , noLines ( 0 ) , isAtLeastUCA62 ( TRUE ) { } ; void setCollator ( Collator * c , Line * l , int32_t nl , UBool atLeastUCA62 ) { coll = c ; lines = l ; noLines = nl ; isAtLeastUCA62 = atLeastUCA62 ; } virtual void run ( ) { uint8_t sk1 [ 1024 ] , sk2 [ 1024 ] ; uint8_t * oldSk = NULL , * newSk = sk1 ; int32_t oldLen = 0 ; int32_t prev = 0 ; int32_t i = 0 ; for ( i = 0 ; i < noLines ; i ++ ) { if ( lines [ i ] . buflen == 0 ) { continue ; } if ( skipLineBecauseOfBug ( lines [ i ] . buff , lines [ i ] . buflen ) ) { continue ; } int32_t resLen = coll -> getSort@@ Key ( lines [ i ] . buff , lines [ i ] . buflen , newSk , 1024 ) ; if ( oldSk != NULL ) { int32_t skres = strcmp ( ( char * ) oldSk , ( char * ) newSk ) ; int32_t cmpres = coll -> compare ( lines [ prev ] . buff , lines [ prev ] . buflen , lines [ i ] . buff , lines [ i ] . buflen ) ; int32_t cmpres2 = coll -> compare ( lines [ i ] . buff , lines [ i ] . buflen , lines [ prev ] . buff , lines [ prev ] . buflen ) ; if ( cmpres != - cmpres2 ) { error ( UnicodeString ( " Compare ▁ result ▁ not ▁ symmetr@@ ical ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } if ( cmpres != normalizeResult ( skres ) ) { error ( UnicodeString ( " Difference ▁ between ▁ coll - > compare ▁ and ▁ sortkey ▁ compare ▁ on ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } int32_t res = cmpres ; if ( res == 0 && ! isAtLeastUCA62 ) { res = u_strcmp@@ CodePoint@@ Order ( lines [ prev ] . buff , lines [ i ] . buff ) ; } if ( res > 0 ) { error ( UnicodeString ( " Line ▁ is ▁ not ▁ greater ▁ or ▁ equal ▁ than ▁ previous ▁ line , ▁ for ▁ line ▁ " ) + ( i + 1 ) ) ; break ; } } oldSk = newSk ; oldLen = resLen ; ( void ) oldLen ; prev = i ; newSk = ( newSk == sk1 ) ? sk2 : sk1 ; } } } ; void MultithreadTest :: TestCollators ( ) { UErrorCode status = U_ZERO_ERROR ; FILE * testFile = NULL ; char testDataPath [ 1024 ] ; strcpy ( testDataPath , IntlTest :: getSource@@ TestData ( status ) ) ; if ( U_FAILURE ( status ) ) { errln ( " ERROR : ▁ could ▁ not ▁ open ▁ test ▁ data ▁ % s " , u_errorName ( status ) ) ; return ; } strcat ( testDataPath , " Collation@@ Test _ " ) ; const char * type = " NON _ IGNORABLE " ; const char * ext = " . txt " ; if ( testFile ) { fclose ( testFile ) ; } char buffer [ 1024 ] ; strcpy ( buffer , testDataPath ) ; strcat ( buffer , type ) ; size_t bufLen = strlen ( buffer ) ; strcpy ( buffer + bufLen , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ SHOR@@ T " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { strcpy ( buffer + bufLen , " _ STUB " ) ; strcat ( buffer , ext ) ; testFile = fopen ( buffer , " rb " ) ; if ( testFile == 0 ) { * ( buffer + bufLen ) = 0 ; dataerrln ( " could ▁ not ▁ open ▁ any ▁ of ▁ the ▁ conformance ▁ test ▁ files , ▁ tried ▁ opening ▁ base ▁ % s " , buffer ) ; return ; } else { infoln ( " INFO : ▁ Working ▁ with ▁ the ▁ stub ▁ file . \n " " If ▁ you ▁ need ▁ the ▁ full ▁ conformance ▁ test , ▁ please \n " " download ▁ the ▁ appro@@ priate ▁ data ▁ files ▁ from : \n " " http : // source . icu - project . org / repos / icu / tools / trunk / unicod@@ etools / com / ibm / text / data / " ) ; } } } LocalArray < Line > lines ( new Line [ 200000 ] ) ; memset ( lines . getAlias ( ) , 0 , sizeof ( Line ) * 200000 ) ; int32_t lineNum = 0 ; UChar bufferU [ 1024 ] ; uint32_t first = 0 ; while ( fgets ( buffer , 1024 , testFile ) != NULL ) { if ( * buffer == 0 || buffer [ 0 ] == ' # ' ) { lines [ lineNum ] . buflen = 0 ; lines [ lineNum ] . buff [ 0 ] = 0 ; } else { int32_t buflen = u_parse@@ String ( buffer , bufferU , 1024 , & first , & status ) ; lines [ lineNum ] . buflen = buflen ; u_memcpy ( lines [ lineNum ] . buff , bufferU , buflen ) ; lines [ lineNum ] . buff [ buflen ] = 0 ; } lineNum ++ ; } fclose ( testFile ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Couldn ' t ▁ read ▁ the ▁ test ▁ file ! " ) ; return ; } UVersionInfo uniVersion ; static const UVersionInfo v62 = { 6 , 2 , 0 , 0 } ; u_getUnicode@@ Version ( uniVersion ) ; UBool isAtLeastUCA62 = uprv_memcmp ( uniVersion , v62 , 4 ) >= 0 ; LocalPointer < Collator > coll ( Collator :: createInstance ( Locale :: getRoot ( ) , status ) ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " Couldn ' t ▁ open ▁ UCA ▁ collator " ) ; return ; } coll -> setAttribute ( UCOL_NORM@@ ALIZATION_MODE , UCOL_ON , status ) ; coll -> setAttribute ( UCOL_CASE_@@ FIRST , UCOL_OFF , status ) ; coll -> setAttribute ( UCOL_CASE_@@ LEVEL , UCOL_OFF , status ) ; coll -> setAttribute ( UCO@@ L_STRENG@@ TH , isAtLeastUCA62 ? UCOL_IDENTICAL : UCOL_TERTIARY , status ) ; coll -> setAttribute ( UCOL_ALTER@@ NATE_@@ HANDLING , UCOL_NON_@@ IGNORABLE , status ) ; int32_t noSpawned = 0 ; int32_t spawnResult = 0 ; LocalArray < CollatorThreadTest > tests ( new CollatorThreadTest [ kCollatorThreadThreads ] ) ; logln ( UnicodeString ( " Spawning : ▁ " ) + kCollatorThreadThreads + " ▁ threads ▁ * ▁ " + kFormatThreadIterations + " ▁ iterations ▁ each . " ) ; int32_t j = 0 ; for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { tests [ j ] . setCollator ( coll . getAlias ( ) , lines . getAlias ( ) , lineNum , isAtLeastUCA62 ) ; } for ( j = 0 ; j < kCollatorThreadThreads ; j ++ ) { log ( " % i ▁ " , j ) ; spawnResult = tests [ j ] . start ( ) ; if ( spawnResult != 0 ) { infoln ( " THREAD ▁ INFO : ▁ Couldn ' t ▁ spawn ▁ more ▁ than ▁ % i ▁ threads " , noSpawned ) ; break ; } noSpawned ++ ; } logln ( " Spawned ▁ all " ) ; if ( noSpawned == 0 ) { errln ( " No ▁ threads ▁ could ▁ be ▁ spawned . " ) ; return ; } for ( int32_t patience = kCollatorThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; int32_t terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kCollatorThreadThreads ; i ++ ) { if ( tests [ i ] . isRunning ( ) == FALSE ) { completed ++ ; UnicodeString theErr ; if ( tests [ i ] . getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } logln ( " Completed ▁ % i ▁ tests " , completed ) ; if ( completed == noSpawned ) { logln ( " Done ! ▁ All ▁ % i ▁ tests ▁ are ▁ finished " , noSpawned ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; SimpleThread :: errorFunc ( ) ; } return ; } SimpleThread :: sleep ( 900 ) ; } errln ( " patience ▁ exceeded . ▁ " ) ; SimpleThread :: errorFunc ( ) ; } # endif const int kStringThreadIterations = 2500 ; const int kStringThreadThreads = 10 ; const int kStringThreadPatience = 120 ; class StringThreadTest2 : public ThreadWithStatus { public : int fNum ; int fTraceInfo ; const UnicodeString * fSharedString ; StringThreadTest2 ( const UnicodeString * sharedString , int num ) : ThreadWithStatus ( ) , fNum ( num ) , fTraceInfo ( 0 ) , fSharedString ( sharedString ) { } ; virtual void run ( ) { fTraceInfo = 1 ; int loopCount = 0 ; for ( loopCount = 0 ; loopCount < kStringThreadIterations ; loopCount ++ ) { if ( * fSharedString != " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) { error ( " Original ▁ string ▁ is ▁ corrupt . " ) ; break ; } UnicodeString s1 = * fSharedString ; s1 += " cat ▁ this " ; UnicodeString s2 ( s1 ) ; UnicodeString s3 = * fSharedString ; s2 = s3 ; s3 . truncate ( 12 ) ; s2 . truncate ( 0 ) ; } fTraceInfo = 2 ; } } ; void MultithreadTest :: TestString ( ) { int patience ; int terrs = 0 ; int j ; UnicodeString * testString = new UnicodeString ( " This ▁ is ▁ the ▁ original ▁ test ▁ string . " ) ; StringThreadTest2 * tests [ kStringThreadThreads ] ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { tests [ j ] = new StringThreadTest2 ( testString , j ) ; } logln ( UnicodeString ( " Spawning : ▁ " ) + kStringThreadThreads + " ▁ threads ▁ * ▁ " + kStringThreadIterations + " ▁ iterations ▁ each . " ) ; for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { int32_t threadStatus = tests [ j ] -> start ( ) ; if ( threadStatus != 0 ) { errln ( " System ▁ Error ▁ % d ▁ starting ▁ thread ▁ number ▁ % d . " , threadStatus , j ) ; SimpleThread :: errorFunc ( ) ; goto cleanupAndReturn ; } } for ( patience = kStringThreadPatience ; patience > 0 ; patience -- ) { logln ( " Waiting . . . " ) ; int32_t i ; terrs = 0 ; int32_t completed = 0 ; for ( i = 0 ; i < kStringThreadThreads ; i ++ ) { if ( tests [ i ] -> isRunning ( ) == FALSE ) { completed ++ ; logln ( UnicodeString ( " Test ▁ # " ) + i + " ▁ is ▁ complete . . ▁ " ) ; UnicodeString theErr ; if ( tests [ i ] -> getError ( theErr ) ) { terrs ++ ; errln ( UnicodeString ( " # " ) + i + " : ▁ " + theErr ) ; } } } if ( completed == kStringThreadThreads ) { logln ( " Done ! " ) ; if ( terrs ) { errln ( " There ▁ were ▁ errors . " ) ; } break ; } SimpleThread :: sleep ( 900 ) ; } if ( patience <= 0 ) { errln ( " patience ▁ exceeded . ▁ " ) ; terrs ++ ; } if ( terrs > 0 ) { SimpleThread :: errorFunc ( ) ; } cleanupAndReturn : if ( terrs == 0 ) { for ( j = 0 ; j < kStringThreadThreads ; j ++ ) { delete tests [ j ] ; } delete testString ; } } # if ! UCONFIG_NO_TRANSLITERATION class TxThread : public SimpleThread { private : Transliterator * fSharedTranslit ; public : UBool fSuccess ; TxThread ( Transliterator * tx ) : fSharedTranslit ( tx ) , fSuccess ( FALSE ) { } ; ~ TxThread ( ) ; void run ( ) ; } ; TxThread :: ~ TxThread ( ) { } void TxThread :: run ( ) { UnicodeString greekString ( " \\u03B4\\u03B9\\u03B@@ 1\\u03C@@ 6\\u03BF@@ \\u03C@@ 1\\u03B@@ 5\\u03C@@ 4\\u03B9\\u03B@@ A\\u03BF@@ \\u03CD\\u03C@@ 2" ) ; greekString = greekString . unescape ( ) ; fSharedTranslit -> transl@@ iterate ( greekString ) ; fSuccess = greekString [ 0 ] == 0x64 ; } # endif void MultithreadTest :: TestAnyTranslit ( ) { # if ! UCONFIG_NO_TRANSLITERATION UErrorCode status = U_ZERO_ERROR ; LocalPointer < Transliterator > tx ( Transliterator :: createInstance ( " Any - Latin " , UTRAN@@ S_FOR@@ WARD , status ) ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ status ▁ = ▁ % s " , __FILE__ , __LINE__ , u_errorName ( status ) ) ; return ; } TxThread * threads [ 4 ] ; int32_t i ; for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] = new TxThread ( tx . getAlias ( ) ) ; } for ( i = 0 ; i < 4 ; i ++ ) { threads [ i ] -> start ( ) ; } int32_t patience = 100 ; UBool success ; UBool someThreadRunning ; do { someThreadRunning = FALSE ; success = TRUE ; for ( i = 0 ; i < 4 ; i ++ ) { if ( threads [ i ] -> isRunning ( ) ) { someThreadRunning = TRUE ; SimpleThread :: sleep ( 10 ) ; break ; } else { if ( threads [ i ] -> fSuccess == FALSE ) { success = FALSE ; } } } } while ( someThreadRunning && -- patience > 0 ) ; if ( patience <= 0 ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ one ▁ or ▁ more ▁ threads ▁ did ▁ not ▁ complete . " , __FILE__ , __LINE__ ) ; } if ( success == FALSE ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ transl@@ iteration ▁ result ▁ incorrect . " , __FILE__ , __LINE__ ) ; } for ( i = 0 ; i < 4 ; i ++ ) { delete threads [ i ] ; } # endif } class CondThread : public SimpleThread { public : CondThread ( ) : fFinished ( false ) { } ; ~ CondThread ( ) { } ; void run ( ) ; bool fFinished ; } ; static UMutex gCTMutex = U_MUTEX_INITIALIZER ; static UConditionVar gCTConditionVar = U_CONDITION_@@ INITIALIZER ; int gConditionTestOne = 1 ; int gStartedThreads ; int gFinishedThreads ; static const int NUMTHREADS = 10 ; static MultithreadTest * gThisTest = NULL ; void CondThread :: run ( ) { umtx_lock ( & gCTMutex ) ; gStartedThreads += gConditionTestOne ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gStartedThreads < NUMTHREADS ) { if ( gFinishedThreads != 0 ) { gThisTest -> errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ gStartedThreads ▁ = ▁ % d , ▁ gFinishedThreads ▁ = ▁ % d " , __FILE__ , __LINE__ , gStartedThreads , gFinishedThreads ) ; } umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } gFinishedThreads += gConditionTestOne ; fFinished = true ; umtx_condBroadcast ( & gCTConditionVar ) ; while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestConditionVariables ( ) { gThisTest = this ; gStartedThreads = 0 ; gFinishedThreads = 0 ; int i ; umtx_lock ( & gCTMutex ) ; CondThread * threads [ NUMTHREADS ] ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { threads [ i ] = new CondThread ; threads [ i ] -> start ( ) ; } while ( gStartedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } while ( gFinishedThreads < NUMTHREADS ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } umtx_unlock ( & gCTMutex ) ; for ( i = 0 ; i < NUMTHREADS ; ++ i ) { if ( ! threads [ i ] -> fFinished ) { errln ( " File ▁ % s , ▁ Line ▁ % d : ▁ Error , ▁ threads [ % d ] - > fFinished ▁ = = ▁ false " , __FILE__ , __LINE__ , i ) ; } delete threads [ i ] ; } } static const char * gCacheLocales [ ] = { " en _ US " , " en _ GB " , " fr _ FR " , " fr " } ; static int32_t gObjectsCreated = 0 ; static const int32_t CACHE_LOAD = 3 ; class UCTMultiThreadItem : public SharedObject { public : char * value ; UCTMultiThreadItem ( const char * x ) : value ( NULL ) { value = uprv_strdup ( x ) ; } virtual ~ UCTMultiThreadItem ( ) { uprv_free ( value ) ; } } ; U_NAMESPACE_BEGIN template < > U_EXPORT const UCTMultiThreadItem * LocaleCacheKey < UCTMultiThreadItem > :: createObject ( const void * , UErrorCode & ) const { umtx_lock ( & gCTMutex ) ; if ( gObjectsCreated != 0 ) { gThisTest -> errln ( " Expected ▁ no ▁ objects ▁ to ▁ be ▁ created ▁ yet . " ) ; } umtx_unlock ( & gCTMutex ) ; SimpleThread :: sleep ( 1000 ) ; umtx_lock ( & gCTMutex ) ; ++ gObjectsCreated ; umtx_unlock ( & gCTMutex ) ; UCTMultiThreadItem * result = new UCTMultiThreadItem ( fLoc . getName ( ) ) ; result -> addRef ( ) ; return result ; } U_NAMESPACE_END class UnifiedCacheThread : public SimpleThread { public : UnifiedCacheThread ( const char * loc ) : fLoc ( loc ) { } ; ~ UnifiedCacheThread ( ) { } ; void run ( ) ; const char * fLoc ; } ; void UnifiedCacheThread :: run ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( status == U_ZERO_ERROR ) ; const UCTMultiThreadItem * item = NULL ; cache -> get ( LocaleCacheKey < UCTMultiThreadItem > ( fLoc ) , item , status ) ; U_ASSERT ( item != NULL ) ; if ( uprv_strcmp ( fLoc , item -> value ) ) { gThisTest -> errln ( " Expected ▁ % s , ▁ got ▁ % s " , fLoc , item -> value ) ; } item -> removeRef ( ) ; umtx_lock ( & gCTMutex ) ; ++ gFinishedThreads ; umtx_condBroadcast ( & gCTConditionVar ) ; umtx_unlock ( & gCTMutex ) ; } void MultithreadTest :: TestUnifiedCache ( ) { UErrorCode status = U_ZERO_ERROR ; const UnifiedCache * cache = UnifiedCache :: getInstance ( status ) ; U_ASSERT ( cache != NULL ) ; cache -> flush ( ) ; gThisTest = this ; gFinishedThreads = 0 ; gObjectsCreated = 0 ; UnifiedCacheThread * threads [ CACHE_LOAD ] [ UPRV_LENGTHOF ( gCacheLocales ) ] ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { threads [ i ] [ j ] = new UnifiedCacheThread ( gCacheLocales [ j ] ) ; threads [ i ] [ j ] -> start ( ) ; } } umtx_lock ( & gCTMutex ) ; while ( gFinishedThreads < CACHE_LOAD * UPRV_LENGTHOF ( gCacheLocales ) ) { umtx_condWait ( & gCTConditionVar , & gCTMutex ) ; } assert@@ Equals ( " Objects ▁ created " , UPRV_LENGTHOF ( gCacheLocales ) , gObjectsCreated ) ; umtx_unlock ( & gCTMutex ) ; for ( int32_t i = 0 ; i < CACHE_LOAD ; ++ i ) { for ( int32_t j = 0 ; j < UPRV_LENGTHOF ( gCacheLocales ) ; ++ j ) { delete threads [ i ] [ j ] ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="dev@@ -il@@ y/ILoveYou@@ Coins/tree/master/src/rpcwallet@@ .cpp"> # include < boost / assign / list_of . hpp > # include " wallet . h " # include " walletdb . h " # include " bitcoinrpc . h " # include " init . h " # include " base58 . h " using namespace std ; using namespace boost ; using namespace boost :: assign ; using namespace json_spirit ; int64 nWalletUnlockTime ; static CCriticalSection cs_nWalletUnlockTime ; std :: string HelpRequiringPassphrase ( ) { return pwalletMain && pwalletMain -> IsCrypted ( ) ? " \n requires ▁ wallet ▁ passphrase ▁ to ▁ be ▁ set ▁ with ▁ walletpassphrase ▁ first " : " " ; } void EnsureWalletIsUnlocked ( ) { if ( pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_UNLOCK_@@ NEEDED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ passphrase ▁ with ▁ walletpassphrase ▁ first . " ) ; if ( fWalletUnlockStakingOnly ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKE@@ D_ST@@ AKING_@@ ONLY , " Error : ▁ Wallet ▁ is ▁ unlocked ▁ for ▁ staking ▁ only . " ) ; } void WalletTxToJSON ( const CWalletTx & wtx , Object & entry ) { int confirms = wtx . GetDepthInMainChain ( ) ; entry . push_back ( Pair ( " confirmations " , confirms ) ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confirms > 0 ) { entry . push_back ( Pair ( " blockhash " , wtx . hashBlock . GetHex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " blocktime " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hashBlock ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " txid " , wtx . GetHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " normtxid " , wtx . GetNormal@@ ized@@ Hash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . GetTxTime ( ) ) ) ; entry . push_back ( Pair ( " timereceiv@@ ed " , ( boost :: int64_t ) wtx . nTimeReceived ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . mapValue ) entry . push_back ( Pair ( item . first , item . second ) ) ; } string AccountFromValue ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JSONRPCError ( RPC_WALLET_INVALID_ACCOUNT_@@ NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; } Value getinfo ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 0 ) throw runtime_error ( " getinfo \n " " Returns ▁ an ▁ object ▁ containing ▁ various ▁ state ▁ info . " ) ; proxy@@ Type proxy ; GetProxy ( NET_IP@@ V4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " proto@@ colversion " , ( int ) PROTOCOL_VERSION ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " walletversion " , pwalletMain -> GetVersion ( ) ) ) ; obj . push_back ( Pair ( " balance " , ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ) ) ; obj . push_back ( Pair ( " unconfirmedbalance " , ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ) ) ; obj . push_back ( Pair ( " stake " , ValueFromAmount ( pwalletMain -> GetStake ( ) ) ) ) ; obj . push_back ( Pair ( " locked " , pwalletMain -> IsLocked ( ) ) ) ; obj . push_back ( Pair ( " encrypted " , pwalletMain -> IsCrypted ( ) ) ) ; } obj . push_back ( Pair ( " blocks " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " timeoffset " , ( boost :: int64_t ) GetTimeOffset ( ) ) ) ; obj . push_back ( Pair ( " money@@ supply " , ValueFromAmount ( pindexBest -> nMoney@@ Supply ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) vNodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToString@@ IPPort ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " difficulty " , ( double ) GetDifficulty ( ) ) ) ; obj . push_back ( Pair ( " testnet " , fTestNet ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " keypoolo@@ ldest " , ( boost :: int64_t ) pwalletMain -> GetOldest@@ KeyPool@@ Time ( ) ) ) ; obj . push_back ( Pair ( " keypool@@ size " , ( int ) pwalletMain -> GetKeyPoolSize ( ) ) ) ; } obj . push_back ( Pair ( " paytxfee " , ValueFromAmount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " mininput " , ValueFromAmount ( nMinimumInputValue ) ) ) ; if ( pwalletMain && pwalletMain -> IsCrypted ( ) ) obj . push_back ( Pair ( " unlocked _ until " , ( boost :: int64_t ) nWalletUnlockTime ) ) ; obj . push_back ( Pair ( " errors " , GetWar@@ nings ( " statusbar " ) ) ) ; return obj ; } Value getnewaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " getnewaddress ▁ [ account ] \n " " Returns ▁ a ▁ new ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( recomm@@ ended ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ payments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ credited ▁ to ▁ [ account ] . " ) ; string strAccount ; if ( params . size ( ) > 0 ) strAccount = AccountFromValue ( params [ 0 ] ) ; if ( ! pwalletMain -> IsLocked ( ) ) pwalletMain -> TopUpKeyPool ( ) ; CPubKey newKey ; if ( ! pwalletMain -> GetKeyFromPool ( newKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; CKeyID keyID = newKey . GetID ( ) ; pwalletMain -> SetAddressBookName ( keyID , strAccount ) ; return CBitcoinAddress ( keyID ) . ToString ( ) ; } CBitcoinAddress GetAccountAddress ( string strAccount , bool bForceNew = false ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; CAccount account ; walletdb . ReadAccount ( strAccount , account ) ; bool bKeyUsed = false ; if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . SetDestination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) bKeyUsed = true ; } } if ( ! account . vchPubKey . IsValid ( ) || bForceNew || bKeyUsed ) { if ( ! pwalletMain -> GetKeyFromPool ( account . vchPubKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; pwalletMain -> SetAddressBookName ( account . vchPubKey . GetID ( ) , strAccount ) ; walletdb . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; } Value getaccountaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccountaddress ▁ < account > \n " " Returns ▁ the ▁ current ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments ▁ to ▁ this ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Value ret ; ret = GetAccountAddress ( strAccount ) . ToString ( ) ; return ret ; } Value setaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " setaccount ▁ < iloveyoucoinsaddress > ▁ < account > \n " " Sets ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = AccountFromValue ( params [ 1 ] ) ; if ( pwalletMain -> mapAddressBook . count ( address . Get ( ) ) ) { string strOldAccount = pwalletMain -> mapAddressBook [ address . Get ( ) ] ; if ( address == GetAccountAddress ( strOldAccount ) ) GetAccountAddress ( strOldAccount , true ) ; } pwalletMain -> SetAddressBookName ( address . Get ( ) , strAccount ) ; return Value :: null ; } Value getaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccount ▁ < iloveyoucoinsaddress > \n " " Returns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pwalletMain -> mapAddressBook . find ( address . Get ( ) ) ; if ( mi != pwalletMain -> mapAddressBook . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; } Value getaddressesbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaddressesbyaccount ▁ < account > \n " " Returns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ given ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; } Value setmininput ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " setmininput ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" ) ; int64 nAmount = 0 ; if ( params [ 0 ] . get_real ( ) != 0.0 ) nAmount = AmountFromValue ( params [ 0 ] ) ; nMinimumInputValue = nAmount ; return true ; } Value sendtoaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendtoaddress ▁ < iloveyoucoinsaddress > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null_type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 3 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; } Value listaddressgroupings ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listaddressgroupings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ which ▁ have ▁ had ▁ their ▁ common ▁ ownership \n " " made ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ resulting ▁ change \n " " in ▁ past ▁ transactions " ) ; Array jsonGroupings ; map < CTxDestination , int64 > balances = pwalletMain -> GetAddress@@ Balances ( ) ; BOOST_FOREACH ( set < CTxDestination > grouping , pwalletMain -> GetAddress@@ Groupings ( ) ) { Array jsonGrouping ; BOOST_FOREACH ( CTxDestination address , grouping ) { Array addressInfo ; addressInfo . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; addressInfo . push_back ( ValueFromAmount ( balances [ address ] ) ) ; { LOCK ( pwalletMain -> cs_wallet ) ; if ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) != pwalletMain -> mapAddressBook . end ( ) ) addressInfo . push_back ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } jsonGrouping . push_back ( addressInfo ) ; } jsonGroupings . push_back ( jsonGrouping ) ; } return jsonGroupings ; } Value signmessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 2 ) throw runtime_error ( " signmessage ▁ < iloveyoucoinsaddress > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; EnsureWalletIsUnlocked ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strMessage = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; CKey key ; if ( ! pwalletMain -> GetKey ( keyID , key ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Private ▁ key ▁ not ▁ available " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; vector < unsigned char > vchSig ; if ( ! key . SignCompact ( ss . GetHash ( ) , vchSig ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Sign ▁ failed " ) ; return Encode@@ Base64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; } Value verifymessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 3 ) throw runtime_error ( " verifymessage ▁ < iloveyoucoinsaddress > ▁ < signature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strSign = params [ 1 ] . get_str ( ) ; string strMessage = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; bool fInvalid = false ; vector < unsigned char > vchSig = Decode@@ Base64 ( strSign . c_str ( ) , & fInvalid ) ; if ( fInvalid ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Mal@@ formed ▁ base64 ▁ encoding " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; CPubKey pubkey ; if ( ! pubkey . Reco@@ verCompact ( ss . GetHash ( ) , vchSig ) ) return false ; return ( pubkey . GetID ( ) == keyID ) ; } Value getreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaddress ▁ < iloveyoucoinsaddress > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < iloveyoucoinsaddress > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; scriptPubKey . SetDestination ( address . Get ( ) ) ; if ( ! IsMine ( * pwalletMain , scriptPubKey ) ) return ( double ) 0.0 ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } return ValueFromAmount ( nAmount ) ; } void GetAccountAddresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pwalletMain -> mapAddressBook ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } } Value getreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaccount ▁ < account > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; set < CTxDestination > setAddress ; GetAccountAddresses ( strAccount , setAddress ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( txout . scriptPubKey , address ) && IsMine ( * pwalletMain , address ) && setAddress . count ( address ) ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } } return ( double ) nAmount / ( double ) COIN ; } int64 GetAccountBalance ( CWalletDB & walletdb , const string & strAccount , int nMinDepth ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsFinal ( ) ) continue ; int64 nReceived , nSent , nFee ; wtx . GetAccountAmounts ( strAccount , nReceived , nSent , nFee ) ; if ( nReceived != 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) nBalance += nReceived ; nBalance -= nSent + nFee ; } nBalance += walletdb . GetAccountCreditDebit ( strAccount ) ; return nBalance ; } int64 GetAccountBalance ( const string & strAccount , int nMinDepth ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; return GetAccountBalance ( walletdb , strAccount , nMinDepth ) ; } Value getbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getbalance ▁ [ account ] ▁ [ minconf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ balance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ balance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirmed ( ) ) continue ; int64 allFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , allFee , strSentAccount ) ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) nBalance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listSent ) nBalance -= r . second ; nBalance -= allFee ; } return ValueFromAmount ( nBalance ) ; } string strAccount = AccountFromValue ( params [ 0 ] ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; return ValueFromAmount ( nBalance ) ; } Value getunconfirmedbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " getunconfirmedbalance \n " " Returns ▁ the ▁ server ' s ▁ total ▁ unconfirmed ▁ balance \n " ) ; return ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ; } Value movec@@ md ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < fromaccount > ▁ < toaccount > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ another . " ) ; string strFrom = AccountFromValue ( params [ 0 ] ) ; string strTo = AccountFromValue ( params [ 1 ] ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) ( void ) params [ 3 ] . get_int ( ) ; string strComment ; if ( params . size ( ) > 4 ) strComment = params [ 4 ] . get_str ( ) ; CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; if ( ! walletdb . Txn@@ Begin ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; int64 nNow = GetAdjust@@ edTime ( ) ; CAccountingEntry debit ; debit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; debit . strAccount = strFrom ; debit . nCreditDebit = - nAmount ; debit . nTime = nNow ; debit . strOtherAccount = strTo ; debit . strComment = strComment ; walletdb . WriteAccountingEntry ( debit ) ; CAccountingEntry credit ; credit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; credit . strAccount = strTo ; credit . nCreditDebit = nAmount ; credit . nTime = nNow ; credit . strOtherAccount = strFrom ; credit . strComment = strComment ; walletdb . WriteAccountingEntry ( credit ) ; if ( ! walletdb . Txn@@ Commit ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; return true ; } Value sendfrom ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " sendfrom ▁ < fromaccount > ▁ < toiloveyoucoinsaddress > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; int nMinDepth = 1 ; if ( params . size ( ) > 3 ) nMinDepth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null_type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null_type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 5 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( nAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; } Value sendmany ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendmany ▁ < fromaccount > ▁ { address : amount , . . . } ▁ [ minconf = 1 ] ▁ [ comment ] \n " " amounts ▁ are ▁ double - precision ▁ floating ▁ point ▁ numbers " + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Object sendTo = params [ 1 ] . get_obj ( ) ; int nMinDepth = 1 ; if ( params . size ( ) > 2 ) nMinDepth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vecSend ; int64 totalAmount = 0 ; BOOST_FOREACH ( const Pair & s , sendTo ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , string ( " Invalid ▁ ILoveYouCoins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JSONRPCError ( RPC_INVALID_PARAMETER , string ( " Invalid ▁ parameter , ▁ duplic@@ ated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . SetDestination ( address . Get ( ) ) ; int64 nAmount = AmountFromValue ( s . value_ ) ; totalAmount += nAmount ; vecSend . push_back ( make_pair ( scriptPubKey , nAmount ) ) ; } EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( totalAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; CReserve@@ Key keyChange ( pwalletMain ) ; int64 nFeeRequired = 0 ; string strFailReason ; bool fCreated = pwalletMain -> CreateTransaction ( vecSend , wtx , keyChange , nFeeRequired , strFailReason ) ; if ( ! fCreated ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , strFailReason ) ; if ( ! pwalletMain -> Commit@@ Transaction ( wtx , keyChange ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Transaction ▁ commit ▁ failed " ) ; return wtx . GetHash ( ) . GetHex ( ) ; } static CScript _createmultisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; if ( nRequired < 1 ) throw runtime_error ( " a ▁ multisignature ▁ address ▁ must ▁ require ▁ at ▁ least ▁ one ▁ key ▁ to ▁ redeem " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ supplied ▁ " " ( got ▁ % " PR@@ Iszu " ▁ keys , ▁ but ▁ need ▁ at ▁ least ▁ % d ▁ to ▁ redeem ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CPubKey > pubkeys ; pubkeys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; CBitcoinAddress address ( ks ) ; if ( pwalletMain && address . IsValid ( ) ) { CKeyID keyID ; if ( ! address . GetKeyID ( keyID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ refer ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CPubKey vchPubKey ; if ( ! pwalletMain -> GetPubKey ( keyID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else if ( IsHex ( ks ) ) { CPubKey vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . SetMulti@@ sig ( nRequired , pubkeys ) ; return result ; } Value addmultisigaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ nrequired - to - sign ▁ multisignature ▁ address ▁ to ▁ the ▁ wallet\ " \n " " each ▁ key ▁ is ▁ a ▁ ILoveYouCoins ▁ address ▁ or ▁ hex - encoded ▁ public ▁ key \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = AccountFromValue ( params [ 2 ] ) ; CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; pwalletMain -> AddCScript ( inner ) ; pwalletMain -> SetAddressBookName ( innerID , strAccount ) ; return CBitcoinAddress ( innerID ) . ToString ( ) ; } Value createmultisig ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " createmultisig ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > \n " " Creates ▁ a ▁ multi - signature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \n " " with ▁ keys : \n " " address ▁ : ▁ iloveyoucoins ▁ address \n " " redeemScript ▁ : ▁ hex - encoded ▁ rede@@ mpt@@ ion ▁ script " ; throw runtime_error ( msg ) ; } CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; CBitcoinAddress address ( innerID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " redeemScript " , HexStr ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct tallyitem { int64 nAmount ; int nConf ; vector < uint256 > txids ; tallyitem ( ) { nAmount = 0 ; nConf = std :: numeric_limits < int > :: max ( ) ; } } ; Value ListReceived ( const Array & params , bool fByAccounts ) { int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; bool fIncludeEmpty = false ; if ( params . size ( ) > 1 ) fIncludeEmpty = params [ 1 ] . get_bool ( ) ; map < CBitcoinAddress , tallyitem > mapTally ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; int nDepth = wtx . GetDepthInMainChain ( ) ; if ( nDepth < nMinDepth ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( txout . scriptPubKey , address ) || ! IsMine ( * pwalletMain , address ) ) continue ; tallyitem & item = mapTally [ address ] ; item . nAmount += txout . nValue ; item . nConf = min ( item . nConf , nDepth ) ; item . txids . push_back ( wtx . GetHash ( ) ) ; } } Array ret ; map < string , tallyitem > mapAccountTally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , tallyitem > :: iterator it = mapTally . find ( address ) ; if ( it == mapTally . end ( ) && ! fIncludeEmpty ) continue ; int64 nAmount = 0 ; int nConf = std :: numeric_limits < int > :: max ( ) ; if ( it != mapTally . end ( ) ) { nAmount = ( * it ) . second . nAmount ; nConf = ( * it ) . second . nConf ; } if ( fByAccounts ) { tallyitem & item = mapAccountTally [ strAccount ] ; item . nAmount += nAmount ; item . nConf = min ( item . nConf , nConf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; Array transactions ; if ( it != mapTally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . txids ) { transactions . push_back ( item . GetHex ( ) ) ; } } obj . push_back ( Pair ( " txids " , transactions ) ) ; ret . push_back ( obj ) ; } } if ( fByAccounts ) { for ( map < string , tallyitem > :: iterator it = mapAccountTally . begin ( ) ; it != mapAccountTally . end ( ) ; ++ it ) { int64 nAmount = ( * it ) . second . nAmount ; int nConf = ( * it ) . second . nConf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value listreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaddress ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ addresses ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address\ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included \n " " ▁ ▁ \ " txids\ " ▁ : ▁ list ▁ of ▁ transactions ▁ with ▁ outputs ▁ to ▁ the ▁ address \n " ) ; return ListReceived ( params , false ) ; } Value listreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaccount ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ accounts ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included " ) ; return ListReceived ( params , true ) ; } static void MaybePushAddress ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void ListTransactions ( const CWalletTx & wtx , const string & strAccount , int nMinDepth , bool fLong , Array & ret ) { int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( ! wtx . IsCoinStake ( ) && ( ! listSent . empty ( ) || nFee != 0 ) && ( fAllAccounts || strAccount == strSentAccount ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) { Object entry ; entry . push_back ( Pair ( " account " , strSentAccount ) ) ; MaybePushAddress ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fee " , ValueFromAmount ( - nFee ) ) ) ; if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } } if ( listReceived . size ( ) > 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) { string account ; if ( pwalletMain -> mapAddressBook . count ( r . first ) ) account = pwalletMain -> mapAddressBook [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; MaybePushAddress ( entry , r . first ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) { if ( wtx . GetDepthInMainChain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orph@@ an " ) ) ; else if ( wtx . GetBlocksToMaturity ( ) > 0 ) entry . push_back ( Pair ( " category " , " immature " ) ) ; else if ( wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " category " , " stake " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " amount " , ValueFromAmount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , ValueFromAmount ( - nFee ) ) ) ; stop = true ; } if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void AcentryToJSON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " otheraccount " , acentry . strOtherAccount ) ) ; entry . push_back ( Pair ( " comment " , acentry . strComment ) ) ; ret . push_back ( entry ) ; } } Value listtransactions ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 3 ) throw runtime_error ( " listtransactions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \n " " Returns ▁ up ▁ to ▁ [ count ] ▁ most ▁ recent ▁ transactions ▁ skipp@@ ing ▁ the ▁ first ▁ [ from ] ▁ transactions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int nCount = 10 ; if ( params . size ( ) > 1 ) nCount = params [ 1 ] . get_int ( ) ; int nFrom = 0 ; if ( params . size ( ) > 2 ) nFrom = params [ 2 ] . get_int ( ) ; if ( nCount < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ count " ) ; if ( nFrom < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > acentries ; CWallet :: TxItems txOrdered = pwalletMain -> OrderedTxItems ( acentries , strAccount ) ; for ( CWallet :: TxItems :: reverse_iterator it = txOrdered . rbegin ( ) ; it != txOrdered . rend ( ) ; ++ it ) { CWalletTx * const pwtx = ( * it ) . second . first ; if ( pwtx != 0 ) ListTransactions ( * pwtx , strAccount , 0 , true , ret ) ; CAccountingEntry * const pacentry = ( * it ) . second . second ; if ( pacentry != 0 ) AcentryToJSON ( * pacentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( nCount + nFrom ) ) break ; } if ( nFrom > ( int ) ret . size ( ) ) nFrom = ret . size ( ) ; if ( ( nFrom + nCount ) > ( int ) ret . size ( ) ) nCount = ret . size ( ) - nFrom ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , nFrom ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , nFrom + nCount ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: reverse ( ret . begin ( ) , ret . end ( ) ) ; return ret ; } Value listaccounts ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " listaccounts ▁ [ minconf = 1 ] \n " " Returns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ balances ▁ as ▁ values . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; map < string , int64 > mapAccountBalances ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pwalletMain -> mapAddressBook ) { if ( IsMine ( * pwalletMain , entry . first ) ) mapAccountBalances [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; mapAccountBalances [ strSentAccount ] -= nFee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) mapAccountBalances [ strSentAccount ] -= s . second ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) if ( pwalletMain -> mapAddressBook . count ( r . first ) ) mapAccountBalances [ pwalletMain -> mapAddressBook [ r . first ] ] += r . second ; else mapAccountBalances [ " " ] += r . second ; } } list < CAccountingEntry > acentries ; CWalletDB ( pwalletMain -> strWalletFile ) . ListAccountCreditDebit ( " * " , acentries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , acentries ) mapAccountBalances [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & accountBalance , mapAccountBalances ) { ret . push_back ( Pair ( accountBalance . first , ValueFromAmount ( accountBalance . second ) ) ) ; } return ret ; } Value listsinceblock ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listsinceblock ▁ [ blockhash ] ▁ [ target - confirmations ] \n " " Get ▁ all ▁ transactions ▁ in ▁ blocks ▁ since ▁ block ▁ [ blockhash ] , ▁ or ▁ all ▁ transactions ▁ if ▁ omit@@ ted " ) ; CBlockIndex * pindex = NULL ; int target_confirms = 1 ; if ( params . size ( ) > 0 ) { uint256 blockId = 0 ; blockId . SetHex ( params [ 0 ] . get_str ( ) ) ; pindex = CBlock@@ Locator ( blockId ) . GetBlockIndex ( ) ; } if ( params . size ( ) > 1 ) { target_confirms = params [ 1 ] . get_int ( ) ; if ( target_confirms < 1 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array transactions ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . GetDepthInMainChain ( ) < depth ) ListTransactions ( tx , " * " , 0 , true , transactions ) ; } uint256 lastblock ; if ( target_confirms == 1 ) { lastblock = hashBestChain ; } else { int target_height = pindexBest -> nHeight + 1 - target_confirms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > target_height ; block = block -> pprev ) { } lastblock = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " transactions " , transactions ) ) ; ret . push_back ( Pair ( " lastblock " , lastblock . GetHex ( ) ) ) ; return ret ; } Value gettransaction ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " gettransaction ▁ < txid > \n " " Get ▁ detailed ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < txid > " ) ; uint256 hash ; hash . SetHex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pwalletMain -> mapWallet . count ( hash ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pwalletMain -> mapWallet [ hash ] ; int64 nCredit = wtx . GetCredit ( ) ; int64 nDebit = wtx . GetDebit ( ) ; int64 nNet = nCredit - nDebit ; int64 nFee = ( wtx . IsFromMe ( ) ? wtx . GetValueOut ( ) - nDebit : 0 ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( nNet - nFee ) ) ) ; if ( wtx . IsFromMe ( ) ) entry . push_back ( Pair ( " fee " , ValueFromAmount ( nFee ) ) ) ; WalletTxToJSON ( wtx , entry ) ; Array details ; ListTransactions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value backupwallet ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " backupwallet ▁ < destination > \n " " Safely ▁ copies ▁ wallet . dat ▁ to ▁ destination , ▁ which ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pwalletMain , strDest ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error : ▁ Wallet ▁ backup ▁ failed ! " ) ; return Value :: null ; } Value keypoolrefill ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " keypoolrefill \n " " Fills ▁ the ▁ keypool . " + HelpRequiringPassphrase ( ) ) ; EnsureWalletIsUnlocked ( ) ; pwalletMain -> TopUpKeyPool ( ) ; if ( pwalletMain -> GetKeyPoolSize ( ) < GetArg ( " - keypool " , 100 ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error ▁ refreshing ▁ keypool . " ) ; return Value :: null ; } void ThreadTopUpKeyPool ( void * parg ) { RenameThread ( " iloveyoucoins - key - top " ) ; pwalletMain -> TopUpKeyPool ( ) ; } void ThreadCleanWalletPassphrase ( void * parg ) { RenameThread ( " iloveyoucoins - lock - wa " ) ; int64 nMyWakeTime = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; if ( nWalletUnlockTime == 0 ) { nWalletUnlockTime = nMyWakeTime ; do { if ( nWalletUnlockTime == 0 ) break ; int64 nToSleep = nWalletUnlockTime - GetTimeMillis ( ) ; if ( nToSleep <= 0 ) break ; LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; MilliSleep ( nToSleep ) ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; } while ( 1 ) ; if ( nWalletUnlockTime ) { nWalletUnlockTime = 0 ; pwalletMain -> Lock ( ) ; } } else { if ( nWalletUnlockTime < nMyWakeTime ) nWalletUnlockTime = nMyWakeTime ; } LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; delete ( int64 * ) parg ; } Value walletpassphrase ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > ▁ [ stakingonly ] \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \n " " if ▁ [ stakingonly ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ disable@@ d . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrase ▁ was ▁ called . " ) ; if ( ! pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKE@@ D , " Error : ▁ Wallet ▁ is ▁ already ▁ unlocked . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) > 0 ) { if ( ! pwalletMain -> Unlock ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > \n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; NewThread ( ThreadTopUpKeyPool , NULL ) ; int64 * pnSleepTime = new int64 ( params [ 1 ] . get_int64 ( ) ) ; NewThread ( ThreadCleanWalletPassphrase , pnSleepTime ) ; if ( params . size ( ) > 2 ) fWalletUnlockStakingOnly = params [ 2 ] . get_bool ( ) ; else fWalletUnlockStakingOnly = false ; return Value :: null ; } Value walletpassphrasechange ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 2 ) ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrasechange ▁ was ▁ called . " ) ; SecureString strOldWalletPass ; strOldWalletPass . reserve ( 100 ) ; strOldWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; SecureString strNewWalletPass ; strNewWalletPass . reserve ( 100 ) ; strNewWalletPass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( strOldWalletPass . length ( ) < 1 || strNewWalletPass . length ( ) < 1 ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( ! pwalletMain -> ChangeWalletPassphrase ( strOldWalletPass , strNewWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value walletlock ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 0 ) ) throw runtime_error ( " walletlock \n " " Removes ▁ the ▁ wallet ▁ encrypt@@ ion ▁ key ▁ from ▁ memory , ▁ locking ▁ the ▁ wallet . \n " " After ▁ calling ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ walletpassphrase ▁ again \n " " before ▁ being ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ which ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ unlocked . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletlock ▁ was ▁ called . " ) ; { LOCK ( cs_nWalletUnlockTime ) ; pwalletMain -> Lock ( ) ; nWalletUnlockTime = 0 ; } return Value :: null ; } Value encryptwallet ( const Array & params , bool fHelp ) { if ( ! pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 1 ) ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( fHelp ) return true ; if ( pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ encrypted ▁ wallet , ▁ but ▁ encryptwallet ▁ was ▁ called . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) < 1 ) throw runtime_error ( " encryptwallet ▁ < passphrase > \n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( ! pwalletMain -> Encrypt@@ Wallet ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_ENCRYP@@ TION_FAILED , " Error : ▁ Failed ▁ to ▁ encr@@ ypt ▁ the ▁ wallet . " ) ; StartShutdown ( ) ; return " wallet ▁ encrypted ; ▁ ILoveYouCoins ▁ server ▁ stopping , ▁ restart ▁ to ▁ run ▁ with ▁ encrypted ▁ wallet . ▁ The ▁ keypool ▁ has ▁ been ▁ flush@@ ed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ backup . " ; } class DescribeAddressVisitor : public boost :: static_visitor < Object > { public : Object operator ( ) ( const CNo@@ Destination & dest ) const { return Object ( ) ; } Object operator ( ) ( const CKeyID & keyID ) const { Object obj ; CPubKey vchPubKey ; pwalletMain -> GetPubKey ( keyID , vchPubKey ) ; obj . push_back ( Pair ( " isscript " , false ) ) ; obj . push_back ( Pair ( " pubkey " , HexStr ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " iscomp@@ ressed " , vchPubKey . IsCompressed ( ) ) ) ; return obj ; } Object operator ( ) ( const CScriptID & scriptID ) const { Object obj ; obj . push_back ( Pair ( " isscript " , true ) ) ; CScript subscript ; pwalletMain -> GetCScript ( scriptID , subscript ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( subscript , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , GetTxn@@ OutputType ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX_MULTISIG ) obj . push_back ( Pair ( " sig@@ srequired " , nRequired ) ) ; return obj ; } } ; Value validateaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " validateaddress ▁ < iloveyoucoinsaddress > \n " " Return ▁ information ▁ about ▁ < iloveyoucoinsaddress > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " isvalid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string currentAddress = address . ToString ( ) ; ret . push_back ( Pair ( " address " , currentAddress ) ) ; bool fMine = pwalletMain ? IsMine ( * pwalletMain , dest ) : false ; ret . push_back ( Pair ( " ismine " , fMine ) ) ; if ( fMine ) { Object detail = boost :: apply_visitor ( DescribeAddressVisitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pwalletMain && pwalletMain -> mapAddressBook . count ( dest ) ) ret . push_back ( Pair ( " account " , pwalletMain -> mapAddressBook [ dest ] ) ) ; } return ret ; } Value reservebalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " reservebalance ▁ [ < reserve > ▁ [ amount ] ] \n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ turn ▁ balance ▁ reserve ▁ on ▁ or ▁ off . \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ rounded ▁ to ▁ cent . \n " " Set ▁ reserve ▁ amount ▁ not ▁ partic@@ ipating ▁ in ▁ network ▁ protection . \n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ printed . \n " ) ; if ( params . size ( ) > 0 ) { bool fReserve = params [ 0 ] . get_bool ( ) ; if ( fReserve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provi@@ de ▁ amount ▁ to ▁ reserve ▁ balance . \n " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; nAmount = ( nAmount / CENT ) * CENT ; if ( nAmount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \n " ) ; nReserveBalance = nAmount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ specify ▁ amount ▁ to ▁ turn ▁ off ▁ reserve . \n " ) ; nReserveBalance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( nReserveBalance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , ValueFromAmount ( nReserveBalance ) ) ) ; return result ; } Value getinterest ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getinterest ▁ [ start ] ▁ [ end ] \n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UNIX ▁ timestamp@@ s . " ) ; unsigned int nTimeStart = 0 ; unsigned int nTimeEnd = - 1 ; if ( params . size ( ) >= 1 ) nTimeStart = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) nTimeEnd = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 nInterest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsCoinStake ( ) || wtx . nTime < nTimeStart || wtx . nTime > nTimeEnd ) continue ; int64 nDebit = wtx . GetDebit ( ) ; int64 nCredit = wtx . GetCredit ( ) ; if ( nDebit <= 0 || nCredit <= 0 || nDebit >= nCredit ) continue ; else nInterest += nCredit - nDebit ; } return ValueFromAmount ( nInterest ) ; } Value lockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lockunspent ▁ unlock ? ▁ [ array - of - Objects ] \n " " Updates ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; if ( params . size ( ) == 1 ) RPCTypeCheck ( params , list_of ( bool_type ) ) ; else RPCTypeCheck ( params , list_of ( bool_type ) ( array_type ) ) ; bool fUnlock = params [ 0 ] . get_bool ( ) ; if ( params . size ( ) == 1 ) { if ( fUnlock ) pwalletMain -> UnlockAllCoins ( ) ; return true ; } Array outputs = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , outputs ) { if ( output . type ( ) != obj_type ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_obj ( ) ; RPCTypeCheck ( o , map_list_of ( " txid " , str_type ) ( " vout " , int_type ) ) ; string txid = find_value ( o , " txid " ) . get_str ( ) ; if ( ! IsHex ( txid ) ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ txid " ) ; int nOutput = find_value ( o , " vout " ) . get_int ( ) ; if ( nOutput < 0 ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint outpt ( uint256 ( txid ) , nOutput ) ; if ( fUnlock ) pwalletMain -> UnlockCoin ( outpt ) ; else pwalletMain -> LockCoin ( outpt ) ; } return true ; } Value listlockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " listlockunspent \n " " Returns ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; vector < COutPoint > vOutpts ; pwalletMain -> ListLocked@@ Coins ( vOutpts ) ; Array ret ; BOOST_FOREACH ( COutPoint & outpt , vOutpts ) { Object o ; o . push_back ( Pair ( " txid " , outpt . hash . GetHex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) outpt . n ) ) ; ret . push_back ( o ) ; } return ret ; } </DOCUMENT>
<DOCUMENT_ID="y@@ inch@@ unlong@@ /abel@@ khan@@ -1/tree/master/@@ ext/c++/@@ third@@ part/c++/@@ boost/libs/math@@ /re@@ porting/ac@@ curacy/@@ test_ibet@@ a.cpp"> # include " bindings . hpp " # include " . . / . . / test / test _ ibet@@ a . hpp " # include < boost / math / special_functions / beta . hpp > BOOST_AUTO_TEST_CASE_@@ EXPECTED_@@ FAIL@@ URES ( test_main , 10000 ) ; BOOST_AUTO_TEST_CASE ( test_main ) { BOOST_MATH_CONTROL_FP ; error_@@ stream@@ _repla@@ cer rep ; # ifdef TYPE_TO_TEST test_beta ( static_cast < TYPE_TO_TEST > ( 0 ) , NAME_OF_TYPE_TO_TEST ) ; # else bool test_float = false ; bool test_double = false ; bool test_long_double = false ; if ( std :: numeric_limits < long double > :: digits == std :: numeric_limits < double > :: digits ) { if ( BOOST_MATH_PROMOTE_FLOAT_POLICY == false ) test_float = true ; test_double = true ; } else { if ( BOOST_MATH_PROMOTE_FLOAT_POLICY == false ) test_float = true ; if ( BOOST_MATH_PROMOTE_@@ DOUBLE_@@ POLICY == false ) test_double = true ; test_long_double = true ; } # ifdef ALWAYS_TEST_DOUBLE test_double = true ; # endif if ( test_float ) test_beta ( 0.0f , " float " ) ; if ( test_double ) test_beta ( 0.0 , " double " ) ; if ( test_long_double ) test_beta ( 0.0L , " long ▁ double " ) ; # ifdef BOOST_MATH_USE_FLO@@ AT128 # endif # endif } </DOCUMENT>
<DOCUMENT_ID="j@@ ames@@ fowk@@ es/DataLog@@ ger/tree/master/libraries/@@ DLDataField@@ /DLDataField@@ .Manager.cpp"> # ifdef ARDUIN@@ O # include < Ardu@@ ino . h > # else # include < stdint . h > # include < stdio . h > # include < string . h > # endif # ifdef TEST # include < iostream > # endif # include " DLUtility . Aver@@ ager . h " # include " DLDataField . Types . h " # include " DLDataField . h " # include " DLDataField . Manager . h " # include " DLSettings . Reader . Errors . h " # include " DLSettings . DataChannels . h " # include " DLUtility . h " # include " DLUtility . ArrayFunctions . h " # include " DLPlatform . h " DataFieldManager :: DataFieldManager ( uint32_t dataSize , uint32_t averagerSize ) { m_dataSize = dataSize ; m_averagerSize = averagerSize ; m_fieldCount = 0 ; m_dataCount = 0 ; uint8_t i = 0 ; for ( i = 0 ; i < MAX_FIELDS ; i ++ ) { m_fields [ i ] = NULL ; } } uint8_t DataFieldManager :: fieldCount ( ) { return m_fieldCount ; } bool DataFieldManager :: addField ( NumericDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } PLATFORM_@@ special@@ FieldSetup ( field ) ; field -> setData@@ Siz@@ es ( m_dataSize , m_averagerSize ) ; m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } bool DataFieldManager :: addField ( StringDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; } void DataFieldManager :: storeDataArray ( int32_t * data ) { uint16_t field = 0 ; uint16_t dataIndex ; bool newAverageStored = false ; for ( field = 0 ; field < m_fieldCount ; field ++ ) { NumericDataField * pField = ( NumericDataField * ) m_fields [ field ] ; if ( pField ) { dataIndex = m_channelNumbers [ field ] - 1 ; newAverageStored |= pField -> storeData ( data [ dataIndex ] ) ; } } if ( newAverageStored ) { m_dataCount ++ ; } } void DataFieldManager :: getData@@ Array ( float * buffer , bool converted , bool alsoRemove ) { uint16_t field ; for ( field = 0 ; field < m_fieldCount ; ++ field ) { if ( converted ) { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getConv@@ Data ( alsoRemove ) ; } else { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getRawData ( alsoRemove ) ; } } if ( alsoRemove ) { m_dataCount -- ; } } DataField * DataFieldManager :: getChannel ( uint8_t channel ) { int32_t actualIndex = indexOf ( m_channelNumbers , ( uint32_t ) channel , m_fieldCount ) ; return actualIndex >= 0 ? m_fields [ actualIndex ] : NULL ; } DataField * DataFieldManager :: getField ( uint8_t index ) { return m_fields [ index ] ; } DataField * * DataFieldManager :: getField@@ s ( void ) { return m_fields ; } uint32_t DataFieldManager :: writeHeader@@ sToBuffer ( char * buffer , uint8_t bufferLength ) { if ( ! buffer ) { return 0 ; } uint8_t i ; FixedLength@@ Accumulator headerAccumulator ( buffer , bufferLength ) ; for ( i = 0 ; i < m_fieldCount ; ++ i ) { headerAccumulator . writeString ( m_fields [ i ] -> getTypeString ( ) ) ; if ( ! lastinloop ( i , m_fieldCount ) ) { headerAccumulator . writeString ( " , ▁ " ) ; } } headerAccumulator . writeString ( " \n " ) ; return headerAccumulator . length ( ) ; } void DataFieldManager :: setupAllValidChannels ( void ) { uint8_t ch ; NumericDataField * field ; FIELD_TYPE type ; void * data ; uint32_t maxChannels = Settings_@@ GetMax@@ Channels ( ) ; for ( ch = 1 ; ch < maxChannels ; ch ++ ) { if ( Settings_@@ ChannelSettingIsValid ( ch ) ) { type = Settings_@@ GetChannel@@ Type ( ch ) ; data = Settings_@@ GetData ( ch ) ; switch ( type ) { case VOLTAGE : case CURRENT : case TEMPERATURE_@@ C : case TEMPERATURE_@@ K : case TEMPERATURE_@@ F : field = new NumericDataField ( type , data , ch ) ; # ifdef TEST std :: cout << " Adding ▁ channel ▁ " << ( int ) ch << " , ▁ type ▁ " << field -> getTypeString ( ) << std :: endl ; # endif addField ( field ) ; break ; default : break ; } } } } bool DataFieldManager :: hasData ( void ) { uint8_t i = 0 ; bool atLeastOneFieldHasData = false ; for ( i = 0 ; i < m_fieldCount ; i ++ ) { atLeastOneFieldHasData |= m_fields [ i ] -> hasData ( ) ; } return atLeastOneFieldHasData ; } uint32_t DataFieldManager :: count ( void ) { return m_dataCount ; } uint32_t * DataFieldManager :: getChannel@@ Numbers ( void ) { return m_channelNumbers ; } </DOCUMENT>
<DOCUMENT_ID="DL@@ R-SC@@ /tigl@@ /tree/master/src/generated/@@ CPACSFarField.cpp"> # include " CPACSFarField . h " # include " CTigl@@ Error . h " # include " CTigl@@ Logging . h " # include " TixiHelper . h " namespace tig@@ l { namespace generated { CPACSFarField :: CPACSFarField ( ) : m_referenceLength ( 0 ) , m_multiplier ( 0 ) { } CPACSFarField :: ~ CPACSFarField ( ) { } void CPACSFarField :: ReadCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) { if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / type " ) ) { m_type = stringToT@@ iglFarField@@ Type ( tixi :: TixiGetElement < std :: string > ( tixiHandle , xpath + " / type " ) ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ type ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / referenceLength " ) ) { m_referenceLength = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / referenceLength " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ referenceLength ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / multiplier " ) ) { m_multiplier = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / multiplier " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ multiplier ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } } void CPACSFarField :: WriteCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) const { tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / type " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / type " , TiglFarField@@ TypeToString ( m_type ) ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / referenceLength " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / referenceLength " , m_referenceLength ) ; tixi :: TixiCreateElementIfNotExists ( tixiHandle , xpath + " / multiplier " ) ; tixi :: TixiSaveElement ( tixiHandle , xpath + " / multiplier " , m_multiplier ) ; } const TiglFarFieldType & CPACSFarField :: GetType ( ) const { return m_type ; } void CPACSFarField :: SetType ( const TiglFarFieldType & value ) { m_type = value ; } const double & CPACSFarField :: GetReference@@ Length ( ) const { return m_referenceLength ; } void CPACSFarField :: SetReference@@ Length ( const double & value ) { m_referenceLength = value ; } const double & CPACSFarField :: GetMultiplier ( ) const { return m_multiplier ; } void CPACSFarField :: SetMultiplier ( const double & value ) { m_multiplier = value ; } } } </DOCUMENT>
<DOCUMENT_ID="gr@@ zeg@@ orz2047@@ /Ho@@ telReser@@ vation/tree/master/@@ fileio.cpp"> # include < stdio . h > # include < string > # include < stdlib . h > # include < time . h > # include < sstream > # include < fstream > # include < vector > # include < iostream > std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { lines . push_back ( line ) ; } } read . close ( ) ; return lines ; } void save@@ File ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; } </DOCUMENT>
<DOCUMENT_ID="lassoan/@@ CTK/tree/master/Libs/@@ Core/ctkWorkflowStep.cpp"> # include < QDebug > # include < QMeta@@ Type > # include < QObject > # include < QState > # include " ctkWorkflowStep . h " # include " ctkWorkflowStep _ p . h " # include " ctkWorkflow . h " # include " ctkLogger . h " # include < iostream > static ctkLogger logger ( " org . commont@@ k . core . ctkWorkflowStep " ) ; ctkWorkflowStepPrivate :: ctkWorkflowStepPrivate ( ctkWorkflowStep & object ) : q_ptr ( & object ) { qRegister@@ Meta@@ Type < ctkWorkflowStep * > ( " ctkWorkflowStep * " ) ; this -> Workflow = 0 ; this -> WidgetType = false ; this -> HasValidateCommand = false ; this -> HasOnEntryCommand = false ; this -> HasOnExitCommand = false ; this -> ProcessingState = new QState ( ) ; this -> ValidationState = new QState ( ) ; this -> ValidationTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationTransition ) ; this -> ValidationTransition -> setTargetState ( this -> ValidationState ) ; this -> ProcessingState -> addTransition ( this -> ValidationTransition ) ; this -> ValidationFailedTransition = 0 ; this -> ValidationFailedTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationFailedTransition ) ; this -> ValidationFailedTransition -> setTargetState ( this -> ProcessingState ) ; this -> ValidationState -> addTransition ( this -> ValidationFailedTransition ) ; } ctkWorkflowStepPrivate :: ~ ctkWorkflowStepPrivate ( ) { if ( ! this -> ValidationState . isNull ( ) ) { delete this -> ValidationState ; } if ( ! this -> ProcessingState . isNull ( ) ) { delete this -> ProcessingState ; } } void ctkWorkflowStepPrivate :: validationCompleteInternal ( bool validationResults , const QString & branchId ) const { emit validationComplete ( validationResults , branchId ) ; } void ctkWorkflowStepPrivate :: onEntryCompleteInternal ( ) const { emit onEntryComplete ( ) ; } void ctkWorkflowStepPrivate :: onExitCompleteInternal ( ) const { emit onExitComplete ( ) ; } void ctkWorkflowStepPrivate :: invokeValidateCommandInternal ( const QString & desiredBranchId ) const { emit invokeValidateCommand ( desiredBranchId ) ; } void ctkWorkflowStepPrivate :: invokeOnEntryCommandInternal ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnEntryCommand ( comingFrom , transitionType ) ; } void ctkWorkflowStepPrivate :: invokeOnExitCommandInternal ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { emit invokeOnExitCommand ( goingTo , transitionType ) ; } ctkWorkflowStep :: ctkWorkflowStep ( ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { } ctkWorkflowStep :: ctkWorkflowStep ( const QString & newId ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ctkWorkflowStep ( ctkWorkflowStepPrivate * pimpl , const QString & newId ) : d_ptr ( pimpl ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; } ctkWorkflowStep :: ~ ctkWorkflowStep ( ) { } CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflow * , workflow , Workflow ) ; CTK_SET_CPP ( ctkWorkflowStep , ctkWorkflow * , setWorkflow , Workflow ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , id , Id ) ; void ctkWorkflowStep :: setId ( const QString & newId ) { Q_D ( ctkWorkflowStep ) ; if ( d -> Workflow && d -> Workflow -> hasStep ( newId ) && ! this -> id ( ) . isEmpty ( ) ) { logger . error ( QString ( " ctkWorkflowStep ▁ - ▁ Failed ▁ to ▁ change ▁ id ▁ from ▁ ' %1 ' ▁ to ▁ ' %2 ' ▁ - ▁ " " Step ▁ already ▁ added ▁ to ▁ a ▁ workflow ▁ ! " ) . arg ( this -> id ( ) ) . arg ( newId ) ) ; return ; } d -> Id = newId ; } CTK_GET_CPP ( ctkWorkflowStep , QString , name , Name ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setName , Name ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , description , Description ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setDescription , Description ) ; CTK_GET_CPP ( ctkWorkflowStep , QString , statusText , StatusText ) ; CTK_SET_CPP ( ctkWorkflowStep , const QString & , setStatusText , StatusText ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasValidateCommand , HasValidateCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasValidateCommand , HasValidateCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnEntryCommand , HasOnEntryCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnEntryCommand , HasOnEntryCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , hasOnExitCommand , HasOnExitCommand ) ; CTK_SET_CPP ( ctkWorkflowStep , bool , setHasOnExitCommand , HasOnExitCommand ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , processingState , ProcessingState ) ; CTK_GET_CPP ( ctkWorkflowStep , QState * , validationState , ValidationState ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationTransition , ValidationTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , ctkWorkflowIntrastepTransition * , validationFailedTransition , ValidationFailedTransition ) ; CTK_GET_CPP ( ctkWorkflowStep , bool , isWidgetType , WidgetType ) ; QObject * ctkWorkflowStep :: ctkWorkflowStepQObject ( ) { Q_D ( ctkWorkflowStep ) ; return d ; } void ctkWorkflowStep :: validationComplete ( bool validationResults , const QString & branchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> validationCompleteInternal ( validationResults , branchId ) ; } void ctkWorkflowStep :: onEntryComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onEntryCompleteInternal ( ) ; } void ctkWorkflowStep :: onExitComplete ( ) const { Q_D ( const ctkWorkflowStep ) ; d -> onExitCompleteInternal ( ) ; } void ctkWorkflowStep :: invokeValidateCommand ( const QString & desiredBranchId ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeValidateCommandInternal ( desiredBranchId ) ; } void ctkWorkflowStep :: invokeOnEntryCommand ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnEntryCommandInternal ( comingFrom , transitionType ) ; } void ctkWorkflowStep :: invokeOnExitCommand ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) const { Q_D ( const ctkWorkflowStep ) ; d -> invokeOnExitCommandInternal ( goingTo , transitionType ) ; } void ctkWorkflowStep :: validate ( const QString & desiredBranchId ) { Q_D ( ctkWorkflowStep ) ; logger . info ( QString ( " validate ▁ - ▁ validating ▁ the ▁ input ▁ from ▁ % 1" ) . arg ( d -> Name ) ) ; this -> validationComplete ( true , desiredBranchId ) ; } void ctkWorkflowStep :: onEntry ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( comingFrom ) ; Q_UNUSED ( transitionType ) ; this -> onEntryComplete ( ) ; } void ctkWorkflowStep :: onExit ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( goingTo ) ; Q_UNUSED ( transitionType ) ; this -> onExitComplete ( ) ; } </DOCUMENT>
<DOCUMENT_ID="stom@@ an/@@ HashCode2017@@ Warmup@@ /tree/master/loon/@@ code/@@ pathfind@@ ing.cpp"> # pragma once # include " util . cpp " # include < set > # include < cmath > struct Coord { int r , c , h ; } ; bool operator < ( const Coord & a , const Coord & b ) { if ( a . r != b . r ) return a . r < b . r ; else if ( a . c != b . c ) return a . c < b . c ; else return a . h < b . h ; } double compute_distance ( double r1 , double c1 , double h , double r2 , double c2 , double r , double c ) { if ( r1 < 0 || r1 >= r || r2 < 0 || r2 >= r ) return 1e@@ 12 ; double dr = abs ( r1 - r2 ) ; double dc = min ( abs ( c1 - c2 ) , c - abs ( c1 - c2 ) ) ; return sqrt ( dr * dr + dc * dc ) + 20. * ( h - 1. ) / ( sqrt ( dr * dr + dc * dc ) + 1 ) ; } int check_cell_value ( Input & input , int r , int c ) { c = ( c + input . c ) % input . c ; if ( r >= 0 && r < input . r ) return input . cell_field [ r ] [ c ] ; else return 0 ; } void check_cell ( Input & input , Coord cur , vector < Coord > & path , vector < int > & prev , set < Coord > & visited , vector < double > & dist , int idx , double r , double c , double alpha ) { int dr = input . movement_@@ r [ cur . r ] [ cur . c ] [ cur . h ] ; int dc = input . movement_c [ cur . r ] [ cur . c ] [ cur . h ] ; cur . r += dr ; cur . c += dc ; cur . c = ( cur . c + input . c ) % input . c ; if ( visited . find ( cur ) != visited . end ( ) ) return ; int cnt_cells = 0 ; for ( int i = - 2 ; i <= 2 ; i ++ ) for ( int j = - 2 ; j <= 2 ; j ++ ) cnt_cells += check_cell_value ( input , cur . r + i , cur . c + j ) ; if ( cnt_cells > 12 ) dist . push_back ( dist [ idx ] + alpha ) ; else dist . push_back ( dist [ idx ] + 1.0 ) ; path . push_back ( cur ) ; prev . push_back ( idx ) ; visited . insert ( cur ) ; } void bfs ( Input & input , vector < Coord > & path , vector < int > & prev , double r , double c , int bfsdepth , double alpha ) { set < Coord > visited ; vector < double > dist ; int idx = 0 ; dist . push_back ( 0 ) ; visited . insert ( path [ idx ] ) ; while ( idx < path . size ( ) ) { Coord cur = path [ idx ] ; if ( dist [ idx ] > ( double ) bfsdepth ) break ; if ( cur . r >= input . r || cur . r < 0 ) { path . push_back ( cur ) ; prev . push_back ( idx ) ; dist . push_back ( dist [ idx ] + 1 ) ; } else { check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; if ( cur . h > 1 ) { cur . h -- ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h ++ ; } if ( cur . h < input . a ) { cur . h ++ ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h -- ; } } idx ++ ; } } void append_path ( Input & input , int balloon , vector < Coord > & path , vector < int > & prev , int idx_min ) { vector < Coord > reversed_path ; for ( int i = idx_min ; i != 0 ; i = prev [ i ] ) reversed_path . push_back ( path [ i ] ) ; for ( int i = reversed_path . size ( ) - 1 ; i >= 0 ; i -- ) { input . balloons [ balloon ] . h . push_back ( reversed_path [ i ] . h ) ; input . balloons [ balloon ] . r . push_back ( reversed_path [ i ] . r ) ; input . balloons [ balloon ] . c . push_back ( reversed_path [ i ] . c ) ; if ( input . balloons [ balloon ] . h . size ( ) > input . t ) break ; } } int choose_closest_point ( Input & input , vector < Coord > & path , double r , double c ) { double mind = 1e@@ 10 , curd ; int idx_min = 0 ; for ( int i = 1 ; i < path . size ( ) ; i ++ ) { curd = compute_distance ( path [ i ] . r , path [ i ] . c , path [ i ] . h , r , c , input . r , input . c ) ; if ( curd < mind || idx_min == 0 ) { idx_min = i ; mind = curd ; } } return idx_min ; } bool check_horizontal_distance ( double c1 , double c2 , double delta_c , double c ) { if ( delta_c > c ) return true ; c2 += delta_c ; if ( c2 > c ) c2 -= c ; if ( abs ( c2 - c1 ) < c - abs ( c2 - c1 ) ) return c1 < c2 ; else return c1 > c2 ; } void pathfind@@ ing ( Input & input , int balloon , double r , double c , double delta , int bfsdepth , double delta_c , double alpha = 0.5 ) { bool step_done = false ; while ( step_done == false || ( input . balloons [ balloon ] . h . size ( ) <= input . t && compute_distance ( input . balloons [ balloon ] . r . back ( ) , input . balloons [ balloon ] . c . back ( ) , input . balloons [ balloon ] . h . back ( ) , r , c , input . r , input . c ) > delta && check_horizontal_distance ( input . balloons [ balloon ] . c . back ( ) , c , delta_c , input . c ) ) ) { vector < Coord > path ; vector < int > prev ; Coord start ; start . r = input . balloons [ balloon ] . r . back ( ) ; start . c = input . balloons [ balloon ] . c . back ( ) ; start . h = input . balloons [ balloon ] . h . back ( ) ; path . push_back ( start ) ; prev . push_back ( - 1 ) ; bfs ( input , path , prev , r , c , bfsdepth , alpha ) ; int idx_min = choose_closest_point ( input , path , r , c ) ; append_path ( input , balloon , path , prev , idx_min ) ; step_done = true ; } } </DOCUMENT>
<DOCUMENT_ID="Ra@@ zZz@@ iel/@@ sc_@@ pong@@ /tree/master/src/scfont.cpp"> # include < stdlib . h > # include < string . h > # include " SDL / SDL . h " # include " SDL / SDL _ image . h " # include " scfont . h " ScFont * ScLoadFont ( const char * filename ) { ScFont * font = ( ScFont * ) malloc ( sizeof ( ScFont ) ) ; FILE * file = fopen ( filename , " r " ) ; fread ( ( void * ) & font -> header , sizeof ( ScFontHeader ) , 1 , file ) ; int n_offsets = font -> header . highIndex - font -> header . lowIndex ; Uint32 * offsets = ( Uint32 * ) malloc ( sizeof ( Uint32 ) * ( n_offsets + 1 ) ) ; fseek ( file , sizeof ( ScFontHeader ) , SEEK_SET ) ; fread ( ( void * ) offsets , sizeof ( Uint32 ) , n_offsets , file ) ; fseek ( file , 0 , SEEK_@@ END ) ; offsets [ n_offsets ] = fte@@ ll ( file ) ; font -> letters = ( ScLetter * ) malloc ( sizeof ( ScLetter ) * ( n_offsets + 1 ) ) ; for ( int i = 1 ; i <= n_offsets ; i ++ ) { if ( offsets [ i - 1 ] ) { fseek ( file , offsets [ i - 1 ] , SEEK_SET ) ; fread ( ( void * ) & font -> letters [ i ] . header , sizeof ( ScLetterHeader ) , 1 , file ) ; int next_offset = offsets [ i ] ; for ( int o = 0 ; ! next_offset ; o ++ ) { next_offset = offsets [ i + o ] ; } font -> letters [ i ] . n_pixels = next_offset - ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) - 1 ; font -> letters [ i ] . pixels = ( Uint8 * ) malloc ( sizeof ( Uint8 ) * font -> letters [ i ] . n_pixels ) ; fseek ( file , ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) , SEEK_SET ) ; fread ( ( void * ) font -> letters [ i ] . pixels , sizeof ( Uint8 ) , font -> letters [ i ] . n_pixels , file ) ; } else font -> letters [ i ] . n_pixels = - 1 ; } font -> letters [ 0 ] . n_pixels = 0 ; font -> letters [ 0 ] . header . x = 0 ; font -> letters [ 0 ] . header . y = 0 ; font -> letters [ 0 ] . header . h = 0 ; font -> letters [ 0 ] . header . w = font -> header . maxWidth / 2 ; free ( offsets ) ; fclose ( file ) ; return font ; } ScPalette * ScLoad@@ Palette ( const char * filename ) { ScPalette * palette = ( ScPalette * ) malloc ( sizeof ( ScPalette ) ) ; SDL_Surface * s_palette ; if ( ( s_palette = SDL_Display@@ Format ( IMG_Load ( filename ) ) ) == NULL ) { fprintf ( stderr , " ERROR : ▁ Cannot ▁ load ▁ palette ▁ ' % s ' " , filename ) ; exit ( 1 ) ; } memcpy ( * palette , s_palette -> pixels , s_palette -> format -> BytesPerPixel * s_palette -> w ) ; SDL_FreeSurface ( s_palette ) ; return palette ; } SDL_Surface * ScRenderChar ( unsigned const char car , ScFont * font , ScColor * color ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; int index = car - font -> header . lowIndex ; if ( ( car < font -> header . lowIndex ) || ( car > font -> header . highIndex ) || ( font -> letters [ index ] . n_pixels < 0 ) ) { fprintf ( stderr , " ERROR ▁ ( ScRenderChar ) : ▁ Invalid ▁ character ▁ index ▁ % d \n " , car ) ; return NULL ; } SDL_Surface * letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> letters [ index ] . header . h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; if ( font -> letters [ index ] . header . h > 0 ) { char * pixels = ( char * ) letter -> pixels - letter -> format -> BytesPerPixel ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 gamma = font -> letters [ index ] . pixels [ p ] & 7 ; pixels += skip * letter -> format -> BytesPerPixel + letter -> format -> BytesPerPixel ; memcpy ( pixels , * color + gamma , letter -> format -> BytesPerPixel ) ; } SDL_SetColorKey ( letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; } SDL_Surface * final_letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_Rect offset = { font -> letters [ index ] . header . x , font -> letters [ index ] . header . y , 0 , 0 } ; SDL_BlitSurface ( letter , NULL , final_letter , & offset ) ; SDL_FreeSurface ( letter ) ; SDL_SetColorKey ( final_letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; return final_letter ; } int calculateWidth ( const unsigned char * text , ScFont * font , char delim ) { int width = 0 ; while ( * text ) { if ( * text != delim ) width += font -> letters [ * text - font -> header . lowIndex ] . header . w + 1 ; text ++ ; } return width - 1 ; } SDL_Surface * ScRenderText ( const char * text , ScFont * font , ScColor * color , ScColor * color_hi , char delim ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Surface * s_text = SDL_CreateRGBSurface ( SDL_SWSURFACE , calculateWidth ( ( unsigned char * ) text , font , delim ) , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_SetColorKey ( s_text , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; SDL_Surface * s_char ; SDL_Rect offset = { 0 , 0 , 0 , 0 } ; if ( color_hi ) { ScColor * actual_color = color ; while ( * text ) { if ( * text == delim ) { if ( actual_color == color ) actual_color = color_hi ; else actual_color = color ; } else { if ( ( s_char = ScRenderChar ( * text , font , actual_color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } else { while ( * text ) { if ( * text != delim ) { if ( ( s_char = ScRenderChar ( * text , font , color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } return s_text ; } ScColor * ScGetColor ( const ScPalette * palette , int index ) { ScColor * color = ( ScColor * ) malloc ( sizeof ( ScColor ) ) ; memcpy ( * color , * palette + ( index * MAX_G@@ AMM@@ A ) , sizeof ( ScColor ) ) ; return color ; } void ScTestFont ( ScFont * font , ScPalette * palette ) { # define TEST_SDL SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Fill@@ Rect ( screen , NULL , SDL_Map@@ RGB ( SDL_GetVideoSurface ( ) -> format , 255 , 255 , 255 ) ) ; SDL_Flip ( screen ) ; # ifdef TEST_SDL SDL_Rect offset = { 10 , 10 , 0 , 0 } ; SDL_BlitSurface ( ScRenderText ( " El ▁ veloz ▁ mur@@ ci � ago ▁ hind " , font , ScGetColor ( palette , 1 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " Jui@@ porentender@@ las " , font , ScGetColor ( palette , 5 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " _ S _ ingle ▁ Player " , font , ScGetColor ( palette , 1 ) , ScGetColor ( palette , 2 ) , ' _ ' ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; # endif for ( int i = font -> header . lowIndex ; i <= font -> header . highIndex ; i ++ ) { # ifdef TEST_SDL SDL_Surface * s_char = ScRenderChar ( i , font , ScGetColor ( palette , 2 ) ) ; if ( s_char ) { SDL_BlitSurface ( s_char , NULL , screen , & offset ) ; SDL_FreeSurface ( s_char ) ; } if ( ( offset . x += font -> header . maxWidth + 2 ) > ( screen -> w - font -> header . maxWidth - 10 ) ) { offset . x = 10 ; offset . y += font -> header . maxHeight + 2 ; } # else int index = i - font -> header . lowIndex ; int x = 1 ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) printf ( " % d ▁ " , ( font -> letters [ i ] . pixels [ p ] >> 3 ) ) ; printf ( " \n " ) ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 color = font -> letters [ index ] . pixels [ p ] & 7 ; for ( int j = 0 ; j < skip ; j ++ ) { printf ( " ▁ " ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " % d " , color ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " \n test ▁ end \n " ) ; getchar ( ) ; # endif } SDL_Flip ( screen ) ; * screen = * SDL_CreateRGBSurface ( SDL_SWSURFACE , screen -> w , screen -> h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; getchar ( ) ; } </DOCUMENT>
<DOCUMENT_ID="uw@@ afsl/@@ ardupilot/tree/master/libraries/AP_@@ HAL_Linux/@@ Util.cpp"> # include < AP_HAL / AP_HAL . h > # if CONFIG_HAL_BOARD == HAL_BOARD_@@ LINUX # include < stdio . h > # include < stdarg . h > # include < sys / stat . h > # include < unistd . h > # include < stdlib . h > # include < errno . h > # include < time . h > # include < fcntl . h > extern const AP_HAL :: HAL & hal ; # include " ToneAlarm _ Raspilot . h " # include " Util . h " # include " Heat _ Pwm . h " using namespace Linux ; static int state ; # if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_@@ RAS@@ PI@@ LOT ToneAlarm_@@ Raspilot Util :: _toneAlarm ; # else ToneAlarm Util :: _toneAlarm ; # endif void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; # ifdef HAL_UTILS_HEAT # if HAL_UTILS_HEAT == HAL_LINUX_HEAT_P@@ WM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_P@@ WM_NUM , HAL_LINUX_HEAT_K@@ P , HAL_LINUX_HEAT_K@@ I , HAL_LINUX_HEAT_@@ PERIO@@ D_NS , HAL_LINUX_HEAT_@@ TARGET_TEMP ) ; # else # error Unrecognized Heat # endif # else _heat = new Linux :: Heat ( ) ; # endif } void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; } void Util :: commandlin@@ e_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; } bool Util :: toneAlarm_@@ init ( ) { return _toneAlarm . init ( ) ; } void Util :: toneAlarm_@@ set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; } void Util :: _toneAlar@@ m_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_t@@ une ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tun@@ e_comp ( ) ) { state = 0 ; } } void Util :: set_system_@@ clock ( uint64_t time_utc_usec ) { # if CONFIG_HAL_BOARD_SUBTYPE != HAL_BOARD_SUBTYPE_LINUX_@@ NONE timespec ts ; ts . tv_sec = time_utc_usec / 1.0@@ e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_@@ settime ( CLOCK_@@ REAL@@ TIME , & ts ) ; # endif } bool Util :: is_char@@ dev_@@ node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_IS@@ CHR ( st . st_mode ) ; } uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; } int Util :: write_@@ file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRO@@ NLY | O_CLO@@ EXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; } int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vf@@ scan@@ f ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; } const char * Linux :: Util :: _hw_names [ UTIL_NUM_HARDWARES ] = { [ UTIL_HARDWARE_RPI@@ 1 ] = " BCM@@ 2708@@ " , [ UTIL_HARDWARE_RPI@@ 2 ] = " BCM@@ 270@@ 9" , [ UTIL_HARDWARE_BEBO@@ P ] = " Mykon@@ os3 ▁ board " , [ UTIL_HARDWARE_BEBO@@ P2 ] = " Milo@@ s ▁ board " , } ; # define MAX_SIZE_LINE 50 int Util :: get_h@@ w_arm@@ 32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hard@@ ware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpu@@ info " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; } # endif </DOCUMENT>
<DOCUMENT_ID="keich@@ an100@@ yen/ode@@ -ext@@ /tree/master/boost/libs/@@ config/test/@@ no_std_@@ allocator_@@ fail@@ .cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifdef BOOST_NO_STD_@@ ALLOCATOR # include " boost _ no _ std _ allocator . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_@@ no_std_@@ allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="LiquidSh@@ ock@@ Gam@@ es/bongobuck@@ s/tree/master/src/qt/@@ sendcoins@@ dialog.cpp"> # include " sendcoinsdialog . h " # include " ui _ sendcoinsdialog . h " # include " walletmodel . h " # include " bitcoin@@ units . h " # include " addressbook@@ page . h " # include " optionsmodel . h " # include " sendcoins@@ entry . h " # include " guiutil . h " # include " askpassphr@@ ased@@ ialog . h " # include < QMessageBox > # include < QLocale > # include < QTextDocument > # include < QScrollBar > SendCoinsDialog :: SendCoinsDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: SendCoinsDialog ) , model ( 0 ) { ui -> setupUi ( this ) ; # ifdef Q_WS_MAC ui -> addButton -> setIcon ( QIcon ( ) ) ; ui -> clearButton -> setIcon ( QIcon ( ) ) ; ui -> sendButton -> setIcon ( QIcon ( ) ) ; # endif addEntry ( ) ; connect ( ui -> addButton , SIGNAL ( clicked ( ) ) , this , SLOT ( addEntry ( ) ) ) ; connect ( ui -> clearButton , SIGNAL ( clicked ( ) ) , this , SLOT ( clear ( ) ) ) ; fNewRecipientAllowed = true ; } void SendCoinsDialog :: setModel ( WalletModel * model ) { this -> model = model ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setModel ( model ) ; } } if ( model && model -> getOptionsModel ( ) ) { setBalance ( model -> getBalance ( ) , model -> getUn@@ confirmedBalance ( ) , model -> getIm@@ matureBalance ( ) ) ; connect ( model , SIGNAL ( balance@@ Changed ( qint64 , qint64 , qint64 ) ) , this , SLOT ( setBalance ( qint64 , qint64 , qint64 ) ) ) ; connect ( model -> getOptionsModel ( ) , SIGNAL ( displayUnitChanged ( int ) ) , this , SLOT ( updateDisplayUnit ( ) ) ) ; } } SendCoinsDialog :: ~ SendCoinsDialog ( ) { delete ui ; } void SendCoinsDialog :: on_send@@ Button_clicked ( ) { QList < SendCoinsRecipient > recipients ; bool valid = true ; if ( ! model ) return ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { if ( entry -> validate ( ) ) { recipients . append ( entry -> getValue ( ) ) ; } else { valid = false ; } } } if ( ! valid || recipients . isEmpty ( ) ) { return ; } QStringList formatted ; foreach ( const SendCoinsRecipient & rcp , recipients ) { formatted . append ( tr ( " < b > % 1 < / b > ▁ to ▁ % 2 ▁ ( %3 ) " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , rcp . amount ) , Qt :: escape ( rcp . label ) , rcp . address ) ) ; } fNewRecipientAllowed = false ; QMessageBox :: StandardButton retval = QMessageBox :: question ( this , tr ( " Confirm ▁ send ▁ coins " ) , tr ( " Are ▁ you ▁ sure ▁ you ▁ want ▁ to ▁ send ▁ % 1 ? " ) . arg ( formatted . join ( tr ( " ▁ and ▁ " ) ) ) , QMessageBox :: Yes | QMessageBox :: Cancel , QMessageBox :: Cancel ) ; if ( retval != QMessageBox :: Yes ) { fNewRecipientAllowed = true ; return ; } WalletModel :: UnlockContext ctx ( model -> requestUnlock ( ) ) ; if ( ! ctx . isValid ( ) ) { fNewRecipientAllowed = true ; return ; } WalletModel :: SendCoinsReturn sendstatus = model -> sendCoins ( recipients ) ; switch ( sendstatus . status ) { case WalletModel :: InvalidAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ rece@@ pient ▁ address ▁ is ▁ not ▁ valid , ▁ please ▁ recheck . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: InvalidAmount : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ to ▁ pay ▁ must ▁ be ▁ larger ▁ than ▁ 0 . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ exceeds ▁ your ▁ balance . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountWithFee@@ ExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ total ▁ exceeds ▁ your ▁ balance ▁ when ▁ the ▁ % 1 ▁ transaction ▁ fee ▁ is ▁ included . " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , sendstatus . fee ) ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: DuplicateAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Duplicate ▁ address ▁ found , ▁ can ▁ only ▁ send ▁ to ▁ each ▁ address ▁ once ▁ per ▁ send ▁ operation . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCreation@@ Failed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ Transaction ▁ creation ▁ failed . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCommit@@ Failed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ The ▁ transaction ▁ was ▁ reject@@ ed . ▁ This ▁ might ▁ happen ▁ if ▁ some ▁ of ▁ the ▁ coins ▁ in ▁ your ▁ wallet ▁ were ▁ already ▁ spent , ▁ such ▁ as ▁ if ▁ you ▁ used ▁ a ▁ copy ▁ of ▁ wallet . dat ▁ and ▁ coins ▁ were ▁ spent ▁ in ▁ the ▁ copy ▁ but ▁ not ▁ marked ▁ as ▁ spent ▁ here . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: Aborted : break ; case WalletModel :: OK : accept ( ) ; break ; } fNewRecipientAllowed = true ; } void SendCoinsDialog :: clear ( ) { while ( ui -> entries -> count ( ) ) { delete ui -> entries -> take@@ At ( 0 ) -> widget ( ) ; } addEntry ( ) ; updateRemoveEnabled ( ) ; ui -> sendButton -> setDefault ( true ) ; } void SendCoinsDialog :: reject ( ) { clear ( ) ; } void SendCoinsDialog :: accept ( ) { clear ( ) ; } SendCoinsEntry * SendCoinsDialog :: addEntry ( ) { SendCoinsEntry * entry = new SendCoinsEntry ( this ) ; entry -> setModel ( model ) ; ui -> entries -> addWidget ( entry ) ; connect ( entry , SIGNAL ( removeEntry ( SendCoinsEntry * ) ) , this , SLOT ( removeEntry ( SendCoinsEntry * ) ) ) ; updateRemoveEnabled ( ) ; entry -> clear ( ) ; entry -> setFocus ( ) ; ui -> scrollAreaWidgetContents -> resize ( ui -> scrollAreaWidgetContents -> sizeHint ( ) ) ; QCoreApplication :: instance ( ) -> processEvents ( ) ; QScrollBar * bar = ui -> scrollArea -> verticalScrollBar ( ) ; if ( bar ) bar -> setSlider@@ Position ( bar -> maximum ( ) ) ; return entry ; } void SendCoinsDialog :: updateRemoveEnabled ( ) { bool enabled = ( ui -> entries -> count ( ) > 1 ) ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setRemoveEnabled ( enabled ) ; } } setupTabChain ( 0 ) ; } void SendCoinsDialog :: removeEntry ( SendCoinsEntry * entry ) { delete entry ; updateRemoveEnabled ( ) ; } QWidget * SendCoinsDialog :: setupTabChain ( QWidget * prev ) { for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { prev = entry -> setupTabChain ( prev ) ; } } QWidget :: setTabOrder ( prev , ui -> addButton ) ; QWidget :: setTabOrder ( ui -> addButton , ui -> sendButton ) ; return ui -> sendButton ; } void SendCoinsDialog :: pasteEntry ( const SendCoinsRecipient & rv ) { if ( ! fNewRecipientAllowed ) return ; SendCoinsEntry * entry = 0 ; if ( ui -> entries -> count ( ) == 1 ) { SendCoinsEntry * first = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( 0 ) -> widget ( ) ) ; if ( first -> isClear ( ) ) { entry = first ; } } if ( ! entry ) { entry = addEntry ( ) ; } entry -> setValue ( rv ) ; } bool SendCoinsDialog :: handleURI ( const QString & uri ) { SendCoinsRecipient rv ; if ( GUIUtil :: parseBitcoin@@ URI ( uri , & rv ) ) { pasteEntry ( rv ) ; return true ; } return false ; } void SendCoinsDialog :: setBalance ( qint64 balance , qint64 unconfirmedBalance , qint64 immatureBalance ) { Q_UNUSED ( unconfirmedBalance ) ; Q_UNUSED ( immatureBalance ) ; if ( ! model || ! model -> getOptionsModel ( ) ) return ; int unit = model -> getOptionsModel ( ) -> getDisplayUnit ( ) ; ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( unit , balance ) ) ; } void SendCoinsDialog :: updateDisplayUnit ( ) { if ( model && model -> getOptionsModel ( ) ) { ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( model -> getOptionsModel ( ) -> getDisplayUnit ( ) , model -> getBalance ( ) ) ) ; } } </DOCUMENT>
<DOCUMENT_ID="h@@ bwh@@ lk@@ live@@ /color-emoji.skia/tree/master/src/@@ ports/SkGlobal@@ Initialization@@ _chromi@@ um.cpp"> # include " SkBitmapProcShader . h " # include " SkBlurImageFilter . h " # include " SkBlurMaskFilter . h " # include " SkColorFilter . h " # include " SkCornerPathEffect . h " # include " SkDashPathEffect . h " # include " SkGradientShader . h " # include " SkLayerDrawLooper . h " # include " SkMallocPixelRef . h " # include " SkXfermode . h " # include " SkMagnifierImageFilter . h " void SkFlat@@ tenable :: InitializeFlattenables ( ) { SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBitmapProcShader ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBlurImageFilter ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkCornerPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkDashPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkLayerDrawLooper ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMallocPixelRef ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMagnifierImageFilter ) SkBlurMaskFilter :: InitializeFlattenables ( ) ; SkColorFilter :: InitializeFlattenables ( ) ; SkGradientShader :: InitializeFlattenables ( ) ; SkXfermode :: InitializeFlattenables ( ) ; } </DOCUMENT>
<DOCUMENT_ID="P@@ KRo@@ ma/poedit/tree/master/deps/boost/libs/@@ phoenix/test/@@ container/@@ container_@@ tests8@@ a.cpp"> # include " container _ tests . hpp " # include < boost / static_assert . hpp > std :: set < int > const build_set ( ) { typedef std :: set < int > int_set ; typedef std :: vector < int > int_vector ; int_set result ; int_vector const data = build_vector ( ) ; int_vector :: const_iterator it = data . begin ( ) ; int_vector :: const_iterator const end = data . end ( ) ; result . insert ( it , end ) ; return result ; } std :: multiset < int > const build_multiset ( ) { typedef std :: set < int > int_set ; typedef std :: multiset < int > int_multiset ; int_set const data = build_set ( ) ; return int_multiset ( data . begin ( ) , data . end ( ) ) ; } std :: vector < int > const init_vector ( ) { typedef std :: vector < int > int_vector ; int const data [ ] = { - 4 , - 3 , - 2 , - 1 , 0 } ; int_vector :: size_type const data_size = sizeof ( data ) / sizeof ( data [ 0 ] ) ; return int_vector ( data , data + data_size ) ; } std :: vector < int > const build_vector ( ) { typedef std :: vector < int > int_vector ; static int_vector data = init_vector ( ) ; int_vector :: size_type const size = data . size ( ) ; int_vector :: iterator it = data . begin ( ) ; int_vector :: iterator const end = data . end ( ) ; for ( ; it != end ; ++ it ) * it += size ; return data ; } int main ( ) { BOOST_STATIC_ASSERT ( ( ! phx :: stl :: has_@@ mapped_type < std :: multiset < int > > :: value ) ) ; BOOST_STATIC_ASSERT ( ( phx :: stl :: has_@@ key_type < std :: multiset < int > > :: value ) ) ; std :: multiset < int > const data = build_multiset ( ) ; test_begin ( data ) ; test_clear ( data ) ; test_empty ( data ) ; test_end ( data ) ; test_set_@@ erase ( data ) ; test_get_@@ allocator ( data ) ; return boost :: report_@@ errors ( ) ; } </DOCUMENT>
<DOCUMENT_ID="w@@ ilton@@ lazar@@ y/arangodb/tree/master/3rdParty/boost/@@ 1.6@@ 1.0/libs/@@ math@@ /test/compile_@@ test/sf_@@ hypo@@ t_inc@@ l_test.cpp"> # include < boost / math / special_functions / hypot . hpp > # include " test _ compile _ result . hpp " void compile_@@ and_link_@@ test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="P@@ umpuli/@@ multit@@ hefta@@ uto/tree/master/vend@@ or/@@ cegui@@ -0.@@ 4.0@@ -custom@@ /Widget@@ Sets/@@ Falagard/src/FalCheckbox@@ .cpp"> # include " StdInc . h " # include " FalCheckbox . h " # include " falagard / CEGUIFalWidgetLook@@ Manager . h " # include " falagard / CEGUIFalWidgetLook@@ Feel . h " namespace CEGUI { const utf8 FalagardCheckbox :: WidgetTypeName [ ] = " Falagard / Checkbox " ; FalagardCheckbox :: FalagardCheckbox ( const String & type , const String & name ) : Checkbox ( type , name ) { } FalagardCheckbox :: ~ FalagardCheckbox ( ) { } void FalagardCheckbox :: drawSelf ( float z ) { Checkbox :: drawSelf ( z ) ; Window :: drawSelf ( z ) ; } void FalagardCheckbox :: drawNormal ( float z ) { doButtonRender ( d_selected ? " SelectedNormal " : " Normal " ) ; } void FalagardCheckbox :: drawHover ( float z ) { doButtonRender ( d_selected ? " SelectedHover " : " Hover " ) ; } void FalagardCheckbox :: drawPushed ( float z ) { doButtonRender ( d_selected ? " SelectedPushed " : " Pushed " ) ; } void FalagardCheckbox :: drawDisabled ( float z ) { doButtonRender ( d_selected ? " SelectedDisabled " : " Disabled " ) ; } void FalagardCheckbox :: doButtonRender ( const String & state ) { if ( d_needsRedraw ) { const StateImagery * imagery ; d_render@@ Cache . clearCached@@ Imagery ( ) ; d_needsRedraw = false ; try { const WidgetLook@@ Feel & wlf = WidgetLook@@ Manager :: getSingleton ( ) . getWidget@@ Look ( d_look@@ Name ) ; imagery = wlf . isState@@ Imager@@ yPresent ( state ) ? & wlf . getStateImagery ( state ) : d_selected ? & wlf . getStateImagery ( " SelectedNormal " ) : & wlf . getStateImagery ( " Normal " ) ; } catch ( UnknownObjectException ) { return ; } imagery -> render ( * this ) ; } } Window * FalagardCheckboxFactory :: createWindow ( const String & name ) { return new FalagardCheckbox ( d_type , name ) ; } void FalagardCheckboxFactory :: destroy@@ Window ( Window * window ) { delete window ; } } </DOCUMENT>
<DOCUMENT_ID="Code@@ DJ@@ /qt5-h@@ idpi@@ /tree/master/qt@@ /qtdeclarative@@ /src/quick@@ /util@@ /qquickanimator@@ controller@@ .cpp"> # include " qquickanimator@@ controller _ p . h " # include < private / qquick@@ window_p . h > # include < private / qsgr@@ enderloop@@ _p . h > # include < private / qanimation@@ groupjob@@ _p . h > # include < QtGui / qscreen . h > # include < QtCore / qcore@@ application . h > QT_BEGIN_NAMESPACE QQuickAnimatorController :: QQuickAnimatorController ( ) : m_window ( 0 ) { } QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controller@@ WasDeleted ( ) ; qDelete@@ All ( m_animatorRoots . keys ( ) ) ; foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } } void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; } void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; } static void qquick_initialize_helper ( QAbstractAnimationJob * job , QQuickAnimatorController * c ) { if ( job -> isRenderThreadJob ( ) ) { QQuickAnimatorJob * j = static_cast < QQuickAnimatorJob * > ( job ) ; if ( ! j -> target ( ) ) { return ; } else if ( c -> m_deletedSinceLastFrame . contains ( j -> target ( ) ) ) { j -> targetWasDeleted ( ) ; } else { j -> addAnimationChangeListener ( c , QAbstractAnimationJob :: StateChange ) ; j -> initialize ( c ) ; } } else if ( job -> isGroup ( ) ) { QAnimationGroupJob * g = static_cast < QAnimationGroupJob * > ( job ) ; for ( QAbstractAnimationJob * a = g -> firstChild ( ) ; a ; a = a -> nextSibling ( ) ) qquick_initialize_helper ( a , c ) ; } } void QQuickAnimatorController :: before@@ NodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedBy@@ Controller ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; } void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUn@@ ifor@@ m ( ) && job -> target ( ) ) static_cast < QQuickUniform@@ AnimatorJob * > ( job ) -> afterNodeSync ( ) ; } } void QQuickAnimatorController :: animation@@ Finished ( QAbstractAnimationJob * job ) { if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; } } void QQuickAnimatorController :: animation@@ StateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeen@@ Running ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } } void QQuickAnimatorController :: requestSync ( ) { m_window -> may@@ beUpdate ( ) ; } void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: stop@@ Job ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; } void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="carvalhomb/tsmells/tree/master/sample/poco/poco/@@ Net/src/ICMP@@ Packet.cpp"> # include " Poco / Net / ICMPPacket . h " # include " Poco / Net / ICMPv4PacketImpl . h " # include " Poco / Net / NetException . h " # include " Poco / Timestamp . h " # include " Poco / Timespan . h " # include " Poco / Process . h " # include " Poco / NumberFormatter . h " # include < sstream > using Poco :: InvalidArgumentException ; using Poco :: NotImplementedException ; using Poco :: Timestamp ; using Poco :: Timespan ; using Poco :: Process ; using Poco :: NumberFormatter ; using Poco :: UInt8 ; using Poco :: UInt16 ; using Poco :: Int32 ; namespace Poco { namespace Net { ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; # if POCO_HAVE_@@ IPv6 else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; # endif else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; } ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; } void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; } int ICMPPacket :: getDataSize ( ) const { return _pImpl -> getDataSize ( ) ; } int ICMPPacket :: packetSize ( ) const { return _pImpl -> packetSize ( ) ; } int ICMPPacket :: maxPacketSize ( ) const { return _pImpl -> maxPacketSize ( ) ; } const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; } struct timeval ICMPPacket :: time ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> time ( buffer , length ) ; } bool ICMPPacket :: validReplyID ( Poco :: UInt8 * buffer , int length ) const { return _pImpl -> validReplyID ( buffer , length ) ; } std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; } std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; } } } </DOCUMENT>
<DOCUMENT_ID="aust@@ inzh@@ eng/swift@@ /tree/master/lib/@@ SILOptim@@ izer/IPO@@ /LetPropertiesOpt@@ s.cpp"> # define DEBUG_TYPE " let - properties - opt " # include " swift / SIL / DebugUtils . h " # include " swift / SIL / InstructionUtils . h " # include " swift / SIL / SILBasicBlock . h " # include " swift / SIL / SILInstruction . h " # include " swift / SIL / SILLink@@ age . h " # include " swift / SILOptimizer / PassManager / Passes . h " # include " swift / SILOptimizer / PassManager / Transforms . h " # include " swift / SILOptimizer / Utils / Local . h " # include " llvm / ADT / MapVector . h " # include " llvm / Support / CommandLine . h " # include " llvm / Support / Debug . h " using namespace swift ; namespace { using InstructionList = SmallVector < SILInstruction * , 8 > ; struct InitSequence { InstructionList Instructions ; SILValue Result ; bool isValid ( ) const { return ( bool ) Result ; } } ; class LetPropertiesOpt { SILModule * Module ; typedef SmallVector < VarDecl * , 4 > Properties ; llvm :: SetVector < SILFunction * > ChangedFunctions ; llvm :: MapVector < VarDecl * , InstructionList > AccessMap ; llvm :: MapVector < VarDecl * , InitSequence > InitMap ; llvm :: SmallPtrSet < VarDecl * , 16 > SkipProcessing ; llvm :: SmallPtrSet < NominalTypeDecl * , 16 > SkipTypeProcessing ; llvm :: SmallPtrSet < VarDecl * , 16 > CannotRemove ; llvm :: MapVector < NominalTypeDecl * , Properties > NominalTypeLetProperties ; llvm :: SmallPtrSet < VarDecl * , 16 > PotentialConstantLetProperty ; public : LetPropertiesOpt ( SILModule * M ) : Module ( M ) { } void run ( SILModuleTransform * T ) ; protected : bool isConstantLetProperty ( VarDecl * Property ) ; void collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) ; void collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) ; void optimizeLetPropertyAccess ( VarDecl * SILG , const InitSequence & Init ) ; bool analyzeInitValue ( SILInstruction * I , VarDecl * Prop ) ; } ; class InitSequenceCloner : public SILClonerWithScopes < InitSequenceCloner > { friend class SILInstruction@@ Visitor < InitSequenceCloner > ; friend class SILCloner < InitSequenceCloner > ; const InitSequence & Init ; SILInstruction * DestIP ; public : InitSequenceCloner ( const InitSequence & init , SILInstruction * destIP ) : SILClonerWithScopes ( * destIP -> getFunction ( ) ) , Init ( init ) , DestIP ( destIP ) { } void process ( SILInstruction * I ) { visit ( I ) ; } SILBasicBlock * remap@@ BasicBlock ( SILBasicBlock * BB ) { return BB ; } SILValue getMappedValue ( SILValue Value ) { return SILCloner < InitSequenceCloner > :: getMappedValue ( Value ) ; } void postProcess ( SILInstruction * orig , SILInstruction * cloned ) { DestIP -> getParent ( ) -> push_front ( cloned ) ; cloned -> moveBefore ( DestIP ) ; SILClonerWithScopes < InitSequenceCloner > :: postProcess ( orig , cloned ) ; } SILValue clone ( ) { for ( auto I : Init . Instructions ) process ( I ) ; return getMappedValue ( Init . Result ) ; } } ; } # ifndef NDEBUG static raw_ostream & operator << ( raw_ostream & OS , const VarDecl & decl ) { auto * Ty = dyn_cast < NominalTypeDecl > ( decl . getDeclContext ( ) ) ; if ( Ty ) OS << Ty -> getName ( ) << " : : " ; OS << decl . getName ( ) ; return OS ; } # endif void LetPropertiesOpt :: optimizeLetPropertyAccess ( VarDecl * Property , const InitSequence & init ) { assert ( init . isValid ( ) ) ; if ( SkipProcessing . count ( Property ) ) return ; auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( SkipTypeProcessing . count ( Ty ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Repla@@ cing ▁ access ▁ to ▁ property ▁ ' " << * Property << " ' ▁ by ▁ its ▁ constant ▁ initializer \n " ) ; auto PropertyAccess = Property -> getEffectiveAccess ( ) ; auto TypeAccess = Ty -> getEffectiveAccess ( ) ; auto CanRemove = false ; if ( TypeAccess <= AccessLevel :: FilePrivate || PropertyAccess <= AccessLevel :: FilePrivate || ( ( TypeAccess <= AccessLevel :: Internal || PropertyAccess <= AccessLevel :: Internal ) && Module -> isWholeModule ( ) ) ) { CanRemove = true ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Storage ▁ for ▁ property ▁ ' " << * Property << " ' ▁ can ▁ be ▁ elimin@@ ated \n " ) ; } if ( CannotRemove . count ( Property ) ) CanRemove = false ; if ( ! AccessMap . count ( Property ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ never ▁ read \n " ) ; if ( CanRemove ) { } return ; } auto & Loads = AccessMap [ Property ] ; unsigned NumReplaced = 0 ; for ( auto Load : Loads ) { SILFunction * F = Load -> getFunction ( ) ; auto cloneInitAt = [ & ] ( SILInstruction * insertionPoint ) -> SILValue { InitSequenceCloner cloner ( init , insertionPoint ) ; return cloner . clone ( ) ; } ; if ( isa < RefElementAddrInst > ( Load ) || isa < StructElementAddrInst > ( Load ) || isa < BeginAccessInst > ( Load ) ) { auto proj = cast < SingleValueInstruction > ( Load ) ; SILValue clonedInit = cloneInitAt ( proj ) ; SILBuilder@@ WithScope B ( proj ) ; for ( auto UI = proj -> use_begin ( ) , E = proj -> use_end ( ) ; UI != E ; ) { auto * User = UI -> getUser ( ) ; ++ UI ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( isa < StoreInst > ( User ) ) continue ; replaceLoadSequence ( User , clonedInit , B ) ; erase@@ Uses@@ OfInstruction ( User ) ; User -> eraseFromParent ( ) ; ++ NumReplaced ; } ChangedFunctions . insert ( F ) ; } else if ( auto proj = dyn_cast < StructExtractInst > ( Load ) ) { SILValue clonedInit = cloneInitAt ( proj ) ; proj -> replaceAllUses@@ With ( clonedInit ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced : \n " ; clonedInit -> dumpInContext ( ) ) ; proj -> eraseFromParent ( ) ; ++ NumReplaced ; ChangedFunctions . insert ( F ) ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced ▁ " << NumReplaced << " ▁ time ( s ) \n " ) ; if ( CanRemove ) { } } static bool isStructurallyIdentical ( SILValue LHS , SILValue RHS ) { if ( LHS == RHS ) return true ; if ( LHS -> getType ( ) != RHS -> getType ( ) ) return false ; auto lResult = LHS -> getDefiningInstructionResult ( ) ; auto rResult = RHS -> getDefiningInstructionResult ( ) ; assert ( lResult && rResult && " operands ▁ of ▁ instructions ▁ appro@@ ved ▁ by ▁ analyzeStaticInitializer ▁ " " should ▁ always ▁ be ▁ defined ▁ by ▁ instructions " ) ; return ( lResult -> ResultIndex == rResult -> ResultIndex && lResult -> Instruction -> isIdentical@@ To ( rResult -> Instruction , isStructurallyIdentical ) ) ; } ; static bool isSameInitSequence ( const InitSequence & LHS , const InitSequence & RHS ) { assert ( LHS . isValid ( ) && RHS . isValid ( ) ) ; return isStructurallyIdentical ( LHS . Result , RHS . Result ) ; } static bool isAssignableExternally ( VarDecl * Property , SILModule * Module ) { if ( Module -> isVisible@@ Externally ( Property ) ) { auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( isa < ClassDecl > ( Ty ) ) return false ; for ( auto SP : Ty -> getStoredProperties ( ) ) { auto storedPropertyAccess = SP -> getEffectiveAccess ( ) ; if ( storedPropertyAccess <= AccessLevel :: FilePrivate || ( storedPropertyAccess <= AccessLevel :: Internal && Module -> isWholeModule ( ) ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ cannot ▁ be ▁ set ▁ externally \n " ) ; return false ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ can ▁ be ▁ used ▁ externally \n " ) ; return true ; } return false ; } static bool mayHaveUnknownUses ( VarDecl * Property , SILModule * Module ) { if ( Property -> getDeclContext ( ) -> getParent@@ Module ( ) != Module -> getSw@@ iftModule ( ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ is ▁ defined ▁ in ▁ a ▁ differ@@ ent ▁ module \n " ) ; return true ; } if ( isAssignableExternally ( Property , Module ) ) { return true ; } return false ; } bool LetPropertiesOpt :: isConstantLetProperty ( VarDecl * Property ) { if ( ! Property -> isLet ( ) || Property -> isStatic ( ) ) return false ; if ( SkipProcessing . count ( Property ) ) return false ; if ( PotentialConstantLetProperty . count ( Property ) ) return true ; if ( mayHaveUnknownUses ( Property , Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ may ▁ have ▁ unknown ▁ uses \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ has ▁ no ▁ unknown ▁ uses \n " ) ; if ( ! isSimple@@ Type ( Module -> Types . getLower@@ edType ( Property -> getType ( ) ) , * Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ not ▁ of ▁ triv@@ ial ▁ type \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } PotentialConstantLetProperty . insert ( Property ) ; return true ; } static bool isProjectionOfProperty ( SILValue addr , VarDecl * Property ) { if ( auto * REA = dyn_cast < RefElementAddrInst > ( addr ) ) { return REA -> getField ( ) == Property ; } if ( auto * SEA = dyn_cast < StructElementAddrInst > ( addr ) ) { return SEA -> getField ( ) == Property ; } return false ; } bool LetPropertiesOpt :: analyzeInitValue ( SILInstruction * I , VarDecl * Property ) { SILValue value ; if ( auto SI = dyn_cast < StructInst > ( I ) ) { value = SI -> getField@@ Value ( Property ) ; } else if ( auto SI = dyn_cast < StoreInst > ( I ) ) { auto Dest = stripAddressAccess ( SI -> getDest ( ) ) ; assert ( isProjectionOfProperty ( stripAddressAccess ( SI -> getDest ( ) ) , Property ) && " Store ▁ instruction ▁ should ▁ store ▁ into ▁ a ▁ proper ▁ let ▁ property " ) ; ( void ) Dest ; value = SI -> getSrc ( ) ; } if ( auto * LI = dyn_cast < LoadInst > ( value ) ) { SILValue addr = LI -> getOperand ( ) ; if ( isProjectionOfProperty ( addr , Property ) ) return true ; } InitSequence sequence ; sequence . Result = value ; if ( ! analyzeStaticInitializer ( value , sequence . Instructions ) ) return false ; auto & cachedSequence = InitMap [ Property ] ; if ( cachedSequence . isValid ( ) && ! isSameInitSequence ( cachedSequence , sequence ) ) { return false ; } else { LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ property ▁ ' " << * Property << " ' ▁ is ▁ statically ▁ known ▁ so ▁ far \n " ) ; cachedSequence = std :: move ( sequence ) ; return true ; } } void LetPropertiesOpt :: collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) { auto structDecl = SI -> getStruct@@ Decl ( ) ; if ( SkipTypeProcessing . count ( structDecl ) ) return ; if ( ! NominalTypeLetProperties . count ( structDecl ) ) { SmallVector < VarDecl * , 4 > LetProps ; for ( auto Prop : structDecl -> getStoredProperties ( ) ) { if ( ! isConstantLetProperty ( Prop ) ) continue ; LetProps . push_back ( Prop ) ; } if ( LetProps . empty ( ) ) { SkipTypeProcessing . insert ( structDecl ) ; return ; } NominalTypeLetProperties [ structDecl ] = LetProps ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Computed ▁ set ▁ of ▁ let ▁ properties ▁ for ▁ struct ▁ ' " << structDecl -> getName ( ) << " ' \n " ) ; } auto & Props = NominalTypeLetProperties [ structDecl ] ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Found ▁ a ▁ struct ▁ instruction ▁ initializing ▁ some ▁ " " let ▁ properties : ▁ " ; SI -> dumpInContext ( ) ) ; for ( auto Prop : Props ) { if ( SkipProcessing . count ( Prop ) ) continue ; SILValue PropValue = SI -> getOper@@ andForField ( Prop ) -> get ( ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Check ▁ the ▁ value ▁ of ▁ property ▁ ' " << * Prop << " ' ▁ : " << PropValue << " \n " ) ; if ( ! analyzeInitValue ( SI , Prop ) ) { SkipProcessing . insert ( Prop ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ a ▁ let ▁ property ▁ ' " << * Prop << " ' ▁ is ▁ not ▁ statically ▁ known \n " ) ; } ( void ) PropValue ; } } static bool isValidPropertyLoad ( SILInstruction * I ) { if ( isa < LoadInst > ( I ) ) return true ; if ( isa < StructElementAddrInst > ( I ) || isa < Tup@@ leElementAddrInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { if ( isIncidentalUse ( Use -> getUser ( ) ) ) continue ; if ( ! isValidPropertyLoad ( Use -> getUser ( ) ) ) return false ; } return true ; } return false ; } void LetPropertiesOpt :: collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) { if ( ! isConstantLetProperty ( Property ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Collecting ▁ property ▁ access ▁ for ▁ property ▁ ' " << * Property << " ' : \n " ; llvm :: dbgs ( ) << " The ▁ instructions ▁ are : \n " ; I -> dumpInContext ( ) ) ; if ( isa < RefElementAddrInst > ( I ) || isa < StructElementAddrInst > ( I ) || isa < BeginAccessInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { auto * User = Use -> getUser ( ) ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( auto * SI = dyn_cast < StoreInst > ( User ) ) { if ( SI -> getDest ( ) != projection || ! analyzeInitValue ( SI , Property ) ) { SkipProcessing . insert ( Property ) ; return ; } continue ; } if ( ! isValidPropertyLoad ( User ) ) { SkipProcessing . insert ( Property ) ; return ; } } } AccessMap [ Property ] . push_back ( I ) ; if ( NonRemovable ) CannotRemove . insert ( Property ) ; } void LetPropertiesOpt :: run ( SILModuleTransform * T ) { for ( auto & F : * Module ) { bool NonRemovable = ! F . shouldOptim@@ ize ( ) ; for ( auto & BB : F ) { for ( auto & I : BB ) if ( auto * BAI = dyn_cast < BeginAccessInst > ( & I ) ) { if ( auto * REAI = dyn_cast < RefElementAddrInst > ( stripAddressAccess ( BAI ) ) ) { collectPropertyAccess ( BAI , REAI -> getField ( ) , NonRemovable ) ; } } else if ( auto * REAI = dyn_cast < RefElementAddrInst > ( & I ) ) { collectPropertyAccess ( REAI , REAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEI = dyn_cast < StructExtractInst > ( & I ) ) { collectPropertyAccess ( SEI , SEI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEAI = dyn_cast < StructElementAddrInst > ( & I ) ) { collectPropertyAccess ( SEAI , SEAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SI = dyn_cast < StructInst > ( & I ) ) { collectStructPropertiesAccess ( SI , NonRemovable ) ; } } } for ( auto & Init : InitMap ) { optimizeLetPropertyAccess ( Init . first , Init . second ) ; } for ( SILFunction * ChangedFn : ChangedFunctions ) { T -> invalidate@@ Analysis ( ChangedFn , SILAnalysis :: InvalidationKind :: Instructions ) ; } } namespace { class LetPropertiesOptPass : public SILModuleTransform { void run ( ) override { LetPropertiesOpt ( getModule ( ) ) . run ( this ) ; } } ; } SILTransform * swift :: createLetPropertiesOpt ( ) { return new LetPropertiesOptPass ( ) ; } </DOCUMENT>
<DOCUMENT_ID="h@@ 0tw@@ 1r3@@ /m@@ ame/tree/master/src/@@ mame@@ /video@@ /m@@ ikromi@@ k.cpp"> # include " includes / mikromi@@ k . h " # define HORIZONTAL_CHARACTER_PIXELS 10 I8275_@@ DRAW_CHARACTER_@@ MEMBER ( mm1_state :: crtc_display_pixels ) { UINT8 romdata = m_char@@ _rom -> base ( ) [ ( charcode << 4 ) | linecount ] ; int gpa0 = BIT ( gpa , 0 ) ; int llen = m_llen ; int compl_in = rvv ; int hlt_in = hl@@ gt ; int color ; int i , qh , video_in ; int d7 = BIT ( romdata , 7 ) ; int d6 = BIT ( romdata , 6 ) ; int d0 = BIT ( romdata , 0 ) ; UINT8 data = ( romdata << 1 ) | ( d7 & d0 ) ; if ( y < 360 || x >= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0 ) { if ( HORIZONTAL_CHARACTER_PIXELS == 10 ) { qh = d7 & d6 ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + 8 ) = m_palette -> pen ( color ) ; bitmap . pix32 ( y , x + 9 ) = m_palette -> pen ( color ) ; } for ( i = 0 ; i < 8 ; ++ i ) { qh = BIT ( data , i ) ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + i ) = m_palette -> pen ( color ) ; } } } static ADDRESS_MAP@@ _START ( mm1_upd7220_map , AS_0 , 16 , mm1_state ) ADDRESS_MAP_@@ GLOBAL_@@ MASK ( 0x7fff ) AM_RANGE ( 0x0000 , 0x7fff ) AM_RA@@ M AM_SHAR@@ E ( " video _ ram " ) ADDRESS_MAP_@@ END UPD7220_DISPLAY_PIXELS_@@ MEMBER ( mm1_state :: hgdc_display_pixels ) { UINT16 data = m_video_@@ ram [ address >> 1 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( BIT ( data , i ) ) bitmap . pix32 ( y , x + i ) = m_palette -> pen ( 2 ) ; } } UINT32 mm1_state :: screen_update ( screen_@@ device & screen , bitmap@@ _rgb@@ 32 & bitmap , const rectangle & cliprect ) { m_cr@@ tc -> screen_update ( screen , bitmap , cliprect ) ; m_hgdc -> screen_update ( screen , bitmap , cliprect ) ; return 0 ; } static const gf@@ x_layout charlayout = { 8 , 16 , RGN_FRA@@ C ( 1 , 1 ) , 1 , { 0 } , { 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 } , { 0 * 8 , 1 * 8 , 2 * 8 , 3 * 8 , 4 * 8 , 5 * 8 , 6 * 8 , 7 * 8 , 8 * 8 , 9 * 8 , 10 * 8 , 11 * 8 , 12 * 8 , 13 * 8 , 14 * 8 , 15 * 8 } , 8 * 16 } ; static GFXDECODE_@@ START ( mm1 ) GFXDECODE_@@ ENTRY ( " charg@@ en " , 0 , charlayout , 0 , 1 ) GFXDECODE_@@ END PALETTE_@@ INIT_MEMBER ( mm1_state , mm1 ) { palette . set_pen_color ( 0 , rgb_t ( 0x00 , 0x00 , 0x00 ) ) ; palette . set_pen_color ( 1 , rgb_t ( 0x00 , 0x7F , 0x0A ) ) ; palette . set_pen_color ( 2 , rgb_t ( 0x08 , 0xD0 , 0x1A ) ) ; } MACHINE_CONFIG_@@ FRAGMENT ( mm1m@@ 6_@@ video ) MCFG_SCREEN_@@ ADD ( SCREEN_TAG , RAS@@ TER ) MCFG_SCREEN_@@ REFRES@@ H_RATE ( 50 ) MCFG_SCREEN_@@ UPDATE_@@ DRI@@ VER ( mm1_state , screen_update ) MCFG_S@@ CREEN_SIZE ( 800 , 375 ) MCFG_SCREEN_@@ VISIBLE_@@ AREA ( 0 , 800 - 1 , 0 , 375 - 1 ) MCFG_GFXDECODE_@@ ADD ( " gfx@@ decode " , " palette " , mm1 ) MCFG_PALETTE_@@ ADD ( " palette " , 3 ) MCFG_PALETTE_@@ INIT_OWNER ( mm1_state , mm1 ) MCFG_DEVICE_ADD ( I8275_@@ TAG , I8275 , XTAL_18_720MHz / 8 ) MCFG_I8275_@@ CHARACTER_WID@@ TH ( HORIZONTAL_CHARACTER_PIXELS ) MCFG_I8275_@@ DRAW_CHARACTER_@@ CALLBACK_OWNER ( mm1_state , crtc_display_pixels ) MCFG_I8275_@@ DRQ_@@ CALLBACK ( DEVWRITELINE ( I8237_TAG , am9517@@ a_device , dreq@@ 0_@@ w ) ) MCFG_I8275_@@ VRTC_CALLBACK ( DEVWRITELINE ( UPD7220_TAG , upd7220_@@ device , ext_syn@@ c_w ) ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MCFG_DEVICE_ADD ( UPD7220_TAG , UPD@@ 7220 , XTAL_18_720MHz / 8 ) MCFG_DEVICE_@@ ADDRESS_MAP ( AS_0 , mm1_upd7220_map ) MCFG_UPD7220_DISPLAY_PIXELS_@@ CALLBACK_OWNER ( mm1_state , hgdc_display_pixels ) MCFG_VIDEO_SET_SCREEN ( SCREEN_TAG ) MACHINE_CONFIG_@@ END </DOCUMENT>
<DOCUMENT_ID="root-@@ mirror@@ /root@@ /tree/master/interpreter/llvm/src/@@ tools/@@ llvm-@@ pdbutil/@@ Pretty@@ ExternalSymbol@@ Dumper.cpp"> # include " Pretty@@ ExternalSymbolDumper . h " # include " LinePrinter . h " # include " llvm / DebugInfo / PDB / PDBSymbolExe . h " # include " llvm / DebugInfo / PDB / PDBSymbolPublicSymbol . h " # include " llvm / Support / Format . h " using namespace llvm ; using namespace llvm :: pdb ; ExternalSymbolDumper :: ExternalSymbolDumper ( LinePrinter & P ) : PDBSymDumper ( true ) , Printer ( P ) { } void ExternalSymbolDumper :: start ( const PDBSymbolExe & Symbol ) { auto Vars = Symbol . findAll@@ Children < PDBSymbolPublicSymbol > ( ) ; while ( auto Var = Vars -> getNext ( ) ) Var -> dump ( * this ) ; } void ExternalSymbolDumper :: dump ( const PDBSymbolPublicSymbol & Symbol ) { std :: string LinkageName = Symbol . getName ( ) ; if ( Printer . IsSymbol@@ Exclu@@ ded ( LinkageName ) ) return ; Printer . NewLine ( ) ; uint64_t Addr = Symbol . getVirtual@@ Address ( ) ; Printer << " [ " ; WithColor ( Printer , PDB_ColorItem :: Address ) . get ( ) << format_he@@ x ( Addr , 10 ) ; Printer << " ] ▁ " ; WithColor ( Printer , PDB_ColorItem :: Identifier ) . get ( ) << LinkageName ; } </DOCUMENT>
<DOCUMENT_ID="dead@@ coda/@@ arg3db@@ /tree/master/src/sqlite@@ /result@@ set.cpp"> # include " resultset . h " # include " . . / exception . h " # include " row . h " # include " session . h " using namespace std ; namespace coda { namespace db { namespace sqlite { resultset :: resultset ( const std :: shared_ptr < sqlite :: session > & sess , const shared_ptr < sqlite3_@@ stmt > & stmt ) : stmt_ ( stmt ) , sess_ ( sess ) , status_ ( - 1 ) { if ( sess_ == nullptr ) { throw database_exception ( " No ▁ database ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } if ( stmt_ == nullptr ) { throw database_exception ( " no ▁ state@@ ment ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } } resultset :: resultset ( resultset && other ) : stmt_ ( std :: move ( other . stmt_ ) ) , sess_ ( std :: move ( other . sess_ ) ) , status_ ( other . status_ ) { other . sess_ = nullptr ; other . stmt_ = nullptr ; } resultset :: ~ resultset ( ) { } resultset & resultset :: operator = ( resultset && other ) { stmt_ = std :: move ( other . stmt_ ) ; sess_ = std :: move ( other . sess_ ) ; status_ = other . status_ ; other . sess_ = nullptr ; other . stmt_ = nullptr ; return * this ; } bool resultset :: is_valid ( ) const noexcept { return stmt_ != nullptr && stmt_ ; } bool resultset :: next ( ) { if ( ! is_valid ( ) ) { return false ; } if ( status_ == SQLITE_@@ DONE ) { return false ; } status_ = sqlite3_@@ step ( stmt_ . get ( ) ) ; return status_ == SQLITE_@@ ROW ; } void resultset :: reset ( ) { if ( ! is_valid ( ) ) { return ; } if ( sqlite3_@@ reset ( stmt_ . get ( ) ) != SQLITE_@@ OK ) { throw database_exception ( sess_ -> last_error ( ) ) ; } status_ = - 1 ; } resultset :: row_type resultset :: current_row ( ) { return row_type ( make_shared < row > ( sess_ , stmt_ ) ) ; } } } } </DOCUMENT>
