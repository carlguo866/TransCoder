MP4DmaxAtom :: MP4DmaxAtom ( ) : MP4@@ Atom ( " dmax " ) { AddProperty ( new MP4@@ Integer32Property ( " milli@@ Secs " ) ) ; }
void Pipeline :: setStaticPerPixel ( int gx , int gy ) { staticPerPixel = true ; this -> gx = gx ; this -> gy = gy ; this -> x_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> x_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } this -> y_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> y_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } }
Pipeline :: ~ Pipeline ( ) { if ( staticPerPixel ) { for ( int x = 0 ; x < this -> gx ; x ++ ) { free ( this -> x_mesh [ x ] ) ; free ( this -> y_mesh [ x ] ) ; } free ( x_mesh ) ; free ( y_mesh ) ; } }
PixelPoint Pipeline :: PerPixel ( PixelPoint p , const PerPixelContext context ) { return p ; }
void Driver_Document :: SetFile ( const std :: string & theFileName ) { myFile = theFileName ; }
void Driver_Document :: SetDocument ( SMES@@ HDS_@@ Document * theDocument ) { myDocument = theDocument ; }
eInputContentString :: eInputContentString ( ) { m_string = " bla " ; m_cursor = 0 ; m_input = 0 ; m_len = m_string . size ( ) ; }
void eInputContentString :: getDisplay ( std :: string & res , int & cursor ) { res = m_string ; cursor = m_cursor ; }
void eInputContentString :: moveCursor ( int dir ) { int old_cursor = m_cursor ; switch ( dir ) { case dirLeft : -- m_cursor ; break ; case dirRight : ++ m_cursor ; break ; case dirHome : m_cursor = 0 ; break ; case dirEnd : m_cursor = m_len ; break ; } if ( m_cursor < 0 ) m_cursor = 0 ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_cursor != old_cursor ) if ( m_input ) m_input -> invalidate ( ) ; }
int eInputContentString :: haveKey ( int code , int overwrite ) { int have_char = - 1 ; if ( code >= 0x80@@ 20 ) have_char = code & ~ 0x8000 ; if ( have_char != - 1 ) { if ( overwrite && m_cursor < m_len ) m_string [ m_cursor ] = have_char ; else { m_string . insert ( m_cursor , 1 , have_char ) ; ++ m_len ; } m_cursor ++ ; ASSERT ( m_cursor <= m_len ) ; if ( m_input ) m_input -> invalidate ( ) ; return 1 ; } return 0 ; }
void eInputContentString :: deleteChar ( int dir ) { if ( dir == deleteForward ) { eDebug ( " forward " ) ; if ( m_cursor != m_len ) ++ m_cursor ; else return ; } if ( ! m_cursor ) return ; if ( ! m_len ) return ; m_string . erase ( m_cursor - 1 , m_cursor ) ; m_len -- ; m_cursor -- ; if ( m_input ) m_input -> invalidate ( ) ; }
int eInputContentString :: isValid ( ) { return 1 ; }
void eInputContentString :: setText ( const std :: string & str ) { m_string = str ; m_len = m_string . size ( ) ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_input ) m_input -> invalidate ( ) ; }
std :: string eInputContentString :: getText ( ) { return m_string ; }
void LocalCapture :: createAPC@@ Directory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWX@@ U | S_IRWX@@ G | S_I@@ ROTH | S_IX@@ OTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } }
void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeTo@@ Disk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; }
char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; }
int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IF@@ DIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedir ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; }
void LocalCapture :: copyImages ( ImageLink@@ List * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFile@@ Part ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } }
TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } }
TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; }
void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; }
void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummy@@ Listener ; }
void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; }
void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; }
void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; }
void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; }
void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; }
void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; }
void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; }
void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; }
void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; }
void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; }
void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; }
void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; }
void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; }
void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; }
void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; }
void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; }
void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; }
void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; }
void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; }
void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; }
void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; }
void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; }
void TestTracker :: countWarning ( ) { ++ _warnings ; }
void TestTracker :: countSkipped ( ) { ++ _skippedTests ; }
void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } }
void VM_CMS_Operation :: acquire_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: acquire@@ PLL ) ; }
void VM_CMS_Operation :: release_and_notify_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: release@@ AndNotify@@ PLL ) ; }
void VM_CMS_Operation :: verify_before_gc ( ) { if ( VerifyBefore@@ GC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ Before " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: heap ( ) -> prepare@@ _for_verify ( ) ; Universe :: verify ( ) ; } }
void VM_CMS_Operation :: verify_after_gc ( ) { if ( VerifyAfter@@ GC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ After " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: verify ( ) ; } }
bool VM_CMS_Operation :: doit_prologue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; if ( needs_pll ( ) ) { acquire_pending_list_lock ( ) ; } Heap_lock -> lock ( ) ; if ( lost_race ( ) ) { assert ( _prologue_succeeded == false , " Initialized ▁ in ▁ c ' tor " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } else { _prologue_succeeded = true ; } return _prologue_succeeded ; }
void VM_CMS_Operation :: doit_epilogue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } }
void VM_CMS_Initial_Mark :: doit ( ) { if ( lost_race ( ) ) { return ; } HS_DTRACE_PROBE ( hs_private , cms__initmark__begin ) ; HS_PRIVATE_CMS_INITMARK_@@ BEGIN ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_start ( " Initial ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_@@ initial_@@ mark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRoots@@ Initial , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; HS_DTRACE_PROBE ( hs_private , cms__initmark__end ) ; HS_PRIVATE_CMS_INITMARK_@@ END ( ) ; }
void VM_CMS_Final_Remark :: doit ( ) { if ( lost_race ( ) ) { return ; } HS_DTRACE_PROBE ( hs_private , cms__remark__begin ) ; HS_PRIVATE_CMS_REMARK_@@ BEGIN ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_start ( " Final ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_@@ final_remark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRoots@@ Final , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> save_@@ heap@@ _summar@@ y ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; HS_DTRACE_PROBE ( hs_private , cms__remark__end ) ; HS_PRIVATE_CMS_REMARK_@@ END ( ) ; }
void VM_GenCollectFullConcurrent :: doit ( ) { assert ( Thread :: current ( ) -> is_VM_thread ( ) , " Should ▁ be ▁ VM ▁ thread " ) ; assert ( GCLocker@@ InvokesConcurrent || ExplicitGCInvokesConcurrent , " Unexpected " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before == gch -> total_collections ( ) ) { assert ( SafepointSynchron@@ ize :: is_at_safepoint ( ) , " We ▁ can ▁ only ▁ be ▁ executing ▁ this ▁ arm ▁ of ▁ if ▁ at ▁ a ▁ safepoint " ) ; GCCauseSetter gccs ( gch , _gc_cause ) ; gch -> do_full_@@ collection ( gch -> must_@@ clear_al@@ l_so@@ ft_refs ( ) , 0 ) ; } assert ( ( _gc_count_before < gch -> total_collections ( ) ) || ( GC_locker :: is_active ( ) && ( _gc_count_before == gch -> total_collections ( ) ) ) , " total _ collections ( ) ▁ should ▁ be ▁ monot@@ onically ▁ increasing " ) ; MutexLockerEx x ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; assert ( _full_gc_count_before <= gch -> total_full_collections ( ) , " Error " ) ; if ( gch -> total_full_collections ( ) == _full_gc_count_before ) { CMSCollector :: disable_@@ icms ( ) ; _disabled_icms = true ; CMSCollector :: start_icms ( ) ; CMSCollector :: request_full_@@ gc ( _full_gc_count_before , _gc_cause ) ; } else { assert ( _full_gc_count_before < gch -> total_full_collections ( ) , " Error " ) ; FullGCCount_lock -> notify_all ( ) ; } }
void VM_GenCollectFullConcurrent :: doit_epilogue ( ) { Thread * thr = Thread :: current ( ) ; assert ( thr -> is_Java_thread ( ) , " just ▁ checking " ) ; JavaThread * jt = ( JavaThread * ) thr ; Heap_lock -> unlock ( ) ; release_and_notify_pending_list_lock ( ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_cause != GCCause :: _gc_locker && gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { assert ( _gc_cause == GCCause :: _jav@@ a_lan@@ g_system_@@ gc , " the ▁ only ▁ way ▁ to ▁ get ▁ here ▁ if ▁ this ▁ was ▁ a ▁ System . gc ( ) - induced ▁ GC " ) ; assert ( ExplicitGCInvokesConcurrent , " Error " ) ; ThreadToNative@@ FromVM native ( jt ) ; MutexLockerEx ml ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; while ( gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { FullGCCount_lock -> wait ( Mutex :: _no_safepoint_check_flag ) ; } } if ( _disabled_icms ) { CMSCollector :: enable_ic@@ ms ( ) ; } }
Node * CsClassFactory :: CreateNeuron ( std :: string strType , bool bThrowError ) { Node * lpNeuron = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURON@@ GROUP " ) lpNeuron = new CsNeuronGroup ; else if ( strType == " SPIKEGENER@@ ATOR@@ GROUP " ) lpNeuron = new CsSpikeGeneratorGroup ; else { lpNeuron = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalid@@ NeuronType , Cs_Err_strInvalid@@ NeuronType , " NeuronType " , strType ) ; } return lpNeuron ; } catch ( CStdErrorInfo oError ) { if ( lpNeuron ) delete lpNeuron ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpNeuron ) delete lpNeuron ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
AnimatSim :: Link * CsClassFactory :: CreateSynapse ( std :: string strType , bool bThrowError ) { AnimatSim :: Link * lpSynapse = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " ONETO@@ ONES@@ YNAPSE " ) lpSynapse = new CsSynapseOneToOne ; else if ( strType == " FULLSYNAPSE " ) lpSynapse = new CsSynapseFull ; else if ( strType == " RANDOMSYNAPSE " ) lpSynapse = new CsSynapseRandom ; else if ( strType == " INDI@@ VIDUAL@@ SYNAPSE " ) lpSynapse = new CsSynapseIndividual ; else if ( strType == " SPIKIN@@ GCURRENT@@ SYNAPSE " ) lpSynapse = new CsSpikingCurrentSynapse ; else { lpSynapse = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalid@@ SynapseType , Cs_Err_strInvalid@@ SynapseType , " SynapseType " , strType ) ; } return lpSynapse ; } catch ( CStdErrorInfo oError ) { if ( lpSynapse ) delete lpSynapse ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpSynapse ) delete lpSynapse ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
NeuralModule * CsClassFactory :: CreateNeuralModule ( std :: string strType , bool bThrowError ) { NeuralModule * lpModule = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " CAR@@ LSIM@@ NEURALMODULE " ) lpModule = new CsNeuralModule ; else { lpModule = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ NeuralModuleType , Al_Err_strInvalid@@ NeuralModuleType , " NeuralModule " , strType ) ; } return lpModule ; } catch ( CStdErrorInfo oError ) { if ( lpModule ) delete lpModule ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpModule ) delete lpModule ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
ExternalStimulus * CsClassFactory :: CreateExternalStimulus ( std :: string strType , bool bThrowError ) { ExternalStimulus * lpStimulus = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " FIRINGR@@ ATE " ) lpStimulus = new CsFiringRateStimulus ; else { lpStimulus = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ ExternalStimulusType , Al_Err_strInvalid@@ ExternalStimulusType , " ExternalStimulusType " , strType ) ; } return lpStimulus ; } catch ( CStdErrorInfo oError ) { if ( lpStimulus ) delete lpStimulus ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpStimulus ) delete lpStimulus ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
DataColumn * CsClassFactory :: CreateDataColumn ( std :: string strType , bool bThrowError ) { DataColumn * lpColumn = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURON@@ DATACOLUMN " ) lpColumn = new CsNeuronDataColumn ; else { lpColumn = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ DataColumnType , Al_Err_strInvalid@@ DataColumnType , " DataColumnType " , strType ) ; } return lpColumn ; } catch ( CStdErrorInfo oError ) { if ( lpColumn ) delete lpColumn ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpColumn ) delete lpColumn ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
Adapter * CsClassFactory :: CreateAdapter ( std :: string strType , bool bThrowError ) { Adapter * lpAdapter = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NODE@@ TONODE " ) lpAdapter = new CsAdapter ; else if ( strType == " PHYSICAL@@ TONODE " ) lpAdapter = new CsAdapter ; else { lpAdapter = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ AdapterType , Al_Err_strInvalid@@ AdapterType , " AdapterType " , strType ) ; } return lpAdapter ; } catch ( CStdErrorInfo oError ) { if ( lpAdapter ) delete lpAdapter ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpAdapter ) delete lpAdapter ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } }
CStdSerialize * CsClassFactory :: CreateObject ( std :: string strClassType , std :: string strObjectType , bool bThrowError ) { CStdSerialize * lpObject = NULL ; strClassType = Std_ToUpper ( Std_Trim ( strClassType ) ) ; if ( strClassType == " NEURON " ) lpObject = CreateNeuron ( strObjectType , bThrowError ) ; else if ( strClassType == " SYNAPSE " ) lpObject = CreateSynapse ( strObjectType , bThrowError ) ; else if ( strClassType == " NEURALMODULE " ) lpObject = CreateNeuralModule ( strObjectType , bThrowError ) ; else if ( strClassType == " EXTERNAL@@ STI@@ MULUS " ) lpObject = CreateExternalStimulus ( strObjectType , bThrowError ) ; else if ( strClassType == " DATACOLUMN " ) lpObject = CreateDataColumn ( strObjectType , bThrowError ) ; else if ( strClassType == " ADAPTER " ) lpObject = CreateAdapter ( strObjectType , bThrowError ) ; else { lpObject = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Std_Err_lInvalid@@ ClassType , Std_Err_strInvalid@@ ClassType , " ClassType " , strClassType ) ; } return lpObject ; }
StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMain@@ Widget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeader@@ Label ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarch@@ ical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItem@@ Changed ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; }
void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; }
void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) m_styleList -> setRootIsDecorated ( false ) ; else { m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } }
void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParent@@ Name ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; }
void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; }
void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefresh@@ SheetViews ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; }
void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> take@@ Style ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; }
void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; }
gSDLDC :: gSDLDC ( ) : m_pump ( eApp , 1 ) { if ( SDL_Init ( SDL_INIT_@@ VIDEO ) < 0 ) { eWarning ( " [ gSDLDC ] ▁ Could ▁ not ▁ initialize ▁ SDL : ▁ % s " , SDL_GetError ( ) ) ; return ; } setResolution ( 720 , 576 ) ; CONNECT ( m_pump . recv_msg , gSDLDC :: pumpEvent ) ; m_surface . type = 0 ; m_surface . clut . colors = 256 ; m_surface . clut . data = new gRGB [ m_surface . clut . colors ] ; m_pixmap = new gPixmap ( & m_surface ) ; memset ( m_surface . clut . data , 0 , sizeof ( * m_surface . clut . data ) * m_surface . clut . colors ) ; run ( ) ; }
gSDLDC :: ~ gSDLDC ( ) { pushEvent ( EV_QUIT ) ; kill ( ) ; SDL_Quit ( ) ; }
void gSDLDC :: keyEvent ( const SDL_Event & event ) { eSDLInputDriver * driver = eSDLInputDriver :: getInstance ( ) ; eDebug ( " [ gSDLDC ] ▁ Key ▁ % s : ▁ key = % d " , ( event . type == SDL_KEYDOWN ) ? " Down " : " Up " , event . key . keysym . sym ) ; if ( driver ) driver -> keyPressed ( & event . key ) ; }
void gSDLDC :: pumpEvent ( const SDL_Event & event ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : keyEvent ( event ) ; break ; case SDL_QUIT : eDebug ( " [ gSDLDC ] ▁ Quit " ) ; extern void quitMainloop ( int exit_@@ code ) ; quitMainloop ( 0 ) ; break ; } }
void gSDLDC :: pushEvent ( enum event code , void * data1 , void * data2 ) { SDL_Event event ; event . type = SDL_USEREVENT ; event . user . code = code ; event . user . data1 = data1 ; event . user . data2 = data2 ; SDL_PushEvent ( & event ) ; }
void gSDLDC :: exec ( const gOpcode * o ) { switch ( o -> opcode ) { case gOpcode :: flush : pushEvent ( EV_FLIP ) ; eDebug ( " [ gSDLDC ] ▁ FLUSH " ) ; break ; default : gDC :: exec ( o ) ; break ; } }
void gSDLDC :: setResolution ( int xres , int yres ) { pushEvent ( EV_SET_VIDEO_MODE , ( void * ) xres , ( void * ) yres ) ; }
void gSDLDC :: evSetVideoMode ( unsigned long xres , unsigned long yres ) { m_screen = SDL_SetVideoMode ( xres , yres , 32 , SDL_HWSURFACE ) ; if ( ! m_screen ) { eF@@ atal ( " [ gSDLDC ] ▁ Could ▁ not ▁ create ▁ SDL ▁ surface : ▁ % s " , SDL_GetError ( ) ) ; return ; } m_surface . x = m_screen -> w ; m_surface . y = m_screen -> h ; m_surface . bpp = m_screen -> format -> BitsPerPixel ; m_surface . byp@@ p = m_screen -> format -> BytesPerPixel ; m_surface . stride = m_screen -> pitch ; m_surface . data = m_screen -> pixels ; SDL_Enable@@ UNICODE ( 1 ) ; }
void gSDLDC :: evFlip ( ) { SDL_Flip ( m_screen ) ; }
void gSDLDC :: thread ( ) { hasStarted ( ) ; bool stop = false ; while ( ! stop ) { SDL_Event event ; if ( SDL_Wait@@ Event ( & event ) ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : case SDL_QUIT : m_pump . send ( event ) ; break ; case SDL_USEREVENT : switch ( event . user . code ) { case EV_SET_VIDEO_MODE : evSetVideoMode ( ( unsigned long ) event . user . data1 , ( unsigned long ) event . user . data2 ) ; break ; case EV_FLIP : evFlip ( ) ; break ; case EV_QUIT : stop = true ; break ; } break ; } } } }
bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirmed ( ) ; if ( confirmed ) { settings = dialog -> m_settings ; } return confirmed ; }
void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; }
void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; }
void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VEC@@ SOURC@@ ES shares ; g_mediaManager . GetLocal@@ Drives ( shares ) ; g_mediaManager . GetNetwork@@ Locations ( shares ) ; g_mediaManager . GetRemov@@ ableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlash@@ AtEnd ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatch@@ ingSource ( strDirectory , shares , bIsSource ) < 0 ) { CMedia@@ Source share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } }
bool CGUIDialogLibExportSettings :: OnMessage ( CGUI@@ Message & message ) { switch ( message . GetMessage ( ) ) { case GUI_@@ MSG_CLICKED : { int iControl = message . GetSender@@ Id ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; }
void CGUIDialogLibExportSettings :: OnOK ( ) { if ( m_settings . IsToLib@@ Fold@@ ers ( ) ) { std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { if ( HELPERS :: ShowYes@@ NoDialogText ( 20223 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . Activate@@ Window ( WINDOW@@ _SETTINGS_@@ MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOK@@ DialogText ( CVariant { 38300 } , CVariant { 383@@ 18 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; }
void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusic@@ ExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; }
void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHe@@ ading ( 38300 ) ; SET_CONTROL_@@ HID@@ DEN ( CONTROL_SETTINGS_@@ CUSTO@@ M_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 383@@ 19 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_@@ CANCEL_@@ BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; }
void CGUIDialogLibExportSettings :: UpdateButtons ( ) { bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_@@ ON_CONDI@@ TION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; }
void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddC@@ ategory ( " export@@ settings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } Translatable@@ IntegerSettingOptions entries ; entries . push_back ( std :: make_pair ( 3830@@ 1 , ELIBEXPORT_S@@ INGLEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_@@ SEPAR@@ ATEFI@@ LES ) ) ; entries . push_back ( std :: make_pair ( 3830@@ 3 , ELIBEXPORT_@@ TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUM@@ S ) ) ; entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUM@@ ARTISTS ) ) ; entries . push_back ( std :: make_pair ( 383@@ 12 , ELIBEXPORT_S@@ ONGARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_@@ OTH@@ ERARTISTS ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExport@@ Items ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 3830@@ 8 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 3830@@ 7 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 383@@ 10 , SettingLevel :: Basic , m_settings . m_overwrite ) ; }
void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LAB@@ EL2 ( settingControl -> GetID ( ) , label ) ; }
void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } }
void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_@@ FOCUS ( settingControl -> GetID ( ) , 0 ) ; }
int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConst@@ Ptr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElement@@ Type ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; }
BattlegroundAB :: BattlegroundAB ( ) { m_IsInformedNearVictory = false ; m_Buff@@ Change = true ; BgObjects . resize ( BG_AB_OBJECT_MAX ) ; BgCreatures . resize ( BG_AB_ALL_NODES_COUNT + 5 ) ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; m_BannerTimers [ i ] . type = 0 ; m_BannerTimers [ i ] . teamIndex = 0 ; } for ( uint8 i = 0 ; i < BG_TEAMS_COUNT ; ++ i ) { m_lastTick [ i ] = 0 ; m_HonorScoreTics [ i ] = 0 ; m_ReputationScoreTics [ i ] = 0 ; m_TeamScores500Disadvantage [ i ] = false ; } m_HonorTics = 0 ; m_ReputationTics = 0 ; StartMessageIds [ BG_STARTING_EVENT_@@ FIRST ] = LANG_BG_AB_START_@@ TWO_@@ MINUTES ; StartMessageIds [ BG_STARTING_@@ EVENT_S@@ ECOND ] = LANG_BG_AB_START_@@ ONE_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_@@ THIRD ] = LANG_BG_AB_START_@@ HALF_MINUTE ; StartMessageIds [ BG_STARTING_@@ EVENT_FOURTH ] = LANG_BG_AB_HAS_BEGUN ; }
void BattlegroundAB :: PostUpdateImpl ( uint32 diff ) { if ( GetStatus ( ) == STATUS_IN_PROGRESS ) { int team_points [ BG_TEAMS_COUNT ] = { 0 , 0 } ; for ( int node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) { if ( m_BannerTimers [ node ] . timer ) { if ( m_BannerTimers [ node ] . timer > diff ) m_BannerTimers [ node ] . timer -= diff ; else { m_BannerTimers [ node ] . timer = 0 ; _CreateBanner ( node , m_BannerTimers [ node ] . type , m_BannerTimers [ node ] . teamIndex , false ) ; } } if ( m_NodeTimers [ node ] ) { if ( m_NodeTimers [ node ] > diff ) m_NodeTimers [ node ] -= diff ; else { m_NodeTimers [ node ] = 0 ; uint8 teamIndex = m_Nodes [ node ] - 1 ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] += 2 ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeOccupied ( node , ( teamIndex == 0 ) ? ALLIANCE : HORDE ) ; if ( teamIndex == 0 ) { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_@@ ALLIANCE ) ; } else { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_@@ HORDE ) ; } } } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) if ( m_Nodes [ node ] == team + BG_AB_NODE_TYPE_OCCUPIED ) ++ team_points [ team ] ; } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) { int points = team_points [ team ] ; if ( ! points ) continue ; m_lastTick [ team ] += diff ; if ( m_lastTick [ team ] > BG_AB_TickIntervals [ points ] ) { m_lastTick [ team ] -= BG_AB_TickIntervals [ points ] ; m_TeamScores [ team ] += BG_AB_TickPoints [ points ] ; m_HonorScoreTics [ team ] += BG_AB_TickPoints [ points ] ; m_ReputationScoreTics [ team ] += BG_AB_TickPoints [ points ] ; if ( m_ReputationScoreTics [ team ] >= m_ReputationTics ) { ( team == TEAM_ALLIANCE ) ? RewardReputationToTeam ( 509 , 10 , ALLIANCE ) : RewardReputationToTeam ( 510 , 10 , HORDE ) ; m_ReputationScoreTics [ team ] -= m_ReputationTics ; } if ( m_HonorScoreTics [ team ] >= m_HonorTics ) { RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ( team == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; m_HonorScoreTics [ team ] -= m_HonorTics ; } if ( ! m_IsInformedNearVictory && m_TeamScores [ team ] > BG_AB_WARNING_NEAR_VICTORY_SCORE ) { if ( team == TEAM_ALLIANCE ) SendMessageToAll ( LANG_BG_AB_A_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; else SendMessageToAll ( LANG_BG_AB_H_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; PlaySoundToAll ( BG_AB_SOUND_NEAR_VICTORY ) ; m_IsInformedNearVictory = true ; } if ( m_TeamScores [ team ] > BG_AB_MAX_TEAM_SCORE ) m_TeamScores [ team ] = BG_AB_MAX_TEAM_SCORE ; if ( team == TEAM_ALLIANCE ) UpdateWorldState ( BG_AB_OP_RESOURCES_ALLY , m_TeamScores [ team ] ) ; else if ( team == TEAM_HORDE ) UpdateWorldState ( BG_AB_OP_RESOURCES_HORDE , m_TeamScores [ team ] ) ; uint8 otherTeam = ( team + 1 ) % BG_TEAMS_COUNT ; if ( m_TeamScores [ team ] > m_TeamScores [ otherTeam ] + 500 ) m_TeamScores500Disadvantage [ otherTeam ] = true ; } } if ( m_TeamScores [ TEAM_ALLIANCE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( ALLIANCE ) ; else if ( m_TeamScores [ TEAM_HORDE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( HORDE ) ; } }
void BattlegroundAB :: StartingEvent@@ CloseDoors ( ) { for ( int obj = BG_AB_OBJECT_BANNER_NEUTRAL ; obj < BG_AB_DYNAMIC_NODES_COUNT * 8 ; ++ obj ) SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT * 3 ; ++ i ) SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + i , RESPAWN_ONE_DAY ) ; DoorClose ( BG_AB_OBJECT_GATE_A ) ; DoorClose ( BG_AB_OBJECT_GATE_H ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_A , RESPAWN_IMMEDIATELY ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_H , RESPAWN_IMMEDIATELY ) ; _NodeOccupied ( BG_AB_SPIRIT_@@ ALIANCE , ALLIANCE ) ; _NodeOccupied ( BG_AB_SPIRIT_@@ HORDE , HORDE ) ; }
void BattlegroundAB :: StartingEvent@@ OpenDoors ( ) { for ( int banner = BG_AB_OBJECT_BANNER_NEUTRAL , i = 0 ; i < 5 ; banner += 8 , ++ i ) SpawnBGObject ( banner , RESPAWN_IMMEDIATELY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { uint8 buff = urand ( 0 , 2 ) ; SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3 , RESPAWN_IMMEDIATELY ) ; } DoorOpen ( BG_AB_OBJECT_GATE_A ) ; DoorOpen ( BG_AB_OBJECT_GATE_H ) ; StartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , AB_@@ EVENT_START_@@ BATTLE ) ; }
void BattlegroundAB :: AddPlayer ( Player * player ) { Battleground :: AddPlayer ( player ) ; PlayerScor@@ es [ player -> GetGUID ( ) ] = new BattlegroundAB@@ Score ( player -> GetGUID ( ) , player -> GetBG@@ Team ( ) ) ; }
void BattlegroundAB :: HandleAreaTrigger ( Player * player , uint32 trigger , bool entered ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; switch ( trigger ) { case 3948 : if ( player -> GetTeam ( ) != ALLIANCE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Alliance ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3949 : if ( player -> GetTeam ( ) != HORDE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Hor@@ de ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3866 : case 386@@ 9 : case 3867 : case 386@@ 8 : case 3870 : case 4020 : case 4021 : case 4674 : default : Battleground :: HandleAreaTrigger ( player , trigger , entered ) ; break ; } }
void BattlegroundAB :: _CreateBanner ( uint8 node , uint8 type , uint8 teamIndex , bool delay ) { if ( delay ) { m_BannerTimers [ node ] . timer = 2000 ; m_BannerTimers [ node ] . type = type ; m_BannerTimers [ node ] . teamIndex = teamIndex ; return ; } uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; }
void BattlegroundAB :: _DelBanner ( uint8 node , uint8 type , uint8 teamIndex ) { uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; }
int32 BattlegroundAB :: _GetNodeNameId ( uint8 node ) { switch ( node ) { case BG_AB_NODE_STABLES : return LANG_BG_AB_NODE_STABLES ; case BG_AB_NODE_BLACKSMITH : return LANG_BG_AB_NODE_BLACKSMITH ; case BG_AB_NODE_FARM : return LANG_BG_AB_NODE_FARM ; case BG_AB_NODE_LUMBER_MILL : return LANG_BG_AB_NODE_LUMBER_MILL ; case BG_AB_NODE_GOLD_MINE : return LANG_BG_AB_NODE_GOLD_MINE ; default : ABORT ( ) ; } return 0 ; }
void BattlegroundAB :: FillInitialWorldStates ( WorldPackets :: WorldState :: InitWorldStates & packet ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODEICONS [ node ] ) , int32 ( ( m_Nodes [ node ] == 0 ) ? 1 : 0 ) ) ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) for ( uint8 i = 1 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODESTATES [ node ] + plusArray [ i ] ) , int32 ( ( m_Nodes [ node ] == i ) ? 1 : 0 ) ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_ALLY ) , int32 ( ally ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_HORDE ) , int32 ( horde ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_@@ MAX ) , int32 ( BG_AB_MAX_TEAM_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_@@ WARNING ) , int32 ( BG_AB_WARNING_NEAR_VICTORY_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_ALLY ) , int32 ( m_TeamScores [ TEAM_ALLIANCE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_HORDE ) , int32 ( m_TeamScores [ TEAM_HORDE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( 0x745 ) , 0x2 ) ; }
void BattlegroundAB :: _SendNodeUpdate ( uint8 node ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; if ( m_prevNodes [ node ] ) UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_prevNodes [ node ] ] , 0 ) ; else UpdateWorldState ( BG_AB_OP_NODEICONS [ node ] , 0 ) ; UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_Nodes [ node ] ] , 1 ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_ALLY , ally ) ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_HORDE , horde ) ; }
void BattlegroundAB :: _NodeOccupied ( uint8 node , Team team ) { if ( ! AddSpirit@@ Guide ( node , BG_AB_SpiritGui@@ dePos [ node ] , GetTeamIndexByTeamId ( team ) ) ) TC_LOG_ERROR ( " bg . batt@@ leground " , " Failed ▁ to ▁ spawn ▁ spirit ▁ guide ! ▁ point : ▁ % u , ▁ team : ▁ % u , ▁ " , node , team ) ; if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; uint8 capturedNodes = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == GetTeamIndexByTeamId ( team ) + BG_AB_NODE_TYPE_OCCUPIED && ! m_NodeTimers [ i ] ) ++ capturedNodes ; if ( capturedNodes >= 5 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_@@ 5_@@ BASES , team ) ; if ( capturedNodes >= 4 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_@@ 4_BASES , team ) ; Creature * trigger = ! BgCreatures [ node + 7 ] ? GetBG@@ Creature ( node + 7 ) : NULL ; if ( ! trigger ) trigger = AddCreature ( WORLD_@@ TRIGGER , node + 7 , BG_AB_NodePositions [ node ] , GetTeamIndexByTeamId ( team ) ) ; if ( trigger ) { trigger -> setFaction ( team == ALLIANCE ? 84 : 83 ) ; trigger -> CastSpell ( trigger , SPELL_HONORABLE_@@ DEFENDER_@@ 25Y , false ) ; } }
void BattlegroundAB :: _NodeDeOccupied ( uint8 node ) { if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; if ( node < BG_AB_DYNAMIC_NODES_COUNT ) DelCreature ( node + 7 ) ; Reloc@@ ateDe@@ adPlay@@ ers ( BgCreatures [ node ] ) ; DelCreature ( node ) ; }
void BattlegroundAB :: EventPlayer@@ Clicked@@ OnFlag ( Player * source , GameObject * ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; uint8 node = BG_AB_NODE_STABLES ; GameObject * obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + 7 ] ) ; while ( ( node < BG_AB_DYNAMIC_NODES_COUNT ) && ( ( ! obj ) || ( ! source -> IsWithinDistInMap ( obj , 10 ) ) ) ) { ++ node ; obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + BG_AB_OBJECT_AURA_CONTESTED ] ) ; } if ( node == BG_AB_DYNAMIC_NODES_COUNT ) { return ; } TeamId teamIndex = GetTeamIndexByTeamId ( source -> GetTeam ( ) ) ; if ( ! ( m_Nodes [ node ] == 0 || teamIndex == m_Nodes [ node ] % 2 ) ) return ; source -> RemoveAurasWithInterrupt@@ Flags ( AURA_INTERRUP@@ T_FLAG_@@ ENTER_PVP_@@ COMBAT ) ; uint32 sound = 0 ; if ( m_Nodes [ node ] == BG_AB_NODE_TYPE_NEUTRAL ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + 1 ; _DelBanner ( node , BG_AB_NODE_TYPE_NEUTRAL , 0 ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == 0 ) SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) , LANG_BG_AB_ALLY ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) , LANG_BG_AB_HORDE ) ; sound = BG_AB_SOUND_NODE_CLAIMED ; } else if ( ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_@@ CONTESTED ) || ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_@@ CONTESTED ) ) { if ( m_prevNodes [ node ] < BG_AB_NODE_TYPE_OCCUPIED ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } else { UpdatePlayerScore ( source , SCORE_BASES_DEFENDED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = 0 ; _NodeOccupied ( node , ( teamIndex == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } else { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeDeOccupied ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } if ( m_Nodes [ node ] >= BG_AB_NODE_TYPE_OCCUPIED ) { if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; } PlaySoundToAll ( sound ) ; }
uint32 BattlegroundAB :: GetPrematureWinner ( ) { uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; if ( ally > horde ) return ALLIANCE ; else if ( horde > ally ) return HORDE ; return Battleground :: GetPrematureWinner ( ) ; }
bool BattlegroundAB :: SetupBattleground ( ) { for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_BANNER_NEUTRAL + 8 * i , BG_AB_OBJECTID_NODE_BANNER_@@ 0 + i , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_@@ A + 8 * i , BG_AB_OBJECTID_BANNER_CONT_@@ A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_@@ H + 8 * i , BG_AB_OBJECTID_BANNER_CONT_@@ H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_ALLY + 8 * i , BG_AB_OBJECTID_BANNER_@@ A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_HORDE + 8 * i , BG_AB_OBJECTID_BANNER_@@ H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_@@ ALLY + 8 * i , BG_AB_OBJECTID_AURA_@@ A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_@@ HORDE + 8 * i , BG_AB_OBJECTID_AURA_@@ H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_CONTESTED + 8 * i , BG_AB_OBJECTID_AURA_@@ C , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ some ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } } if ( ! AddObject ( BG_AB_OBJECT_GATE_A , BG_AB_OBJECTID_GATE_@@ A , BG_AB_DoorPositions [ 0 ] [ 0 ] , BG_AB_DoorPositions [ 0 ] [ 1 ] , BG_AB_DoorPositions [ 0 ] [ 2 ] , BG_AB_DoorPositions [ 0 ] [ 3 ] , BG_AB_DoorPositions [ 0 ] [ 4 ] , BG_AB_DoorPositions [ 0 ] [ 5 ] , BG_AB_DoorPositions [ 0 ] [ 6 ] , BG_AB_DoorPositions [ 0 ] [ 7 ] , RESPAWN_IMMEDIATELY ) || ! AddObject ( BG_AB_OBJECT_GATE_H , BG_AB_OBJECTID_GATE_@@ H , BG_AB_DoorPositions [ 1 ] [ 0 ] , BG_AB_DoorPositions [ 1 ] [ 1 ] , BG_AB_DoorPositions [ 1 ] [ 2 ] , BG_AB_DoorPositions [ 1 ] [ 3 ] , BG_AB_DoorPositions [ 1 ] [ 4 ] , BG_AB_DoorPositions [ 1 ] [ 5 ] , BG_AB_DoorPositions [ 1 ] [ 6 ] , BG_AB_DoorPositions [ 1 ] [ 7 ] , RESPAWN_IMMEDIATELY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ door ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i , Buff_Entries [ 0 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1 , Buff_Entries [ 1 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2 , Buff_Entries [ 2 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) ) TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ buff ▁ object ! " ) ; } return true ; }
void BattlegroundAB :: Reset ( ) { Battleground :: Reset ( ) ; m_TeamScores [ TEAM_ALLIANCE ] = 0 ; m_TeamScores [ TEAM_HORDE ] = 0 ; m_lastTick [ TEAM_ALLIANCE ] = 0 ; m_lastTick [ TEAM_HORDE ] = 0 ; m_HonorScoreTics [ TEAM_ALLIANCE ] = 0 ; m_HonorScoreTics [ TEAM_HORDE ] = 0 ; m_ReputationScoreTics [ TEAM_ALLIANCE ] = 0 ; m_ReputationScoreTics [ TEAM_HORDE ] = 0 ; m_IsInformedNearVictory = false ; bool isBGWeekend = sBattlegroundMgr -> IsBGWeekend ( GetTypeID ( ) ) ; m_HonorTics = ( isBGWeekend ) ? BG_AB_ABBGWeekend@@ HonorTicks : BG_AB_NotABBGWeekend@@ HonorTicks ; m_ReputationTics = ( isBGWeekend ) ? BG_AB_ABBGWeekend@@ ReputationTicks : BG_AB_NotABBGWeekend@@ ReputationTicks ; m_TeamScores500Disadvantage [ TEAM_ALLIANCE ] = false ; m_TeamScores500Disadvantage [ TEAM_HORDE ] = false ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; } for ( uint8 i = 0 ; i < BG_AB_ALL_NODES_COUNT + 5 ; ++ i ) if ( ! BgCreatures [ i ] . IsEmpty ( ) ) DelCreature ( i ) ; }
void BattlegroundAB :: EndBattleground ( uint32 winner ) { if ( winner == ALLIANCE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; if ( winner == HORDE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; Battleground :: EndBattleground ( winner ) ; }
WorldSafeLocsEntry const * BattlegroundAB :: GetClo@@ sest@@ GraveYard ( Player * player ) { TeamId teamIndex = GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ; std :: vector < uint8 > nodes ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == teamIndex + 3 ) nodes . push_back ( i ) ; WorldSafeLocsEntry const * good_entry = NULL ; if ( ! nodes . empty ( ) ) { float plr_x = player -> GetPositionX ( ) ; float plr_y = player -> GetPositionY ( ) ; float mindist = 9999@@ 99.0f ; for ( uint8 i = 0 ; i < nodes . size ( ) ; ++ i ) { WorldSafeLocsEntry const * entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ nodes [ i ] ] ) ; if ( ! entry ) continue ; float dist = ( entry -> Loc . X - plr_x ) * ( entry -> Loc . X - plr_x ) + ( entry -> Loc . Y - plr_y ) * ( entry -> Loc . Y - plr_y ) ; if ( mindist > dist ) { mindist = dist ; good_entry = entry ; } } nodes . clear ( ) ; } if ( ! good_entry ) good_entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ teamIndex + 5 ] ) ; return good_entry ; }
bool BattlegroundAB :: UpdatePlayerScore ( Player * player , uint32 type , uint32 value , bool doAddHonor ) { if ( ! Battleground :: UpdatePlayerScore ( player , type , value , doAddHonor ) ) return false ; switch ( type ) { case SCORE_BASES_ASSAULTED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_@@ ASSAULT_BAS@@ E ) ; break ; case SCORE_BASES_DEFENDED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_@@ DEFEND_@@ BASE ) ; break ; default : break ; } return true ; }
bool BattlegroundAB :: CheckAchievementCriteriaMeet ( uint32 criteriaId , Player const * player , Unit const * target , uint32 miscvalue ) { switch ( criteriaId ) { case BG_CRITERIA_@@ CHECK_RESILI@@ ENT_VIC@@ TORY : return m_TeamScores500Disadvantage [ GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ] ; } return Battleground :: CheckAchievementCriteriaMeet ( criteriaId , player , target , miscvalue ) ; }
Items :: Items ( ) { items . reserve ( 20000 ) ; }
Items :: ~ Items ( ) { clear ( ) ; }
void Items :: clear ( ) { items . clear ( ) ; }
bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefaults ( ) ; return true ; }
FILELO@@ ADER_@@ ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTB@@ I " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_@@ ATTR_VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; Items :: dwMinorVersion = vi . dwMinorVersion ; Items :: dwBuildNumber = vi . dwBuildNumber ; } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_@@ VERSION_@@ 740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR@@ _SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_@@ CLIEN@@ TID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR@@ _SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_@@ LIGHT@@ 2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_@@ TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_@@ WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup@@ _t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP@@ _SPLAS@@ H : case ITEM_GROUP@@ _FL@@ UID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOC@@ K_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_@@ PROJ@@ ECTI@@ LE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_@@ PATHFIN@@ D , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_@@ HEIG@@ HT , flags ) ; iType . useable = hasBitSet ( FLAG_USE@@ ABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PIC@@ KUP@@ ABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_ST@@ ACK@@ ABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAY@@ SON@@ TOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZON@@ TAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLO@@ WDI@@ STRE@@ AD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROT@@ ATABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READ@@ ABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOK@@ THROUGH , flags ) ; iType . forceUse = hasBitSet ( FLAG_FORCE@@ USE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrin@@ k_to_@@ fit ( ) ; return ERROR_NONE ; }
bool Items :: loadFromXml ( ) { pugi :: xml_document doc ; pugi :: xml_parse_@@ result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXMLError ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; }
void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plur@@ al " ) ; if ( pluralAttribute ) { it . plural@@ Name = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depo@@ t " ) { it . type = ITEM_TYPE_DEPO@@ T ; } else if ( tmpStrValue == " mail@@ box " ) { it . type = ITEM_TYPE_MAIL@@ BOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRAS@@ HHO@@ LDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUN@@ E ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespell@@ name " ) { it . rune@@ SpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extra@@ def " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotat@@ eto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockproject@@ ile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_S@@ OUT@@ H ; } else if ( tmpStrValue == " south@@ alt " ) { it . floorChange = TILESTATE_FLOORCHANGE_S@@ OUTH@@ _ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAS@@ T ; } else if ( tmpStrValue == " east@@ alt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAS@@ T_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " veno@@ m " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIRE ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BEER ; } else if ( tmpStrValue == " sli@@ me " ) { it . fluidSource = FLUID_S@@ LIME ; } else if ( tmpStrValue == " lemon@@ ade " ) { it . fluidSource = FLUID_LEMON@@ ADE ; } else if ( tmpStrValue == " mil@@ k " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " lif@@ e " ) { it . fluidSource = FLUID_LIFE ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OI@@ L ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_COCON@@ UTMILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruit@@ juice " ) { it . fluidSource = FLUID_F@@ RU@@ ITJU@@ ICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAVA ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_S@@ WAMP ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtext@@ len " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonce@@ itemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_S@@ WORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_@@ CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_@@ AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_S@@ HIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_@@ DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_@@ WAND ; } else if ( tmpStrValue == " ammunit@@ ion " ) { it . weaponType = WEAPON_@@ AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_F@@ EET ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACK@@ PACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_@@ HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " neck@@ lace " ) { it . slotPosition |= SLOTP_NEC@@ KLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammo@@ type " ) { it . ammoType = getAmmo@@ Type ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoot@@ type " ) { Shoot@@ Type_t shoot = getShoot@@ Type ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { Magic@@ EffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopd@@ uration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decay@@ to " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transfor@@ mequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhit@@ chance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " health@@ gain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . health@@ Gain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " health@@ ticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . health@@ Ticks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manag@@ ain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . mana@@ Gain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manatick@@ s " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . mana@@ Ticks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashi@@ eld " ) { it . getAbilities ( ) . mana@@ Shield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_S@@ WORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_@@ AXE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_@@ CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_@@ DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FI@@ SHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_S@@ HIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FI@@ ST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhit@@ points " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhit@@ pointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmana@@ points " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmana@@ pointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevelpoints " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercent@@ energy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercent@@ fire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercent@@ poison " || tmpStrValue == " fieldabsor@@ percentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercentelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmag@@ ic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlif@@ edrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIFE@@ DRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MAN@@ ADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentheal@@ ing " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEAL@@ ING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFIN@@ EDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppress@@ drun@@ k " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppress@@ energy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppress@@ fire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppress@@ poison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppress@@ physical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; Combat@@ Type_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generate@@ Damage@@ List ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM@@ _FI@@ ELD , 1 ) ; if ( conditionDamage -> getTotal@@ Damage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM@@ _FORCE@@ UPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sle@@ eper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroy@@ to " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walk@@ stack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdistread " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } }
ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; }
uint16_t Items :: getItemId@@ ByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; }
CFormDialog :: CFormDialog ( ) : CBaseDialog ( IDR_@@ MAINF@@ RAME ) { View = NULL ; WidgetIndexCount = 0 ; WidgetFocused = 0xffffffff ; }
CFormDialog :: ~ CFormDialog ( ) { clear ( ) ; }
void CFormDialog :: clear ( ) { unRegister@@ LastControl ( ) ; for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) delete Widgets [ i ] ; Widgets . clear ( ) ; WidgetFocused = 0xffffffff ; WidgetIndexCount = 0 ; }
void CFormDialog :: DoDataExchange ( CDataExchange * pDX ) { CDialog :: DoDataExchange ( pDX ) ; }
BOOL CFormDialog :: OnInitDialog ( ) { CBaseDialog :: OnInitDialog ( ) ; SetDef@@ ID ( 0xffffffff ) ; UpdateData ( FALSE ) ; return TRUE ; }
void CFormDialog :: OnOK ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOk ( ) ; } } }
void CFormDialog :: OnCancel ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onCancel ( ) ; return ; } } CBaseDialog :: OnCancel ( ) ; }
CWnd * CFormDialog :: addTypeWidget ( const NLGEORGES :: CType & type , uint elmIndex , const char * title , const char * atomName , const char * typeFilename , RECT & currentPos , CForm & form , IFormWidget :: TTypeSrc typeWidget , const char * filenameExt , uint slot ) { switch ( type . UIType ) { case CType :: FileBrowser : case CType :: Edit : case CType :: EditSpin : { CFormMemCombo * memCombo = new CFormMemCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; string tfn = typeFilename ; string key = GEORGES_EDIT_BASE_REG_KEY " \\ " + strlwr ( typeFilename ) + " ▁ MemCombo " ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title , key . c_str ( ) , type . UIType == CType :: EditSpin , type . UIType == CType :: FileBrowser , filenameExt ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: NonEditableCombo : { CFormCombo * memCombo = new CFormCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: BigEdit : { CFormBigEdit * memCombo = new CFormBigEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Edit ; } break ; case CType :: ColorEdit : { CColorEdit * memCombo = new CColorEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Color ; } break ; } return NULL ; }
void CFormDialog :: getVirtualDfnFromDocument ( const NLGEORGES :: CFormDfn * _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , 0xffffffff , structName , IFormWidget :: TypeVirtualDfn , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Dfn : " , GEORGES_EDIT_BASE_REG_KEY " \\Virtu@@ al ▁ Dfn ▁ MemCombo " , false , true , " * . dfn " ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; if ( _dfn ) { std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn -> countParentDfn ( ) ) ; _dfn -> getParentDfn ( arrayDfn ) ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; } elmIndex ++ ; } } } registerLastControl ( ) ; } } }
void CFormDialog :: getDfnFromDocument ( const NLGEORGES :: CFormDfn & _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn . countParentDfn ( ) ) ; _dfn . getParentDfn ( arrayDfn ) ; if ( strcmp ( structName , " " ) == 0 ) { CListWidget * listWidget = new CListWidget ( this , 0xffffffff , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( listWidget ) ; listWidget -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Parent ▁ Form : " , GEORGES_EDIT_BASE_REG_KEY " \\Parent ▁ Form ▁ MemCombo " , 1 ) ; listWidget -> addColumn ( " Parent ▁ filename " ) ; listWidget -> getFromDocument ( * doc -> getFormPtr ( ) ) ; } CWnd * pWnd = NULL ; CWnd * pWndIcon = NULL ; CWnd * pWndIconColor = NULL ; CWnd * pWndIconBack = NULL ; CWnd * pWndIconBackColor = NULL ; CWnd * pWndIconOver = NULL ; CWnd * pWndIconOverColor = NULL ; CWnd * pWndIconOver2 = NULL ; CWnd * pWndIconOver2Color = NULL ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; pWnd = addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; if ( entry . getName ( ) == " Icon " || entry . getName ( ) == " icon " ) pWndIcon = pWnd ; else if ( entry . getName ( ) == " IconColor " ) pWndIconColor = pWnd ; else if ( entry . getName ( ) == " IconBack " || entry . getName ( ) == " icon ▁ background " ) pWndIconBack = pWnd ; else if ( entry . getName ( ) == " IconBackColor " ) pWndIconBackColor = pWnd ; else if ( entry . getName ( ) == " IconOver " || entry . getName ( ) == " icon ▁ overlay " ) pWndIconOver = pWnd ; else if ( entry . getName ( ) == " IconOver@@ Color " ) pWndIconOverColor = pWnd ; else if ( entry . getName ( ) == " IconOver@@ 2" || entry . getName ( ) == " icon ▁ overlay2" ) pWndIconOver2 = pWnd ; else if ( entry . getName ( ) == " IconOver@@ 2Color " ) pWndIconOver2Color = pWnd ; } elmIndex ++ ; } } if ( ( string ( structName ) == " . Client " ) || ( string ( structName ) == " . 3d " ) ) { string title = " Icon ▁ bitmap : " ; CIconWidget * w = new CIconWidget ( this , elmIndex , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( w ) ; w -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title . c_str ( ) ) ; w -> Icon . pWndIcon = pWndIcon ; w -> Icon . pWndIconColor = pWndIconColor ; w -> Icon . pWndIconBack = pWndIconBack ; w -> Icon . pWndIconBackColor = pWndIconBackColor ; w -> Icon . pWndIconOver = pWndIconOver ; w -> Icon . pWndIconOverColor = pWndIconOverColor ; w -> Icon . pWndIconOver2 = pWndIconOver2 ; w -> Icon . pWndIconOver2Color = pWndIconOver2Color ; } registerLastControl ( ) ; } } }
void CFormDialog :: getArrayFromDocument ( const char * structName , uint structId , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , structId , structName , IFormWidget :: TypeArray , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Array ▁ size : " , GEORGES_EDIT_BASE_REG_KEY " \\Array ▁ Size ▁ MemCombo " , true , false , NULL ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; registerLastControl ( ) ; } } }
void CFormDialog :: getTypeFromDocument ( const NLGEORGES :: CType & _type , const char * name , const char * typeFilename , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; addTypeWidget ( _type , 0xffffffff , name , structName , typeFilename , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeType , NULL , slot ) ; registerLastControl ( ) ; } } }
void CFormDialog :: updateLabels ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } }
void CFormDialog :: updateValues ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; Widgets [ i ] -> getFromDocument ( * ( View -> GetDocument ( ) -> getFormPtr ( ) ) ) ; } }
void CFormDialog :: setToDocument ( uint widget ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ widget ] ) ; if ( iconWidget ) return ; if ( Widgets [ widget ] -> getFormName ( ) != " NULL " ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widget ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentVDfnArray ) { if ( ! theApp . yes@@ No ( " Warning , ▁ this ▁ action ▁ will ▁ create ▁ an ▁ array / virtual ▁ dfn ▁ over ▁ an ▁ inher@@ ited ▁ array / virtual ▁ dfn . \n Do ▁ you ▁ want ▁ to ▁ continue ▁ ? " ) ) return ; } } IFormWidget :: TTypeSrc typeSrc = Widgets [ widget ] -> getSrcType ( ) ; if ( typeSrc == IFormWidget :: TypeForm ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeFormParent ) { CForm * form = doc -> getFormPtr ( ) ; uint count = Widgets [ widget ] -> getNumValue ( ) ; vector < string > stringVector ( count ) ; for ( uint value = 0 ; value < count ; value ++ ) { Widgets [ widget ] -> getValue ( stringVector [ value ] , value ) ; } doc -> modify ( new CAction@@ StringVector ( IAction :: FormParents , stringVector , * doc , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeArray ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormArraySize , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeType ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormType@@ Value , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeVirtualDfn ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormVirtual@@ DfnName , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } } if ( ! Widgets [ widget ] -> getFormName ( ) . empty ( ) ) doc -> notify@@ Plugins ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) ) ; }
LRESULT CFormDialog :: WindowProc ( UINT message , WPARAM wParam , LPARAM lParam ) { switch ( message ) { case CL_@@ CHANGED : { uint widgetId = getWidget ( wParam ) ; CColorEdit * colorEdit = safe_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; colorEdit -> Empty = false ; setToDocument ( getWidget ( wParam ) ) ; } break ; case MC@@ _STRING@@ CHANGE : { setToDocument ( getWidget ( wParam ) ) ; } break ; case CBN_CHANGED : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ i ] ) ; if ( iconWidget ) iconWidget -> Icon . Invalidate ( ) ; } } break ; } return CDialog :: WindowProc ( message , wParam , lParam ) ; }
void CFormDialog :: onOpenSelected ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOpenSelected ( ) ; } } }
void CFormDialog :: onFirst@@ Focus ( ) { View -> SetFocus ( ) ; WidgetFocused = 0xffffffff ; }
void CFormDialog :: onLast@@ Focus ( ) { View -> setFocus@@ LeftView ( ) ; WidgetFocused = 0xffffffff ; }
