<DOCUMENT_ID="b@@ ra@@ ing@@ l/@@ b@@ ra@@ ing@@ l@@ /tree/master/src/@@ al@@ g@@ os@@ /sd@@ thread@@ .cpp"> # include " sd@@ thread . h " # include " . . / data / dat@@ as@@ et@@ s / dat@@ as@@ et@@ dw@@ i . h " # include " . . / gui / gl / gl@@ functions . h " SD@@ Thread :: SD@@ Thread ( D@@ at@@ as@@ et@@ D@@ W@@ I * ds , int id ) : m_@@ dat@@ as@@ et ( ds ) , m_id ( id ) { m_@@ dw@@ i = ds -> get@@ Data ( ) ; m_b@@ val@@ s = ds -> get@@ B@@ val@@ s ( ) ; m_b@@ vec@@ s = ds -> get@@ B@@ vec@@ s ( ) ; int nx = ds -> properties ( " ma@@ ing@@ l " ) . get ( Fn :: Property :: D_@@ N@@ X ) . toInt ( ) ; int ny = ds -> properties ( " ma@@ ing@@ l " ) . get ( Fn :: Property :: D_@@ NY ) . toInt ( ) ; int nz = ds -> properties ( " ma@@ ing@@ l " ) . get ( Fn :: Property :: D_@@ NZ ) . toInt ( ) ; m_@@ blockSize = nx * ny * nz ; } SD@@ Thread :: ~ SD@@ Thread ( ) { } void SD@@ Thread :: run ( ) { int num@@ Threads = GL@@ Functions :: ide@@ al@@ Thread@@ Count ; int pro@@ g@@ ress@@ Counter = 0 ; for ( int i = m_id ; i < m_@@ blockSize ; i += num@@ Threads ) { calc@@ SD ( i ) ; ++ pro@@ g@@ ress@@ Counter ; if ( pro@@ g@@ ress@@ Counter == 100 ) { emit ( progress ( ) ) ; pro@@ g@@ ress@@ Counter = 0 ; } } emit ( finished ( ) ) ; } Column@@ Vector SD@@ Thread :: calc@@ SD ( int id ) { return Column@@ Vector ( 20 ) ; } </DOCUMENT>
<DOCUMENT_ID="m@@ 0@@ 39@@ /@@ Vo@@ id@@ /tree/master/thir@@ d@@ -party/@@ vo@@ id@@ -@@ boost/libs/@@ config/test/@@ has_@@ par@@ t_@@ alloc@@ _@@ fail@@ .cpp"> # ifdef BOOST_ASSERT_CONFIG # undef BOOST_ASSERT_CONFIG # endif # include < boost / config . hpp > # include " test . hpp " # ifndef BOOST_HAS_@@ PAR@@ TI@@ AL@@ _STD_@@ ALLOCATOR # include " boost _ has _ part _ alloc . ipp " # else # error " this ▁ file ▁ should ▁ not ▁ compile " # endif int main ( int , char * [ ] ) { return boost_@@ has_@@ par@@ ti@@ al_@@ std_@@ allocator :: test ( ) ; } </DOCUMENT>
<DOCUMENT_ID="@@ ces@@ ar@@ mar@@ in@@ hor@@ j@@ /phantomjs/tree/master/src/qt/qt@@ webkit/Source/@@ WT@@ F/@@ wt@@ f@@ /t@@ ext@@ /@@ Base@@ 64@@ .cpp"> # include " config . h " # include " Base64 . h " # include < limits . h > # include < wtf / String@@ Extr@@ as . h > # include < wtf / text / WT@@ F@@ String . h > namespace WTF { static const char base@@ 64@@ En@@ c@@ Map [ 64 ] = { 0x41 , 0x42 , 0x43 , 0x44 , 0x@@ 45 , 0x46 , 0x47 , 0x48 , 0x49 , 0x4@@ A , 0x4@@ B , 0x4@@ C , 0x4@@ D , 0x4@@ E , 0x4@@ F , 0x50 , 0x51 , 0x@@ 52 , 0x53 , 0x@@ 54 , 0x55 , 0x@@ 56 , 0x57 , 0x58 , 0x59 , 0x5@@ A , 0x61 , 0x@@ 62 , 0x@@ 63 , 0x64 , 0x65 , 0x@@ 66 , 0x@@ 67 , 0x68 , 0x@@ 69 , 0x6@@ A , 0x6@@ B , 0x6@@ C , 0x6@@ D , 0x6@@ E , 0x6@@ F , 0x70 , 0x@@ 71 , 0x@@ 72 , 0x@@ 73 , 0x74 , 0x@@ 75 , 0x76 , 0x77 , 0x78 , 0x@@ 79 , 0x7@@ A , 0x30 , 0x31 , 0x32 , 0x@@ 33 , 0x34 , 0x@@ 35 , 0x@@ 36 , 0x37 , 0x38 , 0x39 , 0x2@@ B , 0x2@@ F } ; static const char base@@ 64@@ Dec@@ Map [ 128 ] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x3E , 0x00 , 0x00 , 0x00 , 0x3F , 0x34 , 0x@@ 35 , 0x@@ 36 , 0x37 , 0x38 , 0x39 , 0x3@@ A , 0x3@@ B , 0x3@@ C , 0x3D , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0@@ B , 0x0@@ C , 0x0@@ D , 0x0@@ E , 0x0F , 0x10 , 0x11 , 0x12 , 0x@@ 13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x1A , 0x1@@ B , 0x1@@ C , 0x1@@ D , 0x1@@ E , 0x1F , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x@@ 29 , 0x2@@ A , 0x2@@ B , 0x2@@ C , 0x@@ 2D , 0x2@@ E , 0x2@@ F , 0x30 , 0x31 , 0x32 , 0x@@ 33 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; String base@@ 64Encode ( const char * data , unsigned length , Base@@ 64@@ Encode@@ Policy policy ) { Vector < char > result ; base@@ 64Encode ( data , length , result , policy ) ; return String ( result . data ( ) , result . size ( ) ) ; } void base@@ 64Encode ( const char * data , unsigned len , Vector < char > & out , Base@@ 64@@ Encode@@ Policy policy ) { out . clear ( ) ; if ( ! len ) return ; const unsigned max@@ Input@@ Buffer@@ Size = UINT_MAX / 77 * 76 / 4 * 3 - 2 ; if ( len > max@@ Input@@ Buffer@@ Size ) return ; unsigned s@@ idx = 0 ; unsigned d@@ idx = 0 ; unsigned out@@ Length = ( ( len + 2 ) / 3 ) * 4 ; bool insert@@ LF@@ s = ( policy == Base@@ 64@@ Insert@@ LF@@ s && out@@ Length > 76 ) ; if ( insert@@ LF@@ s ) out@@ Length += ( ( out@@ Length - 1 ) / 76 ) ; int count = 0 ; out . g@@ row ( out@@ Length ) ; if ( len > 1 ) { while ( s@@ idx < len - 2 ) { if ( insert@@ LF@@ s ) { if ( count && ! ( count % 76 ) ) out [ d@@ idx ++ ] = ' \n ' ; count += 4 ; } out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ s@@ idx ] >> 2 ) & 0@@ 77 ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ s@@ idx + 1 ] >> 4 ) & 0@@ 17 ) | ( ( data [ s@@ idx ] << 4 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ s@@ idx + 2 ] >> 6 ) & 003 ) | ( ( data [ s@@ idx + 1 ] << 2 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ data [ s@@ idx + 2 ] & 0@@ 77 ] ; s@@ idx += 3 ; } } if ( s@@ idx < len ) { if ( insert@@ LF@@ s && ( count > 0 ) && ! ( count % 76 ) ) out [ d@@ idx ++ ] = ' \n ' ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ s@@ idx ] >> 2 ) & 0@@ 77 ] ; if ( s@@ idx < len - 1 ) { out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( ( data [ s@@ idx + 1 ] >> 4 ) & 0@@ 17 ) | ( ( data [ s@@ idx ] << 4 ) & 0@@ 77 ) ] ; out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ s@@ idx + 1 ] << 2 ) & 0@@ 77 ] ; } else out [ d@@ idx ++ ] = base@@ 64@@ En@@ c@@ Map [ ( data [ s@@ idx ] << 4 ) & 0@@ 77 ] ; } while ( d@@ idx < out . size ( ) ) { out [ d@@ idx ] = ' = ' ; ++ d@@ idx ; } } bool base@@ 64@@ De@@ code ( const Vector < char > & in , Vector < char > & out , Base@@ 64@@ Decode@@ Policy policy ) { out . clear ( ) ; if ( in . size ( ) > UINT_MAX ) return false ; return base@@ 64@@ De@@ code ( in . data ( ) , in . size ( ) , out , policy ) ; } template < typename T > static inline bool base@@ 64@@ Decode@@ Internal ( const T * data , unsigned len , Vector < char > & out , Base@@ 64@@ Decode@@ Policy policy ) { out . clear ( ) ; if ( ! len ) return true ; out . g@@ row ( len ) ; bool sa@@ w@@ Equal@@ s@@ Sign = false ; unsigned out@@ Length = 0 ; for ( unsigned idx = 0 ; idx < len ; ++ idx ) { unsigned ch = data [ idx ] ; if ( ch == ' = ' ) sa@@ w@@ Equal@@ s@@ Sign = true ; else if ( ( '0' <= ch && ch <= '9' ) || ( ' A ' <= ch && ch <= ' Z ' ) || ( ' a ' <= ch && ch <= ' z ' ) || ch == ' + ' || ch == ' / ' ) { if ( sa@@ w@@ Equal@@ s@@ Sign ) return false ; out [ out@@ Length ] = base@@ 64@@ Dec@@ Map [ ch ] ; ++ out@@ Length ; } else if ( policy == Base@@ 64@@ Fail@@ On@@ Invalid@@ Charact@@ er || ( policy == Base@@ 64@@ Ignore@@ Wh@@ it@@ esp@@ ace && ! is@@ Space@@ Or@@ New@@ line ( ch ) ) ) return false ; } if ( ! out@@ Length ) return ! sa@@ w@@ Equal@@ s@@ Sign ; if ( ( out@@ Length % 4 ) == 1 ) return false ; out@@ Length -= ( out@@ Length + 3 ) / 4 ; if ( ! out@@ Length ) return false ; unsigned s@@ idx = 0 ; unsigned d@@ idx = 0 ; if ( out@@ Length > 1 ) { while ( d@@ idx < out@@ Length - 2 ) { out [ d@@ idx ] = ( ( ( out [ s@@ idx ] << 2 ) & 255 ) | ( ( out [ s@@ idx + 1 ] >> 4 ) & 003 ) ) ; out [ d@@ idx + 1 ] = ( ( ( out [ s@@ idx + 1 ] << 4 ) & 255 ) | ( ( out [ s@@ idx + 2 ] >> 2 ) & 0@@ 17 ) ) ; out [ d@@ idx + 2 ] = ( ( ( out [ s@@ idx + 2 ] << 6 ) & 255 ) | ( out [ s@@ idx + 3 ] & 0@@ 77 ) ) ; s@@ idx += 4 ; d@@ idx += 3 ; } } if ( d@@ idx < out@@ Length ) out [ d@@ idx ] = ( ( ( out [ s@@ idx ] << 2 ) & 255 ) | ( ( out [ s@@ idx + 1 ] >> 4 ) & 003 ) ) ; if ( ++ d@@ idx < out@@ Length ) out [ d@@ idx ] = ( ( ( out [ s@@ idx + 1 ] << 4 ) & 255 ) | ( ( out [ s@@ idx + 2 ] >> 2 ) & 0@@ 17 ) ) ; if ( out@@ Length < out . size ( ) ) out . shrin@@ k ( out@@ Length ) ; return true ; } bool base@@ 64@@ De@@ code ( const char * data , unsigned len , Vector < char > & out , Base@@ 64@@ Decode@@ Policy policy ) { return base@@ 64@@ Decode@@ Internal < char > ( data , len , out , policy ) ; } bool base@@ 64@@ De@@ code ( const String & in , Vector < char > & out , Base@@ 64@@ Decode@@ Policy policy ) { return base@@ 64@@ Decode@@ Internal < UChar > ( in . characters ( ) , in . length ( ) , out , policy ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ Vo@@ y@@ ag@@ er@@ 1/@@ xbmc/tree/master/xbmc/@@ window@@ ing/@@ rp@@ i/@@ GL@@ Context@@ E@@ GL@@ .cpp"> # include " GL@@ Context@@ E@@ GL . h " # include " guilib / ID@@ i@@ rt@@ y@@ Reg@@ ion@@ Solver . h " # include " settings / Advanced@@ Settings . h " # include " utils / log . h " C@@ GL@@ Context@@ E@@ GL :: C@@ GL@@ Context@@ E@@ GL ( ) : m_@@ e@@ gl@@ Display ( E@@ GL_@@ NO_@@ DISPLAY ) , m_@@ e@@ gl@@ Surface ( E@@ GL_@@ NO@@ _SUR@@ FACE ) , m_@@ e@@ gl@@ Context ( E@@ GL_@@ NO_@@ CON@@ TEXT ) , m_@@ e@@ gl@@ Config ( 0 ) { } C@@ GL@@ Context@@ E@@ GL :: ~ C@@ GL@@ Context@@ E@@ GL ( ) { Destroy ( ) ; } bool C@@ GL@@ Context@@ E@@ GL :: Create@@ Display ( E@@ GL@@ Display display , E@@ GLint render@@ able@@ _type , E@@ GLint render@@ ing_@@ api ) { E@@ GLint ne@@ gl@@ config@@ s = 0 ; int major , minor ; E@@ GLint sur@@ face_@@ type = E@@ GL_@@ WINDOW_@@ BIT ; if ( g_@@ advanc@@ ed@@ Settings . m_gui@@ Algorith@@ m@@ Dirty@@ Reg@@ ions == DI@@ R@@ TY@@ REGI@@ ON_S@@ O@@ LV@@ ER_@@ CO@@ ST_@@ RE@@ D@@ UC@@ TION || g_@@ advanc@@ ed@@ Settings . m_gui@@ Algorith@@ m@@ Dirty@@ Reg@@ ions == DI@@ R@@ TY@@ REGI@@ ON_S@@ O@@ LV@@ ER_@@ UNI@@ ON ) sur@@ face_@@ type |= EG@@ L_S@@ W@@ AP_@@ BEHAVI@@ OR_@@ PRES@@ ERV@@ ED_@@ BIT ; E@@ GLint attrib@@ s [ ] = { E@@ GL_@@ RE@@ D@@ _SIZE , 8 , E@@ GL_@@ GRE@@ EN_SIZE , 8 , E@@ GL_BL@@ UE_@@ SIZE , 8 , E@@ GL_@@ ALPH@@ A@@ _SIZE , 8 , E@@ GL_@@ DE@@ P@@ TH@@ _SIZE , 16 , E@@ GL@@ _ST@@ EN@@ C@@ IL@@ _SIZE , 0 , EG@@ L_S@@ AMP@@ LE_@@ BUFFERS , 0 , EG@@ L_S@@ AMP@@ LES , 0 , EG@@ L_S@@ UR@@ FACE_@@ TYPE , sur@@ face_@@ type , E@@ GL_@@ REN@@ DER@@ ABLE_@@ TYPE , render@@ able@@ _type , E@@ GL_@@ NONE } ; if ( m_@@ e@@ gl@@ Display == E@@ GL_@@ NO_@@ DISPLAY ) { m_@@ e@@ gl@@ Display = e@@ gl@@ Get@@ Display ( ( E@@ GL@@ Native@@ Display@@ Type ) display ) ; } if ( m_@@ e@@ gl@@ Display == E@@ GL_@@ NO_@@ DISPLAY ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ get ▁ E@@ GL ▁ display " ) ; return false ; } if ( ! e@@ gl@@ Initialize ( m_@@ e@@ gl@@ Display , & major , & minor ) ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ initialize ▁ E@@ GL ▁ display " ) ; return false ; } e@@ glBind@@ API ( render@@ ing_@@ api ) ; if ( ! e@@ gl@@ Cho@@ o@@ se@@ Config ( m_@@ e@@ gl@@ Display , attrib@@ s , & m_@@ e@@ gl@@ Config , 1 , & ne@@ gl@@ config@@ s ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ query ▁ number ▁ of ▁ E@@ GL ▁ config@@ s " ) ; return false ; } if ( ne@@ gl@@ config@@ s <= 0 ) { CLog :: Log ( LOGERROR , " No ▁ su@@ it@@ able ▁ E@@ GL ▁ config@@ s ▁ found " ) ; return false ; } return true ; } bool C@@ GL@@ Context@@ E@@ GL :: CreateContext ( ) { int cli@@ ent_@@ version = 2 ; const E@@ GLint context_@@ attrib@@ s [ ] = { E@@ GL_@@ CON@@ TEXT_@@ CLIENT_VERSION , cli@@ ent_@@ version , E@@ GL_@@ NONE } ; if ( m_@@ e@@ gl@@ Context == E@@ GL_@@ NO_@@ CON@@ TEXT ) { m_@@ e@@ gl@@ Context = e@@ gl@@ CreateContext ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Config , E@@ GL_@@ NO_@@ CON@@ TEXT , context_@@ attrib@@ s ) ; } if ( m_@@ e@@ gl@@ Context == E@@ GL_@@ NO_@@ CON@@ TEXT ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ E@@ GL ▁ context " ) ; return false ; } return true ; } bool C@@ GL@@ Context@@ E@@ GL :: Bind@@ Context ( ) { if ( ! e@@ gl@@ Make@@ Curr@@ ent ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Surface , m_@@ e@@ gl@@ Surface , m_@@ e@@ gl@@ Context ) ) { CLog :: Log ( LOGERROR , " Failed ▁ to ▁ make ▁ context ▁ current ▁ % p ▁ % p ▁ % p " , m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Surface , m_@@ e@@ gl@@ Context ) ; return false ; } return true ; } bool C@@ GL@@ Context@@ E@@ GL :: Surface@@ Attri@@ b ( ) { if ( g_@@ advanc@@ ed@@ Settings . m_gui@@ Algorith@@ m@@ Dirty@@ Reg@@ ions == DI@@ R@@ TY@@ REGI@@ ON_S@@ O@@ LV@@ ER_@@ CO@@ ST_@@ RE@@ D@@ UC@@ TION || g_@@ advanc@@ ed@@ Settings . m_gui@@ Algorith@@ m@@ Dirty@@ Reg@@ ions == DI@@ R@@ TY@@ REGI@@ ON_S@@ O@@ LV@@ ER_@@ UNI@@ ON ) { if ( ( m_@@ e@@ gl@@ Display == E@@ GL_@@ NO_@@ DISPLAY ) || ( m_@@ e@@ gl@@ Surface == E@@ GL_@@ NO@@ _SUR@@ FACE ) ) { return false ; } if ( ! e@@ gl@@ Surface@@ Attri@@ b ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Surface , EG@@ L_S@@ W@@ AP_@@ BEHAVI@@ OR , E@@ GL_@@ BUFFER_@@ PRES@@ ERV@@ ED ) ) { CLog :: Log ( LOG@@ DEBUG , " % s : ▁ Could ▁ not ▁ set ▁ E@@ GL _ SW@@ AP _ BEHAVI@@ OR " , __FUNCTION__ ) ; } } return true ; } bool C@@ GL@@ Context@@ E@@ GL :: Create@@ Surface ( E@@ GL@@ Native@@ Window@@ Type surface ) { m_@@ e@@ gl@@ Surface = e@@ gl@@ Create@@ Window@@ Surface ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Config , surface , nullptr ) ; if ( m_@@ e@@ gl@@ Surface == E@@ GL_@@ NO@@ _SUR@@ FACE ) { CLog :: Log ( LOGERROR , " failed ▁ to ▁ create ▁ E@@ GL ▁ window ▁ surface ▁ % d " , e@@ glGetError ( ) ) ; return false ; } return true ; } void C@@ GL@@ Context@@ E@@ GL :: Destroy ( ) { if ( m_@@ e@@ gl@@ Context != E@@ GL_@@ NO_@@ CON@@ TEXT ) { e@@ gl@@ Destroy@@ Context ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Context ) ; e@@ gl@@ Make@@ Curr@@ ent ( m_@@ e@@ gl@@ Display , E@@ GL_@@ NO@@ _SUR@@ FACE , E@@ GL_@@ NO@@ _SUR@@ FACE , E@@ GL_@@ NO_@@ CON@@ TEXT ) ; m_@@ e@@ gl@@ Context = E@@ GL_@@ NO_@@ CON@@ TEXT ; } if ( m_@@ e@@ gl@@ Surface != E@@ GL_@@ NO@@ _SUR@@ FACE ) { e@@ gl@@ Destroy@@ Surface ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Surface ) ; m_@@ e@@ gl@@ Surface = E@@ GL_@@ NO@@ _SUR@@ FACE ; } if ( m_@@ e@@ gl@@ Display != E@@ GL_@@ NO_@@ DISPLAY ) { e@@ gl@@ Termin@@ ate ( m_@@ e@@ gl@@ Display ) ; m_@@ e@@ gl@@ Display = E@@ GL_@@ NO_@@ DISPLAY ; } } void C@@ GL@@ Context@@ E@@ GL :: Detach ( ) { if ( m_@@ e@@ gl@@ Context != E@@ GL_@@ NO_@@ CON@@ TEXT ) { e@@ gl@@ Make@@ Curr@@ ent ( m_@@ e@@ gl@@ Display , E@@ GL_@@ NO@@ _SUR@@ FACE , E@@ GL_@@ NO@@ _SUR@@ FACE , E@@ GL_@@ NO_@@ CON@@ TEXT ) ; } if ( m_@@ e@@ gl@@ Surface != E@@ GL_@@ NO@@ _SUR@@ FACE ) { e@@ gl@@ Destroy@@ Surface ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Surface ) ; m_@@ e@@ gl@@ Surface = E@@ GL_@@ NO@@ _SUR@@ FACE ; } } bool C@@ GL@@ Context@@ E@@ GL :: Set@@ V@@ Sync ( bool enable ) { if ( ! e@@ gl@@ Swap@@ Interval ( m_@@ e@@ gl@@ Display , enable ) ) { return false ; } return true ; } void C@@ GL@@ Context@@ E@@ GL :: Swap@@ Buffers ( ) { if ( m_@@ e@@ gl@@ Display == E@@ GL_@@ NO_@@ DISPLAY || m_@@ e@@ gl@@ Surface == E@@ GL_@@ NO@@ _SUR@@ FACE ) { return ; } e@@ gl@@ Swap@@ Buffers ( m_@@ e@@ gl@@ Display , m_@@ e@@ gl@@ Surface ) ; } </DOCUMENT>
<DOCUMENT_ID="@@ Mat@@ t@@ Mul@@ h@@ ern@@ /Open@@ M@@ am@@ a@@ C@@ ass@@ and@@ ra@@ /tree/master/@@ m@@ am@@ d@@ a/@@ c_@@ cpp/src/@@ example@@ s/@@ par@@ sec@@ md@@ .cpp"> # include < m@@ am@@ a / m@@ am@@ a . h > # include < m@@ am@@ a / m@@ am@@ ac@@ pp . h > # include < m@@ am@@ a / M@@ am@@ a@@ Transport . h > # include " par@@ sec@@ md . h " # include < fstream > # include < iostream > # include < string > # include < map > # include < string . h > # include < m@@ am@@ da / M@@ am@@ da@@ Version . h > using std :: ifstream ; using std :: cerr ; using std :: string ; using std :: map ; using namespace W@@ o@@ mb@@ at ; typedef map < string , const char * > Option@@ Map ; extern void usa@@ ge ( int ) ; Example@@ Log@@ Level g@@ Example@@ Log@@ Level = EX@@ AMP@@ LE_@@ LOG_@@ LEVEL_@@ NORMAL ; struct Common@@ Command@@ Line@@ Parser :: Common@@ Command@@ Line@@ Parser@@ Impl { Common@@ Command@@ Line@@ Parser@@ Impl ( int argc , const char * argv [ ] ) ; const char * m@@ Source@@ Name ; const char * m@@ T@@ port@@ Name ; M@@ am@@ a@@ Source * m@@ Source ; const char * m@@ Dic@@ t@@ Source@@ Name ; const char * m@@ Dic@@ t@@ T@@ port@@ Name ; const char * m@@ Dic@@ t@@ FileName ; M@@ am@@ a@@ Source * m@@ Dic@@ t@@ Source ; const char * m@@ Option@@ Source@@ Name ; const char * m@@ Option@@ T@@ port@@ Name ; M@@ am@@ a@@ Source * m@@ Option@@ Source ; const char * m@@ Symbol@@ Map@@ File ; vector < const char * > m@@ Symbol@@ List ; double m@@ Th@@ rot@@ t@@ le@@ Rate ; int m@@ Threads ; double m@@ Time@@ out ; M@@ am@@ a@@ Log@@ Level m@@ Sub@@ sc@@ Log@@ Level ; Option@@ Map m@@ Options ; bool m@@ Log@@ Req@@ Resp ; bool m@@ Use@@ World@@ View ; const char * m@@ Symbo@@ log@@ y ; int m@@ Ch@@ urn@@ Rate ; double m@@ TimerInterval ; const char * m@@ Log@@ FileName ; const char * m@@ Midd@@ le@@ ware ; int m@@ Pre@@ cision ; int m@@ Shutdown@@ Time ; bool m@@ Show@@ Del@@ t@@ as ; m@@ am@@ aB@@ rid@@ ge m@@ B@@ rid@@ ge ; bool m@@ Sn@@ ap@@ Shot ; const char * m@@ Query@@ Ar@@ g@@ 1 ; const char * m@@ Query@@ Ar@@ g@@ 2 ; const char * m@@ Query@@ Ar@@ g@@ 3 ; const char * m@@ Query@@ Ar@@ g@@ 4 ; int m@@ Query ; int m@@ Query@@ Type ; int m@@ Query@@ C@@ y@@ cle@@ s ; bool m@@ Pub@@ lish@@ Rec@@ ap@@ s ; } ; Common@@ Command@@ Line@@ Parser :: Common@@ Command@@ Line@@ Parser ( int argc , const char * argv [ ] ) : m@@ Impl ( * new Common@@ Command@@ Line@@ Parser@@ Impl ( argc , argv ) ) { } Common@@ Command@@ Line@@ Parser :: ~ Common@@ Command@@ Line@@ Parser ( ) { delete & m@@ Impl ; } bool Common@@ Command@@ Line@@ Parser :: get@@ Pub@@ lish@@ Rec@@ ap@@ s ( ) { return m@@ Impl . m@@ Pub@@ lish@@ Rec@@ ap@@ s ; } M@@ am@@ a@@ Source * Common@@ Command@@ Line@@ Parser :: get@@ Source ( ) { if ( ! m@@ Impl . m@@ Source ) { m@@ Impl . m@@ Source = new M@@ am@@ a@@ Source ( " default " , m@@ Impl . m@@ T@@ port@@ Name , m@@ Impl . m@@ Source@@ Name , m@@ Impl . m@@ B@@ rid@@ ge ) ; m@@ Impl . m@@ Source -> get@@ Transport ( ) -> set@@ Out@@ bound@@ Th@@ rot@@ t@@ le ( m@@ Impl . m@@ Th@@ rot@@ t@@ le@@ Rate , MA@@ MA@@ _@@ THRO@@ TT@@ LE_@@ DEFAULT ) ; } return m@@ Impl . m@@ Source ; } M@@ am@@ a@@ Source * Common@@ Command@@ Line@@ Parser :: get@@ Dic@@ t@@ Source ( ) { if ( ! m@@ Impl . m@@ Dic@@ t@@ Source ) { m@@ Impl . m@@ Dic@@ t@@ Source = new M@@ am@@ a@@ Source ( " dic@@ t " , m@@ Impl . m@@ Dic@@ t@@ T@@ port@@ Name ? m@@ Impl . m@@ Dic@@ t@@ T@@ port@@ Name : m@@ Impl . m@@ T@@ port@@ Name , m@@ Impl . m@@ Dic@@ t@@ Source@@ Name , m@@ Impl . m@@ B@@ rid@@ ge ) ; } return m@@ Impl . m@@ Dic@@ t@@ Source ; } M@@ am@@ a@@ Source * Common@@ Command@@ Line@@ Parser :: getOption@@ Source ( ) { if ( ! m@@ Impl . m@@ Option@@ Source ) { m@@ Impl . m@@ Option@@ Source = new M@@ am@@ a@@ Source ( " options " , m@@ Impl . m@@ Option@@ T@@ port@@ Name ? m@@ Impl . m@@ Option@@ T@@ port@@ Name : m@@ Impl . m@@ T@@ port@@ Name , m@@ Impl . m@@ Option@@ Source@@ Name , m@@ Impl . m@@ B@@ rid@@ ge ) ; m@@ Impl . m@@ Option@@ Source -> get@@ Transport ( ) -> set@@ Out@@ bound@@ Th@@ rot@@ t@@ le ( m@@ Impl . m@@ Th@@ rot@@ t@@ le@@ Rate , MA@@ MA@@ _@@ THRO@@ TT@@ LE_@@ DEFAULT ) ; } return m@@ Impl . m@@ Option@@ Source ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Symbol@@ Map@@ File ( ) { return m@@ Impl . m@@ Symbol@@ Map@@ File ; } const vector < const char * > & Common@@ Command@@ Line@@ Parser :: get@@ Symbol@@ List ( ) { return m@@ Impl . m@@ Symbol@@ List ; } double Common@@ Command@@ Line@@ Parser :: get@@ Th@@ rot@@ t@@ le@@ Rate ( ) { return m@@ Impl . m@@ Th@@ rot@@ t@@ le@@ Rate ; } int Common@@ Command@@ Line@@ Parser :: getNum@@ Threads ( ) { return m@@ Impl . m@@ Threads ; } double Common@@ Command@@ Line@@ Parser :: get@@ Time@@ out ( ) { return m@@ Impl . m@@ Time@@ out ; } M@@ am@@ a@@ Log@@ Level Common@@ Command@@ Line@@ Parser :: getSub@@ sc@@ Log@@ Level ( ) { return m@@ Impl . m@@ Sub@@ sc@@ Log@@ Level ; } bool Common@@ Command@@ Line@@ Parser :: get@@ Use@@ World@@ view ( ) { return m@@ Impl . m@@ Use@@ World@@ View ; } bool Common@@ Command@@ Line@@ Parser :: get@@ Log@@ Req@@ Resp ( ) { return m@@ Impl . m@@ Log@@ Req@@ Resp ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Symbo@@ log@@ y ( ) { return m@@ Impl . m@@ Symbo@@ log@@ y ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Midd@@ le@@ ware ( ) { return m@@ Impl . m@@ Midd@@ le@@ ware ; } int Common@@ Command@@ Line@@ Parser :: getPrecision ( ) { return m@@ Impl . m@@ Pre@@ cision ; } int Common@@ Command@@ Line@@ Parser :: get@@ Shutdown@@ Time ( ) { return m@@ Impl . m@@ Shutdown@@ Time ; } bool Common@@ Command@@ Line@@ Parser :: show@@ Del@@ t@@ as ( ) { return m@@ Impl . m@@ Show@@ Del@@ t@@ as ; } m@@ am@@ aB@@ rid@@ ge Common@@ Command@@ Line@@ Parser :: get@@ B@@ rid@@ ge ( ) { return m@@ Impl . m@@ B@@ rid@@ ge ; } bool Common@@ Command@@ Line@@ Parser :: get@@ Sn@@ ap@@ shot ( ) { return m@@ Impl . m@@ Sn@@ ap@@ Shot ; } bool Common@@ Command@@ Line@@ Parser :: get@@ Opt@@ Bool ( char option@@ 0 ) { string option ( & option@@ 0 , 0 , 1 ) ; Option@@ Map :: iterator found = m@@ Impl . m@@ Options . find ( option ) ; return ( found != m@@ Impl . m@@ Options . end ( ) ) ; } bool Common@@ Command@@ Line@@ Parser :: get@@ Opt@@ Bool ( const char * option@@ 0 ) { string option ( option@@ 0 ) ; Option@@ Map :: iterator found = m@@ Impl . m@@ Options . find ( option ) ; return ( found != m@@ Impl . m@@ Options . end ( ) ) ; } int Common@@ Command@@ Line@@ Parser :: get@@ Opt@@ Int ( char option@@ 0 , int defaultValue ) { string option ( & option@@ 0 , 0 , 1 ) ; Option@@ Map :: iterator found = m@@ Impl . m@@ Options . find ( option ) ; if ( found != m@@ Impl . m@@ Options . end ( ) ) { const char * value = found -> second ; if ( value ) return strto@@ l ( value , NULL , 10 ) ; } return defaultValue ; } int Common@@ Command@@ Line@@ Parser :: get@@ Opt@@ Int ( const char * option@@ 0 , int defaultValue ) { string option ( option@@ 0 ) ; Option@@ Map :: iterator found = m@@ Impl . m@@ Options . find ( option ) ; if ( found != m@@ Impl . m@@ Options . end ( ) ) { const char * value = found -> second ; if ( value ) return strto@@ l ( value , NULL , 10 ) ; } return defaultValue ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Opt@@ String ( char option@@ 0 ) { string option ( & option@@ 0 , 0 , 1 ) ; Option@@ Map :: iterator found = m@@ Impl . m@@ Options . find ( option ) ; if ( found != m@@ Impl . m@@ Options . end ( ) ) { return found -> second ; } return NULL ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Opt@@ String ( const char * option@@ 0 ) { string option ( option@@ 0 ) ; Option@@ Map :: iterator found = m@@ Impl . m@@ Options . find ( option ) ; if ( found != m@@ Impl . m@@ Options . end ( ) ) { return found -> second ; } return NULL ; } int Common@@ Command@@ Line@@ Parser :: get@@ Ch@@ urn@@ Rate ( ) { return m@@ Impl . m@@ Ch@@ urn@@ Rate ; } double Common@@ Command@@ Line@@ Parser :: get@@ TimerInterval ( ) { return m@@ Impl . m@@ TimerInterval ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Log@@ FileName ( ) { return m@@ Impl . m@@ Log@@ FileName ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Query@@ Ar@@ g@@ 1 ( ) { return m@@ Impl . m@@ Query@@ Ar@@ g@@ 1 ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Query@@ Ar@@ g@@ 2 ( ) { return m@@ Impl . m@@ Query@@ Ar@@ g@@ 2 ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Query@@ Ar@@ g@@ 3 ( ) { return m@@ Impl . m@@ Query@@ Ar@@ g@@ 3 ; } const char * Common@@ Command@@ Line@@ Parser :: get@@ Query@@ Ar@@ g@@ 4 ( ) { return m@@ Impl . m@@ Query@@ Ar@@ g@@ 4 ; } int Common@@ Command@@ Line@@ Parser :: get@@ Query ( ) { return m@@ Impl . m@@ Query ; } int Common@@ Command@@ Line@@ Parser :: get@@ Query@@ Type ( ) { return m@@ Impl . m@@ Query@@ Type ; } int Common@@ Command@@ Line@@ Parser :: get@@ Queries ( ) { return m@@ Impl . m@@ Query@@ C@@ y@@ cle@@ s ; } Common@@ Command@@ Line@@ Parser :: Common@@ Command@@ Line@@ Parser@@ Impl :: Common@@ Command@@ Line@@ Parser@@ Impl ( int argc , const char * argv [ ] ) { m@@ Source = NULL ; m@@ Dic@@ t@@ Source = NULL ; m@@ Option@@ Source = NULL ; m@@ Symbol@@ Map@@ File = NULL ; m@@ Th@@ rot@@ t@@ le@@ Rate = 500@@ .0 ; m@@ Threads = 0 ; m@@ Time@@ out = 1.0 ; m@@ Ch@@ urn@@ Rate = 0 ; m@@ TimerInterval = 1.0 ; m@@ Log@@ FileName = NULL ; m@@ Midd@@ le@@ ware = " w@@ m@@ w " ; m@@ Pre@@ cision = 2 ; m@@ Shutdown@@ Time = 0 ; m@@ Show@@ Del@@ t@@ as = false ; m@@ B@@ rid@@ ge = NULL ; int i = 1 ; m@@ Use@@ World@@ View = false ; m@@ T@@ port@@ Name = NULL ; m@@ Dic@@ t@@ T@@ port@@ Name = NULL ; m@@ Option@@ T@@ port@@ Name = NULL ; m@@ Source@@ Name = " W@@ O@@ MB@@ AT " ; m@@ Dic@@ t@@ Source@@ Name = " W@@ O@@ MB@@ AT " ; m@@ Option@@ Source@@ Name = " OP@@ RA " ; m@@ Sn@@ ap@@ Shot = false ; m@@ Pub@@ lish@@ Rec@@ ap@@ s = false ; m@@ Query@@ Ar@@ g@@ 1 = NULL ; m@@ Query@@ Ar@@ g@@ 2 = NULL ; m@@ Query@@ Ar@@ g@@ 3 = NULL ; m@@ Query@@ Ar@@ g@@ 4 = NULL ; m@@ Query = 0 ; m@@ Query@@ Type = 0 ; m@@ Query@@ C@@ y@@ cle@@ s = 1 ; while ( i < argc ) { bool hand@@ led = false ; if ( ( strcmp ( argv [ i ] , " - OS " ) == 0 ) || ( strcmp ( argv [ i ] , " - option@@ Source " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - source " ) == 0 ) ) { m@@ Option@@ Source@@ Name = argv [ i + 1 ] ; hand@@ led = true ; } else if ( ( strcmp ( argv [ i ] , " - S " ) == 0 ) || ( strcmp ( argv [ i ] , " - source " ) == 0 ) ) { m@@ Source@@ Name = argv [ i + 1 ] ; hand@@ led = true ; } else if ( ( strcmp ( argv [ i ] , " - use _ dic@@ t _ file " ) == 0 ) ) { m@@ Dic@@ t@@ FileName = argv [ i + 1 ] ; } else if ( ( strcmp ( argv [ i ] , " - DS " ) == 0 ) || ( strcmp ( argv [ i ] , " - dic@@ t - source " ) == 0 ) || ( strcmp ( argv [ i ] , " - dic@@ t@@ Source " ) == 0 ) || ( strcmp ( argv [ i ] , " - d " ) == 0 ) ) { m@@ Dic@@ t@@ Source@@ Name = argv [ i + 1 ] ; hand@@ led = true ; } else if ( ( strcmp ( argv [ i ] , " - T " ) == 0 ) || ( strcmp ( argv [ i ] , " - t@@ port " ) == 0 ) ) { m@@ T@@ port@@ Name = argv [ i + 1 ] ; hand@@ led = true ; } else if ( ( strcmp ( argv [ i ] , " - D@@ T " ) == 0 ) || ( strcmp ( argv [ i ] , " - dic@@ t@@ T@@ port " ) == 0 ) || ( strcmp ( argv [ i ] , " - dic@@ t - t@@ port " ) == 0 ) || ( strcmp ( argv [ i ] , " - dic@@ t _ t@@ port " ) == 0 ) ) { m@@ Dic@@ t@@ T@@ port@@ Name = argv [ i + 1 ] ; hand@@ led = true ; } else if ( ( strcmp ( argv [ i ] , " - OT " ) == 0 ) || ( strcmp ( argv [ i ] , " - option@@ T@@ port " ) == 0 ) || ( strcmp ( argv [ i ] , " - option - t@@ port " ) == 0 ) ) { m@@ Option@@ T@@ port@@ Name = argv [ i + 1 ] ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - s " ) == 0 ) { m@@ Symbol@@ List . push_back ( argv [ i + 1 ] ) ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - threads " ) == 0 ) { m@@ Threads = strto@@ l ( argv [ i + 1 ] , NULL , 10 ) ; hand@@ led = true ; } else if ( ( strcmp ( argv [ i ] , " - r " ) == 0 ) || ( strcmp ( argv [ i ] , " - rate " ) == 0 ) ) { m@@ Th@@ rot@@ t@@ le@@ Rate = strto@@ d ( argv [ i + 1 ] , NULL ) ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - t " ) == 0 ) { m@@ Time@@ out = strto@@ d ( argv [ i + 1 ] , NULL ) ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - mp " ) == 0 ) { m@@ Symbol@@ Map@@ File = argv [ i + 1 ] ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - m " ) == 0 ) { m@@ Midd@@ le@@ ware = argv [ i + 1 ] ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - precision " ) == 0 ) { m@@ Pre@@ cision = strto@@ l ( argv [ i + 1 ] , NULL , 10 ) ; if ( ! m@@ Pre@@ cision ) { m@@ Pre@@ cision = 2 ; } if ( m@@ Pre@@ cision > 6 ) { m@@ Pre@@ cision = 6 ; } hand@@ led = true ; } else if ( strcmp ( " - sh@@ ut@@ down " , argv [ i ] ) == 0 ) { m@@ Shutdown@@ Time = ato@@ i ( argv [ i + 1 ] ) ; } else if ( strcmp ( argv [ i ] , " - del@@ t@@ as " ) == 0 ) { m@@ Show@@ Del@@ t@@ as = true ; } else if ( strcmp ( argv [ i ] , " - ch@@ urn " ) == 0 ) { m@@ Ch@@ urn@@ Rate = strto@@ l ( argv [ i + 1 ] , NULL , 10 ) ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - timer@@ Interval " ) == 0 ) { m@@ TimerInterval = strto@@ d ( argv [ i + 1 ] , NULL ) ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - log@@ file " ) == 0 ) { m@@ Log@@ FileName = argv [ i + 1 ] ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - f " ) == 0 ) { const char * filename = argv [ i + 1 ] ; ifstream input ( filename ) ; if ( ! input ) { cerr << " Cannot ▁ open ▁ file : ▁ " << filename << " \n " ; exit ( 1 ) ; } string symbol ; input >> symbol ; while ( ! input . eof ( ) ) { if ( ! symbol . empty ( ) ) { m@@ Symbol@@ List . push_back ( strdup ( symbol . c_str ( ) ) ) ; } input >> symbol ; } hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - v " ) == 0 ) { if ( m@@ am@@ a_@@ get@@ Log@@ Level ( ) == MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ NORMAL ) { m@@ am@@ a_@@ enable@@ Logging ( stderr , MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ E ) ; } else if ( m@@ am@@ a_@@ get@@ Log@@ Level ( ) == MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ E ) { m@@ am@@ a_@@ enable@@ Logging ( stderr , MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ ER ) ; } else { m@@ am@@ a_@@ enable@@ Logging ( stderr , MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ EST ) ; } hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - q " ) == 0 ) { if ( g@@ Example@@ Log@@ Level == EX@@ AMP@@ LE_@@ LOG_@@ LEVEL_@@ NORMAL ) { g@@ Example@@ Log@@ Level = EX@@ AMP@@ LE_@@ LOG_@@ LEVEL_@@ QU@@ I@@ E@@ T ; } else if ( g@@ Example@@ Log@@ Level == EX@@ AMP@@ LE_@@ LOG_@@ LEVEL_@@ QU@@ I@@ E@@ T ) { g@@ Example@@ Log@@ Level = EX@@ AMP@@ LE_@@ LOG_@@ LEVEL_@@ QU@@ I@@ E@@ TER ; } else if ( g@@ Example@@ Log@@ Level == EX@@ AMP@@ LE_@@ LOG_@@ LEVEL_@@ QU@@ I@@ E@@ TER ) { g@@ Example@@ Log@@ Level = EX@@ AMP@@ LE_@@ LOG_@@ LEVEL_@@ QU@@ I@@ E@@ TEST ; } hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - V " ) == 0 ) { if ( m@@ Sub@@ sc@@ Log@@ Level == MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ NORMAL ) { m@@ Sub@@ sc@@ Log@@ Level = MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ E ; } else if ( m@@ Sub@@ sc@@ Log@@ Level == MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ E ) { m@@ Sub@@ sc@@ Log@@ Level = MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ ER ; } else { m@@ Sub@@ sc@@ Log@@ Level = MA@@ MA@@ _@@ LOG_@@ LEVEL_@@ FIN@@ EST ; } hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - W " ) == 0 ) { m@@ Use@@ World@@ View = true ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - L " ) == 0 ) { m@@ Log@@ Req@@ Resp = true ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - Y " ) == 0 ) { m@@ Symbo@@ log@@ y = argv [ i + 1 ] ; hand@@ led = true ; } else if ( ( strcmp ( argv [ i ] , " - ? " ) == 0 ) || ( strcmp ( argv [ i ] , " - - help " ) == 0 ) ) { usa@@ ge ( 1 ) ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - P@@ R " ) == 0 ) { m@@ Pub@@ lish@@ Rec@@ ap@@ s = true ; } else if ( strcmp ( argv [ i ] , " - 1" ) == 0 ) { m@@ Sn@@ ap@@ Shot = true ; hand@@ led = true ; } else if ( strcmp ( argv [ i ] , " - Q " ) == 0 ) { m@@ Query = strto@@ l ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - Q@@ T " ) == 0 ) { m@@ Query@@ Type = strto@@ l ( argv [ i + 1 ] , NULL , 10 ) ; } else if ( strcmp ( argv [ i ] , " - A@@ 1" ) == 0 ) { m@@ Query@@ Ar@@ g@@ 1 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A@@ 2" ) == 0 ) { m@@ Query@@ Ar@@ g@@ 2 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A@@ 3" ) == 0 ) { m@@ Query@@ Ar@@ g@@ 3 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - A@@ 4" ) == 0 ) { m@@ Query@@ Ar@@ g@@ 4 = argv [ i + 1 ] ; } else if ( strcmp ( argv [ i ] , " - Q@@ C " ) == 0 ) { m@@ Query@@ C@@ y@@ cle@@ s = strto@@ l ( argv [ i + 1 ] , NULL , 10 ) ; } if ( argv [ i ] [ 0 ] == ' - ' ) { const char * opt = argv [ i ] + 1 ; if ( strlen ( opt ) > 0 ) { if ( ( i + 1 < argc ) && ( argv [ i + 1 ] [ 0 ] != ' - ' ) ) { m@@ Options [ opt ] = argv [ i + 1 ] ; i += 2 ; } else { m@@ Options [ opt ] = "1" ; i ++ ; } } hand@@ led = true ; } if ( ! hand@@ led ) { usa@@ ge ( 1 ) ; } } m@@ B@@ rid@@ ge = M@@ am@@ a :: load@@ B@@ rid@@ ge ( m@@ Midd@@ le@@ ware ) ; } </DOCUMENT>
<DOCUMENT_ID="f@@ stu@@ dio@@ /@@ P@@ ho@@ en@@ ix@@ /tree/master/@@ test/@@ Ex@@ per@@ iment@@ al@@ /libcxx/test/@@ std@@ /string@@ s/@@ char@@ .@@ trait@@ s/@@ char@@ .@@ trait@@ s@@ .@@ special@@ ization@@ s/@@ char@@ .@@ trait@@ s@@ .@@ special@@ ization@@ s@@ .@@ char@@ 16@@ _t@@ /@@ e@@ of@@ .pass.cpp"> # include < string > # include < cassert > int main ( ) { # ifndef _LIB@@ CPP_@@ HAS_@@ NO_@@ UNICODE_@@ CHAR@@ S std :: char@@ _traits < char16_t > :: int_type i = std :: char@@ _traits < char16_t > :: eof ( ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="j@@ e@@ pp@@ eter@@ /my@@ sql@@ 56@@ /tree/master/storage@@ /ndb@@ /src/@@ cw@@ /@@ cp@@ cd@@ /@@ Mon@@ it@@ or@@ .cpp"> # include < ndb@@ _@@ global . h > # include < Ndb@@ Thread . h > # include < Ndb@@ Out . hpp > # include < Ndb@@ Sleep . h > # include " CP@@ C@@ D . hpp " # include " common . hpp " static void * mon@@ it@@ or_@@ thread@@ _@@ create_@@ wrapper ( void * arg ) { CP@@ C@@ D :: Monitor * mon = ( CP@@ C@@ D :: Monitor * ) arg ; mon -> run ( ) ; return NULL ; } CP@@ C@@ D :: Monitor :: Monitor ( CP@@ C@@ D * cp@@ cd , int poll ) { m_@@ cp@@ cd = cp@@ cd ; m_po@@ ll@@ ing@@ Interval = poll ; m_@@ change@@ Condit@@ ion = Ndb@@ Condition@@ _@@ Create ( ) ; m_@@ change@@ Mutex = Ndb@@ Mutex@@ _@@ Create ( ) ; m_@@ mon@@ it@@ or@@ Thread = Ndb@@ Thread@@ _@@ Create ( mon@@ it@@ or_@@ thread@@ _@@ create_@@ wrapper , ( NDB_@@ THREAD_@@ ARG * ) this , 0 , " n@@ db _ cp@@ cd _ monitor " , NDB_@@ THREAD_@@ PRI@@ O_@@ MEAN ) ; m_@@ mon@@ it@@ or@@ Thread@@ Quit@@ Flag = false ; } CP@@ C@@ D :: Monitor :: ~ Monitor ( ) { Ndb@@ Thread@@ _@@ Destroy ( & m_@@ mon@@ it@@ or@@ Thread ) ; Ndb@@ Condition@@ _@@ Destroy ( m_@@ change@@ Condit@@ ion ) ; Ndb@@ Mutex@@ _@@ Destroy ( m_@@ change@@ Mutex ) ; } void CP@@ C@@ D :: Monitor :: run ( ) { while ( 1 ) { Ndb@@ Mutex@@ _@@ Lock ( m_@@ change@@ Mutex ) ; Ndb@@ Condition@@ _@@ Wait@@ Time@@ out ( m_@@ change@@ Condit@@ ion , m_@@ change@@ Mutex , m_po@@ ll@@ ing@@ Interval * 1000 ) ; Mutex@@ Vector < CP@@ C@@ D :: Process * > & proc = * m_@@ cp@@ cd -> get@@ Process@@ List ( ) ; proc . lock ( ) ; for ( size_t i = 0 ; i < proc . size ( ) ; i ++ ) { proc [ i ] -> monitor ( ) ; } proc . unlock ( ) ; Ndb@@ Mutex@@ _@@ Unlock ( m_@@ change@@ Mutex ) ; } } void CP@@ C@@ D :: Monitor :: signal ( ) { Ndb@@ Condition@@ _S@@ ign@@ al ( m_@@ change@@ Condit@@ ion ) ; } template class Mutex@@ Vector < CP@@ C@@ D :: Process * > ; </DOCUMENT>
<DOCUMENT_ID="m@@ ur@@ ray@@ me@@ e@@ han@@ /@@ mar@@ sy@@ as@@ /tree/master/src/@@ other@@ lib@@ s/@@ AN@@ N@@ /@@ k@@ d_@@ pr@@ _@@ search@@ .cpp"> # include " kd _ pr _ se@@ arch . h " double AN@@ N@@ pr@@ E@@ ps ; int AN@@ N@@ pr@@ Dim ; AN@@ N@@ point AN@@ N@@ pr@@ Q ; double AN@@ N@@ pr@@ Max@@ Err ; AN@@ N@@ point@@ Array AN@@ N@@ pr@@ P@@ ts ; AN@@ N@@ pr@@ _queue * AN@@ N@@ pr@@ Box@@ P@@ Q ; AN@@ N@@ min_@@ k * AN@@ N@@ pr@@ Point@@ M@@ K ; void AN@@ N@@ k@@ d_@@ tree :: an@@ n@@ k@@ Pri@@ Search ( AN@@ N@@ point q , int k , AN@@ N@@ idx@@ Array n@@ n_@@ idx , AN@@ N@@ dist@@ Array dd , double e@@ ps ) { AN@@ N@@ pr@@ Max@@ Err = AN@@ N_@@ PO@@ W ( 1.0 + e@@ ps ) ; AN@@ N@@ _FLO@@ P ( 2 ) AN@@ N@@ pr@@ Dim = di@@ m ; AN@@ N@@ pr@@ Q = q ; AN@@ N@@ pr@@ P@@ ts = pts ; AN@@ N@@ pt@@ s@@ Visited = 0 ; AN@@ N@@ pr@@ Point@@ M@@ K = new AN@@ N@@ min_@@ k ( k ) ; AN@@ N@@ dist box_@@ dist = an@@ n@@ Box@@ Di@@ stance ( q , bn@@ d_@@ box_@@ lo , bn@@ d_@@ box_@@ h@@ i , di@@ m ) ; AN@@ N@@ pr@@ Box@@ P@@ Q = new AN@@ N@@ pr@@ _queue ( n_@@ pts ) ; AN@@ N@@ pr@@ Box@@ P@@ Q -> insert ( box_@@ dist , root ) ; while ( AN@@ N@@ pr@@ Box@@ P@@ Q -> non_@@ empty ( ) && ( ! ( AN@@ N@@ max@@ P@@ ts@@ Visited != 0 && AN@@ N@@ pt@@ s@@ Visited > AN@@ N@@ max@@ P@@ ts@@ Visited ) ) ) { AN@@ N@@ k@@ d_ptr n@@ p ; AN@@ N@@ pr@@ Box@@ P@@ Q -> extr@@ _@@ min ( box_@@ dist , ( void * & ) n@@ p ) ; AN@@ N@@ _FLO@@ P ( 2 ) if ( box_@@ dist * AN@@ N@@ pr@@ Max@@ Err >= AN@@ N@@ pr@@ Point@@ M@@ K -> max_@@ key ( ) ) break ; n@@ p -> an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( box_@@ dist ) ; } for ( int i = 0 ; i < k ; i ++ ) { dd [ i ] = AN@@ N@@ pr@@ Point@@ M@@ K -> ith@@ _@@ smalle@@ st_@@ key ( i ) ; n@@ n_@@ idx [ i ] = AN@@ N@@ pr@@ Point@@ M@@ K -> ith@@ _@@ smallest@@ _info ( i ) ; } delete AN@@ N@@ pr@@ Point@@ M@@ K ; delete AN@@ N@@ pr@@ Box@@ P@@ Q ; } void AN@@ N@@ k@@ d_@@ split :: an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( AN@@ N@@ dist box_@@ dist ) { AN@@ N@@ dist new_@@ dist ; AN@@ N@@ co@@ ord c@@ ut_@@ diff = AN@@ N@@ pr@@ Q [ c@@ ut_@@ di@@ m ] - c@@ ut_@@ val ; if ( c@@ ut_@@ diff < 0 ) { AN@@ N@@ co@@ ord box_@@ diff = cd@@ _b@@ n@@ ds [ AN@@ N_@@ LO ] - AN@@ N@@ pr@@ Q [ c@@ ut_@@ di@@ m ] ; if ( box_@@ diff < 0 ) box_@@ diff = 0 ; new_@@ dist = ( AN@@ N@@ dist ) AN@@ N@@ _SU@@ M ( box_@@ dist , AN@@ N_@@ D@@ IF@@ F ( AN@@ N_@@ PO@@ W ( box_@@ diff ) , AN@@ N_@@ PO@@ W ( c@@ ut_@@ diff ) ) ) ; if ( child [ AN@@ N_@@ H@@ I ] != K@@ D_@@ TRI@@ VI@@ AL ) AN@@ N@@ pr@@ Box@@ P@@ Q -> insert ( new_@@ dist , child [ AN@@ N_@@ H@@ I ] ) ; child [ AN@@ N_@@ LO ] -> an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( box_@@ dist ) ; } else { AN@@ N@@ co@@ ord box_@@ diff = AN@@ N@@ pr@@ Q [ c@@ ut_@@ di@@ m ] - cd@@ _b@@ n@@ ds [ AN@@ N_@@ H@@ I ] ; if ( box_@@ diff < 0 ) box_@@ diff = 0 ; new_@@ dist = ( AN@@ N@@ dist ) AN@@ N@@ _SU@@ M ( box_@@ dist , AN@@ N_@@ D@@ IF@@ F ( AN@@ N_@@ PO@@ W ( box_@@ diff ) , AN@@ N_@@ PO@@ W ( c@@ ut_@@ diff ) ) ) ; if ( child [ AN@@ N_@@ LO ] != K@@ D_@@ TRI@@ VI@@ AL ) AN@@ N@@ pr@@ Box@@ P@@ Q -> insert ( new_@@ dist , child [ AN@@ N_@@ LO ] ) ; child [ AN@@ N_@@ H@@ I ] -> an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( box_@@ dist ) ; } AN@@ N@@ _SP@@ L ( 1 ) AN@@ N@@ _FLO@@ P ( 8 ) } void AN@@ N@@ k@@ d_@@ le@@ af :: an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( AN@@ N@@ dist box_@@ dist ) { regi@@ ster AN@@ N@@ dist dist ; regi@@ ster AN@@ N@@ co@@ ord * pp ; regi@@ ster AN@@ N@@ co@@ ord * q@@ q ; regi@@ ster AN@@ N@@ dist min_@@ dist ; regi@@ ster AN@@ N@@ co@@ ord t ; regi@@ ster int d ; min_@@ dist = AN@@ N@@ pr@@ Point@@ M@@ K -> max_@@ key ( ) ; for ( int i = 0 ; i < n_@@ pts ; i ++ ) { pp = AN@@ N@@ pr@@ P@@ ts [ b@@ k@@ t [ i ] ] ; q@@ q = AN@@ N@@ pr@@ Q ; dist = 0 ; for ( d = 0 ; d < AN@@ N@@ pr@@ Dim ; d ++ ) { AN@@ N_@@ CO@@ OR@@ D ( 1 ) AN@@ N@@ _FLO@@ P ( 4 ) t = * ( q@@ q ++ ) - * ( pp ++ ) ; if ( ( dist = AN@@ N@@ _SU@@ M ( dist , AN@@ N_@@ PO@@ W ( t ) ) ) > min_@@ dist ) { break ; } } if ( d >= AN@@ N@@ pr@@ Dim && ( AN@@ N_@@ ALLO@@ W_S@@ EL@@ F_@@ MATCH || dist != 0 ) ) { AN@@ N@@ pr@@ Point@@ M@@ K -> insert ( dist , b@@ k@@ t [ i ] ) ; min_@@ dist = AN@@ N@@ pr@@ Point@@ M@@ K -> max_@@ key ( ) ; } } AN@@ N_@@ LEA@@ F ( 1 ) AN@@ N_@@ PTS ( n_@@ pts ) AN@@ N@@ pt@@ s@@ Visited += n_@@ pts ; } </DOCUMENT>
<DOCUMENT_ID="@@ t@@ pl@@ tn@@ t/@@ un@@ cr@@ ust@@ ify@@ /tree/master/tests/@@ output@@ /cpp/@@ 309@@ 20-@@ ind@@ ent@@ -@@ off@@ .cpp"> struct X { void operator - ( int ) ; void operator + ( int ) ; void operator ( ) ( ) ; } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TAB@@ SY@@ M@@ BO@@ L test@@ \t ▁ TAB@@ SY@@ M@@ BO@@ L ▁ TAB@@ SY@@ M@@ BO@@ L ▁ TAB@@ SY@@ M@@ BO@@ L TAB@@ SY@@ M@@ BO@@ L . . . ▁ ▁ ▁ ? ? ? " ; } } ; struct Y { void operator - ( int ) { } void operator + ( int ) { } void operator ( ) ( ) { } void func ( ) { auto x = " TAB@@ SY@@ M@@ BO@@ L test@@ \t ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ . . . ▁ ▁ ▁ ? ? ? " ; } } ; </DOCUMENT>
<DOCUMENT_ID="@@ pat@@ mar@@ ion/@@ P@@ CL@@ /tree/master/@@ sample@@ _@@ con@@ s@@ en@@ su@@ s/@@ src/@@ ran@@ sa@@ c@@ .cpp"> # include < pc@@ l / impl / instantiate . hpp > # include < pc@@ l / point@@ _@@ types . h > # include < pc@@ l / sample@@ _@@ con@@ sens@@ us / ran@@ sa@@ c . h > # include < pc@@ l / sample@@ _@@ con@@ sens@@ us / impl / ran@@ sa@@ c . hpp > # ifdef PC@@ L_@@ ONLY_@@ COR@@ E_@@ POINT_@@ TYPES PC@@ L_@@ INSTANTI@@ ATE ( Random@@ Sample@@ Consens@@ us , ( pc@@ l :: Point@@ XY@@ Z ) ( pc@@ l :: Point@@ XY@@ Z@@ I ) ( pc@@ l :: Point@@ XY@@ Z@@ RGB@@ A ) ( pc@@ l :: Point@@ XY@@ Z@@ RGB ) ) # else PC@@ L_@@ INSTANTI@@ ATE ( Random@@ Sample@@ Consens@@ us , PC@@ L_@@ XY@@ Z@@ _@@ POINT_@@ TYPES ) # endif </DOCUMENT>
