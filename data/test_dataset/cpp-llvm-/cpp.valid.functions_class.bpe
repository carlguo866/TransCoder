void Driver_Document :: SetFile ( const std :: string & theFileName ) { myFile = theFileName ; }
void Driver_Document :: SetDocument ( SMES@@ HDS_@@ Document * theDocument ) { myDocument = theDocument ; }
void CCustomData :: Copy ( CCustomData * pCustomData ) { std :: map < std :: string , SCustomData > :: const_iterator iter = pCustomData -> IterBegin ( ) ; for ( ; iter != pCustomData -> IterEnd ( ) ; iter ++ ) { Set ( iter -> first . c_str ( ) , iter -> second . Variable ) ; } }
SCustomData * CCustomData :: Get ( const char * szName ) { assert ( szName ) ; std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) return & it -> second ; return NULL ; }
void CCustomData :: Set ( const char * szName , const CLua@@ Argument & Variable , bool bSynchronized ) { assert ( szName ) ; SCustomData * pData = Get ( szName ) ; if ( pData ) { pData -> Variable = Variable ; pData -> bSynchronized = bSynchronized ; } else { SCustomData newData ; newData . Variable = Variable ; newData . bSynchronized = bSynchronized ; m_Data [ szName ] = newData ; } }
bool CCustomData :: Delete ( const char * szName ) { std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) { m_Data . erase ( it ) ; return true ; } return false ; }
int GetOptLong :: getoption ( void ) { const char * oli ; if ( ! * place ) { if ( optind >= argc ) { place = " " ; return - 1 ; } place = argv [ optind ] ; if ( place [ 0 ] != ' - ' ) { place = " " ; return - 1 ; } place ++ ; if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] == ' \0' ) { ++ optind ; place = " " ; return - 1 ; } if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] ) { size_t namelen ; int i ; place ++ ; namelen = strcsp@@ n ( place , " = " ) ; for ( i = 0 ; longopts [ i ] . name != NULL ; i ++ ) { if ( strlen ( longopts [ i ] . name ) == namelen && strncmp ( place , longopts [ i ] . name , namelen ) == 0 ) { if ( longopts [ i ] . has_@@ arg ) { if ( place [ namelen ] == ' = ' ) optarg = place + namelen + 1 ; else if ( optind < argc - 1 ) { optind ++ ; optarg = argv [ optind ] ; } else { if ( optstring [ 0 ] == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } else { optarg = NULL ; if ( place [ namelen ] != 0 ) { } } optind ++ ; longindex = i ; place = " " ; if ( longopts [ i ] . flag == NULL ) return longopts [ i ] . val ; else { * longopts [ i ] . flag = longopts [ i ] . val ; return 0 ; } } } if ( opterr && optstring [ 0 ] != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } optopt = ( int ) * place ++ ; oli = strchr ( optstring , optopt ) ; if ( ! oli ) { if ( ! * place ) ++ optind ; if ( opterr && * optstring != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } if ( oli [ 1 ] != ' : ' ) { optarg = NULL ; if ( ! * place ) ++ optind ; } else { if ( * place ) optarg = place ; else if ( argc <= ++ optind ) { place = " " ; if ( * optstring == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } else optarg = argv [ optind ] ; place = " " ; ++ optind ; } return optopt ; }
mscorlib :: System :: String SoapNmtoken :: GetXsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " GetXsdType " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; }
mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( const char * value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( " mscorlib " , " System " , " String " ) ; __parameters__ [ 0 ] = mono@@ _string_@@ new ( Global :: GetDo@@ main ( ) , value ) ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; }
mscorlib :: System :: String SoapNmtoken :: ToString ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " ToString " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
void SoapNmtoken :: set_Value ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " set _ Value " , __native_object__ , 1 , __parameter_types__ , __parameters__ , NULL ) ; }
mscorlib :: System :: String SoapNmtoken :: get_XsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ XsdType " , NullMonoObject , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
void SoapNmtoken :: set_XsdType ( mscorlib :: System :: String value ) { throw ; }
XbelWriter :: XbelWriter ( BookmarkModel * model ) : QXmlStream@@ Writer ( ) , treeModel ( model ) { setAuto@@ Formatting ( true ) ; }
void XbelWriter :: writeTo@@ File ( QIODevice * device ) { setDevice ( device ) ; writeStart@@ Document ( ) ; writeDT@@ D ( QLatin1String ( " < ! DOCTYPE ▁ xbel > " ) ) ; writeStartElement ( QLatin1String ( " xbel " ) ) ; writeAttribute ( QLatin1String ( " version " ) , QLatin1String ( "1.0" ) ) ; QStandardItem * root = treeModel -> invis@@ ible@@ RootItem ( ) ; for ( int i = 0 ; i < root -> rowCount ( ) ; ++ i ) writeData ( root -> child ( i ) ) ; writeEnd@@ Document ( ) ; }
void XbelWriter :: writeData ( QStandardItem * child ) { Bookmark entry ; entry . title = child -> data ( Qt :: DisplayRole ) . toString ( ) ; entry . url = child -> data ( Qt :: UserRole + 10 ) . toString ( ) ; if ( entry . url == QLatin1String ( " Folder " ) ) { writeStartElement ( QLatin1String ( " folder " ) ) ; entry . folded = ! child -> data ( Qt :: UserRole + 11 ) . toBool ( ) ; writeAttribute ( QLatin1String ( " folded " ) , entry . folded ? QLatin1String ( " yes " ) : QLatin1String ( " no " ) ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; for ( int i = 0 ; i < child -> rowCount ( ) ; ++ i ) writeData ( child -> child ( i ) ) ; writeEndElement ( ) ; } else { writeStartElement ( QLatin1String ( " bookmark " ) ) ; writeAttribute ( QLatin1String ( " href " ) , entry . url ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; writeEndElement ( ) ; } }
XbelReader :: XbelReader ( BookmarkModel * tree , BookmarkModel * list ) : QXmlStream@@ Reader ( ) , treeModel ( tree ) , listModel ( list ) { bookmarkIcon = QIcon ( QLatin1String ( " : / help / images / bookmark . png " ) ) ; folderIcon = QApplication :: style ( ) -> standardIcon ( QStyle :: SP_Dir@@ ClosedIcon ) ; }
bool XbelReader :: readFromFile ( QIODevice * device ) { setDevice ( device ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " xbel " ) && attributes ( ) . value ( QLatin1String ( " version " ) ) == QLatin1String ( "1.0" ) ) { readXBEL ( ) ; } else { raise@@ Error ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " The ▁ file ▁ is ▁ not ▁ an ▁ XBEL ▁ version ▁ 1.0 ▁ file . " ) ) ; } } } return ! error ( ) ; }
void XbelReader :: readXBEL ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( 0 ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( 0 ) ; else readUnknownElement ( ) ; } } }
void XbelReader :: readUnknownElement ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) readUnknownElement ( ) ; } }
void XbelReader :: readFolder ( QStandardItem * item ) { QStandardItem * folder = createChildItem ( item ) ; folder -> setIcon ( folderIcon ) ; folder -> setData ( QLatin1String ( " Folder " ) , Qt :: UserRole + 10 ) ; bool expanded = ( attributes ( ) . value ( QLatin1String ( " folded " ) ) != QLatin1String ( " no " ) ) ; folder -> setData ( expanded , Qt :: UserRole + 11 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) folder -> setText ( readElementText ( ) ) ; else if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( folder ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( folder ) ; else readUnknownElement ( ) ; } } }
void XbelReader :: readBookmark ( QStandardItem * item ) { QStandardItem * bookmark = createChildItem ( item ) ; bookmark -> setIcon ( bookmarkIcon ) ; bookmark -> setText ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " Unknown ▁ title " ) ) ; bookmark -> setData ( attributes ( ) . value ( QLatin1String ( " href " ) ) . toString ( ) , Qt :: UserRole + 10 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) bookmark -> setText ( readElementText ( ) ) ; else readUnknownElement ( ) ; } } listModel -> appendRow ( bookmark -> clone ( ) ) ; }
QStandardItem * XbelReader :: createChildItem ( QStandardItem * item ) { QStandardItem * childItem = new QStandardItem ( ) ; childItem -> setEditable ( false ) ; if ( item ) item -> appendRow ( childItem ) ; else treeModel -> appendRow ( childItem ) ; return childItem ; }
IcoSphere :: IcoSphere ( unsigned int levels ) { for ( int i = 0 ; i < 12 ; i ++ ) mVertices . push_back ( Map < Vector3f > ( vdata [ i ] ) ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & indices = * mIndices . back ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) indices . push_back ( tindices [ i ] [ k ] ) ; } mListIds . push_back ( 0 ) ; while ( mIndices . size ( ) < levels ) _subdivide ( ) ; }
void IcoSphere :: _subdivide ( void ) { typedef unsigned long long Key ; std :: map < Key , int > edgeMap ; const std :: vector < int > & indices = * mIndices . back ( ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & refinedIndices = * mIndices . back ( ) ; int end = indices . size ( ) ; for ( int i = 0 ; i < end ; i += 3 ) { int ids0 [ 3 ] , ids1 [ 3 ] ; for ( int k = 0 ; k < 3 ; ++ k ) { int k1 = ( k + 1 ) % 3 ; int e0 = indices [ i + k ] ; int e1 = indices [ i + k1 ] ; ids0 [ k ] = e0 ; if ( e1 > e0 ) std :: swap ( e0 , e1 ) ; Key edgeKey = Key ( e0 ) | ( Key ( e1 ) << 32 ) ; std :: map < Key , int > :: iterator it = edgeMap . find ( edgeKey ) ; if ( it == edgeMap . end ( ) ) { ids1 [ k ] = mVertices . size ( ) ; edgeMap [ edgeKey ] = ids1 [ k ] ; mVertices . push_back ( ( mVertices [ e0 ] + mVertices [ e1 ] ) . normalized ( ) ) ; } else ids1 [ k ] = it -> second ; } refinedIndices . push_back ( ids0 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids0 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids0 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; } mListIds . push_back ( 0 ) ; }
void IcoSphere :: draw ( int level ) { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; if ( mListIds [ level ] == 0 ) { mListIds [ level ] = glGen@@ Lists ( 1 ) ; glNew@@ List ( mListIds [ level ] , GL_COMPIL@@ E ) ; glVertexPointer ( 3 , GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glNormal@@ Pointer ( GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glEnableClientState ( GL_VERTEX_ARRAY ) ; glEnableClientState ( GL_NORMAL_ARRAY ) ; glDrawElements ( GL_TRI@@ ANGLES , mIndices [ level ] -> size ( ) , GL_UNSIG@@ NED_INT , & ( mIndices [ level ] -> at ( 0 ) ) ) ; glDisableClientState ( GL_VERTEX_ARRAY ) ; glDisableClientState ( GL_NORMAL_ARRAY ) ; glEnd@@ List ( ) ; } glCall@@ List ( mListIds [ level ] ) ; }
CApplicationPlayer :: CApplicationPlayer ( ) { m_iPlayerOPSeq = 0 ; m_eCurrentPlayer = EPC_@@ NONE ; }
void CApplicationPlayer :: ClosePlayer ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { CloseFile ( ) ; CSingleLock lock ( m_player_lock ) ; m_pPlayer . reset ( ) ; } }
void CApplicationPlayer :: CloseFile ( bool reopen ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { ++ m_iPlayerOPSeq ; player -> CloseFile ( reopen ) ; } }
void CApplicationPlayer :: ClosePlayerGap@@ less ( PLAYERCOREID newCore ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; bool gaplessSupported = ( m_eCurrentPlayer == EPC_@@ DVD@@ PLAYER || m_eCurrentPlayer == EPC_@@ PAP@@ LAYER ) ; gaplessSupported = gaplessSupported && ( m_eCurrentPlayer == newCore ) ; if ( ! gaplessSupported ) { ClosePlayer ( ) ; } else { CloseFile ( true ) ; } }
void CApplicationPlayer :: CreatePlayer ( PLAYERCOREID newCore , IPlayer@@ Callback & callback ) { CSingleLock lock ( m_player_lock ) ; if ( ! m_pPlayer ) { m_eCurrentPlayer = newCore ; m_pPlayer . reset ( CPlayer@@ CoreFactory :: Get ( ) . CreatePlayer ( newCore , callback ) ) ; } }
PlayBackRet CApplicationPlayer :: OpenFile ( const CFileItem & item , const CPlayer@@ Options & options ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; PlayBackRet iResult = PLAYBACK_FAIL ; if ( player ) { unsigned int startingSeq = ++ m_iPlayerOPSeq ; iResult = player -> OpenFile ( item , options ) ? PLAYBACK_@@ OK : PLAYBACK_FAIL ; if ( m_iPlayerOPSeq != startingSeq ) iResult = PLAYBACK_@@ CANC@@ ELED ; } return iResult ; }
int CApplicationPlayer :: GetChapter ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapter ( ) ; else return - 1 ; }
int CApplicationPlayer :: GetChapterCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterCount ( ) ; else return 0 ; }
void CApplicationPlayer :: GetChapterName ( std :: string & strChapterName , int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetChapterName ( strChapterName , chapterIdx ) ; }
int64_t CApplicationPlayer :: GetChapterPos ( int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterPos ( chapterIdx ) ; return - 1 ; }
void CApplicationPlayer :: Pause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Pause ( ) ; }
void CApplicationPlayer :: SetMute ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetMute ( bOnOff ) ; }
void CApplicationPlayer :: SetVolume ( float volume ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetVolume ( volume ) ; }
void CApplicationPlayer :: Seek ( bool bPlus , bool bLargeStep , bool bChapterOverride ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Seek ( bPlus , bLargeStep , bChapterOverride ) ; }
void CApplicationPlayer :: SeekPercentage ( float fPercent ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekPercentage ( fPercent ) ; }
bool CApplicationPlayer :: CanSeek ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanSeek ( ) ) ; }
bool CApplicationPlayer :: SeekScene ( bool bPlus ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SeekScene ( bPlus ) ) ; }
void CApplicationPlayer :: SeekTime ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekTime ( iTime ) ; }
void CApplicationPlayer :: SeekTimeRelative ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { if ( ! player -> SeekTimeRelative ( iTime ) ) { int64_t abstime = player -> GetTime ( ) + iTime ; player -> SeekTime ( abstime ) ; } } }
std :: string CApplicationPlayer :: GetPlayingTitle ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayingTitle ( ) ; else return " " ; }
int CApplicationPlayer :: GetSubtitleCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetSubtitleCount ( ) ; else return 0 ; }
int CApplicationPlayer :: GetAudioStream ( ) { if ( ! m_audioStreamUpdate . IsTimePast ( ) ) return m_iAudioStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iAudioStream = player -> GetAudioStream ( ) ; m_audioStreamUpdate . Set ( 1000 ) ; return m_iAudioStream ; } else return 0 ; }
int CApplicationPlayer :: GetSubtitle ( ) { if ( ! m_subtitleStreamUpdate . IsTimePast ( ) ) return m_iSubtitleStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iSubtitleStream = player -> GetSubtitle ( ) ; m_subtitleStreamUpdate . Set ( 1000 ) ; return m_iSubtitleStream ; } else return 0 ; }
bool CApplicationPlayer :: GetSubtitleVisible ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetSubtitleVisible ( ) ) ; }
bool CApplicationPlayer :: CanRecord ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanRecord ( ) ) ; }
bool CApplicationPlayer :: CanPause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanPause ( ) ) ; }
TextCache@@ Struct_t * CApplicationPlayer :: GetTeletextCache ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTeletextCache ( ) ; else return NULL ; }
void CApplicationPlayer :: ToFFRW ( int iSpeed ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> ToFFRW ( iSpeed ) ; }
void CApplicationPlayer :: DoAudioWork ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> DoAudioWork ( ) ; }
std :: string CApplicationPlayer :: GetPlayerState ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayerState ( ) ; else return " " ; }
bool CApplicationPlayer :: QueueNextFile ( const CFileItem & file ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> QueueNextFile ( file ) ) ; }
bool CApplicationPlayer :: GetStreamDetails ( CStreamDetails & details ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetStreamDetails ( details ) ) ; }
bool CApplicationPlayer :: SetPlayerState ( const std :: string & state ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SetPlayerState ( state ) ) ; }
void CApplicationPlayer :: OnNothingToQueueNotify ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OnNothingToQueueNotify ( ) ; }
void CApplicationPlayer :: GetVideoStreamInfo ( SPlayer@@ VideoStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoStreamInfo ( info ) ; }
void CApplicationPlayer :: GetAudioStreamInfo ( int index , SPlayer@@ AudioStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioStreamInfo ( index , info ) ; }
bool CApplicationPlayer :: OnAction ( const CAction & action ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> OnAction ( action ) ) ; }
bool CApplicationPlayer :: Record ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> Record ( bOnOff ) ) ; }
int CApplicationPlayer :: GetAudioStreamCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetAudioStreamCount ( ) ; else return 0 ; }
void CApplicationPlayer :: SetAudioStream ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetAudioStream ( iStream ) ; m_iAudioStream = iStream ; m_audioStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_AudioStream = iStream ; } }
void CApplicationPlayer :: GetSubtitleStreamInfo ( int index , SPlayer@@ SubtitleStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleStreamInfo ( index , info ) ; }
void CApplicationPlayer :: SetSubtitle ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitle ( iStream ) ; m_iSubtitleStream = iStream ; m_subtitleStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = iStream ; } }
void CApplicationPlayer :: SetSubtitleVisible ( bool bVisible ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitleVisible ( bVisible ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_Subtitle@@ On = bVisible ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = player -> GetSubtitle ( ) ; } }
void CApplicationPlayer :: AddSubtitle ( const std :: string & strSubPath ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> AddSubtitle ( strSubPath ) ; }
void CApplicationPlayer :: SetSubTitleDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetSubTitleDelay ( fValue ) ; }
void CApplicationPlayer :: SetAVDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetAVDelay ( fValue ) ; }
void CApplicationPlayer :: SetDynamicRangeCompression ( long drc ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetDynamicRangeCompression ( drc ) ; }
bool CApplicationPlayer :: SwitchChannel ( const PVR :: CPVR@@ ChannelPtr & channel ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SwitchChannel ( channel ) ) ; }
void CApplicationPlayer :: LoadPage ( int p , int sp , unsigned char * buffer ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> LoadPage ( p , sp , buffer ) ; }
void CApplicationPlayer :: GetAudioCapabilities ( std :: vector < int > & audioCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioCapabilities ( audioCaps ) ; }
void CApplicationPlayer :: GetSubtitleCapabilities ( std :: vector < int > & subCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleCapabilities ( subCaps ) ; }
void CApplicationPlayer :: GetAudioInfo ( std :: string & strAudioInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioInfo ( strAudioInfo ) ; }
void CApplicationPlayer :: GetVideoInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoInfo ( strVideoInfo ) ; }
void CApplicationPlayer :: GetGeneralInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetGeneralInfo ( strVideoInfo ) ; }
int CApplicationPlayer :: SeekChapter ( int iChapter ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> SeekChapter ( iChapter ) ; else return 0 ; }
void CApplicationPlayer :: GetRenderFeatures ( std :: vector < int > & renderFeatures ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OM@@ XGetRenderFeatures ( renderFeatures ) ; }
void CApplicationPlayer :: GetDeinterlace@@ Methods ( std :: vector < int > & deinterlaceMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlace@@ Methods ( deinterlaceMethods ) ; }
void CApplicationPlayer :: GetDeinterlace@@ Modes ( std :: vector < int > & deinterlaceModes ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlace@@ Modes ( deinterlaceModes ) ; }
void CApplicationPlayer :: GetScalingMethods ( std :: vector < int > & scalingMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGet@@ ScalingMethods ( scalingMethods ) ; }
void CApplicationPlayer :: SetPlaySpeed ( int iSpeed , bool bApplicationMuted ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; if ( ! IsPlayingAudio ( ) && ! IsPlayingVideo ( ) ) return ; if ( m_iPlaySpeed == iSpeed ) return ; if ( ! CanSeek ( ) ) return ; if ( IsPaused ( ) ) { if ( ( ( m_iPlaySpeed > 1 ) && ( iSpeed > m_iPlaySpeed ) ) || ( ( m_iPlaySpeed < - 1 ) && ( iSpeed < m_iPlaySpeed ) ) ) { iSpeed = m_iPlaySpeed ; } Pause ( ) ; } m_iPlaySpeed = iSpeed ; ToFFRW ( m_iPlaySpeed ) ; if ( ControlsVolume ( ) ) { if ( m_iPlaySpeed == 1 ) { player -> SetVolume ( g_application . GetVolume ( false ) ) ; } else { player -> SetVolume ( VOLUME_MIN@@ IMU@@ M ) ; } player -> SetMute ( bApplicationMuted ) ; } }
HrPwPlot :: HrPwPlot ( MainWindow * mainWindow , HrPwWindow * hrPwWindow ) : QwtPlot ( hrPwWindow ) , hrPwWindow ( hrPwWindow ) , mainWindow ( mainWindow ) , bg ( NULL ) , delay ( - 1 ) , minHr ( 50 ) , minWatt ( 50 ) , maxWatt ( 500 ) , settings ( GC_SETTINGS_@@ CO , GC_SETTINGS_@@ APP ) , unit ( settings . value ( GC_UNIT ) ) { setCanvas@@ Background ( Qt :: white ) ; canvas ( ) -> setFrame@@ Style ( QFrame :: NoFrame ) ; setXTitle ( ) ; regCurve = new QwtPlotCurve ( " reg " ) ; regCurve -> setPen ( QPen ( GColor ( CPLOT@@ MARKER ) ) ) ; regCurve -> attach ( this ) ; wattsStepCurve = new QwtPlotCurve ( " Power " ) ; wattsStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; wattsStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor wattsColor = QColor ( 200 , 200 , 255 ) ; QColor wattsColor2 = QColor ( 100 , 100 , 255 ) ; wattsStepCurve -> setPen ( QPen ( wattsColor2 ) ) ; wattsStepCurve -> setBrush ( QBrush ( wattsColor ) ) ; wattsStepCurve -> attach ( this ) ; hrStepCurve = new QwtPlotCurve ( " Hr " ) ; hrStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; hrStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor hrColor = QColor ( 255 , 200 , 200 ) ; QColor hrColor2 = QColor ( 255 , 100 , 100 ) ; hrStepCurve -> setPen ( QPen ( hrColor2 ) ) ; hrStepCurve -> setBrush ( QBrush ( hrColor ) ) ; hrStepCurve -> attach ( this ) ; hrCurves . resize ( 36 ) ; for ( int i = 0 ; i < 36 ; ++ i ) { hrCurves [ i ] = new QwtPlotCurve ; hrCurves [ i ] -> attach ( this ) ; } grid = new QwtPlotGrid ( ) ; grid -> enableX ( false ) ; QPen gridPen ; gridPen . setStyle ( Qt :: DotLine ) ; gridPen . setColor ( GColor ( CPLOT@@ GRID ) ) ; grid -> setPen ( gridPen ) ; grid -> attach ( this ) ; r_mrk1 = new QwtPlotMarker ; r_mrk2 = new QwtPlotMarker ; r_mrk1 -> attach ( this ) ; r_mrk2 -> attach ( this ) ; shade@@ _zones = true ; }
void HrPwPlot :: setAxisTitle ( int axis , QString label ) { QFont stGiles ; stGiles . fromString ( appsettings -> value ( this , GC_FONT_CHARTLAB@@ ELS , QFont ( ) . toString ( ) ) . toString ( ) ) ; stGiles . setPointSize ( appsettings -> value ( NULL , GC_FONT_CHARTLAB@@ ELS_SIZE , 8 ) . toInt ( ) ) ; QwtText title ( label ) ; title . setFont ( stGiles ) ; QwtPlot :: setAxisFont ( axis , stGiles ) ; QwtPlot :: setAxisTitle ( axis , title ) ; }
void HrPwPlot :: recalc ( ) { if ( timeArray . count ( ) == 0 ) return ; int rideTimeSecs = ( int ) ceil ( timeArray [ arrayLength - 1 ] ) ; if ( rideTimeSecs > 7 * 24 * 60 * 60 ) { return ; } double totalWatts = 0.0 ; double totalHr = 0.0 ; QList < DataPoint * > list ; int i = 0 ; QVector < double > smoothWatts ( rideTimeSecs + 1 ) ; QVector < double > smoothHr ( rideTimeSecs + 1 ) ; QVector < double > smoothTime ( rideTimeSecs + 1 ) ; int decal = 0 ; int smooth = hrPwWindow -> smooth ; for ( int secs = smooth ; secs <= rideTimeSecs ; ++ secs ) { while ( ( i < arrayLength ) && ( timeArray [ i ] <= secs ) ) { DataPoint * dp = new DataPoint ( timeArray [ i ] , hrArray [ i ] , wattsArray [ i ] , interArray [ i ] ) ; totalWatts += wattsArray [ i ] ; totalHr += hrArray [ i ] ; list . append ( dp ) ; ++ i ; } while ( ! list . empty ( ) && ( list . front ( ) -> time < secs - smooth ) ) { DataPoint * dp = list . front ( ) ; list . removeFirst ( ) ; totalWatts -= dp -> watts ; totalHr -= dp -> hr ; delete dp ; } if ( list . empty ( ) ) { ++ decal ; } else { smoothWatts [ secs - decal ] = totalWatts / list . size ( ) ; smoothHr [ secs - decal ] = totalHr / list . size ( ) ; } smoothTime [ secs ] = secs / 60.0 ; } rideTimeSecs = rideTimeSecs - decal ; smoothWatts . resize ( rideTimeSecs ) ; smoothHr . resize ( rideTimeSecs ) ; QVector < double > clipWatts ( rideTimeSecs ) ; QVector < double > clipHr ( rideTimeSecs ) ; decal = 0 ; for ( int secs = 0 ; secs < rideTimeSecs ; ++ secs ) { if ( smoothHr [ secs ] >= minHr && smoothWatts [ secs ] >= minWatt && smoothWatts [ secs ] < maxWatt ) { clipWatts [ secs - decal ] = smoothWatts [ secs ] ; clipHr [ secs - decal ] = smoothHr [ secs ] ; } else decal ++ ; } rideTimeSecs = rideTimeSecs - decal ; clipWatts . resize ( rideTimeSecs ) ; clipHr . resize ( rideTimeSecs ) ; if ( delay == - 1 ) delay = hrPwWindow -> findDelay ( clipWatts , clipHr , clipWatts . size ( ) ) ; QVector < double > delayWatts ( rideTimeSecs - delay ) ; QVector < double > delayHr ( rideTimeSecs - delay ) ; for ( int secs = 0 ; secs < rideTimeSecs - delay ; ++ secs ) { delayWatts [ secs ] = clipWatts [ secs ] ; delayHr [ secs ] = clipHr [ secs + delay ] ; } rideTimeSecs = rideTimeSecs - delay ; double rpente = hrPwWindow -> pente ( delayWatts , delayHr , delayWatts . size ( ) ) ; double rordonnee = hrPwWindow -> ordonnee ( delayWatts , delayHr , delayWatts . size ( ) ) ; double maxr = hrPwWindow -> corr ( delayWatts , delayHr , delayWatts . size ( ) ) ; int intpoints = 10 ; int nbpoints = ( int ) floor ( rideTimeSecs / intpoints ) ; QVector < double > plotedWatts ( nbpoints ) ; QVector < double > plotedHr ( nbpoints ) ; for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { plotedWatts [ secs ] = clipWatts [ secs * intpoints ] ; plotedHr [ secs ] = clipHr [ secs * intpoints ] ; } int nbpoints2 = ( int ) floor ( nbpoints / 36 ) + 2 ; double * plotedWattsArray [ 36 ] ; double * plotedHrArray [ 36 ] ; for ( int i = 0 ; i < 36 ; ++ i ) { plotedWattsArray [ i ] = new double [ nbpoints2 ] ; plotedHrArray [ i ] = new double [ nbpoints2 ] ; } for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { for ( int i = 0 ; i < 36 ; ++ i ) { if ( secs >= i * nbpoints2 && secs < ( i + 1 ) * nbpoints2 ) { plotedWattsArray [ i ] [ secs - i * nbpoints2 ] = plotedWatts [ secs - i ] ; plotedHrArray [ i ] [ secs - i * nbpoints2 ] = plotedHr [ secs - i ] ; } } } for ( int i = 0 ; i < 36 ; ++ i ) { if ( nbpoints - i * nbpoints2 > 0 ) { hrCurves [ i ] -> setData ( plotedWattsArray [ i ] , plotedHrArray [ i ] , ( nbpoints - i * nbpoints2 < nbpoints2 ? nbpoints - i * nbpoints2 : nbpoints2 ) ) ; hrCurves [ i ] -> setVisible ( true ) ; } else hrCurves [ i ] -> setVisible ( false ) ; } setAxisScale ( xBottom , 0.0 , maxWatt ) ; setYMax ( ) ; refreshZoneLabels ( ) ; QString labelp ; labelp . setNum ( rpente , ' f ' , 3 ) ; QString labelo ; labelo . setNum ( rordonnee , ' f ' , 1 ) ; QString labelr ; labelr . setNum ( maxr , ' f ' , 3 ) ; QString labeldelay ; labeldelay . setNum ( delay ) ; int power150 = ( int ) floor ( ( 150 - rordonnee ) / rpente ) ; QString labelpower150 ; labelpower150 . setNum ( power150 ) ; QwtText textr = QwtText ( labelp + " * x + " + labelo + " ▁ : ▁ R ▁ " + labelr + " ▁ ( " + labeldelay + " ) ▁ \n ▁ Power @ 150 : " + labelpower150 + " W " ) ; textr . setFont ( QFont ( " Helvetica " , 10 , QFont :: Bold ) ) ; textr . setColor ( Qt :: black ) ; r_mrk1 -> setValue ( 0 , 0 ) ; r_mrk1 -> setLineStyle ( QwtPlotMarker :: VLine ) ; r_mrk1 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk1 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennewatt = hrPwWindow -> moyenne ( clipWatts , clipWatts . size ( ) ) ; r_mrk1 -> setValue ( moyennewatt , 0.0 ) ; r_mrk1 -> setLabel ( textr ) ; r_mrk2 -> setValue ( 0 , 0 ) ; r_mrk2 -> setLineStyle ( QwtPlotMarker :: HLine ) ; r_mrk2 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk2 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennehr = hrPwWindow -> moyenne ( clipHr , clipHr . size ( ) ) ; r_mrk2 -> setValue ( 0.0 , moyennehr ) ; addWattStepCurve ( clipWatts , clipWatts . size ( ) ) ; addHrStepCurve ( clipHr , clipHr . size ( ) ) ; addRegLinCurve ( rpente , rordonnee ) ; setJoinLine ( joinLine ) ; rep@@ lot ( ) ; }
void HrPwPlot :: setYMax ( ) { double ymax = 0 ; QString ylabel = " " ; for ( int i = 0 ; i < 36 ; ++ i ) { if ( hrCurves [ i ] -> isVisible ( ) ) { ymax = max ( ymax , hrCurves [ i ] -> maxYValue ( ) ) ; } } setAxisScale ( yLeft , minHr , ymax * 1.2 ) ; setAxisTitle ( yLeft , tr ( " Heart ▁ Rate ( BP@@ M ) " ) ) ; }
void HrPwPlot :: addWattStepCurve ( QVector < double > & finalWatts , int nbpoints ) { QMap < double , double > powerHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( powerHist . contains ( finalWatts [ h ] ) ) powerHist [ finalWatts [ h ] ] += 1 ; else powerHist [ finalWatts [ h ] ] = 1 ; } int maxPower = 500 ; double * array = new double [ maxPower ] ; for ( int i = 0 ; i < maxPower ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > k ( powerHist ) ; while ( k . hasNext ( ) ) { k . next ( ) ; array [ ( int ) round ( k . key ( ) ) ] += k . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxPower - 1 ) / 10 ) ; QVector < double > smoothWattsStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 10 ; int high = low + 10 ; smoothWattsStep [ t ] = low ; smoothTimeStep [ t ] = minHr ; while ( low < high ) { smoothTimeStep [ t ] += array [ low ++ ] / nbpoints * 300 ; } } smoothTimeStep [ t ] = 0.0 ; smoothWattsStep [ t ] = t * 10 ; wattsStepCurve -> setData ( smoothWattsStep . data ( ) , smoothTimeStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addHrStepCurve ( QVector < double > & finalHr , int nbpoints ) { QMap < double , double > hrHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( hrHist . contains ( finalHr [ h ] ) ) hrHist [ finalHr [ h ] ] += 1 ; else hrHist [ finalHr [ h ] ] = 1 ; } int maxHr = 220 ; double * array = new double [ maxHr ] ; for ( int i = 0 ; i < maxHr ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > l ( hrHist ) ; while ( l . hasNext ( ) ) { l . next ( ) ; array [ ( int ) round ( l . key ( ) ) ] += l . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxHr - 1 ) / 2 ) ; QVector < double > smoothHrStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep2 ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 2 ; int high = low + 2 ; smoothHrStep [ t ] = low ; smoothTimeStep2 [ t ] = 0.0 ; while ( low < high ) { smoothTimeStep2 [ t ] += array [ low ++ ] / nbpoints * 500 ; } } smoothTimeStep2 [ t ] = 0.0 ; smoothHrStep [ t ] = t * 2 ; hrStepCurve -> setData ( smoothTimeStep2 . data ( ) , smoothHrStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addRegLinCurve ( double rpente , double rordonnee ) { double regWatts [ ] = { 0 , 0 } ; double regHr [ ] = { 0 , 500 } ; regWatts [ 0 ] = regHr [ 0 ] * rpente + rordonnee ; regWatts [ 1 ] = regHr [ 1 ] * rpente + rordonnee ; regCurve -> setData ( regHr , regWatts , 2 ) ; }
void HrPwPlot :: setXTitle ( ) { setAxisTitle ( xBottom , tr ( " Power ▁ ( Watts ) " ) ) ; }
void HrPwPlot :: setData@@ FromRide ( RideItem * _rideItem ) { rideItem = _rideItem ; if ( ! _rideItem || ! _rideItem -> ride ( ) ) return ; RideFile * ride = rideItem -> ride ( ) ; const RideFile@@ DataPresent * dataPresent = ride -> areDataPresent ( ) ; int npoints = ride -> dataPoints ( ) . size ( ) ; if ( dataPresent -> watts && dataPresent -> hr ) { wattsArray . resize ( npoints ) ; hrArray . resize ( npoints ) ; timeArray . resize ( npoints ) ; interArray . resize ( npoints ) ; arrayLength = 0 ; foreach ( const RideFile@@ Point * point , ride -> dataPoints ( ) ) { if ( ! timeArray . empty ( ) ) timeArray [ arrayLength ] = point -> secs ; if ( ! wattsArray . empty ( ) ) wattsArray [ arrayLength ] = max ( 0 , point -> watts ) ; if ( ! hrArray . empty ( ) ) hrArray [ arrayLength ] = max ( 0 , point -> hr ) ; if ( ! interArray . empty ( ) ) interArray [ arrayLength ] = point -> interval ; ++ arrayLength ; } delay = - 1 ; recalc ( ) ; } }
void HrPwPlot :: setJoinLine ( bool value ) { joinLine = value ; for ( int i = 0 ; i < 36 ; ++ i ) { QColor color = QColor ( 255 , 255 , 255 ) ; color . setHsv ( 60 + i * ( 360 / 36 ) , 255 , 255 , 255 ) ; if ( value ) { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: NoSymbol ) ; QPen pen = QPen ( color ) ; pen . setWidth ( 1 ) ; hrCurves [ i ] -> setPen ( pen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Lines ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } else { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: Ellipse ) ; sym . setSize ( 5 ) ; sym . setPen ( QPen ( color ) ) ; sym . setBrush ( QBrush ( color ) ) ; hrCurves [ i ] -> setPen ( Qt :: NoPen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Dots ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } } }
void HrPwPlot :: pointHover ( QwtPlotCurve * curve , int index ) { if ( index >= 0 ) { double yvalue = curve -> sample ( index ) . y ( ) ; double xvalue = curve -> sample ( index ) . x ( ) ; QString text = QString ( " % 1 ▁ % 2 \n % 3 ▁ % 4" ) . arg ( yvalue , 0 , ' f ' , 0 ) . arg ( this -> axisTitle ( curve -> yAxis ( ) ) . text ( ) ) . arg ( xvalue , 0 , ' f ' , 2 ) . arg ( this -> axisTitle ( curve -> xAxis ( ) ) . text ( ) ) ; tooltip -> setText ( text ) ; } else { tooltip -> setText ( " " ) ; } }
