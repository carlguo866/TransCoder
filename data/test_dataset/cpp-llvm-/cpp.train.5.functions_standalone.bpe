void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; file . close ( ) ; }
void _sendResizeEvents ( QWidget * target ) { QResizeEvent e ( target -> size ( ) , QSize ( ) ) ; QApplication :: sendEvent ( target , & e ) ; const QObject@@ List children = target -> children ( ) ; for ( int i = 0 ; i < children . size ( ) ; ++ i ) { QWidget * child = static_cast < QWidget * > ( children . at ( i ) ) ; if ( child -> isWidgetType ( ) && ! child -> isWindow ( ) && child -> testAttribute ( Qt :: WA_PendingResizeEvent ) ) { _sendResizeEvents ( child ) ; } } }
void myEnsureResized ( QWidget * target ) { if ( target && ( target -> testAttribute ( Qt :: WA_PendingResizeEvent ) || ! target -> testAttribute ( Qt :: WA_@@ WStat@@ e_Created ) ) ) { _sendResizeEvents ( target ) ; } }
QPixmap myGra@@ b ( QWidget * target , const QRect & rect ) { if ( ! cRet@@ ina ( ) ) return target -> grab ( rect ) ; myEnsureResized ( target ) ; qreal dpr = App :: app ( ) -> devic@@ ePixelRatio ( ) ; QPixmap result ( rect . size ( ) * dpr ) ; result . setDevice@@ PixelRatio ( dpr ) ; result . fill ( Qt :: transparent ) ; target -> render ( & result , QPoint ( ) , QRegion ( rect ) , QWidget :: DrawWindowBackground | QWidget :: DrawChildren | QWidget :: IgnoreMask ) ; return result ; }
template < class List > void BM_ListPushBack ( bm :: State & st ) { List li ; using T = typename List :: value_type ; T v { } ; size_t count = 0 ; while ( st . Keep@@ Running ( ) ) { for ( int i = 0 , e = st . range ( 0 ) ; i < e ; ++ i ) { if ( li . size ( ) == li . max_size ( ) ) li . clear ( ) ; li . push_back ( v ) ; ++ count ; } li . clear ( ) ; } st . SetComplex@@ ityN ( st . range ( 0 ) ) ; st . SetItems@@ Processed ( count ) ; st . SetBytes@@ Processed ( count * sizeof ( T ) ) ; }
int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; }
void worker_thread ( ) { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; lk . unlock ( ) ; cv . notify_one ( ) ; }
int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; }
public : bool exist ( vector < vector < char >> & board , string word ) { if ( board . size ( ) == 0 ) return word == " " ; m = board . size ( ) , n = board [ 0 ] . size ( ) ; this -> word = word ; this -> board = board ; visit . resize ( m , vector < bool > ( n ) ) ; for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( board [ j ] [ k ] == word [ 0 ] ) { visit [ j ] [ k ] = true ; dfs ( j , k , 0 ) ; visit [ j ] [ k ] = false ; } } } return flag ; }
void dfs ( int x , int y , int index ) { if ( flag == true ) return ; if ( index == word . length ( ) - 1 ) { flag = true ; return ; } for ( int i = 0 ; i < 4 ; i ++ ) { int tx = x + dir [ i ] [ 0 ] , ty = y + dir [ i ] [ 1 ] ; if ( tx >= 0 && tx < m && ty >= 0 && ty < n && board [ tx ] [ ty ] == word [ index + 1 ] && visit [ tx ] [ ty ] == false ) { visit [ tx ] [ ty ] = true ; dfs ( tx , ty , index + 1 ) ; visit [ tx ] [ ty ] = false ; } } }
template < class Iter , class Sent = Iter > void test_iter ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! ( * i < res . first ) ) ; CHECK ( ! ( res . second < * i ) ) ; } }
template < class Iter , class Sent = Iter > void test_iter ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; }
template < class Iter , class Sent = Iter > void test_iter ( ) { test_iter < Iter , Sent > ( 1 ) ; test_iter < Iter , Sent > ( 2 ) ; test_iter < Iter , Sent > ( 3 ) ; test_iter < Iter , Sent > ( 10 ) ; test_iter < Iter , Sent > ( 1000 ) ; }
template < class Iter , class Sent = Iter > void test_iter_comp ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; typedef std :: greater < int > Compare ; Compare comp ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng , comp ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! comp ( * i , res . first ) ) ; CHECK ( ! comp ( res . second , * i ) ) ; } }
template < class Iter , class Sent = Iter > void test_iter_comp ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter_comp ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; }
template < class Iter , class Sent = Iter > void test_iter_comp ( ) { test_iter_comp < Iter , Sent > ( 1 ) ; test_iter_comp < Iter , Sent > ( 2 ) ; test_iter_comp < Iter , Sent > ( 3 ) ; test_iter_comp < Iter , Sent > ( 10 ) ; test_iter_comp < Iter , Sent > ( 1000 ) ; }
int main ( ) { test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; S s [ ] = { S { 1 , 0 } , S { 2 , 1 } , S { 3 , 2 } , S { 4 , 3 } , S { - 4 , 4 } , S { 40 , 5 } , S { - 4 , 6 } , S { 40 , 7 } , S { 7 , 8 } , S { 8 , 9 } , S { 9 , 10 } } ; auto res = ranges :: minmax ( s , std :: less < int > { } , & S :: value ) ; CHECK ( res . first . value == - 4 ) ; CHECK ( res . first . index == 4 ) ; CHECK ( res . second . value == 40 ) ; CHECK ( res . second . index == 7 ) ; return test_result ( ) ; }
extern " C " __decl@@ spec ( dllexport ) IStdClassFactory * __cdecl GetStdClassFactory ( ) extern " C " IStdClassFactory * GetStdClassFactory ( ) { IStdClassFactory * lpFactory = new CsClassFactory ; return lpFactory ; }
int main ( ) { int n = 648 ; int k = 432 ; int p = n - k ; std :: string file = " n648@@ r23" ; int passes = 50 ; bool qam = true ; int symbols = 4 ; double step = 0.25 ; int minsnr = 0 ; double maxsnr = 4.1 ; int maxPackets = 1E@@ 6 ; int minErrors = 100 ; int printInterval = maxPackets / 1000 ; std :: string matrixFolder = " . / matrices / " ; std :: string extIn = " . csv " ; std :: string resultsFolder = " . / results / " ; std :: string extOut = " . dat " ; std :: string encoding = matrixFolder + " enc " + file + extIn ; std :: string decoding = matrixFolder + " dec " + file + extIn ; std :: stringstream ss ; if ( qam ) { ss << " qam " << symbols ; } ss << " _ " << passes ; std :: string output = resultsFolder + file + ss . str ( ) + extOut ; std :: ifstream enc ; enc . open ( encoding . c_str ( ) ) ; std :: ifstream dec ; dec . open ( decoding . c_str ( ) ) ; std :: ofstream out ; out . open ( output . c_str ( ) ) ; out << " # LDPC , ▁ n ▁ = ▁ " << n << " , ▁ k ▁ = ▁ " << k << " \n " ; out << " # SN@@ R ▁ ( dB ) ▁ - ▁ BER ▁ - ▁ PER \n " ; std :: vector < double > snrdb ; std :: vector < int > errors ; std :: vector < int > pktErrors ; std :: vector < int > packets ; boost :: numeric :: ublas :: matrix < int > parityMatrix ( p , n ) ; boost :: numeric :: ublas :: matrix < int > encodingMatrix ( n , k ) ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dec >> parityMatrix ( i , j ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { enc >> encodingMatrix ( i , j ) ; } } for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { snrdb . push_back ( snr ) ; errors . push_back ( 0 ) ; pktErrors . push_back ( 0 ) ; packets . push_back ( 0 ) ; } boost :: mt19937 rng = boost :: mt19937 ( time ( 0 ) ) ; boost :: variate_generator < boost :: mt19937 & , boost :: normal_distribution < > > generator ( rng , boost :: normal_distribution < > ( ) ) ; LDPCEncoder * encoder = new LDPCEncoder ( k , n , encodingMatrix , symbols ) ; LDPCDecoder * decoder = new LDPCDecoder ( k , n , parityMatrix , passes , symbols ) ; std :: cout << std :: time ( NULL ) << " Created ! \n " ; boost :: numeric :: ublas :: matrix < double > results ( snrdb . size ( ) , 26 ) ; for ( int i = 0 ; i < snrdb . size ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { results ( i , j ) = 0 ; } } for ( int packet = 0 ; packet < maxPackets ; packet ++ ) { if ( packet % printInterval == 0 ) { std :: cout << packet << " ▁ " << std :: time ( NULL ) << " \n " ; } std :: vector < int > uncoded ; std :: vector < double > w ; std :: vector < double > w_q ; for ( int i = 0 ; i < n ; i ++ ) { w . push_back ( generator ( ) ) ; if ( qam ) { w_q . push_back ( generator ( ) ) ; } } for ( int i = 0 ; i < k ; i ++ ) { uncoded . push_back ( rand ( ) % 2 ) ; } std :: vector < int > coded = encoder -> encode ( uncoded ) ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { if ( packets . at ( counter ) == 0 ) { double n0 = 1 / pow ( 10 , snr / 10 ) / log2 ( symbols ) / 2 ; std :: vector < double > received ; std :: vector < LDPCEncoder :: symbol > modulated ; if ( ! qam ) { for ( int i = 0 ; i < n ; i ++ ) { double rec = 2 * coded . at ( i ) - 1 + w . at ( i ) * sqrt ( n0 ) ; received . push_back ( rec ) ; } for ( int i = 0 ; i < n ; i ++ ) { double llr = - 2 * received . at ( i ) / n0 ; received . at ( i ) = llr ; } } else { modulated = encoder -> modulate ( coded ) ; std :: vector < double > phase ; std :: vector < double > quad ; for ( int i = 0 ; i < modulated . size ( ) ; i ++ ) { phase . push_back ( modulated . at ( i ) . phase + w . at ( i ) * sqrt ( n0 ) ) ; quad . push_back ( modulated . at ( i ) . quad + w_q . at ( i ) * sqrt ( n0 ) ) ; } received = decoder -> deMod@@ Llr ( phase , quad , n0 ) ; } while ( received . size ( ) > n ) { received . pop_back ( ) ; } std :: vector < int > decoded = decoder -> decode ( received ) ; int error = 0 ; bool correct = true ; for ( int i = 0 ; i < k ; i ++ ) { if ( decoded . at ( i ) != coded . at ( i ) ) { if ( correct ) { correct = false ; pktErrors . at ( counter ) ++ ; } error ++ ; } } errors . at ( counter ) += error ; if ( pktErrors . at ( counter ) > minErrors ) { packets . at ( counter ) = packet + 1 ; } } counter ++ ; } } std :: cout << std :: time ( NULL ) << " Finished ! \n " ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { double nPackets = maxPackets ; if ( packets . at ( counter ) != 0 ) { nPackets = packets . at ( counter ) ; } double per = pktErrors . at ( counter ) / nPackets ; double ber = errors . at ( counter ) / ( nPackets * k ) ; out << snr << " ▁ " << ber << " ▁ " << per << " \n " ; counter ++ ; } enc . close ( ) ; dec . close ( ) ; out . close ( ) ; delete encoder ; delete decoder ; }
void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfo@@ Req msg ; IM :: Buddy :: IMUsersInfo@@ Rsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id@@ _list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id@@ _list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info@@ _list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_@@ USER_@@ INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } }
void getChanged@@ User ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUser@@ Req msg ; IM :: Buddy :: IMAllUser@@ Rsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLast@@ Update ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChanged@@ Id ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_@@ ALL_USER_@@ RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } }
void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfo@@ Rsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_@@ CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShi@@ eldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_@@ PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShi@@ eldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_@@ QUER@@ Y_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } }
BEGIN_MESSAGE_MAP ( CFormDialog , CDialog ) ON_W@@ M_SIZE ( ) ON_WM_LBUTTONDOWN ( ) ON_W@@ M_SETFOCUS ( ) ON_WM_@@ KIL@@ LFOCUS ( ) END_MESSAGE_MAP ( ) void CFormDialog :: OnSize ( UINT nType , int cx , int cy ) { CBaseDialog :: OnSize ( nType , cx , cy ) ; }
