int main ( int argc , char * argv [ ] ) { QApplication a ( argc , argv ) ; MainWindow w ; w . show ( ) ; return a . exec ( ) ; }
BOOST_AUTO_TEST_CASE ( test_main ) { BOOST_MATH_CONTROL_FP ; error_@@ stream@@ _repla@@ cer rep ; test_beta ( static_cast < TYPE_TO_TEST > ( 0 ) , NAME_OF_TYPE_TO_TEST ) ; bool test_float = false ; bool test_double = false ; bool test_long_double = false ; if ( std :: numeric_limits < long double > :: digits == std :: numeric_limits < double > :: digits ) { if ( BOOST_MATH_PROMOTE_FLOAT_POLICY == false ) test_float = true ; test_double = true ; } else { if ( BOOST_MATH_PROMOTE_FLOAT_POLICY == false ) test_float = true ; if ( BOOST_MATH_PROMOTE_@@ DOUBLE_@@ POLICY == false ) test_double = true ; test_long_double = true ; } test_double = true ; if ( test_float ) test_beta ( 0.0f , " float " ) ; if ( test_double ) test_beta ( 0.0 , " double " ) ; if ( test_long_double ) test_beta ( 0.0L , " long ▁ double " ) ; }
void compile_@@ and_link_@@ test ( ) { check_result < float > ( boost :: math :: hypot < float > ( f , f ) ) ; check_result < double > ( boost :: math :: hypot < double > ( d , d ) ) ; check_result < long double > ( boost :: math :: hypot < long double > ( l , l ) ) ; }
void save@@ File ( std :: string filename , std :: vector < std :: string > lines ) { std :: ofstream save ; save . open ( filename . c_str ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { save << lines [ i ] << std :: endl ; } save . close ( ) ; }
int main ( int argc , char * * argv ) { TBool debug = false ; TStr TagsFnm = " / lfs / madmax4/0 / yonathan / tags " ; if ( debug ) { TagsFnm = " / lfs / madmax4/0 / yonathan / tags _ small " ; } Schema TagS ; TagS . Add ( TPair < TStr , TAttrType > ( " UserId " , atInt ) ) ; TagS . Add ( TPair < TStr , TAttrType > ( " Tag " , atStr ) ) ; float ft_max ; float mu_max ; timeval timer4 ; gettimeofday ( & timer4 , NULL ) ; double t1 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_Tags = ExplicitStringTable :: LoadSS ( TagS , TagsFnm + " . tsv " ) ; gettimeofday ( & timer4 , NULL ) ; double t2 = timer4 . tv_sec + ( timer4 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ load ▁ tags ▁ table : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_Tags -> PrintSize ( ) ; getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer6 ; gettimeofday ( & timer6 , NULL ) ; t1 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_TagsJoinUser = ES_Tags -> Sel@@ fJo@@ in ( " UserId " ) ; gettimeofday ( & timer6 , NULL ) ; t2 = timer6 . tv_sec + ( timer6 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ join ▁ on ▁ user ▁ id ▁ column : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_TagsJoinUser -> PrintSize ( ) ; if ( debug ) { ES_TagsJoinUser -> SaveSS ( TagsFnm + " _ join _ user _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; timeval timer7 ; gettimeofday ( & timer7 , NULL ) ; t1 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; PExplicitStringTable ES_JavaTags = ExplicitStringTable :: New ( TagS ) ; TInt@@ V SelectedRows1 ; if ( debug ) { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " c # " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } else { ES_Tags -> SelectAtomicConst ( TStr ( " Tag " ) , TStr ( " java " ) , EQ , SelectedRows1 , ES_JavaTags , false , true ) ; } gettimeofday ( & timer7 , NULL ) ; t2 = timer7 . tv_sec + ( timer7 . tv_usec / 1000000.0 ) ; printf ( " Time ▁ to ▁ select ▁ java ▁ users : ▁ % f \n " , t2 - t1 ) ; printf ( " Table ▁ Size : \n " ) ; ES_JavaTags -> PrintSize ( ) ; if ( debug ) { ES_JavaTags -> SaveSS ( TagsFnm + " _ select _ es . tsv " ) ; } getmaxcpumem ( & ft_max , & mu_max ) ; printf ( " time : ▁ % 0.3f ▁ seconds , ▁ memory : ▁ % 0.3f ▁ MB \n " , ft_max , mu_max ) ; printf ( " \n " ) ; return 0 ; }
int main ( ) { BOOST_STATIC_ASSERT ( ( ! phx :: stl :: has_@@ mapped_type < std :: multiset < int > > :: value ) ) ; BOOST_STATIC_ASSERT ( ( phx :: stl :: has_@@ key_type < std :: multiset < int > > :: value ) ) ; std :: multiset < int > const data = build_multiset ( ) ; test_begin ( data ) ; test_clear ( data ) ; test_empty ( data ) ; test_end ( data ) ; test_set_@@ erase ( data ) ; test_get_@@ allocator ( data ) ; return boost :: report_@@ errors ( ) ; }
static void qquick_initialize_helper ( QAbstractAnimationJob * job , QQuickAnimatorController * c ) { if ( job -> isRenderThreadJob ( ) ) { QQuickAnimatorJob * j = static_cast < QQuickAnimatorJob * > ( job ) ; if ( ! j -> target ( ) ) { return ; } else if ( c -> m_deletedSinceLastFrame . contains ( j -> target ( ) ) ) { j -> targetWasDeleted ( ) ; } else { j -> addAnimationChangeListener ( c , QAbstractAnimationJob :: StateChange ) ; j -> initialize ( c ) ; } } else if ( job -> isGroup ( ) ) { QAnimationGroupJob * g = static_cast < QAnimationGroupJob * > ( job ) ; for ( QAbstractAnimationJob * a = g -> firstChild ( ) ; a ; a = a -> nextSibling ( ) ) qquick_initialize_helper ( a , c ) ; } }
I8275_@@ DRAW_CHARACTER_@@ MEMBER ( mm1_state :: crtc_display_pixels ) { UINT8 romdata = m_char@@ _rom -> base ( ) [ ( charcode << 4 ) | linecount ] ; int gpa0 = BIT ( gpa , 0 ) ; int llen = m_llen ; int compl_in = rvv ; int hlt_in = hl@@ gt ; int color ; int i , qh , video_in ; int d7 = BIT ( romdata , 7 ) ; int d6 = BIT ( romdata , 6 ) ; int d0 = BIT ( romdata , 0 ) ; UINT8 data = ( romdata << 1 ) | ( d7 & d0 ) ; if ( y < 360 || x >= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0 ) { if ( HORIZONTAL_CHARACTER_PIXELS == 10 ) { qh = d7 & d6 ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + 8 ) = m_palette -> pen ( color ) ; bitmap . pix32 ( y , x + 9 ) = m_palette -> pen ( color ) ; } for ( i = 0 ; i < 8 ; ++ i ) { qh = BIT ( data , i ) ; video_in = ( ( ( ( d7 & llen ) | ( vsp ? 0 : 1 ) ) & ( gpa0 ? 0 : 1 ) ) & qh ) | lten ; color = ( hlt_in ? 1 : 2 ) * ( video_in ^ compl_in ) ; bitmap . pix32 ( y , x + i ) = m_palette -> pen ( color ) ; } } }
static ADDRESS_MAP@@ _START ( mm1_upd7220_map , AS_0 , 16 , mm1_state ) ADDRESS_MAP_@@ GLOBAL_@@ MASK ( 0x7fff ) AM_RANGE ( 0x0000 , 0x7fff ) AM_RA@@ M AM_SHAR@@ E ( " video _ ram " ) ADDRESS_MAP_@@ END UPD7220_DISPLAY_PIXELS_@@ MEMBER ( mm1_state :: hgdc_display_pixels ) { UINT16 data = m_video_@@ ram [ address >> 1 ] ; for ( int i = 0 ; i < 16 ; i ++ ) { if ( BIT ( data , i ) ) bitmap . pix32 ( y , x + i ) = m_palette -> pen ( 2 ) ; } }
static GFXDECODE_@@ START ( mm1 ) GFXDECODE_@@ ENTRY ( " charg@@ en " , 0 , charlayout , 0 , 1 ) GFXDECODE_@@ END PALETTE_@@ INIT_MEMBER ( mm1_state , mm1 ) { palette . set_pen_color ( 0 , rgb_t ( 0x00 , 0x00 , 0x00 ) ) ; palette . set_pen_color ( 1 , rgb_t ( 0x00 , 0x7F , 0x0A ) ) ; palette . set_pen_color ( 2 , rgb_t ( 0x08 , 0xD0 , 0x1A ) ) ; }
double compute_distance ( double r1 , double c1 , double h , double r2 , double c2 , double r , double c ) { if ( r1 < 0 || r1 >= r || r2 < 0 || r2 >= r ) return 1e@@ 12 ; double dr = abs ( r1 - r2 ) ; double dc = min ( abs ( c1 - c2 ) , c - abs ( c1 - c2 ) ) ; return sqrt ( dr * dr + dc * dc ) + 20. * ( h - 1. ) / ( sqrt ( dr * dr + dc * dc ) + 1 ) ; }
int check_cell_value ( Input & input , int r , int c ) { c = ( c + input . c ) % input . c ; if ( r >= 0 && r < input . r ) return input . cell_field [ r ] [ c ] ; else return 0 ; }
void check_cell ( Input & input , Coord cur , vector < Coord > & path , vector < int > & prev , set < Coord > & visited , vector < double > & dist , int idx , double r , double c , double alpha ) { int dr = input . movement_@@ r [ cur . r ] [ cur . c ] [ cur . h ] ; int dc = input . movement_c [ cur . r ] [ cur . c ] [ cur . h ] ; cur . r += dr ; cur . c += dc ; cur . c = ( cur . c + input . c ) % input . c ; if ( visited . find ( cur ) != visited . end ( ) ) return ; int cnt_cells = 0 ; for ( int i = - 2 ; i <= 2 ; i ++ ) for ( int j = - 2 ; j <= 2 ; j ++ ) cnt_cells += check_cell_value ( input , cur . r + i , cur . c + j ) ; if ( cnt_cells > 12 ) dist . push_back ( dist [ idx ] + alpha ) ; else dist . push_back ( dist [ idx ] + 1.0 ) ; path . push_back ( cur ) ; prev . push_back ( idx ) ; visited . insert ( cur ) ; }
void bfs ( Input & input , vector < Coord > & path , vector < int > & prev , double r , double c , int bfsdepth , double alpha ) { set < Coord > visited ; vector < double > dist ; int idx = 0 ; dist . push_back ( 0 ) ; visited . insert ( path [ idx ] ) ; while ( idx < path . size ( ) ) { Coord cur = path [ idx ] ; if ( dist [ idx ] > ( double ) bfsdepth ) break ; if ( cur . r >= input . r || cur . r < 0 ) { path . push_back ( cur ) ; prev . push_back ( idx ) ; dist . push_back ( dist [ idx ] + 1 ) ; } else { check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; if ( cur . h > 1 ) { cur . h -- ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h ++ ; } if ( cur . h < input . a ) { cur . h ++ ; check_cell ( input , cur , path , prev , visited , dist , idx , r , c , alpha ) ; cur . h -- ; } } idx ++ ; } }
void append_path ( Input & input , int balloon , vector < Coord > & path , vector < int > & prev , int idx_min ) { vector < Coord > reversed_path ; for ( int i = idx_min ; i != 0 ; i = prev [ i ] ) reversed_path . push_back ( path [ i ] ) ; for ( int i = reversed_path . size ( ) - 1 ; i >= 0 ; i -- ) { input . balloons [ balloon ] . h . push_back ( reversed_path [ i ] . h ) ; input . balloons [ balloon ] . r . push_back ( reversed_path [ i ] . r ) ; input . balloons [ balloon ] . c . push_back ( reversed_path [ i ] . c ) ; if ( input . balloons [ balloon ] . h . size ( ) > input . t ) break ; } }
int choose_closest_point ( Input & input , vector < Coord > & path , double r , double c ) { double mind = 1e@@ 10 , curd ; int idx_min = 0 ; for ( int i = 1 ; i < path . size ( ) ; i ++ ) { curd = compute_distance ( path [ i ] . r , path [ i ] . c , path [ i ] . h , r , c , input . r , input . c ) ; if ( curd < mind || idx_min == 0 ) { idx_min = i ; mind = curd ; } } return idx_min ; }
bool check_horizontal_distance ( double c1 , double c2 , double delta_c , double c ) { if ( delta_c > c ) return true ; c2 += delta_c ; if ( c2 > c ) c2 -= c ; if ( abs ( c2 - c1 ) < c - abs ( c2 - c1 ) ) return c1 < c2 ; else return c1 > c2 ; }
void pathfind@@ ing ( Input & input , int balloon , double r , double c , double delta , int bfsdepth , double delta_c , double alpha = 0.5 ) { bool step_done = false ; while ( step_done == false || ( input . balloons [ balloon ] . h . size ( ) <= input . t && compute_distance ( input . balloons [ balloon ] . r . back ( ) , input . balloons [ balloon ] . c . back ( ) , input . balloons [ balloon ] . h . back ( ) , r , c , input . r , input . c ) > delta && check_horizontal_distance ( input . balloons [ balloon ] . c . back ( ) , c , delta_c , input . c ) ) ) { vector < Coord > path ; vector < int > prev ; Coord start ; start . r = input . balloons [ balloon ] . r . back ( ) ; start . c = input . balloons [ balloon ] . c . back ( ) ; start . h = input . balloons [ balloon ] . h . back ( ) ; path . push_back ( start ) ; prev . push_back ( - 1 ) ; bfs ( input , path , prev , r , c , bfsdepth , alpha ) ; int idx_min = choose_closest_point ( input , path , r , c ) ; append_path ( input , balloon , path , prev , idx_min ) ; step_done = true ; } }
ScFont * ScLoadFont ( const char * filename ) { ScFont * font = ( ScFont * ) malloc ( sizeof ( ScFont ) ) ; FILE * file = fopen ( filename , " r " ) ; fread ( ( void * ) & font -> header , sizeof ( ScFontHeader ) , 1 , file ) ; int n_offsets = font -> header . highIndex - font -> header . lowIndex ; Uint32 * offsets = ( Uint32 * ) malloc ( sizeof ( Uint32 ) * ( n_offsets + 1 ) ) ; fseek ( file , sizeof ( ScFontHeader ) , SEEK_SET ) ; fread ( ( void * ) offsets , sizeof ( Uint32 ) , n_offsets , file ) ; fseek ( file , 0 , SEEK_@@ END ) ; offsets [ n_offsets ] = fte@@ ll ( file ) ; font -> letters = ( ScLetter * ) malloc ( sizeof ( ScLetter ) * ( n_offsets + 1 ) ) ; for ( int i = 1 ; i <= n_offsets ; i ++ ) { if ( offsets [ i - 1 ] ) { fseek ( file , offsets [ i - 1 ] , SEEK_SET ) ; fread ( ( void * ) & font -> letters [ i ] . header , sizeof ( ScLetterHeader ) , 1 , file ) ; int next_offset = offsets [ i ] ; for ( int o = 0 ; ! next_offset ; o ++ ) { next_offset = offsets [ i + o ] ; } font -> letters [ i ] . n_pixels = next_offset - ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) - 1 ; font -> letters [ i ] . pixels = ( Uint8 * ) malloc ( sizeof ( Uint8 ) * font -> letters [ i ] . n_pixels ) ; fseek ( file , ( offsets [ i - 1 ] + sizeof ( ScLetterHeader ) ) , SEEK_SET ) ; fread ( ( void * ) font -> letters [ i ] . pixels , sizeof ( Uint8 ) , font -> letters [ i ] . n_pixels , file ) ; } else font -> letters [ i ] . n_pixels = - 1 ; } font -> letters [ 0 ] . n_pixels = 0 ; font -> letters [ 0 ] . header . x = 0 ; font -> letters [ 0 ] . header . y = 0 ; font -> letters [ 0 ] . header . h = 0 ; font -> letters [ 0 ] . header . w = font -> header . maxWidth / 2 ; free ( offsets ) ; fclose ( file ) ; return font ; }
ScPalette * ScLoad@@ Palette ( const char * filename ) { ScPalette * palette = ( ScPalette * ) malloc ( sizeof ( ScPalette ) ) ; SDL_Surface * s_palette ; if ( ( s_palette = SDL_Display@@ Format ( IMG_Load ( filename ) ) ) == NULL ) { fprintf ( stderr , " ERROR : ▁ Cannot ▁ load ▁ palette ▁ ' % s ' " , filename ) ; exit ( 1 ) ; } memcpy ( * palette , s_palette -> pixels , s_palette -> format -> BytesPerPixel * s_palette -> w ) ; SDL_FreeSurface ( s_palette ) ; return palette ; }
SDL_Surface * ScRenderChar ( unsigned const char car , ScFont * font , ScColor * color ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; int index = car - font -> header . lowIndex ; if ( ( car < font -> header . lowIndex ) || ( car > font -> header . highIndex ) || ( font -> letters [ index ] . n_pixels < 0 ) ) { fprintf ( stderr , " ERROR ▁ ( ScRenderChar ) : ▁ Invalid ▁ character ▁ index ▁ % d \n " , car ) ; return NULL ; } SDL_Surface * letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> letters [ index ] . header . h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; if ( font -> letters [ index ] . header . h > 0 ) { char * pixels = ( char * ) letter -> pixels - letter -> format -> BytesPerPixel ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 gamma = font -> letters [ index ] . pixels [ p ] & 7 ; pixels += skip * letter -> format -> BytesPerPixel + letter -> format -> BytesPerPixel ; memcpy ( pixels , * color + gamma , letter -> format -> BytesPerPixel ) ; } SDL_SetColorKey ( letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; } SDL_Surface * final_letter = SDL_CreateRGBSurface ( SDL_SWSURFACE , font -> letters [ index ] . header . w , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_Rect offset = { font -> letters [ index ] . header . x , font -> letters [ index ] . header . y , 0 , 0 } ; SDL_BlitSurface ( letter , NULL , final_letter , & offset ) ; SDL_FreeSurface ( letter ) ; SDL_SetColorKey ( final_letter , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; return final_letter ; }
int calculateWidth ( const unsigned char * text , ScFont * font , char delim ) { int width = 0 ; while ( * text ) { if ( * text != delim ) width += font -> letters [ * text - font -> header . lowIndex ] . header . w + 1 ; text ++ ; } return width - 1 ; }
SDL_Surface * ScRenderText ( const char * text , ScFont * font , ScColor * color , ScColor * color_hi , char delim ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Surface * s_text = SDL_CreateRGBSurface ( SDL_SWSURFACE , calculateWidth ( ( unsigned char * ) text , font , delim ) , font -> header . maxHeight , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; SDL_SetColorKey ( s_text , SDL_SRCCOLORKEY | SDL_RLEACCEL , 0 ) ; SDL_Surface * s_char ; SDL_Rect offset = { 0 , 0 , 0 , 0 } ; if ( color_hi ) { ScColor * actual_color = color ; while ( * text ) { if ( * text == delim ) { if ( actual_color == color ) actual_color = color_hi ; else actual_color = color ; } else { if ( ( s_char = ScRenderChar ( * text , font , actual_color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } else { while ( * text ) { if ( * text != delim ) { if ( ( s_char = ScRenderChar ( * text , font , color ) ) ) { SDL_BlitSurface ( s_char , NULL , s_text , & offset ) ; offset . x += s_char -> w + 1 ; SDL_FreeSurface ( s_char ) ; } } text ++ ; } } return s_text ; }
ScColor * ScGetColor ( const ScPalette * palette , int index ) { ScColor * color = ( ScColor * ) malloc ( sizeof ( ScColor ) ) ; memcpy ( * color , * palette + ( index * MAX_G@@ AMM@@ A ) , sizeof ( ScColor ) ) ; return color ; }
void ScTestFont ( ScFont * font , ScPalette * palette ) { SDL_Surface * screen = SDL_GetVideoSurface ( ) ; SDL_Fill@@ Rect ( screen , NULL , SDL_Map@@ RGB ( SDL_GetVideoSurface ( ) -> format , 255 , 255 , 255 ) ) ; SDL_Flip ( screen ) ; SDL_Rect offset = { 10 , 10 , 0 , 0 } ; SDL_BlitSurface ( ScRenderText ( " El ▁ veloz ▁ mur@@ ci � ago ▁ hind " , font , ScGetColor ( palette , 1 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " Jui@@ porentender@@ las " , font , ScGetColor ( palette , 5 ) ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; SDL_BlitSurface ( ScRenderText ( " _ S _ ingle ▁ Player " , font , ScGetColor ( palette , 1 ) , ScGetColor ( palette , 2 ) , ' _ ' ) , NULL , screen , & offset ) ; offset . y += font -> header . maxHeight + 2 ; for ( int i = font -> header . lowIndex ; i <= font -> header . highIndex ; i ++ ) { SDL_Surface * s_char = ScRenderChar ( i , font , ScGetColor ( palette , 2 ) ) ; if ( s_char ) { SDL_BlitSurface ( s_char , NULL , screen , & offset ) ; SDL_FreeSurface ( s_char ) ; } if ( ( offset . x += font -> header . maxWidth + 2 ) > ( screen -> w - font -> header . maxWidth - 10 ) ) { offset . x = 10 ; offset . y += font -> header . maxHeight + 2 ; } int index = i - font -> header . lowIndex ; int x = 1 ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) printf ( " % d ▁ " , ( font -> letters [ i ] . pixels [ p ] >> 3 ) ) ; printf ( " \n " ) ; for ( int p = 0 ; p < font -> letters [ index ] . n_pixels ; p ++ ) { Uint8 skip = font -> letters [ index ] . pixels [ p ] >> 3 ; Uint8 color = font -> letters [ index ] . pixels [ p ] & 7 ; for ( int j = 0 ; j < skip ; j ++ ) { printf ( " ▁ " ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " % d " , color ) ; if ( x ++ == font -> letters [ index ] . header . w ) { printf ( " \n " ) ; x = 1 ; } } printf ( " \n test ▁ end \n " ) ; getchar ( ) ; } SDL_Flip ( screen ) ; * screen = * SDL_CreateRGBSurface ( SDL_SWSURFACE , screen -> w , screen -> h , screen -> format -> BitsPerPixel , screen -> format -> Rmask , screen -> format -> Gmask , screen -> format -> Bmask , screen -> format -> Amask ) ; getchar ( ) ; }
void process ( SILInstruction * I ) { visit ( I ) ; }
SILBasicBlock * remap@@ BasicBlock ( SILBasicBlock * BB ) { return BB ; }
SILValue getMappedValue ( SILValue Value ) { return SILCloner < InitSequenceCloner > :: getMappedValue ( Value ) ; }
void postProcess ( SILInstruction * orig , SILInstruction * cloned ) { DestIP -> getParent ( ) -> push_front ( cloned ) ; cloned -> moveBefore ( DestIP ) ; SILClonerWithScopes < InitSequenceCloner > :: postProcess ( orig , cloned ) ; }
SILValue clone ( ) { for ( auto I : Init . Instructions ) process ( I ) ; return getMappedValue ( Init . Result ) ; }
static bool isStructurallyIdentical ( SILValue LHS , SILValue RHS ) { if ( LHS == RHS ) return true ; if ( LHS -> getType ( ) != RHS -> getType ( ) ) return false ; auto lResult = LHS -> getDefiningInstructionResult ( ) ; auto rResult = RHS -> getDefiningInstructionResult ( ) ; assert ( lResult && rResult && " operands ▁ of ▁ instructions ▁ appro@@ ved ▁ by ▁ analyzeStaticInitializer ▁ " " should ▁ always ▁ be ▁ defined ▁ by ▁ instructions " ) ; return ( lResult -> ResultIndex == rResult -> ResultIndex && lResult -> Instruction -> isIdentical@@ To ( rResult -> Instruction , isStructurallyIdentical ) ) ; }
static bool isSameInitSequence ( const InitSequence & LHS , const InitSequence & RHS ) { assert ( LHS . isValid ( ) && RHS . isValid ( ) ) ; return isStructurallyIdentical ( LHS . Result , RHS . Result ) ; }
static bool isAssignableExternally ( VarDecl * Property , SILModule * Module ) { if ( Module -> isVisible@@ Externally ( Property ) ) { auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( isa < ClassDecl > ( Ty ) ) return false ; for ( auto SP : Ty -> getStoredProperties ( ) ) { auto storedPropertyAccess = SP -> getEffectiveAccess ( ) ; if ( storedPropertyAccess <= AccessLevel :: FilePrivate || ( storedPropertyAccess <= AccessLevel :: Internal && Module -> isWholeModule ( ) ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ cannot ▁ be ▁ set ▁ externally \n " ) ; return false ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ can ▁ be ▁ used ▁ externally \n " ) ; return true ; } return false ; }
static bool mayHaveUnknownUses ( VarDecl * Property , SILModule * Module ) { if ( Property -> getDeclContext ( ) -> getParent@@ Module ( ) != Module -> getSw@@ iftModule ( ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ " << * Property << " ▁ is ▁ defined ▁ in ▁ a ▁ differ@@ ent ▁ module \n " ) ; return true ; } if ( isAssignableExternally ( Property , Module ) ) { return true ; } return false ; }
static bool isProjectionOfProperty ( SILValue addr , VarDecl * Property ) { if ( auto * REA = dyn_cast < RefElementAddrInst > ( addr ) ) { return REA -> getField ( ) == Property ; } if ( auto * SEA = dyn_cast < StructElementAddrInst > ( addr ) ) { return SEA -> getField ( ) == Property ; } return false ; }
static bool isValidPropertyLoad ( SILInstruction * I ) { if ( isa < LoadInst > ( I ) ) return true ; if ( isa < StructElementAddrInst > ( I ) || isa < Tup@@ leElementAddrInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { if ( isIncidentalUse ( Use -> getUser ( ) ) ) continue ; if ( ! isValidPropertyLoad ( Use -> getUser ( ) ) ) return false ; } return true ; } return false ; }
void EnsureWalletIsUnlocked ( ) { if ( pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_UNLOCK_@@ NEEDED , " Error : ▁ Please ▁ enter ▁ the ▁ wallet ▁ passphrase ▁ with ▁ walletpassphrase ▁ first . " ) ; if ( fWalletUnlockStakingOnly ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKE@@ D_ST@@ AKING_@@ ONLY , " Error : ▁ Wallet ▁ is ▁ unlocked ▁ for ▁ staking ▁ only . " ) ; }
void WalletTxToJSON ( const CWalletTx & wtx , Object & entry ) { int confirms = wtx . GetDepthInMainChain ( ) ; entry . push_back ( Pair ( " confirmations " , confirms ) ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " generated " , true ) ) ; if ( confirms > 0 ) { entry . push_back ( Pair ( " blockhash " , wtx . hashBlock . GetHex ( ) ) ) ; entry . push_back ( Pair ( " blockindex " , wtx . nIndex ) ) ; entry . push_back ( Pair ( " blocktime " , ( boost :: int64_t ) ( mapBlockIndex [ wtx . hashBlock ] -> nTime ) ) ) ; } entry . push_back ( Pair ( " txid " , wtx . GetHash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " normtxid " , wtx . GetNormal@@ ized@@ Hash ( ) . GetHex ( ) ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) wtx . GetTxTime ( ) ) ) ; entry . push_back ( Pair ( " timereceiv@@ ed " , ( boost :: int64_t ) wtx . nTimeReceived ) ) ; BOOST_FOREACH ( const PAIRTYPE ( string , string ) & item , wtx . mapValue ) entry . push_back ( Pair ( item . first , item . second ) ) ; }
string AccountFromValue ( const Value & value ) { string strAccount = value . get_str ( ) ; if ( strAccount == " * " ) throw JSONRPCError ( RPC_WALLET_INVALID_ACCOUNT_@@ NAME , " Invalid ▁ account ▁ name " ) ; return strAccount ; }
Value getinfo ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 0 ) throw runtime_error ( " getinfo \n " " Returns ▁ an ▁ object ▁ containing ▁ various ▁ state ▁ info . " ) ; proxy@@ Type proxy ; GetProxy ( NET_IP@@ V4 , proxy ) ; Object obj ; obj . push_back ( Pair ( " version " , ( int ) CLIENT_VERSION ) ) ; obj . push_back ( Pair ( " proto@@ colversion " , ( int ) PROTOCOL_VERSION ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " walletversion " , pwalletMain -> GetVersion ( ) ) ) ; obj . push_back ( Pair ( " balance " , ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ) ) ; obj . push_back ( Pair ( " unconfirmedbalance " , ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ) ) ; obj . push_back ( Pair ( " stake " , ValueFromAmount ( pwalletMain -> GetStake ( ) ) ) ) ; obj . push_back ( Pair ( " locked " , pwalletMain -> IsLocked ( ) ) ) ; obj . push_back ( Pair ( " encrypted " , pwalletMain -> IsCrypted ( ) ) ) ; } obj . push_back ( Pair ( " blocks " , ( int ) nBestHeight ) ) ; obj . push_back ( Pair ( " timeoffset " , ( boost :: int64_t ) GetTimeOffset ( ) ) ) ; obj . push_back ( Pair ( " money@@ supply " , ValueFromAmount ( pindexBest -> nMoney@@ Supply ) ) ) ; obj . push_back ( Pair ( " connections " , ( int ) vNodes . size ( ) ) ) ; obj . push_back ( Pair ( " proxy " , ( proxy . first . IsValid ( ) ? proxy . first . ToString@@ IPPort ( ) : string ( ) ) ) ) ; obj . push_back ( Pair ( " difficulty " , ( double ) GetDifficulty ( ) ) ) ; obj . push_back ( Pair ( " testnet " , fTestNet ) ) ; if ( pwalletMain ) { obj . push_back ( Pair ( " keypoolo@@ ldest " , ( boost :: int64_t ) pwalletMain -> GetOldest@@ KeyPool@@ Time ( ) ) ) ; obj . push_back ( Pair ( " keypool@@ size " , ( int ) pwalletMain -> GetKeyPoolSize ( ) ) ) ; } obj . push_back ( Pair ( " paytxfee " , ValueFromAmount ( nTransactionFee ) ) ) ; obj . push_back ( Pair ( " mininput " , ValueFromAmount ( nMinimumInputValue ) ) ) ; if ( pwalletMain && pwalletMain -> IsCrypted ( ) ) obj . push_back ( Pair ( " unlocked _ until " , ( boost :: int64_t ) nWalletUnlockTime ) ) ; obj . push_back ( Pair ( " errors " , GetWar@@ nings ( " statusbar " ) ) ) ; return obj ; }
Value getnewaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " getnewaddress ▁ [ account ] \n " " Returns ▁ a ▁ new ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments . ▁ ▁ " " If ▁ [ account ] ▁ is ▁ specified ▁ ( recomm@@ ended ) , ▁ it ▁ is ▁ added ▁ to ▁ the ▁ address ▁ book ▁ " " so ▁ payments ▁ received ▁ with ▁ the ▁ address ▁ will ▁ be ▁ credited ▁ to ▁ [ account ] . " ) ; string strAccount ; if ( params . size ( ) > 0 ) strAccount = AccountFromValue ( params [ 0 ] ) ; if ( ! pwalletMain -> IsLocked ( ) ) pwalletMain -> TopUpKeyPool ( ) ; CPubKey newKey ; if ( ! pwalletMain -> GetKeyFromPool ( newKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; CKeyID keyID = newKey . GetID ( ) ; pwalletMain -> SetAddressBookName ( keyID , strAccount ) ; return CBitcoinAddress ( keyID ) . ToString ( ) ; }
CBitcoinAddress GetAccountAddress ( string strAccount , bool bForceNew = false ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; CAccount account ; walletdb . ReadAccount ( strAccount , account ) ; bool bKeyUsed = false ; if ( account . vchPubKey . IsValid ( ) ) { CScript scriptPubKey ; scriptPubKey . SetDestination ( account . vchPubKey . GetID ( ) ) ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) && account . vchPubKey . IsValid ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) bKeyUsed = true ; } } if ( ! account . vchPubKey . IsValid ( ) || bForceNew || bKeyUsed ) { if ( ! pwalletMain -> GetKeyFromPool ( account . vchPubKey , false ) ) throw JSONRPCError ( RPC_WALLET_KEYPOOL_RAN_OUT , " Error : ▁ Keypool ▁ ran ▁ out , ▁ please ▁ call ▁ keypoolrefill ▁ first " ) ; pwalletMain -> SetAddressBookName ( account . vchPubKey . GetID ( ) , strAccount ) ; walletdb . WriteAccount ( strAccount , account ) ; } return CBitcoinAddress ( account . vchPubKey . GetID ( ) ) ; }
Value getaccountaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccountaddress ▁ < account > \n " " Returns ▁ the ▁ current ▁ ILoveYouCoins ▁ address ▁ for ▁ receiving ▁ payments ▁ to ▁ this ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Value ret ; ret = GetAccountAddress ( strAccount ) . ToString ( ) ; return ret ; }
Value setaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " setaccount ▁ < iloveyoucoinsaddress > ▁ < account > \n " " Sets ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; if ( params . size ( ) > 1 ) strAccount = AccountFromValue ( params [ 1 ] ) ; if ( pwalletMain -> mapAddressBook . count ( address . Get ( ) ) ) { string strOldAccount = pwalletMain -> mapAddressBook [ address . Get ( ) ] ; if ( address == GetAccountAddress ( strOldAccount ) ) GetAccountAddress ( strOldAccount , true ) ; } pwalletMain -> SetAddressBookName ( address . Get ( ) , strAccount ) ; return Value :: null ; }
Value getaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaccount ▁ < iloveyoucoinsaddress > \n " " Returns ▁ the ▁ account ▁ associated ▁ with ▁ the ▁ given ▁ address . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; string strAccount ; map < CTxDestination , string > :: iterator mi = pwalletMain -> mapAddressBook . find ( address . Get ( ) ) ; if ( mi != pwalletMain -> mapAddressBook . end ( ) && ! ( * mi ) . second . empty ( ) ) strAccount = ( * mi ) . second ; return strAccount ; }
Value getaddressesbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " getaddressesbyaccount ▁ < account > \n " " Returns ▁ the ▁ list ▁ of ▁ addresses ▁ for ▁ the ▁ given ▁ account . " ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Array ret ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) ret . push_back ( address . ToString ( ) ) ; } return ret ; }
Value setmininput ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 1 ) throw runtime_error ( " setmininput ▁ < amount > \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" ) ; int64 nAmount = 0 ; if ( params [ 0 ] . get_real ( ) != 0.0 ) nAmount = AmountFromValue ( params [ 0 ] ) ; nMinimumInputValue = nAmount ; return true ; }
Value sendtoaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendtoaddress ▁ < iloveyoucoinsaddress > ▁ < amount > ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; CWalletTx wtx ; if ( params . size ( ) > 2 && params [ 2 ] . type ( ) != null_type && ! params [ 2 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 2 ] . get_str ( ) ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 3 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
Value listaddressgroupings ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listaddressgroupings \n " " Lists ▁ groups ▁ of ▁ addresses ▁ which ▁ have ▁ had ▁ their ▁ common ▁ ownership \n " " made ▁ public ▁ by ▁ common ▁ use ▁ as ▁ inputs ▁ or ▁ as ▁ the ▁ resulting ▁ change \n " " in ▁ past ▁ transactions " ) ; Array jsonGroupings ; map < CTxDestination , int64 > balances = pwalletMain -> GetAddress@@ Balances ( ) ; BOOST_FOREACH ( set < CTxDestination > grouping , pwalletMain -> GetAddress@@ Groupings ( ) ) { Array jsonGrouping ; BOOST_FOREACH ( CTxDestination address , grouping ) { Array addressInfo ; addressInfo . push_back ( CBitcoinAddress ( address ) . ToString ( ) ) ; addressInfo . push_back ( ValueFromAmount ( balances [ address ] ) ) ; { LOCK ( pwalletMain -> cs_wallet ) ; if ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) != pwalletMain -> mapAddressBook . end ( ) ) addressInfo . push_back ( pwalletMain -> mapAddressBook . find ( CBitcoinAddress ( address ) . Get ( ) ) -> second ) ; } jsonGrouping . push_back ( addressInfo ) ; } jsonGroupings . push_back ( jsonGrouping ) ; } return jsonGroupings ; }
Value signmessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 2 ) throw runtime_error ( " signmessage ▁ < iloveyoucoinsaddress > ▁ < message > \n " " Sign ▁ a ▁ message ▁ with ▁ the ▁ private ▁ key ▁ of ▁ an ▁ address " ) ; EnsureWalletIsUnlocked ( ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strMessage = params [ 1 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; CKey key ; if ( ! pwalletMain -> GetKey ( keyID , key ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Private ▁ key ▁ not ▁ available " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; vector < unsigned char > vchSig ; if ( ! key . SignCompact ( ss . GetHash ( ) , vchSig ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Sign ▁ failed " ) ; return Encode@@ Base64 ( & vchSig [ 0 ] , vchSig . size ( ) ) ; }
Value verifymessage ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 3 ) throw runtime_error ( " verifymessage ▁ < iloveyoucoinsaddress > ▁ < signature > ▁ < message > \n " " Verify ▁ a ▁ signed ▁ message " ) ; string strAddress = params [ 0 ] . get_str ( ) ; string strSign = params [ 1 ] . get_str ( ) ; string strMessage = params [ 2 ] . get_str ( ) ; CBitcoinAddress addr ( strAddress ) ; if ( ! addr . IsValid ( ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Invalid ▁ address " ) ; CKeyID keyID ; if ( ! addr . GetKeyID ( keyID ) ) throw JSONRPCError ( RPC_TYPE_ERROR , " Address ▁ does ▁ not ▁ refer ▁ to ▁ key " ) ; bool fInvalid = false ; vector < unsigned char > vchSig = Decode@@ Base64 ( strSign . c_str ( ) , & fInvalid ) ; if ( fInvalid ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Mal@@ formed ▁ base64 ▁ encoding " ) ; CHashWriter ss ( SER_GETHASH , 0 ) ; ss << strMessageMagic ; ss << strMessage ; CPubKey pubkey ; if ( ! pubkey . Reco@@ verCompact ( ss . GetHash ( ) , vchSig ) ) return false ; return ( pubkey . GetID ( ) == keyID ) ; }
Value getreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaddress ▁ < iloveyoucoinsaddress > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ < iloveyoucoinsaddress > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; CBitcoinAddress address = CBitcoinAddress ( params [ 0 ] . get_str ( ) ) ; CScript scriptPubKey ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; scriptPubKey . SetDestination ( address . Get ( ) ) ; if ( ! IsMine ( * pwalletMain , scriptPubKey ) ) return ( double ) 0.0 ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) if ( txout . scriptPubKey == scriptPubKey ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } return ValueFromAmount ( nAmount ) ; }
void GetAccountAddresses ( string strAccount , set < CTxDestination > & setAddress ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & item , pwalletMain -> mapAddressBook ) { const CTxDestination & address = item . first ; const string & strName = item . second ; if ( strName == strAccount ) setAddress . insert ( address ) ; } }
Value getreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " getreceivedbyaccount ▁ < account > ▁ [ minconf = 1 ] \n " " Returns ▁ the ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ < account > ▁ in ▁ transactions ▁ with ▁ at ▁ least ▁ [ minconf ] ▁ confirmations . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; set < CTxDestination > setAddress ; GetAccountAddresses ( strAccount , setAddress ) ; int64 nAmount = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ExtractDestination ( txout . scriptPubKey , address ) && IsMine ( * pwalletMain , address ) && setAddress . count ( address ) ) if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) nAmount += txout . nValue ; } } return ( double ) nAmount / ( double ) COIN ; }
int64 GetAccountBalance ( CWalletDB & walletdb , const string & strAccount , int nMinDepth ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsFinal ( ) ) continue ; int64 nReceived , nSent , nFee ; wtx . GetAccountAmounts ( strAccount , nReceived , nSent , nFee ) ; if ( nReceived != 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) nBalance += nReceived ; nBalance -= nSent + nFee ; } nBalance += walletdb . GetAccountCreditDebit ( strAccount ) ; return nBalance ; }
int64 GetAccountBalance ( const string & strAccount , int nMinDepth ) { CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; return GetAccountBalance ( walletdb , strAccount , nMinDepth ) ; }
Value getbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getbalance ▁ [ account ] ▁ [ minconf = 1 ] \n " " If ▁ [ account ] ▁ is ▁ not ▁ specified , ▁ returns ▁ the ▁ server ' s ▁ total ▁ available ▁ balance . \n " " If ▁ [ account ] ▁ is ▁ specified , ▁ returns ▁ the ▁ balance ▁ in ▁ the ▁ account . " ) ; if ( params . size ( ) == 0 ) return ValueFromAmount ( pwalletMain -> GetBalance ( ) ) ; int nMinDepth = 1 ; if ( params . size ( ) > 1 ) nMinDepth = params [ 1 ] . get_int ( ) ; if ( params [ 0 ] . get_str ( ) == " * " ) { int64 nBalance = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsConfirmed ( ) ) continue ; int64 allFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , allFee , strSentAccount ) ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) nBalance += r . second ; } BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listSent ) nBalance -= r . second ; nBalance -= allFee ; } return ValueFromAmount ( nBalance ) ; } string strAccount = AccountFromValue ( params [ 0 ] ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; return ValueFromAmount ( nBalance ) ; }
Value getunconfirmedbalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " getunconfirmedbalance \n " " Returns ▁ the ▁ server ' s ▁ total ▁ unconfirmed ▁ balance \n " ) ; return ValueFromAmount ( pwalletMain -> GetUnconfirmedBalance ( ) ) ; }
Value movec@@ md ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 5 ) throw runtime_error ( " move ▁ < fromaccount > ▁ < toaccount > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] \n " " Move ▁ from ▁ one ▁ account ▁ in ▁ your ▁ wallet ▁ to ▁ another . " ) ; string strFrom = AccountFromValue ( params [ 0 ] ) ; string strTo = AccountFromValue ( params [ 1 ] ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; if ( params . size ( ) > 3 ) ( void ) params [ 3 ] . get_int ( ) ; string strComment ; if ( params . size ( ) > 4 ) strComment = params [ 4 ] . get_str ( ) ; CWalletDB walletdb ( pwalletMain -> strWalletFile ) ; if ( ! walletdb . Txn@@ Begin ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; int64 nNow = GetAdjust@@ edTime ( ) ; CAccountingEntry debit ; debit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; debit . strAccount = strFrom ; debit . nCreditDebit = - nAmount ; debit . nTime = nNow ; debit . strOtherAccount = strTo ; debit . strComment = strComment ; walletdb . WriteAccountingEntry ( debit ) ; CAccountingEntry credit ; credit . nOrderPos = pwalletMain -> IncOrderPosNext ( & walletdb ) ; credit . strAccount = strTo ; credit . nCreditDebit = nAmount ; credit . nTime = nNow ; credit . strOtherAccount = strFrom ; credit . strComment = strComment ; walletdb . WriteAccountingEntry ( credit ) ; if ( ! walletdb . Txn@@ Commit ( ) ) throw JSONRPCError ( RPC_DATABASE_ERROR , " database ▁ error " ) ; return true ; }
Value sendfrom ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 3 || params . size ( ) > 6 ) throw runtime_error ( " sendfrom ▁ < fromaccount > ▁ < toiloveyoucoinsaddress > ▁ < amount > ▁ [ minconf = 1 ] ▁ [ comment ] ▁ [ comment - to ] \n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ is ▁ rounded ▁ to ▁ the ▁ nearest ▁ 0.00000001" + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; CBitcoinAddress address ( params [ 1 ] . get_str ( ) ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ ILoveYouCoins ▁ address " ) ; int64 nAmount = AmountFromValue ( params [ 2 ] ) ; int nMinDepth = 1 ; if ( params . size ( ) > 3 ) nMinDepth = params [ 3 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 4 && params [ 4 ] . type ( ) != null_type && ! params [ 4 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 4 ] . get_str ( ) ; if ( params . size ( ) > 5 && params [ 5 ] . type ( ) != null_type && ! params [ 5 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " to " ] = params [ 5 ] . get_str ( ) ; EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( nAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; string strError = pwalletMain -> SendMoneyToDestination ( address . Get ( ) , nAmount , wtx ) ; if ( strError != " " ) throw JSONRPCError ( RPC_WALLET_ERROR , strError ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
Value sendmany ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 4 ) throw runtime_error ( " sendmany ▁ < fromaccount > ▁ { address : amount , . . . } ▁ [ minconf = 1 ] ▁ [ comment ] \n " " amounts ▁ are ▁ double - precision ▁ floating ▁ point ▁ numbers " + HelpRequiringPassphrase ( ) ) ; string strAccount = AccountFromValue ( params [ 0 ] ) ; Object sendTo = params [ 1 ] . get_obj ( ) ; int nMinDepth = 1 ; if ( params . size ( ) > 2 ) nMinDepth = params [ 2 ] . get_int ( ) ; CWalletTx wtx ; wtx . strFromAccount = strAccount ; if ( params . size ( ) > 3 && params [ 3 ] . type ( ) != null_type && ! params [ 3 ] . get_str ( ) . empty ( ) ) wtx . mapValue [ " comment " ] = params [ 3 ] . get_str ( ) ; set < CBitcoinAddress > setAddress ; vector < pair < CScript , int64 > > vecSend ; int64 totalAmount = 0 ; BOOST_FOREACH ( const Pair & s , sendTo ) { CBitcoinAddress address ( s . name_ ) ; if ( ! address . IsValid ( ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , string ( " Invalid ▁ ILoveYouCoins ▁ address : ▁ " ) + s . name_ ) ; if ( setAddress . count ( address ) ) throw JSONRPCError ( RPC_INVALID_PARAMETER , string ( " Invalid ▁ parameter , ▁ duplic@@ ated ▁ address : ▁ " ) + s . name_ ) ; setAddress . insert ( address ) ; CScript scriptPubKey ; scriptPubKey . SetDestination ( address . Get ( ) ) ; int64 nAmount = AmountFromValue ( s . value_ ) ; totalAmount += nAmount ; vecSend . push_back ( make_pair ( scriptPubKey , nAmount ) ) ; } EnsureWalletIsUnlocked ( ) ; int64 nBalance = GetAccountBalance ( strAccount , nMinDepth ) ; if ( totalAmount > nBalance ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , " Account ▁ has ▁ insufficient ▁ funds " ) ; CReserve@@ Key keyChange ( pwalletMain ) ; int64 nFeeRequired = 0 ; string strFailReason ; bool fCreated = pwalletMain -> CreateTransaction ( vecSend , wtx , keyChange , nFeeRequired , strFailReason ) ; if ( ! fCreated ) throw JSONRPCError ( RPC_WALLET_INSUFFICIENT_FUNDS , strFailReason ) ; if ( ! pwalletMain -> Commit@@ Transaction ( wtx , keyChange ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Transaction ▁ commit ▁ failed " ) ; return wtx . GetHash ( ) . GetHex ( ) ; }
static CScript _createmultisig ( const Array & params ) { int nRequired = params [ 0 ] . get_int ( ) ; const Array & keys = params [ 1 ] . get_array ( ) ; if ( nRequired < 1 ) throw runtime_error ( " a ▁ multisignature ▁ address ▁ must ▁ require ▁ at ▁ least ▁ one ▁ key ▁ to ▁ redeem " ) ; if ( ( int ) keys . size ( ) < nRequired ) throw runtime_error ( strprintf ( " not ▁ enough ▁ keys ▁ supplied ▁ " " ( got ▁ % " PR@@ Iszu " ▁ keys , ▁ but ▁ need ▁ at ▁ least ▁ % d ▁ to ▁ redeem ) " , keys . size ( ) , nRequired ) ) ; std :: vector < CPubKey > pubkeys ; pubkeys . resize ( keys . size ( ) ) ; for ( unsigned int i = 0 ; i < keys . size ( ) ; i ++ ) { const std :: string & ks = keys [ i ] . get_str ( ) ; CBitcoinAddress address ( ks ) ; if ( pwalletMain && address . IsValid ( ) ) { CKeyID keyID ; if ( ! address . GetKeyID ( keyID ) ) throw runtime_error ( strprintf ( " % s ▁ does ▁ not ▁ refer ▁ to ▁ a ▁ key " , ks . c_str ( ) ) ) ; CPubKey vchPubKey ; if ( ! pwalletMain -> GetPubKey ( keyID , vchPubKey ) ) throw runtime_error ( strprintf ( " no ▁ full ▁ public ▁ key ▁ for ▁ address ▁ % s " , ks . c_str ( ) ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else if ( IsHex ( ks ) ) { CPubKey vchPubKey ( ParseHex ( ks ) ) ; if ( ! vchPubKey . IsFullyValid ( ) ) throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; pubkeys [ i ] = vchPubKey ; } else { throw runtime_error ( " ▁ Invalid ▁ public ▁ key : ▁ " + ks ) ; } } CScript result ; result . SetMulti@@ sig ( nRequired , pubkeys ) ; return result ; }
Value addmultisigaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) { string msg = " addmultisigaddress ▁ < nrequired > ▁ < ' [ \ " key \ " , \ " key \ " ] ' > ▁ [ account ] \n " " Add ▁ a ▁ nrequired - to - sign ▁ multisignature ▁ address ▁ to ▁ the ▁ wallet\ " \ n " " each ▁ key ▁ is ▁ a ▁ ILoveYouCoins ▁ address ▁ or ▁ hex - encoded ▁ public ▁ key \ n " " If ▁ [ account ] ▁ is ▁ specified , ▁ assign ▁ address ▁ to ▁ [ account ] . " ; throw runtime_error ( msg ) ; } string strAccount ; if ( params . size ( ) > 2 ) strAccount = AccountFromValue ( params [ 2 ] ) ; CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; pwalletMain -> AddCScript ( inner ) ; pwalletMain -> SetAddressBookName ( innerID , strAccount ) ; return CBitcoinAddress ( innerID ) . ToString ( ) ; } Value createmultisig ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 2 || params . size ( ) > 2 ) { string msg = " createmultisig ▁ < nrequired > ▁ < ' [ \ " key\ " , \ " key\ " ] ' > \ n " " Creates ▁ a ▁ multi - signature ▁ address ▁ and ▁ returns ▁ a ▁ json ▁ object \ n " " with ▁ keys : \ n " " address ▁ : ▁ iloveyoucoins ▁ address \ n " " redeemScript ▁ : ▁ hex - encoded ▁ rede@@ mpt@@ ion ▁ script " ; throw runtime_error ( msg ) ; } CScript inner = _createmultisig ( params ) ; CScriptID innerID = inner . GetID ( ) ; CBitcoinAddress address ( innerID ) ; Object result ; result . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; result . push_back ( Pair ( " redeemScript " , HexStr ( inner . begin ( ) , inner . end ( ) ) ) ) ; return result ; } struct tallyitem { int64 nAmount ; int nConf ; vector < uint256 > txids ; tallyitem ( ) { nAmount = 0 ; nConf = std :: numeric_limits < int > :: max ( ) ; } } ; Value ListReceived ( const Array & params , bool fByAccounts ) { int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; bool fIncludeEmpty = false ; if ( params . size ( ) > 1 ) fIncludeEmpty = params [ 1 ] . get_bool ( ) ; map < CBitcoinAddress , tallyitem > mapTally ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) || ! wtx . IsFinal ( ) ) continue ; int nDepth = wtx . GetDepthInMainChain ( ) ; if ( nDepth < nMinDepth ) continue ; BOOST_FOREACH ( const CTxOut & txout , wtx . vout ) { CTxDestination address ; if ( ! ExtractDestination ( txout . scriptPubKey , address ) || ! IsMine ( * pwalletMain , address ) ) continue ; tallyitem & item = mapTally [ address ] ; item . nAmount += txout . nValue ; item . nConf = min ( item . nConf , nDepth ) ; item . txids . push_back ( wtx . GetHash ( ) ) ; } } Array ret ; map < string , tallyitem > mapAccountTally ; BOOST_FOREACH ( const PAIRTYPE ( CBitcoinAddress , string ) & item , pwalletMain -> mapAddressBook ) { const CBitcoinAddress & address = item . first ; const string & strAccount = item . second ; map < CBitcoinAddress , tallyitem > :: iterator it = mapTally . find ( address ) ; if ( it == mapTally . end ( ) && ! fIncludeEmpty ) continue ; int64 nAmount = 0 ; int nConf = std :: numeric_limits < int > :: max ( ) ; if ( it != mapTally . end ( ) ) { nAmount = ( * it ) . second . nAmount ; nConf = ( * it ) . second . nConf ; } if ( fByAccounts ) { tallyitem & item = mapAccountTally [ strAccount ] ; item . nAmount += nAmount ; item . nConf = min ( item . nConf , nConf ) ; } else { Object obj ; obj . push_back ( Pair ( " address " , address . ToString ( ) ) ) ; obj . push_back ( Pair ( " account " , strAccount ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; Array transactions ; if ( it != mapTally . end ( ) ) { BOOST_FOREACH ( const uint256 & item , ( * it ) . second . txids ) { transactions . push_back ( item . GetHex ( ) ) ; } } obj . push_back ( Pair ( " txids " , transactions ) ) ; ret . push_back ( obj ) ; } } if ( fByAccounts ) { for ( map < string , tallyitem > :: iterator it = mapAccountTally . begin ( ) ; it != mapAccountTally . end ( ) ; ++ it ) { int64 nAmount = ( * it ) . second . nAmount ; int nConf = ( * it ) . second . nConf ; Object obj ; obj . push_back ( Pair ( " account " , ( * it ) . first ) ) ; obj . push_back ( Pair ( " amount " , ValueFromAmount ( nAmount ) ) ) ; obj . push_back ( Pair ( " confirmations " , ( nConf == std :: numeric_limits < int > :: max ( ) ? 0 : nConf ) ) ) ; ret . push_back ( obj ) ; } } return ret ; } Value listreceivedbyaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaddress ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \ n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \ n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ addresses ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \n " " ▁ ▁ \ " address\ " ▁ : ▁ receiving ▁ address \n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ address \n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ the ▁ address \n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included \n " " ▁ ▁ \ " txids\ " ▁ : ▁ list ▁ of ▁ transactions ▁ with ▁ outputs ▁ to ▁ the ▁ address \n " ) ; return ListReceived ( params , false ) ; } Value listreceivedbyaccount ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " listreceivedbyaccount ▁ [ minconf = 1 ] ▁ [ includeempty = false ] \n " " [ minconf ] ▁ is ▁ the ▁ minimum ▁ number ▁ of ▁ confirmations ▁ before ▁ payments ▁ are ▁ included . \n " " [ includeempty ] ▁ whether ▁ to ▁ include ▁ accounts ▁ that ▁ haven ' t ▁ received ▁ any ▁ payments . \ n " " Returns ▁ an ▁ array ▁ of ▁ objects ▁ containing : \ n " " ▁ ▁ \ " account\ " ▁ : ▁ the ▁ account ▁ of ▁ the ▁ receiving ▁ addresses \ n " " ▁ ▁ \ " amount\ " ▁ : ▁ total ▁ amount ▁ received ▁ by ▁ addresses ▁ with ▁ this ▁ account \ n " " ▁ ▁ \ " confirmations\ " ▁ : ▁ number ▁ of ▁ confirmations ▁ of ▁ the ▁ most ▁ recent ▁ transaction ▁ included " ) ; return ListReceived ( params , true ) ; } static void MaybePushAddress ( Object & entry , const CTxDestination & dest ) { CBitcoinAddress addr ; if ( addr . Set ( dest ) ) entry . push_back ( Pair ( " address " , addr . ToString ( ) ) ) ; } void ListTransactions ( const CWalletTx & wtx , const string & strAccount , int nMinDepth , bool fLong , Array & ret ) { int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( ! wtx . IsCoinStake ( ) && ( ! listSent . empty ( ) || nFee != 0 ) && ( fAllAccounts || strAccount == strSentAccount ) ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) { Object entry ; entry . push_back ( Pair ( " account " , strSentAccount ) ) ; MaybePushAddress ( entry , s . first ) ; entry . push_back ( Pair ( " category " , " send " ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( - s . second ) ) ) ; entry . push_back ( Pair ( " fee " , ValueFromAmount ( - nFee ) ) ) ; if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } } if ( listReceived . size ( ) > 0 && wtx . GetDepthInMainChain ( ) >= nMinDepth ) { bool stop = false ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) { string account ; if ( pwalletMain -> mapAddressBook . count ( r . first ) ) account = pwalletMain -> mapAddressBook [ r . first ] ; if ( fAllAccounts || ( account == strAccount ) ) { Object entry ; entry . push_back ( Pair ( " account " , account ) ) ; MaybePushAddress ( entry , r . first ) ; if ( wtx . IsCoinBase ( ) || wtx . IsCoinStake ( ) ) { if ( wtx . GetDepthInMainChain ( ) < 1 ) entry . push_back ( Pair ( " category " , " orph@@ an " ) ) ; else if ( wtx . GetBlocksToMaturity ( ) > 0 ) entry . push_back ( Pair ( " category " , " immature " ) ) ; else if ( wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " category " , " stake " ) ) ; else entry . push_back ( Pair ( " category " , " generate " ) ) ; } else { entry . push_back ( Pair ( " category " , " receive " ) ) ; } if ( ! wtx . IsCoinStake ( ) ) entry . push_back ( Pair ( " amount " , ValueFromAmount ( r . second ) ) ) ; else { entry . push_back ( Pair ( " amount " , ValueFromAmount ( - nFee ) ) ) ; stop = true ; } if ( fLong ) WalletTxToJSON ( wtx , entry ) ; ret . push_back ( entry ) ; } if ( stop ) break ; } } } void AcentryToJSON ( const CAccountingEntry & acentry , const string & strAccount , Array & ret ) { bool fAllAccounts = ( strAccount == string ( " * " ) ) ; if ( fAllAccounts || acentry . strAccount == strAccount ) { Object entry ; entry . push_back ( Pair ( " account " , acentry . strAccount ) ) ; entry . push_back ( Pair ( " category " , " move " ) ) ; entry . push_back ( Pair ( " time " , ( boost :: int64_t ) acentry . nTime ) ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( acentry . nCreditDebit ) ) ) ; entry . push_back ( Pair ( " otheraccount " , acentry . strOtherAccount ) ) ; entry . push_back ( Pair ( " comment " , acentry . strComment ) ) ; ret . push_back ( entry ) ; } } Value listtransactions ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 3 ) throw runtime_error ( " listtransactions ▁ [ account ] ▁ [ count = 10 ] ▁ [ from = 0 ] \ n " " Returns ▁ up ▁ to ▁ [ count ] ▁ most ▁ recent ▁ transactions ▁ skipp@@ ing ▁ the ▁ first ▁ [ from ] ▁ transactions ▁ for ▁ account ▁ [ account ] . " ) ; string strAccount = " * " ; if ( params . size ( ) > 0 ) strAccount = params [ 0 ] . get_str ( ) ; int nCount = 10 ; if ( params . size ( ) > 1 ) nCount = params [ 1 ] . get_int ( ) ; int nFrom = 0 ; if ( params . size ( ) > 2 ) nFrom = params [ 2 ] . get_int ( ) ; if ( nCount < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ count " ) ; if ( nFrom < 0 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Negative ▁ from " ) ; Array ret ; std :: list < CAccountingEntry > acentries ; CWallet :: TxItems txOrdered = pwalletMain -> OrderedTxItems ( acentries , strAccount ) ; for ( CWallet :: TxItems :: reverse_iterator it = txOrdered . rbegin ( ) ; it != txOrdered . rend ( ) ; ++ it ) { CWalletTx * const pwtx = ( * it ) . second . first ; if ( pwtx != 0 ) ListTransactions ( * pwtx , strAccount , 0 , true , ret ) ; CAccountingEntry * const pacentry = ( * it ) . second . second ; if ( pacentry != 0 ) AcentryToJSON ( * pacentry , strAccount , ret ) ; if ( ( int ) ret . size ( ) >= ( nCount + nFrom ) ) break ; } if ( nFrom > ( int ) ret . size ( ) ) nFrom = ret . size ( ) ; if ( ( nFrom + nCount ) > ( int ) ret . size ( ) ) nCount = ret . size ( ) - nFrom ; Array :: iterator first = ret . begin ( ) ; std :: advance ( first , nFrom ) ; Array :: iterator last = ret . begin ( ) ; std :: advance ( last , nFrom + nCount ) ; if ( last != ret . end ( ) ) ret . erase ( last , ret . end ( ) ) ; if ( first != ret . begin ( ) ) ret . erase ( ret . begin ( ) , first ) ; std :: reverse ( ret . begin ( ) , ret . end ( ) ) ; return ret ; } Value listaccounts ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 1 ) throw runtime_error ( " listaccounts ▁ [ minconf = 1 ] \ n " " Returns ▁ Object ▁ that ▁ has ▁ account ▁ names ▁ as ▁ keys , ▁ account ▁ balances ▁ as ▁ values . " ) ; int nMinDepth = 1 ; if ( params . size ( ) > 0 ) nMinDepth = params [ 0 ] . get_int ( ) ; map < string , int64 > mapAccountBalances ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , string ) & entry , pwalletMain -> mapAddressBook ) { if ( IsMine ( * pwalletMain , entry . first ) ) mapAccountBalances [ entry . second ] = 0 ; } for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; int64 nFee ; string strSentAccount ; list < pair < CTxDestination , int64 > > listReceived ; list < pair < CTxDestination , int64 > > listSent ; wtx . GetAmounts ( listReceived , listSent , nFee , strSentAccount ) ; mapAccountBalances [ strSentAccount ] -= nFee ; BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & s , listSent ) mapAccountBalances [ strSentAccount ] -= s . second ; if ( wtx . GetDepthInMainChain ( ) >= nMinDepth ) { BOOST_FOREACH ( const PAIRTYPE ( CTxDestination , int64 ) & r , listReceived ) if ( pwalletMain -> mapAddressBook . count ( r . first ) ) mapAccountBalances [ pwalletMain -> mapAddressBook [ r . first ] ] += r . second ; else mapAccountBalances [ " " ] += r . second ; } } list < CAccountingEntry > acentries ; CWalletDB ( pwalletMain -> strWalletFile ) . ListAccountCreditDebit ( " * " , acentries ) ; BOOST_FOREACH ( const CAccountingEntry & entry , acentries ) mapAccountBalances [ entry . strAccount ] += entry . nCreditDebit ; Object ret ; BOOST_FOREACH ( const PAIRTYPE ( string , int64 ) & accountBalance , mapAccountBalances ) { ret . push_back ( Pair ( accountBalance . first , ValueFromAmount ( accountBalance . second ) ) ) ; } return ret ; } Value listsinceblock ( const Array & params , bool fHelp ) { if ( fHelp ) throw runtime_error ( " listsinceblock ▁ [ blockhash ] ▁ [ target - confirmations ] \ n " " Get ▁ all ▁ transactions ▁ in ▁ blocks ▁ since ▁ block ▁ [ blockhash ] , ▁ or ▁ all ▁ transactions ▁ if ▁ omit@@ ted " ) ; CBlockIndex * pindex = NULL ; int target_confirms = 1 ; if ( params . size ( ) > 0 ) { uint256 blockId = 0 ; blockId . SetHex ( params [ 0 ] . get_str ( ) ) ; pindex = CBlock@@ Locator ( blockId ) . GetBlockIndex ( ) ; } if ( params . size ( ) > 1 ) { target_confirms = params [ 1 ] . get_int ( ) ; if ( target_confirms < 1 ) throw JSONRPCError ( RPC_INVALID_PARAMETER , " Invalid ▁ parameter " ) ; } int depth = pindex ? ( 1 + nBestHeight - pindex -> nHeight ) : - 1 ; Array transactions ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; it ++ ) { CWalletTx tx = ( * it ) . second ; if ( depth == - 1 || tx . GetDepthInMainChain ( ) < depth ) ListTransactions ( tx , " * " , 0 , true , transactions ) ; } uint256 lastblock ; if ( target_confirms == 1 ) { lastblock = hashBestChain ; } else { int target_height = pindexBest -> nHeight + 1 - target_confirms ; CBlockIndex * block ; for ( block = pindexBest ; block && block -> nHeight > target_height ; block = block -> pprev ) { } lastblock = block ? block -> GetBlockHash ( ) : 0 ; } Object ret ; ret . push_back ( Pair ( " transactions " , transactions ) ) ; ret . push_back ( Pair ( " lastblock " , lastblock . GetHex ( ) ) ) ; return ret ; } Value gettransaction ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " gettransaction ▁ < txid > \ n " " Get ▁ detailed ▁ information ▁ about ▁ in - wallet ▁ transaction ▁ < txid > " ) ; uint256 hash ; hash . SetHex ( params [ 0 ] . get_str ( ) ) ; Object entry ; if ( ! pwalletMain -> mapWallet . count ( hash ) ) throw JSONRPCError ( RPC_INVALID_ADDRESS_OR_KEY , " Invalid ▁ or ▁ non - wallet ▁ transaction ▁ id " ) ; const CWalletTx & wtx = pwalletMain -> mapWallet [ hash ] ; int64 nCredit = wtx . GetCredit ( ) ; int64 nDebit = wtx . GetDebit ( ) ; int64 nNet = nCredit - nDebit ; int64 nFee = ( wtx . IsFromMe ( ) ? wtx . GetValueOut ( ) - nDebit : 0 ) ; entry . push_back ( Pair ( " amount " , ValueFromAmount ( nNet - nFee ) ) ) ; if ( wtx . IsFromMe ( ) ) entry . push_back ( Pair ( " fee " , ValueFromAmount ( nFee ) ) ) ; WalletTxToJSON ( wtx , entry ) ; Array details ; ListTransactions ( wtx , " * " , 0 , false , details ) ; entry . push_back ( Pair ( " details " , details ) ) ; return entry ; } Value backupwallet ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " backupwallet ▁ < destination > \ n " " Safely ▁ copies ▁ wallet . dat ▁ to ▁ destination , ▁ which ▁ can ▁ be ▁ a ▁ directory ▁ or ▁ a ▁ path ▁ with ▁ filename . " ) ; string strDest = params [ 0 ] . get_str ( ) ; if ( ! BackupWallet ( * pwalletMain , strDest ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error : ▁ Wallet ▁ backup ▁ failed ! " ) ; return Value :: null ; } Value keypoolrefill ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " keypoolrefill \ n " " Fills ▁ the ▁ keypool . " + HelpRequiringPassphrase ( ) ) ; EnsureWalletIsUnlocked ( ) ; pwalletMain -> TopUpKeyPool ( ) ; if ( pwalletMain -> GetKeyPoolSize ( ) < GetArg ( " - keypool " , 100 ) ) throw JSONRPCError ( RPC_WALLET_ERROR , " Error ▁ refreshing ▁ keypool . " ) ; return Value :: null ; } void ThreadTopUpKeyPool ( void * parg ) { RenameThread ( " iloveyoucoins - key - top " ) ; pwalletMain -> TopUpKeyPool ( ) ; } void ThreadCleanWalletPassphrase ( void * parg ) { RenameThread ( " iloveyoucoins - lock - wa " ) ; int64 nMyWakeTime = GetTimeMillis ( ) + * ( ( int64 * ) parg ) * 1000 ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; if ( nWalletUnlockTime == 0 ) { nWalletUnlockTime = nMyWakeTime ; do { if ( nWalletUnlockTime == 0 ) break ; int64 nToSleep = nWalletUnlockTime - GetTimeMillis ( ) ; if ( nToSleep <= 0 ) break ; LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; MilliSleep ( nToSleep ) ; ENTER_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; } while ( 1 ) ; if ( nWalletUnlockTime ) { nWalletUnlockTime = 0 ; pwalletMain -> Lock ( ) ; } } else { if ( nWalletUnlockTime < nMyWakeTime ) nWalletUnlockTime = nMyWakeTime ; } LEAVE_CRITICAL_SECTION ( cs_nWalletUnlockTime ) ; delete ( int64 * ) parg ; } Value walletpassphrase ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) < 2 || params . size ( ) > 3 ) ) throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > ▁ [ stakingonly ] \ n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . \ n " " if ▁ [ stakingonly ] ▁ is ▁ true ▁ sending ▁ functions ▁ are ▁ disable@@ d . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrase ▁ was ▁ called . " ) ; if ( ! pwalletMain -> IsLocked ( ) ) throw JSONRPCError ( RPC_WALLET_ALREADY_UNLOCKE@@ D , " Error : ▁ Wallet ▁ is ▁ already ▁ unlocked . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) > 0 ) { if ( ! pwalletMain -> Unlock ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; } else throw runtime_error ( " walletpassphrase ▁ < passphrase > ▁ < timeout > \ n " " Stores ▁ the ▁ wallet ▁ decryption ▁ key ▁ in ▁ memory ▁ for ▁ < timeout > ▁ seconds . " ) ; NewThread ( ThreadTopUpKeyPool , NULL ) ; int64 * pnSleepTime = new int64 ( params [ 1 ] . get_int64 ( ) ) ; NewThread ( ThreadCleanWalletPassphrase , pnSleepTime ) ; if ( params . size ( ) > 2 ) fWalletUnlockStakingOnly = params [ 2 ] . get_bool ( ) ; else fWalletUnlockStakingOnly = false ; return Value :: null ; } Value walletpassphrasechange ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 2 ) ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \ n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletpassphrasechange ▁ was ▁ called . " ) ; SecureString strOldWalletPass ; strOldWalletPass . reserve ( 100 ) ; strOldWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; SecureString strNewWalletPass ; strNewWalletPass . reserve ( 100 ) ; strNewWalletPass = params [ 1 ] . get_str ( ) . c_str ( ) ; if ( strOldWalletPass . length ( ) < 1 || strNewWalletPass . length ( ) < 1 ) throw runtime_error ( " walletpassphrasechange ▁ < oldpassphrase > ▁ < newpassphrase > \ n " " Changes ▁ the ▁ wallet ▁ passphrase ▁ from ▁ < oldpassphrase > ▁ to ▁ < newpassphrase > . " ) ; if ( ! pwalletMain -> ChangeWalletPassphrase ( strOldWalletPass , strNewWalletPass ) ) throw JSONRPCError ( RPC_WALLET_PASSPHRASE_INCORRECT , " Error : ▁ The ▁ wallet ▁ passphrase ▁ entered ▁ was ▁ incorrect . " ) ; return Value :: null ; } Value walletlock ( const Array & params , bool fHelp ) { if ( pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 0 ) ) throw runtime_error ( " walletlock \ n " " Removes ▁ the ▁ wallet ▁ encrypt@@ ion ▁ key ▁ from ▁ memory , ▁ locking ▁ the ▁ wallet . \ n " " After ▁ calling ▁ this ▁ method , ▁ you ▁ will ▁ need ▁ to ▁ call ▁ walletpassphrase ▁ again \ n " " before ▁ being ▁ able ▁ to ▁ call ▁ any ▁ methods ▁ which ▁ require ▁ the ▁ wallet ▁ to ▁ be ▁ unlocked . " ) ; if ( fHelp ) return true ; if ( ! pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ unencrypted ▁ wallet , ▁ but ▁ walletlock ▁ was ▁ called . " ) ; { LOCK ( cs_nWalletUnlockTime ) ; pwalletMain -> Lock ( ) ; nWalletUnlockTime = 0 ; } return Value :: null ; } Value encryptwallet ( const Array & params , bool fHelp ) { if ( ! pwalletMain -> IsCrypted ( ) && ( fHelp || params . size ( ) != 1 ) ) throw runtime_error ( " encryptwallet ▁ < passphrase > \ n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( fHelp ) return true ; if ( pwalletMain -> IsCrypted ( ) ) throw JSONRPCError ( RPC_WALLET_WRONG_ENC_STATE , " Error : ▁ running ▁ with ▁ an ▁ encrypted ▁ wallet , ▁ but ▁ encryptwallet ▁ was ▁ called . " ) ; SecureString strWalletPass ; strWalletPass . reserve ( 100 ) ; strWalletPass = params [ 0 ] . get_str ( ) . c_str ( ) ; if ( strWalletPass . length ( ) < 1 ) throw runtime_error ( " encryptwallet ▁ < passphrase > \ n " " Encrypts ▁ the ▁ wallet ▁ with ▁ < passphrase > . " ) ; if ( ! pwalletMain -> Encrypt@@ Wallet ( strWalletPass ) ) throw JSONRPCError ( RPC_WALLET_ENCRYP@@ TION_FAILED , " Error : ▁ Failed ▁ to ▁ encr@@ ypt ▁ the ▁ wallet . " ) ; StartShutdown ( ) ; return " wallet ▁ encrypted ; ▁ ILoveYouCoins ▁ server ▁ stopping , ▁ restart ▁ to ▁ run ▁ with ▁ encrypted ▁ wallet . ▁ The ▁ keypool ▁ has ▁ been ▁ flush@@ ed , ▁ you ▁ need ▁ to ▁ make ▁ a ▁ new ▁ backup . " ; } class DescribeAddressVisitor : public boost :: static_visitor < Object > { public : Object operator ( ) ( const CNo@@ Destination & dest ) const { return Object ( ) ; } Object operator ( ) ( const CKeyID & keyID ) const { Object obj ; CPubKey vchPubKey ; pwalletMain -> GetPubKey ( keyID , vchPubKey ) ; obj . push_back ( Pair ( " isscript " , false ) ) ; obj . push_back ( Pair ( " pubkey " , HexStr ( vchPubKey ) ) ) ; obj . push_back ( Pair ( " iscomp@@ ressed " , vchPubKey . IsCompressed ( ) ) ) ; return obj ; } Object operator ( ) ( const CScriptID & scriptID ) const { Object obj ; obj . push_back ( Pair ( " isscript " , true ) ) ; CScript subscript ; pwalletMain -> GetCScript ( scriptID , subscript ) ; std :: vector < CTxDestination > addresses ; txnouttype whichType ; int nRequired ; ExtractDestinations ( subscript , whichType , addresses , nRequired ) ; obj . push_back ( Pair ( " script " , GetTxn@@ OutputType ( whichType ) ) ) ; Array a ; BOOST_FOREACH ( const CTxDestination & addr , addresses ) a . push_back ( CBitcoinAddress ( addr ) . ToString ( ) ) ; obj . push_back ( Pair ( " addresses " , a ) ) ; if ( whichType == TX_MULTISIG ) obj . push_back ( Pair ( " sig@@ srequired " , nRequired ) ) ; return obj ; } } ; Value validateaddress ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) != 1 ) throw runtime_error ( " validateaddress ▁ < iloveyoucoinsaddress > \ n " " Return ▁ information ▁ about ▁ < iloveyoucoinsaddress > . " ) ; CBitcoinAddress address ( params [ 0 ] . get_str ( ) ) ; bool isValid = address . IsValid ( ) ; Object ret ; ret . push_back ( Pair ( " isvalid " , isValid ) ) ; if ( isValid ) { CTxDestination dest = address . Get ( ) ; string currentAddress = address . ToString ( ) ; ret . push_back ( Pair ( " address " , currentAddress ) ) ; bool fMine = pwalletMain ? IsMine ( * pwalletMain , dest ) : false ; ret . push_back ( Pair ( " ismine " , fMine ) ) ; if ( fMine ) { Object detail = boost :: apply_visitor ( DescribeAddressVisitor ( ) , dest ) ; ret . insert ( ret . end ( ) , detail . begin ( ) , detail . end ( ) ) ; } if ( pwalletMain && pwalletMain -> mapAddressBook . count ( dest ) ) ret . push_back ( Pair ( " account " , pwalletMain -> mapAddressBook [ dest ] ) ) ; } return ret ; } Value reservebalance ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " reservebalance ▁ [ < reserve > ▁ [ amount ] ] \ n " " < reserve > ▁ is ▁ true ▁ or ▁ false ▁ to ▁ turn ▁ balance ▁ reserve ▁ on ▁ or ▁ off . \ n " " < amount > ▁ is ▁ a ▁ real ▁ and ▁ rounded ▁ to ▁ cent . \ n " " Set ▁ reserve ▁ amount ▁ not ▁ partic@@ ipating ▁ in ▁ network ▁ protection . \ n " " If ▁ no ▁ parameters ▁ provided ▁ current ▁ setting ▁ is ▁ printed . \ n " ) ; if ( params . size ( ) > 0 ) { bool fReserve = params [ 0 ] . get_bool ( ) ; if ( fReserve ) { if ( params . size ( ) == 1 ) throw runtime_error ( " must ▁ provi@@ de ▁ amount ▁ to ▁ reserve ▁ balance . \ n " ) ; int64 nAmount = AmountFromValue ( params [ 1 ] ) ; nAmount = ( nAmount / CENT ) * CENT ; if ( nAmount < 0 ) throw runtime_error ( " amount ▁ cannot ▁ be ▁ negative . \ n " ) ; nReserveBalance = nAmount ; } else { if ( params . size ( ) > 1 ) throw runtime_error ( " cannot ▁ specify ▁ amount ▁ to ▁ turn ▁ off ▁ reserve . \ n " ) ; nReserveBalance = 0 ; } } Object result ; result . push_back ( Pair ( " reserve " , ( nReserveBalance > 0 ) ) ) ; result . push_back ( Pair ( " amount " , ValueFromAmount ( nReserveBalance ) ) ) ; return result ; } Value getinterest ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 2 ) throw runtime_error ( " getinterest ▁ [ start ] ▁ [ end ] \ n " " Both ▁ [ start ] ▁ and ▁ [ end ] ▁ are ▁ inclusive ▁ and ▁ in ▁ the ▁ form ▁ of ▁ UNIX ▁ timestamp@@ s . " ) ; unsigned int nTimeStart = 0 ; unsigned int nTimeEnd = - 1 ; if ( params . size ( ) >= 1 ) nTimeStart = ( unsigned int ) ( params [ 0 ] . get_int ( ) ) ; if ( params . size ( ) == 2 ) nTimeEnd = ( unsigned int ) ( params [ 1 ] . get_int ( ) ) ; int64 nInterest = 0 ; for ( map < uint256 , CWalletTx > :: iterator it = pwalletMain -> mapWallet . begin ( ) ; it != pwalletMain -> mapWallet . end ( ) ; ++ it ) { const CWalletTx & wtx = ( * it ) . second ; if ( ! wtx . IsCoinStake ( ) || wtx . nTime < nTimeStart || wtx . nTime > nTimeEnd ) continue ; int64 nDebit = wtx . GetDebit ( ) ; int64 nCredit = wtx . GetCredit ( ) ; if ( nDebit <= 0 || nCredit <= 0 || nDebit >= nCredit ) continue ; else nInterest += nCredit - nDebit ; } return ValueFromAmount ( nInterest ) ; } Value lockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) < 1 || params . size ( ) > 2 ) throw runtime_error ( " lockunspent ▁ unlock ? ▁ [ array - of - Objects ] \ n " " Updates ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; if ( params . size ( ) == 1 ) RPCTypeCheck ( params , list_of ( bool_type ) ) ; else RPCTypeCheck ( params , list_of ( bool_type ) ( array_type ) ) ; bool fUnlock = params [ 0 ] . get_bool ( ) ; if ( params . size ( ) == 1 ) { if ( fUnlock ) pwalletMain -> UnlockAllCoins ( ) ; return true ; } Array outputs = params [ 1 ] . get_array ( ) ; BOOST_FOREACH ( Value & output , outputs ) { if ( output . type ( ) != obj_type ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ object " ) ; const Object & o = output . get_obj ( ) ; RPCTypeCheck ( o , map_list_of ( " txid " , str_type ) ( " vout " , int_type ) ) ; string txid = find_value ( o , " txid " ) . get_str ( ) ; if ( ! IsHex ( txid ) ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ expected ▁ hex ▁ txid " ) ; int nOutput = find_value ( o , " vout " ) . get_int ( ) ; if ( nOutput < 0 ) throw JSONRPCError ( - 8 , " Invalid ▁ parameter , ▁ vout ▁ must ▁ be ▁ positive " ) ; COutPoint outpt ( uint256 ( txid ) , nOutput ) ; if ( fUnlock ) pwalletMain -> UnlockCoin ( outpt ) ; else pwalletMain -> LockCoin ( outpt ) ; } return true ; } Value listlockunspent ( const Array & params , bool fHelp ) { if ( fHelp || params . size ( ) > 0 ) throw runtime_error ( " listlockunspent \ n " " Returns ▁ list ▁ of ▁ temporarily ▁ unspendable ▁ outputs . " ) ; vector < COutPoint > vOutpts ; pwalletMain -> ListLocked@@ Coins ( vOutpts ) ; Array ret ; BOOST_FOREACH ( COutPoint & outpt , vOutpts ) { Object o ; o . push_back ( Pair ( " txid " , outpt . hash . GetHex ( ) ) ) ; o . push_back ( Pair ( " vout " , ( int ) outpt . n ) ) ; ret . push_back ( o ) ; } return ret ; } </DOCUMENT>
