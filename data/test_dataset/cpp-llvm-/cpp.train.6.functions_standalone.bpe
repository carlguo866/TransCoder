int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; }
KURL soupURI@@ ToKURL ( Soup@@ URI * soupURI ) { GOwnPtr < gchar > urlString ( soup_ur@@ i_to_string ( soupURI , FALSE ) ) ; KURL url ( KURL ( ) , String :: fromUTF8 ( urlString . get ( ) ) ) ; if ( ! soupURI -> password ) return url ; url . setPass ( String :: fromUTF8 ( soupURI -> password ) ) ; return url ; }
BOOST_AUTO_TEST_SUITE ( rpc_@@ tests ) static Array createArgs ( int nRequired , const char * address1 = NULL , const char * address2 = NULL ) { Array result ; result . push_back ( nRequired ) ; Array addresses ; if ( address1 ) addresses . push_back ( address1 ) ; if ( address2 ) addresses . push_back ( address1 ) ; result . push_back ( addresses ) ; return result ; }
TestNetFixture ( ) { fTestNet = true ; }
~ TestNetFixture ( ) { fTestNet = false ; }
BOOST_FIXTURE_@@ TEST_CASE ( rpc_@@ addmultisig , TestNetFixture ) { rpcf@@ n_type addmultisig = tableRPC [ " addmultisigaddress " ] -> actor ; const char * address1Hex = "04@@ 34e3@@ e09@@ f49@@ ea168c5@@ bbf53@@ f8@@ 77ff420@@ 69238@@ 58aab@@ 7c@@ 7e1@@ df25bc@@ 2639781@@ 07c95@@ e35@@ 065a27@@ ef6@@ f1b27@@ 222db0@@ ec97@@ e0e89@@ 5eac@@ a60@@ 3d3ee@@ 0d4@@ c060@@ ce3d@@ 8a00@@ 286c8" ; const char * address2Hex = "0388@@ c20@@ 37017c6@@ 2240b6@@ b72@@ ac1a2@@ a5f@@ 94da@@ 790596ebd06@@ 177c@@ 857275@@ 292216@@ 5cb@@ 4" ; Value v ; CBitcoinAddress address ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 2 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 0 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , address1Hex ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " " ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " NotAValid@@ Pubkey " ) , false ) , runtime_error ) ; string short1 ( address1Hex , address1Hex + sizeof ( address1Hex ) - 2 ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short1 . c_str ( ) ) , false ) , runtime_error ) ; string short2 ( address1Hex + 2 , address1Hex + sizeof ( address1Hex ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short2 . c_str ( ) ) , false ) , runtime_error ) ; }
int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc@@ 0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; }
int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; }
int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunk@@ Metadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; }
const QualifiedName & pseudoElementTagName ( PseudoId pseudoId ) { switch ( pseudoId ) { case AFTER : { DEFINE_STATIC_LOCAL ( QualifiedName , after , ( nullAtom , " < pseudo : after > " , nullAtom ) ) ; return after ; } case BEFORE : { DEFINE_STATIC_LOCAL ( QualifiedName , before , ( nullAtom , " < pseudo : before > " , nullAtom ) ) ; return before ; } case BACK@@ DROP : { DEFINE_STATIC_LOCAL ( QualifiedName , backdrop , ( nullAtom , " < pseudo : backdrop > " , nullAtom ) ) ; return backdrop ; } default : { ASSERT_NOT_REACHED ( ) ; } } DEFINE_STATIC_LOCAL ( QualifiedName , name , ( nullAtom , " < pseudo > " , nullAtom ) ) ; return name ; }
int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhand@@ led ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } }
int System_Get@@ PropertyInt ( SystemProperty prop ) { return - 1 ; }
float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .35@@ 7214248@@ 0f + .108@@ 706@@ 3463f * x ; y = y * x + 1.06@@ 25192@@ 36f ; y = y * x + - 2.5112@@ 7850@@ 6f ; y = y * x + .19@@ 1900116@@ f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615@@ 1950@@ 94 * x ) ; return sign * ( y - sqrtthing ) ; }
double atan_66s ( double x ) { const double c1 = 1.68676@@ 2910@@ 6 ; const double c2 = 0.4@@ 378497304 ; const double c3 = 1.68676@@ 33134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; }
double fastasin@@ 2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; }
float fastasin@@ 3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; }
float fastasin@@ 4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.57072@@ 88 + - 0.21211@@ 44 * x + 0.07426@@ 10 * x * x + - 0.0187@@ 293 * x * x * x ) ; return sign * x ; }
float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.07426@@ 10f + - 0.0187@@ 293f * x ; fResult = - 0.21211@@ 44f + fResult * x ; fResult = 1.57072@@ 88f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; }
void reset ( ) { fSyllableCount += 1 ; }
void writeChar ( LEUnicode ch , le_uint32 charIndex , FeatureMask featureMask ) { LEErrorCode success = LE_NO_ERROR ; fOutChars [ fOutIndex ] = ch ; fGlyphStorage . setChar@@ Index ( fOutIndex , charIndex , success ) ; fGlyphStorage . setAu@@ xData ( fOutIndex , featureMask , success ) ; fOutIndex += 1 ; }
le_int32 getOutputIndex ( ) { return fOutIndex ; }
void initIDT ( ) { memset ( ( uint8 * ) idtEntries , 0 , sizeof ( idtEntries ) ) ; iptr . limit = sizeof ( idtEntries ) - 1 ; iptr . base = ( uint64 ) & idtEntries ; writePort ( 0x20 , 0x11 ) ; writePort ( 0xA0 , 0x11 ) ; writePort ( 0x21 , 0x20 ) ; writePort ( 0xA1 , 0x28 ) ; writePort ( 0x21 , 0x01 ) ; writePort ( 0xA1 , 0x01 ) ; writePort ( 0x21 , 0x00 ) ; writePort ( 0xA1 , 0x00 ) ; idtSetEntity ( 0 , ( uint64 ) isr0 , 0x08 , 0x8E ) ; idtSetEntity ( 1 , ( uint64 ) isr1 , 0x08 , 0x8E ) ; idtSetEntity ( 2 , ( uint64 ) isr2 , 0x08 , 0x8E ) ; idtSetEntity ( 3 , ( uint64 ) isr3 , 0x08 , 0x8E ) ; idtSetEntity ( 4 , ( uint64 ) isr4 , 0x08 , 0x8E ) ; idtSetEntity ( 5 , ( uint64 ) isr5 , 0x08 , 0x8E ) ; idtSetEntity ( 6 , ( uint64 ) isr6 , 0x08 , 0x8E ) ; idtSetEntity ( 7 , ( uint64 ) isr7 , 0x08 , 0x8E ) ; idtSetEntity ( 8 , ( uint64 ) isr8 , 0x08 , 0x8E ) ; idtSetEntity ( 9 , ( uint64 ) isr9 , 0x08 , 0x8E ) ; idtSetEntity ( 10 , ( uint64 ) isr10 , 0x08 , 0x8E ) ; idtSetEntity ( 11 , ( uint64 ) isr11 , 0x08 , 0x8E ) ; idtSetEntity ( 12 , ( uint64 ) isr12 , 0x08 , 0x8E ) ; idtSetEntity ( 13 , ( uint64 ) isr13 , 0x08 , 0x8E ) ; idtSetEntity ( 14 , ( uint64 ) isr14 , 0x08 , 0x8E ) ; idtSetEntity ( 15 , ( uint64 ) isr15 , 0x08 , 0x8E ) ; idtSetEntity ( 16 , ( uint64 ) isr16 , 0x08 , 0x8E ) ; idtSetEntity ( 17 , ( uint64 ) isr17 , 0x08 , 0x8E ) ; idtSetEntity ( 18 , ( uint64 ) isr18 , 0x08 , 0x8E ) ; idtSetEntity ( 19 , ( uint64 ) isr19 , 0x08 , 0x8E ) ; idtSetEntity ( 20 , ( uint64 ) isr20 , 0x08 , 0x8E ) ; idtSetEntity ( 21 , ( uint64 ) isr21 , 0x08 , 0x8E ) ; idtSetEntity ( 22 , ( uint64 ) isr22 , 0x08 , 0x8E ) ; idtSetEntity ( 23 , ( uint64 ) isr23 , 0x08 , 0x8E ) ; idtSetEntity ( 24 , ( uint64 ) isr24 , 0x08 , 0x8E ) ; idtSetEntity ( 25 , ( uint64 ) isr25 , 0x08 , 0x8E ) ; idtSetEntity ( 26 , ( uint64 ) isr26 , 0x08 , 0x8E ) ; idtSetEntity ( 27 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 28 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 29 , ( uint64 ) isr29 , 0x08 , 0x8E ) ; idtSetEntity ( 30 , ( uint64 ) isr30 , 0x08 , 0x8E ) ; idtSetEntity ( 31 , ( uint64 ) isr31 , 0x08 , 0x8E ) ; idtSetEntity ( 32 , ( uint64 ) irq0 , 0x08 , 0x8E ) ; idtSetEntity ( 33 , ( uint64 ) irq1 , 0x08 , 0x8E ) ; idtSetEntity ( 34 , ( uint64 ) irq2 , 0x08 , 0x8E ) ; idtSetEntity ( 35 , ( uint64 ) irq3 , 0x08 , 0x8E ) ; idtSetEntity ( 36 , ( uint64 ) irq4 , 0x08 , 0x8E ) ; idtSetEntity ( 37 , ( uint64 ) irq5 , 0x08 , 0x8E ) ; idtSetEntity ( 38 , ( uint64 ) irq6 , 0x08 , 0x8E ) ; idtSetEntity ( 39 , ( uint64 ) irq7 , 0x08 , 0x8E ) ; idtSetEntity ( 40 , ( uint64 ) irq8 , 0x08 , 0x8E ) ; idtSetEntity ( 41 , ( uint64 ) irq9 , 0x08 , 0x8E ) ; idtSetEntity ( 42 , ( uint64 ) irq10 , 0x08 , 0x8E ) ; idtSetEntity ( 43 , ( uint64 ) irq11 , 0x08 , 0x8E ) ; idtSetEntity ( 44 , ( uint64 ) irq12 , 0x08 , 0x8E ) ; idtSetEntity ( 45 , ( uint64 ) irq13 , 0x08 , 0x8E ) ; idtSetEntity ( 46 , ( uint64 ) irq14 , 0x08 , 0x8E ) ; idtSetEntity ( 47 , ( uint64 ) irq15 , 0x08 , 0x8E ) ; idtFlush ( ( uint64 ) & iptr ) ; printStr ( " Initializing ▁ interruption ▁ finished . \n " , color_@@ white ) ; }
void isrHandler ( ptRegs * regs ) { if ( interruptHandler [ regs -> intNum ] ) interruptHandler [ regs -> intNum ] ( regs ) ; else { } }
void irqHandler ( ptRegs * regs ) { if ( regs -> intNum > 40 ) { writePort ( 0xA0 , 0x20 ) ; } writePort ( 0x20 , 0x20 ) ; if ( interruptHandler [ regs -> intNum ] ) { interruptHandler [ regs -> intNum ] ( regs ) ; } }
void registerInterrupt@@ Handler ( uint8 n , interruptHandler_t h ) { interruptHandler [ n ] = h ; }
void idtSetEntity ( uint8 num , uint64 base , uint16 selector , uint8 flags ) { idtEntries [ num ] . offset1 = base & 0xffff ; idtEntries [ num ] . offset2 = ( base >> 16 ) & 0xffff ; idtEntries [ num ] . offset3 = ( base >> 32 ) & 0xffffffff ; idtEntries [ num ] . selector = selector ; idtEntries [ num ] . typeAttr = flags ; }
int test_length_mat_non_squared ( ) { int Error = 0 ; Error += glm :: mat2x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat2x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3@@ x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat3@@ x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2@@ x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat2@@ x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3@@ x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat3@@ x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; }
int test_length_mat ( ) { int Error = 0 ; Error += glm :: mat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat2x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3@@ x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2@@ x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3@@ x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; }
int test_length_vec ( ) { int Error = 0 ; Error += glm :: vec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: vec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: vec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: ivec@@ 2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: ivec@@ 3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: ivec@@ 4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: uvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: uvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: uvec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dvec4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; }
int main ( ) { int Error = 0 ; Error += test_length_vec ( ) ; Error += test_length_mat ( ) ; Error += test_length_mat_non_squared ( ) ; return Error ; }
protected : PowerLayerTest ( ) : blob_bottom_ ( new Blob < Dtype > ( 2 , 3 , 4 , 5 ) ) , blob_top_ ( new Blob < Dtype > ( ) ) { Caffe :: set_random_@@ seed ( 1701 ) ; Filler@@ Parameter filler_param ; Gau@@ ssi@@ anFil@@ ler < Dtype > filler ( filler_param ) ; filler . Fill ( this -> blob_bottom_ ) ; blob_bottom_vec_ . push_back ( blob_bottom_ ) ; blob_top_vec_ . push_back ( blob_top_ ) ; }
virtual ~ PowerLayerTest ( ) { delete blob_bottom_ ; delete blob_top_ ; }
void TestForward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; layer . SetUp ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; layer . Forward ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; const Dtype * bottom_data = this -> blob_bottom_ -> cpu_data ( ) ; const Dtype * top_data = this -> blob_top_ -> cpu_data ( ) ; const Dtype min_precision = 1e - 5 ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { Dtype expected_value = pow ( shift + scale * bottom_data [ i ] , power ) ; if ( power == Dtype ( 0 ) || power == Dtype ( 1 ) || power == Dtype ( 2 ) ) { EXPECT_FALSE ( isnan ( top_data [ i ] ) ) ; } if ( isnan ( expected_value ) ) { EXPECT_TRUE ( isnan ( top_data [ i ] ) ) ; } else { Dtype precision = max ( Dtype ( abs ( expected_value * 0.0001 ) ) , min_precision ) ; EXPECT_NEAR ( expected_value , top_data [ i ] , precision ) ; } } }
void TestBackward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; if ( power != Dtype ( 0 ) && power != Dtype ( 1 ) && power != Dtype ( 2 ) ) { Dtype * bottom_data = this -> blob_bottom_ -> mutable_cpu_data ( ) ; Dtype min_value = - shift / scale ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { if ( bottom_data [ i ] < min_value ) { bottom_data [ i ] = min_value + ( min_value - bottom_data [ i ] ) ; } } } GradientChecker < Dtype > checker ( 1e - 2 , 1e - 2 , 1701 , 0. , 0.01 ) ; checker . CheckGradient@@ Eltw@@ ise ( & layer , & ( this -> blob_bottom_vec_ ) , & ( this -> blob_top_vec_ ) ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZero@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerZero@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerZero@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerOne@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerOne@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalf@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZero@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerZero@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerZero@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerOne@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerOne@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalf@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; }
bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D@@ 32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibration@@ Success@@ fulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: inv@@ Distortion@@ CoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translation@@ Key ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoad@@ Image ( fileName . toAs@@ cii ( ) , CV_LOAD_@@ IMA@@ GE_GRAY@@ SCAL@@ E ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarp@@ GroundPla@@ ne ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvClo@@ neImage ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; }
bool CheckMapping@@ IsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; }
bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; }
bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; }
bool CheckRoot@@ Mapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; }
void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } }
template < class RngT > void do_test_iterator_range_impl ( const RngT & rng ) { BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng . begin ( ) , rng . size ( ) ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng . begin ( ) , rng . size ( ) ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng . begin ( ) , rng . size ( ) ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # elif defined ( BOOST_HAS_@@ MS_@@ INT64 ) BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; }
template < class CharT > void test_it_range_using_any_chars ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( rng1 ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( crng1 ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( rng2 ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( crng2 ) ; }
template < class CharT > void test_it_range_using_char ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng1 ) , "1" ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng1 ) , "1" ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng2 ) , "1" ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng2 ) , "1" ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng1 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng1 ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng1 ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng1 ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( crng2 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( crng2 ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( crng2 ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( crng2 ) , 1 ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng2 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng2 ) == L " 1" ) ; && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char16_t > my_char16_string ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng2 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng2 ) == u " 1" ) ; && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char32_t > my_char32_string ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng2 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng2 ) == U " 1" ) ; }
void test_char_iterator_ranges ( ) { typedef char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; }
void test_unsigned_char_iterator_ranges ( ) { typedef unsigned char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; }
void test_signed_char_iterator_ranges ( ) { typedef signed char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; }
void test_wchar_iterator_ranges ( ) { typedef wchar_t test_char_type ; test_char_type data1 [ ] = L " 1" ; test_char_type data2 [ ] = L " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; BOOST_CHECK ( true ) ; }
void test_char16_iterator_ranges ( ) { typedef char16_t test_char_type ; test_char_type data1 [ ] = u " 1" ; test_char_type data2 [ ] = u " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; BOOST_CHECK ( true ) ; }
void test_char32_iterator_ranges ( ) { typedef char32_t test_char_type ; test_char_type data1 [ ] = U " 1" ; test_char_type data2 [ ] = U " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; BOOST_CHECK ( true ) ; }
clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_@@ CAPSUL@@ E ) { return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; }
void SV_Sector@@ List_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } }
worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; }
void SV_ClearWorld ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; }
void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; }
void SV_Link@@ Entity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; } if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOL@@ ID_BMODE@@ L ; } else if ( gEnt -> r . contents & ( CONTENTS_S@@ OLID | CONTENTS_@@ BODY ) ) { i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { float max ; int i ; max = Radi@@ usFrom@@ Bounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; num_leafs = CM_BoxLeaf@@ nums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; if ( ! num_leafs ) { return ; } for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_Leaf@@ Area ( leafs [ i ] ) ; if ( area != - 1 ) { if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_@@ LOAD@@ ING ) { Com_DPrintf ( " Object ▁ % i ▁ touch@@ ing ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLU@@ STERS ) { break ; } } } if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; } ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; }
void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_G@@ EntityFor@@ Sv@@ Entity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; } if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } }
int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; }
void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } }
void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { continue ; } } else { continue ; } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; } } if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_@@ NOSHOT ) ) ) { continue ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; oldTrace = clip -> trace ; if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2@@ API_@@ Collision@@ Detect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info@@ _v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2@@ VertSpace@@ Server , clip -> traceFlags , clip -> useLod ) ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } } }
void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_@@ WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; } clip . contentmask = contentmask ; VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; }
int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; contents = CM_PointContents ( p , 0 ) ; num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; } c2 = CM_Transformed@@ PointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; }
~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } }
void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } }
void DBFlush ( bool fShutdown ) { printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_arch@@ ive ( & listp , DB_ARCH_@@ REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } }
CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phash@@ Block = & ( ( * mi ) . first ) ; return pindexNew ; }
bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; }
void ThreadFlush@@ WalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflush@@ wallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_@@ CRITICAL_BLOCK ( cs_db ) { int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , Date@@ TimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } }
bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFile@@ Backed ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_@@ if_exists ) ; filesystem :: copy_file ( pathSrc , pathDest ) ; printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; }
