<DOCUMENT_ID="K@@ DE/ko@@ ffice@@ /tree/master/kcell@@ s/dialogs/@@ StyleManagerDialog.cpp"> # include " StyleManagerDialog . h " # include < QMap > # include < QTreeWidget > # include < QVBoxLayout > # include < kcombo@@ box . h > # include < kdebug . h > # include < klocale . h > # include " KCC@@ ell . h " # include " LayoutDialog . h " # include " ui / Selection . h " # include " KCSheet . h " # include " KCStyle . h " # include " KCStyleManager . h " # include " commands / KCStyleCommand . h " StyleManagerDialog :: StyleManagerDialog ( QWidget * parent , Selection * selection , KCStyleManager * manager ) : KDialog ( parent ) , m_selection ( selection ) , m_styleManager ( manager ) { setButtons ( Apply | User1 | User2 | User3 | Close ) ; setButtonText ( User3 , i18n ( " & New . . . " ) ) ; setButtonText ( User2 , i18n ( " & Modify . . . " ) ) ; setButtonText ( User1 , i18n ( " & Delete . . . " ) ) ; setButtonsOrientation ( Qt :: Vertical ) ; setCaption ( i18n ( " Style ▁ Manager " ) ) ; QWidget * widget = new QWidget ( this ) ; setMain@@ Widget ( widget ) ; QVBoxLayout * layout = new QVBoxLayout ( widget ) ; m_styleList = new QTreeWidget ( this ) ; m_styleList -> setHeader@@ Label ( i18n ( " Style " ) ) ; layout -> addWidget ( m_styleList ) ; m_displayBox = new KComboBox ( false , this ) ; m_displayBox -> insertItem ( 0 , i18n ( " All ▁ Styles " ) ) ; m_displayBox -> insertItem ( 1 , i18n ( " Custom ▁ Styles " ) ) ; m_displayBox -> insertItem ( 2 , i18n ( " Hierarch@@ ical " ) ) ; layout -> addWidget ( m_displayBox ) ; slotDisplayMode ( 0 ) ; enableButton ( KDialog :: User3 , true ) ; enableButton ( KDialog :: User2 , true ) ; enableButton ( KDialog :: User1 , false ) ; connect ( m_displayBox , SIGNAL ( activated ( int ) ) , this , SLOT ( slotDisplayMode ( int ) ) ) ; connect ( this , SIGNAL ( applyClicked ( ) ) , this , SLOT ( slotOk ( ) ) ) ; connect ( this , SIGNAL ( user3Clicked ( ) ) , this , SLOT ( slotNew ( ) ) ) ; connect ( this , SIGNAL ( user2Clicked ( ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( this , SIGNAL ( user1Clicked ( ) ) , this , SLOT ( slotRemove ( ) ) ) ; connect ( m_styleList , SIGNAL ( itemDoubleClicked ( QTreeWidgetItem * , int ) ) , this , SLOT ( slotEdit ( ) ) ) ; connect ( m_styleList , SIGNAL ( currentItem@@ Changed ( QTreeWidgetItem * , QTreeWidgetItem * ) ) , this , SLOT ( selectionChanged ( QTreeWidgetItem * ) ) ) ; } StyleManagerDialog :: ~ StyleManagerDialog ( ) { } void StyleManagerDialog :: fillComboBox ( ) { typedef QMap < KCCustomStyle * , QTreeWidgetItem * > KCMap ; KCMap entries ; entries . clear ( ) ; entries [ m_styleManager -> defaultStyle ( ) ] = new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: const_iterator iter = m_styleManager -> m_styles . constBegin ( ) ; CustomStyles :: const_iterator end = m_styleManager -> m_styles . constEnd ( ) ; while ( entries . count ( ) != m_styleManager -> m_styles . count ( ) + 1 ) { if ( entries . find ( iter . value ( ) ) == entries . end ( ) ) { if ( iter . value ( ) -> parentName ( ) . isNull ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( entries [ m_styleManager -> defaultStyle ( ) ] , QStringList ( iter . value ( ) -> name ( ) ) ) ; else { KCCustomStyle * parentStyle = m_styleManager -> style ( iter . value ( ) -> parentName ( ) ) ; if ( parentStyle ) { KCMap :: const_iterator i = entries . constFind ( parentStyle ) ; if ( i != entries . constEnd ( ) ) entries [ iter . value ( ) ] = new QTreeWidgetItem ( i . value ( ) , QStringList ( iter . value ( ) -> name ( ) ) ) ; } } } ++ iter ; if ( iter == end ) iter = m_styleManager -> m_styles . constBegin ( ) ; } entries . clear ( ) ; } void StyleManagerDialog :: slotDisplayMode ( int mode ) { m_styleList -> clear ( ) ; if ( mode != 2 ) m_styleList -> setRootIsDecorated ( false ) ; else { m_styleList -> setRootIsDecorated ( true ) ; fillComboBox ( ) ; return ; } if ( mode != 1 ) new QTreeWidgetItem ( m_styleList , QStringList ( i18n ( " Default " ) ) ) ; CustomStyles :: iterator iter = m_styleManager -> m_styles . begin ( ) ; CustomStyles :: iterator end = m_styleManager -> m_styles . end ( ) ; while ( iter != end ) { KCCustomStyle * styleData = iter . value ( ) ; if ( ! styleData || styleData -> name ( ) . isEmpty ( ) ) { ++ iter ; continue ; } if ( mode == 1 ) { if ( styleData -> type ( ) == KCStyle :: CUSTOM ) new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; } else new QTreeWidgetItem ( m_styleList , QStringList ( styleData -> name ( ) ) ) ; ++ iter ; } } void StyleManagerDialog :: slotOk ( ) { kDebug ( ) ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) { accept ( ) ; return ; } QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setDefault ( ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } else { KCStyleCommand * command = new KCStyleCommand ( ) ; command -> setSheet ( m_selection -> activeSheet ( ) ) ; command -> setParent@@ Name ( name ) ; command -> add ( * m_selection ) ; command -> execute ( m_selection -> canvas ( ) ) ; } accept ( ) ; } void StyleManagerDialog :: slotNew ( ) { KCCustomStyle * parentStyle = 0 ; QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( item ) { const QString name = item -> text ( 0 ) ; if ( name == i18n ( " Default " ) ) parentStyle = m_styleManager -> defaultStyle ( ) ; else parentStyle = m_styleManager -> style ( name ) ; } else parentStyle = m_styleManager -> defaultStyle ( ) ; int i = 1 ; QString newName ( i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ) ; while ( m_styleManager -> style ( newName ) != 0 ) { ++ i ; newName = i18n ( " style % 1" , m_styleManager -> count ( ) + i ) ; } KCCustomStyle * style = new KCCustomStyle ( newName , parentStyle ) ; style -> setType ( KCStyle :: TENTATIVE ) ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; delete dialog ; if ( style -> type ( ) == KCStyle :: TENTATIVE ) { delete style ; return ; } m_styleManager -> m_styles [ style -> name ( ) ] = style ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: slotEdit ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; KCCustomStyle * style = 0 ; QString name ( item -> text ( 0 ) ) ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; QPointer < CellFormatDialog > dialog = new CellFormatDialog ( this , m_selection , style , m_styleManager ) ; dialog -> exec ( ) ; if ( dialog -> result ( ) == Accepted ) m_selection -> emitRefresh@@ SheetViews ( ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; delete dialog ; } void StyleManagerDialog :: slotRemove ( ) { QTreeWidgetItem * item = m_styleList -> currentItem ( ) ; if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) return ; if ( style -> type ( ) != KCStyle :: CUSTOM ) return ; m_styleManager -> take@@ Style ( style ) ; slotDisplayMode ( m_displayBox -> currentIndex ( ) ) ; } void StyleManagerDialog :: selectionChanged ( QTreeWidgetItem * item ) { if ( ! item ) return ; const QString name = item -> text ( 0 ) ; KCCustomStyle * style = 0 ; if ( name == i18n ( " Default " ) ) style = m_styleManager -> defaultStyle ( ) ; else style = m_styleManager -> style ( name ) ; if ( ! style ) { enableButton ( KDialog :: User1 , false ) ; return ; } if ( style -> type ( ) == KCStyle :: BUILTIN ) enableButton ( KDialog :: User1 , false ) ; else enableButton ( KDialog :: User1 , true ) ; } # include " StyleManagerDialog . moc " </DOCUMENT>
<DOCUMENT_ID="m@@ antidproject@@ /cxxtest@@ /tree/master/cxx@@ test/TestTrack@@ er.cpp"> # ifndef __cxxtest__TestTracker_cpp__ # define __cxxtest__TestTracker_cpp__ # include < cxxtest / TestTracker . h > namespace Cxx@@ Test { bool TestTracker :: _created = false ; bool TestTracker :: print_@@ tracing = false ; TestTracker :: TestTracker ( ) { if ( ! _created ) { initialize ( ) ; setListener ( 0 ) ; _created = true ; } } TestTracker :: ~ TestTracker ( ) { } TestTracker & TestTracker :: tracker ( ) { static TestTracker theTracker ; return theTracker ; } void TestTracker :: initialize ( ) { _warnings = 0 ; _skippedTests = 0 ; _testSkipped = false ; _failedTests = 0 ; _testFailedAsserts = 0 ; _suiteFailedTests = 0 ; _failedSuites = 0 ; _world = 0 ; _suite = 0 ; _test = 0 ; } const TestDescription * TestTracker :: fixTest ( const TestDescription * d ) const { return d ? d : & dummyTest ( ) ; } const SuiteDescription * TestTracker :: fixSuite ( const SuiteDescription * d ) const { return d ? d : & dummySuite ( ) ; } const WorldDescription * TestTracker :: fixWorld ( const WorldDescription * d ) const { return d ? d : & dummyWorld ( ) ; } const TestDescription & TestTracker :: dummyTest ( ) const { return dummySuite ( ) . testDescription ( 0 ) ; } const SuiteDescription & TestTracker :: dummySuite ( ) const { return dummyWorld ( ) . suiteDescription ( 0 ) ; } const WorldDescription & TestTracker :: dummyWorld ( ) const { return _dummy@@ World ; } void TestTracker :: setListener ( TestListener * l ) { _l = l ? l : & _dummy@@ Listener ; } void TestTracker :: enterWorld ( const WorldDescription & wd ) { setWorld ( & wd ) ; _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0 ; _testSkipped = false ; _l -> enterWorld ( wd ) ; } void TestTracker :: enterSuite ( const SuiteDescription & sd ) { setSuite ( & sd ) ; _testFailedAsserts = _suiteFailedTests = 0 ; _testSkipped = false ; _l -> enterSuite ( sd ) ; } void TestTracker :: enterTest ( const TestDescription & td ) { setTest ( & td ) ; _testFailedAsserts = false ; _testSkipped = false ; _l -> enterTest ( td ) ; } void TestTracker :: leaveTest ( const TestDescription & td ) { _l -> leaveTest ( td ) ; setTest ( 0 ) ; } void TestTracker :: leaveSuite ( const SuiteDescription & sd ) { _l -> leaveSuite ( sd ) ; setSuite ( 0 ) ; } void TestTracker :: leaveWorld ( const WorldDescription & wd ) { _l -> leaveWorld ( wd ) ; setWorld ( 0 ) ; } void TestTracker :: trace ( const char * file , int line , const char * expression ) { _l -> trace ( file , line , expression ) ; } void TestTracker :: warning ( const char * file , int line , const char * expression ) { countWarning ( ) ; _l -> warning ( file , line , expression ) ; } void TestTracker :: skippedTest ( const char * file , int line , const char * expression ) { countSkipped ( ) ; _testSkipped = true ; _l -> skippedTest ( file , line , expression ) ; } void TestTracker :: failedTest ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedTest ( file , line , expression ) ; } void TestTracker :: failedAssert ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssert ( file , line , expression ) ; } void TestTracker :: failedAssertEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertSameData ( const char * file , int line , const char * xStr , const char * yStr , const char * sizeStr , const void * x , const void * y , unsigned size ) { countFailure ( ) ; _l -> failedAssertSameData ( file , line , xStr , yStr , sizeStr , x , y , size ) ; } void TestTracker :: failedAssertDelta ( const char * file , int line , const char * xStr , const char * yStr , const char * dStr , const char * x , const char * y , const char * d ) { countFailure ( ) ; _l -> failedAssertDelta ( file , line , xStr , yStr , dStr , x , y , d ) ; } void TestTracker :: failedAssertDiffers ( const char * file , int line , const char * xStr , const char * yStr , const char * value ) { countFailure ( ) ; _l -> failedAssertDiffers ( file , line , xStr , yStr , value ) ; } void TestTracker :: failedAssertLessThan ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThan ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertLessThanEquals ( const char * file , int line , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertLessThanEquals ( file , line , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertPredicate ( const char * file , int line , const char * predicate , const char * xStr , const char * x ) { countFailure ( ) ; _l -> failedAssertPredicate ( file , line , predicate , xStr , x ) ; } void TestTracker :: failedAssertRelation ( const char * file , int line , const char * relation , const char * xStr , const char * yStr , const char * x , const char * y ) { countFailure ( ) ; _l -> failedAssertRelation ( file , line , relation , xStr , yStr , x , y ) ; } void TestTracker :: failedAssertThrows ( const char * file , int line , const char * expression , const char * type , bool otherThrown ) { countFailure ( ) ; _l -> failedAssertThrows ( file , line , expression , type , otherThrown ) ; } void TestTracker :: failedAssertThrowsNot ( const char * file , int line , const char * expression ) { countFailure ( ) ; _l -> failedAssertThrowsNot ( file , line , expression ) ; } void TestTracker :: failedAssertSameFiles ( const char * file , int line , const char * file1 , const char * file2 , const char * explanation ) { countFailure ( ) ; _l -> failedAssertSameFiles ( file , line , file1 , file2 , explanation ) ; } void TestTracker :: setWorld ( const WorldDescription * w ) { _world = fixWorld ( w ) ; setSuite ( 0 ) ; } void TestTracker :: setSuite ( const SuiteDescription * s ) { _suite = fixSuite ( s ) ; setTest ( 0 ) ; } void TestTracker :: setTest ( const TestDescription * t ) { _test = fixTest ( t ) ; } void TestTracker :: countWarning ( ) { ++ _warnings ; } void TestTracker :: countSkipped ( ) { ++ _skippedTests ; } void TestTracker :: countFailure ( ) { if ( ++ _testFailedAsserts == 1 ) { ++ _failedTests ; if ( ++ _suiteFailedTests == 1 ) { ++ _failedSuites ; } } } } # endif </DOCUMENT>
<DOCUMENT_ID="H@@ ank@@ uo/@@ color-emoji.skia/tree/master/src/@@ gpu@@ /gl@@ /unix/@@ GrGLCreateNative@@ Interface_@@ unix@@ .cpp"> # include " gl / GrGLExtensions . h " # include " gl / GrGLInterface . h " # include " . . / GrGLUtil . h " # include < GL / glx . h > # include < GL / gl . h > # include < GL / glex@@ t . h > # include < GL / glu . h > # define GR_GL_GET_PROC ( F ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F ) ) ; # define GR_GL_GET_PROC_SUFFIX ( F , S ) interface -> f ## F = ( GrGL ## F ## Proc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " gl " # F # S ) ) ; const GrGLInterface * GrGLCreateNative@@ Interface ( ) { if ( NULL != glXGetCurrent@@ Context ( ) ) { const char * versionString = ( const char * ) glGetString ( GL_VERSION ) ; GrGLVersion glVer = GrGLGetVersion@@ FromString ( versionString ) ; GrGLGetStringiProc glGetStringi = ( GrGLGetStringiProc ) glXGetProcAddress ( reinterpret_cast < const GLubyte * > ( " glGetStringi " ) ) ; GrGLExtensions extensions ; if ( ! extensions . init ( kDesktop_GrGLBinding , glGetString , glGetStringi , glGetIntegerv ) ) { return NULL ; } if ( glVer < GR_GL_VER ( 1 , 5 ) ) { return NULL ; } GrGLInterface * interface = new GrGLInterface ( ) ; interface -> fActiveTexture = glActiveTexture ; GR_GL_GET_PROC ( Attach@@ Shader ) ; GR_GL_GET_PROC ( BindAttrib@@ Location ) ; GR_GL_GET_PROC ( BindBuffer ) ; GR_GL_GET_PROC ( BindFragData@@ Location ) ; GR_GL_GET_PROC ( BeginQuery ) ; interface -> fBind@@ Texture = glBind@@ Texture ; interface -> fBlendFunc = glBlendFunc ; if ( glVer >= GR_GL_VER ( 1 , 4 ) || extensions . has ( " GL _ ARB _ imaging " ) || extensions . has ( " GL _ EXT _ blend _ color " ) ) { GR_GL_GET_PROC ( Blend@@ Color ) ; } GR_GL_GET_PROC ( BufferData ) ; GR_GL_GET_PROC ( BufferSubData ) ; interface -> fClear = glClear ; interface -> fClear@@ Color = glClearColor ; interface -> fClear@@ Stencil = glClear@@ Stencil ; interface -> fColor@@ Mask = glColor@@ Mask ; GR_GL_GET_PROC ( CompileShader ) ; interface -> fCompressedTexImage2D = glCompressedTexImage2D ; interface -> fCopyTexSubImage2D = glCopyTexSubImage2D ; GR_GL_GET_PROC ( CreateProgram ) ; GR_GL_GET_PROC ( CreateShader ) ; interface -> fCullFace = glCullFace ; GR_GL_GET_PROC ( DeleteBuffers ) ; GR_GL_GET_PROC ( DeleteProgram ) ; GR_GL_GET_PROC ( DeleteQueries ) ; GR_GL_GET_PROC ( DeleteShader ) ; interface -> fDeleteTextures = glDeleteTextures ; interface -> fDepthMask = glDepthMask ; interface -> fDisable = glDisable ; GR_GL_GET_PROC ( DisableVertexAttribArray ) ; interface -> fDraw@@ Arrays = glDraw@@ Arrays ; interface -> fDraw@@ Buffer = glDraw@@ Buffer ; GR_GL_GET_PROC ( DrawBuffers ) ; interface -> fDraw@@ Elements = glDrawElements ; interface -> fEnable = glEnable ; GR_GL_GET_PROC ( EnableVertexAttribArray ) ; GR_GL_GET_PROC ( EndQuery ) ; interface -> fFinish = glFinish ; interface -> fFlush = glFlush ; interface -> fFrontFace = glFrontFace ; GR_GL_GET_PROC ( GenBuffers ) ; GR_GL_GET_PROC ( GetBuffer@@ Parameteriv ) ; interface -> fGetError = glGetError ; interface -> fGetIntegerv = glGetIntegerv ; GR_GL_GET_PROC ( GetQueryObject@@ iv ) ; GR_GL_GET_PROC ( GetQueryObject@@ uiv ) ; if ( glVer >= GR_GL_VER ( 3 , 3 ) || extensions . has ( " GL _ ARB _ timer _ query " ) ) { GR_GL_GET_PROC ( GetQueryObjecti64v ) ; GR_GL_GET_PROC ( GetQueryObjectui64v ) ; GR_GL_GET_PROC ( QueryCounter ) ; } else if ( extensions . has ( " GL _ EXT _ timer _ query " ) ) { GR_GL_GET_PROC_SUFFIX ( GetQueryObjecti64v , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetQueryObjectui64v , EXT ) ; } GR_GL_GET_PROC ( GetQueryiv ) ; GR_GL_GET_PROC ( GetProgram@@ InfoLog ) ; GR_GL_GET_PROC ( GetProgram@@ iv ) ; GR_GL_GET_PROC ( GetShader@@ InfoLog ) ; GR_GL_GET_PROC ( GetShader@@ iv ) ; interface -> fGetString = glGetString ; GR_GL_GET_PROC ( GetStringi ) ; interface -> fGetTexLevelParameteriv = glGetTexLevelParameteriv ; GR_GL_GET_PROC ( GenQueries ) ; interface -> fGen@@ Textures = glGen@@ Textures ; GR_GL_GET_PROC ( GetUniform@@ Location ) ; interface -> fLineWidth = glLineWidth ; GR_GL_GET_PROC ( LinkProgram ) ; GR_GL_GET_PROC ( MapBuffer ) ; interface -> fPixelStorei = glPixelStorei ; interface -> fRead@@ Buffer = glRead@@ Buffer ; interface -> fRead@@ Pixels = glRead@@ Pixels ; if ( extensions . has ( " GL _ NV _ framebuffer _ multisample _ coverage " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMulti@@ sampleCoverage , NV ) ; } interface -> fScissor = glScissor ; GR_GL_GET_PROC ( Shader@@ Source ) ; interface -> fStencil@@ Func = glStencil@@ Func ; GR_GL_GET_PROC ( StencilFuncSeparate ) ; interface -> fStencil@@ Mask = glStencil@@ Mask ; GR_GL_GET_PROC ( StencilMask@@ Separate ) ; interface -> fStencil@@ Op = glStencil@@ Op ; GR_GL_GET_PROC ( StencilOpSeparate ) ; interface -> fTex@@ Image2D = glTex@@ Image2D ; interface -> fTex@@ Parameteri = glTex@@ Parameteri ; interface -> fTex@@ Parameteriv = glTex@@ Parameteriv ; if ( glVer >= GR_GL_VER ( 4 , 2 ) || extensions . has ( " GL _ ARB _ texture _ storage " ) ) { GR_GL_GET_PROC ( TexStorage2D ) ; } else if ( extensions . has ( " GL _ EXT _ texture _ storage " ) ) { GR_GL_GET_PROC_SUFFIX ( TexStorage2D , EXT ) ; } interface -> fTex@@ SubImage2D = glTex@@ SubImage2D ; GR_GL_GET_PROC ( Uniform1f ) ; GR_GL_GET_PROC ( Uniform1@@ i ) ; GR_GL_GET_PROC ( Uniform1@@ fv ) ; GR_GL_GET_PROC ( Uniform1@@ iv ) ; GR_GL_GET_PROC ( Uniform2f ) ; GR_GL_GET_PROC ( Uniform2@@ i ) ; GR_GL_GET_PROC ( Uniform2@@ fv ) ; GR_GL_GET_PROC ( Uniform2@@ iv ) ; GR_GL_GET_PROC ( Uniform3f ) ; GR_GL_GET_PROC ( Uniform3@@ i ) ; GR_GL_GET_PROC ( Uniform3@@ fv ) ; GR_GL_GET_PROC ( Uniform3@@ iv ) ; GR_GL_GET_PROC ( Uniform4f ) ; GR_GL_GET_PROC ( Uniform4@@ i ) ; GR_GL_GET_PROC ( Uniform4fv ) ; GR_GL_GET_PROC ( Uniform4@@ iv ) ; GR_GL_GET_PROC ( UniformMatrix@@ 2fv ) ; GR_GL_GET_PROC ( UniformMatrix@@ 3fv ) ; GR_GL_GET_PROC ( UniformMatrix@@ 4fv ) ; GR_GL_GET_PROC ( Unmap@@ Buffer ) ; GR_GL_GET_PROC ( UseProgram ) ; GR_GL_GET_PROC ( VertexAttrib@@ 4fv ) ; GR_GL_GET_PROC ( VertexAttrib@@ Pointer ) ; interface -> fViewport = glViewport ; GR_GL_GET_PROC ( BindFragData@@ LocationIndexed ) ; if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ vertex _ array _ object " ) ) { GR_GL_GET_PROC ( BindVertex@@ Array ) ; GR_GL_GET_PROC ( GenVertexArrays ) ; GR_GL_GET_PROC ( DeleteVertexArrays ) ; } if ( glVer >= GR_GL_VER ( 3 , 0 ) || extensions . has ( " GL _ ARB _ framebuffer _ object " ) ) { GR_GL_GET_PROC ( GenFramebuffers ) ; GR_GL_GET_PROC ( GetFramebufferAttachmentParameteriv ) ; GR_GL_GET_PROC ( GetRenderbufferParameteriv ) ; GR_GL_GET_PROC ( BindFramebuffer ) ; GR_GL_GET_PROC ( FramebufferTexture2D ) ; GR_GL_GET_PROC ( CheckFramebufferStatus ) ; GR_GL_GET_PROC ( DeleteFramebuffers ) ; GR_GL_GET_PROC ( RenderbufferStorage ) ; GR_GL_GET_PROC ( GenRenderbuffers ) ; GR_GL_GET_PROC ( DeleteRenderbuffers ) ; GR_GL_GET_PROC ( FramebufferRenderbuffer ) ; GR_GL_GET_PROC ( BindRenderbuffer ) ; GR_GL_GET_PROC ( RenderbufferStorageMultisample ) ; GR_GL_GET_PROC ( BlitFramebuffer ) ; } else if ( extensions . has ( " GL _ EXT _ framebuffer _ object " ) ) { GR_GL_GET_PROC_SUFFIX ( GenFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetFramebufferAttachmentParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GetRenderbufferParameteriv , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindFramebuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferTexture2D , EXT ) ; GR_GL_GET_PROC_SUFFIX ( CheckFramebufferStatus , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteFramebuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( RenderbufferStorage , EXT ) ; GR_GL_GET_PROC_SUFFIX ( GenRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( DeleteRenderbuffers , EXT ) ; GR_GL_GET_PROC_SUFFIX ( FramebufferRenderbuffer , EXT ) ; GR_GL_GET_PROC_SUFFIX ( BindRenderbuffer , EXT ) ; if ( extensions . has ( " GL _ EXT _ framebuffer _ multisample " ) ) { GR_GL_GET_PROC_SUFFIX ( RenderbufferStorageMultisample , EXT ) ; } if ( extensions . has ( " GL _ EXT _ framebuffer _ blit " ) ) { GR_GL_GET_PROC_SUFFIX ( BlitFramebuffer , EXT ) ; } } else { delete interface ; return NULL ; } interface -> fBind@@ ingsEx@@ ported = kDesktop_GrGLBinding ; return interface ; } else { return NULL ; } } </DOCUMENT>
<DOCUMENT_ID="br@@ aska/t@@ desktop/tree/master/Tele@@ gram/Source@@ Files/@@ gui/twidget.cpp"> # include " stdafx . h " # include " application . h " namespace { void _sendResizeEvents ( QWidget * target ) { QResizeEvent e ( target -> size ( ) , QSize ( ) ) ; QApplication :: sendEvent ( target , & e ) ; const QObject@@ List children = target -> children ( ) ; for ( int i = 0 ; i < children . size ( ) ; ++ i ) { QWidget * child = static_cast < QWidget * > ( children . at ( i ) ) ; if ( child -> isWidgetType ( ) && ! child -> isWindow ( ) && child -> testAttribute ( Qt :: WA_PendingResizeEvent ) ) { _sendResizeEvents ( child ) ; } } } } void myEnsureResized ( QWidget * target ) { if ( target && ( target -> testAttribute ( Qt :: WA_PendingResizeEvent ) || ! target -> testAttribute ( Qt :: WA_@@ WStat@@ e_Created ) ) ) { _sendResizeEvents ( target ) ; } } QPixmap myGra@@ b ( QWidget * target , const QRect & rect ) { if ( ! cRet@@ ina ( ) ) return target -> grab ( rect ) ; myEnsureResized ( target ) ; qreal dpr = App :: app ( ) -> devic@@ ePixelRatio ( ) ; QPixmap result ( rect . size ( ) * dpr ) ; result . setDevice@@ PixelRatio ( dpr ) ; result . fill ( Qt :: transparent ) ; target -> render ( & result , QPoint ( ) , QRegion ( rect ) , QWidget :: DrawWindowBackground | QWidget :: DrawChildren | QWidget :: IgnoreMask ) ; return result ; } </DOCUMENT>
<DOCUMENT_ID="Live@@ Asynchron@@ ous@@ Visual@@ ized@@ Architecture@@ /la@@ va@@ /tree/master/nu@@ kle@@ ar/@@ unified@@ .cpp"> # define LAVA_@@ IND@@ EXED_@@ VERTS_@@ IMPL # include " IndexedVerts . h " # include " nano@@ gui / src / screen . cpp " # include " main . cpp " </DOCUMENT>
<DOCUMENT_ID="quang@@ -h@@ a/lammp@@ s/tree/master/lib/@@ kok@@ kos@@ /core@@ /src/eti/@@ OpenMP/Kokkos_@@ OpenMP_@@ ViewCopy@@ ETI@@ Inst_@@ int64@@ _t_double_@@ LayoutStride@@ _Ran@@ k3.cpp"> # define KOKKOS_IMPL_@@ COMPILING_LIBRAR@@ Y true # include < Kokkos_@@ Core . hpp > namespace Kokko@@ s { namespace Impl { KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutRight , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutLeft , OpenMP , int64_t ) KOKKOS_IMPL_VIEWCOPY_ETI_INST ( double * * * , LayoutStride , LayoutStride , OpenMP , int64_t ) KOKKOS_IMPL_VIEW@@ FILL_ETI_INST ( double * * * , LayoutStride , OpenMP , int64_t ) } } </DOCUMENT>
<DOCUMENT_ID="m@@ ur47@@ x111/@@ JDK@@ 8-@@ concurrent@@ -tag@@ ging/tree/master/src/share/v@@ m/gc_@@ implementation/@@ concurrentMarkSweep@@ /v@@ mCMS@@ Operations.cpp"> # include " precompiled . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweep@@ Generation . inline . hpp " # include " gc _ implementation / concurrentMarkSweep / concurrentMarkSweepThread . hpp " # include " gc _ implementation / concurrentMarkSweep / vm@@ CMSOperations . hpp " # include " gc _ implementation / shared / gcTimer . hpp " # include " gc _ implementation / shared / gcTraceTime . hpp " # include " gc _ implementation / shared / isGCActiveMark . hpp " # include " memory / gcLocker . inline . hpp " # include " runtime / interface@@ Support . hpp " # include " runtime / os . hpp " # include " utilities / dtrace . hpp " # ifndef USDT2 HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__initmark__end ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__begin ) ; HS_DTRACE_PROBE_DECL ( hs_private , cms__remark__end ) ; # endif void VM_CMS_Operation :: acquire_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: acquire@@ PLL ) ; } void VM_CMS_Operation :: release_and_notify_pending_list_lock ( ) { ConcurrentMarkSweepThread :: slt ( ) -> manipulatePLL ( SurrogateLockerThread :: release@@ AndNotify@@ PLL ) ; } void VM_CMS_Operation :: verify_before_gc ( ) { if ( VerifyBefore@@ GC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ Before " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: heap ( ) -> prepare@@ _for_verify ( ) ; Universe :: verify ( ) ; } } void VM_CMS_Operation :: verify_after_gc ( ) { if ( VerifyAfter@@ GC && GenCollectedHeap :: heap ( ) -> total_collections ( ) >= VerifyGCStartAt ) { GCTraceTime tm ( " Verify ▁ After " , false , false , _collector -> _gc_timer_cm ) ; HandleMark hm ; FreelistLocker x ( _collector ) ; MutexLockerEx y ( _collector -> bitMapLock ( ) , Mutex :: _no_safepoint_check_flag ) ; Universe :: verify ( ) ; } } bool VM_CMS_Operation :: lost_race ( ) const { if ( CMSCollector :: abstract_state ( ) == CMSCollector :: Idling ) { return true ; } assert ( CMSCollector :: abstract_state ( ) == legal_state ( ) , " Inconsistent ▁ collector ▁ state ? " ) ; return false ; } bool VM_CMS_Operation :: doit_prologue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; if ( needs_pll ( ) ) { acquire_pending_list_lock ( ) ; } Heap_lock -> lock ( ) ; if ( lost_race ( ) ) { assert ( _prologue_succeeded == false , " Initialized ▁ in ▁ c ' tor " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } else { _prologue_succeeded = true ; } return _prologue_succeeded ; } void VM_CMS_Operation :: doit_epilogue ( ) { assert ( Thread :: current ( ) -> is_ConcurrentGC_thread ( ) , " just ▁ checking " ) ; assert ( ! CMSCollector :: foregroundGCShouldWait ( ) , " Possible ▁ deadlock " ) ; assert ( ! ConcurrentMarkSweepThread :: cms_thread_has_cms_token ( ) , " Possible ▁ deadlock " ) ; Heap_lock -> unlock ( ) ; if ( needs_pll ( ) ) { release_and_notify_pending_list_lock ( ) ; } } void VM_CMS_Initial_Mark :: doit ( ) { if ( lost_race ( ) ) { return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__begin ) ; # else HS_PRIVATE_CMS_INITMARK_@@ BEGIN ( ) ; # endif _collector -> _gc_timer_cm -> register_gc_pause_start ( " Initial ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_@@ initial_@@ mark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRoots@@ Initial , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__initmark__end ) ; # else HS_PRIVATE_CMS_INITMARK_@@ END ( ) ; # endif } void VM_CMS_Final_Remark :: doit ( ) { if ( lost_race ( ) ) { return ; } # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__begin ) ; # else HS_PRIVATE_CMS_REMARK_@@ BEGIN ( ) ; # endif _collector -> _gc_timer_cm -> register_gc_pause_start ( " Final ▁ Mark " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; GCCauseSetter gccs ( gch , GCCause :: _cms_@@ final_remark ) ; VM_CMS_Operation :: verify_before_gc ( ) ; IsGCActiveMark x ; _collector -> do_CMS_operation ( CMSCollector :: CMS_op_checkpointRoots@@ Final , gch -> gc_cause ( ) ) ; VM_CMS_Operation :: verify_after_gc ( ) ; _collector -> save_@@ heap@@ _summar@@ y ( ) ; _collector -> _gc_timer_cm -> register_gc_pause_end ( ) ; # ifndef USDT2 HS_DTRACE_PROBE ( hs_private , cms__remark__end ) ; # else HS_PRIVATE_CMS_REMARK_@@ END ( ) ; # endif } void VM_GenCollectFullConcurrent :: doit ( ) { assert ( Thread :: current ( ) -> is_VM_thread ( ) , " Should ▁ be ▁ VM ▁ thread " ) ; assert ( GCLocker@@ InvokesConcurrent || ExplicitGCInvokesConcurrent , " Unexpected " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before == gch -> total_collections ( ) ) { assert ( SafepointSynchron@@ ize :: is_at_safepoint ( ) , " We ▁ can ▁ only ▁ be ▁ executing ▁ this ▁ arm ▁ of ▁ if ▁ at ▁ a ▁ safepoint " ) ; GCCauseSetter gccs ( gch , _gc_cause ) ; gch -> do_full_@@ collection ( gch -> must_@@ clear_al@@ l_so@@ ft_refs ( ) , 0 ) ; } assert ( ( _gc_count_before < gch -> total_collections ( ) ) || ( GC_locker :: is_active ( ) && ( _gc_count_before == gch -> total_collections ( ) ) ) , " total _ collections ( ) ▁ should ▁ be ▁ monot@@ onically ▁ increasing " ) ; MutexLockerEx x ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; assert ( _full_gc_count_before <= gch -> total_full_collections ( ) , " Error " ) ; if ( gch -> total_full_collections ( ) == _full_gc_count_before ) { CMSCollector :: disable_@@ icms ( ) ; _disabled_icms = true ; CMSCollector :: start_icms ( ) ; CMSCollector :: request_full_@@ gc ( _full_gc_count_before , _gc_cause ) ; } else { assert ( _full_gc_count_before < gch -> total_full_collections ( ) , " Error " ) ; FullGCCount_lock -> notify_all ( ) ; } } bool VM_GenCollectFullConcurrent :: evaluate_at_safepoint ( ) const { Thread * thr = Thread :: current ( ) ; assert ( thr != NULL , " Unexpected ▁ tid " ) ; if ( ! thr -> is_Java_thread ( ) ) { assert ( thr -> is_VM_thread ( ) , " Expected ▁ to ▁ be ▁ evaluated ▁ by ▁ VM ▁ thread " ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_count_before != gch -> total_collections ( ) ) { assert ( _gc_count_before < gch -> total_collections ( ) , " total _ collections ( ) ▁ should ▁ be ▁ monot@@ nically ▁ increasing " ) ; return false ; } } return true ; } void VM_GenCollectFullConcurrent :: doit_epilogue ( ) { Thread * thr = Thread :: current ( ) ; assert ( thr -> is_Java_thread ( ) , " just ▁ checking " ) ; JavaThread * jt = ( JavaThread * ) thr ; Heap_lock -> unlock ( ) ; release_and_notify_pending_list_lock ( ) ; GenCollectedHeap * gch = GenCollectedHeap :: heap ( ) ; if ( _gc_cause != GCCause :: _gc_locker && gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { assert ( _gc_cause == GCCause :: _jav@@ a_lan@@ g_system_@@ gc , " the ▁ only ▁ way ▁ to ▁ get ▁ here ▁ if ▁ this ▁ was ▁ a ▁ System . gc ( ) - induced ▁ GC " ) ; assert ( ExplicitGCInvokesConcurrent , " Error " ) ; ThreadToNative@@ FromVM native ( jt ) ; MutexLockerEx ml ( FullGCCount_lock , Mutex :: _no_safepoint_check_flag ) ; while ( gch -> total_full_collections_completed ( ) <= _full_gc_count_before ) { FullGCCount_lock -> wait ( Mutex :: _no_safepoint_check_flag ) ; } } if ( _disabled_icms ) { CMSCollector :: enable_ic@@ ms ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="shli@@ uj@@ ing/@@ TeamTalk@@ /tree/master/server@@ /src/db_pro@@ xy_@@ server/busin@@ ess/@@ UserAct@@ ion.cpp"> # include < list > # include < map > # include " . . / ProxyConn . h " # include " . . / DBPool . h " # include " . . / SyncCenter . h " # include " public _ define . h " # include " UserModel . h " # include " IM . Login . pb . h " # include " IM . Buddy . pb . h " # include " IM . BaseDefine . pb . h " namespace DB_PROXY { void getUserInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMUsersInfo@@ Req msg ; IM :: Buddy :: IMUsersInfo@@ Rsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t from_user_id = msg . user_id ( ) ; uint32_t userCount = msg . user_id@@ _list_size ( ) ; std :: list < uint32_t > idList ; for ( uint32_t i = 0 ; i < userCount ; ++ i ) { idList . push_back ( msg . user_id@@ _list ( i ) ) ; } std :: list < IM :: BaseDefine :: UserInfo > lsUser ; CUserModel :: getInstance ( ) -> getUsers ( idList , lsUser ) ; msgResp . set_user_id ( from_user_id ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUser . begin ( ) ; it != lsUser . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_info@@ _list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , ▁ userCnt = % u " , from_user_id , userCount ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_@@ USER_@@ INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void getChanged@@ User ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMAllUser@@ Req msg ; IM :: Buddy :: IMAllUser@@ Rsp msgResp ; if ( msg . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { CImPdu * pPduRes = new CImPdu ; uint32_t nReqId = msg . user_id ( ) ; uint32_t nLastTime = msg . latest_update_time ( ) ; uint32_t nLastUpdate = CSyncCenter :: getInstance ( ) -> getLast@@ Update ( ) ; list < IM :: BaseDefine :: UserInfo > lsUsers ; if ( nLastUpdate > nLastTime ) { list < uint32_t > lsIds ; CUserModel :: getInstance ( ) -> getChanged@@ Id ( nLastTime , lsIds ) ; CUserModel :: getInstance ( ) -> getUsers ( lsIds , lsUsers ) ; } msgResp . set_user_id ( nReqId ) ; msgResp . set_latest_update_time ( nLastTime ) ; for ( list < IM :: BaseDefine :: UserInfo > :: iterator it = lsUsers . begin ( ) ; it != lsUsers . end ( ) ; ++ it ) { IM :: BaseDefine :: UserInfo * pUser = msgResp . add_user_list ( ) ; pUser -> set_user_id ( it -> user_id ( ) ) ; pUser -> set_user_gender ( it -> user_gender ( ) ) ; pUser -> set_user_nick_name ( it -> user_nick_name ( ) ) ; pUser -> set_avatar_url ( it -> avatar_url ( ) ) ; pUser -> set_sign_info ( it -> sign_info ( ) ) ; pUser -> set_department_id ( it -> department_id ( ) ) ; pUser -> set_email ( it -> email ( ) ) ; pUser -> set_user_real_name ( it -> user_real_name ( ) ) ; pUser -> set_user_tel ( it -> user_tel ( ) ) ; pUser -> set_user_domain ( it -> user_domain ( ) ) ; pUser -> set_status ( it -> status ( ) ) ; } log ( " userId = % u , nLastUpdate = % u , ▁ last _ time = % u , ▁ userCnt = % u " , nReqId , nLastUpdate , nLastTime , msgResp . user_list_size ( ) ) ; msgResp . set_attach_data ( msg . attach_data ( ) ) ; pPduRes -> SetPBMsg ( & msgResp ) ; pPduRes -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pPduRes -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pPduRes -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_@@ ALL_USER_@@ RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pPduRes ) ; } else { log ( " parse ▁ pb ▁ failed " ) ; } } void changeUserSignInfo ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Buddy :: IMChangeSignInfoReq req ; IM :: Buddy :: IMChangeSignInfo@@ Rsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; const string & sign_info = req . sign_info ( ) ; bool result = CUserModel :: getInstance ( ) -> updateUserSignInfo ( user_id , sign_info ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_sign_info ( sign_info ) ; log ( " changeUserSignInfo ▁ sucess , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } else { log ( " changeUserSignInfo ▁ false , ▁ user _ id = % u , ▁ sign _ info = % s " , user_id , sign_info . c_str ( ) ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_BUDDY_LIST ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_BUDDY_LIST_@@ CHANGE_SIGN_INFO_RESPONSE ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " changeUserSignInfo : ▁ IMChangeSignInfoReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMPushShieldReq req ; IM :: Login :: IMPushShi@@ eldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = req . shield_status ( ) ; bool result = CUserModel :: getInstance ( ) -> updatePushShield ( user_id , shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doPushShield ▁ false , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_@@ PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doPushShield : ▁ IMPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } void doQueryPushShield ( CImPdu * pPdu , uint32_t conn_uuid ) { IM :: Login :: IMQueryPushShieldReq req ; IM :: Login :: IMQueryPushShi@@ eldRsp resp ; if ( req . ParseFromArray ( pPdu -> GetBodyData ( ) , pPdu -> GetBodyLength ( ) ) ) { uint32_t user_id = req . user_id ( ) ; uint32_t shield_status = 0 ; bool result = CUserModel :: getInstance ( ) -> getPushShield ( user_id , & shield_status ) ; resp . set_user_id ( user_id ) ; resp . set_result_code ( result ? 0 : 1 ) ; if ( result ) { resp . set_shield_status ( shield_status ) ; log ( " doQueryPushShield ▁ sucess , ▁ user _ id = % u , ▁ shield _ status = % u " , user_id , shield_status ) ; } else { log ( " doQueryPushShield ▁ false , ▁ user _ id = % u " , user_id ) ; } CImPdu * pdu_resp = new CImPdu ( ) ; resp . set_attach_data ( req . attach_data ( ) ) ; pdu_resp -> SetPBMsg ( & resp ) ; pdu_resp -> SetSeqNum ( pPdu -> GetSeqNum ( ) ) ; pdu_resp -> SetServiceId ( IM :: BaseDefine :: SID_LOGIN ) ; pdu_resp -> SetCommandId ( IM :: BaseDefine :: CID_LOGIN_RES_@@ QUER@@ Y_PUSH_SHIELD ) ; CProxyConn :: AddResponsePdu ( conn_uuid , pdu_resp ) ; } else { log ( " doQueryPushShield : ▁ IMQueryPushShieldReq ▁ ParseFromArray ▁ failed ! ! ! " ) ; } } } ; </DOCUMENT>
<DOCUMENT_ID="b@@ iojpp@@ m/c4@@ stl/tree/master/@@ bm/@@ list/push@@ _back/flat_fwd_list__pag@@ ed__@@ NumByte@@ s_64@@ ___int@@ 32_t@@ .cpp"> # include " benchmark / benchmark . h " # include " c4 / log . hpp " # include " c4 / allocator . hpp " # include " . . / list _ types . hpp " namespace bm = benchmark ; namespace c4 { template < class List > void BM_ListPushBack ( bm :: State & st ) { List li ; using T = typename List :: value_type ; T v { } ; size_t count = 0 ; while ( st . Keep@@ Running ( ) ) { for ( int i = 0 , e = st . range ( 0 ) ; i < e ; ++ i ) { if ( li . size ( ) == li . max_size ( ) ) li . clear ( ) ; li . push_back ( v ) ; ++ count ; } li . clear ( ) ; } st . SetComplex@@ ityN ( st . range ( 0 ) ) ; st . SetItems@@ Processed ( count ) ; st . SetBytes@@ Processed ( count * sizeof ( T ) ) ; } BENCHMARK_@@ TEMPLATE ( BM_ListPushBack , flat_fwd_list__pag@@ ed < NumBytes < 64 > C4_@@ COMMA int32_t > ) -> Range@@ Multiplier ( 2 ) -> Range ( 4 , 1 << 19 ) -> Complex@@ ity ( ) ; } BENCHMARK_@@ MAIN ( ) </DOCUMENT>
<DOCUMENT_ID="eugene1g@@ /phantomjs/tree/master/src/qt/qtbase/src/@@ corelib@@ /doc/snippets/code/src_@@ corelib@@ _io_@@ qfile@@ .cpp"> QFile file ; QDir :: setCurrent ( " / tmp " ) ; file . setFileName ( " readme . txt " ) ; QDir :: setCurrent ( " / home " ) ; file . open ( QIODevice :: ReadOnly ) ; QByteArray myEncoderFunc ( const QString & fileName ) ; QString myDecoderFunc ( const QByteArray & localFileName ) ; # include < stdio . h > void printError ( const char * msg ) { QFile file ; file . open ( stderr , QIODevice :: WriteOnly ) ; file . write ( msg , qstrlen ( msg ) ) ; file . close ( ) ; } CONFIG += console </DOCUMENT>
<DOCUMENT_ID="b@@ abymann@@ en/@@ theforgottenserver@@ -7.@@ 4/tree/master/src/@@ items.cpp"> # include " otpch . h " # include " items . h " # include " spells . h " # include " movement . h " # include " weapons . h " # include " pugi@@ cast . h " uint32_t Items :: dwMajorVersion = 0 ; uint32_t Items :: dwMinorVersion = 0 ; uint32_t Items :: dwBuildNumber = 0 ; extern MoveEvents * g_moveEvents ; extern Weapons * g_weapons ; ItemType :: ItemType ( ) : group ( ITEM_GROUP_NONE ) , type ( ITEM_TYPE_NONE ) , id ( 0 ) , clientId ( 0 ) , stackable ( false ) , isAnimat@@ ion ( false ) , weight ( 0 ) , levelDoor ( 0 ) , decayTime ( 0 ) , wield@@ Info ( 0 ) , minReq@@ Level ( 0 ) , minReq@@ Magic@@ Level ( 0 ) , charges ( 0 ) , maxHitChance ( - 1 ) , decayTo ( - 1 ) , attack ( 0 ) , defense ( 0 ) , extraDefense ( 0 ) , armor ( 0 ) , rotateTo ( 0 ) , rune@@ MagLevel ( 0 ) , rune@@ Level ( 0 ) , combatType ( COMBAT_NONE ) , transformToOnUse ( 0 ) , transformToFree ( 0 ) , destroyTo ( 0 ) , maxTextLen ( 0 ) , writeOnceItemId ( 0 ) , transformEquipTo ( 0 ) , transformDeEquipTo ( 0 ) , maxItems ( 8 ) , slotPosition ( SLOTP_HAND ) , speed ( 0 ) , wareId ( 0 ) , magicEffect ( CONST_ME_NONE ) , bedPartnerDir ( DIREC@@ TION_NONE ) , weaponType ( WEAPON_@@ NONE ) , ammoType ( AMMO_NONE ) , shootType ( CONST_ANI_NONE ) , corpseType ( RACE_NONE ) , fluidSource ( FLUID_NONE ) , floorChange ( 0 ) , alwaysOnTopOrder ( 0 ) , lightLevel ( 0 ) , lightColor ( 0 ) , shootRange ( 1 ) , hitChance ( 0 ) , forceUse ( false ) , hasHeight ( false ) , walkStack ( true ) , blockSolid ( false ) , blockPickupable ( false ) , blockProjectile ( false ) , blockPathFind ( false ) , allowPickupable ( false ) , showDuration ( false ) , showCharges ( false ) , showAttributes ( false ) , replaceable ( true ) , pickupable ( false ) , rotatable ( false ) , useable ( false ) , moveable ( false ) , alwaysOnTop ( false ) , canReadText ( false ) , canWriteText ( false ) , isVertical ( false ) , isHorizontal ( false ) , isHangable ( false ) , allowDistRead ( false ) , lookThrough ( false ) , stopTime ( false ) , showCount ( true ) { } Items :: Items ( ) { items . reserve ( 20000 ) ; } Items :: ~ Items ( ) { clear ( ) ; } void Items :: clear ( ) { items . clear ( ) ; } bool Items :: reload ( ) { clear ( ) ; loadFromOtb ( " data / items / items . otb " ) ; if ( ! loadFromXml ( ) ) { return false ; } g_moveEvents -> reload ( ) ; g_weapons -> reload ( ) ; g_weapons -> loadDefaults ( ) ; return true ; } FILELO@@ ADER_@@ ERRORS Items :: loadFromOtb ( const std :: string & file ) { FileLoader f ; if ( ! f . openFile ( file . c_str ( ) , " OTB@@ I " ) ) { return f . getError ( ) ; } uint32_t type ; NODE node = f . getChildNode ( NO_NODE , type ) ; PropStream props ; if ( f . getProps ( node , props ) ) { uint32_t flags ; if ( ! props . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint8_t attr ; if ( ! props . read < uint8_t > ( attr ) ) { return ERROR_INVALID_FORMAT ; } if ( attr == ROOT_@@ ATTR_VERSION ) { uint16_t datalen ; if ( ! props . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } if ( datalen != sizeof ( VERSIONINFO ) ) { return ERROR_INVALID_FORMAT ; } VERSIONINFO vi ; if ( ! props . read ( vi ) ) { return ERROR_INVALID_FORMAT ; } Items :: dwMajorVersion = vi . dwMajorVersion ; Items :: dwMinorVersion = vi . dwMinorVersion ; Items :: dwBuildNumber = vi . dwBuildNumber ; } } if ( Items :: dwMajorVersion == 0xFFFFFFFF ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromOtb ] ▁ items . otb ▁ using ▁ generic ▁ client ▁ version . " << std :: endl ; } else if ( Items :: dwMajorVersion > 2 ) { std :: cout << " New ▁ version ▁ detected , ▁ an ▁ older ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } else if ( Items :: dwMinorVersion < CLIENT_@@ VERSION_@@ 740 ) { std :: cout << " A ▁ newer ▁ version ▁ of ▁ items . otb ▁ is ▁ required . " << std :: endl ; return ERROR_INVALID_FORMAT ; } node = f . getChildNode ( node , type ) ; while ( node != NO_NODE ) { PropStream stream ; if ( ! f . getProps ( node , stream ) ) { return f . getError ( ) ; } uint32_t flags ; if ( ! stream . read < uint32_t > ( flags ) ) { return ERROR_INVALID_FORMAT ; } uint16_t serverId = 0 ; uint16_t clientId = 0 ; uint16_t speed = 0 ; uint16_t wareId = 0 ; uint8_t lightLevel = 0 ; uint8_t lightColor = 0 ; uint8_t alwaysOnTopOrder = 0 ; uint8_t attrib ; while ( stream . read < uint8_t > ( attrib ) ) { uint16_t datalen ; if ( ! stream . read < uint16_t > ( datalen ) ) { return ERROR_INVALID_FORMAT ; } switch ( attrib ) { case ITEM_ATTR@@ _SERVERID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( serverId ) ) { return ERROR_INVALID_FORMAT ; } if ( serverId > 20000 && serverId < 20100 ) { serverId -= 20000 ; } break ; } case ITEM_ATTR_@@ CLIEN@@ TID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( clientId ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR@@ _SPEED : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( speed ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_@@ LIGHT@@ 2 : { if ( datalen != sizeof ( lightBlock2 ) ) { return ERROR_INVALID_FORMAT ; } lightBlock2 lb2 ; if ( ! stream . read ( lb2 ) ) { return ERROR_INVALID_FORMAT ; } lightLevel = static_cast < uint8_t > ( lb2 . lightLevel ) ; lightColor = static_cast < uint8_t > ( lb2 . lightColor ) ; break ; } case ITEM_ATTR_@@ TOPORDER : { if ( datalen != sizeof ( uint8_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint8_t > ( alwaysOnTopOrder ) ) { return ERROR_INVALID_FORMAT ; } break ; } case ITEM_ATTR_@@ WAREID : { if ( datalen != sizeof ( uint16_t ) ) { return ERROR_INVALID_FORMAT ; } if ( ! stream . read < uint16_t > ( wareId ) ) { return ERROR_INVALID_FORMAT ; } break ; } default : { if ( ! stream . skip ( datalen ) ) { return ERROR_INVALID_FORMAT ; } break ; } } } reverseItemMap . emplace ( clientId , serverId ) ; if ( serverId >= items . size ( ) ) { items . resize ( serverId + 1 ) ; } ItemType & iType = items [ serverId ] ; iType . group = static_cast < itemgroup@@ _t > ( type ) ; switch ( type ) { case ITEM_GROUP_CONTAINER : iType . type = ITEM_TYPE_CONTAINER ; break ; case ITEM_GROUP_DOOR : iType . type = ITEM_TYPE_DOOR ; break ; case ITEM_GROUP_MAGICFIELD : iType . type = ITEM_TYPE_MAGICFIELD ; break ; case ITEM_GROUP_TELEPORT : iType . type = ITEM_TYPE_TELEPORT ; break ; case ITEM_GROUP_NONE : case ITEM_GROUP_GROUND : case ITEM_GROUP@@ _SPLAS@@ H : case ITEM_GROUP@@ _FL@@ UID : case ITEM_GROUP_CHARGES : case ITEM_GROUP_DEPRECATED : break ; default : return ERROR_INVALID_FORMAT ; } iType . blockSolid = hasBitSet ( FLAG_BLOC@@ K_SOLID , flags ) ; iType . blockProjectile = hasBitSet ( FLAG_BLOCK_@@ PROJ@@ ECTI@@ LE , flags ) ; iType . blockPathFind = hasBitSet ( FLAG_BLOCK_@@ PATHFIN@@ D , flags ) ; iType . hasHeight = hasBitSet ( FLAG_HAS_@@ HEIG@@ HT , flags ) ; iType . useable = hasBitSet ( FLAG_USE@@ ABLE , flags ) ; iType . pickupable = hasBitSet ( FLAG_PIC@@ KUP@@ ABLE , flags ) ; iType . moveable = hasBitSet ( FLAG_MOVEABLE , flags ) ; iType . stackable = hasBitSet ( FLAG_ST@@ ACK@@ ABLE , flags ) ; iType . alwaysOnTop = hasBitSet ( FLAG_ALWAY@@ SON@@ TOP , flags ) ; iType . isVertical = hasBitSet ( FLAG_VERTICAL , flags ) ; iType . isHorizontal = hasBitSet ( FLAG_HORIZON@@ TAL , flags ) ; iType . isHangable = hasBitSet ( FLAG_HANGABLE , flags ) ; iType . allowDistRead = hasBitSet ( FLAG_ALLO@@ WDI@@ STRE@@ AD , flags ) ; iType . rotatable = hasBitSet ( FLAG_ROT@@ ATABLE , flags ) ; iType . canReadText = hasBitSet ( FLAG_READ@@ ABLE , flags ) ; iType . lookThrough = hasBitSet ( FLAG_LOOK@@ THROUGH , flags ) ; iType . forceUse = hasBitSet ( FLAG_FORCE@@ USE , flags ) ; iType . id = serverId ; iType . clientId = clientId ; iType . speed = speed ; iType . lightLevel = lightLevel ; iType . lightColor = lightColor ; iType . wareId = wareId ; iType . alwaysOnTopOrder = alwaysOnTopOrder ; node = f . getNextNode ( node , type ) ; } items . shrin@@ k_to_@@ fit ( ) ; return ERROR_NONE ; } bool Items :: loadFromXml ( ) { pugi :: xml_document doc ; pugi :: xml_parse_@@ result result = doc . load_file ( " data / items / items . xml " ) ; if ( ! result ) { printXMLError ( " Error ▁ - ▁ Items : : loadFromXml " , " data / items / items . xml " , result ) ; return false ; } for ( auto itemNode : doc . child ( " items " ) . children ( ) ) { pugi :: xml_attribute idAttribute = itemNode . attribute ( " id " ) ; if ( idAttribute ) { parseItemNode ( itemNode , pugi :: cast < uint16_t > ( idAttribute . value ( ) ) ) ; continue ; } pugi :: xml_attribute fromIdAttribute = itemNode . attribute ( " fromid " ) ; if ( ! fromIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ No ▁ item ▁ id ▁ found " << std :: endl ; continue ; } pugi :: xml_attribute toIdAttribute = itemNode . attribute ( " toid " ) ; if ( ! toIdAttribute ) { std :: cout << " [ Warning ▁ - ▁ Items : : loadFromXml ] ▁ fromid ▁ ( " << fromIdAttribute . value ( ) << " ) ▁ without ▁ toid " << std :: endl ; continue ; } uint16_t id = pugi :: cast < uint16_t > ( fromIdAttribute . value ( ) ) ; uint16_t toId = pugi :: cast < uint16_t > ( toIdAttribute . value ( ) ) ; while ( id <= toId ) { parseItemNode ( itemNode , id ++ ) ; } } return true ; } void Items :: parseItemNode ( const pugi :: xml_node & itemNode , uint16_t id ) { if ( id > 20000 && id < 20100 ) { id -= 20000 ; if ( id >= items . size ( ) ) { items . resize ( id + 1 ) ; } ItemType & iType = items [ id ] ; iType . id = id ; } ItemType & it = getItemType ( id ) ; if ( it . id == 0 ) { return ; } it . name = itemNode . attribute ( " name " ) . as_string ( ) ; pugi :: xml_attribute articleAttribute = itemNode . attribute ( " article " ) ; if ( articleAttribute ) { it . article = articleAttribute . as_string ( ) ; } pugi :: xml_attribute pluralAttribute = itemNode . attribute ( " plur@@ al " ) ; if ( pluralAttribute ) { it . plural@@ Name = pluralAttribute . as_string ( ) ; } for ( auto attributeNode : itemNode . children ( ) ) { pugi :: xml_attribute keyAttribute = attributeNode . attribute ( " key " ) ; if ( ! keyAttribute ) { continue ; } pugi :: xml_attribute valueAttribute = attributeNode . attribute ( " value " ) ; if ( ! valueAttribute ) { continue ; } std :: string tmpStrValue = asLowerCaseString ( keyAttribute . as_string ( ) ) ; if ( tmpStrValue == " type " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " key " ) { it . type = ITEM_TYPE_KEY ; } else if ( tmpStrValue == " magicfield " ) { it . type = ITEM_TYPE_MAGICFIELD ; } else if ( tmpStrValue == " container " ) { it . group = ITEM_GROUP_CONTAINER ; it . type = ITEM_TYPE_CONTAINER ; } else if ( tmpStrValue == " depo@@ t " ) { it . type = ITEM_TYPE_DEPO@@ T ; } else if ( tmpStrValue == " mail@@ box " ) { it . type = ITEM_TYPE_MAIL@@ BOX ; } else if ( tmpStrValue == " trashholder " ) { it . type = ITEM_TYPE_TRAS@@ HHO@@ LDER ; } else if ( tmpStrValue == " teleport " ) { it . type = ITEM_TYPE_TELEPORT ; } else if ( tmpStrValue == " door " ) { it . type = ITEM_TYPE_DOOR ; } else if ( tmpStrValue == " bed " ) { it . type = ITEM_TYPE_BED ; } else if ( tmpStrValue == " rune " ) { it . type = ITEM_TYPE_RUN@@ E ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ type : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " description " ) { it . description = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " runespell@@ name " ) { it . rune@@ SpellName = valueAttribute . as_string ( ) ; } else if ( tmpStrValue == " weight " ) { it . weight = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcount " ) { it . showCount = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " armor " ) { it . armor = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " defense " ) { it . defense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " extra@@ def " ) { it . extraDefense = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " attack " ) { it . attack = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " rotat@@ eto " ) { it . rotateTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " moveable " || tmpStrValue == " movable " ) { it . moveable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blockproject@@ ile " ) { it . blockProjectile = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowpickupable " || tmpStrValue == " pickupable " ) { it . allowPickupable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " floorchange " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " down " ) { it . floorChange = TILESTATE_FLOORCHANGE_DOWN ; } else if ( tmpStrValue == " north " ) { it . floorChange = TILESTATE_FLOORCHANGE_NORTH ; } else if ( tmpStrValue == " south " ) { it . floorChange = TILESTATE_FLOORCHANGE_S@@ OUT@@ H ; } else if ( tmpStrValue == " south@@ alt " ) { it . floorChange = TILESTATE_FLOORCHANGE_S@@ OUTH@@ _ALT ; } else if ( tmpStrValue == " west " ) { it . floorChange = TILESTATE_FLOORCHANGE_WEST ; } else if ( tmpStrValue == " east " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAS@@ T ; } else if ( tmpStrValue == " east@@ alt " ) { it . floorChange = TILESTATE_FLOORCHANGE_EAS@@ T_ALT ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ floorChange : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " corpsetype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " veno@@ m " ) { it . corpseType = RACE_VENOM ; } else if ( tmpStrValue == " blood " ) { it . corpseType = RACE_BLOOD ; } else if ( tmpStrValue == " undead " ) { it . corpseType = RACE_UNDEAD ; } else if ( tmpStrValue == " fire " ) { it . corpseType = RACE_FIRE ; } else if ( tmpStrValue == " energy " ) { it . corpseType = RACE_ENERGY ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ corpseType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " containersize " ) { it . maxItems = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fluidsource " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " water " ) { it . fluidSource = FLUID_WATER ; } else if ( tmpStrValue == " blood " ) { it . fluidSource = FLUID_BLOOD ; } else if ( tmpStrValue == " beer " ) { it . fluidSource = FLUID_BEER ; } else if ( tmpStrValue == " sli@@ me " ) { it . fluidSource = FLUID_S@@ LIME ; } else if ( tmpStrValue == " lemon@@ ade " ) { it . fluidSource = FLUID_LEMON@@ ADE ; } else if ( tmpStrValue == " mil@@ k " ) { it . fluidSource = FLUID_MILK ; } else if ( tmpStrValue == " mana " ) { it . fluidSource = FLUID_MANA ; } else if ( tmpStrValue == " lif@@ e " ) { it . fluidSource = FLUID_LIFE ; } else if ( tmpStrValue == " oil " ) { it . fluidSource = FLUID_OI@@ L ; } else if ( tmpStrValue == " urine " ) { it . fluidSource = FLUID_URINE ; } else if ( tmpStrValue == " coconut " ) { it . fluidSource = FLUID_COCON@@ UTMILK ; } else if ( tmpStrValue == " wine " ) { it . fluidSource = FLUID_WINE ; } else if ( tmpStrValue == " mud " ) { it . fluidSource = FLUID_MUD ; } else if ( tmpStrValue == " fruit@@ juice " ) { it . fluidSource = FLUID_F@@ RU@@ ITJU@@ ICE ; } else if ( tmpStrValue == " lava " ) { it . fluidSource = FLUID_LAVA ; } else if ( tmpStrValue == " rum " ) { it . fluidSource = FLUID_RUM ; } else if ( tmpStrValue == " swamp " ) { it . fluidSource = FLUID_S@@ WAMP ; } else if ( tmpStrValue == " tea " ) { it . fluidSource = FLUID_TEA ; } else if ( tmpStrValue == " mead " ) { it . fluidSource = FLUID_MEAD ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ fluidSource : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " readable " ) { it . canReadText = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " writeable " ) { it . canWriteText = valueAttribute . as_bool ( ) ; it . canReadText = it . canWriteText ; } else if ( tmpStrValue == " maxtext@@ len " ) { it . maxTextLen = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " writeonce@@ itemid " ) { it . writeOnceItemId = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " weapontype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " sword " ) { it . weaponType = WEAPON_S@@ WORD ; } else if ( tmpStrValue == " club " ) { it . weaponType = WEAPON_@@ CLUB ; } else if ( tmpStrValue == " axe " ) { it . weaponType = WEAPON_@@ AXE ; } else if ( tmpStrValue == " shield " ) { it . weaponType = WEAPON_S@@ HIELD ; } else if ( tmpStrValue == " distance " ) { it . weaponType = WEAPON_@@ DISTANCE ; } else if ( tmpStrValue == " wand " ) { it . weaponType = WEAPON_@@ WAND ; } else if ( tmpStrValue == " ammunit@@ ion " ) { it . weaponType = WEAPON_@@ AMMO ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ weaponType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " slottype " ) { tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " head " ) { it . slotPosition |= SLOTP_HEAD ; } else if ( tmpStrValue == " body " ) { it . slotPosition |= SLOTP_ARMOR ; } else if ( tmpStrValue == " legs " ) { it . slotPosition |= SLOTP_LEGS ; } else if ( tmpStrValue == " feet " ) { it . slotPosition |= SLOTP_F@@ EET ; } else if ( tmpStrValue == " backpack " ) { it . slotPosition |= SLOTP_BACK@@ PACK ; } else if ( tmpStrValue == " two - handed " ) { it . slotPosition |= SLOTP_TWO_@@ HAND ; } else if ( tmpStrValue == " right - hand " ) { it . slotPosition &= ~ SLOTP_LEFT ; } else if ( tmpStrValue == " left - hand " ) { it . slotPosition &= ~ SLOTP_RIGHT ; } else if ( tmpStrValue == " neck@@ lace " ) { it . slotPosition |= SLOTP_NEC@@ KLACE ; } else if ( tmpStrValue == " ring " ) { it . slotPosition |= SLOTP_RING ; } else if ( tmpStrValue == " ammo " ) { it . slotPosition |= SLOTP_AMMO ; } else if ( tmpStrValue == " hand " ) { it . slotPosition |= SLOTP_HAND ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ slotType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " ammo@@ type " ) { it . ammoType = getAmmo@@ Type ( valueAttribute . as_string ( ) ) ; if ( it . ammoType == AMMO_NONE ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ ammoType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " shoot@@ type " ) { Shoot@@ Type_t shoot = getShoot@@ Type ( valueAttribute . as_string ( ) ) ; if ( shoot != CONST_ANI_NONE ) { it . shootType = shoot ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ shootType : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " effect " ) { Magic@@ EffectClasses effect = getMagicEffect ( valueAttribute . as_string ( ) ) ; if ( effect != CONST_ME_NONE ) { it . magicEffect = effect ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ effect : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } } else if ( tmpStrValue == " range " ) { it . shootRange = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " stopd@@ uration " ) { it . stopTime = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " decay@@ to " ) { it . decayTo = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transfor@@ mequipto " ) { it . transformEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " transformdeequipto " ) { it . transformDeEquipTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " duration " ) { it . decayTime = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showduration " ) { it . showDuration = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " charges " ) { it . charges = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " showcharges " ) { it . showCharges = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " showattributes " ) { it . showAttributes = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " hitchance " ) { it . hitChance = std :: min < int8_t > ( 100 , std :: max < int8_t > ( - 100 , pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ) ) ; } else if ( tmpStrValue == " maxhit@@ chance " ) { it . maxHitChance = std :: min < uint32_t > ( 100 , pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " invisible " ) { it . getAbilities ( ) . invisible = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " speed " ) { it . getAbilities ( ) . speed = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " health@@ gain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . health@@ Gain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " health@@ ticks " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . health@@ Ticks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manag@@ ain " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . mana@@ Gain = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manatick@@ s " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . regeneration = true ; abilities . mana@@ Ticks = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " manashi@@ eld " ) { it . getAbilities ( ) . mana@@ Shield = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " skillsword " ) { it . getAbilities ( ) . skills [ SKILL_S@@ WORD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillaxe " ) { it . getAbilities ( ) . skills [ SKILL_@@ AXE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillclub " ) { it . getAbilities ( ) . skills [ SKILL_@@ CLUB ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skilldist " ) { it . getAbilities ( ) . skills [ SKILL_@@ DISTANCE ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfish " ) { it . getAbilities ( ) . skills [ SKILL_FI@@ SHING ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillshield " ) { it . getAbilities ( ) . skills [ SKILL_S@@ HIELD ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " skillfist " ) { it . getAbilities ( ) . skills [ SKILL_FI@@ ST ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhit@@ points " ) { it . getAbilities ( ) . stats [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxhit@@ pointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXHITPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmana@@ points " ) { it . getAbilities ( ) . stats [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " maxmana@@ pointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAXMANAPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpoints " || tmpStrValue == " magiclevelpoints " ) { it . getAbilities ( ) . stats [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " magicpointspercent " ) { it . getAbilities ( ) . statsPercent [ STAT_MAGICPOINTS ] = pugi :: cast < int32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercent@@ energy " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercent@@ fire " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " fieldabsorbpercent@@ poison " || tmpStrValue == " fieldabsor@@ percentearth " ) { it . getAbilities ( ) . fieldAbsorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentall " || tmpStrValue == " absorbpercentallelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; for ( size_t i = 0 ; i < COMBAT_COUNT ; ++ i ) { abilities . absorbPercent [ i ] += value ; } } else if ( tmpStrValue == " absorbpercentelements " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentmag@@ ic " ) { int16_t value = pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; Abilities & abilities = it . getAbilities ( ) ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += value ; abilities . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += value ; } else if ( tmpStrValue == " absorbpercentenergy " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_ENERGYDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentfire " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_FIREDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentpoison " || tmpStrValue == " absorbpercentearth " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_EARTHDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentlif@@ edrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_LIFE@@ DRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentmanadrain " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_MAN@@ ADRAIN ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentphysical " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_PHYSICALDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentheal@@ ing " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_HEAL@@ ING ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " absorbpercentundefined " ) { it . getAbilities ( ) . absorbPercent [ combatTypeToIndex ( COMBAT_UNDEFIN@@ EDDAMAGE ) ] += pugi :: cast < int16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " suppress@@ drun@@ k " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_DRUNK ; } } else if ( tmpStrValue == " suppress@@ energy " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_ENERGY ; } } else if ( tmpStrValue == " suppress@@ fire " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_FIRE ; } } else if ( tmpStrValue == " suppress@@ poison " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_POISON ; } } else if ( tmpStrValue == " suppress@@ physical " ) { if ( valueAttribute . as_bool ( ) ) { it . getAbilities ( ) . conditionSuppressions |= CONDITION_BLEEDING ; } } else if ( tmpStrValue == " field " ) { it . group = ITEM_GROUP_MAGICFIELD ; it . type = ITEM_TYPE_MAGICFIELD ; Combat@@ Type_t combatType = COMBAT_NONE ; ConditionDamage * conditionDamage = nullptr ; tmpStrValue = asLowerCaseString ( valueAttribute . as_string ( ) ) ; if ( tmpStrValue == " fire " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_FIRE ) ; combatType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " energy " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_ENERGY ) ; combatType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " poison " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_POISON ) ; combatType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " physical " ) { conditionDamage = new ConditionDamage ( CONDITIONID_COMBAT , CONDITION_BLEEDING ) ; combatType = COMBAT_PHYSICALDAMAGE ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ field ▁ value : ▁ " << valueAttribute . as_string ( ) << std :: endl ; } if ( combatType != COMBAT_NONE ) { it . combatType = combatType ; it . conditionDamage . reset ( conditionDamage ) ; uint32_t ticks = 0 ; int32_t damage = 0 ; int32_t start = 0 ; int32_t count = 1 ; for ( auto subAttributeNode : attributeNode . children ( ) ) { pugi :: xml_attribute subKeyAttribute = subAttributeNode . attribute ( " key " ) ; if ( ! subKeyAttribute ) { continue ; } pugi :: xml_attribute subValueAttribute = subAttributeNode . attribute ( " value " ) ; if ( ! subValueAttribute ) { continue ; } tmpStrValue = asLowerCaseString ( subKeyAttribute . as_string ( ) ) ; if ( tmpStrValue == " ticks " ) { ticks = pugi :: cast < uint32_t > ( subValueAttribute . value ( ) ) ; } else if ( tmpStrValue == " count " ) { count = std :: max < int32_t > ( 1 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " start " ) { start = std :: max < int32_t > ( 0 , pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ) ; } else if ( tmpStrValue == " damage " ) { damage = - pugi :: cast < int32_t > ( subValueAttribute . value ( ) ) ; if ( start > 0 ) { std :: list < int32_t > damageList ; ConditionDamage :: generate@@ Damage@@ List ( damage , start , damageList ) ; for ( int32_t damageValue : damageList ) { conditionDamage -> addDamage ( 1 , ticks , - damageValue ) ; } start = 0 ; } else { conditionDamage -> addDamage ( count , ticks , damage ) ; } } } conditionDamage -> setParam ( CONDITION_PARAM@@ _FI@@ ELD , 1 ) ; if ( conditionDamage -> getTotal@@ Damage ( ) > 0 ) { conditionDamage -> setParam ( CONDITION_PARAM@@ _FORCE@@ UPDATE , 1 ) ; } } } else if ( tmpStrValue == " replaceable " ) { it . replaceable = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " partnerdirection " ) { it . bedPartnerDir = getDirection ( valueAttribute . as_string ( ) ) ; } else if ( tmpStrValue == " leveldoor " ) { it . levelDoor = pugi :: cast < uint32_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " sle@@ eper " ) { uint16_t value = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; it . transformToOnUse = value ; ItemType & other = getItemType ( value ) ; if ( other . transformToFree == 0 ) { other . transformToFree = it . id ; } if ( it . transformToOnUse == 0 ) { it . transformToOnUse = value ; } } else if ( tmpStrValue == " transformto " ) { it . transformToFree = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " destroy@@ to " ) { it . destroyTo = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; } else if ( tmpStrValue == " elementearth " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_EARTHDAMAGE ; } else if ( tmpStrValue == " elementfire " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_FIREDAMAGE ; } else if ( tmpStrValue == " elementenergy " ) { Abilities & abilities = it . getAbilities ( ) ; abilities . elementDamage = pugi :: cast < uint16_t > ( valueAttribute . value ( ) ) ; abilities . elementType = COMBAT_ENERGYDAMAGE ; } else if ( tmpStrValue == " walk@@ stack " ) { it . walkStack = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " blocking " ) { it . blockSolid = valueAttribute . as_bool ( ) ; } else if ( tmpStrValue == " allowdistread " ) { it . allowDistRead = booleanString ( valueAttribute . as_string ( ) ) ; } else { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Unknown ▁ key ▁ value : ▁ " << keyAttribute . as_string ( ) << std :: endl ; } } if ( ( it . transformToFree != 0 || it . transformToOnUse != 0 || it . transformToOnUse != 0 ) && it . type != ITEM_TYPE_BED ) { std :: cout << " [ Warning ▁ - ▁ Items : : parseItemNode ] ▁ Item ▁ " << it . id << " ▁ is ▁ not ▁ set ▁ as ▁ a ▁ bed - type " << std :: endl ; } } ItemType & Items :: getItemType ( size_t id ) { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemType ( size_t id ) const { if ( id < items . size ( ) ) { return items [ id ] ; } return items . front ( ) ; } const ItemType & Items :: getItemId@@ ByClient@@ Id ( uint16_t spriteId ) const { auto it = reverseItemMap . find ( spriteId ) ; if ( it != reverseItemMap . end ( ) ) { return getItemType ( it -> second ) ; } return items . front ( ) ; } uint16_t Items :: getItemId@@ ByName ( const std :: string & name ) { if ( name . empty ( ) ) { return 0 ; } const char * itemName = name . c_str ( ) ; for ( size_t i = 100 , size = items . size ( ) ; i < size ; ++ i ) { if ( strcasecmp ( itemName , items [ i ] . name . c_str ( ) ) == 0 ) { return i ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="z@@ acli@@ mon/android_@@ kernel@@ _samsung_@@ kyle@@ pro/tree/master/@@ tools/@@ gator@@ /da@@ emon/@@ LocalCapture@@ .cpp"> # include < sys / stat . h > # include < sys / types . h > # include < dirent . h > # include < string . h > # include < stdlib . h > # include < unistd . h > # include " LocalCapture . h " # include " SessionData . h " # include " Logging . h " # include " Oly@@ Utility . h " # include " EventsXML . h " LocalCapture :: LocalCapture ( ) { } LocalCapture :: ~ LocalCapture ( ) { } void LocalCapture :: createAPC@@ Directory ( char * target_path ) { gSessionData -> mAPCDir = createUniqueDirectory ( target_path , " . apc " ) ; if ( ( removeDirAndAllContents ( gSessionData -> mAPCDir ) != 0 || mkdir ( gSessionData -> mAPCDir , S_IRWX@@ U | S_IRWX@@ G | S_I@@ ROTH | S_IX@@ OTH ) != 0 ) ) { logg -> logError ( __FILE__ , __LINE__ , " Unable ▁ to ▁ create ▁ directory ▁ % s " , gSessionData -> mAPCDir ) ; handleException ( ) ; } } void LocalCapture :: write ( char * string ) { char file [ PATH_MAX ] ; snprintf ( file , PATH_MAX , " % s / session . xml " , gSessionData -> mAPCDir ) ; if ( util -> writeTo@@ Disk ( file , string ) < 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Error ▁ writing ▁ % s \n Please ▁ verify ▁ the ▁ path . " , file ) ; handleException ( ) ; } EventsXML eventsXML ; eventsXML . write ( gSessionData -> mAPCDir ) ; } char * LocalCapture :: createUniqueDirectory ( const char * initialPath , const char * ending ) { char * output ; char path [ PATH_MAX ] ; if ( initialPath == 0 || strlen ( initialPath ) == 0 ) { logg -> logError ( __FILE__ , __LINE__ , " Missing ▁ - o ▁ command ▁ line ▁ option ▁ required ▁ for ▁ a ▁ local ▁ capture . " ) ; handleException ( ) ; } else if ( initialPath [ 0 ] != ' / ' ) { if ( getcwd ( path , PATH_MAX ) == 0 ) { logg -> logMessage ( " Unable ▁ to ▁ retrieve ▁ the ▁ current ▁ working ▁ directory " ) ; } strncat ( path , " / " , PATH_MAX - strlen ( path ) - 1 ) ; strncat ( path , initialPath , PATH_MAX - strlen ( path ) - 1 ) ; } else { strncpy ( path , initialPath , PATH_MAX ) ; path [ PATH_MAX - 1 ] = 0 ; } if ( strcmp ( & path [ strlen ( path ) - strlen ( ending ) ] , ending ) != 0 ) { strncat ( path , ending , PATH_MAX - strlen ( path ) - 1 ) ; } output = strdup ( path ) ; return output ; } int LocalCapture :: removeDirAndAllContents ( char * path ) { int error = 0 ; struct stat mFileInfo ; if ( stat ( path , & mFileInfo ) == 0 ) { if ( mFileInfo . st_mode & S_IF@@ DIR ) { DIR * dir = opendir ( path ) ; dirent * entry = readdir ( dir ) ; while ( entry ) { if ( strcmp ( entry -> d_name , " . " ) != 0 && strcmp ( entry -> d_name , " . . " ) != 0 ) { char * newpath = ( char * ) malloc ( strlen ( path ) + strlen ( entry -> d_name ) + 2 ) ; sprintf ( newpath , " % s / % s " , path , entry -> d_name ) ; error = removeDirAndAllContents ( newpath ) ; free ( newpath ) ; if ( error ) { break ; } } entry = readdir ( dir ) ; } closedir ( dir ) ; if ( error == 0 ) { error = rmdir ( path ) ; } } else { error = remove ( path ) ; } } return error ; } void LocalCapture :: copyImages ( ImageLink@@ List * ptr ) { char dstfilename [ PATH_MAX ] ; while ( ptr ) { strncpy ( dstfilename , gSessionData -> mAPCDir , PATH_MAX ) ; dstfilename [ PATH_MAX - 1 ] = 0 ; if ( gSessionData -> mAPCDir [ strlen ( gSessionData -> mAPCDir ) - 1 ] != ' / ' ) { strncat ( dstfilename , " / " , PATH_MAX - strlen ( dstfilename ) - 1 ) ; } strncat ( dstfilename , util -> getFile@@ Part ( ptr -> path ) , PATH_MAX - strlen ( dstfilename ) - 1 ) ; if ( util -> copyFile ( ptr -> path , dstfilename ) ) { logg -> logMessage ( " copied ▁ file ▁ % s ▁ to ▁ % s " , ptr -> path , dstfilename ) ; } else { logg -> logMessage ( " copy ▁ of ▁ file ▁ % s ▁ to ▁ % s ▁ failed " , ptr -> path , dstfilename ) ; } ptr = ptr -> next ; } } </DOCUMENT>
<DOCUMENT_ID="b@@ redel@@ ings/@@ BAli@@ -Ph@@ y/tree/master/@@ external/@@ range-@@ v3@@ /0.@@ 4.0@@ /test/algorithm/@@ minmax.cpp"> # include < range / v3 / algorithm / minmax . hpp > # include < memory > # include < numeric > # include < random > # include < algorithm > # include " . . / simple _ test . hpp " # include " . . / test _ utils . hpp " # include " . . / test _ iterators . hpp " RANGES_@@ DIAG@@ NOSTI@@ C_IGNORE_@@ GLOBAL_@@ CONSTR@@ UCTORS namespace { std :: mt19937 gen ; template < class Iter , class Sent = Iter > void test_iter ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! ( * i < res . first ) ) ; CHECK ( ! ( res . second < * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter ( ) { test_iter < Iter , Sent > ( 1 ) ; test_iter < Iter , Sent > ( 2 ) ; test_iter < Iter , Sent > ( 3 ) ; test_iter < Iter , Sent > ( 10 ) ; test_iter < Iter , Sent > ( 1000 ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( Iter first , Sent last ) { RANGES_ENSURE ( first != last ) ; typedef std :: greater < int > Compare ; Compare comp ; auto rng = ranges :: make_iterator_range ( first , last ) ; auto res = ranges :: minmax ( rng , comp ) ; for ( Iter i = first ; i != last ; ++ i ) { CHECK ( ! comp ( * i , res . first ) ) ; CHECK ( ! comp ( res . second , * i ) ) ; } } template < class Iter , class Sent = Iter > void test_iter_comp ( unsigned N ) { RANGES_ENSURE ( N > 0 ) ; std :: unique_ptr < int [ ] > a { new int [ N ] } ; std :: iota ( a . get ( ) , a . get ( ) + N , 0 ) ; std :: shuffle ( a . get ( ) , a . get ( ) + N , gen ) ; test_iter_comp ( Iter ( a . get ( ) ) , Sent ( a . get ( ) + N ) ) ; } template < class Iter , class Sent = Iter > void test_iter_comp ( ) { test_iter_comp < Iter , Sent > ( 1 ) ; test_iter_comp < Iter , Sent > ( 2 ) ; test_iter_comp < Iter , Sent > ( 3 ) ; test_iter_comp < Iter , Sent > ( 10 ) ; test_iter_comp < Iter , Sent > ( 1000 ) ; } struct S { int value ; int index ; } ; } int main ( ) { test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < input_iterator < const int * > > ( ) ; test_iter < forward_iterator < const int * > > ( ) ; test_iter < bidirectional_iterator < const int * > > ( ) ; test_iter < random_access_iterator < const int * > > ( ) ; test_iter < const int * > ( ) ; test_iter < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < input_iterator < const int * > > ( ) ; test_iter_comp < forward_iterator < const int * > > ( ) ; test_iter_comp < bidirectional_iterator < const int * > > ( ) ; test_iter_comp < random_access_iterator < const int * > > ( ) ; test_iter_comp < const int * > ( ) ; test_iter_comp < input_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < forward_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < bidirectional_iterator < const int * > , sentinel < const int * >> ( ) ; test_iter_comp < random_access_iterator < const int * > , sentinel < const int * >> ( ) ; S s [ ] = { S { 1 , 0 } , S { 2 , 1 } , S { 3 , 2 } , S { 4 , 3 } , S { - 4 , 4 } , S { 40 , 5 } , S { - 4 , 6 } , S { 40 , 7 } , S { 7 , 8 } , S { 8 , 9 } , S { 9 , 10 } } ; auto res = ranges :: minmax ( s , std :: less < int > { } , & S :: value ) ; CHECK ( res . first . value == - 4 ) ; CHECK ( res . first . index == 4 ) ; CHECK ( res . second . value == 40 ) ; CHECK ( res . second . index == 7 ) ; return test_result ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Su@@ mahith@@ a/samples/tree/master/@@ AllJoyn/Samples/@@ BACnetAdapter@@ /He@@ adless@@ Adapter@@ App/p@@ ch.cpp"> # include " pch . h " </DOCUMENT>
<DOCUMENT_ID="liuch@@ uo/@@ LeetCode@@ -pra@@ ctice@@ /tree/master/C++/@@ 079. Word Search@@ .cpp"> 79. Word Search Given a 2D board and a word , find if the word exists in the grid . The word can be constructed from letters of sequentially adjacent cell , where " adjacent " cells are tho@@ se horizont@@ ally or vertic@@ ally neigh@@ bor@@ ing . The same letter cell may not be used more than once . For example , Given board = [ [ ' A ' , ' B ' , ' C ' , ' E ' ] , [ ' S ' , ' F ' , ' C ' , ' S ' ] , [ ' A ' , ' D ' , ' E ' , ' E ' ] ] word = " ABCC@@ ED " , -> returns true , word = " SEE " , -> returns true , word = " ABCB " , -> returns false . 题目@@ 大意@@ ：给@@ 一个@@ char型二维数组@@ 和一个@@ word字符串，@@ 寻找网格@@ 中是否@@ 含有@@ word字符串，@@ 只能通@@ 过相邻@@ （垂@@ 直或@@ 者水@@ 平）@@ 的格@@ 子连@@ 接～ 分析@@ ：对@@ 于二维数组@@ 中的每@@ 一个@@ 点都@@ 开始@@ 遍历@@ ，如果当前@@ 点的字@@ 母正好@@ 等于word [ 0 ] 就进@@ 入dfs@@ ，设立@@ flag@@ 标记是否@@ 找到@@ ，设立@@ visit@@ 标记是否@@ 访问@@ ： 首先@@ 令起@@ 始节@@ 点visit [ j ] [ k ] 标记@@ 为已@@ 经访问@@ 过，接@@ 着dfs@@ ，如果@@ flag为true@@ 直接return@@ ，如果当前@@ index正好@@ 为word@@ 的最后@@ 一个@@ 字符@@ 下标就@@ 标记@@ flag为true@@ ，return 。 从四@@ 个方@@ 向开始@@ 对结点@@ 进行@@ 深度@@ 优先搜索@@ ，首先@@ 要保@@ 证搜索@@ 的结@@ 点满足@@ ：1 . 是合@@ 法的在@@ 网格@@ 之内@@ 的 2 . 未被@@ 访问@@ 过 3 . 当前@@ 字符@@ 与要@@ 找的word [ index + 1 ] 相同 。 满足@@ 则标记@@ visit [ tx ] [ ty ] = true , 且dfs tx和ty@@ 以及@@ index + 1 ， 两个dfs@@ 后要@@ 把他@@ 重新@@ 置为false ～ 这样@@ 最后@@ 返回@@ flag@@ 的值@@ 即为@@ 是否@@ 能找到@@ 的结@@ 果～ class Solution { private : bool flag = false ; vector < vector < bool >> visit ; vector < vector < char >> board ; string word = " " ; int dir [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; int m , n ; public : bool exist ( vector < vector < char >> & board , string word ) { if ( board . size ( ) == 0 ) return word == " " ; m = board . size ( ) , n = board [ 0 ] . size ( ) ; this -> word = word ; this -> board = board ; visit . resize ( m , vector < bool > ( n ) ) ; for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( board [ j ] [ k ] == word [ 0 ] ) { visit [ j ] [ k ] = true ; dfs ( j , k , 0 ) ; visit [ j ] [ k ] = false ; } } } return flag ; } void dfs ( int x , int y , int index ) { if ( flag == true ) return ; if ( index == word . length ( ) - 1 ) { flag = true ; return ; } for ( int i = 0 ; i < 4 ; i ++ ) { int tx = x + dir [ i ] [ 0 ] , ty = y + dir [ i ] [ 1 ] ; if ( tx >= 0 && tx < m && ty >= 0 && ty < n && board [ tx ] [ ty ] == word [ index + 1 ] && visit [ tx ] [ ty ] == false ) { visit [ tx ] [ ty ] = true ; dfs ( tx , ty , index + 1 ) ; visit [ tx ] [ ty ] = false ; } } } } ; </DOCUMENT>
<DOCUMENT_ID="al@@ essonrenato@@ /TrinityCore/tree/master/src/server/game/@@ Battlegrounds/Zon@@ es/BattlegroundAB@@ .cpp"> # include " BattlegroundAB . h " # include " WorldPacket . h " # include " BattlegroundMgr . h " # include " Creature . h " # include " Language . h " # include " Player . h " # include " Util . h " # include " WorldSession . h " BattlegroundAB :: BattlegroundAB ( ) { m_IsInformedNearVictory = false ; m_Buff@@ Change = true ; BgObjects . resize ( BG_AB_OBJECT_MAX ) ; BgCreatures . resize ( BG_AB_ALL_NODES_COUNT + 5 ) ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; m_BannerTimers [ i ] . type = 0 ; m_BannerTimers [ i ] . teamIndex = 0 ; } for ( uint8 i = 0 ; i < BG_TEAMS_COUNT ; ++ i ) { m_lastTick [ i ] = 0 ; m_HonorScoreTics [ i ] = 0 ; m_ReputationScoreTics [ i ] = 0 ; m_TeamScores500Disadvantage [ i ] = false ; } m_HonorTics = 0 ; m_ReputationTics = 0 ; StartMessageIds [ BG_STARTING_EVENT_@@ FIRST ] = LANG_BG_AB_START_@@ TWO_@@ MINUTES ; StartMessageIds [ BG_STARTING_@@ EVENT_S@@ ECOND ] = LANG_BG_AB_START_@@ ONE_MINUTE ; StartMessageIds [ BG_STARTING_EVENT_@@ THIRD ] = LANG_BG_AB_START_@@ HALF_MINUTE ; StartMessageIds [ BG_STARTING_@@ EVENT_FOURTH ] = LANG_BG_AB_HAS_BEGUN ; } BattlegroundAB :: ~ BattlegroundAB ( ) { } void BattlegroundAB :: PostUpdateImpl ( uint32 diff ) { if ( GetStatus ( ) == STATUS_IN_PROGRESS ) { int team_points [ BG_TEAMS_COUNT ] = { 0 , 0 } ; for ( int node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) { if ( m_BannerTimers [ node ] . timer ) { if ( m_BannerTimers [ node ] . timer > diff ) m_BannerTimers [ node ] . timer -= diff ; else { m_BannerTimers [ node ] . timer = 0 ; _CreateBanner ( node , m_BannerTimers [ node ] . type , m_BannerTimers [ node ] . teamIndex , false ) ; } } if ( m_NodeTimers [ node ] ) { if ( m_NodeTimers [ node ] > diff ) m_NodeTimers [ node ] -= diff ; else { m_NodeTimers [ node ] = 0 ; uint8 teamIndex = m_Nodes [ node ] - 1 ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] += 2 ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeOccupied ( node , ( teamIndex == 0 ) ? ALLIANCE : HORDE ) ; if ( teamIndex == 0 ) { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_@@ ALLIANCE ) ; } else { SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; PlaySoundToAll ( BG_AB_SOUND_NODE_CAPTURED_@@ HORDE ) ; } } } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) if ( m_Nodes [ node ] == team + BG_AB_NODE_TYPE_OCCUPIED ) ++ team_points [ team ] ; } for ( int team = 0 ; team < BG_TEAMS_COUNT ; ++ team ) { int points = team_points [ team ] ; if ( ! points ) continue ; m_lastTick [ team ] += diff ; if ( m_lastTick [ team ] > BG_AB_TickIntervals [ points ] ) { m_lastTick [ team ] -= BG_AB_TickIntervals [ points ] ; m_TeamScores [ team ] += BG_AB_TickPoints [ points ] ; m_HonorScoreTics [ team ] += BG_AB_TickPoints [ points ] ; m_ReputationScoreTics [ team ] += BG_AB_TickPoints [ points ] ; if ( m_ReputationScoreTics [ team ] >= m_ReputationTics ) { ( team == TEAM_ALLIANCE ) ? RewardReputationToTeam ( 509 , 10 , ALLIANCE ) : RewardReputationToTeam ( 510 , 10 , HORDE ) ; m_ReputationScoreTics [ team ] -= m_ReputationTics ; } if ( m_HonorScoreTics [ team ] >= m_HonorTics ) { RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ( team == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; m_HonorScoreTics [ team ] -= m_HonorTics ; } if ( ! m_IsInformedNearVictory && m_TeamScores [ team ] > BG_AB_WARNING_NEAR_VICTORY_SCORE ) { if ( team == TEAM_ALLIANCE ) SendMessageToAll ( LANG_BG_AB_A_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; else SendMessageToAll ( LANG_BG_AB_H_NEAR_VICTORY , CHAT_MSG_BG_SYSTEM_NEUTRAL ) ; PlaySoundToAll ( BG_AB_SOUND_NEAR_VICTORY ) ; m_IsInformedNearVictory = true ; } if ( m_TeamScores [ team ] > BG_AB_MAX_TEAM_SCORE ) m_TeamScores [ team ] = BG_AB_MAX_TEAM_SCORE ; if ( team == TEAM_ALLIANCE ) UpdateWorldState ( BG_AB_OP_RESOURCES_ALLY , m_TeamScores [ team ] ) ; else if ( team == TEAM_HORDE ) UpdateWorldState ( BG_AB_OP_RESOURCES_HORDE , m_TeamScores [ team ] ) ; uint8 otherTeam = ( team + 1 ) % BG_TEAMS_COUNT ; if ( m_TeamScores [ team ] > m_TeamScores [ otherTeam ] + 500 ) m_TeamScores500Disadvantage [ otherTeam ] = true ; } } if ( m_TeamScores [ TEAM_ALLIANCE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( ALLIANCE ) ; else if ( m_TeamScores [ TEAM_HORDE ] >= BG_AB_MAX_TEAM_SCORE ) EndBattleground ( HORDE ) ; } } void BattlegroundAB :: StartingEvent@@ CloseDoors ( ) { for ( int obj = BG_AB_OBJECT_BANNER_NEUTRAL ; obj < BG_AB_DYNAMIC_NODES_COUNT * 8 ; ++ obj ) SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT * 3 ; ++ i ) SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + i , RESPAWN_ONE_DAY ) ; DoorClose ( BG_AB_OBJECT_GATE_A ) ; DoorClose ( BG_AB_OBJECT_GATE_H ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_A , RESPAWN_IMMEDIATELY ) ; SpawnBGObject ( BG_AB_OBJECT_GATE_H , RESPAWN_IMMEDIATELY ) ; _NodeOccupied ( BG_AB_SPIRIT_@@ ALIANCE , ALLIANCE ) ; _NodeOccupied ( BG_AB_SPIRIT_@@ HORDE , HORDE ) ; } void BattlegroundAB :: StartingEvent@@ OpenDoors ( ) { for ( int banner = BG_AB_OBJECT_BANNER_NEUTRAL , i = 0 ; i < 5 ; banner += 8 , ++ i ) SpawnBGObject ( banner , RESPAWN_IMMEDIATELY ) ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { uint8 buff = urand ( 0 , 2 ) ; SpawnBGObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3 , RESPAWN_IMMEDIATELY ) ; } DoorOpen ( BG_AB_OBJECT_GATE_A ) ; DoorOpen ( BG_AB_OBJECT_GATE_H ) ; StartTimedAchievement ( ACHIEVEMENT_TIMED_TYPE_EVENT , AB_@@ EVENT_START_@@ BATTLE ) ; } void BattlegroundAB :: AddPlayer ( Player * player ) { Battleground :: AddPlayer ( player ) ; PlayerScor@@ es [ player -> GetGUID ( ) ] = new BattlegroundAB@@ Score ( player -> GetGUID ( ) , player -> GetBG@@ Team ( ) ) ; } void BattlegroundAB :: RemovePlayer ( Player * , ObjectGuid , uint32 ) { } void BattlegroundAB :: HandleAreaTrigger ( Player * player , uint32 trigger , bool entered ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; switch ( trigger ) { case 3948 : if ( player -> GetTeam ( ) != ALLIANCE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Alliance ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3949 : if ( player -> GetTeam ( ) != HORDE ) player -> GetSession ( ) -> SendNotification ( " Only ▁ The ▁ Hor@@ de ▁ can ▁ use ▁ that ▁ portal " ) ; else player -> LeaveBattleground ( ) ; break ; case 3866 : case 386@@ 9 : case 3867 : case 386@@ 8 : case 3870 : case 4020 : case 4021 : case 4674 : default : Battleground :: HandleAreaTrigger ( player , trigger , entered ) ; break ; } } void BattlegroundAB :: _CreateBanner ( uint8 node , uint8 type , uint8 teamIndex , bool delay ) { if ( delay ) { m_BannerTimers [ node ] . timer = 2000 ; m_BannerTimers [ node ] . type = type ; m_BannerTimers [ node ] . teamIndex = teamIndex ; return ; } uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_IMMEDIATELY ) ; } void BattlegroundAB :: _DelBanner ( uint8 node , uint8 type , uint8 teamIndex ) { uint8 obj = node * 8 + type + teamIndex ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; if ( ! type ) return ; obj = node * 8 + ( ( type == BG_AB_NODE_TYPE_OCCUPIED ) ? ( 5 + teamIndex ) : 7 ) ; SpawnBGObject ( obj , RESPAWN_ONE_DAY ) ; } int32 BattlegroundAB :: _GetNodeNameId ( uint8 node ) { switch ( node ) { case BG_AB_NODE_STABLES : return LANG_BG_AB_NODE_STABLES ; case BG_AB_NODE_BLACKSMITH : return LANG_BG_AB_NODE_BLACKSMITH ; case BG_AB_NODE_FARM : return LANG_BG_AB_NODE_FARM ; case BG_AB_NODE_LUMBER_MILL : return LANG_BG_AB_NODE_LUMBER_MILL ; case BG_AB_NODE_GOLD_MINE : return LANG_BG_AB_NODE_GOLD_MINE ; default : ABORT ( ) ; } return 0 ; } void BattlegroundAB :: FillInitialWorldStates ( WorldPackets :: WorldState :: InitWorldStates & packet ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODEICONS [ node ] ) , int32 ( ( m_Nodes [ node ] == 0 ) ? 1 : 0 ) ) ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) for ( uint8 i = 1 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_NODESTATES [ node ] + plusArray [ i ] ) , int32 ( ( m_Nodes [ node ] == i ) ? 1 : 0 ) ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 node = 0 ; node < BG_AB_DYNAMIC_NODES_COUNT ; ++ node ) if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_ALLY ) , int32 ( ally ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_OCCUPIED_BASES_HORDE ) , int32 ( horde ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_@@ MAX ) , int32 ( BG_AB_MAX_TEAM_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_@@ WARNING ) , int32 ( BG_AB_WARNING_NEAR_VICTORY_SCORE ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_ALLY ) , int32 ( m_TeamScores [ TEAM_ALLIANCE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( BG_AB_OP_RESOURCES_HORDE ) , int32 ( m_TeamScores [ TEAM_HORDE ] ) ) ; packet . Worldstates . emplace_back ( uint32 ( 0x745 ) , 0x2 ) ; } void BattlegroundAB :: _SendNodeUpdate ( uint8 node ) { const uint8 plusArray [ ] = { 0 , 2 , 3 , 0 , 1 } ; if ( m_prevNodes [ node ] ) UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_prevNodes [ node ] ] , 0 ) ; else UpdateWorldState ( BG_AB_OP_NODEICONS [ node ] , 0 ) ; UpdateWorldState ( BG_AB_OP_NODESTATES [ node ] + plusArray [ m_Nodes [ node ] ] , 1 ) ; uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_ALLY , ally ) ; UpdateWorldState ( BG_AB_OP_OCCUPIED_BASES_HORDE , horde ) ; } void BattlegroundAB :: _NodeOccupied ( uint8 node , Team team ) { if ( ! AddSpirit@@ Guide ( node , BG_AB_SpiritGui@@ dePos [ node ] , GetTeamIndexByTeamId ( team ) ) ) TC_LOG_ERROR ( " bg . batt@@ leground " , " Failed ▁ to ▁ spawn ▁ spirit ▁ guide ! ▁ point : ▁ % u , ▁ team : ▁ % u , ▁ " , node , team ) ; if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; uint8 capturedNodes = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == GetTeamIndexByTeamId ( team ) + BG_AB_NODE_TYPE_OCCUPIED && ! m_NodeTimers [ i ] ) ++ capturedNodes ; if ( capturedNodes >= 5 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_@@ 5_@@ BASES , team ) ; if ( capturedNodes >= 4 ) CastSpellOnTeam ( SPELL_AB_QUEST_REWARD_@@ 4_BASES , team ) ; Creature * trigger = ! BgCreatures [ node + 7 ] ? GetBG@@ Creature ( node + 7 ) : NULL ; if ( ! trigger ) trigger = AddCreature ( WORLD_@@ TRIGGER , node + 7 , BG_AB_NodePositions [ node ] , GetTeamIndexByTeamId ( team ) ) ; if ( trigger ) { trigger -> setFaction ( team == ALLIANCE ? 84 : 83 ) ; trigger -> CastSpell ( trigger , SPELL_HONORABLE_@@ DEFENDER_@@ 25Y , false ) ; } } void BattlegroundAB :: _NodeDeOccupied ( uint8 node ) { if ( node >= BG_AB_DYNAMIC_NODES_COUNT ) return ; if ( node < BG_AB_DYNAMIC_NODES_COUNT ) DelCreature ( node + 7 ) ; Reloc@@ ateDe@@ adPlay@@ ers ( BgCreatures [ node ] ) ; DelCreature ( node ) ; } void BattlegroundAB :: EventPlayer@@ Clicked@@ OnFlag ( Player * source , GameObject * ) { if ( GetStatus ( ) != STATUS_IN_PROGRESS ) return ; uint8 node = BG_AB_NODE_STABLES ; GameObject * obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + 7 ] ) ; while ( ( node < BG_AB_DYNAMIC_NODES_COUNT ) && ( ( ! obj ) || ( ! source -> IsWithinDistInMap ( obj , 10 ) ) ) ) { ++ node ; obj = GetBgMap ( ) -> GetGameObject ( BgObjects [ node * 8 + BG_AB_OBJECT_AURA_CONTESTED ] ) ; } if ( node == BG_AB_DYNAMIC_NODES_COUNT ) { return ; } TeamId teamIndex = GetTeamIndexByTeamId ( source -> GetTeam ( ) ) ; if ( ! ( m_Nodes [ node ] == 0 || teamIndex == m_Nodes [ node ] % 2 ) ) return ; source -> RemoveAurasWithInterrupt@@ Flags ( AURA_INTERRUP@@ T_FLAG_@@ ENTER_PVP_@@ COMBAT ) ; uint32 sound = 0 ; if ( m_Nodes [ node ] == BG_AB_NODE_TYPE_NEUTRAL ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + 1 ; _DelBanner ( node , BG_AB_NODE_TYPE_NEUTRAL , 0 ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == 0 ) SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) , LANG_BG_AB_ALLY ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_CLAIMED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) , LANG_BG_AB_HORDE ) ; sound = BG_AB_SOUND_NODE_CLAIMED ; } else if ( ( m_Nodes [ node ] == BG_AB_NODE_STATUS_ALLY_@@ CONTESTED ) || ( m_Nodes [ node ] == BG_AB_NODE_STATUS_HORDE_@@ CONTESTED ) ) { if ( m_prevNodes [ node ] < BG_AB_NODE_TYPE_OCCUPIED ) { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } else { UpdatePlayerScore ( source , SCORE_BASES_DEFENDED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED ; _DelBanner ( node , BG_AB_NODE_TYPE_CONTESTED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; m_NodeTimers [ node ] = 0 ; _NodeOccupied ( node , ( teamIndex == TEAM_ALLIANCE ) ? ALLIANCE : HORDE ) ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_DEFENDED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; } sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } else { UpdatePlayerScore ( source , SCORE_BASES_ASSAULTED , 1 ) ; m_prevNodes [ node ] = m_Nodes [ node ] ; m_Nodes [ node ] = teamIndex + BG_AB_NODE_TYPE_CONTESTED ; _DelBanner ( node , BG_AB_NODE_TYPE_OCCUPIED , ! teamIndex ) ; _CreateBanner ( node , BG_AB_NODE_TYPE_CONTESTED , teamIndex , true ) ; _SendNodeUpdate ( node ) ; _NodeDeOccupied ( node ) ; m_NodeTimers [ node ] = BG_AB_FLAG_CAPTURING_TIME ; if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_ALLIANCE , source , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_ASSAULTED , CHAT_MSG_BG_SYSTEM_HORDE , source , _GetNodeNameId ( node ) ) ; sound = ( teamIndex == TEAM_ALLIANCE ) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE ; } if ( m_Nodes [ node ] >= BG_AB_NODE_TYPE_OCCUPIED ) { if ( teamIndex == TEAM_ALLIANCE ) SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_ALLIANCE , NULL , LANG_BG_AB_ALLY , _GetNodeNameId ( node ) ) ; else SendMessage2ToAll ( LANG_BG_AB_NODE_TAKEN , CHAT_MSG_BG_SYSTEM_HORDE , NULL , LANG_BG_AB_HORDE , _GetNodeNameId ( node ) ) ; } PlaySoundToAll ( sound ) ; } uint32 BattlegroundAB :: GetPrematureWinner ( ) { uint8 ally = 0 , horde = 0 ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) ++ ally ; else if ( m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ++ horde ; if ( ally > horde ) return ALLIANCE ; else if ( horde > ally ) return HORDE ; return Battleground :: GetPrematureWinner ( ) ; } bool BattlegroundAB :: SetupBattleground ( ) { for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_BANNER_NEUTRAL + 8 * i , BG_AB_OBJECTID_NODE_BANNER_@@ 0 + i , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_@@ A + 8 * i , BG_AB_OBJECTID_BANNER_CONT_@@ A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_CONT_@@ H + 8 * i , BG_AB_OBJECTID_BANNER_CONT_@@ H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_ALLY + 8 * i , BG_AB_OBJECTID_BANNER_@@ A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_BANNER_HORDE + 8 * i , BG_AB_OBJECTID_BANNER_@@ H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_@@ ALLY + 8 * i , BG_AB_OBJECTID_AURA_@@ A , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_@@ HORDE + 8 * i , BG_AB_OBJECTID_AURA_@@ H , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_AURA_CONTESTED + 8 * i , BG_AB_OBJECTID_AURA_@@ C , BG_AB_NodePositions [ i ] , 0 , 0 , std :: sin ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , std :: cos ( BG_AB_NodePositions [ i ] . GetOrientation ( ) / 2 ) , RESPAWN_ONE_DAY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ some ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } } if ( ! AddObject ( BG_AB_OBJECT_GATE_A , BG_AB_OBJECTID_GATE_@@ A , BG_AB_DoorPositions [ 0 ] [ 0 ] , BG_AB_DoorPositions [ 0 ] [ 1 ] , BG_AB_DoorPositions [ 0 ] [ 2 ] , BG_AB_DoorPositions [ 0 ] [ 3 ] , BG_AB_DoorPositions [ 0 ] [ 4 ] , BG_AB_DoorPositions [ 0 ] [ 5 ] , BG_AB_DoorPositions [ 0 ] [ 6 ] , BG_AB_DoorPositions [ 0 ] [ 7 ] , RESPAWN_IMMEDIATELY ) || ! AddObject ( BG_AB_OBJECT_GATE_H , BG_AB_OBJECTID_GATE_@@ H , BG_AB_DoorPositions [ 1 ] [ 0 ] , BG_AB_DoorPositions [ 1 ] [ 1 ] , BG_AB_DoorPositions [ 1 ] [ 2 ] , BG_AB_DoorPositions [ 1 ] [ 3 ] , BG_AB_DoorPositions [ 1 ] [ 4 ] , BG_AB_DoorPositions [ 1 ] [ 5 ] , BG_AB_DoorPositions [ 1 ] [ 6 ] , BG_AB_DoorPositions [ 1 ] [ 7 ] , RESPAWN_IMMEDIATELY ) ) { TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ door ▁ object ▁ Battleground ▁ not ▁ created ! " ) ; return false ; } for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { if ( ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i , Buff_Entries [ 0 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1 , Buff_Entries [ 1 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) || ! AddObject ( BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2 , Buff_Entries [ 2 ] , BG_AB_BuffPositions [ i ] [ 0 ] , BG_AB_BuffPositions [ i ] [ 1 ] , BG_AB_BuffPositions [ i ] [ 2 ] , BG_AB_BuffPositions [ i ] [ 3 ] , 0 , 0 , std :: sin ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , std :: cos ( BG_AB_BuffPositions [ i ] [ 3 ] / 2 ) , RESPAWN_ONE_DAY ) ) TC_LOG_ERROR ( " sql . sql " , " BatteGroundAB : ▁ Failed ▁ to ▁ spawn ▁ buff ▁ object ! " ) ; } return true ; } void BattlegroundAB :: Reset ( ) { Battleground :: Reset ( ) ; m_TeamScores [ TEAM_ALLIANCE ] = 0 ; m_TeamScores [ TEAM_HORDE ] = 0 ; m_lastTick [ TEAM_ALLIANCE ] = 0 ; m_lastTick [ TEAM_HORDE ] = 0 ; m_HonorScoreTics [ TEAM_ALLIANCE ] = 0 ; m_HonorScoreTics [ TEAM_HORDE ] = 0 ; m_ReputationScoreTics [ TEAM_ALLIANCE ] = 0 ; m_ReputationScoreTics [ TEAM_HORDE ] = 0 ; m_IsInformedNearVictory = false ; bool isBGWeekend = sBattlegroundMgr -> IsBGWeekend ( GetTypeID ( ) ) ; m_HonorTics = ( isBGWeekend ) ? BG_AB_ABBGWeekend@@ HonorTicks : BG_AB_NotABBGWeekend@@ HonorTicks ; m_ReputationTics = ( isBGWeekend ) ? BG_AB_ABBGWeekend@@ ReputationTicks : BG_AB_NotABBGWeekend@@ ReputationTicks ; m_TeamScores500Disadvantage [ TEAM_ALLIANCE ] = false ; m_TeamScores500Disadvantage [ TEAM_HORDE ] = false ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) { m_Nodes [ i ] = 0 ; m_prevNodes [ i ] = 0 ; m_NodeTimers [ i ] = 0 ; m_BannerTimers [ i ] . timer = 0 ; } for ( uint8 i = 0 ; i < BG_AB_ALL_NODES_COUNT + 5 ; ++ i ) if ( ! BgCreatures [ i ] . IsEmpty ( ) ) DelCreature ( i ) ; } void BattlegroundAB :: EndBattleground ( uint32 winner ) { if ( winner == ALLIANCE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; if ( winner == HORDE ) RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , HORDE ) ; RewardHonorToTeam ( GetBonusHonorFromKill ( 1 ) , ALLIANCE ) ; Battleground :: EndBattleground ( winner ) ; } WorldSafeLocsEntry const * BattlegroundAB :: GetClo@@ sest@@ GraveYard ( Player * player ) { TeamId teamIndex = GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ; std :: vector < uint8 > nodes ; for ( uint8 i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( m_Nodes [ i ] == teamIndex + 3 ) nodes . push_back ( i ) ; WorldSafeLocsEntry const * good_entry = NULL ; if ( ! nodes . empty ( ) ) { float plr_x = player -> GetPositionX ( ) ; float plr_y = player -> GetPositionY ( ) ; float mindist = 9999@@ 99.0f ; for ( uint8 i = 0 ; i < nodes . size ( ) ; ++ i ) { WorldSafeLocsEntry const * entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ nodes [ i ] ] ) ; if ( ! entry ) continue ; float dist = ( entry -> Loc . X - plr_x ) * ( entry -> Loc . X - plr_x ) + ( entry -> Loc . Y - plr_y ) * ( entry -> Loc . Y - plr_y ) ; if ( mindist > dist ) { mindist = dist ; good_entry = entry ; } } nodes . clear ( ) ; } if ( ! good_entry ) good_entry = sWorldSafeLocsStore . LookupEntry ( BG_AB_GraveyardIds [ teamIndex + 5 ] ) ; return good_entry ; } bool BattlegroundAB :: UpdatePlayerScore ( Player * player , uint32 type , uint32 value , bool doAddHonor ) { if ( ! Battleground :: UpdatePlayerScore ( player , type , value , doAddHonor ) ) return false ; switch ( type ) { case SCORE_BASES_ASSAULTED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_@@ ASSAULT_BAS@@ E ) ; break ; case SCORE_BASES_DEFENDED : player -> UpdateAchievementCriteria ( ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE , AB_OBJECTIVE_@@ DEFEND_@@ BASE ) ; break ; default : break ; } return true ; } bool BattlegroundAB :: IsAll@@ Nodes@@ Controlled@@ ByTeam ( uint32 team ) const { uint32 count = 0 ; for ( int i = 0 ; i < BG_AB_DYNAMIC_NODES_COUNT ; ++ i ) if ( ( team == ALLIANCE && m_Nodes [ i ] == BG_AB_NODE_STATUS_ALLY_OCCUPIED ) || ( team == HORDE && m_Nodes [ i ] == BG_AB_NODE_STATUS_HORDE_OCCUPIED ) ) ++ count ; return count == BG_AB_DYNAMIC_NODES_COUNT ; } bool BattlegroundAB :: CheckAchievementCriteriaMeet ( uint32 criteriaId , Player const * player , Unit const * target , uint32 miscvalue ) { switch ( criteriaId ) { case BG_CRITERIA_@@ CHECK_RESILI@@ ENT_VIC@@ TORY : return m_TeamScores500Disadvantage [ GetTeamIndexByTeamId ( player -> GetTeam ( ) ) ] ; } return Battleground :: CheckAchievementCriteriaMeet ( criteriaId , player , target , miscvalue ) ; } </DOCUMENT>
<DOCUMENT_ID="afo@@ ksh@@ a/OpenGL@@ /tree/master/demos/@@ 100_Player@@ /play@@ er_5.cpp"> # include < iostream > # include < string > # include < thread > # include < mutex > # include < condition_variable > std :: mutex m ; std :: condition_variable cv ; std :: string data ; bool ready = false ; bool processed = false ; void worker_thread ( ) { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return ready ; } ) ; std :: cout << " Worker ▁ thread ▁ is ▁ processing ▁ data \n " ; data += " ▁ after ▁ processing " ; processed = true ; std :: cout << " Worker ▁ thread ▁ signals ▁ data ▁ processing ▁ completed \n " ; lk . unlock ( ) ; cv . notify_one ( ) ; } int main ( int argc , char * argv [ ] ) { std :: thread worker ( worker_thread ) ; data = " Example ▁ data " ; { std :: lock_guard < std :: mutex > lk ( m ) ; ready = true ; std :: cout << " main ( ) ▁ signals ▁ data ▁ ready ▁ for ▁ processing \n " ; } cv . notify_one ( ) ; { std :: unique_lock < std :: mutex > lk ( m ) ; cv . wait ( lk , [ ] { return processed ; } ) ; } std :: cout << " Back ▁ in ▁ main ( ) , ▁ data ▁ = ▁ " << data << ' \n ' ; worker . join ( ) ; } </DOCUMENT>
<DOCUMENT_ID="fe@@ dech/@@ ldpc_@@ sim@@ /tree/master/src/Simu@@ lation.cpp"> # include < iostream > # include < fstream > # include < string > # include < boost / numeric / ublas / matrix . hpp > # include < boost / random . hpp > # include < boost / random / normal_distribution . hpp > # include " LDPCEncoder . h " # include " LDPCDecoder . h " int main ( ) { int n = 648 ; int k = 432 ; int p = n - k ; std :: string file = " n648@@ r23" ; int passes = 50 ; bool qam = true ; int symbols = 4 ; double step = 0.25 ; int minsnr = 0 ; double maxsnr = 4.1 ; int maxPackets = 1E@@ 6 ; int minErrors = 100 ; int printInterval = maxPackets / 1000 ; std :: string matrixFolder = " . / matrices / " ; std :: string extIn = " . csv " ; std :: string resultsFolder = " . / results / " ; std :: string extOut = " . dat " ; std :: string encoding = matrixFolder + " enc " + file + extIn ; std :: string decoding = matrixFolder + " dec " + file + extIn ; std :: stringstream ss ; if ( qam ) { ss << " qam " << symbols ; } ss << " _ " << passes ; std :: string output = resultsFolder + file + ss . str ( ) + extOut ; std :: ifstream enc ; enc . open ( encoding . c_str ( ) ) ; std :: ifstream dec ; dec . open ( decoding . c_str ( ) ) ; std :: ofstream out ; out . open ( output . c_str ( ) ) ; out << " # LDPC , ▁ n ▁ = ▁ " << n << " , ▁ k ▁ = ▁ " << k << " \n " ; out << " # SN@@ R ▁ ( dB ) ▁ - ▁ BER ▁ - ▁ PER \n " ; std :: vector < double > snrdb ; std :: vector < int > errors ; std :: vector < int > pktErrors ; std :: vector < int > packets ; boost :: numeric :: ublas :: matrix < int > parityMatrix ( p , n ) ; boost :: numeric :: ublas :: matrix < int > encodingMatrix ( n , k ) ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dec >> parityMatrix ( i , j ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) { enc >> encodingMatrix ( i , j ) ; } } for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { snrdb . push_back ( snr ) ; errors . push_back ( 0 ) ; pktErrors . push_back ( 0 ) ; packets . push_back ( 0 ) ; } boost :: mt19937 rng = boost :: mt19937 ( time ( 0 ) ) ; boost :: variate_generator < boost :: mt19937 & , boost :: normal_distribution < > > generator ( rng , boost :: normal_distribution < > ( ) ) ; LDPCEncoder * encoder = new LDPCEncoder ( k , n , encodingMatrix , symbols ) ; LDPCDecoder * decoder = new LDPCDecoder ( k , n , parityMatrix , passes , symbols ) ; std :: cout << std :: time ( NULL ) << " Created ! \n " ; boost :: numeric :: ublas :: matrix < double > results ( snrdb . size ( ) , 26 ) ; for ( int i = 0 ; i < snrdb . size ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { results ( i , j ) = 0 ; } } for ( int packet = 0 ; packet < maxPackets ; packet ++ ) { if ( packet % printInterval == 0 ) { std :: cout << packet << " ▁ " << std :: time ( NULL ) << " \n " ; } std :: vector < int > uncoded ; std :: vector < double > w ; std :: vector < double > w_q ; for ( int i = 0 ; i < n ; i ++ ) { w . push_back ( generator ( ) ) ; if ( qam ) { w_q . push_back ( generator ( ) ) ; } } for ( int i = 0 ; i < k ; i ++ ) { uncoded . push_back ( rand ( ) % 2 ) ; } std :: vector < int > coded = encoder -> encode ( uncoded ) ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { if ( packets . at ( counter ) == 0 ) { double n0 = 1 / pow ( 10 , snr / 10 ) / log2 ( symbols ) / 2 ; std :: vector < double > received ; std :: vector < LDPCEncoder :: symbol > modulated ; if ( ! qam ) { for ( int i = 0 ; i < n ; i ++ ) { double rec = 2 * coded . at ( i ) - 1 + w . at ( i ) * sqrt ( n0 ) ; received . push_back ( rec ) ; } for ( int i = 0 ; i < n ; i ++ ) { double llr = - 2 * received . at ( i ) / n0 ; received . at ( i ) = llr ; } } else { modulated = encoder -> modulate ( coded ) ; std :: vector < double > phase ; std :: vector < double > quad ; for ( int i = 0 ; i < modulated . size ( ) ; i ++ ) { phase . push_back ( modulated . at ( i ) . phase + w . at ( i ) * sqrt ( n0 ) ) ; quad . push_back ( modulated . at ( i ) . quad + w_q . at ( i ) * sqrt ( n0 ) ) ; } received = decoder -> deMod@@ Llr ( phase , quad , n0 ) ; } while ( received . size ( ) > n ) { received . pop_back ( ) ; } std :: vector < int > decoded = decoder -> decode ( received ) ; int error = 0 ; bool correct = true ; for ( int i = 0 ; i < k ; i ++ ) { if ( decoded . at ( i ) != coded . at ( i ) ) { if ( correct ) { correct = false ; pktErrors . at ( counter ) ++ ; } error ++ ; } } errors . at ( counter ) += error ; if ( pktErrors . at ( counter ) > minErrors ) { packets . at ( counter ) = packet + 1 ; } } counter ++ ; } } std :: cout << std :: time ( NULL ) << " Finished ! \n " ; int counter = 0 ; for ( double snr = minsnr ; snr < maxsnr ; snr += step ) { double nPackets = maxPackets ; if ( packets . at ( counter ) != 0 ) { nPackets = packets . at ( counter ) ; } double per = pktErrors . at ( counter ) / nPackets ; double ber = errors . at ( counter ) / ( nPackets * k ) ; out << snr << " ▁ " << ber << " ▁ " << per << " \n " ; counter ++ ; } enc . close ( ) ; dec . close ( ) ; out . close ( ) ; delete encoder ; delete decoder ; } </DOCUMENT>
<DOCUMENT_ID="Ho@@ fiOne@@ /xbmc/tree/master/xbmc/@@ settings/dialogs/@@ GUIDialogLibExport@@ Settings.cpp"> # include < map > # include < memory > # include < string > # include < utility > # include < vector > # include < limits . h > # include " GUIDialogLibExportSettings . h " # include " dialogs / GUIDialogFileBrowser . h " # include " guilib / GUIComponent . h " # include " guilib / GUIWindowManager . h " # include " guilib / LocalizeStrings . h " # include " messaging / helpers / DialogHelper . h " # include " messaging / helpers / DialogOK@@ Helper . h " # include " ServiceBroker . h " # include " settings / SettingUtils . h " # include " settings / lib / Setting . h " # include " settings / Settings . h " # include " settings / windows / GUIControlSettings . h " # include " storage / Media@@ Manager . h " # include " Util . h " # include " utils / log . h " # include " utils / URIUtils . h " # include " filesystem / Directory . h " using namespace ADDON ; using namespace KODI :: MESSAGING ; using KODI :: MESSAGING :: HELPERS :: DialogResponse ; CGUIDialogLibExportSettings :: CGUIDialogLibExportSettings ( ) : CGUIDialogSettingsManualBase ( WINDOW_DIALOG_LIBEXPORT_SETTINGS , " DialogSettings . xml " ) , m_destinationChecked ( false ) { } bool CGUIDialogLibExportSettings :: Show ( CLibExportSettings & settings ) { CGUIDialogLibExportSettings * dialog = CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . GetWindow < CGUIDialogLibExportSettings > ( WINDOW_DIALOG_LIBEXPORT_SETTINGS ) ; if ( ! dialog ) return false ; dialog -> m_settings . SetExportType ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ) ; dialog -> m_settings . m_strPath = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; dialog -> m_settings . SetItemsToExport ( CServiceBroker :: GetSettings ( ) . GetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) ) ; dialog -> m_settings . m_unscraped = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) ; dialog -> m_settings . m_artwork = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) ; dialog -> m_settings . m_skipnfo = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) ; dialog -> m_settings . m_overwrite = CServiceBroker :: GetSettings ( ) . GetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) ; dialog -> m_destinationChecked = false ; dialog -> Open ( ) ; bool confirmed = dialog -> IsConfirmed ( ) ; if ( confirmed ) { settings = dialog -> m_settings ; } return confirmed ; } void CGUIDialogLibExportSettings :: OnInitWindow ( ) { CGUIDialogSettingsManualBase :: OnInitWindow ( ) ; } void CGUIDialogLibExportSettings :: OnSettingChanged ( std :: shared_ptr < const CSetting > setting ) { if ( ! setting ) return ; CGUIDialogSettingsManualBase :: OnSettingChanged ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) { m_settings . SetExportType ( std :: static_pointer_cast < const CSettingInt > ( setting ) -> GetValue ( ) ) ; SetupView ( ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { m_settings . m_strPath = std :: static_pointer_cast < const CSettingString > ( setting ) -> GetValue ( ) ; UpdateButtons ( ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE ) m_settings . m_overwrite = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS ) m_settings . SetItemsToExport ( GetExportItemsFromSetting ( setting ) ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK ) { m_settings . m_artwork = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED ) m_settings . m_unscraped = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; else if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO ) m_settings . m_skipnfo = std :: static_pointer_cast < const CSettingBool > ( setting ) -> GetValue ( ) ; } void CGUIDialogLibExportSettings :: OnSettingAction ( std :: shared_ptr < const CSetting > setting ) { if ( setting == NULL ) return ; CGUIDialogSettingsManualBase :: OnSettingAction ( setting ) ; const std :: string & settingId = setting -> GetId ( ) ; if ( settingId == CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) { VEC@@ SOURC@@ ES shares ; g_mediaManager . GetLocal@@ Drives ( shares ) ; g_mediaManager . GetNetwork@@ Locations ( shares ) ; g_mediaManager . GetRemov@@ ableDrives ( shares ) ; std :: string strDirectory = m_settings . m_strPath ; if ( ! strDirectory . empty ( ) ) { URIUtils :: AddSlash@@ AtEnd ( strDirectory ) ; bool bIsSource ; if ( CUtil :: GetMatch@@ ingSource ( strDirectory , shares , bIsSource ) < 0 ) { CMedia@@ Source share ; share . strName = g_localizeStrings . Get ( 13278 ) ; share . strPath = strDirectory ; shares . push_back ( share ) ; } } else strDirectory = " default ▁ location " ; if ( CGUIDialogFileBrowser :: ShowAndGetDirectory ( shares , g_localizeStrings . Get ( 661 ) , strDirectory , true ) ) { if ( ! strDirectory . empty ( ) ) { m_destinationChecked = true ; m_settings . m_strPath = strDirectory ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , strDirectory ) ; SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } } UpdateButtons ( ) ; } } bool CGUIDialogLibExportSettings :: OnMessage ( CGUI@@ Message & message ) { switch ( message . GetMessage ( ) ) { case GUI_@@ MSG_CLICKED : { int iControl = message . GetSender@@ Id ( ) ; if ( iControl == CONTROL_SETTINGS_OKAY_BUTTON ) { OnOK ( ) ; return true ; } } break ; } return CGUIDialogSettingsManualBase :: OnMessage ( message ) ; } void CGUIDialogLibExportSettings :: OnOK ( ) { if ( m_settings . IsToLib@@ Fold@@ ers ( ) ) { std :: string path = CServiceBroker :: GetSettings ( ) . GetString ( CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; if ( path . empty ( ) ) { if ( HELPERS :: ShowYes@@ NoDialogText ( 20223 , 38317 , 186 , 10004 ) == DialogResponse :: YES ) { m_confirmed = false ; Close ( ) ; CServiceBroker :: GetGUI ( ) -> GetWindowManager ( ) . Activate@@ Window ( WINDOW@@ _SETTINGS_@@ MEDIA , CSettings :: SETTING_MUSICLIBRARY_ARTISTSFOLDER ) ; } return ; } } else if ( ! m_destinationChecked ) { if ( ! XFILE :: CDirectory :: Exists ( m_settings . m_strPath ) ) { HELPERS :: ShowOK@@ DialogText ( CVariant { 38300 } , CVariant { 383@@ 18 } ) ; return ; } } m_confirmed = true ; Save ( ) ; Close ( ) ; } void CGUIDialogLibExportSettings :: Save ( ) { CLog :: Log ( LOGINFO , " CGUIDialogMusic@@ ExportSettings : ▁ Save ( ) ▁ called " ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , m_settings . GetExportType ( ) ) ; CServiceBroker :: GetSettings ( ) . SetString ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; CServiceBroker :: GetSettings ( ) . SetInt ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , m_settings . GetItemsToExport ( ) ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , m_settings . m_unscraped ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , m_settings . m_overwrite ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , m_settings . m_artwork ) ; CServiceBroker :: GetSettings ( ) . SetBool ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_skipnfo ) ; CServiceBroker :: GetSettings ( ) . Save ( ) ; } void CGUIDialogLibExportSettings :: SetupView ( ) { CGUIDialogSettingsManualBase :: SetupView ( ) ; SetHe@@ ading ( 38300 ) ; SET_CONTROL_@@ HID@@ DEN ( CONTROL_SETTINGS_@@ CUSTO@@ M_BUTTON ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_OKAY_BUTTON , 383@@ 19 ) ; SET_CONTROL_LABEL ( CONTROL_SETTINGS_@@ CANCEL_@@ BUTTON , 222 ) ; SetLabel2 ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , m_settings . m_strPath ) ; if ( m_settings . IsSingleFile ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , false ) ; } else if ( m_settings . IsSeparateFiles ( ) ) { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } else { ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , false ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , true ) ; ToggleState ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , m_settings . m_artwork ) ; } UpdateButtons ( ) ; } void CGUIDialogLibExportSettings :: UpdateButtons ( ) { bool enableExport ( true ) ; if ( m_settings . IsSingleFile ( ) || m_settings . IsSeparateFiles ( ) ) enableExport = ! m_settings . m_strPath . empty ( ) ; CONTROL_ENABLE_@@ ON_CONDI@@ TION ( CONTROL_SETTINGS_OKAY_BUTTON , enableExport ) ; if ( ! enableExport ) SetFocus ( CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER ) ; } void CGUIDialogLibExportSettings :: InitializeSettings ( ) { CGUIDialogSettingsManualBase :: InitializeSettings ( ) ; std :: shared_ptr < CSettingCategory > category = AddC@@ ategory ( " export@@ settings " , - 1 ) ; if ( ! category ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } std :: shared_ptr < CSettingGroup > groupDetails = AddGroup ( category ) ; if ( ! groupDetails ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : ▁ unable ▁ to ▁ setup ▁ settings " ) ; return ; } Translatable@@ IntegerSettingOptions entries ; entries . push_back ( std :: make_pair ( 3830@@ 1 , ELIBEXPORT_S@@ INGLEFILE ) ) ; entries . push_back ( std :: make_pair ( 38302 , ELIBEXPORT_@@ SEPAR@@ ATEFI@@ LES ) ) ; entries . push_back ( std :: make_pair ( 3830@@ 3 , ELIBEXPORT_@@ TOLIBRARYFOLDER ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FILETYPE , 38304 , SettingLevel :: Basic , m_settings . GetExportType ( ) , entries , 38304 ) ; AddButton ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_FOLDER , 38305 , SettingLevel :: Basic ) ; entries . clear ( ) ; entries . push_back ( std :: make_pair ( 132 , ELIBEXPORT_ALBUM@@ S ) ) ; entries . push_back ( std :: make_pair ( 38043 , ELIBEXPORT_ALBUM@@ ARTISTS ) ) ; entries . push_back ( std :: make_pair ( 383@@ 12 , ELIBEXPORT_S@@ ONGARTISTS ) ) ; entries . push_back ( std :: make_pair ( 38313 , ELIBEXPORT_@@ OTH@@ ERARTISTS ) ) ; AddList ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ITEMS , 38306 , SettingLevel :: Basic , m_settings . GetExport@@ Items ( ) , entries , 133 , 1 ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED , 3830@@ 8 , SettingLevel :: Basic , m_settings . m_unscraped ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_ARTWORK , 3830@@ 7 , SettingLevel :: Basic , m_settings . m_artwork ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_SKIPNFO , 38309 , SettingLevel :: Basic , m_settings . m_skipnfo ) ; AddToggle ( groupDetails , CSettings :: SETTING_MUSICLIBRARY_EXPORT_OVERWRITE , 383@@ 10 , SettingLevel :: Basic , m_settings . m_overwrite ) ; } void CGUIDialogLibExportSettings :: SetLabel2 ( const std :: string & settingid , const std :: string & label ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_LAB@@ EL2 ( settingControl -> GetID ( ) , label ) ; } void CGUIDialogLibExportSettings :: ToggleState ( const std :: string & settingid , bool enabled ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) { if ( enabled ) CONTROL_ENABLE ( settingControl -> GetID ( ) ) ; else CONTROL_DISABLE ( settingControl -> GetID ( ) ) ; } } void CGUIDialogLibExportSettings :: SetFocus ( const std :: string & settingid ) { BaseSettingControlPtr settingControl = GetSettingControl ( settingid ) ; if ( settingControl != NULL && settingControl -> GetControl ( ) != NULL ) SET_CONTROL_@@ FOCUS ( settingControl -> GetID ( ) , 0 ) ; } int CGUIDialogLibExportSettings :: GetExportItemsFromSetting ( SettingConst@@ Ptr setting ) { std :: shared_ptr < const CSettingList > settingList = std :: static_pointer_cast < const CSettingList > ( setting ) ; if ( settingList -> GetElement@@ Type ( ) != SettingType :: Integer ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ element ▁ type " , __FUNCTION__ ) ; return 0 ; } int exportitems = 0 ; std :: vector < CVariant > list = CSettingUtils :: GetList ( settingList ) ; for ( const auto & value : list ) { if ( ! value . isInteger ( ) ) { CLog :: Log ( LOGERROR , " CGUIDialogLibExportSettings : : % s ▁ - ▁ wrong ▁ items ▁ value ▁ type " , __FUNCTION__ ) ; return 0 ; } exportitems += value . asInteger ( ) ; } return exportitems ; } </DOCUMENT>
<DOCUMENT_ID="king@@ vup@@ lus/@@ enigma@@ 2/tree/master/lib/@@ gui/einput@@ string.cpp"> # include < lib / gui / einput@@ string . h > DEFINE_RE@@ F ( eInputContentString ) ; eInputContentString :: eInputContentString ( ) { m_string = " bla " ; m_cursor = 0 ; m_input = 0 ; m_len = m_string . size ( ) ; } void eInputContentString :: getDisplay ( std :: string & res , int & cursor ) { res = m_string ; cursor = m_cursor ; } void eInputContentString :: moveCursor ( int dir ) { int old_cursor = m_cursor ; switch ( dir ) { case dirLeft : -- m_cursor ; break ; case dirRight : ++ m_cursor ; break ; case dirHome : m_cursor = 0 ; break ; case dirEnd : m_cursor = m_len ; break ; } if ( m_cursor < 0 ) m_cursor = 0 ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_cursor != old_cursor ) if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: haveKey ( int code , int overwrite ) { int have_char = - 1 ; if ( code >= 0x80@@ 20 ) have_char = code & ~ 0x8000 ; if ( have_char != - 1 ) { if ( overwrite && m_cursor < m_len ) m_string [ m_cursor ] = have_char ; else { m_string . insert ( m_cursor , 1 , have_char ) ; ++ m_len ; } m_cursor ++ ; ASSERT ( m_cursor <= m_len ) ; if ( m_input ) m_input -> invalidate ( ) ; return 1 ; } return 0 ; } void eInputContentString :: deleteChar ( int dir ) { if ( dir == deleteForward ) { eDebug ( " forward " ) ; if ( m_cursor != m_len ) ++ m_cursor ; else return ; } if ( ! m_cursor ) return ; if ( ! m_len ) return ; m_string . erase ( m_cursor - 1 , m_cursor ) ; m_len -- ; m_cursor -- ; if ( m_input ) m_input -> invalidate ( ) ; } int eInputContentString :: isValid ( ) { return 1 ; } void eInputContentString :: validate ( ) { } void eInputContentString :: setText ( const std :: string & str ) { m_string = str ; m_len = m_string . size ( ) ; if ( m_cursor > m_len ) m_cursor = m_len ; if ( m_input ) m_input -> invalidate ( ) ; } std :: string eInputContentString :: getText ( ) { return m_string ; } </DOCUMENT>
<DOCUMENT_ID="g@@ illeslabel@@ le/@@ sagetv/tree/master/third_party/@@ codecs/@@ faac/common/@@ mp4@@ v2/@@ atom_@@ dmax.cpp"> # include " mp4@@ common . h " MP4DmaxAtom :: MP4DmaxAtom ( ) : MP4@@ Atom ( " dmax " ) { AddProperty ( new MP4@@ Integer32Property ( " milli@@ Secs " ) ) ; } </DOCUMENT>
<DOCUMENT_ID="os@@ gcc/@@ ryzom@@ /tree/master/ryzom@@ /tools/@@ leveldesign@@ /geor@@ ges_@@ dll/form_@@ dialog.cpp"> # include " stdafx . h " # include " georges _ edit . h " # include " georges _ edit _ view . h " # include " georges _ edit _ doc . h " # include " form _ dialog . h " # include " action . h " # include " left _ view . h " # include " nel / misc / path . h " # include " nel / georges / type . h " # include " nel / georges / form _ elm . h " using namespace std ; using namespace NLMIS@@ C ; using namespace NLGEORGES ; CFormDialog :: CFormDialog ( ) : CBaseDialog ( IDR_@@ MAINF@@ RAME ) { View = NULL ; WidgetIndexCount = 0 ; WidgetFocused = 0xffffffff ; } CFormDialog :: ~ CFormDialog ( ) { clear ( ) ; } void CFormDialog :: clear ( ) { unRegister@@ LastControl ( ) ; for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) delete Widgets [ i ] ; Widgets . clear ( ) ; WidgetFocused = 0xffffffff ; WidgetIndexCount = 0 ; } void CFormDialog :: DoDataExchange ( CDataExchange * pDX ) { CDialog :: DoDataExchange ( pDX ) ; } BEGIN_MESSAGE_MAP ( CFormDialog , CDialog ) ON_W@@ M_SIZE ( ) ON_WM_LBUTTONDOWN ( ) ON_W@@ M_SETFOCUS ( ) ON_WM_@@ KIL@@ LFOCUS ( ) END_MESSAGE_MAP ( ) void CFormDialog :: OnSize ( UINT nType , int cx , int cy ) { CBaseDialog :: OnSize ( nType , cx , cy ) ; } BOOL CFormDialog :: OnInitDialog ( ) { CBaseDialog :: OnInitDialog ( ) ; SetDef@@ ID ( 0xffffffff ) ; UpdateData ( FALSE ) ; return TRUE ; } void CFormDialog :: OnOK ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOk ( ) ; } } } void CFormDialog :: OnCancel ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateData ( ) ; if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onCancel ( ) ; return ; } } CBaseDialog :: OnCancel ( ) ; } CWnd * CFormDialog :: addTypeWidget ( const NLGEORGES :: CType & type , uint elmIndex , const char * title , const char * atomName , const char * typeFilename , RECT & currentPos , CForm & form , IFormWidget :: TTypeSrc typeWidget , const char * filenameExt , uint slot ) { switch ( type . UIType ) { case CType :: FileBrowser : case CType :: Edit : case CType :: EditSpin : { CFormMemCombo * memCombo = new CFormMemCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; string tfn = typeFilename ; string key = GEORGES_EDIT_BASE_REG_KEY " \\ " + strlwr ( typeFilename ) + " ▁ MemCombo " ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title , key . c_str ( ) , type . UIType == CType :: EditSpin , type . UIType == CType :: FileBrowser , filenameExt ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: NonEditableCombo : { CFormCombo * memCombo = new CFormCombo ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Combo ; } break ; case CType :: BigEdit : { CFormBigEdit * memCombo = new CFormBigEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Edit ; } break ; case CType :: ColorEdit : { CColorEdit * memCombo = new CColorEdit ( this , elmIndex , atomName , typeWidget , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title ) ; memCombo -> getFromDocument ( form ) ; return & memCombo -> Color ; } break ; } return NULL ; } void CFormDialog :: getVirtualDfnFromDocument ( const NLGEORGES :: CFormDfn * _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , 0xffffffff , structName , IFormWidget :: TypeVirtualDfn , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Dfn : " , GEORGES_EDIT_BASE_REG_KEY " \\Virtu@@ al ▁ Dfn ▁ MemCombo " , false , true , " * . dfn " ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; if ( _dfn ) { std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn -> countParentDfn ( ) ) ; _dfn -> getParentDfn ( arrayDfn ) ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; } elmIndex ++ ; } } } registerLastControl ( ) ; } } } void CFormDialog :: getDfnFromDocument ( const NLGEORGES :: CFormDfn & _dfn , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; std :: vector < const CFormDfn * > arrayDfn ; arrayDfn . reserve ( _dfn . countParentDfn ( ) ) ; _dfn . getParentDfn ( arrayDfn ) ; if ( strcmp ( structName , " " ) == 0 ) { CListWidget * listWidget = new CListWidget ( this , 0xffffffff , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( listWidget ) ; listWidget -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Parent ▁ Form : " , GEORGES_EDIT_BASE_REG_KEY " \\Parent ▁ Form ▁ MemCombo " , 1 ) ; listWidget -> addColumn ( " Parent ▁ filename " ) ; listWidget -> getFromDocument ( * doc -> getFormPtr ( ) ) ; } CWnd * pWnd = NULL ; CWnd * pWndIcon = NULL ; CWnd * pWndIconColor = NULL ; CWnd * pWndIconBack = NULL ; CWnd * pWndIconBackColor = NULL ; CWnd * pWndIconOver = NULL ; CWnd * pWndIconOverColor = NULL ; CWnd * pWndIconOver2 = NULL ; CWnd * pWndIconOver2Color = NULL ; uint elmIndex = 0 ; for ( uint dfnIndex = 0 ; dfnIndex < arrayDfn . size ( ) ; dfnIndex ++ ) { nlassert ( arrayDfn [ dfnIndex ] ) ; const CFormDfn & dfn = * arrayDfn [ dfnIndex ] ; for ( uint i = 0 ; i < dfn . getNumEntry ( ) ; i ++ ) { const CFormDfn :: CEntry & entry = dfn . getEntry ( i ) ; if ( entry . getType ( ) == UFormDfn :: EntryType && ! entry . getArrayFlag ( ) ) { string title = entry . getName ( ) + " : " ; string atomName = string ( structName ) + " . " + entry . getName ( ) ; pWnd = addTypeWidget ( * entry . getTypePtr ( ) , elmIndex , title . c_str ( ) , atomName . c_str ( ) , entry . getFilename ( ) . c_str ( ) , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeForm , entry . getFilenameExt ( ) . c_str ( ) , slot ) ; if ( entry . getName ( ) == " Icon " || entry . getName ( ) == " icon " ) pWndIcon = pWnd ; else if ( entry . getName ( ) == " IconColor " ) pWndIconColor = pWnd ; else if ( entry . getName ( ) == " IconBack " || entry . getName ( ) == " icon ▁ background " ) pWndIconBack = pWnd ; else if ( entry . getName ( ) == " IconBackColor " ) pWndIconBackColor = pWnd ; else if ( entry . getName ( ) == " IconOver " || entry . getName ( ) == " icon ▁ overlay " ) pWndIconOver = pWnd ; else if ( entry . getName ( ) == " IconOver@@ Color " ) pWndIconOverColor = pWnd ; else if ( entry . getName ( ) == " IconOver@@ 2" || entry . getName ( ) == " icon ▁ overlay2" ) pWndIconOver2 = pWnd ; else if ( entry . getName ( ) == " IconOver@@ 2Color " ) pWndIconOver2Color = pWnd ; } elmIndex ++ ; } } if ( ( string ( structName ) == " . Client " ) || ( string ( structName ) == " . 3d " ) ) { string title = " Icon ▁ bitmap : " ; CIconWidget * w = new CIconWidget ( this , elmIndex , " " , IFormWidget :: TypeFormParent , slot ) ; Widgets . push_back ( w ) ; w -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , title . c_str ( ) ) ; w -> Icon . pWndIcon = pWndIcon ; w -> Icon . pWndIconColor = pWndIconColor ; w -> Icon . pWndIconBack = pWndIconBack ; w -> Icon . pWndIconBackColor = pWndIconBackColor ; w -> Icon . pWndIconOver = pWndIconOver ; w -> Icon . pWndIconOverColor = pWndIconOverColor ; w -> Icon . pWndIconOver2 = pWndIconOver2 ; w -> Icon . pWndIconOver2Color = pWndIconOver2Color ; } registerLastControl ( ) ; } } } void CFormDialog :: getArrayFromDocument ( const char * structName , uint structId , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; CFormMemCombo * memCombo = new CFormMemCombo ( this , structId , structName , IFormWidget :: TypeArray , slot ) ; Widgets . push_back ( memCombo ) ; memCombo -> create ( WS_CHILD | WS_TABSTOP , currentPos , this , WidgetIndexCount , " Array ▁ size : " , GEORGES_EDIT_BASE_REG_KEY " \\Array ▁ Size ▁ MemCombo " , true , false , NULL ) ; memCombo -> getFromDocument ( * doc -> getFormPtr ( ) ) ; registerLastControl ( ) ; } } } void CFormDialog :: getTypeFromDocument ( const NLGEORGES :: CType & _type , const char * name , const char * typeFilename , const char * structName , uint slot ) { if ( View ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { clear ( ) ; Widgets . reserve ( 10 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; addTypeWidget ( _type , 0xffffffff , name , structName , typeFilename , currentPos , * doc -> getFormPtr ( ) , IFormWidget :: TypeType , NULL , slot ) ; registerLastControl ( ) ; } } } void CFormDialog :: updateLabels ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } } void CFormDialog :: updateValues ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; Widgets [ i ] -> getFromDocument ( * ( View -> GetDocument ( ) -> getFormPtr ( ) ) ) ; } } void CFormDialog :: setToDocument ( uint widget ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ widget ] ) ; if ( iconWidget ) return ; if ( Widgets [ widget ] -> getFormName ( ) != " NULL " ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widget ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentVDfnArray ) { if ( ! theApp . yes@@ No ( " Warning , ▁ this ▁ action ▁ will ▁ create ▁ an ▁ array / virtual ▁ dfn ▁ over ▁ an ▁ inher@@ ited ▁ array / virtual ▁ dfn . \n Do ▁ you ▁ want ▁ to ▁ continue ▁ ? " ) ) return ; } } IFormWidget :: TTypeSrc typeSrc = Widgets [ widget ] -> getSrcType ( ) ; if ( typeSrc == IFormWidget :: TypeForm ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormValue , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeFormParent ) { CForm * form = doc -> getFormPtr ( ) ; uint count = Widgets [ widget ] -> getNumValue ( ) ; vector < string > stringVector ( count ) ; for ( uint value = 0 ; value < count ; value ++ ) { Widgets [ widget ] -> getValue ( stringVector [ value ] , value ) ; } doc -> modify ( new CAction@@ StringVector ( IAction :: FormParents , stringVector , * doc , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeArray ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormArraySize , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeType ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionString ( IAction :: FormType@@ Value , result . c_str ( ) , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , " " , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } else if ( typeSrc == IFormWidget :: TypeVirtualDfn ) { std :: string result ; Widgets [ widget ] -> getValue ( result ) ; doc -> modify ( new CActionBuffer ( IAction :: FormVirtual@@ DfnName , NULL , 0 , * doc , Widgets [ widget ] -> getFormName ( ) . c_str ( ) , result . c_str ( ) , doc -> getLeftView ( ) -> getCurrentSelectionId ( ) , Widgets [ widget ] -> getSlot ( ) ) ) ; } } if ( ! Widgets [ widget ] -> getFormName ( ) . empty ( ) ) doc -> notify@@ Plugins ( Widgets [ widget ] -> getFormName ( ) . c_str ( ) ) ; } LRESULT CFormDialog :: WindowProc ( UINT message , WPARAM wParam , LPARAM lParam ) { switch ( message ) { case CL_@@ CHANGED : { uint widgetId = getWidget ( wParam ) ; CColorEdit * colorEdit = safe_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; colorEdit -> Empty = false ; setToDocument ( getWidget ( wParam ) ) ; } break ; case MC@@ _STRING@@ CHANGE : { setToDocument ( getWidget ( wParam ) ) ; } break ; case CBN_CHANGED : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { CIconWidget * iconWidget = dynamic_cast < CIconWidget * > ( Widgets [ i ] ) ; if ( iconWidget ) iconWidget -> Icon . Invalidate ( ) ; } } break ; } return CDialog :: WindowProc ( message , wParam , lParam ) ; } void CFormDialog :: onOpenSelected ( ) { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> haveFocus ( ) ) { Widgets [ i ] -> onOpenSelected ( ) ; } } } CWnd * CFormDialog :: GetNextDlg@@ TabItem ( CWnd * pWndCtl , BOOL bPrev@@ ious ) const { return NULL ; } void CFormDialog :: onFirst@@ Focus ( ) { View -> SetFocus ( ) ; WidgetFocused = 0xffffffff ; } void CFormDialog :: onLast@@ Focus ( ) { View -> setFocus@@ LeftView ( ) ; WidgetFocused = 0xffffffff ; } int CFormDialog :: getWidget ( uint dialogId ) const { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( dialogId ) ) return i ; } return - 1 ; } BOOL CFormDialog :: OnCommand ( WPARAM wParam , LPARAM lParam ) { switch ( HIWORD ( wParam ) ) { case CBN@@ _SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case EN_SETFOCUS : { onGetSubFocus ( LOWORD ( wParam ) ) ; } return TRUE ; case CBN@@ _SEL@@ CHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) setToDocument ( widgetId ) ; } return TRUE ; case EN_CHANGE : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit ) { CString str ; colorEdit -> Edit . GetWindowText ( str ) ; sint r , g , b ; if ( sscanf ( str , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; colorEdit -> Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) colorEdit -> Empty = false ; } } } } return TRUE ; case BN_@@ CLICKED : { int widgetId = getWidget ( LOWORD ( wParam ) ) ; if ( widgetId != - 1 ) { if ( ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeForm ) || ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeType ) ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( Widgets [ widgetId ] -> getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( Widgets [ widgetId ] -> getFormName ( ) . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( parentDfn ) ; string ext = parentDfn -> getEntry ( indexDfn ) . getFilenameExt ( ) ; char typeName [ 512 ] ; smprintf ( typeName , 512 , " % s " , strlwr ( ext ) . c_str ( ) ) ; uint i = 0 ; while ( ( typeName [ i ] == ' . ' ) || ( typeName [ i ] == ' * ' ) ) i ++ ; if ( typeName [ i ] ) typeName [ i ] = toupper ( typeName [ i ] ) ; char filter [ 512 ] ; smprintf ( filter , 512 , " % s ▁ Files ▁ ( % s ) | % s | All ▁ Files ( * . * ) | * . * | " , typeName + i , ext . c_str ( ) , ext . c_str ( ) ) ; CFileDialog dlgFile ( TRUE , ext . c_str ( ) , ext . c_str ( ) , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; PostMessage ( CBN_CHANGED , 0 , 0 ) ; } } } else { CColorEdit * colorEdit = dynamic_cast < CColorEdit * > ( Widgets [ widgetId ] ) ; if ( colorEdit && IsWindow ( colorEdit -> Color ) ) { colorEdit -> Empty = true ; colorEdit -> Edit . SetWindowText ( " " ) ; setToDocument ( getWidget ( wParam ) ) ; updateValues ( ) ; } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeVirtualDfn ) { CFormMemCombo * combo = dynamic_cast < CFormMemCombo * > ( Widgets [ widgetId ] ) ; if ( combo && IsWindow ( combo -> Browse ) ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { char filter [ 512 ] ; smprintf ( filter , 512 , " Dfn ▁ Files ▁ ( * . dfn ) | * . dfn | All ▁ Files ( * . * ) | * . * | " ) ; CFileDialog dlgFile ( TRUE , " * . dfn " , " * . dfn " , OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT , filter , theApp . m_pMainWnd ) ; if ( dlgFile . DoModal ( ) == IDOK ) { combo -> Combo . UpdateData ( ) ; combo -> Combo . SetWindowText ( dlgFile . GetFileName ( ) ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( widgetId ) ; } } } } else if ( Widgets [ widgetId ] -> getSrcType ( ) == IFormWidget :: TypeFormParent ) { setToDocument ( widgetId ) ; } } } return TRUE ; } return CWnd :: OnCommand ( wParam , lParam ) ; } BOOL CFormDialog :: OnNotify ( WPARAM wParam , LPARAM lParam , LRESULT * pResult ) { LPNMHDR pnmh = ( LPNMHDR ) lParam ; int idCtrl = ( int ) wParam ; switch ( pnmh -> code ) { case NM_SETFOCUS : { onGetSubFocus ( idCtrl ) ; } break ; case UD@@ N_DELTAP@@ OS : { for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { if ( Widgets [ i ] -> isDialog ( idCtrl ) ) { Widgets [ i ] -> getFormName ( ) ; LPNMUPDOWN lpnmud = ( LPNMUPDOWN ) lParam ; CFormMemCombo * combo = ( CFormMemCombo * ) Widgets [ i ] ; float value ; CString str ; combo -> Combo . UpdateData ( ) ; combo -> Combo . GetWindowText ( str ) ; if ( sscanf ( str , " % f " , & value ) == 1 ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( const CFormElm * ) ( doc -> getRootNode ( Widgets [ i ] -> getSlot ( ) ) ) -> getNodeByName ( Widgets [ i ] -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; float increment = 1 ; if ( nodeType ) sscanf ( nodeType -> Increment . c_str ( ) , " % f " , & increment ) ; value -= ( float ) ( lpnmud -> iDelta ) * increment ; char result [ 512 ] ; sprintf ( result , " % g " , value ) ; combo -> Combo . SetWindowText ( result ) ; combo -> Combo . UpdateData ( FALSE ) ; setToDocument ( i ) ; } } break ; } } } break ; } return CDialog :: OnNotify ( wParam , lParam , pResult ) ; } void CFormDialog :: resizeWidgets ( ) { if ( Widgets . size ( ) ) { RECT viewRect ; View -> GetClientRect ( & viewRect ) ; uint virtualWidth = std :: max ( ( uint ) MinViewWidth , ( uint ) ( viewRect . right - viewRect . left ) ) ; CBaseDialog :: resizeWidgets ( virtualWidth , 0 ) ; RECT currentPos ; getFirstItemPos ( currentPos ) ; uint bigWidgetCount [ 2 ] = { 0 , 0 } ; uint i ; uint biggestBottom [ 2 ] = { 0 , 0 } ; uint nextSplit = Widgets . size ( ) / 2 ; for ( i = 0 ; i < Widgets . size ( ) ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , false ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint adjust [ 2 ] ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 0 ] ) ; adjust [ 0 ] = AdjusteHeight ; CBaseDialog :: resizeWidgets ( virtualWidth , biggestBottom [ 1 ] ) ; adjust [ 1 ] = AdjusteHeight ; currentPos ; getFirstItemPos ( currentPos ) ; uint adjustSum [ 2 ] = { bigWidgetCount [ 0 ] ? adjust [ 0 ] / bigWidgetCount [ 0 ] : 0 , bigWidgetCount [ 1 ] ? adjust [ 1 ] / bigWidgetCount [ 1 ] : 0 } ; biggestBottom [ 0 ] = 0 ; biggestBottom [ 1 ] = 0 ; for ( i = 0 ; i < Widgets . size ( ) - 1 ; i ++ ) { uint column = ( i > nextSplit ) ? 1 : 0 ; if ( Widgets [ i ] -> extendableHeight ( ) ) { Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjustSum [ column ] , true ) ; adjust [ column ] -= adjustSum [ column ] ; } else Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , 0 , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } if ( nextSplit == i ) { getNextColumn ( currentPos ) ; currentPos . top = 0 ; } } uint column = ( i > nextSplit ) ? 1 : 0 ; Widgets [ i ] -> resizeScan ( currentPos , bigWidgetCount [ column ] , adjust [ column ] , true ) ; if ( currentPos . bottom > ( int ) biggestBottom [ column ] ) { biggestBottom [ column ] = currentPos . bottom ; } View -> setView@@ Size ( virtualWidth , std :: max ( biggestBottom [ 0 ] , biggestBottom [ 1 ] ) + CGeorgesEditView :: WidgetTop@@ Margin + CGeorgesEditView :: WidgetBotto@@ mMargin ) ; } } void CFormDialog :: getFromDocument ( ) { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { uint widgetFocus ; for ( widgetFocus = 0 ; widgetFocus < Widgets . size ( ) ; widgetFocus ++ ) { if ( Widgets [ widgetFocus ] -> haveFocus ( ) ) break ; } CGeorgesEditDocSub * subObject = doc -> getSelected@@ Object ( ) ; const CFormDfn * parentDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; uint lastElement ; bool array ; bool parentVDfnArray ; UFormDfn :: TEntryType type ; nlverify ( ( ( const CFormElm * ) ( doc -> getRootNode ( subObject -> getSlot ( ) ) ) ) -> getNodeByName ( subObject -> getFormName ( ) . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( parentDfn ) { if ( array ) { nlassert ( ( type == UFormDfn :: EntryDfn ) || ( type == UFormDfn :: EntryType ) ) ; getArrayFromDocument ( subObject -> getFormName ( ) . c_str ( ) , lastElement , subObject -> getSlot ( ) ) ; } else { switch ( parentDfn -> getEntry ( lastElement ) . getType ( ) ) { case UFormDfn :: EntryType : nlassert ( ! array ) ; nlassert ( nodeType ) ; nlassert ( parentDfn ) ; nlassert ( type == UFormDfn :: EntryType ) ; getTypeFromDocument ( * nodeType , ( parentDfn -> getEntry ( lastElement ) . getName ( ) + " : " ) . c_str ( ) , parentDfn -> getEntry ( lastElement ) . getFilename ( ) . c_str ( ) , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryDfn : nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; case UFormDfn :: EntryVirtualDfn : nlassert ( ! array ) ; getVirtualDfnFromDocument ( nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; break ; } } } else { nlassert ( ! array ) ; nlassert ( ( nodeDfn ) && ( type == UFormDfn :: EntryDfn ) ) ; getDfnFromDocument ( * nodeDfn , subObject -> getFormName ( ) . c_str ( ) , subObject -> getSlot ( ) ) ; } for ( uint i = 0 ; i < Widgets . size ( ) ; i ++ ) { Widgets [ i ] -> updateLabel ( ) ; } if ( widgetFocus < Widgets . size ( ) ) { Widgets [ widgetFocus ] -> setFocus ( ) ; } resizeWidgets ( ) ; } } void CFormDialog :: getDfnName ( string & result ) const { CGeorgesEditDoc * doc = View -> GetDocument ( ) ; if ( doc ) { CString str = doc -> GetPath@@ Name ( ) ; char extension [ 512 ] ; _split@@ path ( str , NULL , NULL , NULL , extension ) ; result = ( * extension == ' . ' ) ? extension + 1 : extension ; } else result = " " ; } void CFormDialog :: OnLButtonDown ( UINT nFlags , CPoint point ) { View -> TabCtrl . SetFocus ( ) ; CDialog :: OnLButtonDown ( nFlags , point ) ; } void CFormDialog :: onGetSubFocus ( uint id ) { int widget = getWidget ( id ) ; WidgetFocused = widget ; RECT widgetRect ; if ( Widgets [ widget ] -> getWindowRect ( widgetRect ) ) { View -> ScreenToClient ( & widgetRect ) ; RECT viewRect ; View -> GetClientRect ( & viewRect ) ; int bottom = viewRect . bottom - viewRect . top ; if ( widgetRect . bottom > bottom ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . bottom - bottom + 10 ) ) ; } if ( widgetRect . top < 0 ) { CPoint pt = View -> GetScrollPosition ( ) ; View -> ScrollToPosition ( CPoint ( pt . x , pt . y + widgetRect . top - 10 ) ) ; } } } void CFormDialog :: OnSetFocus ( CWnd * pNewWnd ) { CDialog :: OnSetFocus ( pNewWnd ) ; if ( WidgetFocused != 0xffffffff ) Widgets [ WidgetFocused ] -> setFocus ( ) ; } void CFormDialog :: OnKillFocus ( CWnd * pNewWnd ) { CDialog :: OnKillFocus ( pNewWnd ) ; } IFormWidget :: IFormWidget ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) { FormName = atomName ; Dialog = dialog ; StructId = structId ; SrcType = typeSrc ; Slot = slot ; } bool IFormWidget :: isDialog ( uint id ) const { return ( id >= FirstId ) && ( id <= LastId ) ; } ; uint IFormWidget :: getSlot ( ) const { return Slot ; } ; uint IFormWidget :: getStructId ( ) const { return StructId ; } void IFormWidget :: updateLabel ( ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { if ( IsWindow ( Label ) ) { if ( SrcType != TypeFormParent ) { if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { std :: string result ; UFormElm :: TWh@@ ereIsValue where ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , & where ) ) ; std :: string resultEvaluated ; # ifdef TEST_EVAL_FOR@@ MULA bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Formula , & where ) ; # else bool error = ! elm -> getValueByName ( resultEvaluated , FormName . c_str ( ) , UFormElm :: Eval , & where ) ; # endif string comp ; if ( error ) comp = " ▁ ( Value ▁ = ▁ Error ) " ; else { if ( resultEvaluated != result ) comp = " ▁ ( Value ▁ = ▁ \ " " + resultEvaluated + " \ " ) " ; } switch ( where ) { case UFormElm :: ValueForm : Label . SetWindowText ( ( SavedLabel + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueParent@@ Form : Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefault@@ Dfn : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ DFN ▁ value ) " + comp ) . c_str ( ) ) ; break ; case UFormElm :: ValueDefault@@ Type : Label . SetWindowText ( ( SavedLabel + " ▁ ( default ▁ TYPE ▁ value ) " + comp ) . c_str ( ) ) ; break ; } } else { const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; if ( node ) { if ( node -> getForm ( ) == doc -> getFormPtr ( ) ) { Label . SetWindowText ( SavedLabel . c_str ( ) ) ; } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( in ▁ parent ▁ form ) " ) . c_str ( ) ) ; } } else { Label . SetWindowText ( ( SavedLabel + " ▁ ( undefined ) " ) . c_str ( ) ) ; } } Label . UpdateData ( FALSE ) ; } } } } IFormWidget :: TTypeSrc IFormWidget :: getSrcType ( ) const { return SrcType ; } bool IFormWidget :: extendableHeight ( ) const { return false ; } bool IFormWidget :: getNode ( const CFormDfn * * parentDfn , uint & lastElement , const CFormDfn * * nodeDfn , const CType * * nodeType , CFormElm * * node , UFormDfn :: TEntryType & type , bool & array ) const { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; if ( doc ) { bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; return ( elm -> getNodeByName ( FormName . c_str ( ) , parentDfn , lastElement , nodeDfn , nodeType , node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; } return false ; } CFormElm * IFormWidget :: getFormElmNode ( ) const { const CFormDfn * parentDfn ; uint parentDfnIndex ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; if ( getNode ( & parentDfn , parentDfnIndex , & nodeDfn , & nodeType , & node , type , array ) ) { return node ; } return NULL ; } CFormElmStruct * IFormWidget :: getFormElmStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmStruct * > ( elm ) : NULL ; } CFormElmVirtualStruct * IFormWidget :: getFormElmVirtualStructNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmVirtualStruct * > ( elm ) : NULL ; } CFormElmArray * IFormWidget :: getFormElmArrayNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmArray * > ( elm ) : NULL ; } CFormElmAtom * IFormWidget :: getFormElmAtomNode ( ) const { CFormElm * elm = getFormElmNode ( ) ; return elm ? safe_cast < CFormElmAtom * > ( elm ) : NULL ; } const string & IFormWidget :: getFormName ( ) const { return FormName ; } uint IFormWidget :: getNumValue ( ) { nlstop ; return 0 ; } void IFormWidget :: getValue ( std :: string & result ) { nlstop ; } void IFormWidget :: getValue ( std :: string & result , uint value ) { nlstop ; } bool IFormWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Label ) ) { Label . GetWindowRect ( & rect ) ; return true ; } else return false ; } void IFormWidget :: onOpenSelected ( ) { string str ; getValue ( str ) ; std :: string str2 = CPath :: lookup ( str . c_str ( ) , false , false ) ; if ( str2 . empty ( ) ) str2 = str . c_str ( ) ; theApp . OpenDocumentFile ( str2 . c_str ( ) ) ; } CFormMemCombo :: CFormMemCombo ( CFormDialog * dialog , uint structId , const char * atomName , TTypeSrc typeSrc , uint slot ) : IFormWidget ( dialog , structId , atomName , typeSrc , slot ) { UseSpinner = false ; FileBrowser = false ; } CFormMemCombo :: ~ CFormMemCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; if ( IsWindow ( Spin ) ) Spin . DestroyWindow ( ) ; if ( IsWindow ( Browse ) ) Browse . DestroyWindow ( ) ; } void CFormMemCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , bool useSpinner , bool fileBrowser , const char * filenameExt ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType = NULL ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; FirstId = dialog_index ; LastId = FirstId + 1 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; UseSpinner = useSpinner ; FileBrowser = fileBrowser ; if ( useSpinner ) { parent -> setComboSpinSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextSpinPos ( spinPos ) ; parent -> setSpinSize ( spinPos ) ; Spin . Create ( WS_CHILD | WS_VISIBLE , spinPos , parent , dialog_index + 1 ) ; parent -> getNextPos ( currentPos ) ; } else if ( fileBrowser ) { parent -> setComboBrowseSize ( currentPos ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; RECT spinPos = currentPos ; parent -> getNextBrowsePos ( spinPos ) ; parent -> setBrowseSize ( spinPos ) ; Browse . Create ( " . . . " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , spinPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Browse ) ; parent -> getNextPos ( currentPos ) ; if ( filenameExt ) { if ( strcmp ( filenameExt , " * . * " ) != 0 ) Combo . enableAutoComplete@@ Extension ( true , filenameExt ) ; } } else { parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; Combo . create ( WS_CHILD | WS_TABSTOP , currentPos , parent , dialog_index , reg , theApp . RememberListSize ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; } if ( nodeType ) { for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . addStatic@@ Strings ( nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 2 ; } void CFormMemCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormMemCombo :: haveFocus ( ) { return ( Combo . haveFocus ( ) ) ; } void CFormMemCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormMemCombo :: onOk ( ) { Combo . onOK ( ) ; } void CFormMemCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormMemCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; if ( ( SrcType == TypeForm ) || ( SrcType == TypeType ) ) { string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; Combo . SetWindowText ( result . c_str ( ) ) ; Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } else if ( SrcType == TypeArray ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmArray * arrayNode = safe_cast < CFormElmArray * > ( node ) ; char label [ 512 ] ; smprintf ( label , 512 , " % d " , arrayNode -> Elements . size ( ) ) ; Combo . SetWindowText ( label ) ; if ( arrayNode -> getForm ( ) == & form ) Label . SetWindowText ( " Array ▁ size : " ) ; else Label . SetWindowText ( " Array ▁ size : ▁ ( in ▁ parent ▁ form ) " ) ; } else { Combo . SetWindowText ( "0" ) ; } Combo . UpdateData ( FALSE ) ; } else if ( SrcType == TypeVirtualDfn ) { const CFormDfn * parentDfn ; uint lastElement ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; nlverify ( ( ( const CFormElm * ) doc -> getRootNode ( getSlot ( ) ) ) -> getNodeByName ( FormName . c_str ( ) , & parentDfn , lastElement , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; nlassert ( ! array ) ; Combo . UpdateData ( ) ; if ( node ) { CFormElmVirtualStruct * virtualNode = safe_cast < CFormElmVirtualStruct * > ( node ) ; Combo . SetWindowText ( virtualNode -> DfnFilename . c_str ( ) ) ; } else { Combo . SetWindowText ( " " ) ; } Combo . UpdateData ( FALSE ) ; } } bool CFormMemCombo :: isWnd ( const CWnd * wnd ) const { return Combo . isWnd ( wnd ) ; } void CFormMemCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; if ( UseSpinner ) { Dialog -> setComboSpinSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextSpinPos ( spinPos ) ; Dialog -> setSpinSize ( spinPos ) ; if ( resize ) { Spin . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else if ( FileBrowser ) { Dialog -> setComboBrowseSize ( currentPos ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT spinPos = currentPos ; Dialog -> getNextBrowsePos ( spinPos ) ; Dialog -> setBrowseSize ( spinPos ) ; if ( resize ) { Browse . SetWindowPos ( NULL , spinPos . left , spinPos . top , spinPos . right - spinPos . left , spinPos . bottom - spinPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } else { Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Combo . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } } Dialog -> getNextPos ( currentPos ) ; } bool CFormMemCombo :: getWindowRect ( RECT & rect ) const { if ( Combo ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormCombo :: CFormCombo ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormCombo :: ~ CFormCombo ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Combo ) ) Combo . DestroyWindow ( ) ; } void CFormCombo :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; FirstId = dialog_index ; LastId = FirstId ; const CFormDfn * parentDfn ; uint indexDfn ; const CFormDfn * nodeDfn ; const CType * nodeType ; CFormElm * node ; UFormDfn :: TEntryType type ; bool array ; bool parentVDfnArray ; CForm * form = doc -> getFormPtr ( ) ; CFormElm * elm = doc -> getRootNode ( getSlot ( ) ) ; nlverify ( elm -> getNodeByName ( FormName . c_str ( ) , & parentDfn , indexDfn , & nodeDfn , & nodeType , & node , type , array , parentVDfnArray , true , NLGEORGES_FIRST_ROUND ) ) ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setComboSize ( currentPos , parent -> SmallWidget ) ; RECT comboPos = currentPos ; parent -> adjusteComboSize ( comboPos ) ; Combo . Create ( WS_CHILD | WS_VSCROLL | WS_VISIBLE | CBS_@@ DROPDO@@ WNLIST | CBS_@@ HASS@@ TRINGS | WS_CHILD | WS_TABSTOP , comboPos , parent , dialog_index ) ; parent -> initWidget ( Combo ) ; parent -> getNextPos ( currentPos ) ; if ( nodeType ) { Combo . InsertString ( 0 , " " ) ; for ( uint predef = 0 ; predef < nodeType -> Definitions . size ( ) ; predef ++ ) { Combo . InsertString ( predef + 1 , nodeType -> Definitions [ predef ] . Label . c_str ( ) ) ; } } dialog_index += 1 ; } void CFormCombo :: updateData ( bool update ) { Combo . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormCombo :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Combo ) ; } return false ; } void CFormCombo :: setFocus ( ) { Combo . SetFocus ( ) ; } void CFormCombo :: onOk ( ) { } void CFormCombo :: getValue ( std :: string & result ) { Combo . UpdateData ( ) ; CString str ; Combo . GetWindowText ( str ) ; Combo . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormCombo :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Combo . UpdateData ( ) ; uint itemCount = Combo . GetCount ( ) ; for ( uint i = 0 ; i < itemCount ; i ++ ) { CString item ; Combo . GetLB@@ Text ( i , item ) ; if ( item == result . c_str ( ) ) { Combo . SetCur@@ Sel ( i ) ; break ; } } Combo . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormCombo :: isWnd ( const CWnd * wnd ) const { return & Combo == ( const CWnd * ) wnd ; } void CFormCombo :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setComboSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { RECT comboPos = currentPos ; Dialog -> adjusteComboSize ( comboPos ) ; Combo . SetWindowPos ( NULL , comboPos . left , comboPos . top , comboPos . right - comboPos . left , comboPos . bottom - comboPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormCombo :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Combo ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Combo . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CFormBigEdit :: CFormBigEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CFormBigEdit :: ~ CFormBigEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CFormBigEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , WS_VSCROLL | ES_OEMCONVERT | ES_MULTILINE | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL | ES_AUTO@@ VSCROLL , currentPos , parent , dialog_index ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CFormBigEdit :: updateData ( bool update ) { Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CFormBigEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Edit ) ; } return false ; } void CFormBigEdit :: setFocus ( ) { Edit . SetFocus ( ) ; } void CFormBigEdit :: onOk ( ) { } void CFormBigEdit :: getValue ( std :: string & result ) { Edit . UpdateData ( ) ; CString str ; Edit . GetWindowText ( str ) ; Edit . UpdateData ( FALSE ) ; result = ( const char * ) str ; } void CFormBigEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Edit . UpdateData ( ) ; Dialog -> setEditText@@ MultiLine ( Edit , result . c_str ( ) ) ; Edit . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CFormBigEdit :: isWnd ( const CWnd * wnd ) const { return & Edit == wnd ; } void CFormBigEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setBigEditSize ( currentPos , Dialog -> SmallWidgetNotLimited , Dialog -> BigEditHeight + adjust ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CFormBigEdit :: extendableHeight ( ) const { return true ; } bool CFormBigEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Edit ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Edit . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CColorEdit :: CColorEdit ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { Empty = true ; } CColorEdit :: ~ CColorEdit ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( Color ) ) Color . DestroyWindow ( ) ; if ( IsWindow ( Edit ) ) Edit . DestroyWindow ( ) ; } void CColorEdit :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId + 2 ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setColorSize ( currentPos , parent -> SmallWidget ) ; Color . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Color ) ; RECT resetPos = currentPos ; parent -> getNextColorPos ( resetPos ) ; parent -> setResetColorSize ( resetPos ) ; Reset . Create ( " Reset " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , resetPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Reset ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setBigEditSize ( currentPos , parent -> SmallWidget ) ; Edit . CreateEx ( WS_EX_CLIENTEDGE , _T ( " EDIT " ) , " " , ES_OEMCONVERT | ES_WANTRETURN | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL , currentPos , parent , dialog_index + 2 ) ; parent -> initWidget ( Edit ) ; parent -> getNextPos ( currentPos ) ; Color . setEdit ( & Edit ) ; dialog_index += 3 ; } void CColorEdit :: updateData ( bool update ) { Color . UpdateData ( update ? TRUE : FALSE ) ; Edit . UpdateData ( update ? TRUE : FALSE ) ; } bool CColorEdit :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Color ) ; } return false ; } void CColorEdit :: setFocus ( ) { Color . SetFocus ( ) ; } void CColorEdit :: onOk ( ) { } void CColorEdit :: getValue ( std :: string & result ) { if ( ! Empty ) { Color . UpdateData ( ) ; CRGBA color = Color . getColor ( ) ; char colorName [ 512 ] ; smprintf ( colorName , 512 , " % d , % d , % d " , color . R , color . G , color . B ) ; result = colorName ; } else { result = " " ; } } void CColorEdit :: getFromDocument ( CForm & form ) { CGeorgesEditDoc * doc = Dialog -> View -> GetDocument ( ) ; nlassert ( doc ) ; string result ; if ( doc -> getRootNode ( getSlot ( ) ) -> getValueByName ( result , FormName . c_str ( ) , UFormElm :: NoEval , NULL ) ) { Color . UpdateData ( ) ; sint r , g , b ; if ( sscanf ( result . c_str ( ) , " % d , % d , % d " , & r , & g , & b ) == 3 ) { clamp ( r , 0 , 255 ) ; clamp ( g , 0 , 255 ) ; clamp ( b , 0 , 255 ) ; CRGBA color ( r , g , b ) ; Color . setColor ( color ) ; if ( r != 255 && g != 255 && b != 255 ) Color . updateEdit ( ) ; } else { Color . setColor ( CRGBA :: Black ) ; Color . updateEdit ( ) ; } Color . UpdateData ( FALSE ) ; updateLabel ( ) ; } else { nlstop ; } } bool CColorEdit :: isWnd ( const CWnd * wnd ) const { return & Color == wnd ; } void CColorEdit :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setColorSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Color . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } RECT resetPos = currentPos ; Dialog -> getNextColorPos ( resetPos ) ; Dialog -> setResetColorSize ( resetPos ) ; if ( resize ) { Reset . SetWindowPos ( NULL , resetPos . left , resetPos . top , resetPos . right - resetPos . left , resetPos . bottom - resetPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> SmallWidget , Dialog -> EditHeight ) ; if ( resize ) { Edit . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CColorEdit :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Color ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Color . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } CListWidget :: CListWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { ListCtrl . Ctrl = this ; } CListWidget :: ~ CListWidget ( ) { if ( IsWindow ( Label ) ) Label . DestroyWindow ( ) ; if ( IsWindow ( ListCtrl ) ) ListCtrl . DestroyWindow ( ) ; if ( IsWindow ( Button ) ) Button . DestroyWindow ( ) ; } void CListWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label , const char * reg , uint divid ) { FirstId = dialog_index ; LastId = FirstId + 1 ; Divid = divid ; RegAdr = reg ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setListSize ( currentPos , parent -> SmallWidget ) ; ListCtrl . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( ListCtrl ) ; parent -> getNextPos ( currentPos ) ; parent -> setButtonSize ( currentPos , parent -> SmallWidget ) ; Button . Create ( " Assign ▁ parents " , WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index + 1 ) ; parent -> initWidget ( Button ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 2 ; } void CListWidget :: addColumn ( const char * name ) { ListCtrl . insertColumn ( 0 , name ) ; ListCtrl . recalcColumn ( ) ; } void CListWidget :: onOk ( ) { ListCtrl . onOK ( ) ; } void CListWidget :: updateData ( bool update ) { ListCtrl . UpdateData ( update ) ; } bool CListWidget :: haveFocus ( ) { CWnd * wnd = Dialog -> GetFocus ( ) ; if ( wnd ) { return ( wnd -> GetParent ( ) == & ListCtrl ) ; } return false ; } void CListWidget :: setFocus ( ) { ListCtrl . SetFocus ( ) ; } void CListWidget :: getFromDocument ( NLGEORGES :: CForm & form ) { ListCtrl . ListCtrl . DeleteAll@@ Items ( ) ; for ( uint parent = 0 ; parent < form . getParent@@ Count ( ) ; parent ++ ) { string filename = form . getParent@@ Filename ( parent ) ; ListCtrl . ListCtrl . InsertItem ( parent , filename . c_str ( ) ) ; ListCtrl . ListCtrl . UpdateData ( FALSE ) ; updateLabel ( ) ; } } uint CListWidget :: getNumValue ( ) { return ListCtrl . ListCtrl . GetItemCount ( ) ; } void CListWidget :: getValue ( std :: string & result , uint value ) { CString str = ListCtrl . ListCtrl . GetItemText ( value , 0 ) ; result = str ; } bool CListWidget :: isWnd ( const CWnd * wnd ) const { return ( ( ( & ListCtrl ) == wnd ) || ( ( & ListCtrl . ListCtrl ) == wnd ) ) ; } void CListWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { if ( ! resize ) widgetCount ++ ; Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setListSize ( currentPos , Dialog -> SmallWidgetNotLimited / Divid , Dialog -> ListHeight + adjust ) ; if ( resize ) { ListCtrl . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; ListCtrl . recalcColumn ( ) ; } Dialog -> getNextPos ( currentPos ) ; Dialog -> setButtonSize ( currentPos , Dialog -> SmallWidget ) ; if ( resize ) { Button . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CListWidget :: extendableHeight ( ) const { return true ; } CEditListCtrl :: TItemEdit CListWidget :: CMyEditListCtrl :: getItem@@ EditMode ( uint item , uint subItem ) { return CEditListCtrl :: EditMemCombo ; } void CListWidget :: CMyEditListCtrl :: getMem@@ ComboBoxProp ( uint item , uint subItem , std :: string & regAdr , bool & browse ) { regAdr = Ctrl -> RegAdr ; browse = true ; } void CListWidget :: CMyEditListCtrl :: getNew@@ ItemText ( uint item , uint subItem , std :: string & ret ) { Ctrl -> Dialog -> getDfnName ( ret ) ; ret = " default . " + ret ; } void CListWidget :: CMyEditListCtrl :: getBrowse@@ Info ( uint item , uint subItem , std :: string & defExt , std :: string & defFilename , std :: string & defDir , std :: string & filter ) { string ret ; Ctrl -> Dialog -> getDfnName ( ret ) ; defExt = " * . " + ret ; defFilename = defExt ; filter = " Form ▁ Files ▁ ( * . " + ret + " ) | * . " + ret + " | All ▁ Files ▁ ( * . * ) | * . * | | " ; defDir = theApp . RootSearch@@ Path ; } bool CListWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( ListCtrl ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; ListCtrl . ListCtrl . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } void CListWidget :: onOpenSelected ( ) { POSITION pos = ListCtrl . ListCtrl . GetFirst@@ SelectedItemPosition ( ) ; while ( pos ) { int nItem = ListCtrl . ListCtrl . GetNextSelectedItem ( pos ) ; CString str = ListCtrl . ListCtrl . GetItemText ( nItem , 0 ) ; if ( str != " " ) { string name = CPath :: lookup ( ( const char * ) str , false , false ) ; if ( name . empty ( ) ) name = str ; theApp . OpenDocumentFile ( name . c_str ( ) ) ; } } } CIconWidget :: CIconWidget ( CFormDialog * dialog , uint structId , const char * atomName , IFormWidget :: TTypeSrc typeForm , uint slot ) : IFormWidget ( dialog , structId , atomName , typeForm , slot ) { } CIconWidget :: ~ CIconWidget ( ) { if ( IsWindow ( Icon ) ) Icon . DestroyWindow ( ) ; } void CIconWidget :: create ( DWORD wStyle , RECT & currentPos , CFormDialog * parent , uint & dialog_index , const char * label ) { FirstId = dialog_index ; LastId = FirstId ; SavedLabel = label ; parent -> setStaticSize ( currentPos ) ; Label . Create ( label , WS_VISIBLE , currentPos , parent ) ; parent -> initWidget ( Label ) ; parent -> getNextPosLabel ( currentPos ) ; parent -> setEditSize ( currentPos , parent -> IconHeight , parent -> IconHeight ) ; Icon . create ( WS_CHILD | WS_VISIBLE | WS_TABSTOP , currentPos , parent , dialog_index ) ; parent -> initWidget ( Icon ) ; parent -> getNextPos ( currentPos ) ; dialog_index += 1 ; } void CIconWidget :: updateData ( bool update ) { Icon . UpdateData ( update ? TRUE : FALSE ) ; } bool CIconWidget :: haveFocus ( ) { CWnd * focus = CWnd :: GetFocus ( ) ; if ( focus ) { return ( focus == & Icon ) ; } return false ; } void CIconWidget :: setFocus ( ) { Icon . SetFocus ( ) ; } void CIconWidget :: onOk ( ) { } void CIconWidget :: getValue ( std :: string & result ) { result = " " ; } void CIconWidget :: getFromDocument ( CForm & form ) { } bool CIconWidget :: isWnd ( const CWnd * wnd ) const { return & Icon == wnd ; } void CIconWidget :: resizeScan ( RECT & currentPos , uint & widgetCount , uint adjust , bool resize ) { Dialog -> setStaticSize ( currentPos ) ; if ( resize ) { Label . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPosLabel ( currentPos ) ; Dialog -> setEditSize ( currentPos , Dialog -> IconHeight , Dialog -> IconHeight ) ; if ( resize ) { Icon . SetWindowPos ( NULL , currentPos . left , currentPos . top , currentPos . right - currentPos . left , currentPos . bottom - currentPos . top , SWP_NOZORDER | SWP_NOOWNERZORDER ) ; } Dialog -> getNextPos ( currentPos ) ; } bool CIconWidget :: getWindowRect ( RECT & rect ) const { if ( IsWindow ( Icon ) ) { RECT parentRect ; IFormWidget :: getWindowRect ( parentRect ) ; RECT myRect ; Icon . GetWindowRect ( & myRect ) ; UnionRect ( & rect , & myRect , & parentRect ) ; return true ; } else return false ; } </DOCUMENT>
<DOCUMENT_ID="Neur@@ oRobo@@ ticTech/@@ AnimatLab@@ Public@@ Source/tree/master/Lib@@ raries/AnimatCarl@@ SimCU@@ DA/Cs@@ ClassFactory@@ .cpp"> # include " StdAf@@ x . h " # include " CsNeuralModule . h " # include " CsNeuronGroup . h " # include " CsSpikeGeneratorGroup . h " # include " CsSynapseGroup . h " # include " CsSynapseOneToOne . h " # include " CsSynapseFull . h " # include " CsSynapseRandom . h " # include " CsSynapseIndividual . h " # include " CsSpikingCurrentSynapse . h " # include " CsFiringRateStimulus . h " # include " CsNeuronDataColumn . h " # include " CsAdapter . h " # include " CsClassFactory . h " namespace AnimatCarl@@ Sim { CsClassFactory :: CsClassFactory ( ) { } CsClassFactory :: ~ CsClassFactory ( ) { } Node * CsClassFactory :: CreateNeuron ( std :: string strType , bool bThrowError ) { Node * lpNeuron = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURON@@ GROUP " ) lpNeuron = new CsNeuronGroup ; else if ( strType == " SPIKEGENER@@ ATOR@@ GROUP " ) lpNeuron = new CsSpikeGeneratorGroup ; else { lpNeuron = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalid@@ NeuronType , Cs_Err_strInvalid@@ NeuronType , " NeuronType " , strType ) ; } return lpNeuron ; } catch ( CStdErrorInfo oError ) { if ( lpNeuron ) delete lpNeuron ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpNeuron ) delete lpNeuron ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } AnimatSim :: Link * CsClassFactory :: CreateSynapse ( std :: string strType , bool bThrowError ) { AnimatSim :: Link * lpSynapse = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " ONETO@@ ONES@@ YNAPSE " ) lpSynapse = new CsSynapseOneToOne ; else if ( strType == " FULLSYNAPSE " ) lpSynapse = new CsSynapseFull ; else if ( strType == " RANDOMSYNAPSE " ) lpSynapse = new CsSynapseRandom ; else if ( strType == " INDI@@ VIDUAL@@ SYNAPSE " ) lpSynapse = new CsSynapseIndividual ; else if ( strType == " SPIKIN@@ GCURRENT@@ SYNAPSE " ) lpSynapse = new CsSpikingCurrentSynapse ; else { lpSynapse = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Cs_Err_lInvalid@@ SynapseType , Cs_Err_strInvalid@@ SynapseType , " SynapseType " , strType ) ; } return lpSynapse ; } catch ( CStdErrorInfo oError ) { if ( lpSynapse ) delete lpSynapse ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpSynapse ) delete lpSynapse ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } NeuralModule * CsClassFactory :: CreateNeuralModule ( std :: string strType , bool bThrowError ) { NeuralModule * lpModule = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " CAR@@ LSIM@@ NEURALMODULE " ) lpModule = new CsNeuralModule ; else { lpModule = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ NeuralModuleType , Al_Err_strInvalid@@ NeuralModuleType , " NeuralModule " , strType ) ; } return lpModule ; } catch ( CStdErrorInfo oError ) { if ( lpModule ) delete lpModule ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpModule ) delete lpModule ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } ExternalStimulus * CsClassFactory :: CreateExternalStimulus ( std :: string strType , bool bThrowError ) { ExternalStimulus * lpStimulus = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " FIRINGR@@ ATE " ) lpStimulus = new CsFiringRateStimulus ; else { lpStimulus = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ ExternalStimulusType , Al_Err_strInvalid@@ ExternalStimulusType , " ExternalStimulusType " , strType ) ; } return lpStimulus ; } catch ( CStdErrorInfo oError ) { if ( lpStimulus ) delete lpStimulus ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpStimulus ) delete lpStimulus ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } DataColumn * CsClassFactory :: CreateDataColumn ( std :: string strType , bool bThrowError ) { DataColumn * lpColumn = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NEURON@@ DATACOLUMN " ) lpColumn = new CsNeuronDataColumn ; else { lpColumn = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ DataColumnType , Al_Err_strInvalid@@ DataColumnType , " DataColumnType " , strType ) ; } return lpColumn ; } catch ( CStdErrorInfo oError ) { if ( lpColumn ) delete lpColumn ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpColumn ) delete lpColumn ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } Adapter * CsClassFactory :: CreateAdapter ( std :: string strType , bool bThrowError ) { Adapter * lpAdapter = NULL ; try { strType = Std_ToUpper ( Std_Trim ( strType ) ) ; if ( strType == " NODE@@ TONODE " ) lpAdapter = new CsAdapter ; else if ( strType == " PHYSICAL@@ TONODE " ) lpAdapter = new CsAdapter ; else { lpAdapter = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Al_Err_lInvalid@@ AdapterType , Al_Err_strInvalid@@ AdapterType , " AdapterType " , strType ) ; } return lpAdapter ; } catch ( CStdErrorInfo oError ) { if ( lpAdapter ) delete lpAdapter ; RELAY_ERROR ( oError ) ; return NULL ; } catch ( ... ) { if ( lpAdapter ) delete lpAdapter ; THROW_ERROR ( Std_Err_lUnspecifiedError , Std_Err_strUnspecifiedError ) ; return NULL ; } } CStdSerialize * CsClassFactory :: CreateObject ( std :: string strClassType , std :: string strObjectType , bool bThrowError ) { CStdSerialize * lpObject = NULL ; strClassType = Std_ToUpper ( Std_Trim ( strClassType ) ) ; if ( strClassType == " NEURON " ) lpObject = CreateNeuron ( strObjectType , bThrowError ) ; else if ( strClassType == " SYNAPSE " ) lpObject = CreateSynapse ( strObjectType , bThrowError ) ; else if ( strClassType == " NEURALMODULE " ) lpObject = CreateNeuralModule ( strObjectType , bThrowError ) ; else if ( strClassType == " EXTERNAL@@ STI@@ MULUS " ) lpObject = CreateExternalStimulus ( strObjectType , bThrowError ) ; else if ( strClassType == " DATACOLUMN " ) lpObject = CreateDataColumn ( strObjectType , bThrowError ) ; else if ( strClassType == " ADAPTER " ) lpObject = CreateAdapter ( strObjectType , bThrowError ) ; else { lpObject = NULL ; if ( bThrowError ) THROW_PARAM_ERROR ( Std_Err_lInvalid@@ ClassType , Std_Err_strInvalid@@ ClassType , " ClassType " , strClassType ) ; } return lpObject ; } } # ifdef WIN32 extern " C " __decl@@ spec ( dllexport ) IStdClassFactory * __cdecl GetStdClassFactory ( ) # else extern " C " IStdClassFactory * GetStdClassFactory ( ) # endif { IStdClassFactory * lpFactory = new CsClassFactory ; return lpFactory ; } </DOCUMENT>
<DOCUMENT_ID="mat12/my@@ test/tree/master/lib/@@ gdi@@ /sd@@ l.cpp"> # include < lib / gd@@ i / sdl . h > # include < lib / actions / action . h > # include < lib / base / init . h > # include < lib / base / init_num . h > # include < lib / driver / input_fake . h > # include < lib / driver / rc@@ sdl . h > # include < SDL . h > gSDLDC :: gSDLDC ( ) : m_pump ( eApp , 1 ) { if ( SDL_Init ( SDL_INIT_@@ VIDEO ) < 0 ) { eWarning ( " [ gSDLDC ] ▁ Could ▁ not ▁ initialize ▁ SDL : ▁ % s " , SDL_GetError ( ) ) ; return ; } setResolution ( 720 , 576 ) ; CONNECT ( m_pump . recv_msg , gSDLDC :: pumpEvent ) ; m_surface . type = 0 ; m_surface . clut . colors = 256 ; m_surface . clut . data = new gRGB [ m_surface . clut . colors ] ; m_pixmap = new gPixmap ( & m_surface ) ; memset ( m_surface . clut . data , 0 , sizeof ( * m_surface . clut . data ) * m_surface . clut . colors ) ; run ( ) ; } gSDLDC :: ~ gSDLDC ( ) { pushEvent ( EV_QUIT ) ; kill ( ) ; SDL_Quit ( ) ; } void gSDLDC :: keyEvent ( const SDL_Event & event ) { eSDLInputDriver * driver = eSDLInputDriver :: getInstance ( ) ; eDebug ( " [ gSDLDC ] ▁ Key ▁ % s : ▁ key = % d " , ( event . type == SDL_KEYDOWN ) ? " Down " : " Up " , event . key . keysym . sym ) ; if ( driver ) driver -> keyPressed ( & event . key ) ; } void gSDLDC :: pumpEvent ( const SDL_Event & event ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : keyEvent ( event ) ; break ; case SDL_QUIT : eDebug ( " [ gSDLDC ] ▁ Quit " ) ; extern void quitMainloop ( int exit_@@ code ) ; quitMainloop ( 0 ) ; break ; } } void gSDLDC :: pushEvent ( enum event code , void * data1 , void * data2 ) { SDL_Event event ; event . type = SDL_USEREVENT ; event . user . code = code ; event . user . data1 = data1 ; event . user . data2 = data2 ; SDL_PushEvent ( & event ) ; } void gSDLDC :: exec ( const gOpcode * o ) { switch ( o -> opcode ) { case gOpcode :: flush : pushEvent ( EV_FLIP ) ; eDebug ( " [ gSDLDC ] ▁ FLUSH " ) ; break ; default : gDC :: exec ( o ) ; break ; } } void gSDLDC :: setResolution ( int xres , int yres ) { pushEvent ( EV_SET_VIDEO_MODE , ( void * ) xres , ( void * ) yres ) ; } void gSDLDC :: evSetVideoMode ( unsigned long xres , unsigned long yres ) { m_screen = SDL_SetVideoMode ( xres , yres , 32 , SDL_HWSURFACE ) ; if ( ! m_screen ) { eF@@ atal ( " [ gSDLDC ] ▁ Could ▁ not ▁ create ▁ SDL ▁ surface : ▁ % s " , SDL_GetError ( ) ) ; return ; } m_surface . x = m_screen -> w ; m_surface . y = m_screen -> h ; m_surface . bpp = m_screen -> format -> BitsPerPixel ; m_surface . byp@@ p = m_screen -> format -> BytesPerPixel ; m_surface . stride = m_screen -> pitch ; m_surface . data = m_screen -> pixels ; SDL_Enable@@ UNICODE ( 1 ) ; } void gSDLDC :: evFlip ( ) { SDL_Flip ( m_screen ) ; } void gSDLDC :: thread ( ) { hasStarted ( ) ; bool stop = false ; while ( ! stop ) { SDL_Event event ; if ( SDL_Wait@@ Event ( & event ) ) { switch ( event . type ) { case SDL_KEYDOWN : case SDL_KEYUP : case SDL_QUIT : m_pump . send ( event ) ; break ; case SDL_USEREVENT : switch ( event . user . code ) { case EV_SET_VIDEO_MODE : evSetVideoMode ( ( unsigned long ) event . user . data1 , ( unsigned long ) event . user . data2 ) ; break ; case EV_FLIP : evFlip ( ) ; break ; case EV_QUIT : stop = true ; break ; } break ; } } } } eAutoInit@@ Ptr < gSDLDC > init_g@@ SDLDC ( eAutoInit@@ Numbers :: graphic - 1 , " gSDLDC " ) ; </DOCUMENT>
<DOCUMENT_ID="y@@ antrab@@ udd@@ hi/FreeCAD/tree/master/src/@@ 3rdParty/@@ salo@@ mesmesh/src/@@ Driver/@@ Driver_@@ Document.cpp"> # include " Driver _ Document . h " Driver_Document :: Driver_Document ( ) : myDocument ( NULL ) { } void Driver_Document :: SetFile ( const std :: string & theFileName ) { myFile = theFileName ; } void Driver_Document :: SetDocument ( SMES@@ HDS_@@ Document * theDocument ) { myDocument = theDocument ; } </DOCUMENT>
<DOCUMENT_ID="celeron@@ 55/cle@@ mentine@@ /tree/master/3rdparty/@@ libproject@@ m/Renderer/@@ Pipeline.cpp"> # include " Pipeline . hpp " # include " wipemalloc . h " Pipeline :: Pipeline ( ) : staticPerPixel ( false ) , gx ( 0 ) , gy ( 0 ) , blur1@@ n ( 1 ) , blur2@@ n ( 1 ) , blur3@@ n ( 1 ) , blur1@@ x ( 1 ) , blur2@@ x ( 1 ) , blur3@@ x ( 1 ) , blur1@@ ed ( 1 ) { } void Pipeline :: setStaticPerPixel ( int gx , int gy ) { staticPerPixel = true ; this -> gx = gx ; this -> gy = gy ; this -> x_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> x_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } this -> y_mesh = ( float * * ) wipemalloc ( gx * sizeof ( float * ) ) ; for ( int x = 0 ; x < gx ; x ++ ) { this -> y_mesh [ x ] = ( float * ) wipemalloc ( gy * sizeof ( float ) ) ; } } Pipeline :: ~ Pipeline ( ) { if ( staticPerPixel ) { for ( int x = 0 ; x < this -> gx ; x ++ ) { free ( this -> x_mesh [ x ] ) ; free ( this -> y_mesh [ x ] ) ; } free ( x_mesh ) ; free ( y_mesh ) ; } } PixelPoint Pipeline :: PerPixel ( PixelPoint p , const PerPixelContext context ) { return p ; } </DOCUMENT>
<DOCUMENT_ID="Ch@@ ameleonOS@@ /android_@@ external_@@ skia@@ /tree/master/tests/@@ PathOpsAngle@@ Test.cpp"> # include " PathOpsTestCommon . h " # include " SkOpSegment . h " # include " SkTArray . h " # include " Test . h " static const SkPoint cubics [ ] [ 4 ] = { { { 0 , 1 } , { 2 , 6 } , { 4 , 2 } , { 5 , 3 } } , { { 10 , 234 } , { 10 , 229.@@ 581@@ 726f } , { 13.5@@ 81720@@ 4f , 226 } , { 18 , 226 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.@@ 233078@@ 0029@@ 2969@@ f , 11418.3193359375f } , { 131.0370@@ 94116@@ 21094f , 11419 } , { 132 , 11419 } } , { { 0 , 1 } , { 0 , 5 } , { 4 , 1 } , { 6 , 4 } } , { { 1 , 5 } , { 4 , 6 } , { 1 , 0 } , { 4 , 0 } } , { { 0 , 1 } , { 0 , 4 } , { 5 , 1 } , { 6 , 4 } } , { { 0 , 1 } , { 1 , 2 } , { 1 , 0 } , { 6 , 1 } } , { { 0 , 3 } , { 0 , 1 } , { 2 , 0 } , { 1 , 0 } } , { { 189 , 7 } , { 189 , 5.3431@@ 45847320@@ 5566f } , { 190.@@ 3431@@ 39648@@ 4375f , 4 } , { 192 , 4 } } , { { 0 , 1 } , { 1 , 3 } , { 1 , 0 } , { 6 , 4 } } , { { 0 , 1 } , { 2 , 3 } , { 2 , 1 } , { 4 , 3 } } , { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } , { 3 , 2 } } , { { 0 , 1 } , { 4 , 6 } , { 4 , 3 } , { 5 , 4 } } , { { 806 , 11419 } , { 806.96@@ 2890625f , 11419 } , { 807.@@ 766@@ 906738@@ 28125f , 11418.3193359375f } , { 807.@@ 95@@ 7275@@ 390625f , 11417.4130859375f } } , { { 808 , 11417 } , { 808 , 11418.1044921875f } , { 807.@@ 104553222656@@ 25f , 11419 } , { 806 , 11419 } } , { { 132 , 11419 } , { 130.89543151855469f , 11419 } , { 130 , 11418.1044921875f } , { 130 , 11417 } } , { { 130.04275512695312f , 11417.4130859375f } , { 130.@@ 233123@@ 77929@@ 687f , 11418.3193359375f } , { 131.0370@@ 7885@@ 74218@@ 7f , 11419 } , { 132 , 11419 } } , { { 1006.69@@ 5129@@ 3945@@ 312f , 291 } , { 1023@@ .26@@ 36718@@ 75f , 291 } , { 1033@@ .840@@ 2099609@@ 375f , 304.@@ 431@@ 4575@@ 1953125f } , { 1030.@@ 318359375f , 321 } } , } ; static const SkPoint quads [ ] [ 3 ] = { { { 12.@@ 34239@@ 96f , 228.@@ 34240@@ 7f } , { 10 , 230.@@ 686@@ 295f } , { 10 , 234 } } , { { 304.24319@@ 458007812f , 591.@@ 756774902@@ 34375f } , { 306 , 593@@ .5@@ 147094726@@ 5625f } , { 306 , 596 } } , { { 0 , 0 } , { 3 , 1 } , { 0 , 3 } } , { { 0 , 1 } , { 3 , 1 } , { 0 , 2 } } , } ; static const SkPoint lines [ ] [ 2 ] = { { { 6 , 2 } , { 2 , 4 } } , { { 306 , 617 } , { 306 , 590 } } , { { 306 , 596 } , { 306 , 617 } } , { { 6 , 4 } , { 0 , 1 } } , { { 6 , 1 } , { 0 , 1 } } , { { 1 , 0 } , { 0 , 3 } } , { { 246 , 4 } , { 189 , 4 } } , { { 192 , 4 } , { 243 , 4 } } , { { 4 , 3 } , { 0 , 1 } } , { { 3 , 2 } , { 1 , 2 } } , { { 6 , 4 } , { 3 , 4 } } , { { 979@@ .30@@ 487060@@ 546875f , 561 } , { 1036@@ .69@@ 5068@@ 359375f , 291 } } , } ; struct SortSet { const SkPoint * ptData ; int ptCount ; double tStart ; double tEnd ; SkPoint endPt ; } ; static const SortSet set1 [ ] = { { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.66666987081928919 , 0.405037@@ 1120@@ 49930@@ 7 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574070336 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set1@@ a [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 4.58007812f , 2.83@@ 20312@@ 5f } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 4.44444466f , 2.77777767f } } , } ; static const SortSet set2 [ ] = { { cubics [ 0 ] , 4 , 0.666666667 , 0.875 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.388888889 , { 0 , 0 } } , { cubics [ 0 ] , 4 , 0.666666667 , 0.405037112 , { 0 , 0 } } , { lines [ 0 ] , 2 , 0.574074074 , 0.9140625 , { 0 , 0 } } , } ; static const SortSet set3 [ ] = { { cubics [ 1 ] , 4 , 0 , 1 , { 0 , 0 } } , { quads [ 0 ] , 3 , 1 , 0 , { 0 , 0 } } , } ; static const SortSet set4 [ ] = { { cubics [ 2 ] , 4 , 0.81@@ 211@@ 4222 , 1 , { 0 , 0 } } , { cubics [ 3 ] , 4 , 0.06@@ 84734759 , 0 , { 0 , 0 } } , } ; static const SortSet set5 [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 0 , 0 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 0 , 0 } } , { lines [ 2 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set5a [ ] = { { lines [ 1 ] , 2 , 0.777777778 , 1 , { 306 , 590 } } , { quads [ 1 ] , 3 , 1 , 4.34137342e - 06 , { 304.24319@@ 5f , 591.@@ 756775f } } , { lines [ 2 ] , 2 , 0 , 1 , { 306 , 617 } } , } ; static const SortSet set6 [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 0 , 0 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 0 , 0 } } , } ; static const SortSet set6a [ ] = { { lines [ 3 ] , 2 , 0.407407407 , 0.554627832 , { 2.672233@@ 1f , 2.336@@ 11655@@ f } } , { cubics [ 4 ] , 4 , 0.666666667 , 0.548022446 , { 2.616@@ 42241f , 2.83@@ 718@@ 514f } } , { lines [ 3 ] , 2 , 0.407407407 , 0 , { 6 , 4 } } , { cubics [ 4 ] , 4 , 0.666666667 , 1 , { 6 , 4 } } , } ; static const SortSet set7 [ ] = { { cubics [ 5 ] , 4 , 0.545233342 , 0.545454545 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.48@@ 4805744 , { 0 , 0 } } , { cubics [ 5 ] , 4 , 0.545233342 , 0 , { 0 , 0 } } , { cubics [ 6 ] , 4 , 0.484938134 , 0.545454545 , { 0 , 0 } } , } ; static const SortSet set8 [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 0 , 0 } } , } ; static const SortSet set8a [ ] = { { cubics [ 7 ] , 4 , 0.5 , 0.522986744 , { 1.60@@ 668361f , 0.96@@ 559274@@ 2f } } , { lines [ 4 ] , 2 , 0.75 , 1 , { 0 , 1 } } , { cubics [ 7 ] , 4 , 0.5 , 0 , { 0 , 1 } } , { lines [ 4 ] , 2 , 0.75 , 0.737654321 , { 1.57407@@ 403f , 1 } } , } ; static const SortSet set9 [ ] = { { cubics [ 8 ] , 4 , 0.4 , 1 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0 , { 0 , 0 } } , { cubics [ 8 ] , 4 , 0.4 , 0.3946@@ 75838 , { 0 , 0 } } , { lines [ 5 ] , 2 , 0.36 , 0.363999@@ 782 , { 0 , 0 } } , } ; static const SortSet set10 [ ] = { { lines [ 6 ] , 2 , 0.94736@@ 8421 , 1 , { 0 , 0 } } , { cubics [ 9 ] , 4 , 1 , 0.500000@@ 357 , { 0 , 0 } } , { lines [ 7 ] , 2 , 0 , 1 , { 0 , 0 } } , } ; static const SortSet set11 [ ] = { { lines [ 3 ] , 2 , 0.75 , 1 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.228744@@ 269 , { 0 , 0 } } , { lines [ 3 ] , 2 , 0.75 , 0.6@@ 27112@@ 191 , { 0 , 0 } } , { cubics [ 10 ] , 4 , 0.5 , 0.6@@ 339746 , { 0 , 0 } } , } ; static const SortSet set12 [ ] = { { cubics [ 12 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 1 , { 0 , 0 } } , { cubics [ 12 ] , 4 , 0.5 , 0 , { 0 , 0 } } , { lines [ 8 ] , 2 , 0.5 , 0 , { 0 , 0 } } , { cubics [ 11 ] , 4 , 0.5 , 1 , { 0 , 0 } } , { lines [ 9 ] , 2 , 0.5 , 0 , { 0 , 0 } } , } ; static const SortSet set13 [ ] = { { cubics [ 13 ] , 4 , 0.5 , 0.400@@ 6310@@ 46 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.928 , { 0 , 0 } } , { lines [ 10 ] , 2 , 0.791666667 , 0.3333@@ 33333 , { 0 , 0 } } , { cubics [ 13 ] , 4 , 0.5 , 0.866@@ 666667 , { 0 , 0 } } , } ; static const SortSet set14 [ ] = { { quads [ 2 ] , 3 , 0.5 , 0.310@@ 1020@@ 51 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.2 , { 0 , 0 } } , { quads [ 3 ] , 3 , 0.5 , 0.770@@ 1562@@ 12 , { 0 , 0 } } , { quads [ 2 ] , 3 , 0.5 , 0.7 , { 0 , 0 } } , } ; static const SortSet set15 [ ] = { { cubics [ 14 ] , 4 , 0.93081374 , 1 , { 0 , 0 } } , { cubics [ 15 ] , 4 , 0.1885@@ 18131 , 0 , { 0 , 0 } } , { cubics [ 14 ] , 4 , 0.93081374 , 0 , { 0 , 0 } } , } ; static const SortSet set16 [ ] = { { cubics [ 17 ] , 4 , 0.0682619216 , 0 , { 130.042755@@ f , 11417.4@@ 131f } } , { cubics [ 16 ] , 4 , 0.81@@ 230@@ 2088 , 1 , { 130 , 11417 } } , { cubics [ 17 ] , 4 , 0.0682619216 , 1 , { 132 , 11419 } } , } ; static const SortSet set17 [ ] = { { lines [ 11 ] , 2 , 0.888889581 , 1 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 0 , { 0 , 0 } } , { lines [ 11 ] , 2 , 0.888889581 , 0 , { 0 , 0 } } , { cubics [ 18 ] , 4 , 0.999996241 , 1 , { 0 , 0 } } , } ; struct SortSetTests { const char * name ; const SortSet * set ; size_t count ; SkPoint startPt ; } ; # define TEST_ENTRY ( name ) # name , name , SK_ARRAY_COUNT ( name ) static const SortSetTests tests [ ] = { { TEST_ENTRY ( set17 ) , { 0 , 0 } } , { TEST_ENTRY ( set16 ) , { 130.0@@ 90179@@ f , 11417.@@ 5957f } } , { TEST_ENTRY ( set14 ) , { 0 , 0 } } , { TEST_ENTRY ( set13 ) , { 0 , 0 } } , { TEST_ENTRY ( set12 ) , { 0 , 0 } } , { TEST_ENTRY ( set11 ) , { 0 , 0 } } , { TEST_ENTRY ( set10 ) , { 0 , 0 } } , { TEST_ENTRY ( set9 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set8a ) , { 1.5f , 1 } } , { TEST_ENTRY ( set8 ) , { 0 , 0 } } , { TEST_ENTRY ( set7 ) , { 0 , 0 } } , { TEST_ENTRY ( set6a ) , { 3.55555558f , 2.77777767f } } , { TEST_ENTRY ( set6 ) , { 0 , 0 } } , { TEST_ENTRY ( set5a ) , { 306 , 596 } } , { TEST_ENTRY ( set5 ) , { 0 , 0 } } , { TEST_ENTRY ( set3 ) , { 0 , 0 } } , { TEST_ENTRY ( set2 ) , { 0 , 0 } } , { TEST_ENTRY ( set1 ) , { 0 , 0 } } , } ; # undef TEST_ENTRY static void setup ( const SortSet * set , const size_t idx , SkOpSegment * seg , int * ts , const SkPoint & startPt ) { SkPoint start , end ; const SkPoint * data = set [ idx ] . ptData ; bool useIntersectPt = startPt . fX != 0 || startPt . fY != 0 ; if ( useIntersectPt ) { start = startPt ; end = set [ idx ] . endPt ; } switch ( set [ idx ] . ptCount ) { case 2 : { SkASSERT ( ValidPoints ( data , 2 ) ) ; seg -> addLine ( data , false , false ) ; SkDLine dLine ; dLine . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidLine ( dLine ) ) ; if ( useIntersectPt ) { break ; } start = dLine . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dLine . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 3 : { SkASSERT ( ValidPoints ( data , 3 ) ) ; seg -> addQuad ( data , false , false ) ; SkD@@ Quad dQuad ; dQuad . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidQuad ( dQuad ) ) ; if ( useIntersectPt ) { break ; } start = dQuad . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dQuad . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; case 4 : { SkASSERT ( ValidPoints ( data , 4 ) ) ; seg -> addCubic ( data , false , false ) ; SkD@@ Cubic dCubic ; dCubic . set ( set [ idx ] . ptData ) ; SkASSERT ( ValidCubic ( dCubic ) ) ; if ( useIntersectPt ) { break ; } start = dCubic . ptAtT ( set [ idx ] . tStart ) . asSkPoint ( ) ; end = dCubic . ptAtT ( set [ idx ] . tEnd ) . asSkPoint ( ) ; } break ; } double tStart = set [ idx ] . tStart ; double tEnd = set [ idx ] . tEnd ; seg -> addT ( NULL , start , tStart ) ; seg -> addT ( NULL , end , tEnd ) ; if ( tStart != 0 && tEnd != 0 ) { seg -> addT ( NULL , set [ idx ] . ptData [ 0 ] , 0 ) ; } if ( tStart != 1 && tEnd != 1 ) { seg -> addT ( NULL , set [ idx ] . ptData [ set [ idx ] . ptCount - 1 ] , 1 ) ; } int tIndex = 0 ; ts [ 0 ] = 0 ; ts [ 1 ] = 1 ; do { if ( seg -> t ( tIndex ) == set [ idx ] . tStart ) { ts [ 0 ] = tIndex ; } if ( seg -> t ( tIndex ) == set [ idx ] . tEnd ) { ts [ 1 ] = tIndex ; } if ( seg -> t ( tIndex ) >= 1 ) { break ; } } while ( ++ tIndex ) ; } static void testOne ( skiatest :: Reporter * reporter , const SortSetTests & test ) { SkT@@ DArray < SkOpAngle > angles ; bool unsortable = false ; bool unorderable = false ; SkTArray < SkOpSegment > segs ; for ( size_t idx = 0 ; idx < test . count ; ++ idx ) { int ts [ 2 ] ; const SortSet * set = test . set ; SkOpSegment & seg = segs . push_back ( ) ; setup ( set , idx , & seg , ts , test . startPt ) ; SkOpAngle * angle = angles . append ( ) ; angle -> set ( & seg , ts [ 0 ] , ts [ 1 ] ) ; # if DEBUG_ANGLE angle -> setID ( idx ) ; # endif if ( angle -> unsortable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unsortable \n " , __FUNCTION__ , test . name , idx ) ; # endif unsortable = true ; } if ( angle -> unorderable ( ) ) { # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ angle [ % d ] ▁ unorderable \n " , __FUNCTION__ , test . name , idx ) ; # endif unorderable = true ; } reporter -> bumpTestCount ( ) ; } if ( unsortable || unorderable ) { return ; } # if DEBUG_ANGLE SkDebugf ( " % s ▁ test [ % s ] \n " , __FUNCTION__ , test . name ) ; # endif for ( size_t idxL = 0 ; idxL < test . count ; ++ idxL ) { const SkOpAngle & first = angles [ idxL ] ; for ( size_t idxG = 0 ; idxG < test . count ; ++ idxG ) { if ( idxL == idxG ) { continue ; } const SkOpAngle & second = angles [ idxG ] ; bool compare = first < second ; if ( idxL < idxG ) { if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ > ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ first [ % d ] ▁ < ▁ second [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = first < second ; } REPORTER_ASSERT ( reporter , ! compare ) ; } compare = second < first ; if ( idxL < idxG ) { if ( compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ < ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , ! compare ) ; } else { SkASSERT ( idxL > idxG ) ; if ( ! compare ) { SkDebugf ( " % s ▁ test [ % s ] : ▁ ▁ second [ % d ] ▁ > ▁ first [ % d ] \n " , __FUNCTION__ , test . name , idxL , idxG ) ; compare = second < first ; } REPORTER_ASSERT ( reporter , compare ) ; } } } } static void PathOpsAngleTest ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( tests ) ; ++ index ) { const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; reporter -> bumpTestCount ( ) ; } } static void PathOpsAngleTestOne ( skiatest :: Reporter * reporter ) { size_t index = 0 ; const SortSetTests & test = tests [ index ] ; testOne ( reporter , test ) ; } # if 0 static int find_slop ( double x , double y , double rx , double ry ) { int slopBits = 0 ; bool less1 , less2 ; double absX = fabs ( x ) ; double absY = fabs ( y ) ; double length = absX < absY ? absX / 2 + absY : absX + absY / 2 ; int exponent ; ( void ) frexp ( length , & exponent ) ; double epsilon = ldexp ( FLT_EPSILON , exponent ) ; do { double xSlop = epsilon * slopBits ; double ySlop = x * y < 0 ? - xSlop : xSlop ; double x1 = x - xSlop ; double y1 = y + ySlop ; double x_ry1 = x1 * ry ; double rx_y1 = rx * y1 ; less1 = x_ry1 < rx_y1 ; double x2 = x + xSlop ; double y2 = y - ySlop ; double x_ry2 = x2 * ry ; double rx_y2 = rx * y2 ; less2 = x_ry2 < rx_y2 ; } while ( less1 == less2 && ++ slopBits ) ; return slopBits ; } static double diamond_angle ( double y , double x ) { if ( y >= 0 ) return ( x >= 0 ? y / ( x + y ) : 1 - x / ( - x + y ) ) ; else return ( x < 0 ? 2 - y / ( - x - y ) : 3 + x / ( x - y ) ) ; } static const double slopTests [ ] [ 4 ] = { { - 0.05855@@ 4756@@ 45259@@ 3892 , - 0.1880@@ 45858@@ 438@@ 27226 , - 0.0185685@@ 6964602@@ 1160 , - 0.05@@ 96152944@@ 34479438 } , { - 0.00137174129@@ 4860@@ 8398 , 0.004@@ 11522388@@ 45825195 , - 0.000@@ 4583@@ 79441959@@ 25573 , 0.001375@@ 317@@ 573547@@ 8074 } , { - 2.1033@@ 7741@@ 45221198 , - 1.4046@@ 019@@ 261273@@ 715@@ e - 008 , - 0.700@@ 62688@@ 352066@@ 704 , - 1.270@@ 632@@ 4683@@ 777995e - 008 } , } ; static void PathOpsAngle@@ FindSlop ( skiatest :: Reporter * reporter ) { for ( size_t index = 0 ; index < SK_ARRAY_COUNT ( slopTests ) ; ++ index ) { const double * slopTest = slopTests [ index ] ; double x = slopTest [ 0 ] ; double y = slopTest [ 1 ] ; double rx = slopTest [ 2 ] ; double ry = slopTest [ 3 ] ; SkDebugf ( " % s ▁ ▁ xy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( x , y , rx , ry ) ) ; SkDebugf ( " % s ▁ rxy ▁ % d = % d \n " , __FUNCTION__ , ( int ) index , find_slop ( rx , ry , x , y ) ) ; double angle = diamond_angle ( y , x ) ; double rAngle = diamond_angle ( ry , rx ) ; double diff = fabs ( angle - rAngle ) ; SkDebugf ( " % s ▁ diamon@@ d ▁ xy = % 1.9g ▁ rxy = % 1.9g ▁ diff = % 1.9g ▁ factor = % d \n " , __FUNCTION__ , angle , rAngle , diff , ( int ) ( diff / FLT_EPSILON ) ) ; } } # endif # include " TestClass@@ Def . h " DEFINE_TESTCLASS_SHORT ( PathOpsAngleTest ) DEFINE_TESTCLASS_SHORT ( PathOpsAngleTestOne ) </DOCUMENT>
<DOCUMENT_ID="k@@ rf@@ /kdeve@@ lop/tree/master/de@@ bugg@@ ers/@@ gdb@@ /pr@@ inters/@@ tests/@@ qmap@@ int.cpp"> # include < QMap > int main ( ) { QMap < int , int > m ; m [ 10 ] = 100 ; m [ 20 ] = 200 ; m [ 30 ] = 300 ; return 0 ; } </DOCUMENT>
