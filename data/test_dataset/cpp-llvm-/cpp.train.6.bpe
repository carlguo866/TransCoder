<DOCUMENT_ID="d@@ andan94@@ /Open@@ GLTest/tree/master/@@ finalOpenGL@@ /Hel@@ loGL@@ FW@@ /lib/@@ boost_1_@@ 59_0/libs/@@ lexical_@@ cast/test/lexical_@@ cast_@@ iterator_range_@@ test.cpp"> # include < boost / config . hpp > # if defined ( __INTEL_COMPILER ) # pragma warning ( disable : 193 383 488 981 1418 1419 ) # elif defined ( BOOST_MSVC ) # pragma warning ( disable : 4097 4100 4121 4127 4146 4244 4245 4511 4512 4701 4800 ) # endif # include < boost / lexical_cast . hpp > # include < boost / test / unit_test . hpp > # include < boost / range / iterator_range . hpp > using namespace boost ; # if defined ( BOOST_NO@@ _STRING@@ STREAM ) || defined ( BOOST_NO_STD_@@ WSTRING ) # define BOOST_LCAST_NO_WCHAR_T # endif # if ! defined ( BOOST_NO_CXX11_CHAR@@ 16_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU16 # endif # if ! defined ( BOOST_NO_CXX11_CHAR@@ 32_T ) && ! defined ( BOOST_NO_CXX11_UNICODE_LITERALS ) && ! defined ( _LIBCPP_VERSION ) # define BOOST_LC_RUNU32 # endif struct class_with_user_defined_sream_operators { int i ; operator int ( ) const { return i ; } } ; template < class CharT > inline std :: basic_istream < CharT > & operator >> ( std :: basic_istream < CharT > & istr , class_with_user_defined_sream_operators & rhs ) { return istr >> rhs . i ; } template < class RngT > void do_test_iterator_range_impl ( const RngT & rng ) { BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < short > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned short > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < long int > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned long int > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; # ifdef BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng . begin ( ) , rng . size ( ) ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng ) , 1.0 ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng . begin ( ) , rng . size ( ) ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng ) , 1.0L ) ; BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng . begin ( ) , rng . size ( ) ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng ) , 1 ) ; # endif # if defined ( BOOST_HAS_@@ LONG_LONG ) BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: ulong_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < boost :: long_long_type > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # elif defined ( BOOST_HAS_@@ MS_@@ INT64 ) BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < unsigned __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1u ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < __int64 > ( rng . begin ( ) , rng . size ( ) ) , 1 ) ; # endif } template < class CharT > void test_it_range_using_any_chars ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( rng1 ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; do_test_iterator_range_impl ( crng1 ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( rng2 ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; do_test_iterator_range_impl ( crng2 ) ; } template < class CharT > void test_it_range_using_char ( CharT * one , CharT * eleven ) { typedef CharT test_char_type ; iterator_range < test_char_type * > rng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng1 ) , "1" ) ; iterator_range < const test_char_type * > crng1 ( one , one + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng1 ) , "1" ) ; iterator_range < test_char_type * > rng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( rng2 ) , "1" ) ; iterator_range < const test_char_type * > crng2 ( eleven , eleven + 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < std :: string > ( crng2 ) , "1" ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( rng1 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( rng1 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( rng1 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( rng1 ) , 1 ) ; BOOST_CHECK_EQUAL ( lexical_cast < float > ( crng2 ) , 1.0f ) ; BOOST_CHECK_EQUAL ( lexical_cast < double > ( crng2 ) , 1.0 ) ; # ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS BOOST_CHECK_EQUAL ( lexical_cast < long double > ( crng2 ) , 1.0L ) ; # endif BOOST_CHECK_EQUAL ( lexical_cast < class_with_user_defined_sream_operators > ( crng2 ) , 1 ) ; # ifndef BOOST_LCAST_NO_WCHAR_T BOOST_CHECK ( lexical_cast < std :: wstring > ( rng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng1 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( rng2 ) == L " 1" ) ; BOOST_CHECK ( lexical_cast < std :: wstring > ( crng2 ) == L " 1" ) ; # endif # if defined ( BOOST_LC_RUNU16 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char16_t > my_char16_string ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng1 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( rng2 ) == u " 1" ) ; BOOST_CHECK ( lexical_cast < my_char16_string > ( crng2 ) == u " 1" ) ; # endif # if defined ( BOOST_LC_RUNU32 ) && defined ( BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES ) typedef std :: basic_string < char32_t > my_char32_string ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng1 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( rng2 ) == U " 1" ) ; BOOST_CHECK ( lexical_cast < my_char32_string > ( crng2 ) == U " 1" ) ; # endif } void test_char_iterator_ranges ( ) { typedef char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_unsigned_char_iterator_ranges ( ) { typedef unsigned char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_signed_char_iterator_ranges ( ) { typedef signed char test_char_type ; test_char_type data1 [ ] = "1" ; test_char_type data2 [ ] = "11" ; test_it_range_using_any_chars ( data1 , data2 ) ; test_it_range_using_char ( data1 , data2 ) ; } void test_wchar_iterator_ranges ( ) { # ifndef BOOST_LCAST_NO_WCHAR_T typedef wchar_t test_char_type ; test_char_type data1 [ ] = L " 1" ; test_char_type data2 [ ] = L " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char16_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU16 ) typedef char16_t test_char_type ; test_char_type data1 [ ] = u " 1" ; test_char_type data2 [ ] = u " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } void test_char32_iterator_ranges ( ) { # if defined ( BOOST_LC_RUNU32 ) typedef char32_t test_char_type ; test_char_type data1 [ ] = U " 1" ; test_char_type data2 [ ] = U " 11" ; test_it_range_using_any_chars ( data1 , data2 ) ; # endif BOOST_CHECK ( true ) ; } unit_test :: test_suite * init_unit_test_@@ suite ( int , char * [ ] ) { unit_test :: test_suite * suite = BOOST_TEST_SUITE ( " lexical _ cast . ▁ Testing ▁ conversions ▁ using ▁ iterator _ range < > " ) ; suite -> add ( BOOST_TEST_CASE ( & test_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_unsigned_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_signed_char_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_wchar_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char16_iterator_ranges ) ) ; suite -> add ( BOOST_TEST_CASE ( & test_char32_iterator_ranges ) ) ; return suite ; } </DOCUMENT>
<DOCUMENT_ID="er@@ dinc@@ ay/cla@@ mav@@ -de@@ vel/tree/master/lib@@ clamav/@@ c++/@@ llvm@@ /lib/@@ Target/PowerPC/@@ PPC@@ SelectionDAG@@ Info.cpp"> # define DEBUG_TYPE " powerpc - selectiondag - info " # include " PPCTargetMachine . h " using namespace llvm ; PPCSelectionDAGInfo :: PPCSelectionDAGInfo ( const PPCTargetMachine & TM ) : TargetSelectionDAGInfo ( TM ) { } PPCSelectionDAGInfo :: ~ PPCSelectionDAGInfo ( ) { } </DOCUMENT>
<DOCUMENT_ID="PG@@ er/incubator@@ -h@@ awq/tree/master/src/@@ backend/ac@@ cess/par@@ quet/met@@ adata@@ util_@@ c++/@@ Metadatainterface@@ .cpp"> # include < iostream > # include < stdint . h > # include < boost / shared_ptr . hpp > # include < boost / math_fwd . hpp > # include < thrift / protocol / TBinary@@ Protocol . h > # include < fcntl . h > # include < fstream > # include < stdio . h > # include < bitset > # include " MetadataUtil . h " using namespace haw@@ q ; using namespace std ; using namespace boost ; extern " C " { # include " postgres . h " # include " utils / palloc . h " int readPageMetadata ( uint8_t * buf , uint32_t * len , int compact , struct PageMetadata_4C * * ppageMetdata ) { * ppageMetdata = ( struct PageMetadata_4C * ) palloc@@ 0 ( sizeof ( struct PageMetadata_4C ) ) ; bool compactBool = ( compact == 1 ) ? true : false ; int iret = MetadataUtil :: readPageMetadata ( buf , len , compactBool , * ppageMetdata ) ; return iret ; } int writePageMetadata ( uint8_t * * buf , uint32_t * len , struct PageMetadata_4C * ppageMetadata ) { int iret = MetadataUtil :: writePageMetadata ( buf , len , ppageMetadata ) ; return iret ; } int writeColumnChunkMetadata ( uint8_t * * buf , uint32_t * len , struct ColumnChunk@@ Metadata_4C * blockMetadata ) { int iret = MetadataUtil :: writeColumnChunkMetadata ( buf , len , blockMetadata ) ; return iret ; } } </DOCUMENT>
<DOCUMENT_ID="Nick@@ elMedi@@ a/phantomjs/tree/master/src/qt/qt@@ base/@@ config.tests/@@ unix/@@ evdev/@@ evdev@@ .cpp"> # include < linux / input . h > # include < linux / kd . h > enum { e1 = ABS_@@ PRESSURE , e2 = ABS_@@ X , e3 = REL_@@ X , e4 = SYN_REPORT , } ; int main ( ) { :: input_event buf [ 32 ] ; ( void ) buf ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="android@@ -ia/@@ platform_external_@@ chromi@@ um_@@ org_@@ thir@@ d_part@@ y_WebKit@@ /tree/master/Source/core/@@ dom/Pseudo@@ Element.cpp"> # include " config . h " # include " core / dom / PseudoElement . h " # include " core / insp@@ ector / InspectorInstrumentation . h " # include " core / rendering / RenderObject . h " # include " core / rendering / RenderQuote . h " # include " core / rendering / style / ContentData . h " namespace blink { const QualifiedName & pseudoElementTagName ( PseudoId pseudoId ) { switch ( pseudoId ) { case AFTER : { DEFINE_STATIC_LOCAL ( QualifiedName , after , ( nullAtom , " < pseudo : after > " , nullAtom ) ) ; return after ; } case BEFORE : { DEFINE_STATIC_LOCAL ( QualifiedName , before , ( nullAtom , " < pseudo : before > " , nullAtom ) ) ; return before ; } case BACK@@ DROP : { DEFINE_STATIC_LOCAL ( QualifiedName , backdrop , ( nullAtom , " < pseudo : backdrop > " , nullAtom ) ) ; return backdrop ; } default : { ASSERT_NOT_REACHED ( ) ; } } DEFINE_STATIC_LOCAL ( QualifiedName , name , ( nullAtom , " < pseudo > " , nullAtom ) ) ; return name ; } String PseudoElement :: pseudoElement@@ NameFor@@ Events ( PseudoId pseudoId ) { DEFINE_STATIC_LOCAL ( const String , after , ( " : : after " ) ) ; DEFINE_STATIC_LOCAL ( const String , before , ( " : : before " ) ) ; switch ( pseudoId ) { case AFTER : return after ; case BEFORE : return before ; default : return emptyString ( ) ; } } PseudoElement :: PseudoElement ( Element * parent , PseudoId pseudoId ) : Element ( pseudoElementTagName ( pseudoId ) , & parent -> document ( ) , CreateElement ) , m_pseudoId ( pseudoId ) { ASSERT ( pseudoId != NOP@@ SEUD@@ O ) ; setParentOrShadowHostNode ( parent ) ; setHasCustomStyle@@ Callbacks ( ) ; } PassRefPtr < RenderStyle > PseudoElement :: custom@@ StyleFor@@ Renderer ( ) { return parentOrShadowHostElement ( ) -> renderer ( ) -> getCached@@ PseudoStyle ( m_pseudoId ) ; } void PseudoElement :: dispose ( ) { ASSERT ( parentOrShadowHostElement ( ) ) ; InspectorInstrumentation :: pseudoElement@@ Destroyed ( this ) ; ASSERT ( ! nextSibling ( ) ) ; ASSERT ( ! previous@@ Sibling ( ) ) ; detach ( ) ; RefPtrWillBeRawPtr < Element > parent = parentOrShadowHostElement ( ) ; setParentOrShadowHostNode ( 0 ) ; removedFrom ( parent . get ( ) ) ; } void PseudoElement :: attach ( const Attach@@ Context & context ) { ASSERT ( ! renderer ( ) ) ; Element :: attach ( context ) ; RenderObject * renderer = this -> renderer ( ) ; if ( ! renderer ) return ; RenderStyle * style = renderer -> style ( ) ; if ( style -> styleType ( ) != BEFORE && style -> styleType ( ) != AFTER ) return ; ASSERT ( style -> contentData ( ) ) ; for ( const ContentData * content = style -> contentData ( ) ; content ; content = content -> next ( ) ) { RenderObject * child = content -> createRenderer ( document ( ) , style ) ; if ( renderer -> isChild@@ Allowed ( child , style ) ) { renderer -> addChild ( child ) ; if ( child -> isQuote ( ) ) toRenderQuote ( child ) -> attachQuote ( ) ; } else child -> destroy ( ) ; } } bool PseudoElement :: rendererIsNeeded ( const RenderStyle & style ) { return pseudoElement@@ RendererIsNeeded ( & style ) ; } void PseudoElement :: didRecalcStyle ( StyleRe@@ calcChange ) { if ( ! renderer ( ) ) return ; RenderObject * renderer = this -> renderer ( ) ; for ( RenderObject * child = renderer -> nextInPreOrder ( renderer ) ; child ; child = child -> nextInPreOrder ( renderer ) ) { if ( ! child -> isText ( ) && ! child -> isQuote ( ) && ! child -> isImage ( ) ) continue ; if ( child -> style ( ) -> styleType ( ) == FIRST_LET@@ TER ) continue ; child -> setPseudoStyle ( renderer -> style ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="Jo@@ seBar@@ ral@@ es/mlnc@@ /tree/master/src/test/@@ rpc_@@ tests.cpp"> # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include " base58 . h " # include " util . h " # include " bitcoinrpc . h " using namespace std ; using namespace json_spirit ; BOOST_AUTO_TEST_SUITE ( rpc_@@ tests ) static Array createArgs ( int nRequired , const char * address1 = NULL , const char * address2 = NULL ) { Array result ; result . push_back ( nRequired ) ; Array addresses ; if ( address1 ) addresses . push_back ( address1 ) ; if ( address2 ) addresses . push_back ( address1 ) ; result . push_back ( addresses ) ; return result ; } struct TestNetFixture { TestNetFixture ( ) { fTestNet = true ; } ~ TestNetFixture ( ) { fTestNet = false ; } } ; BOOST_FIXTURE_@@ TEST_CASE ( rpc_@@ addmultisig , TestNetFixture ) { rpcf@@ n_type addmultisig = tableRPC [ " addmultisigaddress " ] -> actor ; const char * address1Hex = "04@@ 34e3@@ e09@@ f49@@ ea168c5@@ bbf53@@ f8@@ 77ff420@@ 69238@@ 58aab@@ 7c@@ 7e1@@ df25bc@@ 2639781@@ 07c95@@ e35@@ 065a27@@ ef6@@ f1b27@@ 222db0@@ ec97@@ e0e89@@ 5eac@@ a60@@ 3d3ee@@ 0d4@@ c060@@ ce3d@@ 8a00@@ 286c8" ; const char * address2Hex = "0388@@ c20@@ 37017c6@@ 2240b6@@ b72@@ ac1a2@@ a5f@@ 94da@@ 790596ebd06@@ 177c@@ 857275@@ 292216@@ 5cb@@ 4" ; Value v ; CBitcoinAddress address ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 1 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_NO_THROW ( v = addmultisig ( createArgs ( 2 , address1Hex , address2Hex ) , false ) ) ; address . SetString ( v . get_str ( ) ) ; BOOST_CHECK ( address . IsValid ( ) && address . IsScript ( ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 0 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , address1Hex ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " " ) , false ) , runtime_error ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 1 , " NotAValid@@ Pubkey " ) , false ) , runtime_error ) ; string short1 ( address1Hex , address1Hex + sizeof ( address1Hex ) - 2 ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short1 . c_str ( ) ) , false ) , runtime_error ) ; string short2 ( address1Hex + 2 , address1Hex + sizeof ( address1Hex ) ) ; BOOST_CHECK_THROW ( addmultisig ( createArgs ( 2 , short2 . c_str ( ) ) , false ) , runtime_error ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="lop@@ ez@@ loo/@@ mt@@ asa-@@ blue@@ /tree/master/Client@@ /mod@@ s/de@@ athmatch@@ /log@@ ic/@@ CCustomData.cpp"> # include " StdInc . h " # define DECLARE_@@ PROFIL@@ ER_S@@ ECTION_CCustomData # include " profile@@ r / SharedUtil . Profile@@ r . h " void CCustomData :: Copy ( CCustomData * pCustomData ) { std :: map < std :: string , SCustomData > :: const_iterator iter = pCustomData -> IterBegin ( ) ; for ( ; iter != pCustomData -> IterEnd ( ) ; iter ++ ) { Set ( iter -> first . c_str ( ) , iter -> second . Variable ) ; } } SCustomData * CCustomData :: Get ( const char * szName ) { assert ( szName ) ; std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) return & it -> second ; return NULL ; } void CCustomData :: Set ( const char * szName , const CLua@@ Argument & Variable , bool bSynchronized ) { assert ( szName ) ; SCustomData * pData = Get ( szName ) ; if ( pData ) { pData -> Variable = Variable ; pData -> bSynchronized = bSynchronized ; } else { SCustomData newData ; newData . Variable = Variable ; newData . bSynchronized = bSynchronized ; m_Data [ szName ] = newData ; } } bool CCustomData :: Delete ( const char * szName ) { std :: map < std :: string , SCustomData > :: iterator it = m_Data . find ( szName ) ; if ( it != m_Data . end ( ) ) { m_Data . erase ( it ) ; return true ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="S@@ atoshi@@ Mab@@ uch@@ i/Crystal@@ /tree/master/ThirdParty/@@ glm-0.@@ 9.8.5/test/@@ core/core_type_@@ length.cpp"> # include < glm / glm . hpp > int test_length_mat_non_squared ( ) { int Error = 0 ; Error += glm :: mat2x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat2x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3@@ x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat3@@ x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2@@ x3 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat2@@ x4 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3@@ x2 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat3@@ x4 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x2 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat4x3 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int test_length_mat ( ) { int Error = 0 ; Error += glm :: mat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: mat2x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: mat3@@ x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: mat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dmat2@@ x2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dmat3@@ x3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dmat4x4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int test_length_vec ( ) { int Error = 0 ; Error += glm :: vec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: vec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: vec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: ivec@@ 2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: ivec@@ 3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: ivec@@ 4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: uvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: uvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: uvec4 ( ) . length ( ) == 4 ? 0 : 1 ; Error += glm :: dvec2 ( ) . length ( ) == 2 ? 0 : 1 ; Error += glm :: dvec3 ( ) . length ( ) == 3 ? 0 : 1 ; Error += glm :: dvec4 ( ) . length ( ) == 4 ? 0 : 1 ; return Error ; } int main ( ) { int Error = 0 ; Error += test_length_vec ( ) ; Error += test_length_mat ( ) ; Error += test_length_mat_non_squared ( ) ; return Error ; } </DOCUMENT>
<DOCUMENT_ID="basic@@ 60/AR@@ CUS@@ /tree/master/source/@@ kernel/@@ interruption/@@ idt.cpp"> # include " types . h " # include " idt . h " # include " string . h " # include " print _ charmode . h " # include " port . h " # include " keyboard . h " idtEntry idtEntries [ 256 ] ; interruptHandler_t interruptHandler [ 256 ] ; idtPtr iptr ; extern " C " void idtFlush ( uint64 addr ) ; void initIDT ( ) { memset ( ( uint8 * ) idtEntries , 0 , sizeof ( idtEntries ) ) ; iptr . limit = sizeof ( idtEntries ) - 1 ; iptr . base = ( uint64 ) & idtEntries ; writePort ( 0x20 , 0x11 ) ; writePort ( 0xA0 , 0x11 ) ; writePort ( 0x21 , 0x20 ) ; writePort ( 0xA1 , 0x28 ) ; writePort ( 0x21 , 0x01 ) ; writePort ( 0xA1 , 0x01 ) ; writePort ( 0x21 , 0x00 ) ; writePort ( 0xA1 , 0x00 ) ; idtSetEntity ( 0 , ( uint64 ) isr0 , 0x08 , 0x8E ) ; idtSetEntity ( 1 , ( uint64 ) isr1 , 0x08 , 0x8E ) ; idtSetEntity ( 2 , ( uint64 ) isr2 , 0x08 , 0x8E ) ; idtSetEntity ( 3 , ( uint64 ) isr3 , 0x08 , 0x8E ) ; idtSetEntity ( 4 , ( uint64 ) isr4 , 0x08 , 0x8E ) ; idtSetEntity ( 5 , ( uint64 ) isr5 , 0x08 , 0x8E ) ; idtSetEntity ( 6 , ( uint64 ) isr6 , 0x08 , 0x8E ) ; idtSetEntity ( 7 , ( uint64 ) isr7 , 0x08 , 0x8E ) ; idtSetEntity ( 8 , ( uint64 ) isr8 , 0x08 , 0x8E ) ; idtSetEntity ( 9 , ( uint64 ) isr9 , 0x08 , 0x8E ) ; idtSetEntity ( 10 , ( uint64 ) isr10 , 0x08 , 0x8E ) ; idtSetEntity ( 11 , ( uint64 ) isr11 , 0x08 , 0x8E ) ; idtSetEntity ( 12 , ( uint64 ) isr12 , 0x08 , 0x8E ) ; idtSetEntity ( 13 , ( uint64 ) isr13 , 0x08 , 0x8E ) ; idtSetEntity ( 14 , ( uint64 ) isr14 , 0x08 , 0x8E ) ; idtSetEntity ( 15 , ( uint64 ) isr15 , 0x08 , 0x8E ) ; idtSetEntity ( 16 , ( uint64 ) isr16 , 0x08 , 0x8E ) ; idtSetEntity ( 17 , ( uint64 ) isr17 , 0x08 , 0x8E ) ; idtSetEntity ( 18 , ( uint64 ) isr18 , 0x08 , 0x8E ) ; idtSetEntity ( 19 , ( uint64 ) isr19 , 0x08 , 0x8E ) ; idtSetEntity ( 20 , ( uint64 ) isr20 , 0x08 , 0x8E ) ; idtSetEntity ( 21 , ( uint64 ) isr21 , 0x08 , 0x8E ) ; idtSetEntity ( 22 , ( uint64 ) isr22 , 0x08 , 0x8E ) ; idtSetEntity ( 23 , ( uint64 ) isr23 , 0x08 , 0x8E ) ; idtSetEntity ( 24 , ( uint64 ) isr24 , 0x08 , 0x8E ) ; idtSetEntity ( 25 , ( uint64 ) isr25 , 0x08 , 0x8E ) ; idtSetEntity ( 26 , ( uint64 ) isr26 , 0x08 , 0x8E ) ; idtSetEntity ( 27 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 28 , ( uint64 ) isr27 , 0x08 , 0x8E ) ; idtSetEntity ( 29 , ( uint64 ) isr29 , 0x08 , 0x8E ) ; idtSetEntity ( 30 , ( uint64 ) isr30 , 0x08 , 0x8E ) ; idtSetEntity ( 31 , ( uint64 ) isr31 , 0x08 , 0x8E ) ; idtSetEntity ( 32 , ( uint64 ) irq0 , 0x08 , 0x8E ) ; idtSetEntity ( 33 , ( uint64 ) irq1 , 0x08 , 0x8E ) ; idtSetEntity ( 34 , ( uint64 ) irq2 , 0x08 , 0x8E ) ; idtSetEntity ( 35 , ( uint64 ) irq3 , 0x08 , 0x8E ) ; idtSetEntity ( 36 , ( uint64 ) irq4 , 0x08 , 0x8E ) ; idtSetEntity ( 37 , ( uint64 ) irq5 , 0x08 , 0x8E ) ; idtSetEntity ( 38 , ( uint64 ) irq6 , 0x08 , 0x8E ) ; idtSetEntity ( 39 , ( uint64 ) irq7 , 0x08 , 0x8E ) ; idtSetEntity ( 40 , ( uint64 ) irq8 , 0x08 , 0x8E ) ; idtSetEntity ( 41 , ( uint64 ) irq9 , 0x08 , 0x8E ) ; idtSetEntity ( 42 , ( uint64 ) irq10 , 0x08 , 0x8E ) ; idtSetEntity ( 43 , ( uint64 ) irq11 , 0x08 , 0x8E ) ; idtSetEntity ( 44 , ( uint64 ) irq12 , 0x08 , 0x8E ) ; idtSetEntity ( 45 , ( uint64 ) irq13 , 0x08 , 0x8E ) ; idtSetEntity ( 46 , ( uint64 ) irq14 , 0x08 , 0x8E ) ; idtSetEntity ( 47 , ( uint64 ) irq15 , 0x08 , 0x8E ) ; idtFlush ( ( uint64 ) & iptr ) ; printStr ( " Initializing ▁ interruption ▁ finished . \n " , color_@@ white ) ; } void isrHandler ( ptRegs * regs ) { if ( interruptHandler [ regs -> intNum ] ) interruptHandler [ regs -> intNum ] ( regs ) ; else { } } void irqHandler ( ptRegs * regs ) { if ( regs -> intNum > 40 ) { writePort ( 0xA0 , 0x20 ) ; } writePort ( 0x20 , 0x20 ) ; if ( interruptHandler [ regs -> intNum ] ) { interruptHandler [ regs -> intNum ] ( regs ) ; } } void registerInterrupt@@ Handler ( uint8 n , interruptHandler_t h ) { interruptHandler [ n ] = h ; } void idtSetEntity ( uint8 num , uint64 base , uint16 selector , uint8 flags ) { idtEntries [ num ] . offset1 = base & 0xffff ; idtEntries [ num ] . offset2 = ( base >> 16 ) & 0xffff ; idtEntries [ num ] . offset3 = ( base >> 32 ) & 0xffffffff ; idtEntries [ num ] . selector = selector ; idtEntries [ num ] . typeAttr = flags ; } </DOCUMENT>
<DOCUMENT_ID="y@@ uh@@ angwang@@ /spi@@ i/tree/master/thir@@ dparty/@@ Eigen/@@ demo@@ s/opengl/@@ icos@@ phere.cpp"> # include " icos@@ phere . h " # include < GL / gl . h > # include < map > using namespace Eigen ; # define X .5@@ 25731112@@ 119133606 # define Z .850@@ 650@@ 80835@@ 20399@@ 32 static GLfloat vdata [ 12 ] [ 3 ] = { { - X , 0.0 , Z } , { X , 0.0 , Z } , { - X , 0.0 , - Z } , { X , 0.0 , - Z } , { 0.0 , Z , X } , { 0.0 , Z , - X } , { 0.0 , - Z , X } , { 0.0 , - Z , - X } , { Z , X , 0.0 } , { - Z , X , 0.0 } , { Z , - X , 0.0 } , { - Z , - X , 0.0 } } ; static GLint tindices [ 20 ] [ 3 ] = { { 0 , 4 , 1 } , { 0 , 9 , 4 } , { 9 , 5 , 4 } , { 4 , 5 , 8 } , { 4 , 8 , 1 } , { 8 , 10 , 1 } , { 8 , 3 , 10 } , { 5 , 3 , 8 } , { 5 , 2 , 3 } , { 2 , 7 , 3 } , { 7 , 10 , 3 } , { 7 , 6 , 10 } , { 7 , 11 , 6 } , { 11 , 0 , 6 } , { 0 , 1 , 6 } , { 6 , 1 , 10 } , { 9 , 0 , 11 } , { 9 , 11 , 2 } , { 9 , 2 , 5 } , { 7 , 2 , 11 } } ; IcoSphere :: IcoSphere ( unsigned int levels ) { for ( int i = 0 ; i < 12 ; i ++ ) mVertices . push_back ( Map < Vector3f > ( vdata [ i ] ) ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & indices = * mIndices . back ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) indices . push_back ( tindices [ i ] [ k ] ) ; } mListIds . push_back ( 0 ) ; while ( mIndices . size ( ) < levels ) _subdivide ( ) ; } const std :: vector < int > & IcoSphere :: indices ( int level ) const { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; return * mIndices [ level ] ; } void IcoSphere :: _subdivide ( void ) { typedef unsigned long long Key ; std :: map < Key , int > edgeMap ; const std :: vector < int > & indices = * mIndices . back ( ) ; mIndices . push_back ( new std :: vector < int > ) ; std :: vector < int > & refinedIndices = * mIndices . back ( ) ; int end = indices . size ( ) ; for ( int i = 0 ; i < end ; i += 3 ) { int ids0 [ 3 ] , ids1 [ 3 ] ; for ( int k = 0 ; k < 3 ; ++ k ) { int k1 = ( k + 1 ) % 3 ; int e0 = indices [ i + k ] ; int e1 = indices [ i + k1 ] ; ids0 [ k ] = e0 ; if ( e1 > e0 ) std :: swap ( e0 , e1 ) ; Key edgeKey = Key ( e0 ) | ( Key ( e1 ) << 32 ) ; std :: map < Key , int > :: iterator it = edgeMap . find ( edgeKey ) ; if ( it == edgeMap . end ( ) ) { ids1 [ k ] = mVertices . size ( ) ; edgeMap [ edgeKey ] = ids1 [ k ] ; mVertices . push_back ( ( mVertices [ e0 ] + mVertices [ e1 ] ) . normalized ( ) ) ; } else ids1 [ k ] = it -> second ; } refinedIndices . push_back ( ids0 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids0 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids0 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 0 ] ) ; refinedIndices . push_back ( ids1 [ 1 ] ) ; refinedIndices . push_back ( ids1 [ 2 ] ) ; } mListIds . push_back ( 0 ) ; } void IcoSphere :: draw ( int level ) { while ( level >= int ( mIndices . size ( ) ) ) const_cast < IcoSphere * > ( this ) -> _subdivide ( ) ; if ( mListIds [ level ] == 0 ) { mListIds [ level ] = glGen@@ Lists ( 1 ) ; glNew@@ List ( mListIds [ level ] , GL_COMPIL@@ E ) ; glVertexPointer ( 3 , GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glNormal@@ Pointer ( GL_FLOAT , 0 , mVertices [ 0 ] . data ( ) ) ; glEnableClientState ( GL_VERTEX_ARRAY ) ; glEnableClientState ( GL_NORMAL_ARRAY ) ; glDrawElements ( GL_TRI@@ ANGLES , mIndices [ level ] -> size ( ) , GL_UNSIG@@ NED_INT , & ( mIndices [ level ] -> at ( 0 ) ) ) ; glDisableClientState ( GL_VERTEX_ARRAY ) ; glDisableClientState ( GL_NORMAL_ARRAY ) ; glEnd@@ List ( ) ; } glCall@@ List ( mListIds [ level ] ) ; } </DOCUMENT>
<DOCUMENT_ID="ay@@ bass@@ iouny/@@ winc@@ affe-@@ cmake@@ /tree/master/src/caff@@ e/test/@@ test_power@@ _lay@@ er.cpp"> # include < algorithm > # include < vector > # include " cu@@ da _ runtime . h " # include " gtest / gtest . h " # include " caffe / blob . hpp " # include " caffe / common . hpp " # include " caffe / filler . hpp " # include " caffe / vision _ layers . hpp " # include " caffe / test / test _ gradient _ check _ util . hpp " # include " caffe / test / test _ caffe _ main . hpp " using std :: isnan ; namespace caffe { extern cu@@ da@@ DeviceProp CA@@ FFE_TEST_@@ CUDA_@@ PROP ; template < typename Dtype > class PowerLayerTest : public :: testing :: Test { protected : PowerLayerTest ( ) : blob_bottom_ ( new Blob < Dtype > ( 2 , 3 , 4 , 5 ) ) , blob_top_ ( new Blob < Dtype > ( ) ) { Caffe :: set_random_@@ seed ( 1701 ) ; Filler@@ Parameter filler_param ; Gau@@ ssi@@ anFil@@ ler < Dtype > filler ( filler_param ) ; filler . Fill ( this -> blob_bottom_ ) ; blob_bottom_vec_ . push_back ( blob_bottom_ ) ; blob_top_vec_ . push_back ( blob_top_ ) ; } virtual ~ PowerLayerTest ( ) { delete blob_bottom_ ; delete blob_top_ ; } void TestForward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; layer . SetUp ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; layer . Forward ( this -> blob_bottom_vec_ , & ( this -> blob_top_vec_ ) ) ; const Dtype * bottom_data = this -> blob_bottom_ -> cpu_data ( ) ; const Dtype * top_data = this -> blob_top_ -> cpu_data ( ) ; const Dtype min_precision = 1e - 5 ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { Dtype expected_value = pow ( shift + scale * bottom_data [ i ] , power ) ; if ( power == Dtype ( 0 ) || power == Dtype ( 1 ) || power == Dtype ( 2 ) ) { EXPECT_FALSE ( isnan ( top_data [ i ] ) ) ; } if ( isnan ( expected_value ) ) { EXPECT_TRUE ( isnan ( top_data [ i ] ) ) ; } else { Dtype precision = max ( Dtype ( abs ( expected_value * 0.0001 ) ) , min_precision ) ; EXPECT_NEAR ( expected_value , top_data [ i ] , precision ) ; } } } void TestBackward ( Dtype power , Dtype scale , Dtype shift ) { LayerParameter layer_param ; layer_param . mutable_power_param ( ) -> set_power ( power ) ; layer_param . mutable_power_param ( ) -> set_scale ( scale ) ; layer_param . mutable_power_param ( ) -> set_shift ( shift ) ; PowerLayer < Dtype > layer ( layer_param ) ; if ( power != Dtype ( 0 ) && power != Dtype ( 1 ) && power != Dtype ( 2 ) ) { Dtype * bottom_data = this -> blob_bottom_ -> mutable_cpu_data ( ) ; Dtype min_value = - shift / scale ; for ( int i = 0 ; i < this -> blob_bottom_ -> count ( ) ; ++ i ) { if ( bottom_data [ i ] < min_value ) { bottom_data [ i ] = min_value + ( min_value - bottom_data [ i ] ) ; } } } GradientChecker < Dtype > checker ( 1e - 2 , 1e - 2 , 1701 , 0. , 0.01 ) ; checker . CheckGradient@@ Eltw@@ ise ( & layer , & ( this -> blob_bottom_vec_ ) , & ( this -> blob_top_vec_ ) ) ; } Blob < Dtype > * const blob_bottom_ ; Blob < Dtype > * const blob_top_ ; vector < Blob < Dtype > * > blob_bottom_vec_ ; vector < Blob < Dtype > * > blob_top_vec_ ; } ; typedef :: testing :: Types < float , double > Dtypes ; TYPED_TEST_CASE ( PowerLayerTest , Dtypes ) ; TYPED_TEST ( PowerLayerTest , TestPowerCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZero@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZero@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZero@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOne@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOne@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ CPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalf@@ GradientCPU ) { Caffe :: set_mode ( Caffe :: CPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerGradientShiftZero@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.37 ; TypeParam scale = 0.83 ; TypeParam shift = 0.0 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZero@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerZero@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 0.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOne@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerOne@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 1.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ GPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.34 ; TypeParam shift = - 2.4 ; this -> TestForward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwo@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.83 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } TYPED_TEST ( PowerLayerTest , TestPowerTwoScaleHalf@@ GradientGPU ) { Caffe :: set_mode ( Caffe :: GPU ) ; TypeParam power = 2.0 ; TypeParam scale = 0.5 ; TypeParam shift = - 2.4 ; this -> TestBackward ( power , scale , shift ) ; } } </DOCUMENT>
<DOCUMENT_ID="e@@ inon/@@ affymetri@@ x-@@ power-tool@@ s/tree/master/sdk/@@ calvin_@@ files/@@ parameter/test/@@ ParameterFileDataTest.cpp"> # include " calvin _ files / parameter / src / ParameterFileData . h " # include < cppunit / extensions / HelperMacros . h > using namespace affymetri@@ x_calvin_@@ parameter ; class ParameterFileDataTest : public CPPUNIT_NS :: TestFixture { CPPUNIT_TEST_SUITE ( ParameterFileDataTest ) ; CPPUNIT_TEST ( testAccess ) ; CPPUNIT_TEST_SUITE_END ( ) ; public : void setUp ( ) ; void tearDown ( ) ; void testAccess ( ) ; } ; CPPUNIT_TEST_SUITE_REGISTRATION ( ParameterFileDataTest ) ; void ParameterFileDataTest :: setUp ( ) { } void ParameterFileDataTest :: tearDown ( ) { } void ParameterFileDataTest :: testAccess ( ) { ParameterFileData d ; d . ImplementationAttributes ( ) . description = L " d " ; d . ImplementationAttributes ( ) . executableFileName = L " e " ; d . ImplementationAttributes ( ) . name = L " n " ; d . ImplementationAttributes ( ) . version = L " v " ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " d " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " e " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " n " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " v " ) ; d . ParameterFileAttributes ( ) . company = L " c " ; d . ParameterFileAttributes ( ) . userName = L " u " ; d . ParameterFileAttributes ( ) . contentVersion = L " cv " ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " c " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " u " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " cv " ) ; ParameterType p ; p . name = L " n " ; p . index = L " i " ; p . displayName = L " d " ; p . category = L " c " ; p . isEditable = L " is " ; p . type = L " t " ; p . currentValue = L " cv " ; p . minValue = L " mv " ; p . maxValue = L " xv " ; p . defaultValue = L " dv " ; p . precision = L " p " ; p . maxLength = L " l " ; p . description = L " de " ; CPPUNIT_ASSERT ( p . name == L " n " ) ; CPPUNIT_ASSERT ( p . index == L " i " ) ; CPPUNIT_ASSERT ( p . displayName == L " d " ) ; CPPUNIT_ASSERT ( p . category == L " c " ) ; CPPUNIT_ASSERT ( p . isEditable == L " is " ) ; CPPUNIT_ASSERT ( p . type == L " t " ) ; CPPUNIT_ASSERT ( p . currentValue == L " cv " ) ; CPPUNIT_ASSERT ( p . minValue == L " mv " ) ; CPPUNIT_ASSERT ( p . maxValue == L " xv " ) ; CPPUNIT_ASSERT ( p . defaultValue == L " dv " ) ; CPPUNIT_ASSERT ( p . precision == L " p " ) ; CPPUNIT_ASSERT ( p . maxLength == L " l " ) ; CPPUNIT_ASSERT ( p . description == L " de " ) ; d . Parameters ( ) . push_back ( p ) ; p . name . clear ( ) ; p . index . clear ( ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 1 ) ; d . Clear ( ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . description == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . executableFileName == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . name == L " " ) ; CPPUNIT_ASSERT ( d . ImplementationAttributes ( ) . version == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . company == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . userName == L " " ) ; CPPUNIT_ASSERT ( d . ParameterFileAttributes ( ) . contentVersion == L " " ) ; CPPUNIT_ASSERT ( d . Parameters ( ) . size ( ) == 0 ) ; } </DOCUMENT>
<DOCUMENT_ID="Morco@@ FreeCode/@@ 2015__MorcoEngine@@ 3D/tree/master/MorcoEngine@@ 3D v0.@@ 13/Source/@@ Libraries/@@ glm/@@ Include@@ /detail@@ /gl@@ m.cpp"> # include < glm / glm . hpp > # include < glm / gtc / quaternion . hpp > # include < glm / gtx / dual_quaternion . hpp > namespace glm { namespace detail { template struct tvec2 < uint8 , lowp > ; template struct tvec2 < uint16 , lowp > ; template struct tvec2 < uint32 , lowp > ; template struct tvec2 < uint64 , lowp > ; template struct tvec2 < int8 , lowp > ; template struct tvec2 < int16 , lowp > ; template struct tvec2 < int32 , lowp > ; template struct tvec2 < int64 , lowp > ; template struct tvec2 < float32 , lowp > ; template struct tvec2 < float64 , lowp > ; template struct tvec2 < uint8 , mediump > ; template struct tvec2 < uint16 , mediump > ; template struct tvec2 < uint32 , mediump > ; template struct tvec2 < uint64 , mediump > ; template struct tvec2 < int8 , mediump > ; template struct tvec2 < int16 , mediump > ; template struct tvec2 < int32 , mediump > ; template struct tvec2 < int64 , mediump > ; template struct tvec2 < float32 , mediump > ; template struct tvec2 < float64 , mediump > ; template struct tvec2 < uint8 , highp > ; template struct tvec2 < uint16 , highp > ; template struct tvec2 < uint32 , highp > ; template struct tvec2 < uint64 , highp > ; template struct tvec2 < int8 , highp > ; template struct tvec2 < int16 , highp > ; template struct tvec2 < int32 , highp > ; template struct tvec2 < int64 , highp > ; template struct tvec2 < float32 , highp > ; template struct tvec2 < float64 , highp > ; template struct tvec3 < uint8 , lowp > ; template struct tvec3 < uint16 , lowp > ; template struct tvec3 < uint32 , lowp > ; template struct tvec3 < uint64 , lowp > ; template struct tvec3 < int8 , lowp > ; template struct tvec3 < int16 , lowp > ; template struct tvec3 < int32 , lowp > ; template struct tvec3 < int64 , lowp > ; template struct tvec3 < float32 , lowp > ; template struct tvec3 < float64 , lowp > ; template struct tvec3 < uint8 , mediump > ; template struct tvec3 < uint16 , mediump > ; template struct tvec3 < uint32 , mediump > ; template struct tvec3 < uint64 , mediump > ; template struct tvec3 < int8 , mediump > ; template struct tvec3 < int16 , mediump > ; template struct tvec3 < int32 , mediump > ; template struct tvec3 < int64 , mediump > ; template struct tvec3 < float32 , mediump > ; template struct tvec3 < float64 , mediump > ; template struct tvec3 < uint8 , highp > ; template struct tvec3 < uint16 , highp > ; template struct tvec3 < uint32 , highp > ; template struct tvec3 < uint64 , highp > ; template struct tvec3 < int8 , highp > ; template struct tvec3 < int16 , highp > ; template struct tvec3 < int32 , highp > ; template struct tvec3 < int64 , highp > ; template struct tvec3 < float32 , highp > ; template struct tvec3 < float64 , highp > ; template struct tvec4 < uint8 , lowp > ; template struct tvec4 < uint16 , lowp > ; template struct tvec4 < uint32 , lowp > ; template struct tvec4 < uint64 , lowp > ; template struct tvec4 < int8 , lowp > ; template struct tvec4 < int16 , lowp > ; template struct tvec4 < int32 , lowp > ; template struct tvec4 < int64 , lowp > ; template struct tvec4 < float32 , lowp > ; template struct tvec4 < float64 , lowp > ; template struct tvec4 < uint8 , mediump > ; template struct tvec4 < uint16 , mediump > ; template struct tvec4 < uint32 , mediump > ; template struct tvec4 < uint64 , mediump > ; template struct tvec4 < int8 , mediump > ; template struct tvec4 < int16 , mediump > ; template struct tvec4 < int32 , mediump > ; template struct tvec4 < int64 , mediump > ; template struct tvec4 < float32 , mediump > ; template struct tvec4 < float64 , mediump > ; template struct tvec4 < uint8 , highp > ; template struct tvec4 < uint16 , highp > ; template struct tvec4 < uint32 , highp > ; template struct tvec4 < uint64 , highp > ; template struct tvec4 < int8 , highp > ; template struct tvec4 < int16 , highp > ; template struct tvec4 < int32 , highp > ; template struct tvec4 < int64 , highp > ; template struct tvec4 < float32 , highp > ; template struct tvec4 < float64 , highp > ; template struct tmat2x2 < float32 , lowp > ; template struct tmat2x2 < float64 , lowp > ; template struct tmat2x2 < float32 , mediump > ; template struct tmat2x2 < float64 , mediump > ; template struct tmat2x2 < float32 , highp > ; template struct tmat2x2 < float64 , highp > ; template struct tmat2x3 < float32 , lowp > ; template struct tmat2x3 < float64 , lowp > ; template struct tmat2x3 < float32 , mediump > ; template struct tmat2x3 < float64 , mediump > ; template struct tmat2x3 < float32 , highp > ; template struct tmat2x3 < float64 , highp > ; template struct tmat2x4 < float32 , lowp > ; template struct tmat2x4 < float64 , lowp > ; template struct tmat2x4 < float32 , mediump > ; template struct tmat2x4 < float64 , mediump > ; template struct tmat2x4 < float32 , highp > ; template struct tmat2x4 < float64 , highp > ; template struct tmat3x2 < float32 , lowp > ; template struct tmat3x2 < float64 , lowp > ; template struct tmat3x2 < float32 , mediump > ; template struct tmat3x2 < float64 , mediump > ; template struct tmat3x2 < float32 , highp > ; template struct tmat3x2 < float64 , highp > ; template struct tmat3x3 < float32 , lowp > ; template struct tmat3x3 < float64 , lowp > ; template struct tmat3x3 < float32 , mediump > ; template struct tmat3x3 < float64 , mediump > ; template struct tmat3x3 < float32 , highp > ; template struct tmat3x3 < float64 , highp > ; template struct tmat3x4 < float32 , lowp > ; template struct tmat3x4 < float64 , lowp > ; template struct tmat3x4 < float32 , mediump > ; template struct tmat3x4 < float64 , mediump > ; template struct tmat3x4 < float32 , highp > ; template struct tmat3x4 < float64 , highp > ; template struct tmat4x2 < float32 , lowp > ; template struct tmat4x2 < float64 , lowp > ; template struct tmat4x2 < float32 , mediump > ; template struct tmat4x2 < float64 , mediump > ; template struct tmat4x2 < float32 , highp > ; template struct tmat4x2 < float64 , highp > ; template struct tmat4x3 < float32 , lowp > ; template struct tmat4x3 < float64 , lowp > ; template struct tmat4x3 < float32 , mediump > ; template struct tmat4x3 < float64 , mediump > ; template struct tmat4x3 < float32 , highp > ; template struct tmat4x3 < float64 , highp > ; template struct tmat4x4 < float32 , lowp > ; template struct tmat4x4 < float64 , lowp > ; template struct tmat4x4 < float32 , mediump > ; template struct tmat4x4 < float64 , mediump > ; template struct tmat4x4 < float32 , highp > ; template struct tmat4x4 < float64 , highp > ; template struct tquat < float32 , lowp > ; template struct tquat < float64 , lowp > ; template struct tquat < float32 , mediump > ; template struct tquat < float64 , mediump > ; template struct tquat < float32 , highp > ; template struct tquat < float64 , highp > ; template struct tdualquat < float32 , lowp > ; template struct tdualquat < float64 , lowp > ; template struct tdualquat < float32 , mediump > ; template struct tdualquat < float64 , mediump > ; template struct tdualquat < float32 , highp > ; template struct tdualquat < float64 , highp > ; } } </DOCUMENT>
<DOCUMENT_ID="Admir@@ alCur@@ tiss@@ /ppsspp/tree/master/@@ unittest/UnitTest.cpp"> # include < cstdio > # include < cstdlib > # include < cmath > # include < string > # include < sstream > # include " base / NativeApp . h " # include " base / logging . h " # include " Common / CPUDetect . h " # include " Common / ArmEmitter . h " # include " ext / dis@@ arm . h " # include " math / math _ util . h " # include " util / text / parser@@ s . h " # include " Core / Config . h " # include " Core / MIPS / MIPSVFPU@@ Utils . h " # include " Core / FileSystem@@ s / ISOFile@@ System . h " # include " unittest / JitHarn@@ ess . h " # include " unittest / TestVertexJit . h " # include " unittest / UnitTest . h " std :: string System_Get@@ Property ( SystemProperty prop ) { return " " ; } int System_Get@@ PropertyInt ( SystemProperty prop ) { return - 1 ; } void NativeMessageReceived ( const char * message , const char * value ) { } void GL_S@@ wap@@ Interval ( int ) { } # ifndef M_PI_2 # define M_PI_2 1.5@@ 70796326@@ 79489@@ 6619@@ 23 # endif float fastasin ( double x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float sqrtthing = sqrt ( 1.0f - x * x ) ; float y = - .35@@ 7214248@@ 0f + .108@@ 706@@ 3463f * x ; y = y * x + 1.06@@ 25192@@ 36f ; y = y * x + - 2.5112@@ 7850@@ 6f ; y = y * x + .19@@ 1900116@@ f ; y = y * x + 1.807607311f ; y /= ( 1.807607311f - 1.615@@ 1950@@ 94 * x ) ; return sign * ( y - sqrtthing ) ; } double atan_66s ( double x ) { const double c1 = 1.68676@@ 2910@@ 6 ; const double c2 = 0.4@@ 378497304 ; const double c3 = 1.68676@@ 33134 ; double x2 ; x2 = x * x ; return ( x * ( c1 + x2 * c2 ) / ( c3 + x2 ) ) ; } double fastasin@@ 2 ( double x ) { return atan_66s ( x / sqrt ( 1 - x * x ) ) ; } float fastasin@@ 3 ( float x ) { return x + x * x * x * x * x * 0.4971 ; } float fastasin@@ 4 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; x = M_PI / 2 - sqrtf ( 1.0f - x ) * ( 1.57072@@ 88 + - 0.21211@@ 44 * x + 0.07426@@ 10 * x * x + - 0.0187@@ 293 * x * x * x ) ; return sign * x ; } float fastasin5 ( float x ) { float sign = x >= 0.0f ? 1.0f : - 1.0f ; x = fabs ( x ) ; float fRoot = sqrtf ( 1.0f - x ) ; float fResult = 0.07426@@ 10f + - 0.0187@@ 293f * x ; fResult = - 0.21211@@ 44f + fResult * x ; fResult = 1.57072@@ 88f + fResult * x ; fResult = M_PI / 2 - fRoot * fResult ; return sign * fResult ; } # define C 0.707106781186547@@ 52440f # define BITSPERQUARTER ( 20 ) void fcs ( float angle , float & sinout , float & cosout ) { int phasein = angle * ( 1 << BITSPERQUARTER ) ; float modphase = ( phasein & ( ( 1 << BITSPERQUARTER ) - 1 ) ) * ( 1.0f / ( 1 << BITSPERQUARTER ) ) ; int quarter = phasein >> BITSPERQUARTER ; if ( ! quarter ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = temp + x ; cosout = temp - x ; } else if ( quarter == 1 ) { float x = 0.5f - modphase ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x + temp ; cosout = x - temp ; } else if ( quarter == 2 ) { float x = modphase - 0.5f ; float temp = ( 4 * C - 2 ) * x * x - C ; sinout = temp - x ; cosout = temp + x ; } else if ( quarter == 3 ) { float x = modphase - 0.5f ; float temp = ( 2 - 4 * C ) * x * x + C ; sinout = x - temp ; cosout = x + temp ; } } # undef C const float PI@@ _SQR = 9.8696@@ 044010@@ 893586@@ 1883449@@ 099@@ 987615@@ 114f ; void fcs2 ( float theta , float & outsine , float & outcosine ) { float gamma = theta + 1 ; gamma += 2 ; gamma /= 4 ; theta += 2 ; theta /= 4 ; theta -= floorf ( theta ) ; gamma -= floorf ( gamma ) ; theta *= 4 ; theta -= 2 ; gamma *= 4 ; gamma -= 2 ; float x = 2 * gamma - gamma * fabs ( gamma ) ; float y = 2 * theta - theta * fabs ( theta ) ; const float P = 0.225 ; outsine = P * ( y * fabsf ( y ) - y ) + y ; outcosine = P * ( x * fabsf ( x ) - x ) + x ; } void fastsincos ( float x , float & sine , float & cosine ) { fcs2 ( x , sine , cosine ) ; } bool TestSinCos ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 30.0f ; float slowsin = sinf ( f * M_PI_2 ) , slowcos = cosf ( f * M_PI_2 ) ; float fastsin , fastcos ; fastsincos ( f , fastsin , fastcos ) ; printf ( " % f : ▁ slow : ▁ % 0.8f , ▁ % 0.8f ▁ fast : ▁ % 0.8f , ▁ % 0.8f \n " , f , slowsin , slowcos , fastsin , fastcos ) ; } return true ; } bool TestAsin ( ) { for ( int i = - 100 ; i <= 100 ; i ++ ) { float f = i / 100.0f ; float slowval = asinf ( f ) / M_PI_2 ; float fastval = fastasin5 ( f ) / M_PI_2 ; printf ( " slow : ▁ % 0.16f ▁ fast : ▁ % 0.16f \n " , slowval , fastval ) ; float diff = fabsf ( slowval - fastval ) ; } return true ; } bool TestMathUtil ( ) { EXPECT_FALSE ( my_isinf ( 1.0 ) ) ; volatile float zero = 0.0f ; EXPECT_TRUE ( my_isinf ( 1.0f / zero ) ) ; EXPECT_FALSE ( my_isnan ( 1.0f / zero ) ) ; return true ; } bool TestParsers ( ) { const char * macstr = "01@@ :02@@ :03 : ff : fe : fd " ; uint8_t mac [ 6 ] ; ParseMacAddress ( macstr , mac ) ; EXPECT_TRUE ( mac [ 0 ] == 1 ) ; EXPECT_TRUE ( mac [ 1 ] == 2 ) ; EXPECT_TRUE ( mac [ 2 ] == 3 ) ; EXPECT_TRUE ( mac [ 3 ] == 255 ) ; EXPECT_TRUE ( mac [ 4 ] == 254 ) ; EXPECT_TRUE ( mac [ 5 ] == 253 ) ; return true ; } bool TestVFPUSinCos ( ) { float sine , cosine ; vfpu_sincos ( 0.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 1.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 2.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , - 1.0f ) ; vfpu_sincos ( 3.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , - 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; vfpu_sincos ( 4.0f , sine , cosine ) ; EXPECT_EQ_FLOAT ( sine , 0.0f ) ; EXPECT_EQ_FLOAT ( cosine , 1.0f ) ; vfpu_sincos ( 5.0f , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , 1.0f ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , 0.0f ) ; for ( float angle = - 10.0f ; angle < 10.0f ; angle ++ ) { vfpu_sincos ( angle , sine , cosine ) ; EXPECT_APPROX_EQ_FLOAT ( sine , sinf ( angle * M_PI_2 ) ) ; EXPECT_APPROX_EQ_FLOAT ( cosine , cosf ( angle * M_PI_2 ) ) ; } return true ; } bool TestMatrixTranspose ( ) { MatrixSize sz = M_4x4 ; int matrix = 0 ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; int transposed = Xpose ( matrix ) ; u8 x_cols [ 4 ] ; u8 x_rows [ 4 ] ; GetMatrixColumns ( transposed , sz , x_cols ) ; GetMatrixRows ( transposed , sz , x_rows ) ; for ( int i = 0 ; i < GetMatrixSide ( sz ) ; i ++ ) { EXPECT_EQ_INT ( cols [ i ] , x_rows [ i ] ) ; EXPECT_EQ_INT ( x_cols [ i ] , rows [ i ] ) ; } return true ; } void TestGetMatrix ( int matrix , MatrixSize sz ) { ILOG ( " Testing ▁ matrix ▁ % s " , GetMatrixNotation ( matrix , sz ) ) ; u8 fullMatrix [ 16 ] ; u8 cols [ 4 ] ; u8 rows [ 4 ] ; GetMatrixColumns ( matrix , sz , cols ) ; GetMatrixRows ( matrix , sz , rows ) ; GetMatrixRegs ( fullMatrix , sz , matrix ) ; int n = GetMatrixSide ( sz ) ; VectorSize vsz = GetVector@@ Size ( sz ) ; for ( int i = 0 ; i < n ; i ++ ) { int colName = cols [ i ] ; int rowName = rows [ i ] ; ILOG ( " Column ▁ % i : ▁ % s " , i , GetVectorNotation ( colName , vsz ) ) ; ILOG ( " Row ▁ % i : ▁ % s " , i , GetVectorNotation ( rowName , vsz ) ) ; u8 colRegs [ 4 ] ; u8 rowRegs [ 4 ] ; GetVectorRegs ( colRegs , vsz , colName ) ; GetVectorRegs ( rowRegs , vsz , rowName ) ; std :: stringstream a , b , c , d ; for ( int j = 0 ; j < n ; j ++ ) { a . clear ( ) ; b . clear ( ) ; a << ( int ) fullMatrix [ i * 4 + j ] << " ▁ " ; b << ( int ) colRegs [ j ] << " ▁ " ; c . clear ( ) ; d . clear ( ) ; c << ( int ) fullMatrix [ j * 4 + i ] << " ▁ " ; d << ( int ) rowRegs [ j ] << " ▁ " ; } ILOG ( " Col : ▁ % s ▁ vs ▁ % s " , a . str ( ) . c_str ( ) , b . str ( ) . c_str ( ) ) ; if ( a . str ( ) != b . str ( ) ) ILOG ( " WRONG ! " ) ; ILOG ( " Row : ▁ % s ▁ vs ▁ % s " , c . str ( ) . c_str ( ) , d . str ( ) . c_str ( ) ) ; if ( c . str ( ) != d . str ( ) ) ILOG ( " WRONG ! " ) ; } } bool TestParseLBN ( ) { const char * validStrings [ ] = { " / sce _ lbn0x5fa0 _ size0x1428" , " / sce _ lbn@@ 7050 _ sizeee@@ 850@@ " , " / sce _ lbn@@ 0x5ee@@ eh _ size0x2@@ 34x " , " / sce _ lbneee _ _ size434 . " , } ; int expectedResults [ ] [ 2 ] = { { 0x5fa0 , 0x14@@ 28 } , { 0x7050 , 0xee@@ 850 } , { 0x5ee@@ e , 0x234 } , { 0xee@@ e , 0x434 } , } ; const char * invalidStrings [ ] = { " / sce _ lbn0x5fa0 _ sze0x1428" , " " , " // " , } ; for ( int i = 0 ; i < ARRAY_SIZE ( validStrings ) ; i ++ ) { u32 startSector = 0 , readSize = 0 ; EXPECT_TRUE ( parseLBN ( validStrings [ i ] , & startSector , & readSize ) ) ; EXPECT_EQ_INT ( startSector , expectedResults [ i ] [ 0 ] ) ; EXPECT_EQ_INT ( readSize , expectedResults [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < ARRAY_SIZE ( invalidStrings ) ; i ++ ) { u32 startSector , readSize ; EXPECT_FALSE ( parseLBN ( invalidStrings [ i ] , & startSector , & readSize ) ) ; } return true ; } typedef bool ( * TestFunc ) ( ) ; struct TestItem { const char * name ; TestFunc func ; } ; # define TEST_ITEM ( name ) { # name , & Test ## name , } bool TestArmEmitter ( ) ; bool TestArm64Emitter ( ) ; bool TestX64Emitter ( ) ; TestItem availableTests [ ] = { # if defined ( ARM64 ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( Arm64Emitter ) , # endif # if defined ( ARM ) || defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( ArmEmitter ) , # endif # if defined ( _M_X64 ) || defined ( _M_IX86 ) TEST_ITEM ( X64Emitter ) , # endif TEST_ITEM ( VertexJit ) , TEST_ITEM ( Asin ) , TEST_ITEM ( SinCos ) , TEST_ITEM ( VFPUSinCos ) , TEST_ITEM ( MathUtil ) , TEST_ITEM ( Parsers ) , TEST_ITEM ( Jit ) , TEST_ITEM ( MatrixTranspose ) , TEST_ITEM ( ParseLBN ) , } ; int main ( int argc , const char * argv [ ] ) { cpu_info . bNE@@ ON = true ; cpu_info . bVF@@ P = true ; cpu_info . bVF@@ Pv3 = true ; cpu_info . bVF@@ Pv4 = true ; g_Config . bEnable@@ Logging = true ; bool allTests = false ; TestFunc testFunc = nullptr ; if ( argc >= 2 ) { if ( ! strcasecmp ( argv [ 1 ] , " all " ) ) { allTests = true ; } for ( auto f : availableTests ) { if ( ! strcasecmp ( argv [ 1 ] , f . name ) ) { testFunc = f . func ; break ; } } } if ( allTests ) { int passes = 0 ; int fails = 0 ; for ( auto f : availableTests ) { if ( f . func ( ) ) { ++ passes ; } else { printf ( " % s : ▁ FAILED \n " , f . name ) ; ++ fails ; } } if ( passes > 0 ) { printf ( " % d ▁ tests ▁ passed . \n " , passes ) ; } if ( fails > 0 ) { return 2 ; } } else if ( testFunc == nullptr ) { fprintf ( stderr , " You ▁ may ▁ select ▁ a ▁ test ▁ to ▁ run ▁ by ▁ passing ▁ an ▁ argument . \n " ) ; fprintf ( stderr , " \n " ) ; fprintf ( stderr , " Available ▁ tests : \n " ) ; for ( auto f : availableTests ) { fprintf ( stderr , " ▁ ▁ * ▁ % s \n " , f . name ) ; } return 1 ; } else { if ( ! testFunc ( ) ) { return 2 ; } } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="qt@@ project/qtwebkit@@ /tree/master/Source/@@ WebCore/html/@@ HTMLFrameSetElement.cpp"> # include " config . h " # include " HTMLFrameSetElement . h " # include " CSSProperty@@ Names . h " # include " Document . h " # include " ElementIterator . h " # include " Event . h " # include " EventNames . h " # include " Frame . h " # include " FrameLoader . h " # include " FrameLoad@@ erClient . h " # include " HTMLBodyElement . h " # include " HTMLNames . h " # include " Length . h " # include " MouseEvent . h " # include " RenderFrameSet . h " # include " Text . h " namespace WebCore { using namespace HTMLNames ; HTMLFrameSetElement :: HTMLFrameSetElement ( const QualifiedName & tagName , Document & document ) : HTMLElement ( tagName , document ) , m_totalRows ( 1 ) , m_totalCols ( 1 ) , m_border ( 6 ) , m_borderSet ( false ) , m_borderColorSet ( false ) , m_frameborder ( true ) , m_frameborderSet ( false ) , m_noresize ( false ) { ASSERT ( hasTagName ( framesetTag ) ) ; setHasCustomStyle@@ Resolve@@ Callbacks ( ) ; } Ref < HTMLFrameSetElement > HTMLFrameSetElement :: create ( const QualifiedName & tagName , Document & document ) { return adoptRef ( * new HTMLFrameSetElement ( tagName , document ) ) ; } bool HTMLFrameSetElement :: isPresentationAttribute ( const QualifiedName & name ) const { if ( name == bordercolorAttr ) return true ; return HTMLElement :: isPresentationAttribute ( name ) ; } void HTMLFrameSetElement :: collectStyleForPresentationAttribute ( const QualifiedName & name , const AtomicString & value , Mutable@@ StyleProperties & style ) { if ( name == bordercolorAttr ) addHTML@@ ColorToStyle ( style , CSSProperty@@ BorderColor , value ) ; else HTMLElement :: collectStyleForPresentationAttribute ( name , value , style ) ; } void HTMLFrameSetElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == rowsAttr ) { if ( ! value . isNull ( ) ) { m_row@@ Lengths = newLengthArray ( value . string ( ) , m_totalRows ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == colsAttr ) { if ( ! value . isNull ( ) ) { m_col@@ Lengths = newLengthArray ( value . string ( ) , m_totalCols ) ; setNeedsStyleRecalc ( ) ; } return ; } if ( name == frameborderAttr ) { if ( ! value . isNull ( ) ) { if ( equalLettersIgnoringASCIICase ( value , " no " ) || value == "0" ) { m_frameborder = false ; m_frameborderSet = true ; } else if ( equalLettersIgnoringASCIICase ( value , " yes " ) || value == "1" ) { m_frameborderSet = true ; } } else { m_frameborder = false ; m_frameborderSet = false ; } return ; } if ( name == noresize@@ Attr ) { m_noresize = true ; return ; } if ( name == borderAttr ) { if ( ! value . isNull ( ) ) { m_border = value . toInt ( ) ; m_borderSet = true ; } else m_borderSet = false ; return ; } if ( name == bordercolorAttr ) { m_borderColorSet = ! value . isEmpty ( ) ; return ; } auto & eventName = HTMLBodyElement :: eventNameFor@@ WindowEventHandler@@ Attribute ( name ) ; if ( ! eventName . isNull ( ) ) { document ( ) . setWindow@@ AttributeEventListener ( eventName , name , value ) ; return ; } HTMLElement :: parseAttribute ( name , value ) ; } bool HTMLFrameSetElement :: rendererIsNeeded ( const RenderStyle & style ) { return style . isStyle@@ Available ( ) ; } RenderPtr < RenderElement > HTMLFrameSetElement :: createElement@@ Renderer ( Ref < RenderStyle > && style , const RenderTree@@ Position & ) { if ( style . get ( ) . hasContent ( ) ) return RenderElement :: createFor ( * this , WTFMove ( style ) ) ; return createRenderer < RenderFrameSet > ( * this , WTFMove ( style ) ) ; } HTMLFrameSetElement * HTMLFrameSetElement :: findContaining ( Element * descendant ) { return ancestorsOf@@ Type < HTMLFrameSetElement > ( * descendant ) . first ( ) ; } void HTMLFrameSetElement :: willAttach@@ Renderers ( ) { const HTMLFrameSetElement * containingFrameSet = findContaining ( this ) ; if ( ! containingFrameSet ) return ; if ( ! m_frameborderSet ) m_frameborder = containingFrameSet -> hasFrame@@ Border ( ) ; if ( m_frameborder ) { if ( ! m_borderSet ) m_border = containingFrameSet -> border ( ) ; if ( ! m_borderColorSet ) m_borderColorSet = containingFrameSet -> hasBorderColor ( ) ; } if ( ! m_noresize ) m_noresize = containingFrameSet -> noResize ( ) ; } void HTMLFrameSetElement :: defaultEventHandler ( Event * event ) { ASSERT ( event ) ; if ( is < MouseEvent > ( * event ) && ! m_noresize && is < RenderFrameSet > ( renderer ( ) ) ) { if ( downcast < RenderFrameSet > ( * renderer ( ) ) . userResize ( downcast < MouseEvent > ( event ) ) ) { event -> setDefault@@ Handled ( ) ; return ; } } HTMLElement :: defaultEventHandler ( event ) ; } bool HTMLFrameSetElement :: willRecalcStyle ( Style :: Change ) { if ( needs@@ StyleRecalc ( ) && renderer ( ) ) { renderer ( ) -> setNeeds@@ Layout ( ) ; clearNeeds@@ StyleRecalc ( ) ; } return true ; } Node :: InsertionNotificationRequest HTMLFrameSetElement :: insertedInto ( ContainerNode & insertionPoint ) { HTMLElement :: insertedInto ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } return Insertion@@ Done ; } void HTMLFrameSetElement :: removedFrom ( ContainerNode & insertionPoint ) { HTMLElement :: removedFrom ( insertionPoint ) ; if ( insertionPoint . inDocument ( ) ) { if ( Frame * frame = document ( ) . frame ( ) ) frame -> loader ( ) . client ( ) . dispatchDidBecomeFrameset ( document ( ) . isFrameSet ( ) ) ; } } } </DOCUMENT>
<DOCUMENT_ID="ge@@ ofl/@@ JK@@ 2_1.02@@ Source/tree/master/CODE-mp@@ /server/@@ sv_world.cpp"> # include " server . h " clipHandle_t SV_ClipHandleForEntity ( const sharedEntity_t * ent ) { if ( ent -> r . bmodel ) { return CM_InlineModel ( ent -> s . modelindex ) ; } if ( ent -> r . svFlags & SVF_@@ CAPSUL@@ E ) { return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qtrue ) ; } return CM_TempBoxModel ( ent -> r . mins , ent -> r . maxs , qfalse ) ; } typedef struct worldSector_s { int axis ; float dist ; struct worldSector_s * children [ 2 ] ; svEntity_t * entities ; } worldSector_t ; # define AREA_DEPTH 4 # define AREA_NODES 64 worldSector_t sv_worldSectors [ AREA_NODES ] ; int sv_numworldSectors ; void SV_Sector@@ List_f ( void ) { int i , c ; worldSector_t * sec ; svEntity_t * ent ; for ( i = 0 ; i < AREA_NODES ; i ++ ) { sec = & sv_worldSectors [ i ] ; c = 0 ; for ( ent = sec -> entities ; ent ; ent = ent -> nextEntityInWorldSector ) { c ++ ; } Com_Printf ( " sector ▁ % i : ▁ % i ▁ entities \n " , i , c ) ; } } worldSector_t * SV_CreateworldSector ( int depth , vec3_t mins , vec3_t maxs ) { worldSector_t * anode ; vec3_t size ; vec3_t mins1 , maxs1 , mins2 , maxs2 ; anode = & sv_worldSectors [ sv_numworldSectors ] ; sv_numworldSectors ++ ; if ( depth == AREA_DEPTH ) { anode -> axis = - 1 ; anode -> children [ 0 ] = anode -> children [ 1 ] = NULL ; return anode ; } VectorSubtract ( maxs , mins , size ) ; if ( size [ 0 ] > size [ 1 ] ) { anode -> axis = 0 ; } else { anode -> axis = 1 ; } anode -> dist = 0.5 * ( maxs [ anode -> axis ] + mins [ anode -> axis ] ) ; VectorCopy ( mins , mins1 ) ; VectorCopy ( mins , mins2 ) ; VectorCopy ( maxs , maxs1 ) ; VectorCopy ( maxs , maxs2 ) ; maxs1 [ anode -> axis ] = mins2 [ anode -> axis ] = anode -> dist ; anode -> children [ 0 ] = SV_CreateworldSector ( depth + 1 , mins2 , maxs2 ) ; anode -> children [ 1 ] = SV_CreateworldSector ( depth + 1 , mins1 , maxs1 ) ; return anode ; } void SV_ClearWorld ( void ) { clipHandle_t h ; vec3_t mins , maxs ; Com_Memset ( sv_worldSectors , 0 , sizeof ( sv_worldSectors ) ) ; sv_numworldSectors = 0 ; h = CM_InlineModel ( 0 ) ; CM_ModelBounds ( h , mins , maxs ) ; SV_CreateworldSector ( 0 , mins , maxs ) ; } void SV_UnlinkEntity ( sharedEntity_t * gEnt ) { svEntity_t * ent ; svEntity_t * scan ; worldSector_t * ws ; ent = SV_SvEntityForGentity ( gEnt ) ; gEnt -> r . linked = qfalse ; ws = ent -> worldSector ; if ( ! ws ) { return ; } ent -> worldSector = NULL ; if ( ws -> entities == ent ) { ws -> entities = ent -> nextEntityInWorldSector ; return ; } for ( scan = ws -> entities ; scan ; scan = scan -> nextEntityInWorldSector ) { if ( scan -> nextEntityInWorldSector == ent ) { scan -> nextEntityInWorldSector = ent -> nextEntityInWorldSector ; return ; } } Com_Printf ( " WARNING : ▁ SV _ UnlinkEntity : ▁ not ▁ found ▁ in ▁ worldSector \n " ) ; } # define MAX_TOTAL_ENT_LEAFS 128 void SV_Link@@ Entity ( sharedEntity_t * gEnt ) { worldSector_t * node ; int leafs [ MAX_TOTAL_ENT_LEAFS ] ; int cluster ; int num_leafs ; int i , j , k ; int area ; int lastLeaf ; float * origin , * angles ; svEntity_t * ent ; ent = SV_SvEntityForGentity ( gEnt ) ; if ( ent -> worldSector ) { SV_UnlinkEntity ( gEnt ) ; } if ( gEnt -> r . bmodel ) { gEnt -> s . solid = SOL@@ ID_BMODE@@ L ; } else if ( gEnt -> r . contents & ( CONTENTS_S@@ OLID | CONTENTS_@@ BODY ) ) { i = gEnt -> r . maxs [ 0 ] ; if ( i < 1 ) i = 1 ; if ( i > 255 ) i = 255 ; j = ( - gEnt -> r . mins [ 2 ] ) ; if ( j < 1 ) j = 1 ; if ( j > 255 ) j = 255 ; k = ( gEnt -> r . maxs [ 2 ] + 32 ) ; if ( k < 1 ) k = 1 ; if ( k > 255 ) k = 255 ; gEnt -> s . solid = ( k << 16 ) | ( j << 8 ) | i ; } else { gEnt -> s . solid = 0 ; } origin = gEnt -> r . currentOrigin ; angles = gEnt -> r . currentAngles ; if ( gEnt -> r . bmodel && ( angles [ 0 ] || angles [ 1 ] || angles [ 2 ] ) ) { float max ; int i ; max = Radi@@ usFrom@@ Bounds ( gEnt -> r . mins , gEnt -> r . maxs ) ; for ( i = 0 ; i < 3 ; i ++ ) { gEnt -> r . absmin [ i ] = origin [ i ] - max ; gEnt -> r . absmax [ i ] = origin [ i ] + max ; } } else { VectorAdd ( origin , gEnt -> r . mins , gEnt -> r . absmin ) ; VectorAdd ( origin , gEnt -> r . maxs , gEnt -> r . absmax ) ; } gEnt -> r . absmin [ 0 ] -= 1 ; gEnt -> r . absmin [ 1 ] -= 1 ; gEnt -> r . absmin [ 2 ] -= 1 ; gEnt -> r . absmax [ 0 ] += 1 ; gEnt -> r . absmax [ 1 ] += 1 ; gEnt -> r . absmax [ 2 ] += 1 ; ent -> numClusters = 0 ; ent -> lastCluster = 0 ; ent -> areanum = - 1 ; ent -> areanum2 = - 1 ; num_leafs = CM_BoxLeaf@@ nums ( gEnt -> r . absmin , gEnt -> r . absmax , leafs , MAX_TOTAL_ENT_LEAFS , & lastLeaf ) ; if ( ! num_leafs ) { return ; } for ( i = 0 ; i < num_leafs ; i ++ ) { area = CM_Leaf@@ Area ( leafs [ i ] ) ; if ( area != - 1 ) { if ( ent -> areanum != - 1 && ent -> areanum != area ) { if ( ent -> areanum2 != - 1 && ent -> areanum2 != area && sv . state == SS_@@ LOAD@@ ING ) { Com_DPrintf ( " Object ▁ % i ▁ touch@@ ing ▁ 3 ▁ areas ▁ at ▁ % f ▁ % f ▁ % f \n " , gEnt -> s . number , gEnt -> r . absmin [ 0 ] , gEnt -> r . absmin [ 1 ] , gEnt -> r . absmin [ 2 ] ) ; } ent -> areanum2 = area ; } else { ent -> areanum = area ; } } } ent -> numClusters = 0 ; for ( i = 0 ; i < num_leafs ; i ++ ) { cluster = CM_LeafCluster ( leafs [ i ] ) ; if ( cluster != - 1 ) { ent -> clusternums [ ent -> numClusters ++ ] = cluster ; if ( ent -> numClusters == MAX_ENT_CLU@@ STERS ) { break ; } } } if ( i != num_leafs ) { ent -> lastCluster = CM_LeafCluster ( lastLeaf ) ; } gEnt -> r . linkcount ++ ; node = sv_worldSectors ; while ( 1 ) { if ( node -> axis == - 1 ) break ; if ( gEnt -> r . absmin [ node -> axis ] > node -> dist ) node = node -> children [ 0 ] ; else if ( gEnt -> r . absmax [ node -> axis ] < node -> dist ) node = node -> children [ 1 ] ; else break ; } ent -> worldSector = node ; ent -> nextEntityInWorldSector = node -> entities ; node -> entities = ent ; gEnt -> r . linked = qtrue ; } typedef struct { const float * mins ; const float * maxs ; int * list ; int count , maxcount ; } areaParms_t ; void SV_AreaEntities_r ( worldSector_t * node , areaParms_t * ap ) { svEntity_t * check , * next ; sharedEntity_t * gcheck ; int count ; count = 0 ; for ( check = node -> entities ; check ; check = next ) { next = check -> nextEntityInWorldSector ; gcheck = SV_G@@ EntityFor@@ Sv@@ Entity ( check ) ; if ( gcheck -> r . absmin [ 0 ] > ap -> maxs [ 0 ] || gcheck -> r . absmin [ 1 ] > ap -> maxs [ 1 ] || gcheck -> r . absmin [ 2 ] > ap -> maxs [ 2 ] || gcheck -> r . absmax [ 0 ] < ap -> mins [ 0 ] || gcheck -> r . absmax [ 1 ] < ap -> mins [ 1 ] || gcheck -> r . absmax [ 2 ] < ap -> mins [ 2 ] ) { continue ; } if ( ap -> count == ap -> maxcount ) { Com_Printf ( " SV _ AreaEntities : ▁ MAXCOUNT \n " ) ; return ; } ap -> list [ ap -> count ] = check - sv . svEntities ; ap -> count ++ ; } if ( node -> axis == - 1 ) { return ; } if ( ap -> maxs [ node -> axis ] > node -> dist ) { SV_AreaEntities_r ( node -> children [ 0 ] , ap ) ; } if ( ap -> mins [ node -> axis ] < node -> dist ) { SV_AreaEntities_r ( node -> children [ 1 ] , ap ) ; } } int SV_AreaEntities ( const vec3_t mins , const vec3_t maxs , int * entityList , int maxcount ) { areaParms_t ap ; ap . mins = mins ; ap . maxs = maxs ; ap . list = entityList ; ap . count = 0 ; ap . maxcount = maxcount ; SV_AreaEntities_r ( sv_worldSectors , & ap ) ; return ap . count ; } typedef struct { vec3_t boxmins , boxmaxs ; const float * mins ; const float * maxs ; vec3_t start ; vec3_t end ; int passEntityNum ; int contentmask ; int capsule ; int traceFlags ; int useLod ; trace_t trace ; } moveclip_t ; void SV_ClipToEntity ( trace_t * trace , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int entityNum , int contentmask , int capsule ) { sharedEntity_t * touch ; clipHandle_t clipHandle ; float * origin , * angles ; touch = SV_GentityNum ( entityNum ) ; Com_Memset ( trace , 0 , sizeof ( trace_t ) ) ; if ( ! ( contentmask & touch -> r . contents ) ) { trace -> fraction = 1.0 ; return ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( trace , ( float * ) start , ( float * ) end , ( float * ) mins , ( float * ) maxs , clipHandle , contentmask , origin , angles , capsule ) ; if ( trace -> fraction < 1 ) { trace -> entityNum = touch -> s . number ; } } void SV_ClipMoveToEntities ( moveclip_t * clip ) { int i , num ; int touchlist [ MAX_GENTITIES ] ; sharedEntity_t * touch ; int passOwnerNum ; trace_t trace , oldTrace ; clipHandle_t clipHandle ; float * origin , * angles ; int thisOwnerShared = 1 ; num = SV_AreaEntities ( clip -> boxmins , clip -> boxmaxs , touchlist , MAX_GENTITIES ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { passOwnerNum = ( SV_GentityNum ( clip -> passEntityNum ) ) -> r . ownerNum ; if ( passOwnerNum == ENTITYNUM_NONE ) { passOwnerNum = - 1 ; } } else { passOwnerNum = - 1 ; } if ( SV_GentityNum ( clip -> passEntityNum ) -> r . svFlags & SVF_OWNERNOTSHARED ) { thisOwnerShared = 0 ; } for ( i = 0 ; i < num ; i ++ ) { if ( clip -> trace . allsolid ) { return ; } touch = SV_GentityNum ( touchlist [ i ] ) ; if ( clip -> passEntityNum != ENTITYNUM_NONE ) { if ( touchlist [ i ] == clip -> passEntityNum ) { continue ; } if ( touch -> r . ownerNum == clip -> passEntityNum ) { if ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) { if ( clip -> contentmask != ( MASK_SHOT | CONTENTS_LIGHTSABER ) && clip -> contentmask != ( MASK_SHOT ) ) { continue ; } } else { continue ; } } if ( touch -> r . ownerNum == passOwnerNum && ! ( touch -> r . svFlags & SVF_OWNERNOTSHARED ) && ! thisOwnerShared ) { continue ; } } if ( ! ( clip -> contentmask & touch -> r . contents ) ) { continue ; } if ( ( clip -> contentmask == ( MASK_SHOT | CONTENTS_LIGHTSABER ) || clip -> contentmask == MASK_SHOT ) && ( touch -> r . contents > 0 && ( touch -> r . contents & CONTENTS_@@ NOSHOT ) ) ) { continue ; } clipHandle = SV_ClipHandleForEntity ( touch ) ; origin = touch -> r . currentOrigin ; angles = touch -> r . currentAngles ; if ( ! touch -> r . bmodel ) { angles = vec3_origin ; } CM_TransformedBoxTrace ( & trace , ( float * ) clip -> start , ( float * ) clip -> end , ( float * ) clip -> mins , ( float * ) clip -> maxs , clipHandle , clip -> contentmask , origin , angles , clip -> capsule ) ; oldTrace = clip -> trace ; if ( trace . allsolid ) { clip -> trace . allsolid = qtrue ; trace . entityNum = touch -> s . number ; } else if ( trace . startsolid ) { clip -> trace . startsolid = qtrue ; trace . entityNum = touch -> s . number ; } if ( trace . fraction < clip -> trace . fraction ) { qboolean oldStart ; oldStart = clip -> trace . startsolid ; trace . entityNum = touch -> s . number ; clip -> trace = trace ; clip -> trace . startsolid = ( qboolean ) ( ( unsigned ) clip -> trace . startsolid | ( unsigned ) oldStart ) ; } # if 0 if ( ( trace . entityNum == touch -> s . number ) && ( clip -> traceFlags ) ) { if ( touch -> s . ghoul2 ) { int oldTraceRecSize = 0 ; int newTraceRecSize = 0 ; int z ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { oldTraceRecSize ++ ; } } G2@@ API_@@ Collision@@ Detect ( & clip -> trace . G2CollisionMap [ 0 ] , * ( ( CGhoul2Info@@ _v * ) touch -> s . ghoul2 ) , touch -> s . angles , touch -> s . origin , svs . time , touch -> s . number , clip -> start , clip -> end , touch -> s . modelScale , G2@@ VertSpace@@ Server , clip -> traceFlags , clip -> useLod ) ; for ( z = 0 ; z < MAX_G2_COLLISIONS ; z ++ ) { if ( clip -> trace . G2CollisionMap [ z ] . mEntityNum != - 1 ) { newTraceRecSize ++ ; } } if ( newTraceRecSize == oldTraceRecSize ) { clip -> trace = oldTrace ; } } } # endif } } void SV_Trace ( trace_t * results , const vec3_t start , const vec3_t mins , const vec3_t maxs , const vec3_t end , int passEntityNum , int contentmask , int capsule , int traceFlags , int useLod ) { moveclip_t clip ; int i ; if ( ! mins ) { mins = vec3_origin ; } if ( ! maxs ) { maxs = vec3_origin ; } Com_Memset ( & clip , 0 , sizeof ( moveclip_t ) ) ; CM_BoxTrace ( & clip . trace , start , end , mins , maxs , 0 , contentmask , capsule ) ; clip . trace . entityNum = clip . trace . fraction != 1.0 ? ENTITYNUM_@@ WORLD : ENTITYNUM_NONE ; if ( clip . trace . fraction == 0 ) { * results = clip . trace ; return ; } clip . contentmask = contentmask ; VectorCopy ( start , clip . start ) ; clip . traceFlags = traceFlags ; clip . useLod = useLod ; VectorCopy ( end , clip . end ) ; clip . mins = mins ; clip . maxs = maxs ; clip . passEntityNum = passEntityNum ; clip . capsule = capsule ; for ( i = 0 ; i < 3 ; i ++ ) { if ( end [ i ] > start [ i ] ) { clip . boxmins [ i ] = clip . start [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . end [ i ] + clip . maxs [ i ] + 1 ; } else { clip . boxmins [ i ] = clip . end [ i ] + clip . mins [ i ] - 1 ; clip . boxmaxs [ i ] = clip . start [ i ] + clip . maxs [ i ] + 1 ; } } SV_ClipMoveToEntities ( & clip ) ; * results = clip . trace ; } int SV_PointContents ( const vec3_t p , int passEntityNum ) { int touch [ MAX_GENTITIES ] ; sharedEntity_t * hit ; int i , num ; int contents , c2 ; clipHandle_t clipHandle ; float * angles ; contents = CM_PointContents ( p , 0 ) ; num = SV_AreaEntities ( p , p , touch , MAX_GENTITIES ) ; for ( i = 0 ; i < num ; i ++ ) { if ( touch [ i ] == passEntityNum ) { continue ; } hit = SV_GentityNum ( touch [ i ] ) ; clipHandle = SV_ClipHandleForEntity ( hit ) ; angles = hit -> s . angles ; if ( ! hit -> r . bmodel ) { angles = vec3_origin ; } c2 = CM_Transformed@@ PointContents ( p , clipHandle , hit -> s . origin , hit -> s . angles ) ; contents |= c2 ; } return contents ; } </DOCUMENT>
<DOCUMENT_ID="sacar@@ lson/@@ MultiCoin-exp@@ /tree/master/src/db.cpp"> # include " headers . h " # include " db . h " # include " net . h " # include " auxpow . h " # include < boost / filesystem . hpp > # include < boost / filesystem / fstream . hpp > using namespace std ; using namespace boost ; unsigned int nWalletDBUpdated ; uint64 nAccountingEntryNumber = 0 ; static CCriticalSection cs_db ; static bool fDbEnvInit = false ; DbEnv dbenv ( 0 ) ; static map < string , int > mapFileUseCount ; static map < string , Db * > mapDb ; class CDBInit { public : CDBInit ( ) { } ~ CDBInit ( ) { if ( fDbEnvInit ) { dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } instance_@@ of_cdb@@ init ; CDB :: CDB ( const char * pszFile , const char * pszMode ) : pdb ( NULL ) { int ret ; if ( pszFile == NULL ) return ; fReadOnly = ( ! strchr ( pszMode , ' + ' ) && ! strchr ( pszMode , ' w ' ) ) ; bool fCreate = strchr ( pszMode , ' c ' ) ; unsigned int nFlags = DB_THREAD ; if ( fCreate ) nFlags |= DB_CREATE ; CRITICAL_BLOCK ( cs_db ) { if ( ! fDbEnvInit ) { if ( fShutdown ) return ; string strDataDir = GetDataDir ( ) ; string strLogDir = strDataDir + " / database " ; filesystem :: create_directory ( strLogDir . c_str ( ) ) ; string strErrorFile = strDataDir + " / db . log " ; printf ( " dbenv . open ▁ strLogDir = % s ▁ strErrorFile = % s \n " , strLogDir . c_str ( ) , strErrorFile . c_str ( ) ) ; dbenv . set_lg_@@ dir ( strLogDir . c_str ( ) ) ; dbenv . set_lg_@@ max ( 10000000 ) ; dbenv . set_lk_max_@@ locks ( 10000 ) ; dbenv . set_lk_max_@@ objects ( 10000 ) ; dbenv . set_errfile ( fopen ( strErrorFile . c_str ( ) , " a " ) ) ; dbenv . set_flags ( DB_AUTO_@@ COMMIT , 1 ) ; ret = dbenv . open ( strDataDir . c_str ( ) , DB_CREATE | DB_INIT_@@ LOCK | DB_INIT_@@ LOG | DB_INIT_@@ MPOO@@ L | DB_INIT_@@ TXN | DB_THREAD | DB_REC@@ OVER , S_IR@@ USR | S_I@@ WUSR ) ; if ( ret > 0 ) throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ error ▁ % d ▁ opening ▁ database ▁ environment " , ret ) ) ; fDbEnvInit = true ; } strFile = pszFile ; ++ mapFileUseCount [ strFile ] ; pdb = mapDb [ strFile ] ; if ( pdb == NULL ) { pdb = new Db ( & dbenv , 0 ) ; ret = pdb -> open ( NULL , pszFile , " main " , DB_BTRE@@ E , nFlags , 0 ) ; if ( ret > 0 ) { delete pdb ; pdb = NULL ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; strFile = " " ; throw runtime_error ( strprintf ( " CDB ( ) ▁ : ▁ can ' t ▁ open ▁ database ▁ file ▁ % s , ▁ error ▁ % d " , pszFile , ret ) ) ; } if ( fCreate && ! Exists ( string ( " version " ) ) ) { bool fTmp = fReadOnly ; fReadOnly = false ; WriteVersion ( VERSION ) ; fReadOnly = fTmp ; } mapDb [ strFile ] = pdb ; } } } void CDB :: Close ( ) { if ( ! pdb ) return ; if ( ! vTxn . empty ( ) ) vTxn . front ( ) -> abort ( ) ; vTxn . clear ( ) ; pdb = NULL ; unsigned int nMinutes = 0 ; if ( fReadOnly ) nMinutes = 1 ; if ( strFile == " addr . dat " ) nMinutes = 2 ; if ( strFile == " blkindex . dat " && IsInitial@@ BlockDown@@ load ( ) && nBestHeight % 500 != 0 ) nMinutes = 1 ; dbenv . txn_checkpoint ( 0 , nMinutes , 0 ) ; CRITICAL_BLOCK ( cs_db ) -- mapFileUseCount [ strFile ] ; } void static CloseDb ( const string & strFile ) { CRITICAL_BLOCK ( cs_db ) { if ( mapDb [ strFile ] != NULL ) { Db * pdb = mapDb [ strFile ] ; pdb -> close ( 0 ) ; delete pdb ; mapDb [ strFile ] = NULL ; } } } void DBFlush ( bool fShutdown ) { printf ( " DBFlush ( % s ) % s \n " , fShutdown ? " true " : " false " , fDbEnvInit ? " " : " ▁ db ▁ not ▁ started " ) ; if ( ! fDbEnvInit ) return ; CRITICAL_BLOCK ( cs_db ) { map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { string strFile = ( * mi ) . first ; int nRefCount = ( * mi ) . second ; printf ( " % s ▁ refcount = % d \n " , strFile . c_str ( ) , nRefCount ) ; if ( nRefCount == 0 ) { CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; printf ( " % s ▁ flush \n " , strFile . c_str ( ) ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; } else mi ++ ; } if ( fShutdown ) { char * * listp ; if ( mapFileUseCount . empty ( ) ) dbenv . log_arch@@ ive ( & listp , DB_ARCH_@@ REMOVE ) ; dbenv . close ( 0 ) ; fDbEnvInit = false ; } } } bool CTxDB :: ReadTxIndex ( uint256 hash , CTxIndex & txindex ) { assert ( ! fClient ) ; txindex . SetNull ( ) ; return Read ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: UpdateTxIndex ( uint256 hash , const CTxIndex & txindex ) { assert ( ! fClient ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: AddTxIndex ( const CTransaction & tx , const CDiskTxPos & pos , int nHeight ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; CTxIndex txindex ( pos , tx . vout . size ( ) ) ; return Write ( make_pair ( string ( " tx " ) , hash ) , txindex ) ; } bool CTxDB :: Erase@@ TxIndex ( const CTransaction & tx ) { assert ( ! fClient ) ; uint256 hash = tx . GetHash ( ) ; return Erase ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ContainsTx ( uint256 hash ) { assert ( ! fClient ) ; return Exists ( make_pair ( string ( " tx " ) , hash ) ) ; } bool CTxDB :: ReadOwner@@ Txes ( uint160 hash160 , int nMinHeight , vector < CTransaction > & vtx ) { assert ( ! fClient ) ; vtx . clear ( ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << string ( " owner " ) << hash160 << CDiskTxPos ( 0 , 0 , 0 ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; return false ; } string strType ; uint160 hashItem ; CDiskTxPos pos ; ssKey >> strType >> hashItem >> pos ; int nItemHeight ; ssValue >> nItemHeight ; if ( strType != " owner " || hashItem != hash160 ) break ; if ( nItemHeight >= nMinHeight ) { vtx . resize ( vtx . size ( ) + 1 ) ; if ( ! vtx . back ( ) . ReadFromDisk ( pos ) ) { pcursor -> close ( ) ; return false ; } } } pcursor -> close ( ) ; return true ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx , CTxIndex & txindex ) { assert ( ! fClient ) ; tx . SetNull ( ) ; if ( ! ReadTxIndex ( hash , txindex ) ) return false ; return ( tx . ReadFromDisk ( txindex . pos ) ) ; } bool CTxDB :: ReadDiskTx ( uint256 hash , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx , CTxIndex & txindex ) { return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: ReadDiskTx ( COutPoint outpoint , CTransaction & tx ) { CTxIndex txindex ; return ReadDiskTx ( outpoint . hash , tx , txindex ) ; } bool CTxDB :: WriteBlockIndex ( const CDiskBlockIndex & blockindex ) { return Write ( make_pair ( string ( " blockindex " ) , blockindex . GetBlockHash ( ) ) , blockindex ) ; } bool CTxDB :: Erase@@ BlockIndex ( uint256 hash ) { return Erase ( make_pair ( string ( " blockindex " ) , hash ) ) ; } bool CTxDB :: ReadHashBestChain ( uint256 & hashBestChain ) { return Read ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: WriteHashBestChain ( uint256 hashBestChain ) { return Write ( string ( " hashBestChain " ) , hashBestChain ) ; } bool CTxDB :: ReadBestInvalidWork ( CBigNum & bnBestInvalidWork ) { return Read ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } bool CTxDB :: WriteBestInvalidWork ( CBigNum bnBestInvalidWork ) { return Write ( string ( " bnBestInvalidWork " ) , bnBestInvalidWork ) ; } CBlockIndex static * InsertBlockIndex ( uint256 hash ) { if ( hash == 0 ) return NULL ; map < uint256 , CBlockIndex * > :: iterator mi = mapBlockIndex . find ( hash ) ; if ( mi != mapBlockIndex . end ( ) ) return ( * mi ) . second ; CBlockIndex * pindexNew = new CBlockIndex ( ) ; if ( ! pindexNew ) throw runtime_error ( " LoadBlockIndex ( ) ▁ : ▁ new ▁ CBlockIndex ▁ failed " ) ; mi = mapBlockIndex . insert ( make_pair ( hash , pindexNew ) ) . first ; pindexNew -> phash@@ Block = & ( ( * mi ) . first ) ; return pindexNew ; } bool CTxDB :: LoadBlockIndex ( ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_pair ( string ( " blockindex " ) , uint256 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " blockindex " ) { CDiskBlockIndex diskindex ; ssValue >> diskindex ; CBlockIndex * pindexNew = InsertBlockIndex ( diskindex . GetBlockHash ( ) ) ; pindexNew -> pprev = InsertBlockIndex ( diskindex . hashPrev ) ; pindexNew -> pnext = InsertBlockIndex ( diskindex . hashNext ) ; pindexNew -> nFile = diskindex . nFile ; pindexNew -> nBlockPos = diskindex . nBlockPos ; pindexNew -> nHeight = diskindex . nHeight ; pindexNew -> nVersion = diskindex . nVersion ; pindexNew -> hashMerkleRoot = diskindex . hashMerkleRoot ; pindexNew -> nTime = diskindex . nTime ; pindexNew -> nBits = diskindex . nBits ; pindexNew -> nNonce = diskindex . nNonce ; pindexNew -> auxpow = diskindex . auxpow ; if ( pindexGenesisBlock == NULL && diskindex . GetBlockHash ( ) == hashGenesisBlock ) pindexGenesisBlock = pindexNew ; if ( ! pindexNew -> CheckIndex ( ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ CheckIndex ▁ failed ▁ at ▁ % d " , pindexNew -> nHeight ) ; } else { break ; } } pcursor -> close ( ) ; vector < pair < int , CBlockIndex * > > vSortedByHeight ; vSortedByHeight . reserve ( mapBlockIndex . size ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( uint256 , CBlockIndex * ) & item , mapBlockIndex ) { CBlockIndex * pindex = item . second ; vSortedByHeight . push_back ( make_pair ( pindex -> nHeight , pindex ) ) ; } sort ( vSortedByHeight . begin ( ) , vSortedByHeight . end ( ) ) ; BOOST_FOREACH ( const PAIRTYPE ( int , CBlockIndex * ) & item , vSortedByHeight ) { CBlockIndex * pindex = item . second ; pindex -> bnChainWork = ( pindex -> pprev ? pindex -> pprev -> bnChainWork : 0 ) + pindex -> GetBlockWork ( ) ; } if ( ! ReadHashBestChain ( hashBestChain ) ) { if ( pindexGenesisBlock == NULL ) return true ; return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ loaded " ) ; } if ( ! mapBlockIndex . count ( hashBestChain ) ) return error ( " CTxDB : : LoadBlockIndex ( ) ▁ : ▁ hashBestChain ▁ not ▁ found ▁ in ▁ the ▁ block ▁ index " ) ; pindexBest = mapBlockIndex [ hashBestChain ] ; nBestHeight = pindexBest -> nHeight ; bnBestChainWork = pindexBest -> bnChainWork ; printf ( " LoadBlockIndex ( ) : ▁ hashBestChain = % s ▁ ▁ height = % d \n " , hashBestChain . ToString ( ) . substr ( 0 , 20 ) . c_str ( ) , nBestHeight ) ; ReadBestInvalidWork ( bnBestInvalidWork ) ; CBlockIndex * pindexFork = NULL ; for ( CBlockIndex * pindex = pindexBest ; pindex && pindex -> pprev ; pindex = pindex -> pprev ) { if ( pindex -> nHeight < nBestHeight - 2500 && ! mapArgs . count ( " - checkblocks " ) ) break ; CBlock block ; if ( ! block . ReadFromDisk ( pindex ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; if ( ! block . CheckBlock ( pindex -> nHeight ) ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ found ▁ bad ▁ block ▁ at ▁ % d , ▁ hash = % s \n " , pindex -> nHeight , pindex -> GetBlockHash ( ) . ToString ( ) . c_str ( ) ) ; pindexFork = pindex -> pprev ; } } if ( pindexFork ) { printf ( " LoadBlockIndex ( ) ▁ : ▁ * * * ▁ moving ▁ best ▁ chain ▁ pointer ▁ back ▁ to ▁ block ▁ % d \n " , pindexFork -> nHeight ) ; CBlock block ; if ( ! block . ReadFromDisk ( pindexFork ) ) return error ( " LoadBlockIndex ( ) ▁ : ▁ block . ReadFromDisk ▁ failed " ) ; CTxDB txdb ; block . SetBestChain ( txdb , pindexFork ) ; } return true ; } bool CAddrDB :: WriteAddress ( const CAddress & addr ) { return Write ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) , addr ) ; } bool CAddrDB :: Erase@@ Address ( const CAddress & addr ) { return Erase ( make_pair ( string ( " addr " ) , addr . GetKey ( ) ) ) ; } bool CAddrDB :: LoadAddresses ( ) { CRITICAL_BLOCK ( cs_mapAddresses ) { CAuto@@ File filein = fopen ( ( GetDataDir ( ) + " / addr . txt " ) . c_str ( ) , " rt " ) ; if ( filein ) { try { char psz [ 1000 ] ; while ( fgets ( psz , sizeof ( psz ) , filein ) ) { CAddress addr ( psz , NODE_NETWORK ) ; addr . nTime = 0 ; if ( addr . IsValid ( ) ) AddAddress ( addr ) ; } } catch ( ... ) { } } Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " addr " ) { CAddress addr ; ssValue >> addr ; mapAddresses . insert ( make_pair ( addr . GetKey ( ) , addr ) ) ; } } pcursor -> close ( ) ; printf ( " Loaded ▁ % d ▁ addresses \n " , mapAddresses . size ( ) ) ; } return true ; } bool LoadAddresses ( ) { return CAddrDB ( " cr + " ) . LoadAddresses ( ) ; } bool CWalletDB :: WriteName ( const string & strAddress , const string & strName ) { nWalletDBUpdated ++ ; return Write ( make_pair ( string ( " name " ) , strAddress ) , strName ) ; } bool CWalletDB :: Erase@@ Name ( const string & strAddress ) { nWalletDBUpdated ++ ; return Erase ( make_pair ( string ( " name " ) , strAddress ) ) ; } bool CWalletDB :: ReadAccount ( const string & strAccount , CAccount & account ) { account . SetNull ( ) ; return Read ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccount ( const string & strAccount , const CAccount & account ) { return Write ( make_pair ( string ( " acc " ) , strAccount ) , account ) ; } bool CWalletDB :: WriteAccountingEntry ( const CAccountingEntry & acentry ) { return Write ( make_tuple ( string ( " acentry " ) , acentry . strAccount , ++ nAccountingEntryNumber ) , acentry ) ; } int64 CWalletDB :: GetAccountCreditDebit ( const string & strAccount ) { list < CAccountingEntry > entries ; ListAccountCreditDebit ( strAccount , entries ) ; int64 nCreditDebit = 0 ; BOOST_FOREACH ( const CAccountingEntry & entry , entries ) nCreditDebit += entry . nCreditDebit ; return nCreditDebit ; } void CWalletDB :: ListAccountCreditDebit ( const string & strAccount , list < CAccountingEntry > & entries ) { int64 nCreditDebit = 0 ; bool fAllAccounts = ( strAccount == " * " ) ; Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ cannot ▁ create ▁ DB ▁ cursor " ) ; unsigned int fFlags = DB_SET_RANGE ; loop { CDataStream ssKey ; if ( fFlags == DB_SET_RANGE ) ssKey << make_tuple ( string ( " acentry " ) , ( fAllAccounts ? string ( " " ) : strAccount ) , uint64 ( 0 ) ) ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue , fFlags ) ; fFlags = DB_NEXT ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) { pcursor -> close ( ) ; throw runtime_error ( " CWalletDB : : ListAccountCreditDebit ( ) ▁ : ▁ error ▁ scan@@ ning ▁ DB " ) ; } string strType ; ssKey >> strType ; if ( strType != " acentry " ) break ; CAccountingEntry acentry ; ssKey >> acentry . strAccount ; if ( ! fAllAccounts && acentry . strAccount != strAccount ) break ; ssValue >> acentry ; entries . push_back ( acentry ) ; } pcursor -> close ( ) ; } bool CWalletDB :: LoadWallet ( CWallet * pwallet ) { pwallet -> vchDefaultKey . clear ( ) ; int nFileVersion = 0 ; vector < uint256 > vWalletUpgrade ; # ifndef __WXMSW__ fMinimizeToTray = false ; fMinimizeOnClose = false ; # endif CRITICAL_BLOCK ( pwallet -> cs_mapWallet ) CRITICAL_BLOCK ( pwallet -> cs_mapKeys ) { Dbc * pcursor = GetCursor ( ) ; if ( ! pcursor ) return false ; loop { CDataStream ssKey ; CDataStream ssValue ; int ret = ReadAtCursor ( pcursor , ssKey , ssValue ) ; if ( ret == DB_NOTFOUND ) break ; else if ( ret != 0 ) return false ; string strType ; ssKey >> strType ; if ( strType == " name " ) { string strAddress ; ssKey >> strAddress ; ssValue >> pwallet -> mapAddressBook [ strAddress ] ; } else if ( strType == " tx " ) { uint256 hash ; ssKey >> hash ; CWalletTx & wtx = pwallet -> mapWallet [ hash ] ; ssValue >> wtx ; wtx . pwallet = pwallet ; if ( wtx . GetHash ( ) != hash ) printf ( " Error ▁ in ▁ wallet . dat , ▁ hash ▁ mismatch \n " ) ; if ( 3140@@ 4 <= wtx . fTimeReceivedIsTxTime && wtx . fTimeReceivedIsTxTime <= 317@@ 03 ) { if ( ! ssValue . empty ( ) ) { char fTmp ; char fUnused ; ssValue >> fTmp >> fUnused >> wtx . strFromAccount ; printf ( " LoadWallet ( ) ▁ upgrad@@ ing ▁ tx ▁ ver = % d ▁ % d ▁ ' % s ' ▁ % s \n " , wtx . fTimeReceivedIsTxTime , fTmp , wtx . strFromAccount . c_str ( ) , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = fTmp ; } else { printf ( " LoadWallet ( ) ▁ repair@@ ing ▁ tx ▁ ver = % d ▁ % s \n " , wtx . fTimeReceivedIsTxTime , hash . ToString ( ) . c_str ( ) ) ; wtx . fTimeReceivedIsTxTime = 0 ; } vWalletUpgrade . push_back ( hash ) ; } } else if ( strType == " acentry " ) { string strAccount ; ssKey >> strAccount ; uint64 nNumber ; ssKey >> nNumber ; if ( nNumber > nAccountingEntryNumber ) nAccountingEntryNumber = nNumber ; } else if ( strType == " key " || strType == " wkey " ) { vector < unsigned char > vchPubKey ; ssKey >> vchPubKey ; CWalletKey wkey ; if ( strType == " key " ) ssValue >> wkey . vchPrivKey ; else ssValue >> wkey ; pwallet -> mapKeys [ vchPubKey ] = wkey . vchPrivKey ; mapPubKeys [ Hash160 ( vchPubKey ) ] = vchPubKey ; } else if ( strType == " defaultkey " ) { ssValue >> pwallet -> vchDefaultKey ; } else if ( strType == " pool " ) { int64 nIndex ; ssKey >> nIndex ; pwallet -> setKeyPool . insert ( nIndex ) ; } else if ( strType == " version " ) { ssValue >> nFileVersion ; if ( nFileVersion == 10300 ) nFileVersion = 300 ; } else if ( strType == " setting " ) { string strKey ; ssKey >> strKey ; # ifndef GUI if ( strKey == " fGenerateBitcoins " ) ssValue >> fGenerateBitcoins ; # endif if ( strKey == " nTransactionFee " ) ssValue >> nTransactionFee ; if ( strKey == " addrIncoming " ) ssValue >> addrIncoming ; if ( strKey == " fLimitProcessors " ) ssValue >> fLimitProcessors ; if ( strKey == " nLimitProcessors " ) ssValue >> nLimitProcessors ; if ( strKey == " fMinimizeToTray " ) ssValue >> fMinimizeToTray ; if ( strKey == " fMinimizeOnClose " ) ssValue >> fMinimizeOnClose ; if ( strKey == " fUseProxy " ) ssValue >> fUseProxy ; if ( strKey == " addrProxy " ) ssValue >> addrProxy ; if ( fHaveUPnP && strKey == " fUseUPnP " ) ssValue >> fUseUPnP ; } } pcursor -> close ( ) ; } BOOST_FOREACH ( uint256 hash , vWalletUpgrade ) WriteTx ( hash , pwallet -> mapWallet [ hash ] ) ; printf ( " nFileVersion ▁ = ▁ % d \n " , nFileVersion ) ; printf ( " fGenerateBitcoins ▁ = ▁ % d \n " , fGenerateBitcoins ) ; printf ( " nTransactionFee ▁ = ▁ % " PRI64d " \n " , nTransactionFee ) ; printf ( " addrIncoming ▁ = ▁ % s \n " , addrIncoming . ToString ( ) . c_str ( ) ) ; printf ( " fMinimizeToTray ▁ = ▁ % d \n " , fMinimizeToTray ) ; printf ( " fMinimizeOnClose ▁ = ▁ % d \n " , fMinimizeOnClose ) ; printf ( " fUseProxy ▁ = ▁ % d \n " , fUseProxy ) ; printf ( " addrProxy ▁ = ▁ % s \n " , addrProxy . ToString ( ) . c_str ( ) ) ; if ( fHaveUPnP ) printf ( " fUseUPnP ▁ = ▁ % d \n " , fUseUPnP ) ; if ( nFileVersion < VERSION ) { if ( nFileVersion <= 105 && ! pszSetDataDir [ 0 ] ) unlink ( " debug . log " ) ; WriteVersion ( VERSION ) ; } return true ; } void ThreadFlush@@ WalletDB ( void * parg ) { const string & strFile = ( ( const string * ) parg ) [ 0 ] ; static bool fOneThread ; if ( fOneThread ) return ; fOneThread = true ; if ( mapArgs . count ( " - noflush@@ wallet " ) ) return ; unsigned int nLastSeen = nWalletDBUpdated ; unsigned int nLastFlushed = nWalletDBUpdated ; int64 nLastWalletUpdate = GetTime ( ) ; while ( ! fShutdown ) { Sleep ( 500 ) ; if ( nLastSeen != nWalletDBUpdated ) { nLastSeen = nWalletDBUpdated ; nLastWalletUpdate = GetTime ( ) ; } if ( nLastFlushed != nWalletDBUpdated && GetTime ( ) - nLastWalletUpdate >= 2 ) { TRY_@@ CRITICAL_BLOCK ( cs_db ) { int nRefCount = 0 ; map < string , int > :: iterator mi = mapFileUseCount . begin ( ) ; while ( mi != mapFileUseCount . end ( ) ) { nRefCount += ( * mi ) . second ; mi ++ ; } if ( nRefCount == 0 && ! fShutdown ) { map < string , int > :: iterator mi = mapFileUseCount . find ( strFile ) ; if ( mi != mapFileUseCount . end ( ) ) { printf ( " % s ▁ " , Date@@ TimeStrFormat ( " % x ▁ % H : % M : % S " , GetTime ( ) ) . c_str ( ) ) ; printf ( " Flushing ▁ wallet . dat \n " ) ; nLastFlushed = nWalletDBUpdated ; int64 nStart = GetTimeMillis ( ) ; CloseDb ( strFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( strFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( mi ++ ) ; printf ( " Flushed ▁ wallet . dat ▁ % " PRI64d " ms \n " , GetTimeMillis ( ) - nStart ) ; } } } } } } bool BackupWallet ( const CWallet & wallet , const string & strDest ) { if ( ! wallet . fFile@@ Backed ) return false ; while ( ! fShutdown ) { CRITICAL_BLOCK ( cs_db ) { if ( ! mapFileUseCount . count ( wallet . strWalletFile ) || mapFileUseCount [ wallet . strWalletFile ] == 0 ) { CloseDb ( wallet . strWalletFile ) ; dbenv . txn_checkpoint ( 0 , 0 , 0 ) ; dbenv . lsn_reset ( wallet . strWalletFile . c_str ( ) , 0 ) ; mapFileUseCount . erase ( wallet . strWalletFile ) ; filesystem :: path pathSrc ( GetDataDir ( ) + " / " + wallet . strWalletFile ) ; filesystem :: path pathDest ( strDest ) ; if ( filesystem :: is_directory ( pathDest ) ) pathDest = pathDest / wallet . strWalletFile ; # if BOOST_VERSION >= 104000 filesystem :: copy_file ( pathSrc , pathDest , filesystem :: copy_option :: overwrite_@@ if_exists ) ; # else filesystem :: copy_file ( pathSrc , pathDest ) ; # endif printf ( " copied ▁ wallet . dat ▁ to ▁ % s \n " , pathDest . string ( ) . c_str ( ) ) ; return true ; } } Sleep ( 100 ) ; } return false ; } </DOCUMENT>
<DOCUMENT_ID="s@@ neii@@ ler/ardupilot/tree/master/libraries/AP_@@ HAL/util@@ ity/@@ getopt@@ _cpp@@ .cpp"> # include " getopt _ cpp . h " # include < stdio . h > # include < string . h > GetOptLong :: GetOptLong ( int _argc , char * const _argv [ ] , const char * _optstring , const GetOptLong :: option * _longopts ) : opterr ( 0 ) , optind ( 1 ) , optopt ( 0 ) , longindex ( - 1 ) , optarg ( NULL ) , argc ( _argc ) , argv ( _argv ) , optstring ( _optstring ) , longopts ( _longopts ) , place ( " " ) { } int GetOptLong :: getoption ( void ) { const char * oli ; if ( ! * place ) { if ( optind >= argc ) { place = " " ; return - 1 ; } place = argv [ optind ] ; if ( place [ 0 ] != ' - ' ) { place = " " ; return - 1 ; } place ++ ; if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] == ' \0' ) { ++ optind ; place = " " ; return - 1 ; } if ( place [ 0 ] && place [ 0 ] == ' - ' && place [ 1 ] ) { size_t namelen ; int i ; place ++ ; namelen = strcsp@@ n ( place , " = " ) ; for ( i = 0 ; longopts [ i ] . name != NULL ; i ++ ) { if ( strlen ( longopts [ i ] . name ) == namelen && strncmp ( place , longopts [ i ] . name , namelen ) == 0 ) { if ( longopts [ i ] . has_@@ arg ) { if ( place [ namelen ] == ' = ' ) optarg = place + namelen + 1 ; else if ( optind < argc - 1 ) { optind ++ ; optarg = argv [ optind ] ; } else { if ( optstring [ 0 ] == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } else { optarg = NULL ; if ( place [ namelen ] != 0 ) { } } optind ++ ; longindex = i ; place = " " ; if ( longopts [ i ] . flag == NULL ) return longopts [ i ] . val ; else { * longopts [ i ] . flag = longopts [ i ] . val ; return 0 ; } } } if ( opterr && optstring [ 0 ] != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % s \n " , argv [ 0 ] , place ) ; place = " " ; optind ++ ; return BADCH ; } } optopt = ( int ) * place ++ ; oli = strchr ( optstring , optopt ) ; if ( ! oli ) { if ( ! * place ) ++ optind ; if ( opterr && * optstring != ' : ' ) fprintf ( stderr , " % s : ▁ illegal ▁ option ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } if ( oli [ 1 ] != ' : ' ) { optarg = NULL ; if ( ! * place ) ++ optind ; } else { if ( * place ) optarg = place ; else if ( argc <= ++ optind ) { place = " " ; if ( * optstring == ' : ' ) return BADARG ; if ( opterr ) fprintf ( stderr , " % s : ▁ option ▁ requires ▁ an ▁ argument ▁ - - ▁ % c \n " , argv [ 0 ] , optopt ) ; return BADCH ; } else optarg = argv [ optind ] ; place = " " ; ++ optind ; } return optopt ; } </DOCUMENT>
<DOCUMENT_ID="do@@ mini@@ k-th/xbmc/tree/master/xbmc/@@ ApplicationPlayer@@ .cpp"> # include " ApplicationPlayer . h " # include " cores / IPlayer . h " # include " Application . h " # include " settings / Media@@ Settings . h " CApplicationPlayer :: CApplicationPlayer ( ) { m_iPlayerOPSeq = 0 ; m_eCurrentPlayer = EPC_@@ NONE ; } std :: shared_ptr < IPlayer > CApplicationPlayer :: GetInternal ( ) const { CSingleLock lock ( m_player_lock ) ; return m_pPlayer ; } void CApplicationPlayer :: ClosePlayer ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { CloseFile ( ) ; CSingleLock lock ( m_player_lock ) ; m_pPlayer . reset ( ) ; } } void CApplicationPlayer :: CloseFile ( bool reopen ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { ++ m_iPlayerOPSeq ; player -> CloseFile ( reopen ) ; } } void CApplicationPlayer :: ClosePlayerGap@@ less ( PLAYERCOREID newCore ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; bool gaplessSupported = ( m_eCurrentPlayer == EPC_@@ DVD@@ PLAYER || m_eCurrentPlayer == EPC_@@ PAP@@ LAYER ) ; gaplessSupported = gaplessSupported && ( m_eCurrentPlayer == newCore ) ; if ( ! gaplessSupported ) { ClosePlayer ( ) ; } else { CloseFile ( true ) ; } } void CApplicationPlayer :: CreatePlayer ( PLAYERCOREID newCore , IPlayer@@ Callback & callback ) { CSingleLock lock ( m_player_lock ) ; if ( ! m_pPlayer ) { m_eCurrentPlayer = newCore ; m_pPlayer . reset ( CPlayer@@ CoreFactory :: Get ( ) . CreatePlayer ( newCore , callback ) ) ; } } PlayBackRet CApplicationPlayer :: OpenFile ( const CFileItem & item , const CPlayer@@ Options & options ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; PlayBackRet iResult = PLAYBACK_FAIL ; if ( player ) { unsigned int startingSeq = ++ m_iPlayerOPSeq ; iResult = player -> OpenFile ( item , options ) ? PLAYBACK_@@ OK : PLAYBACK_FAIL ; if ( m_iPlayerOPSeq != startingSeq ) iResult = PLAYBACK_@@ CANC@@ ELED ; } return iResult ; } bool CApplicationPlayer :: HasPlayer ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return player != NULL ; } int CApplicationPlayer :: GetChapter ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapter ( ) ; else return - 1 ; } int CApplicationPlayer :: GetChapterCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterCount ( ) ; else return 0 ; } void CApplicationPlayer :: GetChapterName ( std :: string & strChapterName , int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetChapterName ( strChapterName , chapterIdx ) ; } int64_t CApplicationPlayer :: GetChapterPos ( int chapterIdx ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetChapterPos ( chapterIdx ) ; return - 1 ; } bool CApplicationPlayer :: HasAudio ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasAudio ( ) ) ; } bool CApplicationPlayer :: HasVideo ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasVideo ( ) ) ; } int CApplicationPlayer :: GetPre@@ ferred@@ Playlist ( ) const { if ( IsPlayingVideo ( ) ) return PLAYLIST_@@ VIDEO ; if ( IsPlayingAudio ( ) ) return PLAYLIST_@@ MUSIC ; return PLAYLIST_@@ NONE ; } bool CApplicationPlayer :: IsPaused ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlaying ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPlaying ( ) ) ; } bool CApplicationPlayer :: IsPau@@ sedPlayback ( ) const { return ( IsPlaying ( ) && IsPaused ( ) ) ; } bool CApplicationPlayer :: IsPlayingAudio ( ) const { return ( IsPlaying ( ) && ! HasVideo ( ) && HasAudio ( ) ) ; } bool CApplicationPlayer :: IsPlayingVideo ( ) const { return ( IsPlaying ( ) && HasVideo ( ) ) ; } void CApplicationPlayer :: Pause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Pause ( ) ; } bool CApplicationPlayer :: ControlsVolume ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> ControlsVolume ( ) ) ; } void CApplicationPlayer :: SetMute ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetMute ( bOnOff ) ; } void CApplicationPlayer :: SetVolume ( float volume ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetVolume ( volume ) ; } void CApplicationPlayer :: Seek ( bool bPlus , bool bLargeStep , bool bChapterOverride ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> Seek ( bPlus , bLargeStep , bChapterOverride ) ; } void CApplicationPlayer :: SeekPercentage ( float fPercent ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekPercentage ( fPercent ) ; } bool CApplicationPlayer :: IsPassthrough ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsPassthrough ( ) ) ; } bool CApplicationPlayer :: CanSeek ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanSeek ( ) ) ; } bool CApplicationPlayer :: SeekScene ( bool bPlus ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SeekScene ( bPlus ) ) ; } void CApplicationPlayer :: SeekTime ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SeekTime ( iTime ) ; } void CApplicationPlayer :: SeekTimeRelative ( int64_t iTime ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { if ( ! player -> SeekTimeRelative ( iTime ) ) { int64_t abstime = player -> GetTime ( ) + iTime ; player -> SeekTime ( abstime ) ; } } } std :: string CApplicationPlayer :: GetPlayingTitle ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayingTitle ( ) ; else return " " ; } int64_t CApplicationPlayer :: GetTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTime ( ) ; else return 0 ; } int64_t CApplicationPlayer :: GetDisplayTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetDisplayTime ( ) ; else return 0 ; } bool CApplicationPlayer :: IsCaching ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsCaching ( ) ) ; } bool CApplicationPlayer :: IsInMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsInMenu ( ) ) ; } bool CApplicationPlayer :: HasMenu ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> HasMenu ( ) ) ; } int CApplicationPlayer :: GetCacheLevel ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCacheLevel ( ) ; else return 0 ; } int CApplicationPlayer :: GetSubtitleCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetSubtitleCount ( ) ; else return 0 ; } int CApplicationPlayer :: GetAudioStream ( ) { if ( ! m_audioStreamUpdate . IsTimePast ( ) ) return m_iAudioStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iAudioStream = player -> GetAudioStream ( ) ; m_audioStreamUpdate . Set ( 1000 ) ; return m_iAudioStream ; } else return 0 ; } int CApplicationPlayer :: GetSubtitle ( ) { if ( ! m_subtitleStreamUpdate . IsTimePast ( ) ) return m_iSubtitleStream ; std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { m_iSubtitleStream = player -> GetSubtitle ( ) ; m_subtitleStreamUpdate . Set ( 1000 ) ; return m_iSubtitleStream ; } else return 0 ; } bool CApplicationPlayer :: GetSubtitleVisible ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetSubtitleVisible ( ) ) ; } bool CApplicationPlayer :: CanRecord ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanRecord ( ) ) ; } bool CApplicationPlayer :: CanPause ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> CanPause ( ) ) ; } bool CApplicationPlayer :: IsRecording ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> IsRecording ( ) ) ; } TextCache@@ Struct_t * CApplicationPlayer :: GetTeletextCache ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTeletextCache ( ) ; else return NULL ; } int64_t CApplicationPlayer :: GetTotalTime ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetTotalTime ( ) ; else return 0 ; } float CApplicationPlayer :: GetPercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPercentage ( ) ; else return 0.0 ; } float CApplicationPlayer :: GetCachePercentage ( ) const { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetCachePercentage ( ) ; else return 0.0 ; } void CApplicationPlayer :: ToFFRW ( int iSpeed ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> ToFFRW ( iSpeed ) ; } void CApplicationPlayer :: DoAudioWork ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> DoAudioWork ( ) ; } std :: string CApplicationPlayer :: GetPlayerState ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetPlayerState ( ) ; else return " " ; } bool CApplicationPlayer :: QueueNextFile ( const CFileItem & file ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> QueueNextFile ( file ) ) ; } bool CApplicationPlayer :: GetStreamDetails ( CStreamDetails & details ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> GetStreamDetails ( details ) ) ; } bool CApplicationPlayer :: SetPlayerState ( const std :: string & state ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SetPlayerState ( state ) ) ; } void CApplicationPlayer :: OnNothingToQueueNotify ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OnNothingToQueueNotify ( ) ; } void CApplicationPlayer :: GetVideoStreamInfo ( SPlayer@@ VideoStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoStreamInfo ( info ) ; } void CApplicationPlayer :: GetAudioStreamInfo ( int index , SPlayer@@ AudioStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioStreamInfo ( index , info ) ; } bool CApplicationPlayer :: OnAction ( const CAction & action ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> OnAction ( action ) ) ; } bool CApplicationPlayer :: Record ( bool bOnOff ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> Record ( bOnOff ) ) ; } int CApplicationPlayer :: GetAudioStreamCount ( ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> GetAudioStreamCount ( ) ; else return 0 ; } void CApplicationPlayer :: SetAudioStream ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetAudioStream ( iStream ) ; m_iAudioStream = iStream ; m_audioStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_AudioStream = iStream ; } } void CApplicationPlayer :: GetSubtitleStreamInfo ( int index , SPlayer@@ SubtitleStreamInfo & info ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleStreamInfo ( index , info ) ; } void CApplicationPlayer :: SetSubtitle ( int iStream ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitle ( iStream ) ; m_iSubtitleStream = iStream ; m_subtitleStreamUpdate . Set ( 1000 ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = iStream ; } } void CApplicationPlayer :: SetSubtitleVisible ( bool bVisible ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) { player -> SetSubtitleVisible ( bVisible ) ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_Subtitle@@ On = bVisible ; CMediaSettings :: Get ( ) . GetCurrentVideoSettings ( ) . m_SubtitleStream = player -> GetSubtitle ( ) ; } } void CApplicationPlayer :: AddSubtitle ( const std :: string & strSubPath ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> AddSubtitle ( strSubPath ) ; } void CApplicationPlayer :: SetSubTitleDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetSubTitleDelay ( fValue ) ; } void CApplicationPlayer :: SetAVDelay ( float fValue ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetAVDelay ( fValue ) ; } void CApplicationPlayer :: SetDynamicRangeCompression ( long drc ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> SetDynamicRangeCompression ( drc ) ; } bool CApplicationPlayer :: SwitchChannel ( const PVR :: CPVR@@ ChannelPtr & channel ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; return ( player && player -> SwitchChannel ( channel ) ) ; } void CApplicationPlayer :: LoadPage ( int p , int sp , unsigned char * buffer ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> LoadPage ( p , sp , buffer ) ; } void CApplicationPlayer :: GetAudioCapabilities ( std :: vector < int > & audioCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioCapabilities ( audioCaps ) ; } void CApplicationPlayer :: GetSubtitleCapabilities ( std :: vector < int > & subCaps ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetSubtitleCapabilities ( subCaps ) ; } void CApplicationPlayer :: GetAudioInfo ( std :: string & strAudioInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetAudioInfo ( strAudioInfo ) ; } void CApplicationPlayer :: GetVideoInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetVideoInfo ( strVideoInfo ) ; } void CApplicationPlayer :: GetGeneralInfo ( std :: string & strVideoInfo ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> GetGeneralInfo ( strVideoInfo ) ; } int CApplicationPlayer :: SeekChapter ( int iChapter ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) return player -> SeekChapter ( iChapter ) ; else return 0 ; } void CApplicationPlayer :: GetRenderFeatures ( std :: vector < int > & renderFeatures ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OM@@ XGetRenderFeatures ( renderFeatures ) ; } void CApplicationPlayer :: GetDeinterlace@@ Methods ( std :: vector < int > & deinterlaceMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlace@@ Methods ( deinterlaceMethods ) ; } void CApplicationPlayer :: GetDeinterlace@@ Modes ( std :: vector < int > & deinterlaceModes ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGetDeinterlace@@ Modes ( deinterlaceModes ) ; } void CApplicationPlayer :: GetScalingMethods ( std :: vector < int > & scalingMethods ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( player ) player -> OMXGet@@ ScalingMethods ( scalingMethods ) ; } void CApplicationPlayer :: SetPlaySpeed ( int iSpeed , bool bApplicationMuted ) { std :: shared_ptr < IPlayer > player = GetInternal ( ) ; if ( ! player ) return ; if ( ! IsPlayingAudio ( ) && ! IsPlayingVideo ( ) ) return ; if ( m_iPlaySpeed == iSpeed ) return ; if ( ! CanSeek ( ) ) return ; if ( IsPaused ( ) ) { if ( ( ( m_iPlaySpeed > 1 ) && ( iSpeed > m_iPlaySpeed ) ) || ( ( m_iPlaySpeed < - 1 ) && ( iSpeed < m_iPlaySpeed ) ) ) { iSpeed = m_iPlaySpeed ; } Pause ( ) ; } m_iPlaySpeed = iSpeed ; ToFFRW ( m_iPlaySpeed ) ; if ( ControlsVolume ( ) ) { if ( m_iPlaySpeed == 1 ) { player -> SetVolume ( g_application . GetVolume ( false ) ) ; } else { player -> SetVolume ( VOLUME_MIN@@ IMU@@ M ) ; } player -> SetMute ( bApplicationMuted ) ; } } int CApplicationPlayer :: GetPlaySpeed ( ) const { return m_iPlaySpeed ; } </DOCUMENT>
<DOCUMENT_ID="dy@@ son@@ lt@@ d/g@@ ts/tree/master/@@ app/src/@@ tools/@@ core/component@@ s/FloorPlan@@ ning.cpp"> # include " Rooms@@ Collection . h " # include " CamerasCollection . h " # include " CameraPositionsCollection . h " # include " CalibrationSchema . h " # include " ExtrinsicCalibrationSchema . h " # include " CameraPositionSchema . h " # include " RoomLayoutSchema . h " # include " FloorPlanSchema . h " # include " CalibrationAlgorith@@ m . h " # include " WbConfigTools . h " # include " WbConfig . h " # include " GroundPlaneUtility . h " # include " OpenCv@@ Utility . h " # include " Robot@@ Metrics . h " # include " CameraCalibration . h " # include " FileUtilities . h " # include " FileDialogs . h " # include " Message . h " # include " Logging . h " # include < QFileDialog > # include < QtGlobal > # include < opencv / cv . h > # include < opencv / highgui . h > # include < iostream > # include < algorithm > namespace FloorPlanning { bool LoadFile ( WbConfig config , KeyId cameraPosition , IplImage * * camImg , QString fileName , CvPoint2D@@ 32f * offset , bool unWarp ) { bool successful = true ; Collection camerasCollection ( CamerasCollection ( ) ) ; Collection cameraPositionsCollection ( CameraPositionsCollection ( ) ) ; camerasCollection . SetConfig ( config ) ; cameraPositionsCollection . SetConfig ( config ) ; const KeyId camPosId = cameraPosition ; LOG_INFO ( QObject :: tr ( " Camera ▁ position ▁ id : ▁ % 1" ) . arg ( camPosId ) ) ; const WbConfig camPosConfig = cameraPositionsCollection . ElementById ( camPosId ) ; if ( camPosConfig . IsNull ( ) ) successful = false ; CvMat * cameraMtx = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * distortionCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * inverseCoeffs = cvCreateMat ( 5 , 1 , CV_32F ) ; CvMat * rot = cvCreateMat ( 3 , 3 , CV_32F ) ; CvMat * trans = cvCreateMat ( 1 , 3 , CV_32F ) ; if ( successful ) { const KeyId camId = camPosConfig . GetKeyValue ( CameraPositionSchema :: cameraIdKey ) . ToKeyId ( ) ; LOG_INFO ( QObject :: tr ( " Camera ▁ id : ▁ % 1" ) . arg ( camId ) ) ; WbConfig cameraConfig = camerasCollection . ElementById ( camId ) ; if ( cameraConfig . IsNull ( ) ) successful = false ; if ( successful ) { const WbConfig cameraIntrisicConfig ( cameraConfig . GetSubConfig ( CalibrationSchema :: schemaName ) ) ; if ( cameraIntrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool calibrationWasSuccessful = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: calibration@@ Success@@ fulKey ) . ToBool ( ) ; const bool cameraMtxValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: cameraMatrixKey ) . ToCvMat ( * cameraMtx ) ; const bool distortionCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: distortionCoefficientsKey ) . ToCvMat ( * distortionCoeffs ) ; const bool inverseCoeffsValid = cameraIntrisicConfig . GetKeyValue ( CalibrationSchema :: inv@@ Distortion@@ CoefficientsKey ) . ToCvMat ( * inverseCoeffs ) ; successful = calibrationWasSuccessful && cameraMtxValid && distortionCoeffsValid && inverseCoeffsValid ; } const WbConfig cameraExtrisicConfig ( camPosConfig . GetSubConfig ( ExtrinsicCalibrationSchema :: schemaName ) ) ; if ( cameraExtrisicConfig . IsNull ( ) ) successful = false ; if ( successful ) { const bool rotMatValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: rotationMatrixKey ) . ToCvMat ( * rot ) ; const bool transValid = cameraExtrisicConfig . GetKeyValue ( ExtrinsicCalibrationSchema :: translation@@ Key ) . ToCvMat ( * trans ) ; successful = rotMatValid && transValid ; } } } if ( successful ) { IplImage * imgGrey = cvLoad@@ Image ( fileName . toAs@@ cii ( ) , CV_LOAD_@@ IMA@@ GE_GRAY@@ SCAL@@ E ) ; if ( unWarp ) { * camImg = GroundPlaneUtility :: unwarp@@ GroundPla@@ ne ( imgGrey , cameraMtx , distortionCoeffs , inverseCoeffs , rot , trans , offset ) ; } else { * camImg = cvClo@@ neImage ( imgGrey ) ; } cvReleaseImage ( & imgGrey ) ; } cvReleaseMat ( & cameraMtx ) ; cvReleaseMat ( & distortionCoeffs ) ; cvReleaseMat ( & inverseCoeffs ) ; cvReleaseMat ( & rot ) ; cvReleaseMat ( & trans ) ; return successful ; } bool CheckMapping@@ IsComplete ( WbConfig config ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool found = false ; LOG_INFO ( QObject :: tr ( " Checking ▁ mapping ▁ for ▁ % 1 . " ) . arg ( camPosId ) ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camPosId == camera1Id ) || ( camPosId == camera2Id ) ) { found = true ; break ; } } if ( ! found ) { allMapped = false ; break ; } } return allMapped ; } bool IsBase ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool base = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera1Id ) { base = true ; break ; } } return base ; } bool IsRef ( WbConfig config , KeyId camId ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; bool ref = false ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camId == camera2Id ) { ref = true ; break ; } } return ref ; } std :: vector < KeyId > FindRoot ( WbConfig config ) { std :: vector < KeyId > rootCamera ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; bool root = true ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( camPosId == camera2Id ) { root = false ; break ; } } if ( root && IsBase ( config , camPosId ) ) { rootCamera . push_back ( camPosId ) ; } } return rootCamera ; } std :: vector < KeyId > FindChain ( WbConfig config , KeyId camId , KeyId rootId , std :: vector < KeyId > mappingChain ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; LOG_INFO ( QObject :: tr ( " Camera1 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera1Id ) ) ; LOG_INFO ( QObject :: tr ( " Camera2 ▁ id ▁ = ▁ % 1 . " ) . arg ( camera2Id ) ) ; if ( camId == camera2Id ) { if ( std :: find ( mappingChain . begin ( ) , mappingChain . end ( ) , camera1Id ) == mappingChain . end ( ) ) { mappingChain . push_back ( camera1Id ) ; if ( camera1Id != rootId ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camera1Id ) . arg ( rootId ) ) ; mappingChain = FindChain ( config , camera1Id , rootId , mappingChain ) ; } if ( mappingChain . back ( ) == rootId ) { LOG_INFO ( " Found . " ) ; break ; } else { mappingChain . pop_back ( ) ; } } } } return mappingChain ; } bool CheckRoot@@ Mapping ( WbConfig config , KeyId rootId ) { bool allMapped = true ; const WbConfig roomLayoutConfig ( config . GetParent ( ) . GetSubConfig ( RoomLayoutSchema :: schemaName ) ) ; const QStringList cameraPositionIds ( roomLayoutConfig . GetKeyValue ( RoomLayoutSchema :: cameraPositionIdsKey ) . ToQStringList ( ) ) ; const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( int n = 0 ; n < cameraPositionIds . size ( ) ; ++ n ) { const KeyId camPosId = cameraPositionIds . at ( n ) ; if ( ( camPosId != rootId ) && IsRef ( config , camPosId ) ) { LOG_INFO ( QObject :: tr ( " Find ▁ chain ▁ for ▁ % 1 ▁ - ▁ % 2 . " ) . arg ( camPosId ) . arg ( rootId ) ) ; std :: vector < KeyId > chain = FindChain ( config , camPosId , rootId , std :: vector < KeyId > ( ) ) ; if ( chain . size ( ) == 0 ) { LOG_INFO ( " Not ▁ found . " ) ; allMapped = false ; break ; } } } return allMapped ; } void ComputeTransform ( WbConfig config , KeyId refId , std :: vector < KeyId > chain , CvMat * transform ) { const WbKeyValues :: ValueIdPairList cameraMappingIds = config . GetKeyValues ( FloorPlanSchema :: homographyKey ) ; for ( std :: vector < KeyId > :: iterator elt = chain . begin ( ) ; elt != chain . end ( ) ; ++ elt ) { for ( WbKeyValues :: ValueIdPairList :: const_iterator it = cameraMappingIds . begin ( ) ; it != cameraMappingIds . end ( ) ; ++ it ) { const KeyId camera1Id ( config . GetKeyValue ( FloorPlanSchema :: camera1IdKey , it -> id ) . ToKeyId ( ) ) ; const KeyId camera2Id ( config . GetKeyValue ( FloorPlanSchema :: camera2IdKey , it -> id ) . ToKeyId ( ) ) ; if ( ( camera1Id == * elt ) && ( camera2Id == refId ) ) { CvMat * homography = cvCreateMat ( 3 , 3 , CV_32F ) ; const bool homographyValid = config . GetKeyValue ( FloorPlanSchema :: homographyKey , it -> id ) . ToCvMat ( * homography ) ; Q_UNUSED ( homographyValid ) ; CvMat * tmp = cvCreateMat ( 3 , 3 , CV_32F ) ; cvMatMul ( homography , transform , tmp ) ; cvmSet ( transform , 0 , 0 , cvmGet ( tmp , 0 , 0 ) ) ; cvmSet ( transform , 0 , 1 , cvmGet ( tmp , 0 , 1 ) ) ; cvmSet ( transform , 0 , 2 , cvmGet ( tmp , 0 , 2 ) ) ; cvmSet ( transform , 1 , 0 , cvmGet ( tmp , 1 , 0 ) ) ; cvmSet ( transform , 1 , 1 , cvmGet ( tmp , 1 , 1 ) ) ; cvmSet ( transform , 1 , 2 , cvmGet ( tmp , 1 , 2 ) ) ; cvmSet ( transform , 2 , 0 , cvmGet ( tmp , 2 , 0 ) ) ; cvmSet ( transform , 2 , 1 , cvmGet ( tmp , 2 , 1 ) ) ; cvmSet ( transform , 2 , 2 , cvmGet ( tmp , 2 , 2 ) ) ; cvReleaseMat ( & tmp ) ; cvReleaseMat ( & homography ) ; refId = * elt ; } } } } } </DOCUMENT>
<DOCUMENT_ID="Shut@@ ok/Oreg@@ onCustom@@ /tree/master/dep/g@@ 3dlite@@ /source/@@ Color3@@ .cpp"> # include " G3D / platform . h " # include < stdlib . h > # include " G3D / Color3 . h " # include " G3D / Vector3 . h " # include " G3D / format . h " # include " G3D / BinaryInput . h " # include " G3D / BinaryOutput . h " # include " G3D / Color3uint8 . h " # include " G3D / Any . h " # include " G3D / stringutils . h " namespace G3D { Color3 :: Color3 ( const Any & any ) { * this = Color3 :: zero ( ) ; any . verifyName ( " Color3" ) ; std :: string name = toLower ( any . name ( ) ) ; switch ( any . type ( ) ) { case Any :: TABLE : for ( Any :: AnyTable :: Iterator it = any . table ( ) . begin ( ) ; it . hasMor@@ e ( ) ; ++ it ) { const std :: string & key = toLower ( it -> key ) ; if ( key == " r " ) { r = it -> value ; } else if ( key == " g " ) { g = it -> value ; } else if ( key == " b " ) { b = it -> value ; } else { any . verify ( false , " Illegal ▁ key : ▁ " + it -> key ) ; } } break ; case Any :: ARRAY : if ( name == " color3" ) { any . verifySize ( 3 ) ; r = any [ 0 ] ; g = any [ 1 ] ; b = any [ 2 ] ; } else if ( name == " color3 : : one " ) { any . verifySize ( 0 ) ; * this = one ( ) ; } else if ( name == " color3 : : zero " ) { any . verifySize ( 0 ) ; * this = zero ( ) ; } else if ( name == " color3 : : fromargb " ) { * this = Color3 :: fromARGB ( ( int ) any [ 0 ] . number ( ) ) ; } else { any . verify ( false , " Expected ▁ Color3 ▁ constructor " ) ; } break ; default : any . verify ( false , " Bad ▁ Color3 ▁ constructor " ) ; } } Color3 :: operator Any ( ) const { Any a ( Any :: ARRAY , " Color3" ) ; a . append ( r , g , b ) ; return a ; } Color3 Color3 :: ansiMap ( uint32 i ) { static const Color3 map [ ] = { Color3 :: black ( ) , Color3 :: red ( ) * 0.75f , Color3 :: green ( ) * 0.75f , Color3 :: yellow ( ) * 0.75f , Color3 :: blue ( ) * 0.75f , Color3 :: purple ( ) * 0.75f , Color3 :: cyan ( ) * 0.75f , Color3 :: white ( ) * 0.75f , Color3 :: white ( ) * 0.90@@ f , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: yellow ( ) , Color3 :: blue ( ) , Color3 :: purple ( ) , Color3 :: cyan ( ) , Color3 :: white ( ) } ; return map [ i & 15 ] ; } Color3 Color3 :: past@@ elMap ( uint32 i ) { uint32 x = Crypto :: crc32 ( & i , sizeof ( uint32 ) ) ; Vector3 v ( ( ( x >> 22 ) & 1023 ) / 1023@@ .0f , ( ( ( x >> 11 ) & 2047 ) / 2047.0f ) * 0.5f + 0.25f , ( ( x & 2047 ) / 2047.0f ) * 0.75f + 0.25f ) ; return Color3 :: fromHSV ( v ) ; } const Color3 & Color3 :: red ( ) { static Color3 c ( 1.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: green ( ) { static Color3 c ( 0.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: blue ( ) { static Color3 c ( 0.0f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: purple ( ) { static Color3 c ( 0.7f , 0.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: cyan ( ) { static Color3 c ( 0.0f , 0.7f , 1.0f ) ; return c ; } const Color3 & Color3 :: yellow ( ) { static Color3 c ( 1.0f , 1.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: brown ( ) { static Color3 c ( 0.5f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: orange ( ) { static Color3 c ( 1.0f , 0.5f , 0.0f ) ; return c ; } const Color3 & Color3 :: black ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: zero ( ) { static Color3 c ( 0.0f , 0.0f , 0.0f ) ; return c ; } const Color3 & Color3 :: one ( ) { static Color3 c ( 1.0f , 1.0f , 1.0f ) ; return c ; } const Color3 & Color3 :: gray ( ) { static Color3 c ( 0.7f , 0.7f , 0.7f ) ; return c ; } const Color3 & Color3 :: white ( ) { static Color3 c ( 1 , 1 , 1 ) ; return c ; } bool Color3 :: isFinite ( ) const { return G3D :: isFinite ( r ) && G3D :: isFinite ( g ) && G3D :: isFinite ( b ) ; } Color3 :: Color3 ( BinaryInput & bi ) { deserialize ( bi ) ; } void Color3 :: deserialize ( BinaryInput & bi ) { r = bi . readFloat32 ( ) ; g = bi . readFloat32 ( ) ; b = bi . readFloat32 ( ) ; } void Color3 :: serialize ( BinaryOutput & bo ) const { bo . writeFloat32 ( r ) ; bo . writeFloat32 ( g ) ; bo . writeFloat32 ( b ) ; } const Color3 & Color3 :: wheel@@ Random ( ) { static const Color3 colorArray [ 8 ] = { Color3 :: blue ( ) , Color3 :: red ( ) , Color3 :: green ( ) , Color3 :: orange ( ) , Color3 :: yellow ( ) , Color3 :: cyan ( ) , Color3 :: purple ( ) , Color3 :: brown ( ) } ; return colorArray [ iRandom ( 0 , 7 ) ] ; } size_t Color3 :: hashCode ( ) const { unsigned int rhash = ( * ( int * ) ( void * ) ( & r ) ) ; unsigned int ghash = ( * ( int * ) ( void * ) ( & g ) ) ; unsigned int bhash = ( * ( int * ) ( void * ) ( & b ) ) ; return rhash + ( ghash * 37 ) + ( bhash * 101 ) ; } Color3 :: Color3 ( const Vector3 & v ) { r = v . x ; g = v . y ; b = v . z ; } Color3 :: Color3 ( const class Color3uint8 & other ) { r = other . r / 255.0f ; g = other . g / 255.0f ; b = other . b / 255.0f ; } Color3 Color3 :: fromARGB ( uint32 x ) { return Color3 ( ( float ) ( ( x >> 16 ) & 0xFF ) , ( float ) ( ( x >> 8 ) & 0xFF ) , ( float ) ( x & 0xFF ) ) / 255.0f ; } Color3 Color3 :: random ( ) { return Color3 ( uniformRandom ( ) , uniformRandom ( ) , uniformRandom ( ) ) . direction ( ) ; } Color3 & Color3 :: operator /= ( float fScalar ) { if ( fScalar != 0.0f ) { float fInvScalar = 1.0f / fScalar ; r *= fInvScalar ; g *= fInvScalar ; b *= fInvScalar ; } else { r = ( float ) G3D :: finf ( ) ; g = ( float ) G3D :: finf ( ) ; b = ( float ) G3D :: finf ( ) ; } return * this ; } float Color3 :: unitize ( float fTolerance ) { float fLength = length ( ) ; if ( fLength > fTolerance ) { float fInvLength = 1.0f / fLength ; r *= fInvLength ; g *= fInvLength ; b *= fInvLength ; } else { fLength = 0.0f ; } return fLength ; } Color3 Color3 :: fromHSV ( const Vector3 & _hsv ) { debugAssertM ( ( _hsv . x <= 1.0f && _hsv . x >= 0.0f ) && ( _hsv . y <= 1.0f && _hsv . y >= 0.0f ) && ( _hsv . z <= 1.0f && _hsv . z >= 0.0f ) , " H , S , V ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; const int i = iMin ( 5 , G3D :: iF@@ loor ( 6.0 * _hsv . x ) ) ; const float f = 6.0f * _hsv . x - i ; const float m = _hsv . z * ( 1.0f - ( _hsv . y ) ) ; const float n = _hsv . z * ( 1.0f - ( _hsv . y * f ) ) ; const float k = _hsv . z * ( 1.0f - ( _hsv . y * ( 1 - f ) ) ) ; switch ( i ) { case 0 : return Color3 ( _hsv . z , k , m ) ; case 1 : return Color3 ( n , _hsv . z , m ) ; case 2 : return Color3 ( m , _hsv . z , k ) ; case 3 : return Color3 ( m , n , _hsv . z ) ; case 4 : return Color3 ( k , m , _hsv . z ) ; case 5 : return Color3 ( _hsv . z , m , n ) ; default : debugAssertM ( false , " fell ▁ through ▁ switch . . " ) ; } return Color3 :: black ( ) ; } Vector3 Color3 :: toHSV ( const Color3 & _rgb ) { debugAssertM ( ( _rgb . r <= 1.0f && _rgb . r >= 0.0f ) && ( _rgb . g <= 1.0f && _rgb . g >= 0.0f ) && ( _rgb . b <= 1.0f && _rgb . b >= 0.0f ) , " R , G , B ▁ must ▁ be ▁ between ▁ [ 0,1 ] " ) ; Vector3 hsv = Vector3 :: zero ( ) ; hsv . z = G3D :: max ( G3D :: max ( _rgb . r , _rgb . g ) , _rgb . b ) ; if ( G3D :: fuzzyEq ( hsv . z , 0.0f ) ) { return hsv ; } const float x = G3D :: min ( G3D :: min ( _rgb . r , _rgb . g ) , _rgb . b ) ; hsv . y = ( hsv . z - x ) / hsv . z ; if ( G3D :: fuzzyEq ( hsv . y , 0.0f ) ) { return hsv ; } Vector3 rgbN ; rgbN . x = ( hsv . z - _rgb . r ) / ( hsv . z - x ) ; rgbN . y = ( hsv . z - _rgb . g ) / ( hsv . z - x ) ; rgbN . z = ( hsv . z - _rgb . b ) / ( hsv . z - x ) ; if ( _rgb . r == hsv . z ) { hsv . x = ( _rgb . g == x ) ? 5.0f + rgbN . z : 1.0f - rgbN . y ; } else if ( _rgb . g == hsv . z ) { hsv . x = ( _rgb . b == x ) ? 1.0f + rgbN . x : 3.0f - rgbN . z ; } else { hsv . x = ( _rgb . r == x ) ? 3.0f + rgbN . y : 5.0f - rgbN . x ; } hsv . x /= 6.0f ; return hsv ; } Color3 Color3 :: jetColor@@ Map ( const float & val ) { debugAssertM ( val <= 1.0f && val >= 0.0f , " value ▁ should ▁ be ▁ in ▁ [ 0,1 ] " ) ; Color3 jet ; jet . r = G3D :: min ( 4.0f * val - 1.5f , - 4.0f * val + 4.5f ) ; jet . g = G3D :: min ( 4.0f * val - 0.5f , - 4.0f * val + 3.5f ) ; jet . b = G3D :: min ( 4.0f * val + 0.5f , - 4.0f * val + 2.5f ) ; jet . r = G3D :: clamp ( jet . r , 0.0f , 1.0f ) ; jet . g = G3D :: clamp ( jet . g , 0.0f , 1.0f ) ; jet . b = G3D :: clamp ( jet . b , 0.0f , 1.0f ) ; return jet ; } std :: string Color3 :: toString ( ) const { return G3D :: format ( " ( % g , ▁ % g , ▁ % g ) " , r , g , b ) ; } Color3 Color3 :: rain@@ bowColor@@ Map ( float hue ) { return fromHSV ( Vector3 ( hue , 1.0f , 1.0f ) ) ; } } ; </DOCUMENT>
<DOCUMENT_ID="Maximus-@@ /WinObjC/tree/master/deps/3rdparty/ic@@ u/icu/@@ source/layout@@ /TibetanReordering@@ .cpp"> # include " LETypes . h " # include " OpenTypeTables . h " # include " TibetanReordering . h " # include " LEGlyphStorage . h " U_NAMESPACE_BEGIN enum { C_DOTTED_CIRCLE = 0x25@@ CC , C_PRE_NUMBER_MARK = 0x0F@@ 3F } ; enum { _xx = TibetanClassTable :: CC_RESERVED , _ba = TibetanClassTable :: CC_BASE , _sj = TibetanClassTable :: CC_SUB@@ JOINED | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _tp = TibetanClassTable :: CC_TS@@ A_PH@@ RU | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _ac = TibetanClassTable :: CC_A_CHUN@@ G | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _cs = TibetanClassTable :: CC_COMP@@ _SAN@@ SKRIT | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _ha = TibetanClassTable :: CC_HAL@@ ANTA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _bv = TibetanClassTable :: CC_BELO@@ W_VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _av = TibetanClassTable :: CC_ABOVE_@@ VOWEL | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _an = TibetanClassTable :: CC_ANUSV@@ ARA | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _cb = TibetanClassTable :: CC_CAND@@ RAB@@ IND@@ U | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _vs = TibetanClassTable :: CC_VISARG@@ A | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER , _as = TibetanClassTable :: CC_ABOVE_@@ S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_ABOVE , _bs = TibetanClassTable :: CC_BELO@@ W_S_MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_BELOW , _di = TibetanClassTable :: CC_DIGIT | TibetanClassTable :: CF_DIGIT , _pd = TibetanClassTable :: CC_PRE_@@ DIGIT_@@ MARK | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_PREDIGIT | TibetanClassTable :: CF_POS_BEFORE , _bd = TibetanClassTable :: CC_POST_BELO@@ W_DIGIT_@@ M | TibetanClassTable :: CF_DOTTED_CIRCLE | TibetanClassTable :: CF_POS_AFTER } ; static const TibetanClassTable :: CharClass tibetanCharClasses [ ] = { _xx , _ba , _xx , _xx , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bd , _bd , _xx , _xx , _xx , _xx , _xx , _xx , _di , _di , _di , _di , _di , _di , _di , _di , _di , _di , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _bs , _xx , _tp , _xx , _xx , _xx , _xx , _bd , _pd , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _xx , _xx , _ac , _av , _cs , _bv , _bv , _cs , _cs , _cs , _cs , _av , _av , _av , _av , _an , _vs , _av , _cs , _cb , _cb , _ha , _xx , _as , _as , _ba , _ba , _ba , _ba , _xx , _xx , _xx , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _sj , _xx , _sj , _sj , _xx , _xx , _xx , _xx , _xx , _xx , _bs , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , _xx , } ; static const TibetanClassTable tibetanClassTable = { 0x0F@@ 00 , 0x0FF@@ F , tibetanCharClasses } ; TibetanClassTable :: CharClass TibetanClassTable :: getCharClass ( LEUnicode ch ) const { if ( ch < firstChar || ch > lastChar ) { return CC_RESERVED ; } return classTable [ ch - firstChar ] ; } const TibetanClassTable * TibetanClassTable :: getTibetanClassTable ( ) { return & tibetanClassTable ; } class TibetanReorderingOutput : public UMem@@ ory { private : le_int32 fSyllableCount ; le_int32 fOutIndex ; LEUnicode * fOutChars ; LEGlyphStorage & fGlyphStorage ; public : TibetanReorderingOutput ( LEUnicode * outChars , LEGlyphStorage & glyphStorage ) : fSyllableCount ( 0 ) , fOutIndex ( 0 ) , fOutChars ( outChars ) , fGlyphStorage ( glyphStorage ) { } ~ TibetanReorderingOutput ( ) { } void reset ( ) { fSyllableCount += 1 ; } void writeChar ( LEUnicode ch , le_uint32 charIndex , FeatureMask featureMask ) { LEErrorCode success = LE_NO_ERROR ; fOutChars [ fOutIndex ] = ch ; fGlyphStorage . setChar@@ Index ( fOutIndex , charIndex , success ) ; fGlyphStorage . setAu@@ xData ( fOutIndex , featureMask , success ) ; fOutIndex += 1 ; } le_int32 getOutputIndex ( ) { return fOutIndex ; } } ; # define ccmpFeatureTag LE_CCMP_FEATURE_TAG # define blwfFeatureTag LE_BLW@@ F_FEATURE_TAG # define pstfFeatureTag LE_PST@@ F_FEATURE_TAG # define presFeatureTag LE_PRES@@ _FEATURE_TAG # define blwsFeatureTag LE_BLW@@ S_FEATURE_TAG # define abvsFeatureTag LE_AB@@ VS_FEATURE_TAG # define pstsFeatureTag LE_PST@@ S_FEATURE_TAG # define blwmFeatureTag LE_BLW@@ M_FEATURE_TAG # define abvmFeatureTag LE_AB@@ VM_FEATURE_TAG # define distFeatureTag LE_DIST_FEATURE_TAG # define prefFeatureTag LE_PRE@@ F_FEATURE_TAG # define abvfFeatureTag LE_AB@@ VF_FEATURE_TAG # define cligFeatureTag LE_CLI@@ G_FEATURE_TAG # define mkmkFeatureTag LE_MK@@ MK@@ _FEATURE_TAG # define prefFeatureMask 0x80000000UL # define blwfFeatureMask 0x40000000UL # define abvfFeatureMask 0x20000000UL # define pstfFeatureMask 0x10000000UL # define presFeatureMask 0x08@@ 000000UL # define blwsFeatureMask 0x04000000UL # define abvsFeatureMask 0x02@@ 000000UL # define pstsFeatureMask 0x01000000@@ UL # define cligFeatureMask 0x00800000UL # define ccmpFeatureMask 0x0004@@ 0000UL # define distFeatureMask 0x00400000UL # define blwmFeatureMask 0x00200000UL # define abvmFeatureMask 0x00100000UL # define mkmkFeatureMask 0x0008@@ 0000UL # define tagPref ( ccmpFeatureMask | prefFeatureMask | presFeatureMask | cligFeatureMask | distFeatureMask ) # define tagAbvf ( ccmpFeatureMask | abvfFeatureMask | abvsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask ) # define tagPstf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | prefFeatureMask | presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask ) # define tagBlwf ( ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask | mkmkFeatureMask ) # define tagDefault ( ccmpFeatureMask | prefFeatureMask | blwfFeatureMask | presFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | blwmFeatureMask | mkmkFeatureMask ) static const FeatureMap featureMap [ ] = { { ccmpFeatureTag , ccmpFeatureMask } , { prefFeatureTag , prefFeatureMask } , { blwfFeatureTag , blwfFeatureMask } , { abvfFeatureTag , abvfFeatureMask } , { pstfFeatureTag , pstfFeatureMask } , { presFeatureTag , presFeatureMask } , { blwsFeatureTag , blwsFeatureMask } , { abvsFeatureTag , abvsFeatureMask } , { pstsFeatureTag , pstsFeatureMask } , { cligFeatureTag , cligFeatureMask } , { distFeatureTag , distFeatureMask } , { blwmFeatureTag , blwmFeatureMask } , { abvmFeatureTag , abvmFeatureMask } , { mkmkFeatureTag , mkmkFeatureMask } , } ; static const le_int32 featureMapCount = LE_ARRAY_SIZE ( featureMap ) ; static const le_int8 tibetanStateTable [ ] [ TibetanClassTable :: CC_COUNT ] = { { 1 , 2 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , 20 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 3 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 4 , 6 , 8 , 7 , 9 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , 5 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , 8 , 7 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 10 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 11 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 12 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 13 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 14 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 15 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 16 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 17 , 17 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 18 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 19 , 19 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , 21 , 21 , } , { - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , - 1 , } , } ; const FeatureMap * TibetanReordering :: getFeatureMap ( le_int32 & count ) { count = featureMapCount ; return featureMap ; } le_int32 TibetanReordering :: findSyllable ( const TibetanClassTable * classTable , const LEUnicode * chars , le_int32 prev , le_int32 charCount ) { le_int32 cursor = prev ; le_int8 state = 0 ; while ( cursor < charCount ) { TibetanClassTable :: CharClass charClass = ( classTable -> getCharClass ( chars [ cursor ] ) & TibetanClassTable :: CF_CLASS_@@ MASK ) ; state = tibetanStateTable [ state ] [ charClass ] ; if ( state < 0 ) { break ; } cursor += 1 ; } return cursor ; } le_int32 TibetanReordering :: reorder ( const LEUnicode * chars , le_int32 charCount , le_int32 , LEUnicode * outChars , LEGlyphStorage & glyphStorage ) { const TibetanClassTable * classTable = TibetanClassTable :: getTibetanClassTable ( ) ; TibetanReorderingOutput output ( outChars , glyphStorage ) ; TibetanClassTable :: CharClass charClass ; le_int32 i , prev = 0 ; while ( prev < charCount ) { le_int32 syllable = findSyllable ( classTable , chars , prev , charCount ) ; output . reset ( ) ; if ( classTable -> getCharClass ( chars [ prev ] ) & TibetanClassTable :: CF_DOTTED_CIRCLE ) { output . writeChar ( C_DOTTED_CIRCLE , prev , tagDefault ) ; } for ( i = prev ; i < syllable ; i += 1 ) { charClass = classTable -> getCharClass ( chars [ i ] ) ; if ( ( TibetanClassTable :: CF_DIGIT & charClass ) && ( classTable -> getCharClass ( chars [ i + 1 ] ) & TibetanClassTable :: CF_PREDIGIT ) ) { output . writeChar ( C_PRE_NUMBER_MARK , i , tagPref ) ; output . writeChar ( chars [ i ] , i + 1 , tagPref ) ; i += 1 ; } else { switch ( charClass & TibetanClassTable :: CF_POS_MASK ) { case TibetanClassTable :: CF_POS_ABOVE : output . writeChar ( chars [ i ] , i , tagAbvf ) ; break ; case TibetanClassTable :: CF_POS_AFTER : output . writeChar ( chars [ i ] , i , tagPstf ) ; break ; case TibetanClassTable :: CF_POS_BELOW : output . writeChar ( chars [ i ] , i , tagBlwf ) ; break ; default : output . writeChar ( chars [ i ] , i , tagDefault ) ; break ; } } } prev = syllable ; } return output . getOutputIndex ( ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="k@@ yro@@ skoh@@ /phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/@@ network/soup@@ /Soup@@ URI@@ Utils.cpp"> # include " config . h " # include " Soup@@ URIUtils . h " # include < wtf / gobject / GOwnPtr . h > # include < libsoup / soup . h > namespace WebCore { KURL soupURI@@ ToKURL ( Soup@@ URI * soupURI ) { GOwnPtr < gchar > urlString ( soup_ur@@ i_to_string ( soupURI , FALSE ) ) ; KURL url ( KURL ( ) , String :: fromUTF8 ( urlString . get ( ) ) ) ; if ( ! soupURI -> password ) return url ; url . setPass ( String :: fromUTF8 ( soupURI -> password ) ) ; return url ; } } </DOCUMENT>
<DOCUMENT_ID="l@@ thall@@ /Le@@ onard_@@ ardupilot/tree/master/libraries/AP_@@ NavEKF/@@ AP_NavEKF_core_@@ common.cpp"> # include " AP _ NavEKF _ core _ common . h " NavEKF_core_common :: Matrix24 NavEKF_core_common :: KH ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: KHP ; NavEKF_core_common :: Matrix24 NavEKF_core_common :: nextP ; NavEKF_core_common :: Vector28 NavEKF_core_common :: Kfusion ; void NavEKF_core_common :: fill_scratch@@ _variables ( void ) { # if CONFIG_HAL_BOARD == HAL_BOARD@@ _SIT@@ L fill_nanf ( & KH [ 0 ] [ 0 ] , sizeof ( KH ) / sizeof ( float ) ) ; fill_nanf ( & KHP [ 0 ] [ 0 ] , sizeof ( KHP ) / sizeof ( float ) ) ; fill_nanf ( & nextP [ 0 ] [ 0 ] , sizeof ( nextP ) / sizeof ( float ) ) ; fill_nanf ( & Kfusion [ 0 ] , sizeof ( Kfusion ) / sizeof ( float ) ) ; # endif } </DOCUMENT>
<DOCUMENT_ID="whc1000@@ 2/@@ stu@@ dy/tree/master/lib@@ cd@@ s/test/unit@@ /strip@@ ed-map@@ /map_@@ boost_@@ flat_map.cpp"> # ifdef CDSUNIT_@@ ENABLE_BOOST_CONTAINER # include < boost / version . hpp > # include < cds / details / defs . h > # if CDS_@@ COMPILER == CDS_COMPILER_@@ MSVC && CDS_COMPILER_@@ VERSION == CDS_COMPILER_@@ MSV@@ C12 && BOOST_VERSION < 105500 # elif BOOST_VERSION >= 104800 # include < cds / container / striped_@@ map / boost_@@ flat_map . h > # include " test _ striped _ map . h " namespace { struct test_traits { typedef boost :: container :: flat_map < cds_test :: striped_map_fixture :: key_type , cds_test :: striped_map_fixture :: value_type , cds_test :: striped_map_fixture :: less > container_type ; struct copy_policy { typedef container_type :: iterator iterator ; void operator ( ) ( container_type & m , iterator , iterator itWhat ) { m . insert ( * itWhat ) ; } } ; static bool const c_has@@ FindWith = false ; static bool const c_has@@ Erase@@ With = false ; } ; INSTANTIATE_TYPED_TEST_CASE_P ( BoostFlatMap , Strip@@ edMap , test_traits ) ; INSTANTIATE_TYPED_TEST_CASE_P ( BoostFlatMap , Refin@@ ableMap , test_traits ) ; } # else # endif # endif </DOCUMENT>
<DOCUMENT_ID="eugene1g@@ /phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/@@ css@@ /CSSSupport@@ sRule@@ .cpp"> # include " config . h " # include " CSSSupportsRule . h " # include " CSSParser . h " # include " CSSRule . h " # include " CSSRuleList . h " # include " CSSStyleSheet . h " # include " ExceptionCode . h " # include " StyleRule . h " # include < wtf / text / StringBuilder . h > # if ENABLE ( CSS3_@@ CONDITIONAL_RULES ) namespace WebCore { CSSSupportsRule :: CSSSupportsRule ( StyleRuleSupports * supportsRule , CSSStyleSheet * parent ) : CSSGroupingRule ( supportsRule , parent ) { } String CSSSupportsRule :: css@@ Text ( ) const { StringBuilder result ; result . append ( " @ supports ▁ " ) ; result . append ( conditionText ( ) ) ; result . append ( " ▁ { \n " ) ; appendCss@@ TextForItems ( result ) ; result . append ( ' } ' ) ; return result . toString ( ) ; } String CSSSupportsRule :: conditionText ( ) const { return toStyleRuleSupports ( m_group@@ Rule . get ( ) ) -> conditionText ( ) ; } } # endif </DOCUMENT>
<DOCUMENT_ID="k@@ stripp/Litt@@ leBud@@ get/tree/master/src/core/@@ main.cpp"> # include < iostream > # include " lb . h " using std :: cout ; using std :: endl ; using std :: cerr ; # ifndef VERSION # define VERSION "1.0.1" # endif int main ( int argc , const char * argv [ ] ) { try { lb app ( argc , argv ) ; return app . run ( ) ; } catch ( lb_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( runtime_error e ) { cerr << e . what ( ) << endl ; return EXIT_FAILURE ; } catch ( ... ) { cerr << " Unhand@@ led ▁ exception ▁ in ▁ lb . " << endl ; return EXIT_FAILURE ; } } </DOCUMENT>
<DOCUMENT_ID="B@@ enKey@@ FSI@@ /poedit/tree/master/deps/boost/libs/@@ wave/test/testwave@@ /testfiles/@@ t_6_@@ 044.cpp"> # define CON ## name CON </DOCUMENT>
