extern __valu@@ e_in_re@@ gs struct __initial_stackheap __user_@@ setup_@@ stackheap ( uint32_t R0 , uint32_t R1 , uint32_t R2 , uint32_t R3 ) { struct __initial_stackheap r ; r . heap@@ _base = ( uint32_t ) Image$$ARM_LIB_HEAP$$Base ; r . heap_@@ limit = ( uint32_t ) Image$$ARM_LIB_HEAP$$ZI$$Limit ; return r ; }
int main ( ) { Game aGame ; aGame . add ( " Chet " ) ; aGame . add ( " Pat " ) ; aGame . add ( " Sue " ) ; do { aGame . roll ( rand ( ) % 5 + 1 ) ; if ( rand ( ) % 9 == 7 ) { notAWinner = aGame . wron@@ gAns@@ wer ( ) ; } else { notAWinner = aGame . wasCor@@ rectlyAns@@ wered ( ) ; } } while ( notAWinner ) ; }
DWORD CascDe@@ compress ( LPBYTE pbOutBuffer , PDWORD pcbOutBuffer , LPBYTE pbInBuffer , DWORD cbInBuffer ) { z_@@ stream z ; DWORD dwErrCode = ERROR_FILE_@@ CORRUP@@ T ; uInt cbOutBuffer = * pcbOutBuffer ; int nResult ; z . next_in = pbInBuffer ; z . avai@@ l_in = cbInBuffer ; z . total_in = cbInBuffer ; z . next_out = pbOutBuffer ; z . avai@@ l_out = cbOutBuffer ; z . total_out = 0 ; z . zalloc = NULL ; z . zfree = NULL ; cbOutBuffer = 0 ; if ( ( nResult = inflate@@ Init ( & z ) ) == Z_OK ) { nResult = inf@@ late ( & z , Z_NO@@ _FL@@ USH ) ; if ( nResult == Z_OK || nResult == Z_STREAM_@@ END ) { cbOutBuffer = z . total_out ; dwErrCode = ERROR_SUCCESS ; } inflate@@ End ( & z ) ; } pcbOutBuffer [ 0 ] = cbOutBuffer ; return dwErrCode ; }
TEST ( CodeGenTest , TestNull@@ CodeGen ) { auto Invocation = std :: make_shared < Compiler@@ Invocation > ( ) ; Invocation -> getPreprocessor@@ Opts ( ) . addRe@@ mappedFile ( " test . cc " , MemoryBuffer :: getMem@@ Buffer ( " " ) . release ( ) ) ; Invocation -> getFrontendOpts ( ) . Inputs . push_back ( Frontend@@ InputFile ( " test . cc " , Language :: CXX ) ) ; Invocation -> getFrontendOpts ( ) . ProgramAction = EmitLLVM ; Invocation -> getTarget@@ Opts ( ) . Triple = " i38@@ 6 - unknown - linux - gnu " ; CompilerInstance Compiler ; Compiler . setInvocation ( std :: move ( Invocation ) ) ; Compiler . createDiagnostics ( ) ; EXPECT_TRUE ( Compiler . hasDiagnostics ( ) ) ; std :: unique_ptr < Frontend@@ Action > Act ( new NullCodeGenAction ) ; bool Success = Compiler . ExecuteAction ( * Act ) ; EXPECT_TRUE ( Success ) ; }
int main ( ) { string s ; cin >> s ; map < string , int > m ; vector < string > ar ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string sstr = s . substr ( i , s . size ( ) - i ) ; m [ sstr ] = i ; ar . push_back ( sstr ) ; } sort ( ar . begin ( ) , ar . end ( ) ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { cout << m [ ar [ i ] ] << endl ; } return 0 ; }
void AddSC_@@ boss_high_interrogator_gerstahn ( ) { new boss_high_interrogator_gerstahn ( ) ; }
void AddSC_@@ arathi_high@@ lands ( ) { new npc_professor_phizzlethorpe ( ) ; }
void mex@@ Function ( int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ] ) { narg@@ chk ( nrhs >= 1 && ( nrhs % 2 ) == 1 && nlhs <= 1 ) ; vector < MxArray > rhs ( prhs , prhs + nrhs ) ; int blockSize = 5 ; int ksize = 3 ; double k = 0.04 ; int borderType = cv :: BOR@@ DER_DEFAULT ; for ( int i = 1 ; i < nrhs ; i += 2 ) { string key ( rhs [ i ] . toString ( ) ) ; if ( key == " BlockSize " ) blockSize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " KSize " ) ksize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " K " ) k = rhs [ i + 1 ] . toDouble ( ) ; else if ( key == " BorderType " ) borderType = BorderType [ rhs [ i + 1 ] . toString ( ) ] ; else mex@@ ErrMsg@@ IdAnd@@ Txt ( " mexopencv : error " , " Unrecognized ▁ option " ) ; } Mat src ( rhs [ 0 ] . toMat ( rhs [ 0 ] . isUint8 ( ) ? CV_8U : CV_32F ) ) , dst ; cornerHarri@@ s ( src , dst , blockSize , ksize , k , borderType ) ; plhs [ 0 ] = MxArray ( dst ) ; }
ActivableScopedAdvancedTimer ( bool active , const char * message , Base * base ) : message ( message ) , m_active ( active ) , m_base ( base ) { if ( m_active ) AdvancedTimer :: stepBegin ( message , m_base ) ; }
~ ActivableScopedAdvancedTimer ( ) { if ( m_active ) AdvancedTimer :: stepEnd ( message , m_base ) ; }
public : MyFileEventListener ( PythonScriptController * psc ) { m_controller = psc ; }
Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGL@@ Format ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; }
void build ( const QString & file_path ) { clear ( ) ; read_data ( file_path ) ; if ( ! brect_initialized_ ) { return ; } construct_brect ( ) ; construct_@@ voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } update_view_port ( ) ; }
void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; }
void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; }
protected : void initialize@@ GL ( ) { glHint ( GL_POINT_SMO@@ OTH_@@ HINT , GL_NIC@@ EST ) ; glBlendFunc ( GL_S@@ RC_ALPHA , GL_ONE_@@ MINUS_S@@ RC_ALPHA ) ; glEnable ( GL_BL@@ END ) ; glEnable ( GL_POINT_SMO@@ OTH ) ; }
void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_@@ BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; }
void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; }
void timerEvent ( QTimer@@ Event * e ) { update ( ) ; }
void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; }
void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; }
void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } }
void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloa@@ t ( brect_ , side * 1.2 ) ; }
void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_@@ next ( ) ; } while ( e != v -> incident_edge ( ) ) ; }
void update_view_port ( ) { glMatrixMode ( GL_PROJ@@ ECTION ) ; glLoad@@ Identity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOr@@ tho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODEL@@ VIE@@ W ) ; }
void draw_points ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; }
void draw_segments ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; }
void draw_vertices ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; }
void draw_edges ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_@@ STRI@@ P ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } }
void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } }
void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_@@ visual_@@ utils < coordinate_type > :: disc@@ retize ( point , segment , max_dist , sampled_edge ) ; }
point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGOR@@ Y_SING@@ LE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGOR@@ Y_SE@@ GMENT_START_@@ POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } }
segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; }
Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSize@@ Constraint ( QLayout :: SetFix@@ edSize ) ; }
private slo@@ ts : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; }
void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; }
void browse ( ) { QString new_path = QFileDialog :: getExisting@@ Directory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; }
void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; }
void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } }
private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QList@@ WidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; }
void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; }
int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; }
static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; }
static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhase@@ Mask ; }
int ctkExampleUseOfWorkflowWidget@@ UsingSignalsAndSlots ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; bool hideWidgets = false ; ctkWorkflow * workflow = new ctkWorkflow ; ctkWorkflowTabWidget * workflowWidget = new ctkWorkflowTabWidget ; workflowWidget -> setWorkflow ( workflow ) ; ctkWorkflowGroupBox * groupBox = workflowWidget -> workflowGroupBox ( ) ; groupBox -> setPre@@ Text ( " I ▁ am ▁ some ▁ pre - text " ) ; groupBox -> setPost@@ Text ( " I ▁ am ▁ some ▁ post - text " ) ; groupBox -> setHide@@ WidgetsOf@@ NonCurrent@@ Steps ( hideWidgets ) ; ctkWorkflowWidgetStep * testStep1 = new ctkWorkflowWidgetStep ( " Step ▁ 1" ) ; testStep1 -> setName ( " Step ▁ 1" ) ; testStep1 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 1" ) ; workflowWidget -> associateStepWithLabel ( testStep1 , " name ▁ 1" ) ; ctkWorkflowWidgetStep * testStep2 = new ctkWorkflowWidgetStep ( " Step ▁ 2" ) ; testStep2 -> setName ( " Step ▁ 2" ) ; testStep2 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 2" ) ; workflowWidget -> associateStepWithLabel ( testStep2 , " name ▁ 2" ) ; ctkWorkflowWidgetStep * testStep3 = new ctkWorkflowWidgetStep ( " Step ▁ 3" ) ; testStep3 -> setName ( " Step ▁ 3" ) ; testStep3 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 3" ) ; workflowWidget -> associateStepWith@@ Page ( testStep3 , 1 , " name ▁ 3" ) ; workflow -> addTransition ( testStep1 , testStep2 ) ; workflow -> addTransition ( testStep2 , testStep3 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject1 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep1 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject2 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep2 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject3 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep3 ) ; qObject1 -> setWidget ( testStep1 -> stepArea ( ) ) ; qObject2 -> setWidget ( testStep2 -> stepArea ( ) ) ; qObject3 -> setWidget ( testStep3 -> stepArea ( ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject1 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject2 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject3 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject1 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject1 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject2 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject2 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject3 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject3 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; testStep1 -> setHasValidateCommand ( 1 ) ; testStep1 -> setHasOnEntryCommand ( 1 ) ; testStep1 -> setHasOnExitCommand ( 1 ) ; testStep1 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep2 -> setHasValidateCommand ( 1 ) ; testStep2 -> setHasOnEntryCommand ( 1 ) ; testStep2 -> setHasOnExitCommand ( 1 ) ; testStep2 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep3 -> setHasValidateCommand ( 1 ) ; testStep3 -> setHasOnEntryCommand ( 1 ) ; testStep3 -> setHasOnExitCommand ( 1 ) ; testStep3 -> setHasCreateUserInterfaceCommand ( 1 ) ; workflow -> setInitial@@ Step ( testStep1 ) ; workflow -> start ( ) ; workflowWidget -> show ( ) ; QTimer :: singleShot ( 500 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; workflow -> stop ( ) ; QTimer :: singleShot ( 100 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; delete workflowWidget ; return EXIT_SUCCESS ; }
BOOST_AUTO_TEST_SUITE ( multisig_@@ tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; }
BOOST_AUTO_TEST_CASE ( multisig_@@ verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } }
BOOST_AUTO_TEST_CASE ( multisig_@@ IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; }
BOOST_AUTO_TEST_CASE ( multisig_S@@ olver1 ) { CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH@@ 160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUAL@@ VERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } }
BOOST_AUTO_TEST_CASE ( multisig_S@@ ign ) { CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } }
void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; }
private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_@@ H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_@@ H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_@@ A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_@@ A ) ) ; default : return false ; } }
double angleDiff ( double phi1 , double phi2 ) { double d = phi2 - phi1 ; if ( d > 0.0 ) { d = fmod ( d + M_PI , 2 * M_PI ) - M_PI ; } else { d = fmod ( d - M_PI , 2 * M_PI ) + M_PI ; } return d ; }
Vector4d quatConjugate ( const Eigen :: Vector4d & q ) { Vector4d q_conj ; q_conj << q ( 0 ) , - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; return q_conj ; }
double quatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; double e = - 2.0 + 2 * r ( 0 ) * r ( 0 ) + 2 * pow ( u ( 0 ) * r ( 1 ) + u ( 1 ) * r ( 2 ) + u ( 2 ) * r ( 3 ) , 2 ) ; return e ; }
double quatNorm ( const Eigen :: Vector4d & q ) { return std :: acos ( q ( 0 ) ) ; }
Vector4d uniformlyRandomAxisAngle ( std :: default_random_engine & generator ) { std :: normal_distribution < double > normal ; std :: unifor@@ m_real_distribution < double > uniform ( - M_PI , M_PI ) ; double angle = uniform ( generator ) ; Vector3d axis = Vector3d ( normal ( generator ) , normal ( generator ) , normal ( generator ) ) ; axis . normalize ( ) ; Vector4d a ; a << axis , angle ; return a ; }
Vector4d uniformlyRandomQuat ( std :: default_random_engine & generator ) { return axis2quat ( uniformlyRandomAxisAngle ( generator ) ) ; }
DLLEXPORT int rotationRepresentationSize ( int rotation_type ) { switch ( rotation_type ) { case 0 : return 0 ; break ; case 1 : return 3 ; break ; case 2 : return 4 ; break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } }
Matrix3d rotz ( double theta ) { Matrix3d M ; double c = cos ( theta ) ; double s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; return M ; }
void rotz ( double theta , Matrix3d & M , Matrix3d & dM , Matrix3d & ddM ) { double c = cos ( theta ) , s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; dM << - s , - c , 0 , c , - s , 0 , 0 , 0 , 0 ; ddM << - c , s , 0 , - s , - c , 0 , 0 , 0 , 0 ; }
template < typename Derived > void normalizeVec ( const Eigen :: MatrixBase < Derived > & x , typename Derived :: PlainObject & x_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 1 > :: type * dx_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 2 > :: type * ddx_norm ) { typename Derived :: Scalar xdotx = x . squaredNorm ( ) ; typename Derived :: Scalar norm_x = std :: sqrt ( xdotx ) ; x_norm = x / norm_x ; if ( dx_norm ) { dx_norm -> setIdentity ( x . rows ( ) , x . rows ( ) ) ; ( * dx_norm ) -= x * x . transpose ( ) / xdotx ; ( * dx_norm ) /= norm_x ; if ( ddx_norm ) { auto dx_norm_transpose = transposeGrad ( * dx_norm , x . rows ( ) ) ; auto ddx_norm_times_norm = - matGradM@@ ultMat ( x_norm , x_norm . transpose ( ) , ( * dx_norm ) , dx_norm_transpose ) ; auto dnorm_inv = - x . transpose ( ) / ( xdotx * norm_x ) ; ( * ddx_norm ) = ddx_norm_times_norm / norm_x ; auto temp = ( * dx_norm ) * norm_x ; typename Derived :: Index n = x . rows ( ) ; for ( int col = 0 ; col < n ; col ++ ) { auto column_as_matrix = ( dnorm_inv ( 0 , col ) * temp ) ; for ( int row_block = 0 ; row_block < n ; row_block ++ ) { ddx_norm -> block ( row_block * n , col , n , 1 ) += column_as_matrix . col ( row_block ) ; } } } } }
template < typename DerivedQ , typename DerivedM , typename DerivedDM > void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , Eigen :: MatrixBase < DerivedDM > * dM ) { M . resize ( QUAT_SIZE , SPACE_DIMENSION ) ; M . row ( 0 ) << - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; M . row ( 1 ) << q ( 0 ) , q ( 3 ) , - q ( 2 ) ; M . row ( 2 ) << - q ( 3 ) , q ( 0 ) , q ( 1 ) ; M . row ( 3 ) << q ( 2 ) , - q ( 1 ) , q ( 0 ) ; M *= 0.5 ; if ( dM ) { ( * dM ) << 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 ; } }
template < typename DerivedQ , typename DerivedM > void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , typename Gradient < DerivedM , QUAT_SIZE , 1 > :: type * dM ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedQ > , QUAT_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedM > , SPACE_DIMENSION , QUAT_SIZE ) ; typename DerivedQ :: PlainObject qtilde ; if ( dM ) { typename Gradient < DerivedQ , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; ( * dM ) << 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 ; ( * dM ) *= dqtilde ; } else { normalizeVec ( q , qtilde ) ; } M << - qtilde ( 1 ) , qtilde ( 0 ) , - qtilde ( 3 ) , qtilde ( 2 ) , - qtilde ( 2 ) , qtilde ( 3 ) , qtilde ( 0 ) , - qtilde ( 1 ) , - qtilde ( 3 ) , - qtilde ( 2 ) , qtilde ( 1 ) , qtilde ( 0 ) ; M *= 2.0 ; }
template < typename DerivedRPY , typename DerivedPhi , typename DerivedDPhi , typename DerivedDDPhi > void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , typename Eigen :: MatrixBase < DerivedPhi > & phi , typename Eigen :: MatrixBase < DerivedDPhi > * dphi , typename Eigen :: MatrixBase < DerivedDDPhi > * ddphi ) { phi . resize ( RPY_SIZE , SPACE_DIMENSION ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; using namespace std ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar tp = sp / cp ; phi << cy / cp , sy / cp , 0.0 , - sy , cy , 0.0 , cy * tp , tp * sy , 1.0 ; if ( dphi ) { dphi -> resize ( phi . size ( ) , RPY_SIZE ) ; Scalar sp2 = sp * sp ; Scalar cp2 = cp * cp ; ( * dphi ) << 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy + ( cy * sp2 ) / cp2 , - ( sp * sy ) / cp , 0.0 , ( sp * sy ) / cp2 , cy / cp , 0.0 , 0.0 , - sy , 0.0 , sy + ( sp2 * sy ) / cp2 , ( cy * sp ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; if ( ddphi ) { ddphi -> resize ( dphi -> size ( ) , RPY_SIZE ) ; Scalar cp3 = cp2 * cp ; ( * ddphi ) << 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - ( cy * ( cp2 - 2.0 ) ) / cp3 , ( sp * sy ) / ( sp2 - 1.0 ) , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * cy * sp ) / cp3 , sy / ( sp2 - 1.0 ) , 0.0 , ( 2.0 * sy - cp2 * sy ) / cp3 , ( cy * sp ) / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * sp * sy ) / cp3 , cy / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , ( sp * sy ) / ( sp2 - 1.0 ) , - cy / cp , 0.0 , 0.0 , sy , 0.0 , sy / ( sp2 - 1.0 ) , - ( cy * sp ) / cp , 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy / cp2 , - ( sp * sy ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } }
template < typename DerivedRPY , typename DerivedE > void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , Eigen :: MatrixBase < DerivedE > & E , typename Gradient < DerivedE , RPY_SIZE , 1 > :: type * dE ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedRPY > , RPY_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedE > , SPACE_DIMENSION , RPY_SIZE ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; using namespace std ; E << cp * cy , - sy , 0.0 , cp * sy , cy , 0.0 , - sp , 0.0 , 1.0 ; if ( dE ) { ( * dE ) << 0.0 , - sp * cy , - cp * sy , 0.0 , - sp * sy , cp * cy , 0.0 , - cp , 0.0 , 0.0 , 0.0 , - cy , 0.0 , 0.0 , - sy , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } }
template < typename Scalar > DLLEXPORT void cylindrical2cartesian ( const Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Matrix < Scalar , 3 , 1 > & cylinder_origin , const Matrix < Scalar , 6 , 1 > & x_cylinder , const Matrix < Scalar , 6 , 1 > & v_cylinder , Matrix < Scalar , 6 , 1 > & x_cartesian , Matrix < Scalar , 6 , 1 > & v_cartesian , Matrix < Scalar , 6 , 6 > & J , Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; double radius = x_cylinder ( 0 ) ; double theta = x_cylinder ( 1 ) ; double c_theta = cos ( theta ) ; double s_theta = sin ( theta ) ; double height = x_cylinder ( 2 ) ; double radius_dot = v_cylinder ( 0 ) ; double theta_dot = v_cylinder ( 1 ) ; double height_dot = v_cylinder ( 2 ) ; Matrix < Scalar , 3 , 1 > x_pos_cartesian ; x_pos_cartesian << radius * c_theta , radius * s_theta , height ; x_pos_cartesian = R_cylinder2cartesian * x_pos_cartesian + cylinder_origin ; Matrix < Scalar , 3 , 1 > v_pos_cartesian ; v_pos_cartesian << radius * - s_theta * theta_dot + radius_dot * c_theta , radius * c_theta * theta_dot + radius_dot * s_theta , height_dot ; v_pos_cartesian = R_cylinder2cartesian * v_pos_cartesian ; Vector3d x_rpy_cylinder = x_cylinder . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_tangent = rpy2rotmat ( x_rpy_cylinder ) ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder_dtheta = dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > R_cylinder = R_tangent2cylinder * R_tangent ; Matrix < Scalar , 3 , 3 > R_cartesian = R_cylinder2cartesian * R_cylinder ; Matrix < Scalar , 3 , 1 > x_rpy_cartesian = rotmat2rpy ( R_cartesian ) ; x_cartesian . block ( 0 , 0 , 3 , 1 ) = x_pos_cartesian ; x_cartesian . block ( 3 , 0 , 3 , 1 ) = x_rpy_cartesian ; v_cartesian . block ( 0 , 0 , 3 , 1 ) = v_pos_cartesian ; v_cartesian . block ( 3 , 0 , 3 , 1 ) = theta_dot * R_cylinder2cartesian . col ( 2 ) + R_cylinder2cartesian * R_tangent2cylinder * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J . block ( 0 , 0 , 3 , 1 ) << c_theta , s_theta , 0 ; J . block ( 0 , 1 , 3 , 1 ) << radius * - s_theta , radius * c_theta , 0 ; J . block ( 0 , 2 , 3 , 1 ) << 0 , 0 , 1 ; J . block ( 0 , 0 , 3 , 3 ) = R_cylinder2cartesian * J . block ( 0 , 0 , 3 , 3 ) ; J . block ( 3 , 1 , 3 , 1 ) = R_cylinder2cartesian . col ( 2 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2cartesian * R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dJ1_dradius = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dradius ( 0 , 1 ) = - s_theta ; dJ1_dradius ( 1 , 1 ) = c_theta ; Matrix < Scalar , 3 , 3 > dJ1_dtheta = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dtheta ( 0 , 0 ) = - s_theta ; dJ1_dtheta ( 0 , 1 ) = - radius * c_theta ; dJ1_dtheta ( 1 , 0 ) = c_theta ; dJ1_dtheta ( 1 , 1 ) = - radius * s_theta ; Jdotv . block ( 0 , 0 , 3 , 1 ) = R_cylinder2cartesian * ( dJ1_dradius * radius_dot + dJ1_dtheta * theta_dot ) * v_cylinder . block ( 0 , 0 , 3 , 1 ) ; Jdotv . block ( 3 , 0 , 3 , 1 ) = R_cylinder2cartesian * dR_tangent2cylinder_dtheta * theta_dot * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; }
template < typename Scalar > DLLEXPORT void cartesian2cylindrical ( const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Eigen :: Matrix < Scalar , 3 , 1 > & cylinder_origin , const Eigen :: Matrix < Scalar , 6 , 1 > & x_cartesian , const Eigen :: Matrix < Scalar , 6 , 1 > & v_cartesian , Eigen :: Matrix < Scalar , 6 , 1 > & x_cylinder , Eigen :: Matrix < Scalar , 6 , 1 > & v_cylinder , Eigen :: Matrix < Scalar , 6 , 6 > & J , Eigen :: Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; Matrix < Scalar , 3 , 3 > R_cartesian2cylinder = R_cylinder2cartesian . transpose ( ) ; Matrix < Scalar , 3 , 1 > x_pos_cylinder = R_cartesian2cylinder * ( x_cartesian . block ( 0 , 0 , 3 , 1 ) - cylinder_origin ) ; Matrix < Scalar , 3 , 1 > v_pos_cylinder = R_cartesian2cylinder * v_cartesian . block ( 0 , 0 , 3 , 1 ) ; double radius = sqrt ( pow ( x_pos_cylinder ( 0 ) , 2 ) + pow ( x_pos_cylinder ( 1 ) , 2 ) ) ; double radius_dot = ( x_pos_cylinder ( 0 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 1 ) * v_pos_cylinder ( 1 ) ) / radius ; double theta = atan2 ( x_pos_cylinder ( 1 ) , x_pos_cylinder ( 0 ) ) ; double radius_square = pow ( radius , 2 ) ; double radius_cubic = pow ( radius , 3 ) ; double radius_quad = pow ( radius , 4 ) ; double theta_dot = ( - x_pos_cylinder ( 1 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 0 ) * v_pos_cylinder ( 1 ) ) / radius_square ; double height = x_pos_cylinder ( 2 ) ; double height_dot = v_pos_cylinder ( 2 ) ; x_cylinder ( 0 ) = radius ; x_cylinder ( 1 ) = theta ; x_cylinder ( 2 ) = height ; v_cylinder ( 0 ) = radius_dot ; v_cylinder ( 1 ) = theta_dot ; v_cylinder ( 2 ) = height_dot ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > R_cylinder2tangent = R_tangent2cylinder . transpose ( ) ; Vector3d x_rpy_cartesian = x_cartesian . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_cartesian = rpy2rotmat ( x_rpy_cartesian ) ; x_cylinder . block ( 3 , 0 , 3 , 1 ) = rotmat2rpy ( R_cylinder2tangent * R_cartesian2cylinder * R_cartesian ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; Matrix < Scalar , 6 , 6 > Jdot = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J ( 0 , 0 ) = x_pos_cylinder ( 0 ) / radius ; J ( 0 , 1 ) = x_pos_cylinder ( 1 ) / radius ; J ( 1 , 0 ) = - x_pos_cylinder ( 1 ) / radius_square ; J ( 1 , 1 ) = x_pos_cylinder ( 0 ) / radius_square ; J ( 2 , 2 ) = 1.0 ; J . block ( 0 , 0 , 3 , 3 ) = J . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; Jdot ( 0 , 0 ) = pow ( x_pos_cylinder ( 1 ) , 2 ) / radius_cubic * v_pos_cylinder ( 0 ) - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 0 , 1 ) = - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 0 ) + pow ( x_pos_cylinder ( 0 ) , 2 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 0 ) = 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 0 ) + ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 1 ) = ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 0 ) - 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot . block ( 0 , 0 , 3 , 3 ) = Jdot . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; v_cylinder . block ( 3 , 0 , 3 , 1 ) = R_cylinder2tangent * R_cartesian2cylinder * v_cartesian . block ( 3 , 0 , 3 , 1 ) - theta_dot * R_cylinder2tangent . col ( 2 ) ; J . block ( 3 , 0 , 3 , 3 ) = R_cylinder2tangent . col ( 2 ) * - J . block ( 1 , 0 , 1 , 3 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2tangent * R_cartesian2cylinder ; Jdot . block ( 3 , 0 , 3 , 3 ) = dR_tangent2cylinder . row ( 2 ) . transpose ( ) * - J . block ( 1 , 0 , 1 , 3 ) * theta_dot + R_cylinder2tangent . col ( 2 ) * - Jdot . block ( 1 , 0 , 1 , 3 ) ; Jdot . block ( 3 , 3 , 3 , 3 ) = dR_tangent2cylinder . transpose ( ) * theta_dot * R_cartesian2cylinder ; Jdotv = Jdot * v_cartesian ; }
DLLEXPORT GradientVar < double , 3 , 1 > quat2expmap ( const Ref < const Vector4d > & q , int gradient_order ) { double t = sqrt ( 1 - q ( 0 ) * q ( 0 ) ) ; bool is_degenerate = ( t * t < std :: numeric_limits < double > :: epsilon ( ) ) ; double s = is_degenerate ? 2.0 : 2.0 * acos ( q ( 0 ) ) / t ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 4 , gradient_order ) ; ret . value ( ) = s * q . tail ( 3 ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix < double , 3 , 4 > :: Zero ( ) ; double dsdq1 = is_degenerate ? 0.0 : ( - 2 * t + 2 * acos ( q ( 0 ) ) * q ( 0 ) ) / pow ( t , 3 ) ; ret . gradient ( ) . value ( ) . col ( 0 ) = q . tail ( 3 ) * dsdq1 ; ret . gradient ( ) . value ( ) . block ( 0 , 1 , 3 , 3 ) = Matrix3d :: Identity ( ) * s ; } else if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ quat2expmap " ) ; } return ret ; }
DLLEXPORT GradientVar < double , 3 , 1 > flipExpmap ( const Ref < const Vector3d > & expmap , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ flipExpmap " ) ; } double expmap_norm = expmap . norm ( ) ; bool is_degenerate = ( expmap_norm < std :: numeric_limits < double > :: epsilon ( ) ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; Matrix3d eye3 = Matrix3d :: Identity ( ) ; if ( is_degenerate ) { ret . value ( ) = expmap ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 ; } } else { ret . value ( ) = expmap - expmap / expmap_norm * 2 * M_PI ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 - ( expmap_norm * expmap_norm * eye3 - expmap * expmap . transpose ( ) ) / pow ( expmap_norm , 3 ) * 2 * M_PI ; } } return ret ; }
DLLEXPORT GradientVar < double , 3 , 1 > unwrap@@ Expmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { auto expmap2_flip = flipExpmap ( expmap2 , gradient_order ) ; double distance1 = ( expmap1 - expmap2 ) . squaredNorm ( ) ; double distance2 = ( expmap1 - expmap2_flip . value ( ) ) . squaredNorm ( ) ; if ( distance1 > distance2 ) { return expmap2_flip ; } else { GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; ret . value ( ) = expmap2 ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } return ret ; } }
void quat2expmapSequence ( const Ref < const Matrix < double , 4 , Dynamic >> & quat , const Ref < const Matrix < double , 4 , Dynamic >> & quat_dot , Ref < Matrix < double , 3 , Dynamic >> expmap , Ref < Matrix < double , 3 , Dynamic >> expmap_dot ) { Dense@@ Index N = quat . cols ( ) ; if ( quat_dot . cols ( ) != N ) { throw std :: runtime_error ( " quat _ dot ▁ must ▁ have ▁ the ▁ same ▁ number ▁ of ▁ colum@@ ns ▁ as ▁ quat ▁ in ▁ quat2expmapSequence " ) ; } expmap . resize ( 3 , N ) ; expmap_dot . resize ( 3 , N ) ; for ( int i = 0 ; i < N ; i ++ ) { auto expmap_grad = quat2expmap ( quat . col ( i ) , 1 ) ; expmap . col ( i ) = expmap_grad . value ( ) ; expmap_dot . col ( i ) = expmap_grad . gradient ( ) . value ( ) * quat_dot . col ( i ) ; if ( i >= 1 ) { auto closest_grad = closestExpmap ( expmap . col ( i - 1 ) , expmap . col ( i ) , 1 ) ; expmap . col ( i ) = closest_grad . value ( ) ; expmap_dot . col ( i ) = closest_grad . gradient ( ) . value ( ) * expmap_dot . col ( i ) ; } } }
DLLEXPORT GradientVar < double , 3 , 1 > closestExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " closestExpmap ▁ only ▁ supports ▁ first ▁ order ▁ gradient " ) ; } double expmap1_norm = expmap1 . norm ( ) ; double expmap2_norm = expmap2 . norm ( ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; if ( expmap2_norm < std :: numeric_limits < double > :: epsilon ( ) ) { if ( expmap1_norm > std :: numeric_limits < double > :: epsilon ( ) ) { Vector3d expmap1_axis = expmap1 / expmap1_norm ; int expmap1_round = static_cast < int > ( expmap1_norm / ( 2 * M_PI ) + 0.5 ) ; ret . value ( ) = expmap1_axis * expmap1_round * 2 * M_PI ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Zero ( ) ; } return ret ; } else { ret . value ( ) = expmap2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } } } else { Vector3d expmap2_axis = expmap2 / expmap2_norm ; Matrix3d dexpmap2_axis_dexpmap2 = ( expmap2_norm * Matrix3d :: Identity ( ) - expmap2 * expmap2 . transpose ( ) / expmap2_norm ) / pow ( expmap2_norm , 2 ) ; double expmap2_closest_k = ( expmap2_axis . transpose ( ) * expmap1 - expmap2_norm ) / ( 2 * M_PI ) ; int expmap2_closest_k1 ; int expmap2_closest_k2 ; if ( expmap2_closest_k > 0 ) { expmap2_closest_k1 = ( int ) expmap2_closest_k ; } else { expmap2_closest_k1 = ( int ) expmap2_closest_k - 1 ; } expmap2_closest_k2 = expmap2_closest_k1 + 1 ; Vector3d expmap2_closest1 = expmap2 + 2 * expmap2_closest_k1 * M_PI * expmap2_axis ; Vector3d expmap2_closest2 = expmap2 + 2 * expmap2_closest_k2 * M_PI * expmap2_axis ; if ( ( expmap2_closest1 - expmap1 ) . norm ( ) < ( expmap2_closest2 - expmap1 ) . norm ( ) ) { ret . value ( ) = expmap2_closest1 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k1 * M_PI ; } return ret ; } else { ret . value ( ) = expmap2_closest2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k2 * M_PI ; } return ret ; } } return ret ; }
