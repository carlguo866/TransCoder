RCInterval :: RCInterval ( RCInterval :: RCReser@@ ved@@ Interval special ) : RCBase ( ) { switch ( special ) { case RCInterval :: now : interval = PR_@@ Interval@@ Now ( ) ; break ; case RCInterval :: no_timeout : interval = PR_INTERVAL_NO_@@ TIME@@ OUT ; break ; case RCInterval :: no_wait : interval = PR_INTERVAL_NO_@@ WAIT ; break ; default : break ; } }
void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_@@ parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetError@@ Response ( ERROR_NO_SU@@ CH_WINDO@@ W , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevel@@ WindowHandle ( ) ; if ( ! :: IsZo@@ omed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_@@ MAXIMI@@ ZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccess@@ Response ( response_value ) ; }
void QmitkDIAppConnectomicsPerspective :: CreateInitial@@ Layout ( berry :: IPageLayout :: Pointer layout ) { std :: string editorArea = layout -> GetEdit@@ orArea ( ) ; layout -> AddStandaloneView ( " org . mitk . views . datamanager " , false , berry :: IPageLayout :: LEFT , 0.3f , editorArea ) ; layout -> AddStandaloneView ( " org . mitk . views . controlvisualizationpropertiesview " , false , berry :: IPageLayout :: BOTTOM , .15f , " org . mitk . views . datamanager " ) ; berry :: IFolder@@ Layout :: Pointer left = layout -> CreateFolder ( " org . mbi . diffusionimaginginternal . leftcontrols " , berry :: IPageLayout :: BOTTOM , 0.1f , " org . mitk . views . controlvisualizationpropertiesview " ) ; layout -> AddStandalone@@ ViewPlace@@ holder ( " org . mitk . views . imagen@@ avigator " , berry :: IPageLayout :: BOTTOM , .4f , " org . mbi . diffusionimaginginternal . leftcontrols " , false ) ; left -> AddView ( " org . mitk . views . connectomicsstatistics " ) ; berry :: IViewLayout :: Pointer lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsstatistics " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsdata " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsdata " ) ; lo -> SetCloseable ( false ) ; }
void AudioFIFO :: consume ( AudioBus * destination , size_t framesToConsume ) { bool isGood = destination && ( framesToConsume <= m_fifoLength ) && ( framesToConsume <= m_framesInFifo ) && ( destination -> length ( ) >= framesToConsume ) ; ASSERT ( isGood ) ; if ( ! isGood ) return ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_readIndex , framesToConsume , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destinationData = destination -> channel ( channelIndex ) -> mutableData ( ) ; const float * sourceData = m_fifoAudioBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_readIndex < m_fifoLength ) && ( m_readIndex + part1Length ) <= m_fifoLength && ( part1Length <= destination -> length ( ) ) && ( part1Length + part2Length ) <= destination -> length ( ) ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destinationData , sourceData + m_readIndex , part1Length * sizeof ( * sourceData ) ) ; if ( part2Length ) memcpy ( destinationData + part1Length , sourceData , part2Length * sizeof ( * sourceData ) ) ; } m_readIndex = updateIndex ( m_readIndex , framesToConsume ) ; ASSERT ( m_framesInFifo >= framesToConsume ) ; m_framesInFifo -= framesToConsume ; }
void AudioFIFO :: push ( const AudioBus * sourceBus ) { bool isGood = sourceBus && ( m_framesInFifo + sourceBus -> length ( ) <= m_fifoLength ) ; if ( ! isGood ) return ; size_t sourceLength = sourceBus -> length ( ) ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_writeIndex , sourceLength , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destination = m_fifoAudioBus -> channel ( channelIndex ) -> mutableData ( ) ; const float * source = sourceBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_writeIndex < m_fifoLength ) && ( m_writeIndex + part1Length ) <= m_fifoLength && part2Length < m_fifoLength && part1Length + part2Length <= sourceLength ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destination + m_writeIndex , source , part1Length * sizeof ( * destination ) ) ; if ( part2Length ) memcpy ( destination , source + part1Length , part2Length * sizeof ( * destination ) ) ; } m_framesInFifo += sourceLength ; ASSERT ( m_framesInFifo <= m_fifoLength ) ; m_writeIndex = updateIndex ( m_writeIndex , sourceLength ) ; }
void AudioFIFO :: findWrapLengths ( size_t index , size_t size , size_t & part1Length , size_t & part2Length ) { ASSERT_WITH_SEC@@ URITY_@@ IMPLICATION ( index < m_fifoLength && size <= m_fifoLength ) ; if ( index < m_fifoLength && size <= m_fifoLength ) { if ( index + size > m_fifoLength ) { part1Length = m_fifoLength - index ; part2Length = size - part1Length ; } else { part1Length = size ; part2Length = 0 ; } } else { part1Length = 0 ; part2Length = 0 ; } }
std :: string CJNISystem :: getProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; }
std :: string CJNISystem :: getProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; }
std :: string CJNISystem :: setProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " setProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; }
std :: string CJNISystem :: clearProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " clearProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; }
int64_t CJNISystem :: nanoTime ( ) { return call_static_method < jlong > ( " java / lang / System " , " nanoTime " , " ( ) J " ) ; }
DWORD MaterialDef :: GetView@@ Data ( const char * viewName ) { DWORD * value = NULL ; viewData . Get ( viewName , & value ) ; return * value ; }
void MaterialDef :: SetView@@ Data ( const char * viewName , DWORD value ) { viewData . Set ( viewName , value ) ; }
void MaterialDefManager :: InitializeMaterialDefLists ( ) { char * buffer ; int length = fileSystem -> ReadFile ( MATERIAL_DEF_FILE , ( void * * ) & buffer ) ; if ( length == - 1 ) { common -> Error ( " Couldn ' t ▁ load ▁ material ▁ editor ▁ definition : ▁ % s " , MATERIAL_DEF_FILE ) ; return ; } idLexer src ; if ( ! src . LoadMemory ( buffer , length , MATERIAL_DEF_FILE ) ) { common -> Error ( " Couldn ' t ▁ parse ▁ % s " , MATERIAL_DEF_FILE ) ; fileSystem -> FreeFile ( buffer ) ; } InitializeMaterialDefList ( & src , " materialprops " , & materialDefs [ MATERIAL_DEF_MATERIAL ] ) ; InitializeMaterialDefList ( & src , " stageprops " , & materialDefs [ MATERIAL_DEF_STAGE ] ) ; InitializeMaterialDefList ( & src , " special@@ mapstageprops " , & materialDefs [ MATERIAL_DEF_SPECI@@ AL_STAGE ] ) ; fileSystem -> FreeFile ( buffer ) ; }
void MaterialDefManager :: InitializeMaterialDefList ( idLexer * src , const char * typeName , MaterialDefList * list ) { idToken token ; src -> Reset ( ) ; src -> SkipUntilString ( typeName ) ; src -> SkipUntilString ( " { " ) ; while ( 1 ) { if ( ! src -> Expect@@ AnyToken ( & token ) ) { return ; } if ( token == " } " ) { break ; } MaterialDef * newProp = new MaterialDef ( ) ; if ( ! token . Icmp ( " TYPE _ GROUP " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ GROUP ; } else if ( ! token . Icmp ( " TYPE _ BOOL " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ BOOL ; } else if ( ! token . Icmp ( " TYPE _ STRING " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_STRING ; } else if ( ! token . Icmp ( " TYPE _ FLOAT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ FLOAT ; } else if ( ! token . Icmp ( " TYPE _ INT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ INT ; } src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> dictName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayInfo = token ; if ( newProp -> type == MaterialDef :: MATERIAL_DEF_TYPE_STRING ) { newProp -> quotes = false ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; if ( token == "1" ) { newProp -> quotes = true ; } } src -> SkipRestOf@@ Line ( ) ; list -> Append ( newProp ) ; } }
void MaterialDefManager :: DestroyMaterialDefLists ( ) { for ( int i = 0 ; i < MATERIAL_DEF_NUM ; i ++ ) { for ( int j = 0 ; j < materialDefs [ i ] . Num ( ) ; j ++ ) { delete materialDefs [ i ] [ j ] ; } materialDefs [ i ] . Clear ( ) ; } }
MaterialDefList * MaterialDefManager :: GetMaterial@@ Defs ( int type ) { if ( type >= 0 && type < MATERIAL_DEF_NUM ) { return & materialDefs [ type ] ; } return NULL ; }
void SimpleExample@@ Widget :: paintEvent ( QPaintEvent * ) { QPainter painter ( this ) ; painter . setPen ( Qt :: blue ) ; painter . setFont ( QFont ( " Arial " , 30 ) ) ; painter . drawText ( rect ( ) , Qt :: AlignCenter , " Qt " ) ; }
void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ; p . begin ( this ) ; p . drawLine ( ... ) ; p . end ( ) ; }
void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ( this ) ; p . drawLine ( ... ) ; }
void QPainter :: rotate ( qreal angle ) { QMatrix matrix ; matrix . rotate ( angle ) ; setWorld@@ Matrix ( matrix , true ) ; }
CEXIAgp :: CEXIAgp ( int index ) { m_slot = index ; m_rom_size = 0 ; LoadRom ( ) ; m_address = 0 ; }
CEXIAgp :: ~ CEXIAgp ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; SaveFileFromEEPROM ( gbapath + " . sav " ) ; }
void CEXIAgp :: CRC8 ( const u8 * data , u32 size ) { for ( u32 it = 0 ; it < size ; it ++ ) { u8 crc = 0 ; m_hash = m_hash ^ data [ it ] ; if ( m_hash & 1 ) crc ^= 0x5e ; if ( m_hash & 2 ) crc ^= 0xbc ; if ( m_hash & 4 ) crc ^= 0x61 ; if ( m_hash & 8 ) crc ^= 0xc2 ; if ( m_hash & 0x10 ) crc ^= 0x9d ; if ( m_hash & 0x20 ) crc ^= 0x23 ; if ( m_hash & 0x40 ) crc ^= 0x46 ; if ( m_hash & 0x80 ) crc ^= 0x8c ; m_hash = crc ; } }
void CEXIAgp :: LoadRom ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; LoadFileToROM ( gbapath + ext ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ rom : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; LoadFileToEEPROM ( gbapath + " . sav " ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ sav : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; }
void CEXIAgp :: LoadFileToROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_rom_size = filesize & 0xFFFFFFFF ; m_rom_mask = ( m_rom_size - 1 ) ; m_rom . resize ( m_rom_size ) ; pStream . ReadBytes ( m_rom . data ( ) , filesize ) ; } else { m_rom . resize ( 0x2000 ) ; } }
void CEXIAgp :: LoadFileToEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_eeprom_size = filesize & 0xFFFFFFFF ; m_eeprom_mask = ( m_eeprom_size - 1 ) ; m_eeprom . resize ( m_eeprom_size ) ; pStream . ReadBytes ( m_eeprom . data ( ) , filesize ) ; if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = 0 ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) NewVal = ( NewVal << 0x8 ) | m_eeprom [ index * 8 + indexb ] ; ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] = NewVal ; } m_eeprom_add_end = ( m_eeprom_size == 512 ? ( 2 + 6 ) : ( 2 + 14 ) ) ; m_eeprom_add_mask = ( m_eeprom_size == 512 ? 0x3F : 0x3FF ) ; m_eeprom_read_mask = ( m_eeprom_size == 512 ? 0x80 : 0x8000 ) ; m_eeprom_status_mask = ( m_rom_size == 0x2000000 ? 0x1FFFF00 : 0x1000000 ) ; } else m_eeprom_status_mask = 0 ; } else { m_eeprom_size = 0 ; m_eeprom . clear ( ) ; } }
void CEXIAgp :: SaveFileFromEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " wb " ) ; if ( pStream ) { if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { std :: vector < u8 > temp_eeprom ( m_eeprom_size ) ; for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) temp_eeprom [ index * 8 + ( 7 - indexb ) ] = ( NewVal >> ( indexb * 8 ) ) & 0xFF ; } pStream . WriteBytes ( temp_eeprom . data ( ) , m_eeprom_size ) ; } else { pStream . WriteBytes ( m_eeprom . data ( ) , m_eeprom_size ) ; } } }
u32 CEXIAgp :: ImmRead ( u32 _uSize ) { u32 uData = 0 ; u8 RomVal1 , RomVal2 , RomVal3 , RomVal4 ; switch ( m_current_cmd ) { case 0xAE000000 : uData = 0x5AA@@ A5517 ; m_current_cmd = 0 ; break ; case 0xAE010000 : uData = ( m_return_pos == 0 ) ? 0x01020@@ 304 : 0xF@@ 0020@@ 304 ; if ( m_return_pos == 1 ) m_current_cmd = 0 ; else m_return_pos = 1 ; break ; case 0xAE020000 : if ( m_eeprom_write_status && ( ( m_rw_offset & m_eeprom_status_mask ) == m_eeprom_status_mask ) && ( m_eeprom_status_mask != 0 ) ) { RomVal1 = 0x1 ; RomVal2 = 0x0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; } CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_current_cmd = 0 ; break ; case 0xAE030000 : if ( _uSize == 1 ) { uData = 0xFF000000 ; m_current_cmd = 0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal3 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal4 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; CRC8 ( & RomVal4 , 1 ) ; CRC8 ( & RomVal3 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( RomVal4 << 8 ) | ( RomVal3 ) ; } break ; case 0xAE040000 : if ( m_eeprom_size == 0 ) RomVal1 = 0xFF ; else RomVal1 = ( m_eeprom . data ( ) ) [ m_eeprom_pos ] ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal1 << 24 ) | ( m_hash << 16 ) ; m_current_cmd = 0 ; break ; case 0xAE0B0000 : RomVal1 = EE_READ_@@ FALSE ; if ( ( m_eeprom_size != 0 ) && ( m_eeprom_pos >= EE_IGNORE_BITS ) && ( ( ( ( u64 * ) m_eeprom . data ( ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] ) >> ( ( EE_DATA_BITS - 1 ) - ( m_eeprom_pos - EE_IGNORE_BITS ) ) ) & 0x1 ) { RomVal1 = EE_READ_@@ TRUE ; } RomVal2 = 0 ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_eeprom_pos ++ ; m_current_cmd = 0 ; break ; case 0xAE070000 : case 0xAE0C0000 : uData = m_hash << 24 ; m_current_cmd = 0 ; break ; default : uData = 0x0 ; m_current_cmd = 0 ; break ; } DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ read ▁ % x " , uData ) ; return uData ; }
void CEXIAgp :: ImmWrite ( u32 _uData , u32 _uSize ) { if ( ( _uSize == 1 ) && ( ( _uData & 0xFF000000 ) == 0 ) ) return ; u8 HashCmd ; u64 Mask ; DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ command ▁ % x " , _uData ) ; switch ( m_current_cmd ) { case 0xAE020000 : case 0xAE030000 : m_rw_offset = ( ( _uData & 0xFFFFFF00 ) >> ( 8 - 1 ) ) ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE040000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE070000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; if ( m_eeprom_size != 0 ) ( ( m_eeprom . data ( ) ) ) [ ( m_eeprom_pos ) ] = ( _uData & 0x0000FF00 ) >> 0x8 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0C0000 : if ( ( m_eeprom_pos < m_eeprom_add_end ) || ( m_eeprom_pos == ( ( m_eeprom_cmd & m_eeprom_read_mask ) ? m_eeprom_add_end : m_eeprom_add_end + EE_DATA_BITS ) ) ) { Mask = ( 1ULL << ( m_eeprom_add_end - std :: min ( m_eeprom_pos , m_eeprom_add_end ) ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_cmd |= Mask ; else m_eeprom_cmd &= ~ Mask ; if ( m_eeprom_pos == m_eeprom_add_end + EE_DATA_BITS ) { if ( m_eeprom_size != 0 ) ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] = m_eeprom_data ; m_eeprom_write_status = true ; } } else { Mask = ( 1ULL << ( m_eeprom_add_end + EE_DATA_BITS - 1 - m_eeprom_pos ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_data |= Mask ; else m_eeprom_data &= ~ Mask ; } m_eeprom_pos ++ ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0B0000 : m_eeprom_write_status = false ; break ; case 0xAE000000 : case 0xAE010000 : case 0xAE090000 : m_eeprom_write_status = false ; case 0xAE0A0000 : m_eeprom_pos = 0 ; default : m_current_cmd = _uData ; m_return_pos = 0 ; m_hash = 0xFF ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; } }
void CEXIAgp :: DoState ( PointerWrap & p ) { p . Do ( m_slot ) ; p . Do ( m_address ) ; p . Do ( m_current_cmd ) ; p . Do ( m_eeprom ) ; p . Do ( m_eeprom_cmd ) ; p . Do ( m_eeprom_data ) ; p . Do ( m_eeprom_mask ) ; p . Do ( m_eeprom_pos ) ; p . Do ( m_eeprom_size ) ; p . Do ( m_eeprom_add_end ) ; p . Do ( m_eeprom_add_mask ) ; p . Do ( m_eeprom_read_mask ) ; p . Do ( m_eeprom_status_mask ) ; p . Do ( m_eeprom_write_status ) ; p . Do ( m_hash ) ; p . Do ( m_position ) ; p . Do ( m_return_pos ) ; p . Do ( m_rom ) ; p . Do ( m_rom_mask ) ; p . Do ( m_rom_size ) ; p . Do ( m_rw_offset ) ; }
void ASResource :: buildAssignmentOperators ( vector < const string * > & assignmentOperators ) { assignmentOperators . push_back ( & AS_ASSIGN ) ; assignmentOperators . push_back ( & AS_PLUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MINUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MULT_ASSIGN ) ; assignmentOperators . push_back ( & AS_DIV_ASSIGN ) ; assignmentOperators . push_back ( & AS_MOD_ASSIGN ) ; assignmentOperators . push_back ( & AS_OR_ASSIGN ) ; assignmentOperators . push_back ( & AS_AND_ASSIGN ) ; assignmentOperators . push_back ( & AS_XOR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_RETURN ) ; }
void ASResource :: buildCastOperators ( vector < const string * > & castOperators ) { castOperators . push_back ( & AS_CONST_CAST ) ; castOperators . push_back ( & AS_DYNAMIC_CAST ) ; castOperators . push_back ( & AS_REINTERPRET_CAST ) ; castOperators . push_back ( & AS_STATIC_CAST ) ; }
void ASResource :: buildHeaders ( vector < const string * > & headers , int fileType , bool beautifier ) { headers . push_back ( & AS_IF ) ; headers . push_back ( & AS_ELSE ) ; headers . push_back ( & AS_FOR ) ; headers . push_back ( & AS_WHILE ) ; headers . push_back ( & AS_DO ) ; headers . push_back ( & AS_SWITCH ) ; headers . push_back ( & AS_TRY ) ; headers . push_back ( & AS_CATCH ) ; if ( beautifier ) { headers . push_back ( & AS_CASE ) ; headers . push_back ( & AS_DEFAULT ) ; headers . push_back ( & AS_CONST ) ; headers . push_back ( & AS_STATIC ) ; headers . push_back ( & AS_EXTERN ) ; headers . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_SYNCHRONIZED ) ; } if ( fileType == SHARP_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_FOREACH ) ; headers . push_back ( & AS_LOCK ) ; headers . push_back ( & AS_UNSAFE ) ; headers . push_back ( & AS_FIXED ) ; headers . push_back ( & AS_GET ) ; headers . push_back ( & AS_SET ) ; headers . push_back ( & AS_ADD ) ; headers . push_back ( & AS_REMOVE ) ; } }
void ASResource :: buildNon@@ AssignmentOperators ( vector < const string * > & nonAssignmentOperators ) { nonAssignmentOperators . push_back ( & AS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_PLUS_PLUS ) ; nonAssignmentOperators . push_back ( & AS_MINUS_MINUS ) ; nonAssignmentOperators . push_back ( & AS_NOT_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_LS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_LS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_ARROW ) ; nonAssignmentOperators . push_back ( & AS_AND ) ; nonAssignmentOperators . push_back ( & AS_OR ) ; }
void ASResource :: buildNon@@ ParenHeaders ( vector < const string * > & nonParenHeaders , int fileType , bool beautifier ) { nonParenHeaders . push_back ( & AS_ELSE ) ; nonParenHeaders . push_back ( & AS_DO ) ; nonParenHeaders . push_back ( & AS_TRY ) ; if ( beautifier ) { nonParenHeaders . push_back ( & AS_CASE ) ; nonParenHeaders . push_back ( & AS_DEFAULT ) ; nonParenHeaders . push_back ( & AS_CONST ) ; nonParenHeaders . push_back ( & AS_STATIC ) ; nonParenHeaders . push_back ( & AS_EXTERN ) ; nonParenHeaders . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; } if ( fileType == SHARP_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; nonParenHeaders . push_back ( & AS_UNSAFE ) ; nonParenHeaders . push_back ( & AS_GET ) ; nonParenHeaders . push_back ( & AS_SET ) ; nonParenHeaders . push_back ( & AS_ADD ) ; nonParenHeaders . push_back ( & AS_REMOVE ) ; } }
void ASResource :: buildOperators ( vector < const string * > & operators ) { operators . push_back ( & AS_PLUS_ASSIGN ) ; operators . push_back ( & AS_MINUS_ASSIGN ) ; operators . push_back ( & AS_MULT_ASSIGN ) ; operators . push_back ( & AS_DIV_ASSIGN ) ; operators . push_back ( & AS_MOD_ASSIGN ) ; operators . push_back ( & AS_OR_ASSIGN ) ; operators . push_back ( & AS_AND_ASSIGN ) ; operators . push_back ( & AS_XOR_ASSIGN ) ; operators . push_back ( & AS_EQUAL ) ; operators . push_back ( & AS_PLUS_PLUS ) ; operators . push_back ( & AS_MINUS_MINUS ) ; operators . push_back ( & AS_NOT_EQUAL ) ; operators . push_back ( & AS_GR_EQUAL ) ; operators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_GR ) ; operators . push_back ( & AS_GR_GR ) ; operators . push_back ( & AS_LS_EQUAL ) ; operators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_LS ) ; operators . push_back ( & AS_LS_LS ) ; operators . push_back ( & AS_ARROW ) ; operators . push_back ( & AS_AND ) ; operators . push_back ( & AS_OR ) ; operators . push_back ( & AS_COLON_COLON ) ; operators . push_back ( & AS_PLUS ) ; operators . push_back ( & AS_MINUS ) ; operators . push_back ( & AS_MULT ) ; operators . push_back ( & AS_DIV ) ; operators . push_back ( & AS_MOD ) ; operators . push_back ( & AS_QUESTION ) ; operators . push_back ( & AS_COLON ) ; operators . push_back ( & AS_ASSIGN ) ; operators . push_back ( & AS_LS ) ; operators . push_back ( & AS_GR ) ; operators . push_back ( & AS_NOT ) ; operators . push_back ( & AS_BIT_OR ) ; operators . push_back ( & AS_BIT_AND ) ; operators . push_back ( & AS_BIT_NOT ) ; operators . push_back ( & AS_BIT_XOR ) ; operators . push_back ( & AS_OPERATOR ) ; operators . push_back ( & AS_COMMA ) ; operators . push_back ( & AS_RETURN ) ; }
void ASResource :: buildPre@@ BlockStatements ( vector < const string * > & preBlockStatements ) { preBlockStatements . push_back ( & AS_CLASS ) ; preBlockStatements . push_back ( & AS_STRUCT ) ; preBlockStatements . push_back ( & AS_UNION ) ; preBlockStatements . push_back ( & AS_INTERFACE ) ; preBlockStatements . push_back ( & AS_NAMESPACE ) ; preBlockStatements . push_back ( & AS_THROWS ) ; preBlockStatements . push_back ( & AS_EXTERN ) ; }
void ASResource :: buildPre@@ CommandHeaders ( vector < const string * > & preCommandHeaders ) { preCommandHeaders . push_back ( & AS_EXTERN ) ; preCommandHeaders . push_back ( & AS_THROWS ) ; preCommandHeaders . push_back ( & AS_CONST ) ; }
void ASResource :: buildPre@@ DefinitionHeaders ( vector < const string * > & preDefinitionHeaders ) { preDefinitionHeaders . push_back ( & AS_CLASS ) ; preDefinitionHeaders . push_back ( & AS_INTERFACE ) ; preDefinitionHeaders . push_back ( & AS_NAMESPACE ) ; preDefinitionHeaders . push_back ( & AS_STRUCT ) ; }
bool LWEProtocolWebSocketSecure :: ProcessRead ( LWSocket & Socket , const char * Buffer , uint32_t BufferLen ) { char Buf [ 256 ] ; char BufB [ 256 ] ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; if ( ! WebSocket ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( * Request . m_SecWebSockKey && Request . m_WebSockVersion == LWEWEBSOCKET_SUPPVER && Request . Upgrade@@ Connection ( ) ) ? 0 : 2 ; if ( ! Error && * Request . m_SecWebSockProto ) { bool ValidProtocol = false ; if ( * m_SubProtocol ) { uint32_t ProtocolLen = ( uint32_t ) strlen ( m_SubProtocol ) ; for ( const char * C = Request . m_SecWebSockProto ; C && ! ValidProtocol ; C = LWText :: FirstToken ( C , ' , ' ) ) { C = LWText :: NextWord ( * C == ' , ' ? C + 1 : C , true ) ; ValidProtocol = LWText :: Compare ( C , m_SubProtocol , ProtocolLen ) ; } } if ( ! ValidProtocol ) Error = 3 ; } if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ Headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; else if ( Error == 3 ) std :: cout << " Error ▁ protocol ▁ asked ▁ for ▁ is ▁ not ▁ supported . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket = m_Allocator . Allocate < LWEWebSocket > ( nullptr , nullptr ) ; WebSocket -> m_Socket = & Socket ; * Buf = ' \0' ; strncat ( Buf , Request . m_SecWebSockKey , sizeof ( Buf ) ) ; strncat ( Buf , LWEWEBSOCKE@@ T_GUID , sizeof ( Buf ) ) ; LWCrypto :: HashSH@@ A1 ( Buf , ( uint32_t ) strlen ( Buf ) , BufB ) ; uint32_t * uBuf = ( uint32_t * ) BufB ; for ( uint32_t i = 0 ; i < 5 ; i ++ ) uBuf [ i ] = ( uBuf [ i ] & 0xFF ) << 24 | ( uBuf [ i ] & 0xFF00 ) << 8 | ( uBuf [ i ] & 0xFF0000 ) >> 8 | ( uBuf [ i ] & 0xFF000000 ) >> 24 ; uint32_t Len = LWCrypto :: Base64Encode ( BufB , 20 , WebSocket -> m_SecKey , sizeof ( WebSocket -> m_SecKey ) ) ; WebSocket -> m_SecKey [ Len ] = ' \0' ; WebSocket -> SetSec@@ Protocols ( m_SubProtocol ) ; WebSocket -> SetHost ( Request . m_Host ) ; WebSocket -> SetPath ( Request . m_Path ) ; WebSocket -> SetOrigin ( Request . m_Origin ) ; WebSocket -> m_Flag |= LWEWebSocket :: CONNECTING_SERVER ; Socket . SetProtocolData ( m_wProtocolID , WebSocket ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_CONNECT ) ; return true ; } if ( ! WebSocket -> IsConnected ( ) ) { if ( WebSocket -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( ( * Request . m_SecWebSockKey && Request . m_Status == LWEHttpRequest :: SwitchingProtocols ) ? 0 : 2 ) ; if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket -> m_Flag = ( WebSocket -> m_Flag & ~ LWEWebSocket :: CONNECTING_CLIENT ) | LWEWebSocket :: CONNECTED_CLIENT ; } return true ; } char IPBuf [ 32 ] ; LWSocket :: MakeAddress ( Socket . GetRemote@@ IP ( ) , IPBuf , sizeof ( IPBuf ) ) ; if ( BufferLen > 100 ) { } LWEWebPacket * OPack ; uint32_t Target ; uint32_t ReservePos ; uint32_t o = 0 ; while ( o != BufferLen ) { uint32_t Res = WebSocket -> m_ActivePacket . Deserialize ( Buffer + o , BufferLen - o , m_Allocator ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ deserializing ▁ data . " << std :: endl ; return false ; } o += Res ; if ( ! WebSocket -> m_ActivePacket . Finished ( ) ) continue ; if ( WebSocket -> m_ActivePacket . m_DataLen != WebSocket -> m_ActivePacket . m_Data@@ Pos ) continue ; if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_CLO@@ SED ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; Socket . MarkClosable ( ) ; return true ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_P@@ ING ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_PONG ) ; continue ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PONG ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; continue ; } WebSocket -> m_ActivePacket . m_WebSocket = WebSocket ; if ( ! m_InPackets . PushStart ( & OPack , Target , ReservePos ) ) return false ; * OPack = std :: move ( WebSocket -> m_ActivePacket ) ; m_InPackets . PushFinished ( Target , ReservePos ) ; } return true ; }
LWProtocol & LWEProtocolWebSocketSecure :: SocketClosed ( LWSocket & Socket , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketClosed ( Socket , Manager ) ; LWEWebSocket * WebSock = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; bool Del = true ; if ( m_WebSocketClosedCallback ) Del = m_WebSocketClosedCallback ( Socket , WebSock , Manager ) ; if ( WebSock ) WebSock -> m_Socket = nullptr ; if ( Del ) LWAllocator :: Destroy ( WebSock ) ; return * this ; }
LWProtocol & LWEProtocolWebSocketSecure :: SocketChanged ( LWSocket & Prev , LWSocket & New , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketChanged ( Prev , New , Manager ) ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Prev . GetProtocolData ( m_wProtocolID ) ; New . SetProtocolData ( m_wProtocolID , Prev . GetProtocolData ( m_wProtocolID ) ) ; if ( WebSocket ) WebSocket -> m_Socket = & New ; if ( m_WebSocketChangedCallback ) m_WebSocketChangedCallback ( Prev , New , WebSocket , Manager ) ; return * this ; }
LWProtocol & LWEProtocolWebSocketSecure :: ProcessTLS@@ Data ( LWSocket & Socket , const char * Data , uint32_t DataLen ) { ProcessRead ( Socket , Data , DataLen ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: ProcessOutPackets ( void ) { char Buffer [ 1024 * 64 ] ; LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; while ( m_OutPackets . PopStart ( & Pack , Target , ReservePos ) ) { LWEWebPacket RPack = std :: move ( * Pack ) ; m_OutPackets . PopFinshed ( Target , ReservePos ) ; LWEWebSocket * Sock = RPack . m_WebSocket ; if ( ! Sock -> IsConnected ( ) && ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) ) { if ( ! Sock -> m_Socket ) return * this ; LWEHttpRequest Request ; Request . SetWebSock@@ Key ( Sock -> m_SecKey ) ; Request . SetWebSock@@ Proto ( m_SubProtocol ) ; Request . m_Flag |= LWEHttpRequest :: Connection@@ Upgrade | LWEHttpRequest :: Upgrade@@ WebSock ; Request . m_Status = Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_SERVER ? LWEHttpRequest :: SwitchingProtocols : 0 ; if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { Request . SetHost ( Sock -> m_Host ) . SetPath ( Sock -> m_Path ) . SetOrigin ( Sock -> m_Origin ) ; Request . m_WebSockVersion = LWEWEBSOCKET_SUPPVER ; } else Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTED_SERVER ; uint32_t Len = Request . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ? m_UserAgent : m_Server ) ; std :: cout << " Sending ▁ headers ! " << std :: endl ; uint32_t Res = Send ( * Sock -> m_Socket , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_SERVER ) Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTING_SERVER ; PushOutPacket ( nullptr , 0 , Sock , LWEWebPacket :: CONTROL_CONNECT ) ; return * this ; } } if ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) continue ; if ( ! Sock -> IsConnected ( ) ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return * this ; } std :: cout << " Sending ▁ data : ▁ " << RPack . GetOp ( ) << " ▁ Len : ▁ " << RPack . m_DataLen << " ▁ Fin : ▁ " << RPack . m_ControlFlag << std :: endl ; LWSocket * rSock = RPack . m_WebSocket -> m_Socket ; if ( ! rSock ) continue ; uint32_t Len = RPack . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ) ; std :: cout << " Serialized : ▁ " << Len << std :: endl ; uint32_t Res = Send ( * rSock , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; } } return * this ; }
LWEWebSocket * LWEProtocolWebSocketSecure :: OpenSocket ( const char * URI , uint32_t ProtocolID , const char * Origin ) { char Host [ 256 ] ; char Path [ 256 ] ; char Protocol [ 256 ] ; uint16_t Port = LWEHttpRequest :: ParseURI ( URI , Host , sizeof ( Host ) , nullptr , Path , sizeof ( Path ) , nullptr , Protocol , sizeof ( Protocol ) , nullptr ) ; LWSocket Sock ; uint32_t Err = LWSocket :: CreateSocket ( Sock , Host , Port , LWSocket :: Tcp , ProtocolID ) ; if ( Err ) { std :: cout << " Error ▁ creating ▁ socket : ▁ " << Err << std :: endl ; return nullptr ; } LWSocket * S = m_Manager -> PushSocket ( Sock ) ; LWEWebSocket * WebSock = m_Allocator . Allocate < LWEWebSocket > ( URI , Origin ) ; WebSock -> m_Flag |= LWEWebSocket :: CONNECTING_CLIENT ; WebSock -> GenerateKey ( m_KeySeed ++ ) ; S -> SetProtocolData ( m_wProtocolID , WebSock ) ; WebSock -> m_Socket = S ; PushOutPacket ( nullptr , 0 , WebSock , LWEWebPacket :: CONTROL_CONNECT ) ; return WebSock ; }
bool LWEProtocolWebSocketSecure :: PushOutPacket ( const char * Buffer , uint32_t BufferLen , LWEWebSocket * Socket , uint32_t ControlFlag ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) return false ; * Pack = LWEWebPacket ( Buffer , BufferLen , m_Allocator , ControlFlag | LWEWebPacket :: CONTROL_FINISHED , Socket ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return true ; }
bool LWEProtocolWebSocketSecure :: GetNextPacket ( LWEWebPacket & Packet ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_InPackets . PopStart ( & Pack , Target , ReservePos ) ) return false ; Packet = std :: move ( * Pack ) ; m_InPackets . PopFinshed ( Target , ReservePos ) ; return true ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetServer ( const char * Server ) { * m_Server = ' \0' ; strncat ( m_Server , Server , sizeof ( m_Server ) ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetUserAgent ( const char * Agent ) { * m_UserAgent = ' \0' ; strncat ( m_UserAgent , Agent , sizeof ( m_UserAgent ) ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetSubProtocol ( const char * SubProtocol ) { * m_SubProtocol = ' \0' ; strncat ( m_SubProtocol , SubProtocol , sizeof ( m_SubProtocol ) ) ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketClosedCallback ( std :: function < bool ( LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketClosedCallback ) { m_WebSocketClosedCallback = WebSocketClosedCallback ; return * this ; }
LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketChangedCallback ( std :: function < void ( LWSocket & , LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketChangedCallback ) { m_WebSocketChangedCallback = WebSocketChangedCallback ; return * this ; }
LWEProtocolWebSocketSecure :: LWEProtocolWebSocketSecure ( uint32_t ProtocolID , uint32_t TLSProtocolID , LWAllocator & Allocator , LWProtocolManager * Manager , const char * CertFile , const char * KeyFile ) : LWEProtocolTLS ( TLSProtocolID , Allocator , CertFile , KeyFile ) , m_wProtocolID ( ProtocolID ) , m_Allocator ( Allocator ) , m_Manager ( Manager ) , m_KeySeed ( 0 ) { * m_Server = * m_UserAgent = * m_SubProtocol = ' \0' ; m_WebSocketClosedCallback = nullptr ; m_WebSocketChangedCallback = nullptr ; }
BtSrc8Iii :: BtSrc8Iii ( RDMatrix * matrix , QObject * parent ) : Switch@@ er ( matrix , parent ) { bt_istate = 0 ; for ( int i = 0 ; i < BTSRC8III_@@ GPIO_@@ PIN@@ S ; i ++ ) { bt_gpi_state [ i ] = false ; bt_gpi_mask [ i ] = false ; } bt_matrix = matrix -> matrix ( ) ; bt_gpis = matrix -> gpis ( ) ; bt_gpos = matrix -> gpos ( ) ; RDTty * tty = new RDTty ( rda -> station ( ) -> name ( ) , matrix -> port ( RDMatrix :: Primar@@ y ) ) ; bt_device = new RDTTYDevice ( ) ; if ( tty -> active ( ) ) { bt_device -> setName ( tty -> port ( ) ) ; bt_device -> setSpeed ( tty -> baudRate ( ) ) ; bt_device -> setWord@@ Length ( tty -> dataBits ( ) ) ; bt_device -> setPar@@ ity ( tty -> parity ( ) ) ; bt_device -> open ( QIODevice :: Unbuffer@@ ed | QIODevice :: ReadWrite ) ; } delete tty ; bt_gpi_oneshot = new RDOneShot ( this ) ; connect ( bt_gpi_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpiOneshotData ( int ) ) ) ; bt_gpo_oneshot = new RDOneShot ( this ) ; connect ( bt_gpo_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpoOneshotData ( int ) ) ) ; QTimer * timer = new QTimer ( this , " poll _ timer " ) ; connect ( timer , SIGNAL ( timeout ( ) ) , this , SLOT ( processStatus ( ) ) ) ; timer -> start ( BTSRC8III_@@ POLL_INTER@@ VAL ) ; }
BtSrc8Iii :: ~ BtSrc8Iii ( ) { delete bt_device ; delete bt_gpi_oneshot ; delete bt_gpo_oneshot ; }
RDMatrix :: Type BtSrc8Iii :: type ( ) { return RDMatrix :: BtSrc8III ; }
unsigned BtSrc8Iii :: gpiQuantity ( ) { return bt_gpis ; }
unsigned BtSrc8Iii :: gpoQuantity ( ) { return bt_gpos ; }
bool BtSrc8Iii :: primaryTtyActive ( ) { return true ; }
bool BtSrc8Iii :: second@@ aryTtyActive ( ) { return false ; }
void BtSrc8Iii :: processCommand ( RDMacro * cmd ) { char str [ 9 ] ; switch ( cmd -> command ( ) ) { case RDMacro :: GO : if ( ( cmd -> argQuantity ( ) != 5 ) || ( ( cmd -> arg ( 1 ) . lower ( ) != " i " ) && ( cmd -> arg ( 1 ) . lower ( ) != " o " ) ) || ( cmd -> arg ( 2 ) . toInt ( ) < 1 ) || ( cmd -> arg ( 3 ) . toInt ( ) > bt_gpos ) || ( cmd -> arg ( 2 ) . toInt ( ) > bt_gpos ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 1 ) . lower ( ) != " i " ) ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 3 ) . toInt ( ) != - 1 ) && ( cmd -> arg ( 1 ) . lower ( ) == " i " ) ) || ( cmd -> arg ( 4 ) . toInt ( ) < 0 ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; return ; } if ( cmd -> arg ( 3 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dF \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; } } else { if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; } return ; } } else { if ( cmd -> arg ( 3 ) . toInt ( ) == - 1 ) { bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; bt_device -> write ( " * 0SPA \n " , 7 ) ; } else { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dL \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; } } else { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; bt_gpi_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dP % 02d \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) , cmd -> arg ( 4 ) . toInt ( ) / 100 + 1 ) ; bt_device -> write ( str , 10 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpo_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } } } } if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( true ) ; emit rmlEcho ( cmd ) ; } break ; default : cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; break ; } }
void BtSrc8Iii :: processStatus ( ) { char buffer [ 256 ] ; int n ; int gpi ; while ( ( n = bt_device -> read ( buffer , 255 ) ) > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { switch ( bt_istate ) { case 0 : if ( buffer [ i ] == ' S ' ) { bt_istate = 1 ; } break ; case 1 : if ( buffer [ i ] == ( BTSRC8III_UNIT_ID + '0' ) ) { bt_istate = 2 ; } else { bt_istate = 0 ; } break ; case 2 : if ( buffer [ i ] == ' P ' ) { bt_istate = 3 ; } else { bt_istate = 0 ; } break ; case 3 : if ( buffer [ i ] == ' , ' ) { bt_istate = 4 ; } else { bt_istate = 0 ; } break ; case 4 : if ( buffer [ i ] == ' A ' ) { bt_istate = 5 ; } else { bt_istate = 0 ; } break ; case 5 : case 7 : case 9 : case 11 : case 13 : case 15 : case 17 : case 19 : if ( buffer [ i ] == ' , ' ) { bt_istate ++ ; } else { bt_istate = 0 ; } break ; case 6 : case 8 : case 10 : case 12 : case 14 : case 16 : case 18 : case 20 : if ( buffer [ i ] == '0' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( bt_gpi_state [ gpi ] && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , false ) ; bt_gpi_state [ gpi ] = false ; } bt_istate ++ ; } if ( buffer [ i ] == '1' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( ( ! bt_gpi_state [ gpi ] ) && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , true ) ; bt_gpi_state [ gpi ] = true ; } bt_istate ++ ; } break ; default : bt_istate = 0 ; } } } }
void BtSrc8Iii :: gpiOneshotData ( int value ) { bt_gpi_mask [ value ] = false ; bt_device -> write ( " * 0SPA " , 5 ) ; }
void BtSrc8Iii :: gpoOneshotData ( int value ) { emit gpoChanged ( bt_matrix , value , false ) ; }
HrPwPlot :: HrPwPlot ( MainWindow * mainWindow , HrPwWindow * hrPwWindow ) : QwtPlot ( hrPwWindow ) , hrPwWindow ( hrPwWindow ) , mainWindow ( mainWindow ) , bg ( NULL ) , delay ( - 1 ) , minHr ( 50 ) , minWatt ( 50 ) , maxWatt ( 500 ) , settings ( GC_SETTINGS_@@ CO , GC_SETTINGS_@@ APP ) , unit ( settings . value ( GC_UNIT ) ) { setCanvas@@ Background ( Qt :: white ) ; canvas ( ) -> setFrame@@ Style ( QFrame :: NoFrame ) ; setXTitle ( ) ; regCurve = new QwtPlotCurve ( " reg " ) ; regCurve -> setPen ( QPen ( GColor ( CPLOT@@ MARKER ) ) ) ; regCurve -> attach ( this ) ; wattsStepCurve = new QwtPlotCurve ( " Power " ) ; wattsStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; wattsStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor wattsColor = QColor ( 200 , 200 , 255 ) ; QColor wattsColor2 = QColor ( 100 , 100 , 255 ) ; wattsStepCurve -> setPen ( QPen ( wattsColor2 ) ) ; wattsStepCurve -> setBrush ( QBrush ( wattsColor ) ) ; wattsStepCurve -> attach ( this ) ; hrStepCurve = new QwtPlotCurve ( " Hr " ) ; hrStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; hrStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor hrColor = QColor ( 255 , 200 , 200 ) ; QColor hrColor2 = QColor ( 255 , 100 , 100 ) ; hrStepCurve -> setPen ( QPen ( hrColor2 ) ) ; hrStepCurve -> setBrush ( QBrush ( hrColor ) ) ; hrStepCurve -> attach ( this ) ; hrCurves . resize ( 36 ) ; for ( int i = 0 ; i < 36 ; ++ i ) { hrCurves [ i ] = new QwtPlotCurve ; hrCurves [ i ] -> attach ( this ) ; } grid = new QwtPlotGrid ( ) ; grid -> enableX ( false ) ; QPen gridPen ; gridPen . setStyle ( Qt :: DotLine ) ; gridPen . setColor ( GColor ( CPLOT@@ GRID ) ) ; grid -> setPen ( gridPen ) ; grid -> attach ( this ) ; r_mrk1 = new QwtPlotMarker ; r_mrk2 = new QwtPlotMarker ; r_mrk1 -> attach ( this ) ; r_mrk2 -> attach ( this ) ; shade@@ _zones = true ; }
void HrPwPlot :: setAxisTitle ( int axis , QString label ) { QFont stGiles ; stGiles . fromString ( appsettings -> value ( this , GC_FONT_CHARTLAB@@ ELS , QFont ( ) . toString ( ) ) . toString ( ) ) ; stGiles . setPointSize ( appsettings -> value ( NULL , GC_FONT_CHARTLAB@@ ELS_SIZE , 8 ) . toInt ( ) ) ; QwtText title ( label ) ; title . setFont ( stGiles ) ; QwtPlot :: setAxisFont ( axis , stGiles ) ; QwtPlot :: setAxisTitle ( axis , title ) ; }
void HrPwPlot :: recalc ( ) { if ( timeArray . count ( ) == 0 ) return ; int rideTimeSecs = ( int ) ceil ( timeArray [ arrayLength - 1 ] ) ; if ( rideTimeSecs > 7 * 24 * 60 * 60 ) { return ; } double totalWatts = 0.0 ; double totalHr = 0.0 ; QList < DataPoint * > list ; int i = 0 ; QVector < double > smoothWatts ( rideTimeSecs + 1 ) ; QVector < double > smoothHr ( rideTimeSecs + 1 ) ; QVector < double > smoothTime ( rideTimeSecs + 1 ) ; int decal = 0 ; int smooth = hrPwWindow -> smooth ; for ( int secs = smooth ; secs <= rideTimeSecs ; ++ secs ) { while ( ( i < arrayLength ) && ( timeArray [ i ] <= secs ) ) { DataPoint * dp = new DataPoint ( timeArray [ i ] , hrArray [ i ] , wattsArray [ i ] , interArray [ i ] ) ; totalWatts += wattsArray [ i ] ; totalHr += hrArray [ i ] ; list . append ( dp ) ; ++ i ; } while ( ! list . empty ( ) && ( list . front ( ) -> time < secs - smooth ) ) { DataPoint * dp = list . front ( ) ; list . removeFirst ( ) ; totalWatts -= dp -> watts ; totalHr -= dp -> hr ; delete dp ; } if ( list . empty ( ) ) { ++ decal ; } else { smoothWatts [ secs - decal ] = totalWatts / list . size ( ) ; smoothHr [ secs - decal ] = totalHr / list . size ( ) ; } smoothTime [ secs ] = secs / 60.0 ; } rideTimeSecs = rideTimeSecs - decal ; smoothWatts . resize ( rideTimeSecs ) ; smoothHr . resize ( rideTimeSecs ) ; QVector < double > clipWatts ( rideTimeSecs ) ; QVector < double > clipHr ( rideTimeSecs ) ; decal = 0 ; for ( int secs = 0 ; secs < rideTimeSecs ; ++ secs ) { if ( smoothHr [ secs ] >= minHr && smoothWatts [ secs ] >= minWatt && smoothWatts [ secs ] < maxWatt ) { clipWatts [ secs - decal ] = smoothWatts [ secs ] ; clipHr [ secs - decal ] = smoothHr [ secs ] ; } else decal ++ ; } rideTimeSecs = rideTimeSecs - decal ; clipWatts . resize ( rideTimeSecs ) ; clipHr . resize ( rideTimeSecs ) ; if ( delay == - 1 ) delay = hrPwWindow -> findDelay ( clipWatts , clipHr , clipWatts . size ( ) ) ; QVector < double > delayWatts ( rideTimeSecs - delay ) ; QVector < double > delayHr ( rideTimeSecs - delay ) ; for ( int secs = 0 ; secs < rideTimeSecs - delay ; ++ secs ) { delayWatts [ secs ] = clipWatts [ secs ] ; delayHr [ secs ] = clipHr [ secs + delay ] ; } rideTimeSecs = rideTimeSecs - delay ; double rpente = hrPwWindow -> pente ( delayWatts , delayHr , delayWatts . size ( ) ) ; double rordonnee = hrPwWindow -> ordonnee ( delayWatts , delayHr , delayWatts . size ( ) ) ; double maxr = hrPwWindow -> corr ( delayWatts , delayHr , delayWatts . size ( ) ) ; int intpoints = 10 ; int nbpoints = ( int ) floor ( rideTimeSecs / intpoints ) ; QVector < double > plotedWatts ( nbpoints ) ; QVector < double > plotedHr ( nbpoints ) ; for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { plotedWatts [ secs ] = clipWatts [ secs * intpoints ] ; plotedHr [ secs ] = clipHr [ secs * intpoints ] ; } int nbpoints2 = ( int ) floor ( nbpoints / 36 ) + 2 ; double * plotedWattsArray [ 36 ] ; double * plotedHrArray [ 36 ] ; for ( int i = 0 ; i < 36 ; ++ i ) { plotedWattsArray [ i ] = new double [ nbpoints2 ] ; plotedHrArray [ i ] = new double [ nbpoints2 ] ; } for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { for ( int i = 0 ; i < 36 ; ++ i ) { if ( secs >= i * nbpoints2 && secs < ( i + 1 ) * nbpoints2 ) { plotedWattsArray [ i ] [ secs - i * nbpoints2 ] = plotedWatts [ secs - i ] ; plotedHrArray [ i ] [ secs - i * nbpoints2 ] = plotedHr [ secs - i ] ; } } } for ( int i = 0 ; i < 36 ; ++ i ) { if ( nbpoints - i * nbpoints2 > 0 ) { hrCurves [ i ] -> setData ( plotedWattsArray [ i ] , plotedHrArray [ i ] , ( nbpoints - i * nbpoints2 < nbpoints2 ? nbpoints - i * nbpoints2 : nbpoints2 ) ) ; hrCurves [ i ] -> setVisible ( true ) ; } else hrCurves [ i ] -> setVisible ( false ) ; } setAxisScale ( xBottom , 0.0 , maxWatt ) ; setYMax ( ) ; refreshZoneLabels ( ) ; QString labelp ; labelp . setNum ( rpente , ' f ' , 3 ) ; QString labelo ; labelo . setNum ( rordonnee , ' f ' , 1 ) ; QString labelr ; labelr . setNum ( maxr , ' f ' , 3 ) ; QString labeldelay ; labeldelay . setNum ( delay ) ; int power150 = ( int ) floor ( ( 150 - rordonnee ) / rpente ) ; QString labelpower150 ; labelpower150 . setNum ( power150 ) ; QwtText textr = QwtText ( labelp + " * x + " + labelo + " ▁ : ▁ R ▁ " + labelr + " ▁ ( " + labeldelay + " ) ▁ \n ▁ Power @ 150 : " + labelpower150 + " W " ) ; textr . setFont ( QFont ( " Helvetica " , 10 , QFont :: Bold ) ) ; textr . setColor ( Qt :: black ) ; r_mrk1 -> setValue ( 0 , 0 ) ; r_mrk1 -> setLineStyle ( QwtPlotMarker :: VLine ) ; r_mrk1 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk1 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennewatt = hrPwWindow -> moyenne ( clipWatts , clipWatts . size ( ) ) ; r_mrk1 -> setValue ( moyennewatt , 0.0 ) ; r_mrk1 -> setLabel ( textr ) ; r_mrk2 -> setValue ( 0 , 0 ) ; r_mrk2 -> setLineStyle ( QwtPlotMarker :: HLine ) ; r_mrk2 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk2 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennehr = hrPwWindow -> moyenne ( clipHr , clipHr . size ( ) ) ; r_mrk2 -> setValue ( 0.0 , moyennehr ) ; addWattStepCurve ( clipWatts , clipWatts . size ( ) ) ; addHrStepCurve ( clipHr , clipHr . size ( ) ) ; addRegLinCurve ( rpente , rordonnee ) ; setJoinLine ( joinLine ) ; rep@@ lot ( ) ; }
void HrPwPlot :: setYMax ( ) { double ymax = 0 ; QString ylabel = " " ; for ( int i = 0 ; i < 36 ; ++ i ) { if ( hrCurves [ i ] -> isVisible ( ) ) { ymax = max ( ymax , hrCurves [ i ] -> maxYValue ( ) ) ; } } setAxisScale ( yLeft , minHr , ymax * 1.2 ) ; setAxisTitle ( yLeft , tr ( " Heart ▁ Rate ( BP@@ M ) " ) ) ; }
void HrPwPlot :: addWattStepCurve ( QVector < double > & finalWatts , int nbpoints ) { QMap < double , double > powerHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( powerHist . contains ( finalWatts [ h ] ) ) powerHist [ finalWatts [ h ] ] += 1 ; else powerHist [ finalWatts [ h ] ] = 1 ; } int maxPower = 500 ; double * array = new double [ maxPower ] ; for ( int i = 0 ; i < maxPower ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > k ( powerHist ) ; while ( k . hasNext ( ) ) { k . next ( ) ; array [ ( int ) round ( k . key ( ) ) ] += k . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxPower - 1 ) / 10 ) ; QVector < double > smoothWattsStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 10 ; int high = low + 10 ; smoothWattsStep [ t ] = low ; smoothTimeStep [ t ] = minHr ; while ( low < high ) { smoothTimeStep [ t ] += array [ low ++ ] / nbpoints * 300 ; } } smoothTimeStep [ t ] = 0.0 ; smoothWattsStep [ t ] = t * 10 ; wattsStepCurve -> setData ( smoothWattsStep . data ( ) , smoothTimeStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addHrStepCurve ( QVector < double > & finalHr , int nbpoints ) { QMap < double , double > hrHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( hrHist . contains ( finalHr [ h ] ) ) hrHist [ finalHr [ h ] ] += 1 ; else hrHist [ finalHr [ h ] ] = 1 ; } int maxHr = 220 ; double * array = new double [ maxHr ] ; for ( int i = 0 ; i < maxHr ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > l ( hrHist ) ; while ( l . hasNext ( ) ) { l . next ( ) ; array [ ( int ) round ( l . key ( ) ) ] += l . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxHr - 1 ) / 2 ) ; QVector < double > smoothHrStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep2 ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 2 ; int high = low + 2 ; smoothHrStep [ t ] = low ; smoothTimeStep2 [ t ] = 0.0 ; while ( low < high ) { smoothTimeStep2 [ t ] += array [ low ++ ] / nbpoints * 500 ; } } smoothTimeStep2 [ t ] = 0.0 ; smoothHrStep [ t ] = t * 2 ; hrStepCurve -> setData ( smoothTimeStep2 . data ( ) , smoothHrStep . data ( ) , nbSteps + 1 ) ; }
void HrPwPlot :: addRegLinCurve ( double rpente , double rordonnee ) { double regWatts [ ] = { 0 , 0 } ; double regHr [ ] = { 0 , 500 } ; regWatts [ 0 ] = regHr [ 0 ] * rpente + rordonnee ; regWatts [ 1 ] = regHr [ 1 ] * rpente + rordonnee ; regCurve -> setData ( regHr , regWatts , 2 ) ; }
void HrPwPlot :: setXTitle ( ) { setAxisTitle ( xBottom , tr ( " Power ▁ ( Watts ) " ) ) ; }
void HrPwPlot :: setData@@ FromRide ( RideItem * _rideItem ) { rideItem = _rideItem ; if ( ! _rideItem || ! _rideItem -> ride ( ) ) return ; RideFile * ride = rideItem -> ride ( ) ; const RideFile@@ DataPresent * dataPresent = ride -> areDataPresent ( ) ; int npoints = ride -> dataPoints ( ) . size ( ) ; if ( dataPresent -> watts && dataPresent -> hr ) { wattsArray . resize ( npoints ) ; hrArray . resize ( npoints ) ; timeArray . resize ( npoints ) ; interArray . resize ( npoints ) ; arrayLength = 0 ; foreach ( const RideFile@@ Point * point , ride -> dataPoints ( ) ) { if ( ! timeArray . empty ( ) ) timeArray [ arrayLength ] = point -> secs ; if ( ! wattsArray . empty ( ) ) wattsArray [ arrayLength ] = max ( 0 , point -> watts ) ; if ( ! hrArray . empty ( ) ) hrArray [ arrayLength ] = max ( 0 , point -> hr ) ; if ( ! interArray . empty ( ) ) interArray [ arrayLength ] = point -> interval ; ++ arrayLength ; } delay = - 1 ; recalc ( ) ; } }
void HrPwPlot :: setJoinLine ( bool value ) { joinLine = value ; for ( int i = 0 ; i < 36 ; ++ i ) { QColor color = QColor ( 255 , 255 , 255 ) ; color . setHsv ( 60 + i * ( 360 / 36 ) , 255 , 255 , 255 ) ; if ( value ) { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: NoSymbol ) ; QPen pen = QPen ( color ) ; pen . setWidth ( 1 ) ; hrCurves [ i ] -> setPen ( pen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Lines ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } else { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: Ellipse ) ; sym . setSize ( 5 ) ; sym . setPen ( QPen ( color ) ) ; sym . setBrush ( QBrush ( color ) ) ; hrCurves [ i ] -> setPen ( Qt :: NoPen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Dots ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } } }
void HrPwPlot :: pointHover ( QwtPlotCurve * curve , int index ) { if ( index >= 0 ) { double yvalue = curve -> sample ( index ) . y ( ) ; double xvalue = curve -> sample ( index ) . x ( ) ; QString text = QString ( " % 1 ▁ % 2 \n % 3 ▁ % 4" ) . arg ( yvalue , 0 , ' f ' , 0 ) . arg ( this -> axisTitle ( curve -> yAxis ( ) ) . text ( ) ) . arg ( xvalue , 0 , ' f ' , 2 ) . arg ( this -> axisTitle ( curve -> xAxis ( ) ) . text ( ) ) ; tooltip -> setText ( text ) ; } else { tooltip -> setText ( " " ) ; } }
wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; }
wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; }
wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindow@@ ToRoot@@ Window ( & x , & y ) ; HIShape@@ GetAs@@ QDRgn ( ( ( wxWindow * ) win ) -> MacGet@@ Visible@@ Region ( true ) . GetWXHRG@@ N ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } }
wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; }
wxWidget@@ Impl@@ Type * wxWidgetImpl :: CreateTextControl ( wxTextCtrl * wxpeer , wxWindow@@ Mac * WXUNUSED ( parent ) , wxWindow@@ ID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extra@@ Style ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; }
wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPassword@@ CFStringTag ; } OSStatus err = CreateEdit@@ UnicodeTextControl ( MAC_@@ WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLine@@ Tag , true ) ; InstallEventHandlers ( ) ; }
void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControl@@ EventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; }
wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; }
void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } }
void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { wxMacWindowClipper c ( GetWXPeer ( ) ) ; { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } }
TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDraw@@ CaretWhenInactiveMask ; frameOptions |= kTXNDoFontSub@@ stitution@@ Mask ; if ( ! ( wxStyle & wxTE_NOHID@@ ESEL ) ) frameOptions |= kTXNDontDraw@@ SelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlways@@ Wrap@@ AtView@@ Edge@@ Mask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; }
void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSub@@ stitution , kTXNWord@@ Wrap@@ StateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetTheme@@ Font ( kTheme@@ SystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontName@@ Attribute , kTXNQDFontName@@ AttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFontSize@@ AttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyle@@ Attribute , kTXNQDFontStyle@@ AttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEcho@@ Mode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEdit@@ CommandUpdating | kTXNSupportFont@@ CommandProcessing | kTXNSupportFont@@ CommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOption@@ Int ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } } if ( checkSpelling ) options |= kTXNSupportSpellCheck@@ CommandProcessing | kTXNSupportSpellCheck@@ CommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } }
void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; }
void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUI@@ Style ; typeAttr [ typeAttrCount ] . size = kTXNATSUI@@ StyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGet@@ ATSU@@ Style ( ) ; typeAttrCount ++ ; } if ( style . HasText@@ Colour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetText@@ Colour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColor@@ Attribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColor@@ AttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_@@ LEFT : align = kTXNFlush@@ Left ; break ; case wxTEXT_ALIGNMENT_@@ CENTRE : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_@@ RIGHT : align = kTXNFlush@@ Right ; break ; case wxTEXT_ALIGNMENT_@@ JUS@@ TIFI@@ ED : align = kTXNFull@@ Just ; break ; default : case wxTEXT_ALIGNMENT_@@ DEFAULT : align = kTXNFlush@@ Default ; break ; } controlTags [ controlAttrCount ] = kTXNJust@@ ificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMargin@@ sTag ; controlData [ controlAttrCount ] . marginsPtr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArray@@ Int & tabarray = style . GetT@@ abs ( ) ; controlTags [ controlAttrCount ] = kTXNTab@@ SettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeft@@ Tab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalc@@ TextLayout ( m_txn ) ; } }
void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNull@@ Colour , font ) , kTXNStartOffset , kTXNEndOffset ) ; }
void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; }
void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; }
void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; }
void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; }
void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; }
void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; wxMacWindowClipper c ( GetWXPeer ( ) ) ; TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; }
void wxMacMLTEControl :: Remove ( long from , long to ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; }
void wxMacMLTEControl :: SetSelection ( long from , long to ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelect@@ All ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; }
void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; wxMacWindowClipper c ( GetWXPeer ( ) ) ; { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; }
void wxMacMLTEControl :: Clear ( ) { wxMacWindowClipper c ( GetWXPeer ( ) ) ; wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; }
void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; }
void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; }
LIBSEDML_CPP_@@ NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamesp@@ aces@@ AndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; }
SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElement@@ Namespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; }
SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; }
int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; }
int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; }
int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } }
int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } }
SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; }
SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; }
SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; }
SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; }
int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; }
SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; }
SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; }
SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; }
SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; }
int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; }
SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; }
SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; }
SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; }
SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; }
int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; }
SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; }
SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; }
SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; }
SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; }
int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; }
SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; }
SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; }
SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; }
SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; }
SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; }
int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; }
SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; }
SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; }
SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; }
SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; }
int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; }
SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; }
SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOf@@ DataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOf@@ Simulations " ) { object = & mSimulations ; } if ( name == " listOf@@ Models " ) { object = & mModels ; } if ( name == " listOf@@ Tasks " ) { object = & mTasks ; } if ( name == " listOf@@ DataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOf@@ Outputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; }
void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; }
void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; }
void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; }
void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; }
SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; }
void AbstractState :: begin@@ BasicBlock ( BasicBlock * basicBlock ) { ASSERT ( ! m_block ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> valuesAtHead . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtTail . numberOfLocals ( ) == basicBlock -> valuesAtTail . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> variablesAtTail . numberOfLocals ( ) ) ; for ( size_t i = 0 ; i < basicBlock -> size ( ) ; i ++ ) forNode ( basicBlock -> at ( i ) ) . clear ( ) ; m_variables = basicBlock -> valuesAtHead ; m_haveStructures = false ; for ( size_t i = 0 ; i < m_variables . numberOfArguments ( ) ; ++ i ) { if ( m_variables . argument ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } for ( size_t i = 0 ; i < m_variables . numberOfLocals ( ) ; ++ i ) { if ( m_variables . local ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } basicBlock -> cfaShouldRevisit = false ; basicBlock -> cfaHasVisited = true ; m_block = basicBlock ; m_isValid = true ; m_foundConstants = false ; m_branchDirection = InvalidBranchDirection ; }
void AbstractState :: initialize ( Graph & graph ) { BasicBlock * root = graph . m_blocks [ 0 ] . get ( ) ; root -> cfaShouldRevisit = true ; root -> cfaHasVisited = false ; root -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { Node * node = root -> variablesAtHead . argument ( i ) ; ASSERT ( node -> op ( ) == SetArgument ) ; if ( ! node -> variableAccessData ( ) -> shouldUnbox@@ IfPossible ( ) ) { root -> valuesAtHead . argument ( i ) . makeTop ( ) ; continue ; } SpeculatedType prediction = node -> variableAccessData ( ) -> prediction ( ) ; if ( isInt32Speculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecInt32 ) ; else if ( isBooleanSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecBoolean ) ; else if ( isCellSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecCell ) ; else root -> valuesAtHead . argument ( i ) . makeTop ( ) ; root -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { Node * node = root -> variablesAtHead . local ( i ) ; if ( node && node -> variableAccessData ( ) -> isCaptured ( ) ) root -> valuesAtHead . local ( i ) . makeTop ( ) ; else root -> valuesAtHead . local ( i ) . clear ( ) ; root -> valuesAtTail . local ( i ) . clear ( ) ; } for ( BlockIndex blockIndex = 1 ; blockIndex < graph . m_blocks . size ( ) ; ++ blockIndex ) { BasicBlock * block = graph . m_blocks [ blockIndex ] . get ( ) ; if ( ! block ) continue ; if ( ! block -> isReachable ) continue ; block -> cfaShouldRevisit = false ; block -> cfaHasVisited = false ; block -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { block -> valuesAtHead . argument ( i ) . clear ( ) ; block -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { block -> valuesAtHead . local ( i ) . clear ( ) ; block -> valuesAtTail . local ( i ) . clear ( ) ; } if ( ! block -> isOSR@@ Target ) continue ; if ( block -> bytecodeBegin != graph . m_osr@@ EntryBytecodeIndex ) continue ; for ( size_t i = 0 ; i < graph . m_mustHandleValues . size ( ) ; ++ i ) { AbstractValue value ; value . setMo@@ stSpec@@ ific ( graph . m_mustHandleValues [ i ] ) ; int operand = graph . m_mustHandleValues . operandForIndex ( i ) ; block -> valuesAtHead . operand ( operand ) . merge ( value ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ Initializing ▁ Block ▁ # % u , ▁ operand ▁ r % d , ▁ to ▁ " , blockIndex , operand ) ; block -> valuesAtHead . operand ( operand ) . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; } block -> cfaShouldRevisit = true ; } }
bool AbstractState :: endBasicBlock ( Merge@@ Mode mergeMode ) { ASSERT ( m_block ) ; BasicBlock * block = m_block ; block -> cfaFoundConstants = m_foundConstants ; block -> cfaDid@@ Finish = m_isValid ; block -> cfaBranchDirection = m_branchDirection ; if ( ! m_isValid ) { reset ( ) ; return false ; } bool changed = false ; if ( mergeMode != DontMerge || ! ASSERT_DISABLED ) { for ( size_t argument = 0 ; argument < block -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ argument ▁ % zu . \n " , argument ) ; AbstractValue & destination = block -> valuesAtTail . argument ( argument ) ; changed |= mergeStateAtTail ( destination , m_variables . argument ( argument ) , block -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < block -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ local ▁ % zu . \n " , local ) ; AbstractValue & destination = block -> valuesAtTail . local ( local ) ; changed |= mergeStateAtTail ( destination , m_variables . local ( local ) , block -> variablesAtTail . local ( local ) ) ; } } ASSERT ( mergeMode != DontMerge || ! changed ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Branch ▁ direction ▁ = ▁ % s \n " , branchDire@@ ctionToString ( m_branchDirection ) ) ; reset ( ) ; if ( mergeMode != Merge@@ ToSuccessors ) return changed ; return mergeToSuccessors ( m_graph , block ) ; }
void AbstractState :: reset ( ) { m_block = 0 ; m_isValid = false ; m_branchDirection = InvalidBranchDirection ; }
AbstractState :: BooleanResult AbstractState :: booleanResult ( Node * node , AbstractValue & value ) { JSValue childConst = value . value ( ) ; if ( childConst ) { if ( childConst . toBoolean ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> globalExec ( ) ) ) return DefinitelyTrue ; return DefinitelyFalse ; } if ( isCellSpeculation ( value . m_type ) && value . m_currentKnownStructure . hasSingleton ( ) ) { Structure * structure = value . m_currentKnownStructure . singleton ( ) ; if ( ! structure -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) && structure -> typeInfo ( ) . type ( ) != StringType ) return DefinitelyTrue ; } return UnknownBooleanResult ; }
bool AbstractState :: startExecuting ( Node * node ) { ASSERT ( m_block ) ; ASSERT ( m_isValid ) ; m_didClobber = false ; node -> setCanExit ( false ) ; if ( ! node -> shouldGenerate ( ) ) return false ; return true ; }
bool AbstractState :: startExecuting ( unsigned indexInBlock ) { return startExecuting ( m_block -> at ( indexInBlock ) ) ; }
void AbstractState :: executeEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , filterEdge@@ ByUse ) ; }
void AbstractState :: executeEdges ( unsigned indexInBlock ) { executeEdges ( m_block -> at ( indexInBlock ) ) ; }
void AbstractState :: verifyEdge ( Node * , Edge edge ) { RELEASE_ASSERT ( ! ( forNode ( edge ) . m_type & ~ typeFilter@@ For ( edge . useKind ( ) ) ) ) ; }
void AbstractState :: verifyEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , verifyEdge ) ; }
bool AbstractState :: executeEffects ( unsigned indexInBlock , Node * node ) { if ( ! ASSERT_DISABLED ) verifyEdges ( node ) ; switch ( node -> op ( ) ) { case JSConstant : case Wea@@ kJSConstant : case Phantom@@ Arguments : { forNode ( node ) . set ( m_graph . valueOfJSConstant ( node ) ) ; break ; } case Identity : { forNode ( node ) = forNode ( node -> child1 ( ) ) ; break ; } case GetLocal : { VariableAccessData * variableAccessData = node -> variableAccessData ( ) ; if ( variableAccessData -> prediction ( ) == SpecNone ) { m_isValid = false ; break ; } AbstractValue value = m_variables . operand ( variableAccessData -> local ( ) ) ; if ( ! variableAccessData -> isCaptured ( ) ) { if ( value . isClear ( ) ) node -> setCanExit ( true ) ; } if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case GetLocal@@ Unlinked : { AbstractValue value = m_variables . operand ( node -> unlink@@ edLocal ( ) ) ; if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case SetLocal : { m_variables . operand ( node -> local ( ) ) = forNode ( node -> child1 ( ) ) ; break ; } case MovHintAndCheck : { break ; } case MovHint : case Zo@@ mbie@@ Hint : { RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } case SetArgument : ASSERT ( ! m_block -> valuesAtHead . operand ( node -> local ( ) ) . isClear ( ) ) ; break ; case BitAnd : case BitOr : case BitXor : case BitRShift : case BitLShift : case BitURShift : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isInt32 ( ) && right . isInt32 ( ) ) { int32_t a = left . asInt32 ( ) ; int32_t b = right . asInt32 ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case BitAnd : constantWasSet = trySetConstant ( node , JSValue ( a & b ) ) ; break ; case BitOr : constantWasSet = trySetConstant ( node , JSValue ( a | b ) ) ; break ; case BitXor : constantWasSet = trySetConstant ( node , JSValue ( a ^ b ) ) ; break ; case BitRShift : constantWasSet = trySetConstant ( node , JSValue ( a >> static_cast < uint32_t > ( b ) ) ) ; break ; case BitLShift : constantWasSet = trySetConstant ( node , JSValue ( a << static_cast < uint32_t > ( b ) ) ) ; break ; case BitURShift : constantWasSet = trySetConstant ( node , JSValue ( static_cast < uint32_t > ( a ) >> static_cast < uint32_t > ( b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case UInt32ToNumber : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { ASSERT ( child . isInt32 ( ) ) ; if ( trySetConstant ( node , JSValue ( child . asUInt32 ( ) ) ) ) { m_foundConstants = true ; break ; } } if ( ! node -> canSpeculateInteger ( ) ) forNode ( node ) . set ( SpecDouble ) ; else { forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; } break ; } case DoubleAsInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { double asDouble = child . asNumber ( ) ; int32_t asInt = JSC :: toInt32 ( asDouble ) ; if ( bitwise_cast < int64_t > ( static_cast < double > ( asInt ) ) == bitwise_cast < int64_t > ( asDouble ) && trySetConstant ( node , JSValue ( asInt ) ) ) { m_foundConstants = true ; break ; } } node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; } case ValueToInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { bool constantWasSet ; if ( child . isInt32 ( ) ) constantWasSet = trySetConstant ( node , child ) ; else constantWasSet = trySetConstant ( node , JSValue ( JSC :: toInt32 ( child . asDouble ( ) ) ) ) ; if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case Int32ToDouble : case Forward@@ Int32ToDouble : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( JSValue :: Encode@@ AsDouble , child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } if ( isInt32Speculation ( forNode ( node -> child1 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; } case ValueAdd : case ArithAdd : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) + right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) && isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT ( node -> op ( ) == ValueAdd ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecString | SpecInt32 | SpecNumber ) ; break ; } break ; } case MakeRope : { forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case ArithSub : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) - right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithNeg@@ ate : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( - child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithMul : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) * right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) || ! nodeCan@@ IgnoreNeg@@ ativeZero ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) || isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithIMul : { forNode ( node ) . set ( SpecInt32 ) ; break ; } case ArithDiv : case ArithMin : case ArithMax : case ArithMod : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) ) { double a = left . asNumber ( ) ; double b = right . asNumber ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case ArithDiv : constantWasSet = trySetConstant ( node , JSValue ( a / b ) ) ; break ; case ArithMin : constantWasSet = trySetConstant ( node , JSValue ( a < b ? a : ( b <= a ? b : a + b ) ) ) ; break ; case ArithMax : constantWasSet = trySetConstant ( node , JSValue ( a > b ? a : ( b >= a ? b : a + b ) ) ) ; break ; case ArithMod : constantWasSet = trySetConstant ( node , JSValue ( fmod ( a , b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithAbs : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( fabs ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithSqrt : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( sqrt ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecDouble ) ; break ; } case Logical@@ Not : { bool didSetConstant = false ; switch ( booleanResult ( node , forNode ( node -> child1 ( ) ) ) ) { case DefinitelyTrue : didSetConstant = trySetConstant ( node , jsBoolean ( false ) ) ; break ; case DefinitelyFalse : didSetConstant = trySetConstant ( node , jsBoolean ( true ) ) ; break ; default : break ; } if ( didSetConstant ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Boolean@@ Use : case Int32Use : case NumberUse : case UntypedUse : break ; case ObjectOr@@ OtherUse : node -> setCanExit ( true ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( SpecBoolean ) ; break ; } case IsUndefined : case IsBoolean : case IsNumber : case IsString : case IsObject : case IsFunction : { node -> setCanExit ( node -> op ( ) == IsUndefined && m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child ) { bool constantWasSet ; switch ( node -> op ( ) ) { case IsUndefined : if ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? false : child . isUndefined ( ) ) ) ; } else { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? child . asCell ( ) -> structure ( ) -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) : child . isUndefined ( ) ) ) ; } break ; case IsBoolean : constantWasSet = trySetConstant ( node , jsBoolean ( child . isBoolean ( ) ) ) ; break ; case IsNumber : constantWasSet = trySetConstant ( node , jsBoolean ( child . isNumber ( ) ) ) ; break ; case IsString : constantWasSet = trySetConstant ( node , jsBoolean ( isJS@@ String ( child ) ) ) ; break ; case IsObject : if ( child . isNull ( ) || ! child . isObject ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isNull ( ) ) ) ; break ; } default : constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecBoolean ) ; break ; } case TypeOf : { VM * vm = m_codeBlock -> vm ( ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; AbstractValue & abstractChild = forNode ( node -> child1 ( ) ) ; if ( child ) { JSValue typeString = jsTypeStringFor@@ Value ( * vm , m_codeBlock -> globalObjectFor ( node -> codeOrigin ) , child ) ; if ( trySetConstant ( node , typeString ) ) { m_foundConstants = true ; break ; } } else if ( isNumberSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . numberString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecNumber ) ; m_foundConstants = true ; break ; } } else if ( isString@@ Speculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . stringString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; m_foundConstants = true ; break ; } } else if ( isFinal@@ ObjectSpeculation ( abstractChild . m_type ) || isArray@@ Speculation ( abstractChild . m_type ) || isArguments@@ Speculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . objectString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFinalObject | SpecArray | SpecArguments ) ; m_foundConstants = true ; break ; } } else if ( isFunction@@ Speculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . functionString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFunction ) ; m_foundConstants = true ; break ; } } else if ( isBooleanSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . booleanString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecBoolean ) ; m_foundConstants = true ; break ; } } switch ( node -> child1 ( ) . useKind ( ) ) { case StringUse : case CellUse : node -> setCanExit ( true ) ; break ; case UntypedUse : break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case CompareLess : case CompareLessEq : case CompareGreater : case CompareGreaterEq : case CompareEq : case CompareEqConstant : { bool constantWasSet = false ; JSValue leftConst = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue rightConst = forNode ( node -> child2 ( ) ) . value ( ) ; if ( leftConst && rightConst && leftConst . isNumber ( ) && rightConst . isNumber ( ) ) { double a = leftConst . asNumber ( ) ; double b = rightConst . asNumber ( ) ; switch ( node -> op ( ) ) { case CompareLess : constantWasSet = trySetConstant ( node , jsBoolean ( a < b ) ) ; break ; case CompareLessEq : constantWasSet = trySetConstant ( node , jsBoolean ( a <= b ) ) ; break ; case CompareGreater : constantWasSet = trySetConstant ( node , jsBoolean ( a > b ) ) ; break ; case CompareGreaterEq : constantWasSet = trySetConstant ( node , jsBoolean ( a >= b ) ) ; break ; case CompareEq : constantWasSet = trySetConstant ( node , jsBoolean ( a == b ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } } if ( ! constantWasSet && ( node -> op ( ) == CompareEqConstant || node -> op ( ) == CompareEq ) ) { SpeculatedType leftType = forNode ( node -> child1 ( ) ) . m_type ; SpeculatedType rightType = forNode ( node -> child2 ( ) ) . m_type ; if ( ( isInt32Speculation ( leftType ) && isOtherSpeculation ( rightType ) ) || ( isOtherSpeculation ( leftType ) && isInt32Speculation ( rightType ) ) ) constantWasSet = trySetConstant ( node , jsBoolean ( false ) ) ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case CompareStrict@@ Eq : case CompareStrict@@ EqConstant : { Node * leftNode = node -> child1 ( ) . node ( ) ; Node * rightNode = node -> child2 ( ) . node ( ) ; JSValue left = forNode ( leftNode ) . value ( ) ; JSValue right = forNode ( rightNode ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , jsBoolean ( left . asNumber ( ) == right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case StringChar@@ CodeAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case StringFromChar@@ Code : forNode ( node ) . set ( SpecString ) ; break ; case StringChar@@ At : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case GetByVal : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: SelectUsing@@ Predictions : case Array :: Unprofile@@ d : case Array :: Undec@@ ided : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: String : forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case Array :: Arguments : forNode ( node ) . makeTop ( ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else if ( node -> arrayMode ( ) . isSane@@ Chain ( ) ) forNode ( node ) . set ( SpecDouble ) ; else forNode ( node ) . set ( SpecDoubleReal ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: Int8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int32Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8ClampedArray : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint32Array : if ( node -> shouldSpeculateInteger ( ) ) forNode ( node ) . set ( SpecInt32 ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float32Array : forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float64Array : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case PutByVal : case PutByVal@@ Alias : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . modeForPut ( ) . type ( ) ) { case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . may@@ StoreToHo@@ le ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : break ; } break ; } case ArrayPush : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecNumber ) ; break ; case ArrayPop : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case RegExp@@ Exec : forNode ( node ) . makeTop ( ) ; break ; case RegExp@@ Test : forNode ( node ) . set ( SpecBoolean ) ; break ; case Jump : break ; case Branch : { Node * child = node -> child1 ( ) . node ( ) ; BooleanResult result = booleanResult ( node , forNode ( child ) ) ; if ( result == DefinitelyTrue ) { m_branchDirection = TakeTrue ; break ; } if ( result == DefinitelyFalse ) { m_branchDirection = TakeFalse ; break ; } node -> setCanExit ( true ) ; m_branchDirection = TakeBoth ; break ; } case Return : m_isValid = false ; break ; case Throw : case ThrowReferenceError : m_isValid = false ; node -> setCanExit ( true ) ; break ; case ToPrimitive : { JSValue childConst = forNode ( node -> child1 ( ) ) . value ( ) ; if ( childConst && childConst . isNumber ( ) && trySetConstant ( node , childConst ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> child1 ( ) . useKind ( ) == UntypedUse ) ; AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; SpeculatedType type = source . m_type ; if ( type & ~ ( SpecNumber | SpecString | SpecBoolean ) ) { type &= ( SpecNumber | SpecString | SpecBoolean ) ; type |= SpecString ; } destination . set ( type ) ; break ; } case ToString : { switch ( node -> child1 ( ) . useKind ( ) ) { case StringObjectUse : forNode ( node -> child1 ( ) ) . filter ( m_graph . globalObjectFor ( node -> codeOrigin ) -> stringObjectStructure ( ) ) ; node -> setCanExit ( true ) ; break ; case StringOr@@ StringObjectUse : node -> setCanExit ( true ) ; break ; case CellUse : case UntypedUse : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case NewStringObject : { ASSERT ( node -> structure ( ) -> classInfo ( ) == & StringObject :: s_info ) ; forNode ( node ) . set ( node -> structure ( ) ) ; break ; } case NewArray : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArray@@ Buffer : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArray@@ WithSize : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecArray ) ; m_haveStructures = true ; break ; case NewReg@@ exp : forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> regExpStructure ( ) ) ; m_haveStructures = true ; break ; case ConvertThis : { AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; destination = source ; destination . merge ( SpecObjectOther ) ; break ; } case CreateThis : { forNode ( node ) . set ( SpecFinalObject ) ; break ; } case AllocationProfile@@ Watchpoint : node -> setCanExit ( true ) ; break ; case NewObject : forNode ( node ) . set ( node -> structure ( ) ) ; m_haveStructures = true ; break ; case CreateActivation : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> activationStructure ( ) ) ; m_haveStructures = true ; break ; case CreateArguments : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> arguments@@ Structure ( ) ) ; m_haveStructures = true ; break ; case TearOff@@ Activation : case TearOff@@ Arguments : break ; case CheckArguments@@ NotCreated : if ( isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) m_foundConstants = true ; else node -> setCanExit ( true ) ; break ; case GetMyArguments@@ Length : if ( node -> codeOrigin . inlineCallFrame ) forNode ( node ) . set ( jsNumber ( node -> codeOrigin . inlineCallFrame -> arguments . size ( ) - 1 ) ) ; else forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( ! isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) ; break ; case GetMyArguments@@ LengthSafe : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgument@@ ByVal : node -> setCanExit ( true ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgument@@ ByVal@@ Safe : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case NewFunction : { AbstractValue & value = forNode ( node ) ; value = forNode ( node -> child1 ( ) ) ; if ( ! ( value . m_type & SpecEmpty ) ) { m_foundConstants = true ; break ; } value . set ( ( value . m_type & ~ SpecEmpty ) | SpecFunction ) ; break ; } case NewFunction@@ Expression : case NewFunction@@ NoCheck : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> functionStructure ( ) ) ; break ; case GetCallee : forNode ( node ) . set ( SpecFunction ) ; break ; case SetCallee : case SetMy@@ Scope : break ; case GetScope : case GetMy@@ Scope : case SkipTop@@ Scope : forNode ( node ) . set ( SpecCellOther ) ; break ; case SkipScope : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && trySetConstant ( node , JSValue ( jsCast < JSScope * > ( child . asCell ( ) ) -> next ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecCellOther ) ; break ; } case GetScop@@ eRegister@@ s : forNode ( node ) . clear ( ) ; break ; case GetScopedVar : forNode ( node ) . makeTop ( ) ; break ; case PutScopedVar : clobberCapturedVars ( node -> codeOrigin ) ; break ; case GetById : case GetById@@ Flush : node -> setCanExit ( true ) ; if ( ! node -> prediction ( ) ) { m_isValid = false ; break ; } if ( isCellSpeculation ( node -> child1 ( ) -> prediction ( ) ) ) { if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { GetByIdStatus status = GetByIdStatus :: computeFor ( m_graph . m_vm , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) ) ; if ( status . isSimple ( ) ) { ASSERT ( status . structureSet ( ) . size ( ) == 1 ) ; ASSERT ( status . chain ( ) . isEmpty ( ) ) ; if ( status . specificValue ( ) ) forNode ( node ) . set ( status . specificValue ( ) ) ; else forNode ( node ) . makeTop ( ) ; forNode ( node -> child1 ( ) ) . filter ( status . structureSet ( ) ) ; m_foundConstants = true ; break ; } } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetArray@@ Length : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case CheckExecut@@ able : { node -> setCanExit ( true ) ; break ; } case CheckStructure : case Forward@@ CheckStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( ! ( value . m_type & ~ SpecCell ) ) ; StructureSet & set = node -> structureSet ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; if ( ! value . m_currentKnownStructure . isSubsetOf ( set ) ) node -> setCanExit ( true ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case StructureTransitionWatchpoint : case Forward@@ StructureTransitionWatchpoint : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( value . m_futurePossibleStructure . isSubsetOf ( StructureSet ( node -> structure ( ) ) ) ) ; value . filter ( node -> structure ( ) ) ; m_haveStructures = true ; node -> setCanExit ( true ) ; break ; } case PutStructure : case Phantom@@ PutStructure : if ( ! forNode ( node -> child1 ( ) ) . m_currentKnownStructure . isClear ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( node -> structure@@ TransitionData ( ) . newStructure ) ; m_haveStructures = true ; } break ; case GetBut@@ terfly : case Allocate@@ PropertyStorage : case Reallocate@@ PropertyStorage : forNode ( node ) . clear ( ) ; break ; case CheckArray : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: String : forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; break ; case Array :: Int32 : case Array :: Double : case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : break ; case Array :: Arguments : forNode ( node -> child1 ( ) ) . filter ( SpecArguments ) ; break ; case Array :: Int8Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt8Array ) ; break ; case Array :: Int16Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt16Array ) ; break ; case Array :: Int32Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt32Array ) ; break ; case Array :: Uint8Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint@@ 8Array ) ; break ; case Array :: Uint8ClampedArray : forNode ( node -> child1 ( ) ) . filter ( SpecUint@@ 8ClampedArray ) ; break ; case Array :: Uint16Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint16Array ) ; break ; case Array :: Uint32Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint@@ 32Array ) ; break ; case Array :: Float32Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat32Array ) ; break ; case Array :: Float64Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat64Array ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case Arrayify : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> arrayMode ( ) . conversion ( ) == Array :: Convert || node -> arrayMode ( ) . conversion ( ) == Array :: Rage@@ Convert ) ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case ArrayifyToStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; StructureSet set = node -> structure ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case GetIndexed@@ PropertyStorage : { forNode ( node ) . clear ( ) ; break ; } case GetByOffset : { forNode ( node ) . makeTop ( ) ; break ; } case PutByOffset : { break ; } case CheckFunction : { JSValue value = forNode ( node -> child1 ( ) ) . value ( ) ; if ( value == node -> function ( ) ) { m_foundConstants = true ; ASSERT ( value ) ; break ; } node -> setCanExit ( true ) ; forNode ( node -> child1 ( ) ) . filterByValue ( node -> function ( ) ) ; break ; } case PutById : case PutByIdDirect : node -> setCanExit ( true ) ; if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { PutByIdStatus status = PutByIdStatus :: computeFor ( m_graph . m_vm , m_graph . globalObjectFor ( node -> codeOrigin ) , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) , node -> op ( ) == PutByIdDirect ) ; if ( status . isSimple@@ Replace ( ) ) { forNode ( node -> child1 ( ) ) . filter ( structure ) ; m_foundConstants = true ; break ; } if ( status . isSimple@@ Transition ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( status . newStructure ( ) ) ; m_haveStructures = true ; m_foundConstants = true ; break ; } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case GetGlobal@@ Var : forNode ( node ) . makeTop ( ) ; break ; case GlobalVar@@ Watchpoint : node -> setCanExit ( true ) ; break ; case PutGlobalVar : case PutGlobalVar@@ Check : break ; case CheckHasInstance : node -> setCanExit ( true ) ; break ; case InstanceOf : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecBoolean ) ; break ; case Phi : case Flush : case PhantomLocal : case Brea@@ kpoint : break ; case Call : case Construct : case Resolve : case Resolve@@ Base : case Resolve@@ BaseStrict@@ Put : case Resolve@@ Global : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GarbageValue : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Force@@ OSR@@ Exit : node -> setCanExit ( true ) ; m_isValid = false ; break ; case CheckWatch@@ dog@@ Timer : node -> setCanExit ( true ) ; break ; case Phanto@@ m : case Inline@@ Start : case Nop : case CountExecution : break ; case LastNodeType : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } return m_isValid ; }
bool AbstractState :: executeEffects ( unsigned indexInBlock ) { return executeEffects ( indexInBlock , m_block -> at ( indexInBlock ) ) ; }
bool AbstractState :: execute ( unsigned indexInBlock ) { Node * node = m_block -> at ( indexInBlock ) ; if ( ! startExecuting ( node ) ) return true ; executeEdges ( node ) ; return executeEffects ( indexInBlock , node ) ; }
inline void AbstractState :: clobberWorld ( const CodeOrigin & codeOrigin , unsigned indexInBlock ) { clobberCapturedVars ( codeOrigin ) ; clobberStructures ( indexInBlock ) ; }
inline void AbstractState :: clobberCapturedVars ( const CodeOrigin & codeOrigin ) { if ( codeOrigin . inlineCallFrame ) { const BitVector & capturedVars = codeOrigin . inlineCallFrame -> capturedVars ; for ( size_t i = capturedVars . size ( ) ; i -- ; ) { if ( ! capturedVars . quick@@ Get ( i ) ) continue ; m_variables . local ( i ) . makeTop ( ) ; } } else { for ( size_t i = m_codeBlock -> m_num@@ Vars ; i -- ; ) { if ( m_codeBlock -> isCaptured ( i ) ) m_variables . local ( i ) . makeTop ( ) ; } } for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) { if ( m_codeBlock -> isCaptured ( argument@@ ToOperand ( i ) ) ) m_variables . argument ( i ) . makeTop ( ) ; } }
inline void AbstractState :: clobberStructures ( unsigned indexInBlock ) { if ( ! m_haveStructures ) return ; for ( size_t i = indexInBlock + 1 ; i -- ; ) forNode ( m_block -> at ( i ) ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) m_variables . argument ( i ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfLocals ( ) ; i -- ; ) m_variables . local ( i ) . clobberStructures ( ) ; m_haveStructures = false ; m_didClobber = true ; }
inline bool AbstractState :: mergeStateAtTail ( AbstractValue & destination , AbstractValue & inVariable , Node * node ) { if ( ! node ) return false ; AbstractValue source ; if ( node -> variableAccessData ( ) -> isCaptured ( ) ) { source = inVariable ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ last ▁ access ▁ due ▁ to ▁ captured ▁ variable . \n " ) ; } else { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ It ' s ▁ live , ▁ node ▁ @ % u . \n " , node -> index ( ) ) ; switch ( node -> op ( ) ) { case Phi : case SetArgument : case PhantomLocal : case Flush : source = inVariable ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ head ▁ to ▁ tail . \n " ) ; break ; case GetLocal : source = forNode ( node ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Refin@@ ing ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; break ; case SetLocal : if ( node -> variableAccessData ( ) -> shouldUse@@ DoubleFormat ( ) ) { source . set ( SpecDouble ) ; } else source = forNode ( node -> child1 ( ) ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Setting ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } } if ( destination == source ) { ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Not ▁ changed ! \n " ) ; return false ; } destination = source ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Changed ! \n " ) ; return true ; }
inline bool AbstractState :: merge ( BasicBlock * from , BasicBlock * to ) { ASSERT ( from -> variablesAtTail . numberOfArguments ( ) == to -> variablesAtHead . numberOfArguments ( ) ) ; ASSERT ( from -> variablesAtTail . numberOfLocals ( ) == to -> variablesAtHead . numberOfLocals ( ) ) ; bool changed = false ; for ( size_t argument = 0 ; argument < from -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { AbstractValue & destination = to -> valuesAtHead . argument ( argument ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . argument ( argument ) , to -> variablesAtHead . argument ( argument ) , from -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < from -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { AbstractValue & destination = to -> valuesAtHead . local ( local ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . local ( local ) , to -> variablesAtHead . local ( local ) , from -> variablesAtTail . local ( local ) ) ; } if ( ! to -> cfaHasVisited ) changed = true ; to -> cfaShouldRevisit |= changed ; return changed ; }
inline bool AbstractState :: mergeToSuccessors ( Graph & graph , BasicBlock * basicBlock ) { Node * terminal = basicBlock -> last ( ) ; ASSERT ( terminal -> isTermin@@ al ( ) ) ; switch ( terminal -> op ( ) ) { case Jump : { ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; return merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; } case Branch : { ASSERT ( basicBlock -> cfaBranchDirection != InvalidBranchDirection ) ; bool changed = false ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; if ( basicBlock -> cfaBranchDirection != TakeFalse ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> notTakenBlockIndex ( ) ) ; if ( basicBlock -> cfaBranchDirection != TakeTrue ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> notTakenBlockIndex ( ) ] . get ( ) ) ; return changed ; } case Return : case Throw : case ThrowReferenceError : ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; return false ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; return false ; } }
inline bool AbstractState :: mergeVariableBetweenBlocks ( AbstractValue & destination , AbstractValue & source , Node * destinationNode , Node * sourceNode ) { if ( ! destinationNode ) return false ; ASSERT_UNUSED ( sourceNode , sourceNode ) ; return destination . merge ( source ) ; }
void AbstractState :: dump ( Print@@ Stream & out ) { bool first = true ; for ( size_t i = 0 ; i < m_block -> size ( ) ; ++ i ) { Node * node = m_block -> at ( i ) ; AbstractValue & value = forNode ( node ) ; if ( value . isClear ( ) ) continue ; if ( first ) first = false ; else out . printf ( " ▁ " ) ; out . printf ( " @ % lu : " , static_cast < unsigned long > ( node -> index ( ) ) ) ; value . dump ( out ) ; } }
