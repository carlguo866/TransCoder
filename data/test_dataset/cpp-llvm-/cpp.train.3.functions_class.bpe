AboutDialog :: AboutDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: AboutDialog ) { ui -> setupUi ( this ) ; ui -> copyright@@ Label -> setText ( tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ 2009 - % 1 ▁ " ) . arg ( COPYRIGHT_YEAR ) + tr ( " The ▁ Bitcoin ▁ deve@@ lopers " ) + QString ( " < br > " ) + tr ( " Copyright " ) + QString ( " ▁ & copy ; ▁ " ) + tr ( " % 1 ▁ StartJOIN " ) . arg ( ABOUTDIALOG_COPYRIGHT_YEAR ) ) ; }
void AboutDialog :: setModel ( ClientModel * model ) { if ( model ) { ui -> versionLabel -> setText ( model -> formatFull@@ Version ( ) ) ; } }
AboutDialog :: ~ AboutDialog ( ) { delete ui ; }
void AboutDialog :: on_b@@ utton@@ Box_@@ accepted ( ) { close ( ) ; }
void SkFlat@@ tenable :: InitializeFlattenables ( ) { SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBitmapProcShader ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkBlurImageFilter ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkCornerPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkDashPathEffect ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkLayerDrawLooper ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMallocPixelRef ) SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY ( SkMagnifierImageFilter ) SkBlurMaskFilter :: InitializeFlattenables ( ) ; SkColorFilter :: InitializeFlattenables ( ) ; SkGradientShader :: InitializeFlattenables ( ) ; SkXfermode :: InitializeFlattenables ( ) ; }
std :: vector < std :: string > readFile ( std :: string filename ) { std :: vector < std :: string > lines ; std :: ifstream read ; std :: string line ; read . open ( filename . c_str ( ) ) ; if ( ! read . good ( ) ) { read . close ( ) ; std :: ofstream create ; create . open ( filename . c_str ( ) ) ; return lines ; } while ( ! read . eof ( ) ) { getline ( read , line ) ; if ( line != " " ) { lines . push_back ( line ) ; } } read . close ( ) ; return lines ; }
void ImagePreviewComponent :: selectedFileChanged ( const File & file ) { if ( fileToLoad != file ) { fileToLoad = file ; startTimer ( 100 ) ; } }
void ImagePreviewComponent :: timerCallback ( ) { stop@@ Timer ( ) ; currentThumbnail = Image ( ) ; currentDetails . clear ( ) ; repaint ( ) ; ScopedPointer < FileInputStream > in ( fileToLoad . createInputStream ( ) ) ; if ( in != nullptr ) { if ( ImageFileFormat * const format = ImageFileFormat :: findImage@@ FormatForStream ( * in ) ) { currentThumbnail = format -> decode@@ Image ( * in ) ; if ( currentThumbnail . isValid ( ) ) { int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; currentDetails << fileToLoad . getFileName ( ) << " \n " << format -> getFormat@@ Name ( ) << " \n " << w << " ▁ x ▁ " << h << " ▁ pixels \n " << File :: descriptionOf@@ SizeInBytes ( fileToLoad . getSize ( ) ) ; getThumbSize ( w , h ) ; currentThumbnail = currentThumbnail . rescaled ( w , h ) ; } } } }
void ImagePreviewComponent :: paint ( Graphics & g ) { if ( currentThumbnail . isValid ( ) ) { g . setFont ( 13.0f ) ; int w = currentThumbnail . getWidth ( ) ; int h = currentThumbnail . getHeight ( ) ; getThumbSize ( w , h ) ; const int numLines = 4 ; const int totalH = 13 * numLines + h + 4 ; const int y = ( getHeight ( ) - totalH ) / 2 ; g . drawImageWithin ( currentThumbnail , ( getWidth ( ) - w ) / 2 , y , w , h , RectanglePlacement :: centred | RectanglePlacement :: onlyReduce@@ InSize , false ) ; g . drawFit@@ tedText ( currentDetails , 0 , y + h + 4 , getWidth ( ) , 100 , Justification :: centred@@ Top , numLines ) ; } }
void TreeParser :: reportError ( const Reco@@ gnition@@ Exception & ex ) { ANTLR_USE_NAMESPACE ( std ) cerr << ex . toString ( ) . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: reportError ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " error : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: report@@ Warning ( const ANTLR_USE_NAMESPACE ( std ) string & s ) { ANTLR_USE_NAMESPACE ( std ) cerr << " warning : ▁ " << s . c_str ( ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: traceIndent ( ) { for ( int i = 0 ; i < traceDepth ; i ++ ) ANTLR_USE_NAMESPACE ( std ) cout << " ▁ " ; }
void TreeParser :: traceIn ( const char * rname , RefAST t ) { traceDepth ++ ; traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " > ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; }
void TreeParser :: traceOut ( const char * rname , RefAST t ) { traceIndent ( ) ; ANTLR_USE_NAMESPACE ( std ) cout << " < ▁ " << rname << " ( " << ( t ? t -> toString ( ) . c_str ( ) : " null " ) << " ) " << ( ( inputState -> guessing > 0 ) ? " ▁ [ guessing ] " : " " ) << ANTLR_USE_NAMESPACE ( std ) endl ; traceDepth -- ; }
void ExternalSymbolDumper :: start ( const PDBSymbolExe & Symbol ) { auto Vars = Symbol . findAll@@ Children < PDBSymbolPublicSymbol > ( ) ; while ( auto Var = Vars -> getNext ( ) ) Var -> dump ( * this ) ; }
void ExternalSymbolDumper :: dump ( const PDBSymbolPublicSymbol & Symbol ) { std :: string LinkageName = Symbol . getName ( ) ; if ( Printer . IsSymbol@@ Exclu@@ ded ( LinkageName ) ) return ; Printer . NewLine ( ) ; uint64_t Addr = Symbol . getVirtual@@ Address ( ) ; Printer << " [ " ; WithColor ( Printer , PDB_ColorItem :: Address ) . get ( ) << format_he@@ x ( Addr , 10 ) ; Printer << " ] ▁ " ; WithColor ( Printer , PDB_ColorItem :: Identifier ) . get ( ) << LinkageName ; }
void FalagardCheckbox :: drawSelf ( float z ) { Checkbox :: drawSelf ( z ) ; Window :: drawSelf ( z ) ; }
void FalagardCheckbox :: drawNormal ( float z ) { doButtonRender ( d_selected ? " SelectedNormal " : " Normal " ) ; }
void FalagardCheckbox :: drawHover ( float z ) { doButtonRender ( d_selected ? " SelectedHover " : " Hover " ) ; }
void FalagardCheckbox :: drawPushed ( float z ) { doButtonRender ( d_selected ? " SelectedPushed " : " Pushed " ) ; }
void FalagardCheckbox :: drawDisabled ( float z ) { doButtonRender ( d_selected ? " SelectedDisabled " : " Disabled " ) ; }
void FalagardCheckbox :: doButtonRender ( const String & state ) { if ( d_needsRedraw ) { const StateImagery * imagery ; d_render@@ Cache . clearCached@@ Imagery ( ) ; d_needsRedraw = false ; try { const WidgetLook@@ Feel & wlf = WidgetLook@@ Manager :: getSingleton ( ) . getWidget@@ Look ( d_look@@ Name ) ; imagery = wlf . isState@@ Imager@@ yPresent ( state ) ? & wlf . getStateImagery ( state ) : d_selected ? & wlf . getStateImagery ( " SelectedNormal " ) : & wlf . getStateImagery ( " Normal " ) ; } catch ( UnknownObjectException ) { return ; } imagery -> render ( * this ) ; } }
Window * FalagardCheckboxFactory :: createWindow ( const String & name ) { return new FalagardCheckbox ( d_type , name ) ; }
void FalagardCheckboxFactory :: destroy@@ Window ( Window * window ) { delete window ; }
void CPACSFarField :: ReadCPACS ( const TixiDocumentHandle & tixiHandle , const std :: string & xpath ) { if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / type " ) ) { m_type = stringToT@@ iglFarField@@ Type ( tixi :: TixiGetElement < std :: string > ( tixiHandle , xpath + " / type " ) ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ type ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / referenceLength " ) ) { m_referenceLength = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / referenceLength " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ referenceLength ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } if ( tixi :: TixiCheckElement ( tixiHandle , xpath + " / multiplier " ) ) { m_multiplier = tixi :: TixiGetElement < double > ( tixiHandle , xpath + " / multiplier " ) ; } else { LOG ( ERROR ) << " Required ▁ element ▁ multiplier ▁ is ▁ missing ▁ at ▁ xpath ▁ " << xpath ; } }
void CPACSFarField :: SetType ( const TiglFarFieldType & value ) { m_type = value ; }
void CPACSFarField :: SetReference@@ Length ( const double & value ) { m_referenceLength = value ; }
void CPACSFarField :: SetMultiplier ( const double & value ) { m_multiplier = value ; }
ICMPPacket :: ICMPPacket ( IPAddress :: Family family , int dataSize ) : _pImpl ( 0 ) { if ( family == IPAddress :: IPv4 ) _pImpl = new ICMPv4PacketImpl ( dataSize ) ; else if ( family == IPAddress :: IPv6 ) throw NotImplementedException ( " ICMPv6 ▁ packets ▁ not ▁ implemented . " ) ; else throw InvalidArgumentException ( " Invalid ▁ or ▁ unsupported ▁ address ▁ family ▁ passed ▁ to ▁ ICMPPacket " ) ; }
ICMPPacket :: ~ ICMPPacket ( ) { delete _pImpl ; }
void ICMPPacket :: setDataSize ( int dataSize ) { _pImpl -> setDataSize ( dataSize ) ; }
const Poco :: UInt8 * ICMPPacket :: packet ( ) { return _pImpl -> packet ( ) ; }
std :: string ICMPPacket :: errorDescription ( Poco :: UInt8 * buffer , int length ) { return _pImpl -> errorDescription ( buffer , length ) ; }
std :: string ICMPPacket :: typeDescription ( int typeId ) { return _pImpl -> typeDescription ( typeId ) ; }
DataFieldManager :: DataFieldManager ( uint32_t dataSize , uint32_t averagerSize ) { m_dataSize = dataSize ; m_averagerSize = averagerSize ; m_fieldCount = 0 ; m_dataCount = 0 ; uint8_t i = 0 ; for ( i = 0 ; i < MAX_FIELDS ; i ++ ) { m_fields [ i ] = NULL ; } }
uint8_t DataFieldManager :: fieldCount ( ) { return m_fieldCount ; }
bool DataFieldManager :: addField ( NumericDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } PLATFORM_@@ special@@ FieldSetup ( field ) ; field -> setData@@ Siz@@ es ( m_dataSize , m_averagerSize ) ; m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; }
bool DataFieldManager :: addField ( StringDataField * field ) { if ( ! field ) { return false ; } if ( m_fieldCount == MAX_FIELDS ) { return false ; } m_fields [ m_fieldCount ] = field ; m_channelNumbers [ m_fieldCount ] = field -> getChannelNumber ( ) ; m_fieldCount ++ ; return true ; }
void DataFieldManager :: storeDataArray ( int32_t * data ) { uint16_t field = 0 ; uint16_t dataIndex ; bool newAverageStored = false ; for ( field = 0 ; field < m_fieldCount ; field ++ ) { NumericDataField * pField = ( NumericDataField * ) m_fields [ field ] ; if ( pField ) { dataIndex = m_channelNumbers [ field ] - 1 ; newAverageStored |= pField -> storeData ( data [ dataIndex ] ) ; } } if ( newAverageStored ) { m_dataCount ++ ; } }
void DataFieldManager :: getData@@ Array ( float * buffer , bool converted , bool alsoRemove ) { uint16_t field ; for ( field = 0 ; field < m_fieldCount ; ++ field ) { if ( converted ) { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getConv@@ Data ( alsoRemove ) ; } else { buffer [ field ] = ( ( NumericDataField * ) m_fields [ field ] ) -> getRawData ( alsoRemove ) ; } } if ( alsoRemove ) { m_dataCount -- ; } }
DataField * DataFieldManager :: getChannel ( uint8_t channel ) { int32_t actualIndex = indexOf ( m_channelNumbers , ( uint32_t ) channel , m_fieldCount ) ; return actualIndex >= 0 ? m_fields [ actualIndex ] : NULL ; }
DataField * DataFieldManager :: getField ( uint8_t index ) { return m_fields [ index ] ; }
DataField * * DataFieldManager :: getField@@ s ( void ) { return m_fields ; }
uint32_t DataFieldManager :: writeHeader@@ sToBuffer ( char * buffer , uint8_t bufferLength ) { if ( ! buffer ) { return 0 ; } uint8_t i ; FixedLength@@ Accumulator headerAccumulator ( buffer , bufferLength ) ; for ( i = 0 ; i < m_fieldCount ; ++ i ) { headerAccumulator . writeString ( m_fields [ i ] -> getTypeString ( ) ) ; if ( ! lastinloop ( i , m_fieldCount ) ) { headerAccumulator . writeString ( " , ▁ " ) ; } } headerAccumulator . writeString ( " \n " ) ; return headerAccumulator . length ( ) ; }
void DataFieldManager :: setupAllValidChannels ( void ) { uint8_t ch ; NumericDataField * field ; FIELD_TYPE type ; void * data ; uint32_t maxChannels = Settings_@@ GetMax@@ Channels ( ) ; for ( ch = 1 ; ch < maxChannels ; ch ++ ) { if ( Settings_@@ ChannelSettingIsValid ( ch ) ) { type = Settings_@@ GetChannel@@ Type ( ch ) ; data = Settings_@@ GetData ( ch ) ; switch ( type ) { case VOLTAGE : case CURRENT : case TEMPERATURE_@@ C : case TEMPERATURE_@@ K : case TEMPERATURE_@@ F : field = new NumericDataField ( type , data , ch ) ; std :: cout << " Adding ▁ channel ▁ " << ( int ) ch << " , ▁ type ▁ " << field -> getTypeString ( ) << std :: endl ; addField ( field ) ; break ; default : break ; } } } }
bool DataFieldManager :: hasData ( void ) { uint8_t i = 0 ; bool atLeastOneFieldHasData = false ; for ( i = 0 ; i < m_fieldCount ; i ++ ) { atLeastOneFieldHasData |= m_fields [ i ] -> hasData ( ) ; } return atLeastOneFieldHasData ; }
uint32_t DataFieldManager :: count ( void ) { return m_dataCount ; }
uint32_t * DataFieldManager :: getChannel@@ Numbers ( void ) { return m_channelNumbers ; }
std :: set < int > const build_set ( ) { typedef std :: set < int > int_set ; typedef std :: vector < int > int_vector ; int_set result ; int_vector const data = build_vector ( ) ; int_vector :: const_iterator it = data . begin ( ) ; int_vector :: const_iterator const end = data . end ( ) ; result . insert ( it , end ) ; return result ; }
std :: multiset < int > const build_multiset ( ) { typedef std :: set < int > int_set ; typedef std :: multiset < int > int_multiset ; int_set const data = build_set ( ) ; return int_multiset ( data . begin ( ) , data . end ( ) ) ; }
std :: vector < int > const init_vector ( ) { typedef std :: vector < int > int_vector ; int const data [ ] = { - 4 , - 3 , - 2 , - 1 , 0 } ; int_vector :: size_type const data_size = sizeof ( data ) / sizeof ( data [ 0 ] ) ; return int_vector ( data , data + data_size ) ; }
std :: vector < int > const build_vector ( ) { typedef std :: vector < int > int_vector ; static int_vector data = init_vector ( ) ; int_vector :: size_type const size = data . size ( ) ; int_vector :: iterator it = data . begin ( ) ; int_vector :: iterator const end = data . end ( ) ; for ( ; it != end ; ++ it ) * it += size ; return data ; }
resultset :: resultset ( const std :: shared_ptr < sqlite :: session > & sess , const shared_ptr < sqlite3_@@ stmt > & stmt ) : stmt_ ( stmt ) , sess_ ( sess ) , status_ ( - 1 ) { if ( sess_ == nullptr ) { throw database_exception ( " No ▁ database ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } if ( stmt_ == nullptr ) { throw database_exception ( " no ▁ state@@ ment ▁ provided ▁ to ▁ sqlite3 ▁ resultset " ) ; } }
resultset :: resultset ( resultset && other ) : stmt_ ( std :: move ( other . stmt_ ) ) , sess_ ( std :: move ( other . sess_ ) ) , status_ ( other . status_ ) { other . sess_ = nullptr ; other . stmt_ = nullptr ; }
bool resultset :: next ( ) { if ( ! is_valid ( ) ) { return false ; } if ( status_ == SQLITE_@@ DONE ) { return false ; } status_ = sqlite3_@@ step ( stmt_ . get ( ) ) ; return status_ == SQLITE_@@ ROW ; }
void resultset :: reset ( ) { if ( ! is_valid ( ) ) { return ; } if ( sqlite3_@@ reset ( stmt_ . get ( ) ) != SQLITE_@@ OK ) { throw database_exception ( sess_ -> last_error ( ) ) ; } status_ = - 1 ; }
resultset :: row_type resultset :: current_row ( ) { return row_type ( make_shared < row > ( sess_ , stmt_ ) ) ; }
QQuickAnimatorController :: ~ QQuickAnimatorController ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; delete job ; } foreach ( QQuickAnimatorProxyJob * proxy , m_animatorRoots ) proxy -> controller@@ WasDeleted ( ) ; qDelete@@ All ( m_animatorRoots . keys ( ) ) ; foreach ( QAbstractAnimationJob * job , m_starting . keys ( ) ) { if ( ! m_animatorRoots . contains ( job ) ) delete job ; } }
void QQuickAnimatorController :: itemDestroyed ( QObject * o ) { m_deletedSinceLastFrame << ( QQuickItem * ) o ; }
void QQuickAnimatorController :: advance ( ) { bool running = false ; for ( QHash < QAbstractAnimationJob * , QQuickAnimatorProxyJob * > :: const_iterator it = m_animatorRoots . constBegin ( ) ; ! running && it != m_animatorRoots . constEnd ( ) ; ++ it ) { if ( it . key ( ) -> isRunning ( ) ) running = true ; } lock ( ) ; for ( QHash < QQuickItem * , QQuickTransformAnimatorJob :: Helper * > :: const_iterator it = m_transforms . constBegin ( ) ; it != m_transforms . constEnd ( ) ; ++ it ) { QQuickTransformAnimatorJob :: Helper * xform = * it ; if ( ! xform -> item ) continue ; ( * it ) -> apply ( ) ; } unlock ( ) ; if ( running ) m_window -> update ( ) ; }
void QQuickAnimatorController :: before@@ NodeSync ( ) { foreach ( QAbstractAnimationJob * job , m_deleting ) { m_starting . take ( job ) ; m_stopping . take ( job ) ; m_animatorRoots . take ( job ) ; job -> stop ( ) ; delete job ; } m_deleting . clear ( ) ; if ( m_starting . size ( ) ) m_window -> update ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_starting ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> addAnimationChangeListener ( this , QAbstractAnimationJob :: Completion ) ; qquick_initialize_helper ( job , this ) ; m_animatorRoots [ job ] = proxy ; job -> start ( ) ; proxy -> startedBy@@ Controller ( ) ; } m_starting . clear ( ) ; foreach ( QQuickAnimatorProxyJob * proxy , m_stopping ) { QAbstractAnimationJob * job = proxy -> job ( ) ; job -> stop ( ) ; } m_stopping . clear ( ) ; foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( ! job -> target ( ) ) continue ; else if ( m_deletedSinceLastFrame . contains ( job -> target ( ) ) ) job -> targetWasDeleted ( ) ; else if ( job -> isTransform ( ) ) { QQuickTransformAnimatorJob * xform = static_cast < QQuickTransformAnimatorJob * > ( job ) ; xform -> transformHelper ( ) -> sync ( ) ; } } foreach ( QQuickItem * wiped , m_deletedSinceLastFrame ) { QQuickTransformAnimatorJob :: Helper * helper = m_transforms . value ( wiped ) ; if ( helper ) helper -> item = 0 ; } m_deletedSinceLastFrame . clear ( ) ; }
void QQuickAnimatorController :: afterNodeSync ( ) { foreach ( QQuickAnimatorJob * job , m_activeLeafAnimations ) { if ( job -> isUn@@ ifor@@ m ( ) && job -> target ( ) ) static_cast < QQuickUniform@@ AnimatorJob * > ( job ) -> afterNodeSync ( ) ; } }
void QQuickAnimatorController :: animation@@ Finished ( QAbstractAnimationJob * job ) { if ( ! m_deleting . contains ( job ) ) { QQuickAnimatorProxyJob * proxy = m_animatorRoots [ job ] ; if ( proxy ) QCoreApplication :: postEvent ( proxy , new QEvent ( QEvent :: User ) ) ; } }
void QQuickAnimatorController :: animation@@ StateChanged ( QAbstractAnimationJob * job , QAbstractAnimationJob :: State newState , QAbstractAnimationJob :: State oldState ) { Q_ASSERT ( job -> isRenderThreadJob ( ) ) ; QQuickAnimatorJob * animator = static_cast < QQuickAnimatorJob * > ( job ) ; if ( newState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations << animator ; animator -> setHasBeen@@ Running ( true ) ; } else if ( oldState == QAbstractAnimationJob :: Running ) { m_activeLeafAnimations . remove ( animator ) ; } }
void QQuickAnimatorController :: requestSync ( ) { m_window -> may@@ beUpdate ( ) ; }
void QQuickAnimatorController :: startJob ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_starting [ job ] = proxy ; requestSync ( ) ; }
void QQuickAnimatorController :: stop@@ Job ( QQuickAnimatorProxyJob * proxy , QAbstractAnimationJob * job ) { m_stopping [ job ] = proxy ; requestSync ( ) ; }
void QQuickAnimatorController :: deleteJob ( QAbstractAnimationJob * job ) { lock ( ) ; m_deleting << job ; requestSync ( ) ; unlock ( ) ; }
UINT32 mm1_state :: screen_update ( screen_@@ device & screen , bitmap@@ _rgb@@ 32 & bitmap , const rectangle & cliprect ) { m_cr@@ tc -> screen_update ( screen , bitmap , cliprect ) ; m_hgdc -> screen_update ( screen , bitmap , cliprect ) ; return 0 ; }
ctkWorkflowStepPrivate :: ctkWorkflowStepPrivate ( ctkWorkflowStep & object ) : q_ptr ( & object ) { qRegister@@ Meta@@ Type < ctkWorkflowStep * > ( " ctkWorkflowStep * " ) ; this -> Workflow = 0 ; this -> WidgetType = false ; this -> HasValidateCommand = false ; this -> HasOnEntryCommand = false ; this -> HasOnExitCommand = false ; this -> ProcessingState = new QState ( ) ; this -> ValidationState = new QState ( ) ; this -> ValidationTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationTransition ) ; this -> ValidationTransition -> setTargetState ( this -> ValidationState ) ; this -> ProcessingState -> addTransition ( this -> ValidationTransition ) ; this -> ValidationFailedTransition = 0 ; this -> ValidationFailedTransition = new ctkWorkflowIntrastepTransition ( ctkWorkflowIntrastepTransition :: ValidationFailedTransition ) ; this -> ValidationFailedTransition -> setTargetState ( this -> ProcessingState ) ; this -> ValidationState -> addTransition ( this -> ValidationFailedTransition ) ; }
ctkWorkflowStepPrivate :: ~ ctkWorkflowStepPrivate ( ) { if ( ! this -> ValidationState . isNull ( ) ) { delete this -> ValidationState ; } if ( ! this -> ProcessingState . isNull ( ) ) { delete this -> ProcessingState ; } }
ctkWorkflowStep :: ctkWorkflowStep ( const QString & newId ) : d_ptr ( new ctkWorkflowStepPrivate ( * this ) ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; }
ctkWorkflowStep :: ctkWorkflowStep ( ctkWorkflowStepPrivate * pimpl , const QString & newId ) : d_ptr ( pimpl ) { Q_D ( ctkWorkflowStep ) ; d -> Id = newId ; }
void ctkWorkflowStep :: setId ( const QString & newId ) { Q_D ( ctkWorkflowStep ) ; if ( d -> Workflow && d -> Workflow -> hasStep ( newId ) && ! this -> id ( ) . isEmpty ( ) ) { logger . error ( QString ( " ctkWorkflowStep ▁ - ▁ Failed ▁ to ▁ change ▁ id ▁ from ▁ ' %1 ' ▁ to ▁ ' %2 ' ▁ - ▁ " " Step ▁ already ▁ added ▁ to ▁ a ▁ workflow ▁ ! " ) . arg ( this -> id ( ) ) . arg ( newId ) ) ; return ; } d -> Id = newId ; }
QObject * ctkWorkflowStep :: ctkWorkflowStepQObject ( ) { Q_D ( ctkWorkflowStep ) ; return d ; }
void ctkWorkflowStep :: validate ( const QString & desiredBranchId ) { Q_D ( ctkWorkflowStep ) ; logger . info ( QString ( " validate ▁ - ▁ validating ▁ the ▁ input ▁ from ▁ % 1" ) . arg ( d -> Name ) ) ; this -> validationComplete ( true , desiredBranchId ) ; }
void ctkWorkflowStep :: onEntry ( const ctkWorkflowStep * comingFrom , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( comingFrom ) ; Q_UNUSED ( transitionType ) ; this -> onEntryComplete ( ) ; }
void ctkWorkflowStep :: onExit ( const ctkWorkflowStep * goingTo , const ctkWorkflowInterstepTransition :: InterstepTransitionType transitionType ) { Q_UNUSED ( goingTo ) ; Q_UNUSED ( transitionType ) ; this -> onExitComplete ( ) ; }
void Util :: init ( int argc , char * const * argv ) { saved_argc = argc ; saved_argv = argv ; == HAL_LINUX_HEAT_P@@ WM _heat = new Linux :: HeatPwm ( HAL_LINUX_HEAT_P@@ WM_NUM , HAL_LINUX_HEAT_K@@ P , HAL_LINUX_HEAT_K@@ I , HAL_LINUX_HEAT_@@ PERIO@@ D_NS , HAL_LINUX_HEAT_@@ TARGET_TEMP ) ; # error Unrecognized Heat _heat = new Linux :: Heat ( ) ; }
void Util :: set_imu_temp ( float current ) { _heat -> set_imu_temp ( current ) ; }
void Util :: commandlin@@ e_arguments ( uint8_t & argc , char * const * & argv ) { argc = saved_argc ; argv = saved_argv ; }
bool Util :: toneAlarm_@@ init ( ) { return _toneAlarm . init ( ) ; }
void Util :: toneAlarm_@@ set_tune ( uint8_t tone ) { _toneAlarm . set_tune ( tone ) ; }
void Util :: _toneAlar@@ m_timer_tick ( ) { if ( state == 0 ) { state = state + _toneAlarm . init_t@@ une ( ) ; } else if ( state == 1 ) { state = state + _toneAlarm . set_note ( ) ; } if ( state == 2 ) { state = state + _toneAlarm . play ( ) ; } else if ( state == 3 ) { state = 1 ; } if ( _toneAlarm . is_tun@@ e_comp ( ) ) { state = 0 ; } }
void Util :: set_system_@@ clock ( uint64_t time_utc_usec ) { != HAL_BOARD_SUBTYPE_LINUX_@@ NONE timespec ts ; ts . tv_sec = time_utc_usec / 1.0@@ e6 ; ts . tv_nsec = ( time_utc_usec % 1000000 ) * 1000 ; clock_@@ settime ( CLOCK_@@ REAL@@ TIME , & ts ) ; }
bool Util :: is_char@@ dev_@@ node ( const char * path ) { struct stat st ; if ( ! path || lstat ( path , & st ) < 0 ) return false ; return S_IS@@ CHR ( st . st_mode ) ; }
uint32_t Util :: available_memory ( void ) { return 256 * 1024 ; }
int Util :: write_@@ file ( const char * path , const char * fmt , ... ) { errno = 0 ; int fd = :: open ( path , O_WRO@@ NLY | O_CLO@@ EXEC ) ; if ( fd == - 1 ) { return - errno ; } va_list args ; va_start ( args , fmt ) ; int ret = :: vdprintf ( fd , fmt , args ) ; int errno_bkp = errno ; :: close ( fd ) ; va_end ( args ) ; if ( ret < 1 ) { return - errno_bkp ; } return ret ; }
int Util :: read_file ( const char * path , const char * fmt , ... ) { errno = 0 ; FILE * file = :: fopen ( path , " re " ) ; if ( ! file ) return - errno ; va_list args ; va_start ( args , fmt ) ; int ret = :: vf@@ scan@@ f ( file , fmt , args ) ; int errno_bkp = errno ; :: fclose ( file ) ; va_end ( args ) ; if ( ret < 1 ) return - errno_bkp ; return ret ; }
int Util :: get_h@@ w_arm@@ 32 ( ) { int ret = - ENOENT ; char buffer [ MAX_SIZE_LINE ] ; const char * hardware_description_entry = " Hard@@ ware " ; char * flag ; FILE * f ; f = fopen ( " / proc / cpu@@ info " , " r " ) ; if ( f == NULL ) { ret = - errno ; goto end ; } while ( fgets ( buffer , MAX_SIZE_LINE , f ) != NULL ) { flag = strstr ( buffer , hardware_description_entry ) ; if ( flag != NULL ) { for ( uint8_t i = 0 ; i < UTIL_NUM_HARDWARES ; i ++ ) { if ( strstr ( buffer , _hw_names [ i ] ) != 0 ) { ret = i ; goto close_end ; } } } } close_end : fclose ( f ) ; end : return ret ; }
SendCoinsDialog :: SendCoinsDialog ( QWidget * parent ) : QDialog ( parent ) , ui ( new Ui :: SendCoinsDialog ) , model ( 0 ) { ui -> setupUi ( this ) ; ui -> addButton -> setIcon ( QIcon ( ) ) ; ui -> clearButton -> setIcon ( QIcon ( ) ) ; ui -> sendButton -> setIcon ( QIcon ( ) ) ; addEntry ( ) ; connect ( ui -> addButton , SIGNAL ( clicked ( ) ) , this , SLOT ( addEntry ( ) ) ) ; connect ( ui -> clearButton , SIGNAL ( clicked ( ) ) , this , SLOT ( clear ( ) ) ) ; fNewRecipientAllowed = true ; }
void SendCoinsDialog :: setModel ( WalletModel * model ) { this -> model = model ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setModel ( model ) ; } } if ( model && model -> getOptionsModel ( ) ) { setBalance ( model -> getBalance ( ) , model -> getUn@@ confirmedBalance ( ) , model -> getIm@@ matureBalance ( ) ) ; connect ( model , SIGNAL ( balance@@ Changed ( qint64 , qint64 , qint64 ) ) , this , SLOT ( setBalance ( qint64 , qint64 , qint64 ) ) ) ; connect ( model -> getOptionsModel ( ) , SIGNAL ( displayUnitChanged ( int ) ) , this , SLOT ( updateDisplayUnit ( ) ) ) ; } }
SendCoinsDialog :: ~ SendCoinsDialog ( ) { delete ui ; }
void SendCoinsDialog :: on_send@@ Button_clicked ( ) { QList < SendCoinsRecipient > recipients ; bool valid = true ; if ( ! model ) return ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { if ( entry -> validate ( ) ) { recipients . append ( entry -> getValue ( ) ) ; } else { valid = false ; } } } if ( ! valid || recipients . isEmpty ( ) ) { return ; } QStringList formatted ; foreach ( const SendCoinsRecipient & rcp , recipients ) { formatted . append ( tr ( " < b > % 1 < / b > ▁ to ▁ % 2 ▁ ( %3 ) " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , rcp . amount ) , Qt :: escape ( rcp . label ) , rcp . address ) ) ; } fNewRecipientAllowed = false ; QMessageBox :: StandardButton retval = QMessageBox :: question ( this , tr ( " Confirm ▁ send ▁ coins " ) , tr ( " Are ▁ you ▁ sure ▁ you ▁ want ▁ to ▁ send ▁ % 1 ? " ) . arg ( formatted . join ( tr ( " ▁ and ▁ " ) ) ) , QMessageBox :: Yes | QMessageBox :: Cancel , QMessageBox :: Cancel ) ; if ( retval != QMessageBox :: Yes ) { fNewRecipientAllowed = true ; return ; } WalletModel :: UnlockContext ctx ( model -> requestUnlock ( ) ) ; if ( ! ctx . isValid ( ) ) { fNewRecipientAllowed = true ; return ; } WalletModel :: SendCoinsReturn sendstatus = model -> sendCoins ( recipients ) ; switch ( sendstatus . status ) { case WalletModel :: InvalidAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ rece@@ pient ▁ address ▁ is ▁ not ▁ valid , ▁ please ▁ recheck . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: InvalidAmount : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ to ▁ pay ▁ must ▁ be ▁ larger ▁ than ▁ 0 . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ amount ▁ exceeds ▁ your ▁ balance . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: AmountWithFee@@ ExceedsBalance : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " The ▁ total ▁ exceeds ▁ your ▁ balance ▁ when ▁ the ▁ % 1 ▁ transaction ▁ fee ▁ is ▁ included . " ) . arg ( BitcoinUnits :: formatWithUnit ( BitcoinUnits :: BTC , sendstatus . fee ) ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: DuplicateAddress : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Duplicate ▁ address ▁ found , ▁ can ▁ only ▁ send ▁ to ▁ each ▁ address ▁ once ▁ per ▁ send ▁ operation . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCreation@@ Failed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ Transaction ▁ creation ▁ failed . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: TransactionCommit@@ Failed : QMessageBox :: warning ( this , tr ( " Send ▁ Coins " ) , tr ( " Error : ▁ The ▁ transaction ▁ was ▁ reject@@ ed . ▁ This ▁ might ▁ happen ▁ if ▁ some ▁ of ▁ the ▁ coins ▁ in ▁ your ▁ wallet ▁ were ▁ already ▁ spent , ▁ such ▁ as ▁ if ▁ you ▁ used ▁ a ▁ copy ▁ of ▁ wallet . dat ▁ and ▁ coins ▁ were ▁ spent ▁ in ▁ the ▁ copy ▁ but ▁ not ▁ marked ▁ as ▁ spent ▁ here . " ) , QMessageBox :: Ok , QMessageBox :: Ok ) ; break ; case WalletModel :: Aborted : break ; case WalletModel :: OK : accept ( ) ; break ; } fNewRecipientAllowed = true ; }
void SendCoinsDialog :: clear ( ) { while ( ui -> entries -> count ( ) ) { delete ui -> entries -> take@@ At ( 0 ) -> widget ( ) ; } addEntry ( ) ; updateRemoveEnabled ( ) ; ui -> sendButton -> setDefault ( true ) ; }
void SendCoinsDialog :: reject ( ) { clear ( ) ; }
void SendCoinsDialog :: accept ( ) { clear ( ) ; }
SendCoinsEntry * SendCoinsDialog :: addEntry ( ) { SendCoinsEntry * entry = new SendCoinsEntry ( this ) ; entry -> setModel ( model ) ; ui -> entries -> addWidget ( entry ) ; connect ( entry , SIGNAL ( removeEntry ( SendCoinsEntry * ) ) , this , SLOT ( removeEntry ( SendCoinsEntry * ) ) ) ; updateRemoveEnabled ( ) ; entry -> clear ( ) ; entry -> setFocus ( ) ; ui -> scrollAreaWidgetContents -> resize ( ui -> scrollAreaWidgetContents -> sizeHint ( ) ) ; QCoreApplication :: instance ( ) -> processEvents ( ) ; QScrollBar * bar = ui -> scrollArea -> verticalScrollBar ( ) ; if ( bar ) bar -> setSlider@@ Position ( bar -> maximum ( ) ) ; return entry ; }
void SendCoinsDialog :: updateRemoveEnabled ( ) { bool enabled = ( ui -> entries -> count ( ) > 1 ) ; for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { entry -> setRemoveEnabled ( enabled ) ; } } setupTabChain ( 0 ) ; }
void SendCoinsDialog :: removeEntry ( SendCoinsEntry * entry ) { delete entry ; updateRemoveEnabled ( ) ; }
QWidget * SendCoinsDialog :: setupTabChain ( QWidget * prev ) { for ( int i = 0 ; i < ui -> entries -> count ( ) ; ++ i ) { SendCoinsEntry * entry = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( i ) -> widget ( ) ) ; if ( entry ) { prev = entry -> setupTabChain ( prev ) ; } } QWidget :: setTabOrder ( prev , ui -> addButton ) ; QWidget :: setTabOrder ( ui -> addButton , ui -> sendButton ) ; return ui -> sendButton ; }
void SendCoinsDialog :: pasteEntry ( const SendCoinsRecipient & rv ) { if ( ! fNewRecipientAllowed ) return ; SendCoinsEntry * entry = 0 ; if ( ui -> entries -> count ( ) == 1 ) { SendCoinsEntry * first = qobject_cast < SendCoinsEntry * > ( ui -> entries -> itemAt ( 0 ) -> widget ( ) ) ; if ( first -> isClear ( ) ) { entry = first ; } } if ( ! entry ) { entry = addEntry ( ) ; } entry -> setValue ( rv ) ; }
bool SendCoinsDialog :: handleURI ( const QString & uri ) { SendCoinsRecipient rv ; if ( GUIUtil :: parseBitcoin@@ URI ( uri , & rv ) ) { pasteEntry ( rv ) ; return true ; } return false ; }
void SendCoinsDialog :: setBalance ( qint64 balance , qint64 unconfirmedBalance , qint64 immatureBalance ) { Q_UNUSED ( unconfirmedBalance ) ; Q_UNUSED ( immatureBalance ) ; if ( ! model || ! model -> getOptionsModel ( ) ) return ; int unit = model -> getOptionsModel ( ) -> getDisplayUnit ( ) ; ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( unit , balance ) ) ; }
void SendCoinsDialog :: updateDisplayUnit ( ) { if ( model && model -> getOptionsModel ( ) ) { ui -> labelBalance -> setText ( BitcoinUnits :: formatWithUnit ( model -> getOptionsModel ( ) -> getDisplayUnit ( ) , model -> getBalance ( ) ) ) ; } }
>= 0x040400 QT_BEGIN_NAMESPACE QtCursorDatabase :: QtCursorDatabase ( ) { appendCursor ( Qt :: ArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - arrow . png " ) ) ) ; appendCursor ( Qt :: UpArrowCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Up ▁ Arrow " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - upar@@ row . png " ) ) ) ; appendCursor ( Qt :: Cross@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Cross " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - cross . png " ) ) ) ; appendCursor ( Qt :: WaitCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Wait " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - wait . png " ) ) ) ; appendCursor ( Qt :: IBe@@ amCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " IBe@@ am " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - ibe@@ am . png " ) ) ) ; appendCursor ( Qt :: SizeVerCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizev . png " ) ) ) ; appendCursor ( Qt :: SizeHor@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeh . png " ) ) ) ; appendCursor ( Qt :: SizeFDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Backslash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizef . png " ) ) ) ; appendCursor ( Qt :: SizeBDiagCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ Slash " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeb . png " ) ) ) ; appendCursor ( Qt :: SizeAllCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Size ▁ All " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - sizeall . png " ) ) ) ; appendCursor ( Qt :: Blan@@ kCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Blan@@ k " ) , QIcon ( ) ) ; appendCursor ( Qt :: Split@@ VCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Vertical " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - vsplit . png " ) ) ) ; appendCursor ( Qt :: Split@@ HCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Split ▁ Horizontal " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hsplit . png " ) ) ) ; appendCursor ( Qt :: PointingHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Pointing ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - hand . png " ) ) ) ; appendCursor ( Qt :: Forbidd@@ enCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Forbidden " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - forbidden . png " ) ) ) ; appendCursor ( Qt :: OpenHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Open ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - openhand . png " ) ) ) ; appendCursor ( Qt :: ClosedHandCursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Closed ▁ Hand " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - closed@@ hand . png " ) ) ) ; appendCursor ( Qt :: WhatsThis@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " What ' s ▁ This " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - whatsth@@ is . png " ) ) ) ; appendCursor ( Qt :: Busy@@ Cursor , QCoreApplication :: translate ( " QtCursorDatabase " , " Busy " ) , QIcon ( QLatin1String ( " : / qt - project . org / qtpropertybrowser / images / cursor - busy . png " ) ) ) ; }
void QtCursorDatabase :: clear ( ) { m_cursorNames . clear ( ) ; m_cursorIcons . clear ( ) ; m_valueToCursorShape . clear ( ) ; m_cursorShapeToValue . clear ( ) ; }
void QtCursorDatabase :: appendCursor ( Qt :: CursorShape shape , const QString & name , const QIcon & icon ) { if ( m_cursorShapeToValue . contains ( shape ) ) return ; const int value = m_cursorNames . count ( ) ; m_cursorNames . append ( name ) ; m_cursorIcons . insert ( value , icon ) ; m_valueToCursorShape . insert ( value , shape ) ; m_cursorShapeToValue . insert ( shape , value ) ; }
QPixmap QtPropertyBrowserUtils :: brushValuePixmap ( const QBrush & b ) { QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter painter ( & img ) ; painter . setComposition@@ Mode ( QPainter :: Composition@@ Mode_Sour@@ ce ) ; painter . fillRect ( 0 , 0 , img . width ( ) , img . height ( ) , b ) ; QColor color = b . color ( ) ; if ( color . alpha ( ) != 255 ) { QBrush opaqueBrush = b ; color . setAlpha ( 255 ) ; opaqueBrush . setColor ( color ) ; painter . fillRect ( img . width ( ) / 4 , img . height ( ) / 4 , img . width ( ) / 2 , img . height ( ) / 2 , opaqueBrush ) ; } painter . end ( ) ; return QPixmap :: fromImage ( img ) ; }
QIcon QtPropertyBrowserUtils :: brush@@ ValueIcon ( const QBrush & b ) { return QIcon ( brushValuePixmap ( b ) ) ; }
QString QtPropertyBrowserUtils :: colorValueText ( const QColor & c ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 , ▁ % 3 ] ▁ ( %4 ) " ) . arg ( c . red ( ) ) . arg ( c . green ( ) ) . arg ( c . blue ( ) ) . arg ( c . alpha ( ) ) ; }
QPixmap QtPropertyBrowserUtils :: fontValuePixmap ( const QFont & font ) { QFont f = font ; QImage img ( 16 , 16 , QImage :: Format_ARGB32_Premultiplied ) ; img . fill ( 0 ) ; QPainter p ( & img ) ; p . setRenderHint ( QPainter :: TextAntialiasing , true ) ; p . setRenderHint ( QPainter :: Antialiasing , true ) ; f . setPointSize ( 13 ) ; p . setFont ( f ) ; QTextOption t ; t . setAlignment ( Qt :: AlignCenter ) ; p . drawText ( QRect ( 0 , 0 , 16 , 16 ) , QString ( QLatin1Char ( ' A ' ) ) , t ) ; return QPixmap :: fromImage ( img ) ; }
QIcon QtPropertyBrowserUtils :: fontValueIcon ( const QFont & f ) { return QIcon ( fontValuePixmap ( f ) ) ; }
QString QtPropertyBrowserUtils :: fontValueText ( const QFont & f ) { return QCoreApplication :: translate ( " QtPropertyBrowserUtils " , " [ %1 , ▁ % 2 ] " ) . arg ( f . family ( ) ) . arg ( f . pointSize ( ) ) ; }
QtBoolEdit :: QtBoolEdit ( QWidget * parent ) : QWidget ( parent ) , m_checkBox ( new QCheckBox ( this ) ) , m_textVisible ( true ) { QHBoxLayout * lt = new QHBoxLayout ; if ( QApplication :: layout@@ Direction ( ) == Qt :: LeftToRight ) lt -> setContentsMargins ( 4 , 0 , 0 , 0 ) ; else lt -> setContentsMargins ( 0 , 0 , 4 , 0 ) ; lt -> addWidget ( m_checkBox ) ; setLayout ( lt ) ; connect ( m_checkBox , SIGNAL ( toggled ( bool ) ) , this , SIGNAL ( toggled ( bool ) ) ) ; setFocusProxy ( m_checkBox ) ; m_checkBox -> setText ( tr ( " True " ) ) ; }
void QtBoolEdit :: setText@@ Visible ( bool textVisible ) { if ( m_textVisible == textVisible ) return ; m_textVisible = textVisible ; if ( m_textVisible ) m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; else m_checkBox -> setText ( QString ( ) ) ; }
void QtBoolEdit :: setCheckState ( Qt :: CheckState state ) { m_checkBox -> setCheckState ( state ) ; }
void QtBoolEdit :: setChecked ( bool c ) { m_checkBox -> setChecked ( c ) ; if ( ! m_textVisible ) return ; m_checkBox -> setText ( isChecked ( ) ? tr ( " True " ) : tr ( " False " ) ) ; }
bool QtBoolEdit :: blockCheckBox@@ Signals ( bool block ) { return m_checkBox -> blockSignals ( block ) ; }
void QtBoolEdit :: mousePressEvent ( QMouseEvent * event ) { if ( event -> button@@ s ( ) == Qt :: LeftButton ) { m_checkBox -> click ( ) ; event -> accept ( ) ; } else { QWidget :: mousePressEvent ( event ) ; } }
void QtBoolEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; }
QtKeySequenceEdit :: QtKeySequenceEdit ( QWidget * parent ) : QWidget ( parent ) , m_num ( 0 ) , m_lineEdit ( new QLineEdit ( this ) ) { QHBoxLayout * layout = new QHBoxLayout ( this ) ; layout -> addWidget ( m_lineEdit ) ; layout -> setMargin ( 0 ) ; m_lineEdit -> installEventFilter ( this ) ; m_lineEdit -> setReadOnly ( true ) ; m_lineEdit -> setFocusProxy ( this ) ; setFocusPolicy ( m_lineEdit -> focus@@ Policy ( ) ) ; setAttribute ( Qt :: WA_@@ InputMethod@@ Enabled ) ; }
bool QtKeySequenceEdit :: eventFilter ( QObject * o , QEvent * e ) { if ( o == m_lineEdit && e -> type ( ) == QEvent :: ContextMenu ) { QContextMenuEvent * c = static_cast < QContextMenuEvent * > ( e ) ; QMenu * menu = m_lineEdit -> createStandard@@ ContextMenu ( ) ; const QList < QAction * > actions = menu -> actions ( ) ; QList@@ Iterator < QAction * > itAction ( actions ) ; while ( itAction . hasNext ( ) ) { QAction * action = itAction . next ( ) ; action -> setShortcut ( QKeySequence ( ) ) ; QString actionString = action -> text ( ) ; const int pos = actionString . lastIndexOf ( QLatin1Char ( ' \t ' ) ) ; if ( pos > 0 ) actionString . remove ( pos , actionString . length ( ) - pos ) ; action -> setText ( actionString ) ; } QAction * actionBefore = 0 ; if ( actions . count ( ) > 0 ) actionBefore = actions [ 0 ] ; QAction * clearAction = new QAction ( tr ( " Clear ▁ Shortcut " ) , menu ) ; menu -> insertAction ( actionBefore , clearAction ) ; menu -> insertSeparator ( actionBefore ) ; clearAction -> setEnabled ( ! m_keySequence . isEmpty ( ) ) ; connect ( clearAction , SIGNAL ( triggered ( ) ) , this , SLOT ( slotClearShortcut ( ) ) ) ; menu -> exec ( c -> globalPos ( ) ) ; delete menu ; e -> accept ( ) ; return true ; } return QWidget :: eventFilter ( o , e ) ; }
void QtKeySequenceEdit :: slotClearShortcut ( ) { if ( m_keySequence . isEmpty ( ) ) return ; setKeySequence ( QKeySequence ( ) ) ; emit keySequenceChanged ( m_keySequence ) ; }
void QtKeySequenceEdit :: handleKeyEvent ( QKeyEvent * e ) { int nextKey = e -> key ( ) ; if ( nextKey == Qt :: Key_Control || nextKey == Qt :: Key_S@@ hift || nextKey == Qt :: Key_Meta || nextKey == Qt :: Key_Alt || nextKey == Qt :: Key_S@@ uper@@ _L || nextKey == Qt :: Key_Alt@@ Gr ) return ; nextKey |= translateModifiers ( e -> modifiers ( ) , e -> text ( ) ) ; int k0 = m_keySequence [ 0 ] ; int k1 = m_keySequence [ 1 ] ; int k2 = m_keySequence [ 2 ] ; int k3 = m_keySequence [ 3 ] ; switch ( m_num ) { case 0 : k0 = nextKey ; k1 = 0 ; k2 = 0 ; k3 = 0 ; break ; case 1 : k1 = nextKey ; k2 = 0 ; k3 = 0 ; break ; case 2 : k2 = nextKey ; k3 = 0 ; break ; case 3 : k3 = nextKey ; break ; default : break ; } ++ m_num ; if ( m_num > 3 ) m_num = 0 ; m_keySequence = QKeySequence ( k0 , k1 , k2 , k3 ) ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; e -> accept ( ) ; emit keySequenceChanged ( m_keySequence ) ; }
void QtKeySequenceEdit :: setKeySequence ( const QKeySequence & sequence ) { if ( sequence == m_keySequence ) return ; m_num = 0 ; m_keySequence = sequence ; m_lineEdit -> setText ( m_keySequence . toString ( QKeySequence :: NativeText ) ) ; }
void QtKeySequenceEdit :: focusInEvent ( QFocusEvent * e ) { m_lineEdit -> event ( e ) ; m_lineEdit -> selectAll ( ) ; QWidget :: focusInEvent ( e ) ; }
void QtKeySequenceEdit :: focusOutEvent ( QFocusEvent * e ) { m_num = 0 ; m_lineEdit -> event ( e ) ; QWidget :: focusOutEvent ( e ) ; }
void QtKeySequenceEdit :: keyPressEvent ( QKeyEvent * e ) { handleKeyEvent ( e ) ; e -> accept ( ) ; }
void QtKeySequenceEdit :: keyRelease@@ Event ( QKeyEvent * e ) { m_lineEdit -> event ( e ) ; }
void QtKeySequenceEdit :: paintEvent ( QPaintEvent * ) { QStyleOption opt ; opt . init ( this ) ; QPainter p ( this ) ; style ( ) -> drawPrimitive ( QStyle :: PE_Widget , & opt , & p , this ) ; }
bool QtKeySequenceEdit :: event ( QEvent * e ) { if ( e -> type ( ) == QEvent :: Shortcut || e -> type ( ) == QEvent :: ShortcutOverride || e -> type ( ) == QEvent :: KeyRelease ) { e -> accept ( ) ; return true ; } return QWidget :: event ( e ) ; }
void LetPropertiesOpt :: optimizeLetPropertyAccess ( VarDecl * Property , const InitSequence & init ) { assert ( init . isValid ( ) ) ; if ( SkipProcessing . count ( Property ) ) return ; auto * Ty = dyn_cast < NominalTypeDecl > ( Property -> getDeclContext ( ) ) ; if ( SkipTypeProcessing . count ( Ty ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Repla@@ cing ▁ access ▁ to ▁ property ▁ ' " << * Property << " ' ▁ by ▁ its ▁ constant ▁ initializer \n " ) ; auto PropertyAccess = Property -> getEffectiveAccess ( ) ; auto TypeAccess = Ty -> getEffectiveAccess ( ) ; auto CanRemove = false ; if ( TypeAccess <= AccessLevel :: FilePrivate || PropertyAccess <= AccessLevel :: FilePrivate || ( ( TypeAccess <= AccessLevel :: Internal || PropertyAccess <= AccessLevel :: Internal ) && Module -> isWholeModule ( ) ) ) { CanRemove = true ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Storage ▁ for ▁ property ▁ ' " << * Property << " ' ▁ can ▁ be ▁ elimin@@ ated \n " ) ; } if ( CannotRemove . count ( Property ) ) CanRemove = false ; if ( ! AccessMap . count ( Property ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ never ▁ read \n " ) ; if ( CanRemove ) { } return ; } auto & Loads = AccessMap [ Property ] ; unsigned NumReplaced = 0 ; for ( auto Load : Loads ) { SILFunction * F = Load -> getFunction ( ) ; auto cloneInitAt = [ & ] ( SILInstruction * insertionPoint ) -> SILValue { InitSequenceCloner cloner ( init , insertionPoint ) ; return cloner . clone ( ) ; } ; if ( isa < RefElementAddrInst > ( Load ) || isa < StructElementAddrInst > ( Load ) || isa < BeginAccessInst > ( Load ) ) { auto proj = cast < SingleValueInstruction > ( Load ) ; SILValue clonedInit = cloneInitAt ( proj ) ; SILBuilder@@ WithScope B ( proj ) ; for ( auto UI = proj -> use_begin ( ) , E = proj -> use_end ( ) ; UI != E ; ) { auto * User = UI -> getUser ( ) ; ++ UI ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( isa < StoreInst > ( User ) ) continue ; replaceLoadSequence ( User , clonedInit , B ) ; erase@@ Uses@@ OfInstruction ( User ) ; User -> eraseFromParent ( ) ; ++ NumReplaced ; } ChangedFunctions . insert ( F ) ; } else if ( auto proj = dyn_cast < StructExtractInst > ( Load ) ) { SILValue clonedInit = cloneInitAt ( proj ) ; proj -> replaceAllUses@@ With ( clonedInit ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced : \n " ; clonedInit -> dumpInContext ( ) ) ; proj -> eraseFromParent ( ) ; ++ NumReplaced ; ChangedFunctions . insert ( F ) ; } } LLVM_DEBUG ( llvm :: dbgs ( ) << " Access ▁ to ▁ " << * Property << " ▁ was ▁ replaced ▁ " << NumReplaced << " ▁ time ( s ) \n " ) ; if ( CanRemove ) { } }
bool LetPropertiesOpt :: isConstantLetProperty ( VarDecl * Property ) { if ( ! Property -> isLet ( ) || Property -> isStatic ( ) ) return false ; if ( SkipProcessing . count ( Property ) ) return false ; if ( PotentialConstantLetProperty . count ( Property ) ) return true ; if ( mayHaveUnknownUses ( Property , Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ may ▁ have ▁ unknown ▁ uses \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ has ▁ no ▁ unknown ▁ uses \n " ) ; if ( ! isSimple@@ Type ( Module -> Types . getLower@@ edType ( Property -> getType ( ) ) , * Module ) ) { LLVM_DEBUG ( llvm :: dbgs ( ) << " Property ▁ ' " << * Property << " ' ▁ is ▁ not ▁ of ▁ triv@@ ial ▁ type \n " ) ; SkipProcessing . insert ( Property ) ; return false ; } PotentialConstantLetProperty . insert ( Property ) ; return true ; }
bool LetPropertiesOpt :: analyzeInitValue ( SILInstruction * I , VarDecl * Property ) { SILValue value ; if ( auto SI = dyn_cast < StructInst > ( I ) ) { value = SI -> getField@@ Value ( Property ) ; } else if ( auto SI = dyn_cast < StoreInst > ( I ) ) { auto Dest = stripAddressAccess ( SI -> getDest ( ) ) ; assert ( isProjectionOfProperty ( stripAddressAccess ( SI -> getDest ( ) ) , Property ) && " Store ▁ instruction ▁ should ▁ store ▁ into ▁ a ▁ proper ▁ let ▁ property " ) ; ( void ) Dest ; value = SI -> getSrc ( ) ; } if ( auto * LI = dyn_cast < LoadInst > ( value ) ) { SILValue addr = LI -> getOperand ( ) ; if ( isProjectionOfProperty ( addr , Property ) ) return true ; } InitSequence sequence ; sequence . Result = value ; if ( ! analyzeStaticInitializer ( value , sequence . Instructions ) ) return false ; auto & cachedSequence = InitMap [ Property ] ; if ( cachedSequence . isValid ( ) && ! isSameInitSequence ( cachedSequence , sequence ) ) { return false ; } else { LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ property ▁ ' " << * Property << " ' ▁ is ▁ statically ▁ known ▁ so ▁ far \n " ) ; cachedSequence = std :: move ( sequence ) ; return true ; } }
void LetPropertiesOpt :: collectStructPropertiesAccess ( StructInst * SI , bool NonRemovable ) { auto structDecl = SI -> getStruct@@ Decl ( ) ; if ( SkipTypeProcessing . count ( structDecl ) ) return ; if ( ! NominalTypeLetProperties . count ( structDecl ) ) { SmallVector < VarDecl * , 4 > LetProps ; for ( auto Prop : structDecl -> getStoredProperties ( ) ) { if ( ! isConstantLetProperty ( Prop ) ) continue ; LetProps . push_back ( Prop ) ; } if ( LetProps . empty ( ) ) { SkipTypeProcessing . insert ( structDecl ) ; return ; } NominalTypeLetProperties [ structDecl ] = LetProps ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Computed ▁ set ▁ of ▁ let ▁ properties ▁ for ▁ struct ▁ ' " << structDecl -> getName ( ) << " ' \n " ) ; } auto & Props = NominalTypeLetProperties [ structDecl ] ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Found ▁ a ▁ struct ▁ instruction ▁ initializing ▁ some ▁ " " let ▁ properties : ▁ " ; SI -> dumpInContext ( ) ) ; for ( auto Prop : Props ) { if ( SkipProcessing . count ( Prop ) ) continue ; SILValue PropValue = SI -> getOper@@ andForField ( Prop ) -> get ( ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Check ▁ the ▁ value ▁ of ▁ property ▁ ' " << * Prop << " ' ▁ : " << PropValue << " \n " ) ; if ( ! analyzeInitValue ( SI , Prop ) ) { SkipProcessing . insert ( Prop ) ; LLVM_DEBUG ( llvm :: dbgs ( ) << " The ▁ value ▁ of ▁ a ▁ let ▁ property ▁ ' " << * Prop << " ' ▁ is ▁ not ▁ statically ▁ known \n " ) ; } ( void ) PropValue ; } }
void LetPropertiesOpt :: collectPropertyAccess ( SILInstruction * I , VarDecl * Property , bool NonRemovable ) { if ( ! isConstantLetProperty ( Property ) ) return ; LLVM_DEBUG ( llvm :: dbgs ( ) << " Collecting ▁ property ▁ access ▁ for ▁ property ▁ ' " << * Property << " ' : \n " ; llvm :: dbgs ( ) << " The ▁ instructions ▁ are : \n " ; I -> dumpInContext ( ) ) ; if ( isa < RefElementAddrInst > ( I ) || isa < StructElementAddrInst > ( I ) || isa < BeginAccessInst > ( I ) ) { auto projection = cast < SingleValueInstruction > ( I ) ; for ( auto Use : getNonDebugUses ( projection ) ) { auto * User = Use -> getUser ( ) ; if ( isIncidentalUse ( User ) ) continue ; if ( isa < BeginAccessInst > ( User ) ) continue ; if ( auto * SI = dyn_cast < StoreInst > ( User ) ) { if ( SI -> getDest ( ) != projection || ! analyzeInitValue ( SI , Property ) ) { SkipProcessing . insert ( Property ) ; return ; } continue ; } if ( ! isValidPropertyLoad ( User ) ) { SkipProcessing . insert ( Property ) ; return ; } } } AccessMap [ Property ] . push_back ( I ) ; if ( NonRemovable ) CannotRemove . insert ( Property ) ; }
void LetPropertiesOpt :: run ( SILModuleTransform * T ) { for ( auto & F : * Module ) { bool NonRemovable = ! F . shouldOptim@@ ize ( ) ; for ( auto & BB : F ) { for ( auto & I : BB ) if ( auto * BAI = dyn_cast < BeginAccessInst > ( & I ) ) { if ( auto * REAI = dyn_cast < RefElementAddrInst > ( stripAddressAccess ( BAI ) ) ) { collectPropertyAccess ( BAI , REAI -> getField ( ) , NonRemovable ) ; } } else if ( auto * REAI = dyn_cast < RefElementAddrInst > ( & I ) ) { collectPropertyAccess ( REAI , REAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEI = dyn_cast < StructExtractInst > ( & I ) ) { collectPropertyAccess ( SEI , SEI -> getField ( ) , NonRemovable ) ; } else if ( auto * SEAI = dyn_cast < StructElementAddrInst > ( & I ) ) { collectPropertyAccess ( SEAI , SEAI -> getField ( ) , NonRemovable ) ; } else if ( auto * SI = dyn_cast < StructInst > ( & I ) ) { collectStructPropertiesAccess ( SI , NonRemovable ) ; } } } for ( auto & Init : InitMap ) { optimizeLetPropertyAccess ( Init . first , Init . second ) ; } for ( SILFunction * ChangedFn : ChangedFunctions ) { T -> invalidate@@ Analysis ( ChangedFn , SILAnalysis :: InvalidationKind :: Instructions ) ; } }
SILTransform * swift :: createLetPropertiesOpt ( ) { return new LetPropertiesOptPass ( ) ; }
std :: string HelpRequiringPassphrase ( ) { return pwalletMain && pwalletMain -> IsCrypted ( ) ? " \n requires ▁ wallet ▁ passphrase ▁ to ▁ be ▁ set ▁ with ▁ walletpassphrase ▁ first " : " " ; }
