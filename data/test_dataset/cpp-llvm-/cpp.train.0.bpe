<DOCUMENT_ID="cppisfun/Game@@ Engine/tree/master/fore@@ ign/boost/libs/@@ multi_@@ array/example/@@ subview@@ 2.cpp"> # include " boost / multi _ array . hpp " # include " boost / cstdlib . hpp " int main ( ) { using boost :: extents ; using boost :: indices ; typedef boost :: multi_@@ array < int , 3 > array ; int data [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 } ; const int data_size = 24 ; array myarray ( extents [ 2 ] [ 3 ] [ 4 ] ) ; myarray . assign ( data , data + data_size ) ; typedef boost :: multi_@@ array_types :: index_range range ; array :: array_view < 3 > :: type myview = myarray [ indices [ range ( 0 , 2 ) ] [ range ( 1 , 3 ) ] [ range ( 0 , 4 , 2 ) ] ] ; for ( array :: index i = 0 ; i != 2 ; ++ i ) for ( array :: index j = 0 ; j != 2 ; ++ j ) for ( array :: index k = 0 ; k != 2 ; ++ k ) assert ( myview [ i ] [ j ] [ k ] == myarray [ i ] [ j + 1 ] [ k * 2 ] ) ; return boost :: exit_@@ success ; } </DOCUMENT>
<DOCUMENT_ID="g@@ 3r@@ g/@@ Gold@@ enCh@@ eet@@ ah/tree/master/src/HrPwPlot@@ .cpp"> # include " HrPwPlot . h " # include " MainWindow . h " # include " HrPwWindow . h " # include " RideFile . h " # include " RideItem . h " # include " Zones . h " # include " Settings . h " # include " Colors . h " # include < assert . h > # include < qwt_plot_@@ curve . h > # include < qwt_plot_@@ grid . h > # include < qwt_plot_@@ canvas . h > # include < qwt_plot_@@ marker . h > # include < qwt_text . h > # include < qwt_symbol . h > # include < qwt_legend . h > # include < qwt_series_@@ data . h > static inline double max ( double a , double b ) { if ( a > b ) return a ; else return b ; } HrPwPlot :: HrPwPlot ( MainWindow * mainWindow , HrPwWindow * hrPwWindow ) : QwtPlot ( hrPwWindow ) , hrPwWindow ( hrPwWindow ) , mainWindow ( mainWindow ) , bg ( NULL ) , delay ( - 1 ) , minHr ( 50 ) , minWatt ( 50 ) , maxWatt ( 500 ) , settings ( GC_SETTINGS_@@ CO , GC_SETTINGS_@@ APP ) , unit ( settings . value ( GC_UNIT ) ) { setCanvas@@ Background ( Qt :: white ) ; canvas ( ) -> setFrame@@ Style ( QFrame :: NoFrame ) ; setXTitle ( ) ; regCurve = new QwtPlotCurve ( " reg " ) ; regCurve -> setPen ( QPen ( GColor ( CPLOT@@ MARKER ) ) ) ; regCurve -> attach ( this ) ; wattsStepCurve = new QwtPlotCurve ( " Power " ) ; wattsStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; wattsStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor wattsColor = QColor ( 200 , 200 , 255 ) ; QColor wattsColor2 = QColor ( 100 , 100 , 255 ) ; wattsStepCurve -> setPen ( QPen ( wattsColor2 ) ) ; wattsStepCurve -> setBrush ( QBrush ( wattsColor ) ) ; wattsStepCurve -> attach ( this ) ; hrStepCurve = new QwtPlotCurve ( " Hr " ) ; hrStepCurve -> setStyle ( QwtPlotCurve :: Steps ) ; hrStepCurve -> setRenderHint ( QwtPlotItem :: RenderAntialiased ) ; QColor hrColor = QColor ( 255 , 200 , 200 ) ; QColor hrColor2 = QColor ( 255 , 100 , 100 ) ; hrStepCurve -> setPen ( QPen ( hrColor2 ) ) ; hrStepCurve -> setBrush ( QBrush ( hrColor ) ) ; hrStepCurve -> attach ( this ) ; hrCurves . resize ( 36 ) ; for ( int i = 0 ; i < 36 ; ++ i ) { hrCurves [ i ] = new QwtPlotCurve ; hrCurves [ i ] -> attach ( this ) ; } grid = new QwtPlotGrid ( ) ; grid -> enableX ( false ) ; QPen gridPen ; gridPen . setStyle ( Qt :: DotLine ) ; gridPen . setColor ( GColor ( CPLOT@@ GRID ) ) ; grid -> setPen ( gridPen ) ; grid -> attach ( this ) ; r_mrk1 = new QwtPlotMarker ; r_mrk2 = new QwtPlotMarker ; r_mrk1 -> attach ( this ) ; r_mrk2 -> attach ( this ) ; shade@@ _zones = true ; } struct DataPoint { double time , hr , watts ; int inter ; DataPoint ( double t , double h , double w , int i ) : time ( t ) , hr ( h ) , watts ( w ) , inter ( i ) { } } ; void HrPwPlot :: setAxisTitle ( int axis , QString label ) { QFont stGiles ; stGiles . fromString ( appsettings -> value ( this , GC_FONT_CHARTLAB@@ ELS , QFont ( ) . toString ( ) ) . toString ( ) ) ; stGiles . setPointSize ( appsettings -> value ( NULL , GC_FONT_CHARTLAB@@ ELS_SIZE , 8 ) . toInt ( ) ) ; QwtText title ( label ) ; title . setFont ( stGiles ) ; QwtPlot :: setAxisFont ( axis , stGiles ) ; QwtPlot :: setAxisTitle ( axis , title ) ; } void HrPwPlot :: recalc ( ) { if ( timeArray . count ( ) == 0 ) return ; int rideTimeSecs = ( int ) ceil ( timeArray [ arrayLength - 1 ] ) ; if ( rideTimeSecs > 7 * 24 * 60 * 60 ) { return ; } double totalWatts = 0.0 ; double totalHr = 0.0 ; QList < DataPoint * > list ; int i = 0 ; QVector < double > smoothWatts ( rideTimeSecs + 1 ) ; QVector < double > smoothHr ( rideTimeSecs + 1 ) ; QVector < double > smoothTime ( rideTimeSecs + 1 ) ; int decal = 0 ; int smooth = hrPwWindow -> smooth ; for ( int secs = smooth ; secs <= rideTimeSecs ; ++ secs ) { while ( ( i < arrayLength ) && ( timeArray [ i ] <= secs ) ) { DataPoint * dp = new DataPoint ( timeArray [ i ] , hrArray [ i ] , wattsArray [ i ] , interArray [ i ] ) ; totalWatts += wattsArray [ i ] ; totalHr += hrArray [ i ] ; list . append ( dp ) ; ++ i ; } while ( ! list . empty ( ) && ( list . front ( ) -> time < secs - smooth ) ) { DataPoint * dp = list . front ( ) ; list . removeFirst ( ) ; totalWatts -= dp -> watts ; totalHr -= dp -> hr ; delete dp ; } if ( list . empty ( ) ) { ++ decal ; } else { smoothWatts [ secs - decal ] = totalWatts / list . size ( ) ; smoothHr [ secs - decal ] = totalHr / list . size ( ) ; } smoothTime [ secs ] = secs / 60.0 ; } rideTimeSecs = rideTimeSecs - decal ; smoothWatts . resize ( rideTimeSecs ) ; smoothHr . resize ( rideTimeSecs ) ; QVector < double > clipWatts ( rideTimeSecs ) ; QVector < double > clipHr ( rideTimeSecs ) ; decal = 0 ; for ( int secs = 0 ; secs < rideTimeSecs ; ++ secs ) { if ( smoothHr [ secs ] >= minHr && smoothWatts [ secs ] >= minWatt && smoothWatts [ secs ] < maxWatt ) { clipWatts [ secs - decal ] = smoothWatts [ secs ] ; clipHr [ secs - decal ] = smoothHr [ secs ] ; } else decal ++ ; } rideTimeSecs = rideTimeSecs - decal ; clipWatts . resize ( rideTimeSecs ) ; clipHr . resize ( rideTimeSecs ) ; if ( delay == - 1 ) delay = hrPwWindow -> findDelay ( clipWatts , clipHr , clipWatts . size ( ) ) ; QVector < double > delayWatts ( rideTimeSecs - delay ) ; QVector < double > delayHr ( rideTimeSecs - delay ) ; for ( int secs = 0 ; secs < rideTimeSecs - delay ; ++ secs ) { delayWatts [ secs ] = clipWatts [ secs ] ; delayHr [ secs ] = clipHr [ secs + delay ] ; } rideTimeSecs = rideTimeSecs - delay ; double rpente = hrPwWindow -> pente ( delayWatts , delayHr , delayWatts . size ( ) ) ; double rordonnee = hrPwWindow -> ordonnee ( delayWatts , delayHr , delayWatts . size ( ) ) ; double maxr = hrPwWindow -> corr ( delayWatts , delayHr , delayWatts . size ( ) ) ; int intpoints = 10 ; int nbpoints = ( int ) floor ( rideTimeSecs / intpoints ) ; QVector < double > plotedWatts ( nbpoints ) ; QVector < double > plotedHr ( nbpoints ) ; for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { plotedWatts [ secs ] = clipWatts [ secs * intpoints ] ; plotedHr [ secs ] = clipHr [ secs * intpoints ] ; } int nbpoints2 = ( int ) floor ( nbpoints / 36 ) + 2 ; double * plotedWattsArray [ 36 ] ; double * plotedHrArray [ 36 ] ; for ( int i = 0 ; i < 36 ; ++ i ) { plotedWattsArray [ i ] = new double [ nbpoints2 ] ; plotedHrArray [ i ] = new double [ nbpoints2 ] ; } for ( int secs = 0 ; secs < nbpoints ; ++ secs ) { for ( int i = 0 ; i < 36 ; ++ i ) { if ( secs >= i * nbpoints2 && secs < ( i + 1 ) * nbpoints2 ) { plotedWattsArray [ i ] [ secs - i * nbpoints2 ] = plotedWatts [ secs - i ] ; plotedHrArray [ i ] [ secs - i * nbpoints2 ] = plotedHr [ secs - i ] ; } } } for ( int i = 0 ; i < 36 ; ++ i ) { if ( nbpoints - i * nbpoints2 > 0 ) { hrCurves [ i ] -> setData ( plotedWattsArray [ i ] , plotedHrArray [ i ] , ( nbpoints - i * nbpoints2 < nbpoints2 ? nbpoints - i * nbpoints2 : nbpoints2 ) ) ; hrCurves [ i ] -> setVisible ( true ) ; } else hrCurves [ i ] -> setVisible ( false ) ; } setAxisScale ( xBottom , 0.0 , maxWatt ) ; setYMax ( ) ; refreshZoneLabels ( ) ; QString labelp ; labelp . setNum ( rpente , ' f ' , 3 ) ; QString labelo ; labelo . setNum ( rordonnee , ' f ' , 1 ) ; QString labelr ; labelr . setNum ( maxr , ' f ' , 3 ) ; QString labeldelay ; labeldelay . setNum ( delay ) ; int power150 = ( int ) floor ( ( 150 - rordonnee ) / rpente ) ; QString labelpower150 ; labelpower150 . setNum ( power150 ) ; QwtText textr = QwtText ( labelp + " * x + " + labelo + " ▁ : ▁ R ▁ " + labelr + " ▁ ( " + labeldelay + " ) ▁ \n ▁ Power @ 150 : " + labelpower150 + " W " ) ; textr . setFont ( QFont ( " Helvetica " , 10 , QFont :: Bold ) ) ; textr . setColor ( Qt :: black ) ; r_mrk1 -> setValue ( 0 , 0 ) ; r_mrk1 -> setLineStyle ( QwtPlotMarker :: VLine ) ; r_mrk1 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk1 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennewatt = hrPwWindow -> moyenne ( clipWatts , clipWatts . size ( ) ) ; r_mrk1 -> setValue ( moyennewatt , 0.0 ) ; r_mrk1 -> setLabel ( textr ) ; r_mrk2 -> setValue ( 0 , 0 ) ; r_mrk2 -> setLineStyle ( QwtPlotMarker :: HLine ) ; r_mrk2 -> setLabelAlignment ( Qt :: AlignRight | Qt :: AlignTop ) ; r_mrk2 -> setLinePen ( QPen ( Qt :: black , 0 , Qt :: DashDotLine ) ) ; double moyennehr = hrPwWindow -> moyenne ( clipHr , clipHr . size ( ) ) ; r_mrk2 -> setValue ( 0.0 , moyennehr ) ; addWattStepCurve ( clipWatts , clipWatts . size ( ) ) ; addHrStepCurve ( clipHr , clipHr . size ( ) ) ; addRegLinCurve ( rpente , rordonnee ) ; setJoinLine ( joinLine ) ; rep@@ lot ( ) ; } void HrPwPlot :: setYMax ( ) { double ymax = 0 ; QString ylabel = " " ; for ( int i = 0 ; i < 36 ; ++ i ) { if ( hrCurves [ i ] -> isVisible ( ) ) { ymax = max ( ymax , hrCurves [ i ] -> maxYValue ( ) ) ; } } setAxisScale ( yLeft , minHr , ymax * 1.2 ) ; setAxisTitle ( yLeft , tr ( " Heart ▁ Rate ( BP@@ M ) " ) ) ; } void HrPwPlot :: addWattStepCurve ( QVector < double > & finalWatts , int nbpoints ) { QMap < double , double > powerHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( powerHist . contains ( finalWatts [ h ] ) ) powerHist [ finalWatts [ h ] ] += 1 ; else powerHist [ finalWatts [ h ] ] = 1 ; } int maxPower = 500 ; double * array = new double [ maxPower ] ; for ( int i = 0 ; i < maxPower ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > k ( powerHist ) ; while ( k . hasNext ( ) ) { k . next ( ) ; array [ ( int ) round ( k . key ( ) ) ] += k . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxPower - 1 ) / 10 ) ; QVector < double > smoothWattsStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 10 ; int high = low + 10 ; smoothWattsStep [ t ] = low ; smoothTimeStep [ t ] = minHr ; while ( low < high ) { smoothTimeStep [ t ] += array [ low ++ ] / nbpoints * 300 ; } } smoothTimeStep [ t ] = 0.0 ; smoothWattsStep [ t ] = t * 10 ; wattsStepCurve -> setData ( smoothWattsStep . data ( ) , smoothTimeStep . data ( ) , nbSteps + 1 ) ; } void HrPwPlot :: addHrStepCurve ( QVector < double > & finalHr , int nbpoints ) { QMap < double , double > hrHist ; for ( int h = 0 ; h < nbpoints ; ++ h ) { if ( hrHist . contains ( finalHr [ h ] ) ) hrHist [ finalHr [ h ] ] += 1 ; else hrHist [ finalHr [ h ] ] = 1 ; } int maxHr = 220 ; double * array = new double [ maxHr ] ; for ( int i = 0 ; i < maxHr ; ++ i ) array [ i ] = 0.0 ; QMapIterator < double , double > l ( hrHist ) ; while ( l . hasNext ( ) ) { l . next ( ) ; array [ ( int ) round ( l . key ( ) ) ] += l . value ( ) ; } int nbSteps = ( int ) ceil ( ( maxHr - 1 ) / 2 ) ; QVector < double > smoothHrStep ( nbSteps + 1 ) ; QVector < double > smoothTimeStep2 ( nbSteps + 1 ) ; int t ; for ( t = 1 ; t < nbSteps ; ++ t ) { int low = t * 2 ; int high = low + 2 ; smoothHrStep [ t ] = low ; smoothTimeStep2 [ t ] = 0.0 ; while ( low < high ) { smoothTimeStep2 [ t ] += array [ low ++ ] / nbpoints * 500 ; } } smoothTimeStep2 [ t ] = 0.0 ; smoothHrStep [ t ] = t * 2 ; hrStepCurve -> setData ( smoothTimeStep2 . data ( ) , smoothHrStep . data ( ) , nbSteps + 1 ) ; } void HrPwPlot :: addRegLinCurve ( double rpente , double rordonnee ) { double regWatts [ ] = { 0 , 0 } ; double regHr [ ] = { 0 , 500 } ; regWatts [ 0 ] = regHr [ 0 ] * rpente + rordonnee ; regWatts [ 1 ] = regHr [ 1 ] * rpente + rordonnee ; regCurve -> setData ( regHr , regWatts , 2 ) ; } void HrPwPlot :: setXTitle ( ) { setAxisTitle ( xBottom , tr ( " Power ▁ ( Watts ) " ) ) ; } void HrPwPlot :: setData@@ FromRide ( RideItem * _rideItem ) { rideItem = _rideItem ; if ( ! _rideItem || ! _rideItem -> ride ( ) ) return ; RideFile * ride = rideItem -> ride ( ) ; const RideFile@@ DataPresent * dataPresent = ride -> areDataPresent ( ) ; int npoints = ride -> dataPoints ( ) . size ( ) ; if ( dataPresent -> watts && dataPresent -> hr ) { wattsArray . resize ( npoints ) ; hrArray . resize ( npoints ) ; timeArray . resize ( npoints ) ; interArray . resize ( npoints ) ; arrayLength = 0 ; foreach ( const RideFile@@ Point * point , ride -> dataPoints ( ) ) { if ( ! timeArray . empty ( ) ) timeArray [ arrayLength ] = point -> secs ; if ( ! wattsArray . empty ( ) ) wattsArray [ arrayLength ] = max ( 0 , point -> watts ) ; if ( ! hrArray . empty ( ) ) hrArray [ arrayLength ] = max ( 0 , point -> hr ) ; if ( ! interArray . empty ( ) ) interArray [ arrayLength ] = point -> interval ; ++ arrayLength ; } delay = - 1 ; recalc ( ) ; } } void HrPwPlot :: setJoinLine ( bool value ) { joinLine = value ; for ( int i = 0 ; i < 36 ; ++ i ) { QColor color = QColor ( 255 , 255 , 255 ) ; color . setHsv ( 60 + i * ( 360 / 36 ) , 255 , 255 , 255 ) ; if ( value ) { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: NoSymbol ) ; QPen pen = QPen ( color ) ; pen . setWidth ( 1 ) ; hrCurves [ i ] -> setPen ( pen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Lines ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } else { QwtSymbol sym ; sym . setStyle ( QwtSymbol :: Ellipse ) ; sym . setSize ( 5 ) ; sym . setPen ( QPen ( color ) ) ; sym . setBrush ( QBrush ( color ) ) ; hrCurves [ i ] -> setPen ( Qt :: NoPen ) ; hrCurves [ i ] -> setStyle ( QwtPlotCurve :: Dots ) ; hrCurves [ i ] -> setSymbol ( new QwtSymbol ( sym ) ) ; } } } void HrPwPlot :: pointHover ( QwtPlotCurve * curve , int index ) { if ( index >= 0 ) { double yvalue = curve -> sample ( index ) . y ( ) ; double xvalue = curve -> sample ( index ) . x ( ) ; QString text = QString ( " % 1 ▁ % 2 \n % 3 ▁ % 4" ) . arg ( yvalue , 0 , ' f ' , 0 ) . arg ( this -> axisTitle ( curve -> yAxis ( ) ) . text ( ) ) . arg ( xvalue , 0 , ' f ' , 2 ) . arg ( this -> axisTitle ( curve -> xAxis ( ) ) . text ( ) ) ; tooltip -> setText ( text ) ; } else { tooltip -> setText ( " " ) ; } } class HrPwPlotBackground : public QwtPlotItem { private : HrPwPlot * parent ; public : HrPwPlotBackground ( HrPwPlot * _parent ) { setZ ( 0.0 ) ; parent = _parent ; } virtual int rtti ( ) const { return QwtPlotItem :: Rtti_PlotUserItem ; } virtual void draw ( QPainter * painter , const QwtScaleMap & xMap , const QwtScaleMap & , const QRectF & rect ) const { RideItem * rideItem = parent -> rideItem ; if ( ! rideItem ) return ; const Zones * zones = rideItem -> zones ; int zone_range = rideItem -> zoneRange ( ) ; if ( parent -> isShadeZones ( ) && zones && ( zone_range >= 0 ) ) { QList < int > zone_lows = zones -> getZoneLows ( zone_range ) ; int num_zones = zone_lows . size ( ) ; if ( num_zones > 0 ) { for ( int z = 0 ; z < num_zones ; z ++ ) { QRectF r = rect ; QColor shading_color = zoneColor ( z , num_zones ) ; shading_color . setHsv ( shading_color . hue ( ) , shading_color . sat@@ uration ( ) / 4 , shading_color . value ( ) ) ; r . setLeft ( xMap . transform ( zone_lows [ z ] ) ) ; if ( z + 1 < num_zones ) r . setRight ( xMap . transform ( zone_lows [ z + 1 ] ) ) ; if ( r . left ( ) <= r . right ( ) ) painter -> fillRect ( r , shading_color ) ; } } } } } ; class HrPwPlotZoneLabel : public QwtPlotItem { private : HrPwPlot * parent ; int zone_number ; double watts ; QwtText text ; public : HrPwPlotZoneLabel ( HrPwPlot * _parent , int _zone_number ) { parent = _parent ; zone_number = _zone_number ; RideItem * rideItem = parent -> rideItem ; if ( ! rideItem ) return ; const Zones * zones = rideItem -> zones ; int zone_range = rideItem -> zoneRange ( ) ; if ( parent -> isShadeZones ( ) && zones && ( zone_range >= 0 ) ) { QList < int > zone_lows = zones -> getZoneLows ( zone_range ) ; QList < QString > zone_names = zones -> getZone@@ Names ( zone_range ) ; int num_zones = zone_lows . size ( ) ; assert ( zone_names . size ( ) == num_zones ) ; if ( zone_number < num_zones ) { watts = ( ( zone_number + 1 < num_zones ) ? 0.5 * ( zone_lows [ zone_number ] + zone_lows [ zone_number + 1 ] ) : ( ( zone_number > 0 ) ? ( 1.5 * zone_lows [ zone_number ] - 0.5 * zone_lows [ zone_number - 1 ] ) : 2.0 * zone_lows [ zone_number ] ) ) ; text = QwtText ( zone_names [ zone_number ] ) ; text . setFont ( QFont ( " Helvetica " , 24 , QFont :: Bold ) ) ; QColor text_color = zoneColor ( zone_number , num_zones ) ; text_color . setAlpha ( 64 ) ; text . setColor ( text_color ) ; } } setZ ( 1.0 + zone_number / 100.0 ) ; } virtual int rtti ( ) const { return QwtPlotItem :: Rtti_PlotUserItem ; } void draw ( QPainter * painter , const QwtScaleMap & xMap , const QwtScaleMap & , const QRectF & rect ) const { if ( parent -> isShadeZones ( ) ) { int y = ( rect . bottom ( ) + rect . top ( ) ) / 2 ; int x = xMap . transform ( watts ) ; QRect tr ( QPoint ( 0 , 0 ) , text . textSize ( painter -> font ( ) ) . toSize ( ) ) ; tr . moveCenter ( QPoint ( x , y ) ) ; text . draw ( painter , tr ) ; } } } ; int HrPwPlot :: isShadeZones ( ) const { return ( shadeZones && ! wattsArray . empty ( ) ) ; } void HrPwPlot :: setShadeZones ( int x ) { shadeZones = x ; } void HrPwPlot :: refreshZoneLabels ( ) { foreach ( HrPwPlotZoneLabel * label , zoneLabels ) { label -> detach ( ) ; delete label ; } zoneLabels . clear ( ) ; if ( bg ) { bg -> detach ( ) ; delete bg ; bg = NULL ; } if ( rideItem ) { int zone_range = rideItem -> zoneRange ( ) ; const Zones * zones = rideItem -> zones ; if ( zones && ( zone_range >= 0 ) ) { int num_zones = zones -> numZones ( zone_range ) ; for ( int z = 0 ; z < num_zones ; z ++ ) { HrPwPlotZoneLabel * label = new HrPwPlotZoneLabel ( this , z ) ; label -> attach ( this ) ; zoneLabels . append ( label ) ; } } } bg = new HrPwPlotBackground ( this ) ; bg -> attach ( this ) ; } </DOCUMENT>
<DOCUMENT_ID="s@@ jsinju@@ /coreclr/tree/master/src/@@ pal@@ /tests/@@ pal@@ suite/c_@@ runtime/fmod@@ /test1/test1.cpp"> # include < pal@@ suite . h > # define PAL_EPSILON 8.881@@ 78419700@@ 1252@@ 3e - 16 # define PAL_NAN sqrt ( - 1.0 ) # define PAL_POSINF - log ( 0.0 ) # define PAL_NEGINF log ( 0.0 ) struct test { double numerator ; double denominator ; double expected ; double variance ; } ; void __cdecl validate ( double numerator , double denominator , double expected , double variance ) { double result = fmod ( numerator , denominator ) ; double delta = fabs ( result - expected ) ; if ( delta > variance ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , expected ) ; } } void __cdecl validate_isnan ( double numerator , double denominator ) { double result = fmod ( numerator , denominator ) ; if ( ! _isnan ( result ) ) { Fail ( " fmod ( % g , ▁ % g ) ▁ returned ▁ % 20.17g ▁ when ▁ it ▁ should ▁ have ▁ returned ▁ % 20.17g " , numerator , denominator , result , PAL_NAN ) ; } } INT __cdecl main ( INT argc , CHAR * * argv ) { struct test tests [ ] = { { 0 , PAL_POSINF , 0 , PAL_EPSILON } , { 0.312961796207786@@ 59 , 0.94976@@ 57153816@@ 3866 , 0.312961796207786@@ 58 , PAL_EPSILON } , { 0.42077048331375@@ 735 , 0.90@@ 7167129@@ 2390@@ 9839 , 0.42077048331375@@ 733 , PAL_EPSILON } , { 0.5944807685248@@ 2208 , 0.80@@ 410@@ 9828@@ 22879@@ 171 , 0.5944807685248@@ 2212 , PAL_EPSILON } , { 0.6389612763136@@ 3480 , 0.769@@ 238@@ 90136@@ 3972@@ 13 , 0.6389612763136@@ 3475 , PAL_EPSILON } , { 0.649636939080062@@ 44 , 0.76024@@ 45970756@@ 3015 , 0.649636939080062@@ 48 , PAL_EPSILON } , { 0.70710678118654752 , 0.70710678118654752 , 0 , PAL_EPSILON } , { 1 , 1 , 0 , PAL_EPSILON } , { 0.84@@ 147098480@@ 789651 , 0.54030@@ 230@@ 586@@ 8139@@ 72 , 0.30116@@ 86789@@ 39756@@ 74 , PAL_EPSILON } , { 0.90@@ 37194574@@ 35846@@ 30 , 0.42@@ 8125@@ 147885357@@ 92 , 0.047469@@ 1616@@ 65130@@ 377 , PAL_EPSILON / 10 } , { 0.98@@ 776594599@@ 273553 , 0.155@@ 94369476@@ 537447 , 0.052103@@ 7774@@ 0048@@ 8605 , PAL_EPSILON / 10 } , { 0.99@@ 1806@@ 24439@@ 366372 , 0.127@@ 751217@@ 535239@@ 91 , 0.09@@ 75477216@@ 4698@@ 4359 , PAL_EPSILON / 10 } , { 0.74@@ 3980@@ 336957@@ 49319 , - 0.66820@@ 1510190312@@ 95 , 0.0757788@@ 2676718@@ 0285 , PAL_EPSILON / 10 } , { 0.41078129050@@ 2908@@ 70 , - 0.911@@ 73391478696@@ 510 , 0.41078129050@@ 290868 , PAL_EPSILON } , { 0 , - 1 , 0 , PAL_EPSILON } , { 1 , PAL_POSINF , 1 , PAL_EPSILON * 10 } , } ; if ( PAL_Initialize ( argc , argv ) != 0 ) { return FAIL ; } for ( int i = 0 ; i < ( sizeof ( tests ) / sizeof ( struct test ) ) ; i ++ ) { validate ( tests [ i ] . numerator , tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; validate ( tests [ i ] . numerator , - tests [ i ] . denominator , tests [ i ] . expected , tests [ i ] . variance ) ; validate ( - tests [ i ] . numerator , - tests [ i ] . denominator , - tests [ i ] . expected , tests [ i ] . variance ) ; } validate_isnan ( 0 , 0 ) ; validate_isnan ( - 0.0 , 0 ) ; validate_isnan ( 0 , - 0.0 ) ; validate_isnan ( - 0.0 , - 0.0 ) ; validate_isnan ( 1 , 0 ) ; validate_isnan ( - 1.0 , 0 ) ; validate_isnan ( 1 , - 0.0 ) ; validate_isnan ( - 1.0 , - 0.0 ) ; validate_isnan ( PAL_POSINF , PAL_POSINF ) ; validate_isnan ( PAL_NEGINF , PAL_POSINF ) ; validate_isnan ( PAL_POSINF , PAL_NEGINF ) ; validate_isnan ( PAL_NEGINF , PAL_NEGINF ) ; validate_isnan ( PAL_POSINF , 0 ) ; validate_isnan ( PAL_NEGINF , 0 ) ; validate_isnan ( PAL_POSINF , - 0.0 ) ; validate_isnan ( PAL_NEGINF , - 0.0 ) ; validate_isnan ( PAL_POSINF , 1 ) ; validate_isnan ( PAL_NEGINF , 1 ) ; validate_isnan ( PAL_POSINF , - 1.0 ) ; validate_isnan ( PAL_NEGINF , - 1.0 ) ; PAL_Termin@@ ate ( ) ; return PASS ; } </DOCUMENT>
<DOCUMENT_ID="geo@@ cool@@ /libtmx@@ -par@@ ser/tree/master/@@ src/tmx@@ parser@@ .cpp"> # include " tmxparser . h " # include " base64 . h " # if ( defined ( _WIN32 ) ) # include < string . h > # endif # if ( ( defined ( ANDROID ) ) ) # include < android / log . h > # include < string . h > # else # include < cstdlib > # include < cstdio > # endif # include < algorithm > # include < string > # include < sstream > # ifndef LOG_TAG # define LOG_TAG " libtmxparser " # endif # if defined ( WIN32 ) || defined ( _WIN32 ) # define PATH_SEPARATOR " \\ " # define PATH_SEPARATOR_ALT " / " # else # define PATH_SEPARATOR " / " # define PATH_SEPARATOR_ALT " / " # endif # define QUOTEME_ ( x ) # x # define QUOTEME ( x ) QUOTEME_ ( x ) # define WHEREST@@ R " [ file ▁ % s , ▁ line ▁ % d ] : ▁ " # define WHERE@@ ARG __FILE__ , __LINE__ # if ( ( defined ( ANDROID ) ) ) # ifdef DEBUG # define LOGD ( ... ) __android_log_print ( ANDROID_LOG_@@ DEBUG , LOG_TAG , " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) ▁ " __VA_ARGS__ ) # else # define LOGD ( ... ) # endif # define LOGI ( ... ) __android_log_print ( ANDROID_@@ LOG_INFO , LOG_TAG , " " __VA_ARGS__ ) # define LOGE ( ... ) __android_log_print ( ANDROID_LOG_@@ ERROR , LOG_TAG , __VA_ARGS__ ) # define LOGW ( ... ) __android_log_print ( ANDROID_LOG_@@ WARN , LOG_TAG , __VA_ARGS__ ) # else # ifdef DEBUG # define LOGD ( ... ) fprintf ( stderr , " D / " LOG_TAG " ▁ ( " __FILE__ " : " QUOTEME ( __LINE__ ) " ) : ▁ " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # else # define LOGD ( ... ) # endif # define LOGI ( ... ) fprintf ( stdout , " I / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stdout , " \n " ) ; # define LOGE ( ... ) fprintf ( stderr , " E / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # define LOGW ( ... ) fprintf ( stderr , " W / " QUOTEME ( LOG_TAG ) " ( " " ) " __VA_ARGS__ ) ; fprintf ( stderr , " \n " ) ; # endif namespace tmxparser { # define CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) if ( XMLELEMENT -> Attribute ( ATTRIBNAME ) != NULL ) { LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; } else { LHS = ' \0' ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( XMLELEMENT , ATTRIBNAME , LHS ) LHS = XMLELEMENT -> Attribute ( ATTRIBNAME ) ; if ( LHS . size ( ) == 0 ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return TmxReturn :: kMissingRequiredAttribute ; } # define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( FUNC , ATTRIBNAME , OUT ) if ( FUNC ( ATTRIBNAME , OUT ) == tinyxml2 :: XML_NO_ATTRIBUTE ) { LOGE ( " Missing ▁ required ▁ attribute ▁ [ % s ] " , ATTRIBNAME ) ; return kMissingRequiredAttribute ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) ; TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) ; void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) ; TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) ; TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) ; TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) ; TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) ; TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) ; TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) ; TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) ; TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) ; TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) ; TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) ; TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) ; TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) ; TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) ; TmxReturn parseFromFile ( const std :: string & fileName , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . LoadFile ( fileName . c_str ( ) ) != tinyxml2 :: XML_SUCCESS ) { LOGE ( " Cannot ▁ read ▁ xml ▁ file " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn parseFromMemory ( void * data , size_t length , TmxMap * outMap , const std :: string & tilesetPath ) { tinyxml2 :: XMLDocument doc ; if ( doc . Parse ( ( char * ) data , length ) ) { LOGE ( " Cannot ▁ parse ▁ xml ▁ memory ▁ file . . . " ) ; return TmxReturn :: kErrorParsing ; } return _parseStart ( doc . FirstChildElement ( " map " ) , outMap , tilesetPath ) ; } TmxReturn _parseStart ( tinyxml2 :: XMLElement * element , TmxMap * outMap , const std :: string & tilesetPath ) { TmxReturn retVal = _parseMapNode ( element , outMap ) ; return ( retVal == TmxReturn :: kSuccess ) ? _parseEnd ( outMap , tilesetPath ) : retVal ; } TmxReturn _parseEnd ( TmxMap * outMap , const std :: string & tilesetPath ) { for ( auto tileIt = outMap -> tilesetCollection . begin ( ) ; tileIt != outMap -> tilesetCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; for ( auto tileIt = outMap -> imageLayerCollection . begin ( ) ; tileIt != outMap -> imageLayerCollection . end ( ) ; ++ tileIt ) _parseEndHelper ( tileIt -> image , tilesetPath ) ; return TmxReturn :: kSuccess ; } void _parseEndHelper ( TmxImage & image , const std :: string & tilesetPath ) { auto pathSeperatorMissing = ( image . source . find ( PATH_SEPARATOR ) == std :: string :: npos ) ; auto pathSeperatorAltMissing = ( image . source . find ( PATH_SEPARATOR_ALT ) == std :: string :: npos ) ; if ( pathSeperatorMissing && pathSeperatorAltMissing ) { std :: string baseFilename = image . source . substr ( image . source . find_last_@@ of ( PATH_SEPARATOR ) + 1 ) ; auto seperatorThere = ( tilesetPath . find ( PATH_SEPARATOR ) != std :: string :: npos ) ; auto seperatorAltThere = ( tilesetPath . find ( PATH_SEPARATOR_ALT ) != std :: string :: npos ) ; auto tileSetPathSeparator = PATH_SEPARATOR ; if ( ! seperatorThere && seperatorAltThere ) tileSetPathSeparator = PATH_SEPARATOR_ALT ; image . source = tilesetPath + tileSetPathSeparator + baseFilename ; } } TmxReturn _parseMapNode ( tinyxml2 :: XMLElement * element , TmxMap * outMap ) { if ( element == NULL ) { return TmxReturn :: kMissing@@ MapNode ; } outMap -> version = element -> Attribute ( " version " ) ; const char * orientation = element -> Attribute ( " orientation " ) ; if ( orientation != NULL ) { if ( strcmp ( orientation , " orthogonal " ) == 0 ) { outMap -> orientation = TmxOrientation :: kOrthogonal ; } else if ( strcmp ( orientation , " isometric " ) == 0 ) { outMap -> orientation = TmxOrientation :: kIsomet@@ ric ; } else if ( strcmp ( orientation , " staggered " ) == 0 ) { outMap -> orientation = TmxOrientation :: kSt@@ aggered ; } } else { LOGW ( " Missing ▁ orientation ▁ attribute " ) ; } CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " width " , & outMap -> width ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " height " , & outMap -> height ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outMap -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outMap -> tileHeight ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " background@@ color " , outMap -> background@@ Color ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " renderorder " , outMap -> renderOrder ) ; TmxReturn error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outMap -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ map ▁ properties . . . " ) ; return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tileset " ) ; child != NULL ; child = child -> NextSiblingElement ( " tileset " ) ) { TmxTileset set ; error = _parseTilesetNode ( child , & set ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ tileset ▁ node . . . " ) ; return error ; } outMap -> tilesetCollection . push_back ( set ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " layer " ) ; child != NULL ; child = child -> NextSiblingElement ( " layer " ) ) { TmxLayer layer ; error = _parseLayerNode ( child , outMap -> tilesetCollection , & layer ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ layer ▁ node . . . " ) ; return error ; } outMap -> layer@@ Collection . push_back ( layer ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outMap -> objectGroup@@ Collection . push_back ( group ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " imagelayer " ) ; child != NULL ; child = child -> NextSiblingElement ( " imagelayer " ) ) { TmxImageLayer imageLayer ; error = _parseImageLayerNode ( child , & imageLayer ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ imagelayer ▁ node . . . " ) ; return error ; } outMap -> imageLayerCollection . push_back ( imageLayer ) ; } return error ; } TmxReturn _parsePropertyNode ( tinyxml2 :: XMLElement * element , TmxPropertyMap_t * outPropertyMap ) { if ( element == NULL ) { return TmxReturn :: kSuccess ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " property " ) ; child != NULL ; child = child -> NextSiblingElement ( " property " ) ) { if ( strcmp ( child -> Name ( ) , " property " ) == 0 ) { if ( child -> Attribute ( " name " ) != NULL && child -> Attribute ( " value " ) != NULL ) { ( * outPropertyMap ) [ child -> Attribute ( " name " ) ] = child -> Attribute ( " value " ) ; } else { return TmxReturn :: kMal@@ formed@@ PropertyNode ; } } } return TmxReturn :: kSuccess ; } TmxReturn _parseImageNode ( tinyxml2 :: XMLElement * element , TmxImage * outImage ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " source " , outImage -> source ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " format " , outImage -> format ) ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " trans " , outImage -> transparentColor ) ; outImage -> width = element -> UnsignedAttribute ( " width " ) ; outImage -> height = element -> UnsignedAttribute ( " height " ) ; return TmxReturn :: kSuccess ; } TmxReturn _parseTilesetNode ( tinyxml2 :: XMLElement * element , TmxTileset * outTileset ) { if ( strcmp ( element -> Name ( ) , " tileset " ) == 0 ) { CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " firstgid " , & outTileset -> firstgid ) ; outTileset -> name = element -> Attribute ( " name " ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tilewidth " , & outTileset -> tileWidth ) ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE ( element -> QueryUnsignedAttribute , " tileheight " , & outTileset -> tileHeight ) ; outTileset -> tileSpacingInImage = element -> UnsignedAttribute ( " spacing " ) ; outTileset -> tileMarginInImage = element -> UnsignedAttribute ( " margin " ) ; if ( element -> FirstChildElement ( " image " ) == NULL ) { LOGE ( " We ▁ do ▁ not ▁ support ▁ maps ▁ with ▁ tilesets ▁ that ▁ have ▁ no ▁ image ▁ associated ▁ currently . . . " ) ; return kErrorParsing ; } TmxImage image ; TmxReturn error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outTileset -> image ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ image ▁ node . . . " ) ; return error ; } outTileset -> offset . x = 0 ; outTileset -> offset . y = 0 ; if ( element -> FirstChildElement ( " tileoffset " ) != NULL ) { error = _parseOffsetNode ( element -> FirstChildElement ( " tileoffset " ) , & outTileset -> offset ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxTileDefinition tileDef ; tileDef . id = 0 ; error = _parseTileDefinitionNode ( child , & tileDef ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ tile ▁ definition " ) ; return error ; } outTileset -> tileDefinitions [ tileDef . id ] = tileDef ; } outTileset -> colCount = ( outTileset -> image . width - outTileset -> tileMarginInImage ) / ( outTileset -> tileWidth + outTileset -> tileSpacingInImage ) ; outTileset -> rowCount = ( outTileset -> image . height - outTileset -> tileMarginInImage ) / ( outTileset -> tileHeight + outTileset -> tileSpacingInImage ) ; } return TmxReturn :: kSuccess ; } TmxReturn _parseTileDefinitionNode ( tinyxml2 :: XMLElement * element , TmxTileDefinition * outTileDefinition ) { TmxReturn error = TmxReturn :: kSuccess ; outTileDefinition -> id = element -> UnsignedAttribute ( " id " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outTileDefinition -> propertyMap ) ; if ( error ) { return error ; } if ( element -> FirstChildElement ( " animation " ) != NULL ) { error = _parseTileAnimationNode ( element -> FirstChildElement ( " animation " ) , & outTileDefinition -> animations ) ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " objectgroup " ) ; child != NULL ; child = child -> NextSiblingElement ( " objectgroup " ) ) { TmxObjectGroup group ; error = _parseObjectGroupNode ( child , & group ) ; if ( error ) { LOGE ( " Error ▁ processing ▁ objectgroup ▁ node . . . " ) ; return error ; } outTileDefinition -> objectgroups . push_back ( group ) ; } return error ; } TmxReturn _parseTileAnimationNode ( tinyxml2 :: XMLElement * element , TmxAnimationFrameCollection_t * outAnimationCollection ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " frame " ) ; child != NULL ; child = child -> NextSiblingElement ( " frame " ) ) { TmxAnimation@@ Frame frame ; frame . duration = child -> FloatAttribute ( " duration " ) ; frame . tileId = child -> UnsignedAttribute ( " tileid " ) ; outAnimationCollection -> push_back ( frame ) ; } return kSuccess ; } TmxReturn _parseLayerNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayer * outLayer ) { TmxReturn error = TmxReturn :: kSuccess ; outLayer -> name = element -> Attribute ( " name " ) ; if ( element -> Attribute ( " opacity " ) ) outLayer -> opacity = element -> FloatAttribute ( " opacity " ) ; else outLayer -> opacity = 1 . f ; if ( element -> Attribute ( " visible " ) ) outLayer -> visible = ( element -> IntAttribute ( " visible " ) == 1 ? true : false ) ; else outLayer -> visible = true ; outLayer -> width = element -> UnsignedAttribute ( " width " ) ; outLayer -> height = element -> UnsignedAttribute ( " height " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outLayer -> propertyMap ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ layer ▁ property ▁ node . . . " ) ; return error ; } tinyxml2 :: XMLElement * dataElement = element -> FirstChildElement ( " data " ) ; if ( dataElement != NULL ) { error = _parseLayerDataNode ( dataElement , tilesets , & outLayer -> tiles ) ; } else { LOGE ( " Layer ▁ missing ▁ data ▁ node . . . " ) ; return TmxReturn :: kMissing@@ DataNode ; } return error ; } TmxReturn _parseLayerDataNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTileCollection_t * outTileCollection ) { TmxReturn error = TmxReturn :: kSuccess ; const char * encoding = element -> Attribute ( " encoding " ) ; const char * compression = element -> Attribute ( " compression " ) ; if ( compression != NULL ) { LOGE ( " Does ▁ not ▁ support ▁ compression ▁ yet . . . " ) ; return TmxReturn :: kErrorParsing ; } if ( encoding == NULL ) { for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " tile " ) ; child != NULL ; child = child -> NextSiblingElement ( " tile " ) ) { TmxLayerTile tile ; error = _parseLayerXmlTileNode ( child , tilesets , & tile ) ; outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " csv " ) == 0 ) { std :: stringstream csvss ( element -> FirstChild ( ) -> Value ( ) ) ; unsigned int gid = 0 ; while ( csvss >> gid ) { if ( csvss . peek ( ) == ' , ' || csvss . peek ( ) == ' \n ' ) { csvss . ignore ( ) ; } TmxLayerTile tile ; tile . gid = gid ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else if ( strcmp ( encoding , " base64" ) == 0 ) { std :: string csvbase64 = element -> FirstChild ( ) -> Value ( ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' \n ' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , '' ) , csvbase64 . end ( ) ) ; csvbase64 . erase ( std :: remove ( csvbase64 . begin ( ) , csvbase64 . end ( ) , ' ▁ ' ) , csvbase64 . end ( ) ) ; std :: string csv = base64_de@@ code ( csvbase64 ) ; unsigned int length = csv . size ( ) / sizeof ( unsigned int ) ; unsigned int * p = ( unsigned int * ) csv . c_str ( ) ; for ( unsigned int i = 0 ; i < length ; i ++ ) { TmxLayerTile tile ; tile . gid = p [ i ] ; error = _calculateTileIndices ( tilesets , & tile ) ; if ( error == TmxReturn :: kErrorParsing ) { return error ; } outTileCollection -> push_back ( tile ) ; } } else { LOGE ( " Unsupported ▁ layer ▁ compression ▁ [ % s ] . . . ▁ coming ▁ soon . . . " , encoding ) ; return TmxReturn :: kErrorParsing ; } return error ; } TmxReturn _parseLayerXmlTileNode ( tinyxml2 :: XMLElement * element , const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { TmxReturn error = TmxReturn :: kSuccess ; unsigned int gid = element -> UnsignedAttribute ( " gid " ) ; unsigned int flipXFlag = 0x80000000 ; unsigned int flipYFlag = 0x40000000 ; unsigned int flipDiagonalFlag = 0x20000000 ; outTile -> flipX = ( gid & flipXFlag ? true : false ) ; outTile -> flipY = ( gid & flipYFlag ? true : false ) ; outTile -> flipDiagonal = ( gid & flipDiagonalFlag ? true : false ) ; outTile -> gid = ( gid & ~ ( flipXFlag | flipYFlag | flipDiagonalFlag ) ) ; return _calculateTileIndices ( tilesets , outTile ) ; } TmxReturn _calculateTileIndices ( const TmxTilesetCollection_t & tilesets , TmxLayerTile * outTile ) { outTile -> tilesetIndex = 0 ; outTile -> tileFlatIndex = 0 ; if ( outTile -> gid == 0 ) { return TmxReturn :: kSuccess ; } unsigned int index = 0 ; unsigned int lastEndIndex = 1 ; for ( auto it = tilesets . begin ( ) ; it != tilesets . end ( ) ; ++ it ) { unsigned int colCount = it -> colCount ; unsigned int rowCount = it -> rowCount ; unsigned int startIndex = it -> firstgid ; unsigned int endIndex = it -> firstgid + ( colCount * rowCount ) ; if ( outTile -> gid >= startIndex && outTile -> gid < endIndex ) { outTile -> tilesetIndex = index ; outTile -> tileFlatIndex = ( outTile -> gid ) - lastEndIndex ; return TmxReturn :: kSuccess ; } lastEndIndex = endIndex ; index ++ ; } return TmxReturn :: kUnknown@@ TileIndices ; } TmxReturn _parseObjectGroupNode ( tinyxml2 :: XMLElement * element , TmxObjectGroup * outObjectGroup ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING ( element , " name " , outObjectGroup -> name ) ; if ( element -> Attribute ( " opacity " ) != NULL ) { outObjectGroup -> opacity = element -> FloatAttribute ( " opacity " ) ; } else { outObjectGroup -> opacity = 1.0f ; } if ( element -> Attribute ( " visible " ) != NULL ) { outObjectGroup -> visible = element -> BoolAttribute ( " visible " ) ; } else { outObjectGroup -> visible = true ; } error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObjectGroup -> propertyMap ) ; if ( error ) { return error ; } for ( tinyxml2 :: XMLElement * child = element -> FirstChildElement ( " object " ) ; child != NULL ; child = child -> NextSiblingElement ( " object " ) ) { TmxObject obj ; error = _parseObjectNode ( child , & obj ) ; if ( error ) { LOGE ( " Error ▁ parsing ▁ object ▁ node . . . " ) ; return TmxReturn :: kErrorParsing ; } outObjectGroup -> objects . push_back ( obj ) ; } return error ; } TmxReturn _parseObjectNode ( tinyxml2 :: XMLElement * element , TmxObject * outObj ) { TmxReturn error = TmxReturn :: kSuccess ; if ( element -> Attribute ( " name " ) ) { outObj -> name = element -> Attribute ( " name " ) ; } if ( element -> Attribute ( " type " ) ) { outObj -> type = element -> Attribute ( " type " ) ; } outObj -> x = element -> FloatAttribute ( " x " ) ; outObj -> y = element -> FloatAttribute ( " y " ) ; outObj -> width = element -> FloatAttribute ( " width " ) ; outObj -> height = element -> FloatAttribute ( " height " ) ; outObj -> rotation = element -> FloatAttribute ( " rotation " ) ; outObj -> referenceGid = element -> UnsignedAttribute ( " gid " ) ; outObj -> visible = element -> BoolAttribute ( " visible " ) ; error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outObj -> propertyMap ) ; if ( error ) { return error ; } tinyxml2 :: XMLElement * shapeElement = NULL ; if ( ( shapeElement = element -> FirstChildElement ( " ellipse " ) ) != NULL ) { outObj -> shapeType = kEllipse ; } else if ( ( shapeElement = element -> FirstChildElement ( " polygon " ) ) != NULL ) { outObj -> shapeType = kPolygon ; } else if ( ( shapeElement = element -> FirstChildElement ( " polyline " ) ) != NULL ) { outObj -> shapeType = kPolyline ; } else { outObj -> shapeType = kSquare ; } if ( ( outObj -> shapeType == kPolygon || outObj -> shapeType == kPolyline ) && shapeElement != NULL ) { if ( shapeElement -> Attribute ( " points " ) == NULL ) { LOGE ( " Missing ▁ points ▁ attribute ▁ for ▁ shape ▁ requir@@ ing ▁ one . . . " ) ; return TmxReturn :: kErrorParsing ; } std :: string pointString = shapeElement -> Attribute ( " points " ) ; std :: istringstream pairStringStream ( pointString ) ; std :: string pairToken ; while ( std :: getline ( pairStringStream , pairToken , ' ▁ ' ) ) { TmxShape@@ Point pair ; std :: istringstream pointStringString ( pairToken ) ; std :: string pointToken ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . first = ( float ) atof ( pointToken . c_str ( ) ) ; std :: getline ( pointStringString , pointToken , ' , ' ) ; pair . second = ( float ) atof ( pointToken . c_str ( ) ) ; outObj -> shapePoints . push_back ( pair ) ; } } return error ; } TmxReturn calculateTileCoordin@@ ates@@ UV ( const TmxTileset & tileset , unsigned int tileFlatIndex , float pixelCorrection , bool flipY , TmxRect & outRect ) { if ( tileFlatIndex >= tileset . colCount * tileset . rowCount ) { return TmxReturn :: kInvalid@@ TileIndex ; } TileId_t xIndex = tileFlatIndex % tileset . colCount ; TileId_t yIndex = tileFlatIndex / tileset . colCount ; unsigned int widthDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * xIndex ; unsigned int heightDelta = tileset . tileSpacingInImage + tileset . tileMarginInImage * yIndex ; float u = ( float ) ( ( xIndex * tileset . tileWidth ) + widthDelta + pixelCorrection ) / ( float ) tileset . image . width ; float v = ( float ) ( ( yIndex * tileset . tileHeight ) + heightDelta + pixelCorrection ) / ( float ) tileset . image . height ; float u2 = ( float ) ( ( ( ( xIndex + 1 ) * tileset . tileWidth ) + widthDelta ) - pixelCorrection ) / ( float ) tileset . image . width ; float v2 = ( float ) ( ( ( ( yIndex + 1 ) * tileset . tileHeight ) + heightDelta ) - pixelCorrection ) / ( float ) tileset . image . height ; if ( flipY ) { float tmpV = v ; v = 1 . f - v2 ; v2 = 1 . f - tmpV ; } outRect . u = u ; outRect . v = v ; outRect . u2 = u2 ; outRect . v2 = v2 ; return kSuccess ; } tmxparser :: TmxReturn _parseOffsetNode ( tinyxml2 :: XMLElement * element , TmxOffset * offset ) { TmxReturn error = TmxReturn :: kSuccess ; offset -> x = 0 ; offset -> y = 0 ; if ( element -> Attribute ( " x " ) ) { offset -> x = element -> IntAttribute ( " x " ) ; } if ( element -> Attribute ( " y " ) ) { offset -> y = element -> IntAttribute ( " y " ) ; } return error ; } tmxparser :: TmxReturn _parseImageLayerNode ( tinyxml2 :: XMLElement * element , TmxImageLayer * outImageLayer ) { TmxReturn error = TmxReturn :: kSuccess ; CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING ( element , " name " , outImageLayer -> name ) ; if ( element -> QueryUnsignedAttribute ( " x " , & outImageLayer -> x ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> x = 0U ; if ( element -> QueryUnsignedAttribute ( " y " , & outImageLayer -> y ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> y = 0U ; if ( element -> QueryUnsignedAttribute ( " width " , & outImageLayer -> widthInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> widthInTiles = 0U ; if ( element -> QueryUnsignedAttribute ( " height " , & outImageLayer -> heightInTiles ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> heightInTiles = 0U ; if ( element -> QueryFloatAttribute ( " opacity " , & outImageLayer -> opacity ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> opacity = 1 . f ; if ( element -> QueryBoolAttribute ( " visible " , & outImageLayer -> visible ) == tinyxml2 :: XML_NO_ATTRIBUTE ) outImageLayer -> visible = true ; if ( element -> FirstChildElement ( " properties " ) != NULL ) { error = _parsePropertyNode ( element -> FirstChildElement ( " properties " ) , & outImageLayer -> propertyMap ) ; if ( error != kSuccess ) { LOGE ( " Error ▁ parsing ▁ image ▁ layer ▁ property ▁ node . . . " ) ; return error ; } } if ( element -> FirstChildElement ( " image " ) != NULL ) { error = _parseImageNode ( element -> FirstChildElement ( " image " ) , & outImageLayer -> image ) ; if ( error != kSuccess ) return error ; } return error ; } } </DOCUMENT>
<DOCUMENT_ID="chiri@@ lo/phantomjs/tree/master/src/qt/qtbase/src/@@ gui/doc/snippets/code/src_@@ gui_paint@@ ing_qpainter@@ .cpp"> void SimpleExample@@ Widget :: paintEvent ( QPaintEvent * ) { QPainter painter ( this ) ; painter . setPen ( Qt :: blue ) ; painter . setFont ( QFont ( " Arial " , 30 ) ) ; painter . drawText ( rect ( ) , Qt :: AlignCenter , " Qt " ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ; p . begin ( this ) ; p . drawLine ( ... ) ; p . end ( ) ; } void MyWidget :: paintEvent ( QPaintEvent * ) { QPainter p ( this ) ; p . drawLine ( ... ) ; } painter -> begin ( 0 ) ; QPixmap image ( 0 , 0 ) ; painter -> begin ( & image ) ; painter -> begin ( myWidget ) ; painter@@ 2 -> begin ( myWidget ) ; void QPainter :: rotate ( qreal angle ) { QMatrix matrix ; matrix . rotate ( angle ) ; setWorld@@ Matrix ( matrix , true ) ; } QPainterPath path ; path . moveTo ( 20 , 80 ) ; path . lineTo ( 20 , 30 ) ; path . cubicTo ( 80 , 0 , 50 , 50 , 80 , 80 ) ; QPainter painter ( this ) ; painter . drawPath ( path ) ; QLine@@ F line ( 10.0 , 80.0 , 90.0 , 20.0 ) ; QPainter ( this ) ; painter . drawLine ( line ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRect ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawRound@@ edRect ( rectangle , 20.0 , 15.0 ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QPainter painter ( this ) ; painter . drawEllipse ( rectangle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawArc ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawPi@@ e ( rectangle , startAngle , spanAngle ) ; QRectF rectangle ( 10.0 , 20.0 , 80.0 , 60.0 ) ; int startAngle = 30 * 16 ; int spanAngle = 120 * 16 ; QPainter painter ( this ) ; painter . drawChord ( rect , startAngle , spanAngle ) ; static const QPointF points [ 3 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , } ; QPainter painter ( this ) ; painter . drawPolyline ( points , 3 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawPolygon ( points , 4 ) ; static const QPointF points [ 4 ] = { QPointF ( 10.0 , 80.0 ) , QPointF ( 20.0 , 10.0 ) , QPointF ( 80.0 , 30.0 ) , QPointF ( 90.0 , 70.0 ) } ; QPainter painter ( this ) ; painter . drawConv@@ exPolygon ( points , 4 ) ; QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QPixmap pixmap ( " : myPixmap . png " ) ; QPainter ( this ) ; painter . drawPixmap ( target , pixmap , source ) ; QPainter painter ( this ) ; painter . drawText ( rect , Qt :: AlignCenter , tr ( " Qt \n Project " ) ) ; QPicture picture ; QPointF point ( 10.0 , 20.0 ) picture . load ( " drawing . pic " ) ; QPainter painter ( this ) ; painter . drawPicture ( 0 , 0 , picture ) ; fillRect ( rectangle , background ( ) ) . QRectF target ( 10.0 , 20.0 , 80.0 , 60.0 ) ; QRectF source ( 0.0 , 0.0 , 70.0 , 40.0 ) ; QImage image ( " : / images / myImage . png " ) ; QPainter painter ( this ) ; painter . drawImage ( target , image , source ) ; QPainter painter ( this ) ; painter . fillRect ( 0 , 0 , 128 , 128 , Qt :: green ) ; painter . begin@@ NativePainting ( ) ; glEnable ( GL_SCISSOR_TEST ) ; glScissor ( 0 , 0 , 64 , 64 ) ; glClearColor ( 1 , 0 , 0 , 1 ) ; glClear ( GL_COLOR_BUFFER_BIT ) ; glDisable ( GL_SCISSOR_TEST ) ; painter . endNativePainting ( ) ; </DOCUMENT>
<DOCUMENT_ID="h@@ yuk-@@ kim@@ -tmax@@ /OF@@ ASM-@@ test/tree/master/@@ Mtest/@@ UNKNO@@ WN/MVI@@ 01/@@ main.cpp"> # include < stdlib . h > # include < string . h > extern int MVI01 ( char * p_0 , char * p_1 , char * p_2 ) ; int main ( ) { char * p_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1_0 = ( char * ) malloc ( sizeof ( char ) * 7 ) ; char * p_1 = ( char * ) & p_1_0 ; char * p_2 = ( char * ) malloc ( sizeof ( char ) * 3 ) ; strcpy ( p_0 , " HELLO ▁ " ) ; strcpy ( p_1_0 , " WORLD ▁ " ) ; strcpy ( p_2 , " ! ! " ) ; MVI01 ( p_0 , p_1 , p_2 ) ; MVI01 ( p_0 , p_1 , p_2 ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="s@@ licer4ev@@ er/Light@@ wave/tree/master/Engine@@ /Source/C++@@ 11/LWEProtocol@@ s/LWEProtocolWebSocketSec@@ ure.cpp"> # include " LWEProtocols / LWEProtocolWebSocketSecure . h " # include " LWEProtocols / LWEProtocolHTT@@ P . h " # include < LWNetwork / LWSocket . h > # include < LWNetwork / LWProtocolManager . h > # include < LWCore / LWAllocator . h > # include < LWCore / LWCrypto . h > # include < LWCore / LWText . h > # include < LWCore / LWByteBuffer . h > # include < iostream > bool LWEProtocolWebSocketSecure :: ProcessRead ( LWSocket & Socket , const char * Buffer , uint32_t BufferLen ) { char Buf [ 256 ] ; char BufB [ 256 ] ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; if ( ! WebSocket ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( * Request . m_SecWebSockKey && Request . m_WebSockVersion == LWEWEBSOCKET_SUPPVER && Request . Upgrade@@ Connection ( ) ) ? 0 : 2 ; if ( ! Error && * Request . m_SecWebSockProto ) { bool ValidProtocol = false ; if ( * m_SubProtocol ) { uint32_t ProtocolLen = ( uint32_t ) strlen ( m_SubProtocol ) ; for ( const char * C = Request . m_SecWebSockProto ; C && ! ValidProtocol ; C = LWText :: FirstToken ( C , ' , ' ) ) { C = LWText :: NextWord ( * C == ' , ' ? C + 1 : C , true ) ; ValidProtocol = LWText :: Compare ( C , m_SubProtocol , ProtocolLen ) ; } } if ( ! ValidProtocol ) Error = 3 ; } if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ Headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; else if ( Error == 3 ) std :: cout << " Error ▁ protocol ▁ asked ▁ for ▁ is ▁ not ▁ supported . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket = m_Allocator . Allocate < LWEWebSocket > ( nullptr , nullptr ) ; WebSocket -> m_Socket = & Socket ; * Buf = ' \0' ; strncat ( Buf , Request . m_SecWebSockKey , sizeof ( Buf ) ) ; strncat ( Buf , LWEWEBSOCKE@@ T_GUID , sizeof ( Buf ) ) ; LWCrypto :: HashSH@@ A1 ( Buf , ( uint32_t ) strlen ( Buf ) , BufB ) ; uint32_t * uBuf = ( uint32_t * ) BufB ; for ( uint32_t i = 0 ; i < 5 ; i ++ ) uBuf [ i ] = ( uBuf [ i ] & 0xFF ) << 24 | ( uBuf [ i ] & 0xFF00 ) << 8 | ( uBuf [ i ] & 0xFF0000 ) >> 8 | ( uBuf [ i ] & 0xFF000000 ) >> 24 ; uint32_t Len = LWCrypto :: Base64Encode ( BufB , 20 , WebSocket -> m_SecKey , sizeof ( WebSocket -> m_SecKey ) ) ; WebSocket -> m_SecKey [ Len ] = ' \0' ; WebSocket -> SetSec@@ Protocols ( m_SubProtocol ) ; WebSocket -> SetHost ( Request . m_Host ) ; WebSocket -> SetPath ( Request . m_Path ) ; WebSocket -> SetOrigin ( Request . m_Origin ) ; WebSocket -> m_Flag |= LWEWebSocket :: CONNECTING_SERVER ; Socket . SetProtocolData ( m_wProtocolID , WebSocket ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_CONNECT ) ; return true ; } if ( ! WebSocket -> IsConnected ( ) ) { if ( WebSocket -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { LWEHttpRequest Request ; uint32_t Error = 0 ; Error = Request . Deserialize ( Buffer , BufferLen ) ? 0 : 1 ; Error = Error ? Error : ( ( * Request . m_SecWebSockKey && Request . m_Status == LWEHttpRequest :: SwitchingProtocols ) ? 0 : 2 ) ; if ( Error ) { std :: cout << " Buffer : " << std :: endl << Buffer << std :: endl ; if ( Error == 1 ) std :: cout << " Error ▁ deserializing ▁ websocket ▁ request . " << std :: endl ; else if ( Error == 2 ) std :: cout << " Error ▁ headers ▁ did ▁ not ▁ include ▁ correct ▁ websocket ▁ data . " << std :: endl ; Socket . MarkClosable ( ) ; return false ; } WebSocket -> m_Flag = ( WebSocket -> m_Flag & ~ LWEWebSocket :: CONNECTING_CLIENT ) | LWEWebSocket :: CONNECTED_CLIENT ; } return true ; } char IPBuf [ 32 ] ; LWSocket :: MakeAddress ( Socket . GetRemote@@ IP ( ) , IPBuf , sizeof ( IPBuf ) ) ; if ( BufferLen > 100 ) { } LWEWebPacket * OPack ; uint32_t Target ; uint32_t ReservePos ; uint32_t o = 0 ; while ( o != BufferLen ) { uint32_t Res = WebSocket -> m_ActivePacket . Deserialize ( Buffer + o , BufferLen - o , m_Allocator ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ deserializing ▁ data . " << std :: endl ; return false ; } o += Res ; if ( ! WebSocket -> m_ActivePacket . Finished ( ) ) continue ; if ( WebSocket -> m_ActivePacket . m_DataLen != WebSocket -> m_ActivePacket . m_Data@@ Pos ) continue ; if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_CLO@@ SED ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; Socket . MarkClosable ( ) ; return true ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_P@@ ING ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; PushOutPacket ( nullptr , 0 , WebSocket , LWEWebPacket :: CONTROL_PONG ) ; continue ; } else if ( WebSocket -> m_ActivePacket . GetOp ( ) == LWEWebPacket :: CONTROL_PONG ) { WebSocket -> m_ActivePacket . WorkFinished ( ) ; continue ; } WebSocket -> m_ActivePacket . m_WebSocket = WebSocket ; if ( ! m_InPackets . PushStart ( & OPack , Target , ReservePos ) ) return false ; * OPack = std :: move ( WebSocket -> m_ActivePacket ) ; m_InPackets . PushFinished ( Target , ReservePos ) ; } return true ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketClosed ( LWSocket & Socket , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketClosed ( Socket , Manager ) ; LWEWebSocket * WebSock = ( LWEWebSocket * ) Socket . GetProtocolData ( m_wProtocolID ) ; bool Del = true ; if ( m_WebSocketClosedCallback ) Del = m_WebSocketClosedCallback ( Socket , WebSock , Manager ) ; if ( WebSock ) WebSock -> m_Socket = nullptr ; if ( Del ) LWAllocator :: Destroy ( WebSock ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: SocketChanged ( LWSocket & Prev , LWSocket & New , LWProtocolManager * Manager ) { LWEProtocolTLS :: SocketChanged ( Prev , New , Manager ) ; LWEWebSocket * WebSocket = ( LWEWebSocket * ) Prev . GetProtocolData ( m_wProtocolID ) ; New . SetProtocolData ( m_wProtocolID , Prev . GetProtocolData ( m_wProtocolID ) ) ; if ( WebSocket ) WebSocket -> m_Socket = & New ; if ( m_WebSocketChangedCallback ) m_WebSocketChangedCallback ( Prev , New , WebSocket , Manager ) ; return * this ; } LWProtocol & LWEProtocolWebSocketSecure :: ProcessTLS@@ Data ( LWSocket & Socket , const char * Data , uint32_t DataLen ) { ProcessRead ( Socket , Data , DataLen ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: ProcessOutPackets ( void ) { char Buffer [ 1024 * 64 ] ; LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; while ( m_OutPackets . PopStart ( & Pack , Target , ReservePos ) ) { LWEWebPacket RPack = std :: move ( * Pack ) ; m_OutPackets . PopFinshed ( Target , ReservePos ) ; LWEWebSocket * Sock = RPack . m_WebSocket ; if ( ! Sock -> IsConnected ( ) && ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) ) { if ( ! Sock -> m_Socket ) return * this ; LWEHttpRequest Request ; Request . SetWebSock@@ Key ( Sock -> m_SecKey ) ; Request . SetWebSock@@ Proto ( m_SubProtocol ) ; Request . m_Flag |= LWEHttpRequest :: Connection@@ Upgrade | LWEHttpRequest :: Upgrade@@ WebSock ; Request . m_Status = Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_SERVER ? LWEHttpRequest :: SwitchingProtocols : 0 ; if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTING_CLIENT ) { Request . SetHost ( Sock -> m_Host ) . SetPath ( Sock -> m_Path ) . SetOrigin ( Sock -> m_Origin ) ; Request . m_WebSockVersion = LWEWEBSOCKET_SUPPVER ; } else Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTED_SERVER ; uint32_t Len = Request . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ? m_UserAgent : m_Server ) ; std :: cout << " Sending ▁ headers ! " << std :: endl ; uint32_t Res = Send ( * Sock -> m_Socket , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_SERVER ) Sock -> m_Flag = ( Sock -> m_Flag & ~ LWEWebSocket :: CONNECTING_SERVER ) | LWEWebSocket :: CONNECTING_SERVER ; PushOutPacket ( nullptr , 0 , Sock , LWEWebPacket :: CONTROL_CONNECT ) ; return * this ; } } if ( RPack . m_ControlFlag & LWEWebPacket :: CONTROL_CONNECT ) continue ; if ( ! Sock -> IsConnected ( ) ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return * this ; } std :: cout << " Sending ▁ data : ▁ " << RPack . GetOp ( ) << " ▁ Len : ▁ " << RPack . m_DataLen << " ▁ Fin : ▁ " << RPack . m_ControlFlag << std :: endl ; LWSocket * rSock = RPack . m_WebSocket -> m_Socket ; if ( ! rSock ) continue ; uint32_t Len = RPack . Serialize ( Buffer , sizeof ( Buffer ) , Sock -> GetConnectStatus ( ) == LWEWebSocket :: CONNECTED_CLIENT ) ; std :: cout << " Serialized : ▁ " << Len << std :: endl ; uint32_t Res = Send ( * rSock , Buffer , Len ) ; if ( Res == - 1 ) { std :: cout << " Error ▁ sending ▁ data . " << std :: endl ; return * this ; } if ( ! Res ) { if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) { std :: cout << " Error ▁ re - inserting ▁ packet . " << std :: endl ; return * this ; } * Pack = std :: move ( RPack ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; } } return * this ; } LWEWebSocket * LWEProtocolWebSocketSecure :: OpenSocket ( const char * URI , uint32_t ProtocolID , const char * Origin ) { char Host [ 256 ] ; char Path [ 256 ] ; char Protocol [ 256 ] ; uint16_t Port = LWEHttpRequest :: ParseURI ( URI , Host , sizeof ( Host ) , nullptr , Path , sizeof ( Path ) , nullptr , Protocol , sizeof ( Protocol ) , nullptr ) ; LWSocket Sock ; uint32_t Err = LWSocket :: CreateSocket ( Sock , Host , Port , LWSocket :: Tcp , ProtocolID ) ; if ( Err ) { std :: cout << " Error ▁ creating ▁ socket : ▁ " << Err << std :: endl ; return nullptr ; } LWSocket * S = m_Manager -> PushSocket ( Sock ) ; LWEWebSocket * WebSock = m_Allocator . Allocate < LWEWebSocket > ( URI , Origin ) ; WebSock -> m_Flag |= LWEWebSocket :: CONNECTING_CLIENT ; WebSock -> GenerateKey ( m_KeySeed ++ ) ; S -> SetProtocolData ( m_wProtocolID , WebSock ) ; WebSock -> m_Socket = S ; PushOutPacket ( nullptr , 0 , WebSock , LWEWebPacket :: CONTROL_CONNECT ) ; return WebSock ; } bool LWEProtocolWebSocketSecure :: PushOutPacket ( const char * Buffer , uint32_t BufferLen , LWEWebSocket * Socket , uint32_t ControlFlag ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_OutPackets . PushStart ( & Pack , Target , ReservePos ) ) return false ; * Pack = LWEWebPacket ( Buffer , BufferLen , m_Allocator , ControlFlag | LWEWebPacket :: CONTROL_FINISHED , Socket ) ; m_OutPackets . PushFinished ( Target , ReservePos ) ; return true ; } bool LWEProtocolWebSocketSecure :: GetNextPacket ( LWEWebPacket & Packet ) { LWEWebPacket * Pack ; uint32_t Target ; uint32_t ReservePos ; if ( ! m_InPackets . PopStart ( & Pack , Target , ReservePos ) ) return false ; Packet = std :: move ( * Pack ) ; m_InPackets . PopFinshed ( Target , ReservePos ) ; return true ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetServer ( const char * Server ) { * m_Server = ' \0' ; strncat ( m_Server , Server , sizeof ( m_Server ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetUserAgent ( const char * Agent ) { * m_UserAgent = ' \0' ; strncat ( m_UserAgent , Agent , sizeof ( m_UserAgent ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetSubProtocol ( const char * SubProtocol ) { * m_SubProtocol = ' \0' ; strncat ( m_SubProtocol , SubProtocol , sizeof ( m_SubProtocol ) ) ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketClosedCallback ( std :: function < bool ( LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketClosedCallback ) { m_WebSocketClosedCallback = WebSocketClosedCallback ; return * this ; } LWEProtocolWebSocketSecure & LWEProtocolWebSocketSecure :: SetWebSocketChangedCallback ( std :: function < void ( LWSocket & , LWSocket & , LWEWebSocket * , LWProtocolManager * ) > WebSocketChangedCallback ) { m_WebSocketChangedCallback = WebSocketChangedCallback ; return * this ; } LWEProtocolWebSocketSecure :: LWEProtocolWebSocketSecure ( uint32_t ProtocolID , uint32_t TLSProtocolID , LWAllocator & Allocator , LWProtocolManager * Manager , const char * CertFile , const char * KeyFile ) : LWEProtocolTLS ( TLSProtocolID , Allocator , CertFile , KeyFile ) , m_wProtocolID ( ProtocolID ) , m_Allocator ( Allocator ) , m_Manager ( Manager ) , m_KeySeed ( 0 ) { * m_Server = * m_UserAgent = * m_SubProtocol = ' \0' ; m_WebSocketClosedCallback = nullptr ; m_WebSocketChangedCallback = nullptr ; } </DOCUMENT>
<DOCUMENT_ID="tw@@ alpo@@ le/@@ selenium@@ /tree/master/cpp/ied@@ river/@@ CommandHandlers/@@ MaximizeWindowCommandHandler.cpp"> # include " MaximizeWindowCommandHandler . h " # include " errorcodes . h " # include " . . / Browser . h " # include " . . / IECommandExecutor . h " namespace webdriver { MaximizeWindowCommandHandler :: MaximizeWindowCommandHandler ( void ) { } MaximizeWindowCommandHandler :: ~ MaximizeWindowCommandHandler ( void ) { } void MaximizeWindowCommandHandler :: ExecuteInternal ( const IECommandExecutor & executor , const ParametersMap & command_@@ parameters , Response * response ) { int status_code = WD_SUCCESS ; BrowserHandle browser_wrapper ; status_code = executor . GetCurrentBrowser ( & browser_wrapper ) ; if ( status_code != WD_SUCCESS ) { response -> SetError@@ Response ( ERROR_NO_SU@@ CH_WINDO@@ W , " Error ▁ retrieving ▁ window " ) ; return ; } HWND window_handle = browser_wrapper -> GetTopLevel@@ WindowHandle ( ) ; if ( ! :: IsZo@@ omed ( window_handle ) ) { browser_wrapper -> Restore ( ) ; :: ShowWindow ( window_handle , SW_@@ MAXIMI@@ ZE ) ; } RECT window_rect ; :: GetWindowRect ( window_handle , & window_rect ) ; Json :: Value response_value ; response_value [ " width " ] = window_rect . right - window_rect . left ; response_value [ " height " ] = window_rect . bottom - window_rect . top ; response_value [ " x " ] = window_rect . left ; response_value [ " y " ] = window_rect . top ; response -> SetSuccess@@ Response ( response_value ) ; } } </DOCUMENT>
<DOCUMENT_ID="im@@ AArti@@ st/sim@@ Ir/tree/master/@@ Data/single@@ File/code@@ _72@@ 1.cpp"> int candy ( vector < int > & ratings ) { int size = ratings . size ( ) ; if ( size <= 1 ) return size ; vector < int > num ( size , 1 ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( ratings [ i ] > ratings [ i - 1 ] ) num [ i ] = num [ i - 1 ] + 1 ; } for ( int i = size - 1 ; i > 0 ; i -- ) { if ( ratings [ i - 1 ] > ratings [ i ] ) num [ i - 1 ] = max ( num [ i ] + 1 , num [ i - 1 ] ) ; } int result = 0 ; for ( int i = 0 ; i < size ; i ++ ) { result += num [ i ] ; } return result ; } 1 , 3 , 3 , 3 , 21 , 2 , 1 , 2 , 1public int candy ( int [ ] ratings ) { int len = ratings . length ; int [ ] candy = new int [ len ] ; candy [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { if ( ratings [ i ] > ratings [ i - 1 ] ) { candy [ i ] = candy [ i - 1 ] + 1 ; } else { candy [ i ] = 1 ; } } int total = candy [ len - 1 ] ; for ( int i = len - 2 ; i >= 0 ; -- i ) { if ( ratings [ i ] > ratings [ i + 1 ] && candy [ i ] <= candy [ i + 1 ] ) { candy [ i ] = candy [ i + 1 ] + 1 ; } total += candy [ i ] ; } return total ; } </DOCUMENT>
<DOCUMENT_ID="grokys/@@ coreclr/tree/master/src/@@ vm/@@ common.cpp"> # include " common . h " </DOCUMENT>
<DOCUMENT_ID="f@@ bergmann@@ /libSEDML@@ /tree/master/sedml@@ /SedDocument@@ .cpp"> # include < sedml / SedDocument . h > # include < sedml / SedTypes . h > # include < sb@@ ml / xml / XMLInputStream . h > using namespace std ; LIBSEDML_CPP_@@ NAMESPACE_BEGIN SedDocument :: SedDocument ( unsigned int level , unsigned int version ) : SedBase ( level , version ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( level , version ) , mSimulations ( level , version ) , mModels ( level , version ) , mTasks ( level , version ) , mDataGenerators ( level , version ) , mOutputs ( level , version ) { mLevel = level ; mIsSetLevel = true ; mVersion = version ; mIsSetVersion = true ; setSedDocument ( this ) ; setSedNamesp@@ aces@@ AndOwn ( new SedNamespaces ( level , version ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( SedNamespaces * sedns ) : SedBase ( sedns ) , mLevel ( SEDML_INT_MAX ) , mIsSetLevel ( false ) , mVersion ( SEDML_INT_MAX ) , mIsSetVersion ( false ) , mDataDescriptions ( sedns ) , mSimulations ( sedns ) , mModels ( sedns ) , mTasks ( sedns ) , mDataGenerators ( sedns ) , mOutputs ( sedns ) { mLevel = sedns -> getLevel ( ) ; mIsSetLevel = true ; mVersion = sedns -> getVersion ( ) ; mIsSetVersion = true ; setSedDocument ( this ) ; setElement@@ Namespace ( sedns -> getURI ( ) ) ; connectToChild ( ) ; } SedDocument :: SedDocument ( const SedDocument & orig ) : SedBase ( orig ) { setSedDocument ( this ) ; mLevel = orig . mLevel ; mIsSetLevel = orig . mIsSetLevel ; mVersion = orig . mVersion ; mIsSetVersion = orig . mIsSetVersion ; mDataDescriptions = orig . mDataDescriptions ; mSimulations = orig . mSimulations ; mModels = orig . mModels ; mTasks = orig . mTasks ; mDataGenerators = orig . mDataGenerators ; mOutputs = orig . mOutputs ; connectToChild ( ) ; } SedDocument & SedDocument :: operator = ( const SedDocument & rhs ) { if ( & rhs != this ) { SedBase :: operator = ( rhs ) ; setSedDocument ( this ) ; mLevel = rhs . mLevel ; mIsSetLevel = rhs . mIsSetLevel ; mVersion = rhs . mVersion ; mIsSetVersion = rhs . mIsSetVersion ; mDataDescriptions = rhs . mDataDescriptions ; mSimulations = rhs . mSimulations ; mModels = rhs . mModels ; mTasks = rhs . mTasks ; mDataGenerators = rhs . mDataGenerators ; mOutputs = rhs . mOutputs ; connectToChild ( ) ; } return * this ; } SedDocument * SedDocument :: clone ( ) const { return new SedDocument ( * this ) ; } SedDocument :: ~ SedDocument ( ) { } const int SedDocument :: getLevel ( ) const { return mLevel ; } const int SedDocument :: getVersion ( ) const { return mVersion ; } bool SedDocument :: isSetLevel ( ) const { return mIsSetLevel ; } bool SedDocument :: isSetVersion ( ) const { return mIsSetVersion ; } int SedDocument :: setLevel ( int level ) { mLevel = level ; mIsSetLevel = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: setVersion ( int version ) { mVersion = version ; mIsSetVersion = true ; return LIBSEDML_OPERATION_SUCCESS ; } int SedDocument :: unsetLevel ( ) { mLevel = SEDML_INT_MAX ; mIsSetLevel = false ; if ( isSetLevel ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } int SedDocument :: unsetVersion ( ) { mVersion = SEDML_INT_MAX ; mIsSetVersion = false ; if ( isSetVersion ( ) == false ) { return LIBSEDML_OPERATION_SUCCESS ; } else { return LIBSEDML_OPERATION_FAILED ; } } const SedListOfDataDescriptions * SedDocument :: getListOfDataDescriptions ( ) const { return & mDataDescriptions ; } SedDataDescription * SedDocument :: removeDataDescription ( unsigned int n ) { return mDataDescriptions . remove ( n ) ; } SedDataDescription * SedDocument :: removeDataDescription ( const std :: string & sid ) { return mDataDescriptions . remove ( sid ) ; } SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) { return mDataDescriptions . get ( n ) ; } const SedDataDescription * SedDocument :: getDataDescription ( unsigned int n ) const { return mDataDescriptions . get ( n ) ; } SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) { return mDataDescriptions . get ( sid ) ; } const SedDataDescription * SedDocument :: getDataDescription ( const std :: string & sid ) const { return mDataDescriptions . get ( sid ) ; } int SedDocument :: addDataDescription ( const SedDataDescription * sdd ) { if ( sdd == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataDescriptions . append ( sdd ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataDescriptions ( ) const { return mDataDescriptions . size ( ) ; } SedDataDescription * SedDocument :: createDataDescription ( ) { SedDataDescription * temp = new SedDataDescription ( ) ; if ( temp != NULL ) mDataDescriptions . appendAndOwn ( temp ) ; return temp ; } const SedListOfSimulations * SedDocument :: getListOfSimulations ( ) const { return & mSimulations ; } SedSimulation * SedDocument :: removeSimulation ( unsigned int n ) { return mSimulations . remove ( n ) ; } SedSimulation * SedDocument :: removeSimulation ( const std :: string & sid ) { return mSimulations . remove ( sid ) ; } SedSimulation * SedDocument :: getSimulation ( unsigned int n ) { return mSimulations . get ( n ) ; } const SedSimulation * SedDocument :: getSimulation ( unsigned int n ) const { return mSimulations . get ( n ) ; } SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) { return mSimulations . get ( sid ) ; } const SedSimulation * SedDocument :: getSimulation ( const std :: string & sid ) const { return mSimulations . get ( sid ) ; } int SedDocument :: addSimulation ( const SedSimulation * ss ) { if ( ss == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mSimulations . append ( ss ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumSimulations ( ) const { return mSimulations . size ( ) ; } SedUniformTimeCourse * SedDocument :: createUniformTimeCourse ( ) { SedUniformTimeCourse * temp = new SedUniformTimeCourse ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedOneStep * SedDocument :: createOneStep ( ) { SedOneStep * temp = new SedOneStep ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } SedSteadyState * SedDocument :: createSteadyState ( ) { SedSteadyState * temp = new SedSteadyState ( ) ; if ( temp != NULL ) mSimulations . appendAndOwn ( temp ) ; return temp ; } const SedListOfModels * SedDocument :: getListOfModels ( ) const { return & mModels ; } SedModel * SedDocument :: removeModel ( unsigned int n ) { return mModels . remove ( n ) ; } SedModel * SedDocument :: removeModel ( const std :: string & sid ) { return mModels . remove ( sid ) ; } SedModel * SedDocument :: getModel ( unsigned int n ) { return mModels . get ( n ) ; } const SedModel * SedDocument :: getModel ( unsigned int n ) const { return mModels . get ( n ) ; } SedModel * SedDocument :: getModel ( const std :: string & sid ) { return mModels . get ( sid ) ; } const SedModel * SedDocument :: getModel ( const std :: string & sid ) const { return mModels . get ( sid ) ; } int SedDocument :: addModel ( const SedModel * sm ) { if ( sm == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mModels . append ( sm ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumModels ( ) const { return mModels . size ( ) ; } SedModel * SedDocument :: createModel ( ) { SedModel * temp = new SedModel ( ) ; if ( temp != NULL ) mModels . appendAndOwn ( temp ) ; return temp ; } const SedListOfTasks * SedDocument :: getListOfTasks ( ) const { return & mTasks ; } SedTask * SedDocument :: removeTask ( unsigned int n ) { return mTasks . remove ( n ) ; } SedTask * SedDocument :: removeTask ( const std :: string & sid ) { return mTasks . remove ( sid ) ; } SedTask * SedDocument :: getTask ( unsigned int n ) { return mTasks . get ( n ) ; } const SedTask * SedDocument :: getTask ( unsigned int n ) const { return mTasks . get ( n ) ; } SedTask * SedDocument :: getTask ( const std :: string & sid ) { return mTasks . get ( sid ) ; } const SedTask * SedDocument :: getTask ( const std :: string & sid ) const { return mTasks . get ( sid ) ; } int SedDocument :: addTask ( const SedTask * st ) { if ( st == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mTasks . append ( st ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumTasks ( ) const { return mTasks . size ( ) ; } SedTask * SedDocument :: createTask ( ) { SedTask * temp = new SedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } SedRepeatedTask * SedDocument :: createRepeatedTask ( ) { SedRepeatedTask * temp = new SedRepeatedTask ( ) ; if ( temp != NULL ) mTasks . appendAndOwn ( temp ) ; return temp ; } const SedListOfDataGenerators * SedDocument :: getListOfDataGenerators ( ) const { return & mDataGenerators ; } SedDataGenerator * SedDocument :: removeDataGenerator ( unsigned int n ) { return mDataGenerators . remove ( n ) ; } SedDataGenerator * SedDocument :: removeDataGenerator ( const std :: string & sid ) { return mDataGenerators . remove ( sid ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) { return mDataGenerators . get ( n ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( unsigned int n ) const { return mDataGenerators . get ( n ) ; } SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) { return mDataGenerators . get ( sid ) ; } const SedDataGenerator * SedDocument :: getDataGenerator ( const std :: string & sid ) const { return mDataGenerators . get ( sid ) ; } int SedDocument :: addDataGenerator ( const SedDataGenerator * sdg ) { if ( sdg == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mDataGenerators . append ( sdg ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumDataGenerators ( ) const { return mDataGenerators . size ( ) ; } SedDataGenerator * SedDocument :: createDataGenerator ( ) { SedDataGenerator * temp = new SedDataGenerator ( ) ; if ( temp != NULL ) mDataGenerators . appendAndOwn ( temp ) ; return temp ; } const SedListOfOutputs * SedDocument :: getListOfOutputs ( ) const { return & mOutputs ; } SedOutput * SedDocument :: removeOutput ( unsigned int n ) { return mOutputs . remove ( n ) ; } SedOutput * SedDocument :: removeOutput ( const std :: string & sid ) { return mOutputs . remove ( sid ) ; } SedOutput * SedDocument :: getOutput ( unsigned int n ) { return mOutputs . get ( n ) ; } const SedOutput * SedDocument :: getOutput ( unsigned int n ) const { return mOutputs . get ( n ) ; } SedOutput * SedDocument :: getOutput ( const std :: string & sid ) { return mOutputs . get ( sid ) ; } const SedOutput * SedDocument :: getOutput ( const std :: string & sid ) const { return mOutputs . get ( sid ) ; } int SedDocument :: addOutput ( const SedOutput * so ) { if ( so == NULL ) return LIBSEDML_INVALID_ATTRIBUTE_VALUE ; mOutputs . append ( so ) ; return LIBSEDML_OPERATION_SUCCESS ; } unsigned int SedDocument :: getNumOutputs ( ) const { return mOutputs . size ( ) ; } SedReport * SedDocument :: createReport ( ) { SedReport * temp = new SedReport ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot2D * SedDocument :: createPlot2D ( ) { SedPlot2D * temp = new SedPlot2D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } SedPlot3D * SedDocument :: createPlot3D ( ) { SedPlot3D * temp = new SedPlot3D ( ) ; if ( temp != NULL ) mOutputs . appendAndOwn ( temp ) ; return temp ; } const std :: string & SedDocument :: getElementName ( ) const { static const string name = " sedML " ; return name ; } SedBase * SedDocument :: createObject ( XMLInputStream & stream ) { SedBase * object = NULL ; const string & name = stream . peek ( ) . getName ( ) ; if ( name == " listOf@@ DataDescriptions " ) { object = & mDataDescriptions ; } if ( name == " listOf@@ Simulations " ) { object = & mSimulations ; } if ( name == " listOf@@ Models " ) { object = & mModels ; } if ( name == " listOf@@ Tasks " ) { object = & mTasks ; } if ( name == " listOf@@ DataGenerators " ) { object = & mDataGenerators ; } if ( name == " listOf@@ Outputs " ) { object = & mOutputs ; } connectToChild ( ) ; return object ; } void SedDocument :: connectToChild ( ) { SedBase :: connectToChild ( ) ; mDataDescriptions . connectToParent ( this ) ; mSimulations . connectToParent ( this ) ; mModels . connectToParent ( this ) ; mTasks . connectToParent ( this ) ; mDataGenerators . connectToParent ( this ) ; mOutputs . connectToParent ( this ) ; } int SedDocument :: getTypeCode ( ) const { return SEDML_DOCUMENT ; } bool SedDocument :: hasRequiredAttributes ( ) const { bool allPresent = true ; if ( isSetLevel ( ) == false ) allPresent = false ; if ( isSetVersion ( ) == false ) allPresent = false ; return allPresent ; } bool SedDocument :: hasRequiredElements ( ) const { bool allPresent = true ; return allPresent ; } void SedDocument :: writeElements ( XMLOutputStream & stream ) const { SedBase :: writeElements ( stream ) ; if ( getNumDataDescriptions ( ) > 0 ) { mDataDescriptions . write ( stream ) ; } if ( getNumSimulations ( ) > 0 ) { mSimulations . write ( stream ) ; } if ( getNumModels ( ) > 0 ) { mModels . write ( stream ) ; } if ( getNumTasks ( ) > 0 ) { mTasks . write ( stream ) ; } if ( getNumDataGenerators ( ) > 0 ) { mDataGenerators . write ( stream ) ; } if ( getNumOutputs ( ) > 0 ) { mOutputs . write ( stream ) ; } } bool SedDocument :: accept ( SedVisitor & v ) const { return false ; } void SedDocument :: setSedDocument ( SedDocument * d ) { SedBase :: setSedDocument ( d ) ; mDataDescriptions . setSedDocument ( d ) ; mSimulations . setSedDocument ( d ) ; mModels . setSedDocument ( d ) ; mTasks . setSedDocument ( d ) ; mDataGenerators . setSedDocument ( d ) ; mOutputs . setSedDocument ( d ) ; } void SedDocument :: addExpectedAttributes ( ExpectedAttributes & attributes ) { SedBase :: addExpectedAttributes ( attributes ) ; attributes . add ( " level " ) ; attributes . add ( " version " ) ; } void SedDocument :: readAttributes ( const XMLAttributes & attributes , const ExpectedAttributes & expectedAttributes ) { SedBase :: readAttributes ( attributes , expectedAttributes ) ; bool assigned = false ; mIsSetLevel = attributes . readInto ( " level " , mLevel , getErrorLog ( ) , true ) ; mIsSetVersion = attributes . readInto ( " version " , mVersion , getErrorLog ( ) , true ) ; } void SedDocument :: writeAttributes ( XMLOutputStream & stream ) const { SedBase :: writeAttributes ( stream ) ; if ( isSetLevel ( ) == true ) stream . writeAttribute ( " level " , getPrefix ( ) , mLevel ) ; if ( isSetVersion ( ) == true ) stream . writeAttribute ( " version " , getPrefix ( ) , mVersion ) ; } const SedError * SedDocument :: getError ( unsigned int n ) const { return mErrorLog . getError ( n ) ; } unsigned int SedDocument :: getNumErrors ( ) const { return mErrorLog . getNumErrors ( ) ; } unsigned int SedDocument :: getNumErrors ( unsigned int severity ) const { return getErrorLog ( ) -> getNumFail@@ sWith@@ Sever@@ ity ( severity ) ; } SedErrorLog * SedDocument :: getErrorLog ( ) { return & mErrorLog ; } const SedErrorLog * SedDocument :: getErrorLog ( ) const { return & mErrorLog ; } void SedDocument :: writeXML@@ NS ( XMLOutputStream & stream ) const { XMLNamespaces * thisNs = this -> getNamespaces ( ) ; if ( thisNs == NULL ) { XMLNamespaces xmlns ; if ( getVersion ( ) == 1 ) xmlns . add ( SEDML_XMLNS_L1V1 ) ; else xmlns . add ( SEDML_XMLNS_L1V2 ) ; mSedNamespaces -> setNamespaces ( & xmlns ) ; thisNs = getNamespaces ( ) ; } else if ( thisNs -> getLength ( ) == 0 ) { if ( getVersion ( ) == 1 ) thisNs -> add ( SEDML_XMLNS_L1V1 ) ; else if ( getVersion ( ) == 2 ) thisNs -> add ( SEDML_XMLNS_L1V2 ) ; else thisNs -> add ( SEDML_XMLNS_L1V@@ 3 ) ; } else { std :: string sedmlURI = SedNamespaces :: getSedNamesp@@ aceURI ( getLevel ( ) , getVersion ( ) ) ; std :: string sedmlPrefix = thisNs -> getPrefix ( sedmlURI ) ; if ( thisNs -> hasNS ( sedmlURI , sedmlPrefix ) == false ) { std :: string other = thisNs -> getURI ( sedmlPrefix ) ; if ( other . empty ( ) == false ) { thisNs -> remove ( sedmlPrefix ) ; thisNs -> add ( sedmlURI , sedmlPrefix ) ; thisNs -> add ( other , " added@@ Prefix " ) ; } else { thisNs -> add ( sedmlURI , sedmlPrefix ) ; } } } XMLNamespaces * xmlns = thisNs -> clone ( ) ; if ( xmlns != NULL ) { stream << * ( xmlns ) ; delete xmlns ; } } XMLNamespaces * SedDocument :: getNamespaces ( ) const { return mSedNamespaces -> getNamespaces ( ) ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_create ( unsigned int level , unsigned int version ) { return new SedDocument ( level , version ) ; } LIBSEDML_EXTERN void SedDocument_free ( SedDocument_t * sd ) { if ( sd != NULL ) delete sd ; } LIBSEDML_EXTERN SedDocument_t * SedDocument_clone ( SedDocument_t * sd ) { if ( sd != NULL ) { return static_cast < SedDocument_t * > ( sd -> clone ( ) ) ; } else { return NULL ; } } LIBSEDML_EXTERN int SedDocument_getLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getLevel ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_getVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getVersion ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN int SedDocument_isSetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetLevel ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_isSetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> isSetVersion ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_setLevel ( SedDocument_t * sd , int level ) { return ( sd != NULL ) ? sd -> setLevel ( level ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_setVersion ( SedDocument_t * sd , int version ) { return ( sd != NULL ) ? sd -> setVersion ( version ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetLevel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetLevel ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_unsetVersion ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> unsetVersion ( ) : LIBSEDML_INVALID_OBJECT ; } LIBSEDML_EXTERN int SedDocument_add@@ DataDescription ( SedDocument_t * sd , SedDataDescription_t * sdd ) { return ( sd != NULL ) ? sd -> addDataDescription ( sdd ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_createDataDescription ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataDescription ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOf@@ DataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataDescriptions ( ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_getDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNum@@ DataDescriptions ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataDescriptions ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescription ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataDescription ( n ) : NULL ; } LIBSEDML_EXTERN SedDataDescription_t * SedDocument_removeDataDescriptionById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataDescription ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_add@@ Simulation ( SedDocument_t * sd , SedSimulation_t * ss ) { return ( sd != NULL ) ? sd -> addSimulation ( ss ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedUniformTimeCour@@ se_t * SedDocument_createUniformTimeCourse ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createUniformTimeCourse ( ) : NULL ; } LIBSEDML_EXTERN SedOne@@ Step_t * SedDocument_createOneStep ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createOneStep ( ) : NULL ; } LIBSEDML_EXTERN SedSteady@@ State_t * SedDocument_createSteadyState ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createSteadyState ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOf@@ Simulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfSimulations ( ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_getSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNum@@ Simulations ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumSimulations ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulation ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeSimulation ( n ) : NULL ; } LIBSEDML_EXTERN SedSimulation_t * SedDocument_removeSimulationById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeSimulation ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_add@@ Model ( SedDocument_t * sd , SedModel_t * sm ) { return ( sd != NULL ) ? sd -> addModel ( sm ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedModel_t * SedDocument_createModel ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createModel ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOf@@ Models ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfModels ( ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_getModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getModel ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNum@@ Models ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumModels ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModel ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeModel ( n ) : NULL ; } LIBSEDML_EXTERN SedModel_t * SedDocument_removeModelById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeModel ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_add@@ Task ( SedDocument_t * sd , SedTask_t * st ) { return ( sd != NULL ) ? sd -> addTask ( st ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedTask_t * SedDocument_createTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createTask ( ) : NULL ; } LIBSEDML_EXTERN SedRepeated@@ Task_t * SedDocument_createRepeatedTask ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createRepeatedTask ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOf@@ Tasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfTasks ( ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_getTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getTask ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNum@@ Tasks ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumTasks ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTask ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeTask ( n ) : NULL ; } LIBSEDML_EXTERN SedTask_t * SedDocument_removeTaskById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeTask ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_add@@ DataGenerator ( SedDocument_t * sd , SedDataGenerator_t * sdg ) { return ( sd != NULL ) ? sd -> addDataGenerator ( sdg ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_createDataGenerator ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createDataGenerator ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOf@@ DataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfDataGenerators ( ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_getDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNum@@ DataGenerators ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumDataGenerators ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGenerator ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( n ) : NULL ; } LIBSEDML_EXTERN SedDataGenerator_t * SedDocument_removeDataGeneratorById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeDataGenerator ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_add@@ Output ( SedDocument_t * sd , SedOutput_t * so ) { return ( sd != NULL ) ? sd -> addOutput ( so ) : LIBSBML_INVALID_OBJECT ; } LIBSEDML_EXTERN SedReport_@@ t * SedDocument_createReport ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createReport ( ) : NULL ; } LIBSEDML_EXTERN SedPlot2D_t * SedDocument_createPlot@@ 2D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot2D ( ) : NULL ; } LIBSEDML_EXTERN SedPlot3D_t * SedDocument_createPlot@@ 3D ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> createPlot3D ( ) : NULL ; } LIBSEDML_EXTERN SedListOf_t * SedDocument_getSedListOf@@ Outputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? ( SedListOf_t * ) sd -> getListOfOutputs ( ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> getOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_getOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> getOutput ( sid ) : NULL ; } LIBSEDML_EXTERN unsigned int SedDocument_getNum@@ Outputs ( SedDocument_t * sd ) { return ( sd != NULL ) ? sd -> getNumOutputs ( ) : SEDML_INT_MAX ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutput ( SedDocument_t * sd , unsigned int n ) { return ( sd != NULL ) ? sd -> removeOutput ( n ) : NULL ; } LIBSEDML_EXTERN SedOutput_t * SedDocument_removeOutputById ( SedDocument_t * sd , const char * sid ) { return ( sd != NULL ) ? sd -> removeOutput ( sid ) : NULL ; } LIBSEDML_EXTERN int SedDocument_hasRequiredAttributes ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredAttributes ( ) ) : 0 ; } LIBSEDML_EXTERN int SedDocument_hasRequiredElements ( SedDocument_t * sd ) { return ( sd != NULL ) ? static_cast < int > ( sd -> hasRequiredElements ( ) ) : 0 ; } LIBSEDML_CPP_@@ NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="h@@ acklab-@@ turk@@ u/luum@@ uh@@ illo/tree/master/source/@@ main.cpp"> # include " game . hpp " # include " server . hpp " # ifdef _WIN32 # include < Windows . h > # endif int main ( int argc , char * * argv ) { if ( game . start ( ) != 0 ) return - 1 ; int retcode = game . getServer ( ) -> start ( ) ; if ( retcode == 0 ) { # ifdef _WIN32 Termin@@ ateProcess ( GetCurrentProcess ( ) , EXIT_SUCCESS ) ; # endif return 0 ; } else return retcode ; } </DOCUMENT>
<DOCUMENT_ID="station7/xbmc/tree/master/xbmc/@@ platform/@@ android/@@ jni@@ /Sy@@ stem.cpp"> # include " System . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJNISystem :: getProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; } std :: string CJNISystem :: getProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " getProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; } std :: string CJNISystem :: setProperty ( const std :: string & property , const std :: string & defaultValue ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " setProperty " , " ( Ljava / lang / String ; Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) , jcast < jhstring > ( defaultValue ) ) ) ; } std :: string CJNISystem :: clearProperty ( const std :: string & property ) { return jcast < std :: string > ( call_static_method < jhstring > ( " java / lang / System " , " clearProperty " , " ( Ljava / lang / String ; ) Ljava / lang / String ; " , jcast < jhstring > ( property ) ) ) ; } int64_t CJNISystem :: nanoTime ( ) { return call_static_method < jlong > ( " java / lang / System " , " nanoTime " , " ( ) J " ) ; } </DOCUMENT>
<DOCUMENT_ID="h@@ uan@@ 576@@ 5/co@@ delite@@ -translate@@ 2ch@@ ines@@ e/tree/master/@@ sdk/@@ astyle@@ /src/ASResource@@ .cpp"> # include " astyle . h " namespace astyle { const string ASResource :: AS_IF = string ( " if " ) ; const string ASResource :: AS_ELSE = string ( " else " ) ; const string ASResource :: AS_FOR = string ( " for " ) ; const string ASResource :: AS_DO = string ( " do " ) ; const string ASResource :: AS_WHILE = string ( " while " ) ; const string ASResource :: AS_SWITCH = string ( " switch " ) ; const string ASResource :: AS_CASE = string ( " case " ) ; const string ASResource :: AS_DEFAULT = string ( " default " ) ; const string ASResource :: AS_CLASS = string ( " class " ) ; const string ASResource :: AS_STRUCT = string ( " struct " ) ; const string ASResource :: AS_UNION = string ( " union " ) ; const string ASResource :: AS_INTERFACE = string ( " interface " ) ; const string ASResource :: AS_NAMESPACE = string ( " namespace " ) ; const string ASResource :: AS_EXTERN = string ( " extern " ) ; const string ASResource :: AS_PUBLIC = string ( " public " ) ; const string ASResource :: AS_PROTEC@@ TED = string ( " protected " ) ; const string ASResource :: AS_PRIVATE = string ( " private " ) ; const string ASResource :: AS_STATIC = string ( " static " ) ; const string ASResource :: AS_SYNCHRONIZED = string ( " synchron@@ ized " ) ; const string ASResource :: AS_OPERATOR = string ( " operator " ) ; const string ASResource :: AS_TEMPLATE = string ( " template " ) ; const string ASResource :: AS_TRY = string ( " try " ) ; const string ASResource :: AS_CATCH = string ( " catch " ) ; const string ASResource :: AS_FINALLY = string ( " finally " ) ; const string ASResource :: AS_THROWS = string ( " throws " ) ; const string ASResource :: AS_CONST = string ( " const " ) ; const string ASResource :: AS_ASM = string ( " asm " ) ; const string ASResource :: AS_BAR_@@ DEFINE = string ( " # define " ) ; const string ASResource :: AS_BAR_@@ INCLU@@ DE = string ( " # include " ) ; const string ASResource :: AS_BAR_@@ IF = string ( " # if " ) ; const string ASResource :: AS_BAR_@@ EL = string ( " # el " ) ; const string ASResource :: AS_BAR_@@ ENDI@@ F = string ( " # endif " ) ; const string ASResource :: AS_OPEN_@@ BRACKET = string ( " { " ) ; const string ASResource :: AS_CLOSE_@@ BRACKET = string ( " } " ) ; const string ASResource :: AS_OPEN_@@ LINE_COMMENT = string ( " // " ) ; const string ASResource :: AS_OPEN_@@ COMMENT = string ( " /* " ) ; const string ASResource :: AS_CLOSE_@@ COMMENT = string ( " */ " ) ; const string ASResource :: AS_ASSIGN = string ( " = " ) ; const string ASResource :: AS_PLUS_ASSIGN = string ( " + = " ) ; const string ASResource :: AS_MINUS_ASSIGN = string ( " - = " ) ; const string ASResource :: AS_MULT_ASSIGN = string ( " * = " ) ; const string ASResource :: AS_DIV_ASSIGN = string ( " / = " ) ; const string ASResource :: AS_MOD_ASSIGN = string ( " % = " ) ; const string ASResource :: AS_OR_ASSIGN = string ( " | = " ) ; const string ASResource :: AS_AND_ASSIGN = string ( " & = " ) ; const string ASResource :: AS_XOR_ASSIGN = string ( " ^ = " ) ; const string ASResource :: AS_GR_GR_ASSIGN = string ( " > > = " ) ; const string ASResource :: AS_LS_LS_ASSIGN = string ( " < < = " ) ; const string ASResource :: AS_GR_GR_GR_ASSIGN = string ( " > > > = " ) ; const string ASResource :: AS_LS_LS_LS_ASSIGN = string ( " < < < = " ) ; const string ASResource :: AS_RETURN = string ( " return " ) ; const string ASResource :: AS_EQUAL = string ( " = = " ) ; const string ASResource :: AS_PLUS_PLUS = string ( " + + " ) ; const string ASResource :: AS_MINUS_MINUS = string ( " - - " ) ; const string ASResource :: AS_NOT_EQUAL = string ( " ! = " ) ; const string ASResource :: AS_GR_EQUAL = string ( " > = " ) ; const string ASResource :: AS_GR_GR = string ( " > > " ) ; const string ASResource :: AS_GR_GR_GR = string ( " > > > " ) ; const string ASResource :: AS_LS_EQUAL = string ( " < = " ) ; const string ASResource :: AS_LS_LS = string ( " < < " ) ; const string ASResource :: AS_LS_LS_LS = string ( " < < < " ) ; const string ASResource :: AS_ARROW = string ( " - > " ) ; const string ASResource :: AS_AND = string ( " & & " ) ; const string ASResource :: AS_OR = string ( " | | " ) ; const string ASResource :: AS_COLON_COLON = string ( " : : " ) ; const string ASResource :: AS_PAREN_@@ PAREN = string ( " ( ) " ) ; const string ASResource :: AS_BLPAREN_@@ BLPAREN = string ( " [ ] " ) ; const string ASResource :: AS_PLUS = string ( " + " ) ; const string ASResource :: AS_MINUS = string ( " - " ) ; const string ASResource :: AS_MULT = string ( " * " ) ; const string ASResource :: AS_DIV = string ( " / " ) ; const string ASResource :: AS_MOD = string ( " % " ) ; const string ASResource :: AS_GR = string ( " > " ) ; const string ASResource :: AS_LS = string ( " < " ) ; const string ASResource :: AS_NOT = string ( " ! " ) ; const string ASResource :: AS_BIT_OR = string ( " | " ) ; const string ASResource :: AS_BIT_AND = string ( " & " ) ; const string ASResource :: AS_BIT_NOT = string ( " ~ " ) ; const string ASResource :: AS_BIT_XOR = string ( " ^ " ) ; const string ASResource :: AS_QUESTION = string ( " ? " ) ; const string ASResource :: AS_COLON = string ( " : " ) ; const string ASResource :: AS_COMMA = string ( " , " ) ; const string ASResource :: AS_SE@@ MICOLON = string ( " ; " ) ; const string ASResource :: AS_FOREACH = string ( " foreach " ) ; const string ASResource :: AS_LOCK = string ( " lock " ) ; const string ASResource :: AS_UNSAFE = string ( " unsafe " ) ; const string ASResource :: AS_FIXED = string ( " fixed " ) ; const string ASResource :: AS_GET = string ( " get " ) ; const string ASResource :: AS_SET = string ( " set " ) ; const string ASResource :: AS_ADD = string ( " add " ) ; const string ASResource :: AS_REMOVE = string ( " remove " ) ; const string ASResource :: AS_CONST_CAST = string ( " const _ cast " ) ; const string ASResource :: AS_DYNAMIC_CAST = string ( " dynamic _ cast " ) ; const string ASResource :: AS_REINTERPRET_CAST = string ( " reinter@@ pret _ cast " ) ; const string ASResource :: AS_STATIC_CAST = string ( " static _ cast " ) ; void ASResource :: buildAssignmentOperators ( vector < const string * > & assignmentOperators ) { assignmentOperators . push_back ( & AS_ASSIGN ) ; assignmentOperators . push_back ( & AS_PLUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MINUS_ASSIGN ) ; assignmentOperators . push_back ( & AS_MULT_ASSIGN ) ; assignmentOperators . push_back ( & AS_DIV_ASSIGN ) ; assignmentOperators . push_back ( & AS_MOD_ASSIGN ) ; assignmentOperators . push_back ( & AS_OR_ASSIGN ) ; assignmentOperators . push_back ( & AS_AND_ASSIGN ) ; assignmentOperators . push_back ( & AS_XOR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_GR_GR_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; assignmentOperators . push_back ( & AS_RETURN ) ; } void ASResource :: buildCastOperators ( vector < const string * > & castOperators ) { castOperators . push_back ( & AS_CONST_CAST ) ; castOperators . push_back ( & AS_DYNAMIC_CAST ) ; castOperators . push_back ( & AS_REINTERPRET_CAST ) ; castOperators . push_back ( & AS_STATIC_CAST ) ; } void ASResource :: buildHeaders ( vector < const string * > & headers , int fileType , bool beautifier ) { headers . push_back ( & AS_IF ) ; headers . push_back ( & AS_ELSE ) ; headers . push_back ( & AS_FOR ) ; headers . push_back ( & AS_WHILE ) ; headers . push_back ( & AS_DO ) ; headers . push_back ( & AS_SWITCH ) ; headers . push_back ( & AS_TRY ) ; headers . push_back ( & AS_CATCH ) ; if ( beautifier ) { headers . push_back ( & AS_CASE ) ; headers . push_back ( & AS_DEFAULT ) ; headers . push_back ( & AS_CONST ) ; headers . push_back ( & AS_STATIC ) ; headers . push_back ( & AS_EXTERN ) ; headers . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_SYNCHRONIZED ) ; } if ( fileType == SHARP_TYPE ) { headers . push_back ( & AS_FINALLY ) ; headers . push_back ( & AS_FOREACH ) ; headers . push_back ( & AS_LOCK ) ; headers . push_back ( & AS_UNSAFE ) ; headers . push_back ( & AS_FIXED ) ; headers . push_back ( & AS_GET ) ; headers . push_back ( & AS_SET ) ; headers . push_back ( & AS_ADD ) ; headers . push_back ( & AS_REMOVE ) ; } } void ASResource :: buildNon@@ AssignmentOperators ( vector < const string * > & nonAssignmentOperators ) { nonAssignmentOperators . push_back ( & AS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_PLUS_PLUS ) ; nonAssignmentOperators . push_back ( & AS_MINUS_MINUS ) ; nonAssignmentOperators . push_back ( & AS_NOT_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_GR_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_GR_GR ) ; nonAssignmentOperators . push_back ( & AS_LS_EQUAL ) ; nonAssignmentOperators . push_back ( & AS_LS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_LS_LS ) ; nonAssignmentOperators . push_back ( & AS_ARROW ) ; nonAssignmentOperators . push_back ( & AS_AND ) ; nonAssignmentOperators . push_back ( & AS_OR ) ; } void ASResource :: buildNon@@ ParenHeaders ( vector < const string * > & nonParenHeaders , int fileType , bool beautifier ) { nonParenHeaders . push_back ( & AS_ELSE ) ; nonParenHeaders . push_back ( & AS_DO ) ; nonParenHeaders . push_back ( & AS_TRY ) ; if ( beautifier ) { nonParenHeaders . push_back ( & AS_CASE ) ; nonParenHeaders . push_back ( & AS_DEFAULT ) ; nonParenHeaders . push_back ( & AS_CONST ) ; nonParenHeaders . push_back ( & AS_STATIC ) ; nonParenHeaders . push_back ( & AS_EXTERN ) ; nonParenHeaders . push_back ( & AS_TEMPLATE ) ; } if ( fileType == JAVA_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; } if ( fileType == SHARP_TYPE ) { nonParenHeaders . push_back ( & AS_FINALLY ) ; nonParenHeaders . push_back ( & AS_UNSAFE ) ; nonParenHeaders . push_back ( & AS_GET ) ; nonParenHeaders . push_back ( & AS_SET ) ; nonParenHeaders . push_back ( & AS_ADD ) ; nonParenHeaders . push_back ( & AS_REMOVE ) ; } } void ASResource :: buildOperators ( vector < const string * > & operators ) { operators . push_back ( & AS_PLUS_ASSIGN ) ; operators . push_back ( & AS_MINUS_ASSIGN ) ; operators . push_back ( & AS_MULT_ASSIGN ) ; operators . push_back ( & AS_DIV_ASSIGN ) ; operators . push_back ( & AS_MOD_ASSIGN ) ; operators . push_back ( & AS_OR_ASSIGN ) ; operators . push_back ( & AS_AND_ASSIGN ) ; operators . push_back ( & AS_XOR_ASSIGN ) ; operators . push_back ( & AS_EQUAL ) ; operators . push_back ( & AS_PLUS_PLUS ) ; operators . push_back ( & AS_MINUS_MINUS ) ; operators . push_back ( & AS_NOT_EQUAL ) ; operators . push_back ( & AS_GR_EQUAL ) ; operators . push_back ( & AS_GR_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_ASSIGN ) ; operators . push_back ( & AS_GR_GR_GR ) ; operators . push_back ( & AS_GR_GR ) ; operators . push_back ( & AS_LS_EQUAL ) ; operators . push_back ( & AS_LS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_ASSIGN ) ; operators . push_back ( & AS_LS_LS_LS ) ; operators . push_back ( & AS_LS_LS ) ; operators . push_back ( & AS_ARROW ) ; operators . push_back ( & AS_AND ) ; operators . push_back ( & AS_OR ) ; operators . push_back ( & AS_COLON_COLON ) ; operators . push_back ( & AS_PLUS ) ; operators . push_back ( & AS_MINUS ) ; operators . push_back ( & AS_MULT ) ; operators . push_back ( & AS_DIV ) ; operators . push_back ( & AS_MOD ) ; operators . push_back ( & AS_QUESTION ) ; operators . push_back ( & AS_COLON ) ; operators . push_back ( & AS_ASSIGN ) ; operators . push_back ( & AS_LS ) ; operators . push_back ( & AS_GR ) ; operators . push_back ( & AS_NOT ) ; operators . push_back ( & AS_BIT_OR ) ; operators . push_back ( & AS_BIT_AND ) ; operators . push_back ( & AS_BIT_NOT ) ; operators . push_back ( & AS_BIT_XOR ) ; operators . push_back ( & AS_OPERATOR ) ; operators . push_back ( & AS_COMMA ) ; operators . push_back ( & AS_RETURN ) ; } void ASResource :: buildPre@@ BlockStatements ( vector < const string * > & preBlockStatements ) { preBlockStatements . push_back ( & AS_CLASS ) ; preBlockStatements . push_back ( & AS_STRUCT ) ; preBlockStatements . push_back ( & AS_UNION ) ; preBlockStatements . push_back ( & AS_INTERFACE ) ; preBlockStatements . push_back ( & AS_NAMESPACE ) ; preBlockStatements . push_back ( & AS_THROWS ) ; preBlockStatements . push_back ( & AS_EXTERN ) ; } void ASResource :: buildPre@@ CommandHeaders ( vector < const string * > & preCommandHeaders ) { preCommandHeaders . push_back ( & AS_EXTERN ) ; preCommandHeaders . push_back ( & AS_THROWS ) ; preCommandHeaders . push_back ( & AS_CONST ) ; } void ASResource :: buildPre@@ DefinitionHeaders ( vector < const string * > & preDefinitionHeaders ) { preDefinitionHeaders . push_back ( & AS_CLASS ) ; preDefinitionHeaders . push_back ( & AS_INTERFACE ) ; preDefinitionHeaders . push_back ( & AS_NAMESPACE ) ; preDefinitionHeaders . push_back ( & AS_STRUCT ) ; } } </DOCUMENT>
<DOCUMENT_ID="w@@ addlesp@@ lash@@ /Dol@@ phin@@ Qt/tree/master/External@@ s/wxWidget@@ s3@@ /src/osx/@@ carbon@@ /textctr@@ l.cpp"> # include " wx / wxprec . h " # if wxUSE_TEXT@@ CTRL # include " wx / textctrl . h " # ifndef WX_PRECOMP # include " wx / intl . h " # include " wx / app . h " # include " wx / utils . h " # include " wx / dc . h " # include " wx / button . h " # include " wx / menu . h " # include " wx / settings . h " # include " wx / msgdlg . h " # include " wx / toplevel . h " # endif # ifdef __DAR@@ WIN_@@ _ # include < sys / types . h > # include < sys / stat . h > # else # include < stat . h > # endif # if wxUSE_STD_@@ IOSTRE@@ AM # if wxUSE_IOSTRE@@ AMH # include < fstream . h > # else # include < fstream > # endif # endif # include " wx / filefn . h " # include " wx / sysopt . h " # include " wx / thread . h " # include " wx / osx / private . h " # include " wx / osx / carbon / private / mactext . h " class wxMacFunctor { public : wxMacFunctor ( ) { } virtual ~ wxMacFunctor ( ) { } virtual void * operator ( ) ( ) = 0 ; static void * CallBackProc ( void * param ) { wxMacFunctor * f = ( wxMacFunctor * ) param ; void * result = ( * f ) ( ) ; return result ; } } ; template < typename classtype , typename param1type > class wxMacObjectFunctor1 : public wxMacFunctor { typedef void ( classtype :: * function ) ( param1type p1 ) ; typedef void ( classtype :: * ref_function ) ( const param1type & p1 ) ; public : wxMacObjectFunctor1 ( classtype * obj , function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_function = f ; m_param1 = p1 ; } wxMacObjectFunctor1 ( classtype * obj , ref_function f , param1type p1 ) : wxMacFunctor ( ) { m_object = obj ; m_refFunction = f ; m_param1 = p1 ; } virtual ~ wxMacObjectFunctor1 ( ) { } virtual void * operator ( ) ( ) { ( m_object ->* m_function ) ( m_param1 ) ; return NULL ; } private : classtype * m_object ; param1type m_param1 ; union { function m_function ; ref_function m_refFunction ; } ; } ; template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteCall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMacObjectFunctor1 < classtype , param1type > params ( object , function , p1 ) ; void * result = MPRemoteCall ( wxMacFunctor :: CallBackProc , & params , kMPOwningProcessRemoteContext ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( param1type p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } template < typename classtype , typename param1type > void * wxMacMPRemoteGUICall ( classtype * object , void ( classtype :: * function ) ( const param1type & p1 ) , param1type p1 ) { wxMutexGuiLeave ( ) ; void * result = wxMacMPRemoteCall ( object , function , p1 ) ; wxMutexGuiEnter ( ) ; return result ; } class WXDLLEXPORT wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacPortSaver ) ; public : wxMacPortSaver ( GrafPtr port ) ; ~ wxMacPortSaver ( ) ; private : GrafPtr m_port ; } ; class WXDLLEXPORT wxMacWindowClipper : public wxMacPortSaver { wxDECLARE_NO_COPY_CLASS ( wxMacWindowClipper ) ; public : wxMacWindowClipper ( const wxWindow * win ) ; ~ wxMacWindowClipper ( ) ; private : GrafPtr m_newPort ; RgnHandle m_formerClip ; RgnHandle m_newClip ; } ; wxMacPortSaver :: wxMacPortSaver ( GrafPtr port ) { :: GetPort ( & m_port ) ; :: SetPort ( port ) ; } wxMacPortSaver :: ~ wxMacPortSaver ( ) { :: SetPort ( m_port ) ; } wxMacWindowClipper :: wxMacWindowClipper ( const wxWindow * win ) : wxMacPortSaver ( ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ) { m_newPort = ( GrafPtr ) GetWindowPort ( ( WindowRef ) win -> MacGetTopLevelWindowRef ( ) ) ; m_formerClip = NewRgn ( ) ; m_newClip = NewRgn ( ) ; GetClip ( m_formerClip ) ; if ( win ) { if ( win -> GetPeer ( ) ) { int x = 0 , y = 0 ; win -> MacWindow@@ ToRoot@@ Window ( & x , & y ) ; HIShape@@ GetAs@@ QDRgn ( ( ( wxWindow * ) win ) -> MacGet@@ Visible@@ Region ( true ) . GetWXHRG@@ N ( ) , m_newClip ) ; if ( ! EmptyRgn ( m_newClip ) ) OffsetRgn ( m_newClip , x , y ) ; } SetClip ( m_newClip ) ; } } wxMacWindowClipper :: ~ wxMacWindowClipper ( ) { SetPort ( m_newPort ) ; SetClip ( m_formerClip ) ; DisposeRgn ( m_newClip ) ; DisposeRgn ( m_formerClip ) ; } class wxMacMLTEControl : public wxMacControl , public wxTextWidgetImpl { public : wxMacMLTEControl ( wxTextCtrl * peer ) ; ~ wxMacMLTEControl ( ) { } virtual bool CanFocus ( ) const { return true ; } virtual wxString GetStringValue ( ) const ; virtual void SetStringValue ( const wxString & str ) ; static TXNFrameOptions FrameOptionsFromWXStyle ( long wxStyle ) ; void AdjustCreationAttributes ( const wxColour & background , bool visible ) ; virtual void SetFont ( const wxFont & font , const wxColour & foreground , long windowStyle , bool ignoreBlack ) ; virtual void SetBackgroundColour ( const wxColour & col ) ; virtual void SetStyle ( long start , long end , const wxTextAttr & style ) ; virtual void Copy ( ) ; virtual void Cut ( ) ; virtual void Paste ( ) ; virtual bool CanPaste ( ) const ; virtual void SetEditable ( bool editable ) ; virtual long GetLastPosition ( ) const ; virtual void Replace ( long from , long to , const wxString & str ) ; virtual void Remove ( long from , long to ) ; virtual void GetSelection ( long * from , long * to ) const ; virtual void SetSelection ( long from , long to ) ; virtual void WriteText ( const wxString & str ) ; virtual bool HasOwn@@ ContextMenu ( ) const { TXNCommandEventSupportOptions options ; TXNGetCommandEventSupport ( m_txn , & options ) ; return options & kTXNSupportEditCommandProcessing ; } virtual void CheckSpelling ( bool check ) { TXNSetSpellCheck@@ AsYou@@ Type ( m_txn , ( Boolean ) check ) ; } virtual void Clear ( ) ; virtual bool CanUndo ( ) const ; virtual void Undo ( ) ; virtual bool CanRedo ( ) const ; virtual void Redo ( ) ; virtual int GetNumberOfLines ( ) const ; virtual long XYToPosition ( long x , long y ) const ; virtual bool PositionToXY ( long pos , long * x , long * y ) const ; virtual void ShowPosition ( long pos ) ; virtual int GetLineLength ( long lineNo ) const ; virtual wxString GetLineText ( long lineNo ) const ; void SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) ; TXNObject GetTXNObject ( ) { return m_txn ; } protected : void TXNSetAttribute ( const wxTextAttr & style , long from , long to ) ; TXNObject m_txn ; } ; class wxMacMLTEHIViewControl : public wxMacMLTEControl { public : wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEHIViewControl ( ) ; virtual bool SetFocus ( ) ; virtual bool HasFocus ( ) const ; virtual void SetBackgroundColour ( const wxColour & col ) ; protected : HIViewRef m_scrollView ; HIViewRef m_textView ; } ; class wxMacMLTEClassicControl : public wxMacMLTEControl { public : wxMacMLTEClassicControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) ; virtual ~ wxMacMLTEClassicControl ( ) ; virtual void VisibilityChanged ( bool shown ) ; virtual void SuperChanged@@ Position ( ) ; virtual void MacControlUserPaneDrawProc ( wxInt16 part ) ; virtual wxInt16 MacControlUserPaneHitTestProc ( wxInt16 x , wxInt16 y ) ; virtual wxInt16 MacControlUserPaneTrackingProc ( wxInt16 x , wxInt16 y , void * actionProc ) ; virtual void MacControlUserPaneIdleProc ( ) ; virtual wxInt16 MacControlUserPaneKeyDown@@ Proc ( wxInt16 keyCode , wxInt16 charCode , wxInt16 modifiers ) ; virtual void MacControlUserPaneActivate@@ Proc ( bool activating ) ; virtual wxInt16 MacControlUserPaneFocusProc ( wxInt16 action ) ; virtual void MacControlUserPaneBackground@@ Proc ( void * info ) ; virtual bool SetupCursor ( const wxPoint & WXUNUSED ( pt ) ) { MacControlUserPaneIdleProc ( ) ; return true ; } virtual void Move ( int x , int y , int width , int height ) ; protected : OSStatus DoCreate ( ) ; void MacUpdate@@ Position ( ) ; void MacActivate@@ PaneText ( bool setActive ) ; void MacFocus@@ PaneText ( bool setFocus ) ; void MacSetObject@@ Visibility ( bool vis ) ; private : TXNFrame@@ ID m_txn@@ FrameID ; GrafPtr m_txn@@ Port ; WindowRef m_txn@@ Window ; Rect m_txn@@ ControlBounds ; Rect m_txn@@ VisBounds ; static pascal void TXNScroll@@ ActionProc ( ControlRef controlRef , ControlPartCode partCode ) ; static pascal void TXNScroll@@ InfoProc ( SInt32 iValue , SInt32 iMaximumValue , TXNScrollBarOrientation iScrollBarOrientation , SInt32 iRef@@ Con ) ; ControlRef m_sb@@ Horizontal ; SInt32 m_lastHorizontalValue ; ControlRef m_sb@@ Vertical ; SInt32 m_lastVertical@@ Value ; } ; wxWidget@@ Impl@@ Type * wxWidgetImpl :: CreateTextControl ( wxTextCtrl * wxpeer , wxWindow@@ Mac * WXUNUSED ( parent ) , wxWindow@@ ID WXUNUSED ( id ) , const wxString & str , const wxPoint & pos , const wxSize & size , long style , long WXUNUSED ( extra@@ Style ) ) { return new wxMacMLTEHIViewControl ( wxpeer , str , pos , size , style ) ; } static const EventTypeSpec unicodeTextControlEventList [ ] = { { kEventClassControl , kEventControlSetFocusPart } , } ; static pascal OSStatus wxMacUnicodeTextControlControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacUnicodeTextControl * focus = ( wxMacUnicodeTextControl * ) data ; wxMacCar@@ bonEvent cEvent ( event ) ; switch ( GetEventKind ( event ) ) { case kEventControlSetFocusPart : { ControlPartCode controlPart = cEvent . GetParameter < ControlPartCode > ( kEventParamControlPart , typeControlPartCode ) ; if ( controlPart == kControlFocusNoPart ) { focus -> GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } result = CallNextEventHandler ( handler , event ) ; if ( controlPart != kControlFocusNoPart ) { focus -> SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & focus -> m_selection ) ; } break ; } default : break ; } return result ; } static pascal OSStatus wxMacUnicodeTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassControl : result = wxMacUnicodeTextControlControlEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacUnicodeTextControlEventHandler ) wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { } wxMacUnicodeTextControl :: wxMacUnicodeTextControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacControl ( wxPeer ) , wxTextWidgetImpl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; m_selection . selStart = m_selection . selEnd = 0 ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; m_valueTag = kControlEditTextCFStringTag ; Boolean isPassword = ( m_windowStyle & wxTE_PASSWORD ) != 0 ; if ( isPassword ) { m_valueTag = kControlEditTextPassword@@ CFStringTag ; } OSStatus err = CreateEdit@@ UnicodeTextControl ( MAC_@@ WXHWND ( wxPeer -> MacGetTopLevelWindowRef ( ) ) , & bounds , cf , isPassword , NULL , & m_controlRef ) ; verify_noerr ( err ) ; if ( ! ( m_windowStyle & wxTE_MULTILINE ) ) SetData < Boolean > ( kControlEditTextPart , kControlEditTextSingleLine@@ Tag , true ) ; InstallEventHandlers ( ) ; } void wxMacUnicodeTextControl :: InstallEventHandlers ( ) { :: InstallControlEventHandler ( m_controlRef , GetwxMacUnicodeTextControl@@ EventHandlerUPP ( ) , GetEventTypeCount ( unicodeTextControlEventList ) , unicodeTextControlEventList , this , ( EventHandlerRef * ) & m_macTextCtrlEventHandler ) ; } wxMacUnicodeTextControl :: ~ wxMacUnicodeTextControl ( ) { :: RemoveEventHandler ( ( EventHandlerRef ) m_macTextCtrlEventHandler ) ; } void wxMacUnicodeTextControl :: VisibilityChanged ( bool shown ) { if ( ! ( m_windowStyle & wxTE_MULTILINE ) && shown ) { ControlEditTextSelectionRec sel ; CFStringRef value = NULL ; verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; verify_noerr ( GetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , & value ) ) ; verify_noerr ( SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; CFRelease ( value ) ; } } wxString wxMacUnicodeTextControl :: GetStringValue ( ) const { wxString result ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; result = cf . AsString ( ) ; } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacUnicodeTextControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; verify_noerr ( SetData < CFStringRef > ( 0 , m_valueTag , cf ) ) ; } void wxMacUnicodeTextControl :: Copy ( ) { SendHICommand ( kHICommand@@ Copy ) ; } void wxMacUnicodeTextControl :: Cut ( ) { SendHICommand ( kHICommand@@ Cut ) ; } void wxMacUnicodeTextControl :: Paste ( ) { SendHICommand ( kHICommand@@ Paste ) ; } bool wxMacUnicodeTextControl :: CanPaste ( ) const { return true ; } void wxMacUnicodeTextControl :: SetEditable ( bool WXUNUSED ( editable ) ) { # if 0 SetData < Boolean > ( kControlEditTextPart , kControlEditTextLocked@@ Tag , ( Boolean ) ! editable ) ; # endif } void wxMacUnicodeTextControl :: GetSelection ( long * from , long * to ) const { ControlEditTextSelectionRec sel ; if ( HasFocus ( ) ) verify_noerr ( GetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ) ; else sel = m_selection ; if ( from ) * from = sel . selStart ; if ( to ) * to = sel . selEnd ; } void wxMacUnicodeTextControl :: SetSelection ( long from , long to ) { ControlEditTextSelectionRec sel ; wxString result ; int textLength = 0 ; CFStringRef value = GetData < CFStringRef > ( 0 , m_valueTag ) ; if ( value ) { wxCFStringRef cf ( value ) ; textLength = cf . AsString ( ) . length ( ) ; } if ( ( from == - 1 ) && ( to == - 1 ) ) { from = 0 ; to = textLength ; } else { from = wxMin ( textLength , wxMax ( from , 0 ) ) ; if ( to == - 1 ) to = textLength ; else to = wxMax ( 0 , wxMin ( textLength , to ) ) ; } sel . selStart = from ; sel . selEnd = to ; if ( HasFocus ( ) ) SetData < ControlEditTextSelectionRec > ( 0 , kControlEditTextSelectionTag , & sel ) ; else m_selection = sel ; } void wxMacUnicodeTextControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; if ( HasFocus ( ) ) { wxCFStringRef cf ( st , m_font . GetEncoding ( ) ) ; CFStringRef value = cf ; SetData < CFStringRef > ( 0 , kControlEditTextInsertCFString@@ RefTag , & value ) ; } else { wxString val = GetStringValue ( ) ; long start , end ; GetSelection ( & start , & end ) ; val . Remove ( start , end - start ) ; val . insert ( start , str ) ; SetStringValue ( val ) ; SetSelection ( start + str . length ( ) , start + str . length ( ) ) ; } } class wxMacEditHelper { public : wxMacEditHelper ( TXNObject txn ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; m_txn = txn ; TXNGetTXNObjectControls ( m_txn , 1 , tag , m_data ) ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) { TXNControlData data [ ] = { { kTXNReadWrite } } ; TXNSetTXNObjectControls ( m_txn , false , 1 , tag , data ) ; } } ~ wxMacEditHelper ( ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; if ( m_data [ 0 ] . uValue == kTXNReadOnly ) TXNSetTXNObjectControls ( m_txn , false , 1 , tag , m_data ) ; } protected : TXNObject m_txn ; TXNControlData m_data [ 1 ] ; } ; wxMacMLTEControl :: wxMacMLTEControl ( wxTextCtrl * peer ) : wxMacControl ( peer ) , wxTextWidgetImpl ( peer ) { SetNeeds@@ FocusRect ( true ) ; } wxString wxMacMLTEControl :: GetStringValue ( ) const { wxString result ; OSStatus err ; Size actualSize = 0 ; { # if wxUSE_UNICODE Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; if ( actualSize > 0 ) { wxChar * ptr = NULL ; SetHandleSize ( theText , ( actualSize + 1 ) * sizeof ( UniChar ) ) ; HLock ( theText ) ; ( ( ( UniChar * ) * theText ) [ actualSize ] ) = 0 ; wxMBConvUTF16 converter ; size_t noChars = converter . MB2WC ( NULL , ( const char * ) * theText , 0 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Unable ▁ to ▁ count ▁ the ▁ number ▁ of ▁ characters ▁ in ▁ this ▁ string ! " ) ) ; ptr = new wxChar [ noChars + 1 ] ; noChars = converter . MB2WC ( ptr , ( const char * ) * theText , noChars + 1 ) ; wxASSERT_MSG ( noChars != wxCONV_FAILED , wxT ( " Conversion ▁ of ▁ string ▁ failed ! " ) ) ; ptr [ noChars ] = 0 ; HUnlock ( theText ) ; ptr [ actualSize ] = 0 ; result = wxString ( ptr ) ; delete [ ] ptr ; } DisposeHandle ( theText ) ; } # else Handle theText ; err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err != noErr ) { actualSize = 0 ; } else { actualSize = GetHandleSize ( theText ) ; if ( actualSize > 0 ) { HLock ( theText ) ; result = wxString ( * theText , wxConvLocal , actualSize ) ; HUnlock ( theText ) ; } DisposeHandle ( theText ) ; } # endif } # if ' \n ' == 10 wxMacConvertNewlines13To10 ( & result ) ; # else wxMacConvertNewlines10To13 ( & result ) ; # endif return result ; } void wxMacMLTEControl :: SetStringValue ( const wxString & str ) { wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper help ( m_txn ) ; SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; } TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } } TXNFrameOptions wxMacMLTEControl :: FrameOptionsFromWXStyle ( long wxStyle ) { TXNFrameOptions frameOptions = kTXNDontDraw@@ CaretWhenInactiveMask ; frameOptions |= kTXNDoFontSub@@ stitution@@ Mask ; if ( ! ( wxStyle & wxTE_NOHID@@ ESEL ) ) frameOptions |= kTXNDontDraw@@ SelectionWhenInactiveMask ; if ( wxStyle & ( wxHSCROLL | wxTE_DONTWRAP ) ) frameOptions |= kTXNWantHScrollBarMask ; if ( wxStyle & wxTE_MULTILINE ) { if ( ! ( wxStyle & wxTE_DONTWRAP ) ) frameOptions |= kTXNAlways@@ Wrap@@ AtView@@ Edge@@ Mask ; if ( ! ( wxStyle & wxTE_NO_VSCROLL ) ) { frameOptions |= kTXNWantVScrollBarMask ; } } else { frameOptions |= kTXNSingleLineOnlyMask ; } return frameOptions ; } void wxMacMLTEControl :: AdjustCreationAttributes ( const wxColour & background , bool WXUNUSED ( visible ) ) { TXNControlTag iControlTags [ ] = { kTXNDoFontSub@@ stitution , kTXNWord@@ Wrap@@ StateTag , } ; TXNControlData iControlData [ ] = { { true } , { kTXNNoAutoWrap } , } ; int toptag = WXSIZEOF ( iControlTags ) ; if ( m_windowStyle & wxTE_MULTILINE ) { iControlData [ 1 ] . uValue = ( m_windowStyle & wxTE_DONTWRAP ) ? kTXNNoAutoWrap : kTXNAutoWrap ; } OSStatus err = TXNSetTXNObjectControls ( m_txn , false , toptag , iControlTags , iControlData ) ; verify_noerr ( err ) ; Str255 fontName ; SInt16 fontSize ; Style fontStyle ; GetTheme@@ Font ( kTheme@@ SystemFont , GetApplicationScript ( ) , fontName , & fontSize , & fontStyle ) ; TXNTypeAttributes typeAttr [ ] = { { kTXNQDFontName@@ Attribute , kTXNQDFontName@@ AttributeSize , { ( void * ) fontName } } , { kTXNQDFontSizeAttribute , kTXNFontSize@@ AttributeSize , { ( void * ) ( fontSize << 16 ) } } , { kTXNQDFontStyle@@ Attribute , kTXNQDFontStyle@@ AttributeSize , { ( void * ) normal } } , } ; err = TXNSetTypeAttributes ( m_txn , WXSIZEOF ( typeAttr ) , typeAttr , kTXNStartOffset , kTXNEndOffset ) ; verify_noerr ( err ) ; if ( m_windowStyle & wxTE_PASSWORD ) { UniChar c = 0x00A5 ; err = TXNEcho@@ Mode ( m_txn , c , 0 , true ) ; verify_noerr ( err ) ; } TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; background . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; TXNCommandEventSupportOptions options ; if ( TXNGetCommandEventSupport ( m_txn , & options ) == noErr ) { options |= kTXNSupportEditCommandProcessing | kTXNSupportEdit@@ CommandUpdating | kTXNSupportFont@@ CommandProcessing | kTXNSupportFont@@ CommandUpdating ; bool checkSpelling = false ; if ( ! ( m_windowStyle & wxTE_READONLY ) ) { # if wxUSE_SYST@@ EM_@@ OPTIONS if ( wxSystemOptions :: HasOption ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) && ( wxSystemOptions :: GetOption@@ Int ( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1 ) ) { checkSpelling = true ; } # endif } if ( checkSpelling ) options |= kTXNSupportSpellCheck@@ CommandProcessing | kTXNSupportSpellCheck@@ CommandUpdating ; TXNSetCommandEventSupport ( m_txn , options ) ; } } void wxMacMLTEControl :: SetBackgroundColour ( const wxColour & col ) { TXNBackground tback ; tback . bgType = kTXNBackgroundTypeRGB ; col . GetRGBColor ( & tback . bg . color ) ; TXNSetBackground ( m_txn , & tback ) ; } static inline int wxConvertToTXN ( int x ) { return static_cast < int > ( x / 254.0 * 72 + 0.5 ) ; } void wxMacMLTEControl :: TXNSetAttribute ( const wxTextAttr & style , long from , long to ) { TXNTypeAttributes typeAttr [ 4 ] ; RGBColor color ; size_t typeAttrCount = 0 ; TXNMargins margins ; TXNControlTag controlTags [ 4 ] ; TXNControlData controlData [ 4 ] ; size_t controlAttrCount = 0 ; TXNTab * tabs = NULL ; bool relayout = false ; wxFont font ; if ( style . HasFont ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; font = style . GetFont ( ) ; typeAttr [ typeAttrCount ] . tag = kTXNATSUI@@ Style ; typeAttr [ typeAttrCount ] . size = kTXNATSUI@@ StyleSize ; typeAttr [ typeAttrCount ] . data . dataPtr = font . MacGet@@ ATSU@@ Style ( ) ; typeAttrCount ++ ; } if ( style . HasText@@ Colour ( ) ) { wxASSERT ( typeAttrCount < WXSIZEOF ( typeAttr ) ) ; style . GetText@@ Colour ( ) . GetRGBColor ( & color ) ; typeAttr [ typeAttrCount ] . tag = kTXNQDFontColor@@ Attribute ; typeAttr [ typeAttrCount ] . size = kTXNQDFontColor@@ AttributeSize ; typeAttr [ typeAttrCount ] . data . dataPtr = ( void * ) & color ; typeAttrCount ++ ; } if ( style . HasAlignment ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; SInt32 align ; switch ( style . GetAlignment ( ) ) { case wxTEXT_ALIGNMENT_@@ LEFT : align = kTXNFlush@@ Left ; break ; case wxTEXT_ALIGNMENT_@@ CENTRE : align = kTXNCenter ; break ; case wxTEXT_ALIGNMENT_@@ RIGHT : align = kTXNFlush@@ Right ; break ; case wxTEXT_ALIGNMENT_@@ JUS@@ TIFI@@ ED : align = kTXNFull@@ Just ; break ; default : case wxTEXT_ALIGNMENT_@@ DEFAULT : align = kTXNFlush@@ Default ; break ; } controlTags [ controlAttrCount ] = kTXNJust@@ ificationTag ; controlData [ controlAttrCount ] . sValue = align ; controlAttrCount ++ ; } if ( style . HasLeftIndent ( ) || style . HasRightIndent ( ) ) { wxASSERT ( controlAttrCount < WXSIZEOF ( controlTags ) ) ; controlTags [ controlAttrCount ] = kTXNMargin@@ sTag ; controlData [ controlAttrCount ] . marginsPtr = & margins ; verify_noerr ( TXNGetTXNObjectControls ( m_txn , 1 , & controlTags [ controlAttrCount ] , & controlData [ controlAttrCount ] ) ) ; if ( style . HasLeftIndent ( ) ) { margins . leftMargin = wxConvertToTXN ( style . GetLeftIndent ( ) ) ; } if ( style . HasRightIndent ( ) ) { margins . rightMargin = wxConvertToTXN ( style . GetRightIndent ( ) ) ; } controlAttrCount ++ ; } if ( style . HasTabs ( ) ) { const wxArray@@ Int & tabarray = style . GetT@@ abs ( ) ; controlTags [ controlAttrCount ] = kTXNTab@@ SettingsTag ; if ( tabarray . size ( ) > 0 ) controlData [ controlAttrCount ] . tabValue . value = wxConvertToTXN ( tabarray [ 0 ] ) ; else controlData [ controlAttrCount ] . tabValue . value = 72 ; controlData [ controlAttrCount ] . tabValue . tabType = kTXNLeft@@ Tab ; controlAttrCount ++ ; } if ( controlAttrCount > 0 ) { verify_noerr ( TXNSetTXNObjectControls ( m_txn , false , controlAttrCount , controlTags , controlData ) ) ; relayout = true ; } if ( typeAttrCount > 0 ) { verify_noerr ( TXNSetTypeAttributes ( m_txn , typeAttrCount , typeAttr , from , to ) ) ; if ( from != to ) relayout = true ; } if ( tabs != NULL ) { delete [ ] tabs ; } if ( relayout ) { TXNRecalc@@ TextLayout ( m_txn ) ; } } void wxMacMLTEControl :: SetFont ( const wxFont & font , const wxColour & foreground , long WXUNUSED ( windowStyle ) , bool WXUNUSED ( ignoreBlack ) ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( wxTextAttr ( foreground , wxNull@@ Colour , font ) , kTXNStartOffset , kTXNEndOffset ) ; } void wxMacMLTEControl :: SetStyle ( long start , long end , const wxTextAttr & style ) { wxMacEditHelper help ( m_txn ) ; TXNSetAttribute ( style , start , end ) ; } void wxMacMLTEControl :: Copy ( ) { TXNCopy ( m_txn ) ; } void wxMacMLTEControl :: Cut ( ) { TXNCut ( m_txn ) ; } void wxMacMLTEControl :: Paste ( ) { TXNPaste ( m_txn ) ; } bool wxMacMLTEControl :: CanPaste ( ) const { return TXNIsSc@@ rapP@@ astable ( ) ; } void wxMacMLTEControl :: SetEditable ( bool editable ) { TXNControlTag tag [ ] = { kTXNIOPrivilegesTag } ; TXNControlData data [ ] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ; TXNSetTXNObjectControls ( m_txn , false , WXSIZEOF ( tag ) , tag , data ) ; } long wxMacMLTEControl :: GetLastPosition ( ) const { wxTextPos actualsize = 0 ; Handle theText ; # if wxUSE_UNICODE OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNUnicodeTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) / sizeof ( UniChar ) ; DisposeHandle ( theText ) ; } # else OSErr err = TXNGetDataEncoded ( m_txn , kTXNStartOffset , kTXNEndOffset , & theText , kTXNTextData ) ; if ( err == noErr ) { actualsize = GetHandleSize ( theText ) ; DisposeHandle ( theText ) ; } # endif else { actualsize = 0 ; } return actualsize ; } void wxMacMLTEControl :: Replace ( long from , long to , const wxString & str ) { wxString value = str ; wxMacConvertNewlines10To13 ( & value ) ; wxMacEditHelper help ( m_txn ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNClear ( m_txn ) ; SetTXNData ( value , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } void wxMacMLTEControl :: Remove ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper help ( m_txn ) ; TXNSetSelection ( m_txn , from , to ) ; TXNClear ( m_txn ) ; } void wxMacMLTEControl :: GetSelection ( long * from , long * to ) const { TXNOffset f , t ; TXNGetSelection ( m_txn , & f , & t ) ; * from = f ; * to = t ; } void wxMacMLTEControl :: SetSelection ( long from , long to ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif if ( ( from == - 1 ) && ( to == - 1 ) ) TXNSelect@@ All ( m_txn ) ; else TXNSetSelection ( m_txn , from , to == - 1 ? kTXNEndOffset : to ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; } void wxMacMLTEControl :: WriteText ( const wxString & str ) { if ( ! wxIsMainThread ( ) ) { # if wxOSX_USE_CARBON wxMacMPRemoteGUICall < wxTextCtrl , wxString > ( ( wxTextCtrl * ) GetWXPeer ( ) , & wxTextCtrl :: WriteText , str ) ; # endif return ; } wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; long start , end , dummy ; GetSelection ( & start , & dummy ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif { wxMacEditHelper helper ( m_txn ) ; SetTXNData ( st , kTXNUseCurrentSelection , kTXNUseCurrentSelection ) ; } GetSelection ( & dummy , & end ) ; } void wxMacMLTEControl :: Clear ( ) { # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif wxMacEditHelper st ( m_txn ) ; TXNSetSelection ( m_txn , kTXNStartOffset , kTXNEndOffset ) ; TXNClear ( m_txn ) ; } bool wxMacMLTEControl :: CanUndo ( ) const { return TXNCanUndo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Undo ( ) { TXNUndo ( m_txn ) ; } bool wxMacMLTEControl :: CanRedo ( ) const { return TXNCanRedo ( m_txn , NULL ) ; } void wxMacMLTEControl :: Redo ( ) { TXNRedo ( m_txn ) ; } int wxMacMLTEControl :: GetNumberOfLines ( ) const { ItemCount lines = 0 ; TXNGetLine@@ Count ( m_txn , & lines ) ; return lines ; } long wxMacMLTEControl :: XYToPosition ( long x , long y ) const { Point curpt ; wxTextPos lastpos ; long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; lastpos = GetLastPosition ( ) ; for ( n = 0 ; n <= ( ItemCount ) lastpos ; ++ n ) { if ( y == ypos && x == xpos ) return n ; TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } return 0 ; } bool wxMacMLTEControl :: PositionToXY ( long pos , long * x , long * y ) const { Point curpt ; wxTextPos lastpos ; if ( y ) * y = 0 ; if ( x ) * x = 0 ; lastpos = GetLastPosition ( ) ; if ( pos <= lastpos ) { long xpos = 0 , ypos = 0 ; int lastHeight = 0 ; ItemCount n ; for ( n = 0 ; n <= ( ItemCount ) pos ; ++ n ) { TXNOffsetToPoint ( m_txn , n , & curpt ) ; if ( curpt . v > lastHeight ) { xpos = 0 ; if ( n > 0 ) ++ ypos ; lastHeight = curpt . v ; } else ++ xpos ; } if ( y ) * y = ypos ; if ( x ) * x = xpos ; } return false ; } void wxMacMLTEControl :: ShowPosition ( long pos ) { Point current , desired ; TXNOffset selstart , selend ; TXNGetSelection ( m_txn , & selstart , & selend ) ; TXNOffsetToPoint ( m_txn , selstart , & current ) ; TXNOffsetToPoint ( m_txn , pos , & desired ) ; OSErr theErr = noErr ; long dv = desired . v - current . v ; long dh = desired . h - current . h ; TXNShowSelection ( m_txn , kTXNShowStart ) ; theErr = TXNScroll ( m_txn , kTXNScrollUnitsInPixels , kTXNScrollUnitsInPixels , & dv , & dh ) ; } void wxMacMLTEControl :: SetTXNData ( const wxString & st , TXNOffset start , TXNOffset end ) { # if wxUSE_UNICODE wxMBConvUTF16 converter ; ByteCount byteBufferLen = converter . WC2MB ( NULL , st . wc_str ( ) , 0 ) ; wxASSERT_MSG ( byteBufferLen != wxCONV_FAILED , wxT ( " Conversion ▁ to ▁ UTF - 16 ▁ unexpected@@ ly ▁ failed " ) ) ; UniChar * unibuf = ( UniChar * ) malloc ( byteBufferLen + 2 ) ; converter . WC2MB ( ( char * ) unibuf , st . wc_str ( ) , byteBufferLen + 2 ) ; TXNSetData ( m_txn , kTXNUnicodeTextData , ( void * ) unibuf , byteBufferLen , start , end ) ; free ( unibuf ) ; # else wxChar@@ Buffer text = st . mb_str ( wxConvLocal ) ; TXNSetData ( m_txn , kTXNTextData , ( void * ) text . data ( ) , strlen ( text ) , start , end ) ; # endif } wxString wxMacMLTEControl :: GetLineText ( long lineNo ) const { wxString line ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { line += content [ theOffset ] ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return line ; } int wxMacMLTEControl :: GetLineLength ( long lineNo ) const { int theLength = 0 ; if ( lineNo < GetNumberOfLines ( ) ) { Point firstPoint ; Fixed lineWidth , lineHeight , currentHeight ; long ypos ; TXNOffsetToPoint ( m_txn , 0 , & firstPoint ) ; ypos = 0 ; currentHeight = 0 ; while ( ypos < lineNo ) { TXNGetLineMetrics ( m_txn , ypos ++ , & lineWidth , & lineHeight ) ; currentHeight += lineHeight ; } Point thePoint = { firstPoint . v + ( currentHeight >> 16 ) , firstPoint . h + ( 0 ) } ; TXNOffset theOffset ; TXNPointToOffset ( m_txn , thePoint , & theOffset ) ; wxString content = GetStringValue ( ) ; Point currentPoint = thePoint ; while ( thePoint . v == currentPoint . v && theOffset < content . length ( ) ) { ++ theLength ; TXNOffsetToPoint ( m_txn , ++ theOffset , & currentPoint ) ; } } return theLength ; } static const EventTypeSpec eventList [ ] = { { kEventClassTextInput , kEventTextInputUnicodeForKeyEvent } , } ; static pascal OSStatus wxMacUnicodeTextEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; wxMacMLTEHIViewControl * focus = ( wxMacMLTEHIViewControl * ) data ; switch ( GetEventKind ( event ) ) { case kEventTextInputUnicodeForKeyEvent : { TXNOffset from , to ; TXNGetSelection ( focus -> GetTXNObject ( ) , & from , & to ) ; if ( from == to ) TXNShowSelection ( focus -> GetTXNObject ( ) , kTXNShowStart ) ; result = CallNextEventHandler ( handler , event ) ; break ; } default : break ; } return result ; } static pascal OSStatus wxMacTextControlEventHandler ( EventHandlerCallRef handler , EventRef event , void * data ) { OSStatus result = eventNotHandledErr ; switch ( GetEventClass ( event ) ) { case kEventClassTextInput : result = wxMacUnicodeTextEventHandler ( handler , event , data ) ; break ; default : break ; } return result ; } DEFINE_ONE_SHOT_HANDLER_GETTER ( wxMacTextControlEventHandler ) wxMacMLTEHIViewControl :: wxMacMLTEHIViewControl ( wxTextCtrl * wxPeer , const wxString & str , const wxPoint & pos , const wxSize & size , long style ) : wxMacMLTEControl ( wxPeer ) { m_font = wxPeer -> GetFont ( ) ; m_windowStyle = style ; Rect bounds = wxMacGetBoundsForControl ( wxPeer , pos , size ) ; wxString st = str ; wxMacConvertNewlines10To13 ( & st ) ; HIRect hr = { { bounds . left , bounds . top } , { bounds . right - bounds . left , bounds . bottom - bounds . top } } ; m_scrollView = NULL ; TXNFrameOptions frameOptions = FrameOptionsFromWXStyle ( style ) ; if ( ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) || ( frameOptions & kTXNSingleLineOnlyMask ) ) { if ( frameOptions & ( kTXNWantVScrollBarMask | kTXNWantHScrollBarMask ) ) { HIScrollViewCreate ( ( frameOptions & kTXNWantHScrollBarMask ? kHIScrollViewOptions@@ HorizScroll : 0 ) | ( frameOptions & kTXNWantVScrollBarMask ? kHIScrollViewOptionsVertScroll : 0 ) , & m_scrollView ) ; } else { HIScrollViewCreate ( kHIScrollViewOptionsVertScroll , & m_scrollView ) ; HIScrollView@@ SetScrollBar@@ AutoHide ( m_scrollView , true ) ; } HIViewSetFrame ( m_scrollView , & hr ) ; HIViewSetVisible ( m_scrollView , true ) ; } m_textView = NULL ; HITextView@@ Create ( NULL , 0 , frameOptions , & m_textView ) ; m_txn = HITextView@@ GetTXNObject ( m_textView ) ; HIViewSetVisible ( m_textView , true ) ; if ( m_scrollView ) { HIViewAddSub@@ view ( m_scrollView , m_textView ) ; m_controlRef = m_scrollView ; InstallEventHandler ( ( WXWidget ) m_textView ) ; } else { HIViewSetFrame ( m_textView , & hr ) ; m_controlRef = m_textView ; } AdjustCreationAttributes ( * wxWHITE , true ) ; # ifndef __LP64__ wxMacWindowClipper c ( GetWXPeer ( ) ) ; # endif SetTXNData ( st , kTXNStartOffset , kTXNEndOffset ) ; TXNSetSelection ( m_txn , 0 , 0 ) ; TXNShowSelection ( m_txn , kTXNShowStart ) ; :: InstallControlEventHandler ( m_textView , GetwxMac@@ TextControl@@ EventHandlerUPP ( ) , GetEventTypeCount ( eventList ) , eventList , this , NULL ) ; } wxMacMLTEHIViewControl :: ~ wxMacMLTEHIViewControl ( ) { } bool wxMacMLTEHIViewControl :: SetFocus ( ) { return SetKeyboard@@ Focus ( GetControl@@ Owner ( m_textView ) , m_textView , kControlFocus@@ NextPart ) == noErr ; } bool wxMacMLTEHIViewControl :: HasFocus ( ) const { ControlRef control ; if ( GetUserFocusWindow ( ) == NULL ) return false ; GetKeyboard@@ Focus ( GetUserFocusWindow ( ) , & control ) ; return control == m_textView ; } void wxMacMLTEHIViewControl :: SetBackgroundColour ( const wxColour & col ) { HITextView@@ SetBackground@@ Color ( m_textView , col . GetPix@@ el ( ) ) ; } # endif </DOCUMENT>
<DOCUMENT_ID="TTi@@ mo/do@@ om3.@@ gpl/tree/master/@@ neo/tools/materialeditor/@@ MaterialDef.cpp"> # include " . . / . . / idlib / precompiled . h " # pragma hdrstop # include " MaterialDef . h " MaterialDef :: MaterialDef ( void ) { type = 0 ; quotes = false ; } MaterialDef :: ~ MaterialDef ( void ) { } DWORD MaterialDef :: GetView@@ Data ( const char * viewName ) { DWORD * value = NULL ; viewData . Get ( viewName , & value ) ; return * value ; } void MaterialDef :: SetView@@ Data ( const char * viewName , DWORD value ) { viewData . Set ( viewName , value ) ; } # define MATERIAL_DEF_FILE " MaterialEdit@@ orDefs . med " MaterialDefList MaterialDefManager :: materialDefs [ MaterialDefManager :: MATERIAL_DEF_NUM ] ; void MaterialDefManager :: InitializeMaterialDefLists ( ) { char * buffer ; int length = fileSystem -> ReadFile ( MATERIAL_DEF_FILE , ( void * * ) & buffer ) ; if ( length == - 1 ) { common -> Error ( " Couldn ' t ▁ load ▁ material ▁ editor ▁ definition : ▁ % s " , MATERIAL_DEF_FILE ) ; return ; } idLexer src ; if ( ! src . LoadMemory ( buffer , length , MATERIAL_DEF_FILE ) ) { common -> Error ( " Couldn ' t ▁ parse ▁ % s " , MATERIAL_DEF_FILE ) ; fileSystem -> FreeFile ( buffer ) ; } InitializeMaterialDefList ( & src , " materialprops " , & materialDefs [ MATERIAL_DEF_MATERIAL ] ) ; InitializeMaterialDefList ( & src , " stageprops " , & materialDefs [ MATERIAL_DEF_STAGE ] ) ; InitializeMaterialDefList ( & src , " special@@ mapstageprops " , & materialDefs [ MATERIAL_DEF_SPECI@@ AL_STAGE ] ) ; fileSystem -> FreeFile ( buffer ) ; } void MaterialDefManager :: InitializeMaterialDefList ( idLexer * src , const char * typeName , MaterialDefList * list ) { idToken token ; src -> Reset ( ) ; src -> SkipUntilString ( typeName ) ; src -> SkipUntilString ( " { " ) ; while ( 1 ) { if ( ! src -> Expect@@ AnyToken ( & token ) ) { return ; } if ( token == " } " ) { break ; } MaterialDef * newProp = new MaterialDef ( ) ; if ( ! token . Icmp ( " TYPE _ GROUP " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ GROUP ; } else if ( ! token . Icmp ( " TYPE _ BOOL " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ BOOL ; } else if ( ! token . Icmp ( " TYPE _ STRING " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_STRING ; } else if ( ! token . Icmp ( " TYPE _ FLOAT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ FLOAT ; } else if ( ! token . Icmp ( " TYPE _ INT " ) ) { newProp -> type = MaterialDef :: MATERIAL_DEF_TYPE_@@ INT ; } src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> dictName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayName = token ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; newProp -> displayInfo = token ; if ( newProp -> type == MaterialDef :: MATERIAL_DEF_TYPE_STRING ) { newProp -> quotes = false ; src -> ReadToken ( & token ) ; src -> ReadToken ( & token ) ; if ( token == "1" ) { newProp -> quotes = true ; } } src -> SkipRestOf@@ Line ( ) ; list -> Append ( newProp ) ; } } void MaterialDefManager :: DestroyMaterialDefLists ( ) { for ( int i = 0 ; i < MATERIAL_DEF_NUM ; i ++ ) { for ( int j = 0 ; j < materialDefs [ i ] . Num ( ) ; j ++ ) { delete materialDefs [ i ] [ j ] ; } materialDefs [ i ] . Clear ( ) ; } } MaterialDefList * MaterialDefManager :: GetMaterial@@ Defs ( int type ) { if ( type >= 0 && type < MATERIAL_DEF_NUM ) { return & materialDefs [ type ] ; } return NULL ; } </DOCUMENT>
<DOCUMENT_ID="Ch@@ illed@@ heart@@ /v@@ box/tree/master/src/lib@@ s/xp@@ com18a@@ 4/@@ nspr@@ pub/pr@@ /src/cplu@@ s/rcinr@@ val.cpp"> # include " rcinr@@ val . h " RCInterval :: ~ RCInterval ( ) { } RCInterval :: RCInterval ( RCInterval :: RCReser@@ ved@@ Interval special ) : RCBase ( ) { switch ( special ) { case RCInterval :: now : interval = PR_@@ Interval@@ Now ( ) ; break ; case RCInterval :: no_timeout : interval = PR_INTERVAL_NO_@@ TIME@@ OUT ; break ; case RCInterval :: no_wait : interval = PR_INTERVAL_NO_@@ WAIT ; break ; default : break ; } } </DOCUMENT>
<DOCUMENT_ID="do@@ min110@@ 1/malmo-ch@@ alleng@@ e/tree/master/@@ cpp/src/@@ main.cpp"> # include " LightBul@@ bApp / App . hpp " # include < wx / wxprec . h > # include " PigChase / PigChaseEvolution . hpp " # include " PigChase / TensorflowExporter . hpp " int main ( int argc , char * * argv ) { LightBulb :: App * app = new LightBulb :: App ( ) ; app -> addTra@@ ining@@ Plan ( new PigChaseEvolution ( ) ) ; app -> addExporter ( new TensorflowExporter ( ) ) ; wxApp :: SetInstance ( app ) ; wxEntry ( argc , argv ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="Tomcc@@ /dolphin/tree/master/Source/Core/@@ Core/HW/@@ EXI/EX@@ I_Device@@ AGP@@ .cpp"> # include " Core / HW / EXI / EXI _ DeviceAGP . h " # include < algorithm > # include < memory > # include < string > # include < vector > # include " Common / Chunk@@ File . h " # include " Common / CommonTypes . h " # include " Common / File . h " # include " Common / Logging / Log . h " # include " Common / StringUtil . h " # include " Core / ConfigManager . h " namespace ExpansionInterface { CEXIAgp :: CEXIAgp ( int index ) { m_slot = index ; m_rom_size = 0 ; LoadRom ( ) ; m_address = 0 ; } CEXIAgp :: ~ CEXIAgp ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; SaveFileFromEEPROM ( gbapath + " . sav " ) ; } void CEXIAgp :: CRC8 ( const u8 * data , u32 size ) { for ( u32 it = 0 ; it < size ; it ++ ) { u8 crc = 0 ; m_hash = m_hash ^ data [ it ] ; if ( m_hash & 1 ) crc ^= 0x5e ; if ( m_hash & 2 ) crc ^= 0xbc ; if ( m_hash & 4 ) crc ^= 0x61 ; if ( m_hash & 8 ) crc ^= 0xc2 ; if ( m_hash & 0x10 ) crc ^= 0x9d ; if ( m_hash & 0x20 ) crc ^= 0x23 ; if ( m_hash & 0x40 ) crc ^= 0x46 ; if ( m_hash & 0x80 ) crc ^= 0x8c ; m_hash = crc ; } } void CEXIAgp :: LoadRom ( ) { std :: string path ; std :: string filename ; std :: string ext ; std :: string gbapath ; SplitPath ( m_slot == 0 ? SConfig :: GetInstance ( ) . m_strGbaCartA : SConfig :: GetInstance ( ) . m_strGbaCartB , & path , & filename , & ext ) ; gbapath = path + filename ; LoadFileToROM ( gbapath + ext ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ rom : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; LoadFileToEEPROM ( gbapath + " . sav " ) ; INFO_LOG ( EXPANSIONINTERFACE , " Loaded ▁ GBA ▁ sav : ▁ % s ▁ card : ▁ % d " , gbapath . c_str ( ) , m_slot ) ; } void CEXIAgp :: LoadFileToROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_rom_size = filesize & 0xFFFFFFFF ; m_rom_mask = ( m_rom_size - 1 ) ; m_rom . resize ( m_rom_size ) ; pStream . ReadBytes ( m_rom . data ( ) , filesize ) ; } else { m_rom . resize ( 0x2000 ) ; } } void CEXIAgp :: LoadFileToEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " rb " ) ; if ( pStream ) { u64 filesize = pStream . GetSize ( ) ; m_eeprom_size = filesize & 0xFFFFFFFF ; m_eeprom_mask = ( m_eeprom_size - 1 ) ; m_eeprom . resize ( m_eeprom_size ) ; pStream . ReadBytes ( m_eeprom . data ( ) , filesize ) ; if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = 0 ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) NewVal = ( NewVal << 0x8 ) | m_eeprom [ index * 8 + indexb ] ; ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] = NewVal ; } m_eeprom_add_end = ( m_eeprom_size == 512 ? ( 2 + 6 ) : ( 2 + 14 ) ) ; m_eeprom_add_mask = ( m_eeprom_size == 512 ? 0x3F : 0x3FF ) ; m_eeprom_read_mask = ( m_eeprom_size == 512 ? 0x80 : 0x8000 ) ; m_eeprom_status_mask = ( m_rom_size == 0x2000000 ? 0x1FFFF00 : 0x1000000 ) ; } else m_eeprom_status_mask = 0 ; } else { m_eeprom_size = 0 ; m_eeprom . clear ( ) ; } } void CEXIAgp :: SaveFileFromEEPROM ( const std :: string & filename ) { File :: IOFile pStream ( filename , " wb " ) ; if ( pStream ) { if ( ( m_eeprom_size == 512 ) || ( m_eeprom_size == 8192 ) ) { std :: vector < u8 > temp_eeprom ( m_eeprom_size ) ; for ( u32 index = 0 ; index < ( m_eeprom_size / 8 ) ; index ++ ) { u64 NewVal = ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ index ] ; for ( u32 indexb = 0 ; indexb < 8 ; indexb ++ ) temp_eeprom [ index * 8 + ( 7 - indexb ) ] = ( NewVal >> ( indexb * 8 ) ) & 0xFF ; } pStream . WriteBytes ( temp_eeprom . data ( ) , m_eeprom_size ) ; } else { pStream . WriteBytes ( m_eeprom . data ( ) , m_eeprom_size ) ; } } } u32 CEXIAgp :: ImmRead ( u32 _uSize ) { u32 uData = 0 ; u8 RomVal1 , RomVal2 , RomVal3 , RomVal4 ; switch ( m_current_cmd ) { case 0xAE000000 : uData = 0x5AA@@ A5517 ; m_current_cmd = 0 ; break ; case 0xAE010000 : uData = ( m_return_pos == 0 ) ? 0x01020@@ 304 : 0xF@@ 0020@@ 304 ; if ( m_return_pos == 1 ) m_current_cmd = 0 ; else m_return_pos = 1 ; break ; case 0xAE020000 : if ( m_eeprom_write_status && ( ( m_rw_offset & m_eeprom_status_mask ) == m_eeprom_status_mask ) && ( m_eeprom_status_mask != 0 ) ) { RomVal1 = 0x1 ; RomVal2 = 0x0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; } CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_current_cmd = 0 ; break ; case 0xAE030000 : if ( _uSize == 1 ) { uData = 0xFF000000 ; m_current_cmd = 0 ; } else { RomVal1 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal2 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal3 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; RomVal4 = m_rom [ ( m_rw_offset ++ ) & m_rom_mask ] ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; CRC8 ( & RomVal4 , 1 ) ; CRC8 ( & RomVal3 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( RomVal4 << 8 ) | ( RomVal3 ) ; } break ; case 0xAE040000 : if ( m_eeprom_size == 0 ) RomVal1 = 0xFF ; else RomVal1 = ( m_eeprom . data ( ) ) [ m_eeprom_pos ] ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal1 << 24 ) | ( m_hash << 16 ) ; m_current_cmd = 0 ; break ; case 0xAE0B0000 : RomVal1 = EE_READ_@@ FALSE ; if ( ( m_eeprom_size != 0 ) && ( m_eeprom_pos >= EE_IGNORE_BITS ) && ( ( ( ( u64 * ) m_eeprom . data ( ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] ) >> ( ( EE_DATA_BITS - 1 ) - ( m_eeprom_pos - EE_IGNORE_BITS ) ) ) & 0x1 ) { RomVal1 = EE_READ_@@ TRUE ; } RomVal2 = 0 ; CRC8 ( & RomVal2 , 1 ) ; CRC8 ( & RomVal1 , 1 ) ; uData = ( RomVal2 << 24 ) | ( RomVal1 << 16 ) | ( m_hash << 8 ) ; m_eeprom_pos ++ ; m_current_cmd = 0 ; break ; case 0xAE070000 : case 0xAE0C0000 : uData = m_hash << 24 ; m_current_cmd = 0 ; break ; default : uData = 0x0 ; m_current_cmd = 0 ; break ; } DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ read ▁ % x " , uData ) ; return uData ; } void CEXIAgp :: ImmWrite ( u32 _uData , u32 _uSize ) { if ( ( _uSize == 1 ) && ( ( _uData & 0xFF000000 ) == 0 ) ) return ; u8 HashCmd ; u64 Mask ; DEBUG_LOG ( EXPANSIONINTERFACE , " AGP ▁ command ▁ % x " , _uData ) ; switch ( m_current_cmd ) { case 0xAE020000 : case 0xAE030000 : m_rw_offset = ( ( _uData & 0xFFFFFF00 ) >> ( 8 - 1 ) ) ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE040000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE070000 : m_eeprom_pos = ( ( _uData & 0xFFFF0000 ) >> 0x10 ) & m_eeprom_mask ; if ( m_eeprom_size != 0 ) ( ( m_eeprom . data ( ) ) ) [ ( m_eeprom_pos ) ] = ( _uData & 0x0000FF00 ) >> 0x8 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x0000FF00 ) >> 8 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0C0000 : if ( ( m_eeprom_pos < m_eeprom_add_end ) || ( m_eeprom_pos == ( ( m_eeprom_cmd & m_eeprom_read_mask ) ? m_eeprom_add_end : m_eeprom_add_end + EE_DATA_BITS ) ) ) { Mask = ( 1ULL << ( m_eeprom_add_end - std :: min ( m_eeprom_pos , m_eeprom_add_end ) ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_cmd |= Mask ; else m_eeprom_cmd &= ~ Mask ; if ( m_eeprom_pos == m_eeprom_add_end + EE_DATA_BITS ) { if ( m_eeprom_size != 0 ) ( ( u64 * ) ( m_eeprom . data ( ) ) ) [ ( m_eeprom_cmd >> 1 ) & m_eeprom_add_mask ] = m_eeprom_data ; m_eeprom_write_status = true ; } } else { Mask = ( 1ULL << ( m_eeprom_add_end + EE_DATA_BITS - 1 - m_eeprom_pos ) ) ; if ( ( _uData >> 16 ) & 0x1 ) m_eeprom_data |= Mask ; else m_eeprom_data &= ~ Mask ; } m_eeprom_pos ++ ; m_return_pos = 0 ; HashCmd = ( _uData & 0xFF000000 ) >> 24 ; CRC8 ( & HashCmd , 1 ) ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; case 0xAE0B0000 : m_eeprom_write_status = false ; break ; case 0xAE000000 : case 0xAE010000 : case 0xAE090000 : m_eeprom_write_status = false ; case 0xAE0A0000 : m_eeprom_pos = 0 ; default : m_current_cmd = _uData ; m_return_pos = 0 ; m_hash = 0xFF ; HashCmd = ( _uData & 0x00FF0000 ) >> 16 ; CRC8 ( & HashCmd , 1 ) ; break ; } } void CEXIAgp :: DoState ( PointerWrap & p ) { p . Do ( m_slot ) ; p . Do ( m_address ) ; p . Do ( m_current_cmd ) ; p . Do ( m_eeprom ) ; p . Do ( m_eeprom_cmd ) ; p . Do ( m_eeprom_data ) ; p . Do ( m_eeprom_mask ) ; p . Do ( m_eeprom_pos ) ; p . Do ( m_eeprom_size ) ; p . Do ( m_eeprom_add_end ) ; p . Do ( m_eeprom_add_mask ) ; p . Do ( m_eeprom_read_mask ) ; p . Do ( m_eeprom_status_mask ) ; p . Do ( m_eeprom_write_status ) ; p . Do ( m_hash ) ; p . Do ( m_position ) ; p . Do ( m_return_pos ) ; p . Do ( m_rom ) ; p . Do ( m_rom_mask ) ; p . Do ( m_rom_size ) ; p . Do ( m_rw_offset ) ; } } </DOCUMENT>
<DOCUMENT_ID="rle@@ wis@@ 1988@@ /lean@@ /tree/master/src/lib@@ rary/tactic/@@ smt/util@@ .cpp"> # include " library / annotation . h " # include " library / util . h " # include " library / replace _ visitor . h " # include " library / vm / vm . h " # include " library / tact@@ ic / smt / congru@@ ence _ closure . h " namespace lean { static name * g_cc_proof_name = nullptr ; static macro_definition * g_cc_proof_macro = nullptr ; class cc_proof_macro_cell : public macro_definition_cell { public : virtual name get_name ( ) const { return * g_cc_proof_name ; } virtual expr check_type ( expr const & e , abstract_type_context & ctx , bool ) const { return mk_eq ( ctx , macro_arg ( e , 0 ) , macro_arg ( e , 1 ) ) ; } virtual optional < expr > expand ( expr const & , abstract_type_context & ) const { lean_unreachable ( ) ; } virtual void write ( serializer & ) const { lean_unreachable ( ) ; } virtual bool operator == ( macro_definition_cell const & other ) const { cc_proof_macro_cell const * other_ptr = dynamic_cast < cc_proof_macro_cell const * > ( & other ) ; return other_ptr ; } virtual unsigned hash ( ) const { return 23 ; } } ; expr mk_delayed_cc_eq_proof ( expr const & e1 , expr const & e2 ) { expr args [ 2 ] = { e1 , e2 } ; return mk_macro ( * g_cc_proof_macro , 2 , args ) ; } bool is_delayed_cc_eq_proof ( expr const & e ) { return is_macro ( e ) && dynamic_cast < cc_proof_macro_cell const * > ( macro_def ( e ) . raw ( ) ) ; } static name * g_theory_proof = nullptr ; expr mark_cc_theory_proof ( expr const & pr ) { return mk_annotation ( * g_theory_proof , pr ) ; } bool is_cc_theory_proof ( expr const & e ) { return is_annotation ( e , * g_theory_proof ) ; } expr get_cc_@@ theory_proof_@@ arg ( expr const & pr ) { lean_assert ( is_cc_theory_proof ( pr ) ) ; return get_annot@@ ation_@@ arg ( pr ) ; } class expand_delayed_cc_proofs_fn : public replace_visitor { congruence_closure const & m_cc ; expr visit_macro ( expr const & e ) { if ( is_delayed_cc_eq_proof ( e ) ) { expr const & lhs = macro_arg ( e , 0 ) ; expr const & rhs = macro_arg ( e , 1 ) ; return * m_cc . get_eq_proof ( lhs , rhs ) ; } else { return replace_visitor :: visit_macro ( e ) ; } } public : expand_delayed_cc_proofs_fn ( congruence_closure const & cc ) : m_cc ( cc ) { } } ; expr expand_delayed_cc_pro@@ ofs ( congruence_closure const & cc , expr const & e ) { return expand_delayed_cc_proofs_fn ( cc ) ( e ) ; } void initialize_@@ smt_util ( ) { g_cc_proof_name = new name ( " cc _ proof " ) ; g_cc_proof_macro = new macro_definition ( new cc_proof_macro_cell ( ) ) ; g_theory_proof = new name ( " th _ proof " ) ; register_@@ annotation ( * g_theory_proof ) ; } void finalize_@@ smt_util ( ) { delete g_cc_proof_macro ; delete g_cc_proof_name ; delete g_theory_proof ; } } </DOCUMENT>
<DOCUMENT_ID="E@@ agle-X@@ /foll@@ y/tree/master/@@ foll@@ y/test/@@ IPAddress@@ Benchmark@@ .cpp"> # include < folly / IPAddress . h > # include < glog / logging . h > # include < folly / Bench@@ mark . h > using namespace folly ; using std :: string ; BENCHMARK ( ipv4@@ _to_string_inet_ntop , iters ) { folly :: IPAddressV4 ipv4Addr ( "127.0.0.1" ) ; in_addr ip = ipv4Addr . toAddr ( ) ; char outputString [ INE@@ T_ADDRSTRLEN ] = { 0 } ; while ( iters -- ) { const char * val = inet_ntop ( AF_@@ INE@@ T , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv4@@ _to_fully_qualified , iters ) { IPAddressV4 ip ( "127.0.0.1" ) ; while ( iters -- ) { string outputString = ip . toFullyQualified ( ) ; } } BENCHMARK_@@ DRAW_@@ LINE ( ) BENCHMARK ( ipv6@@ _to_string_inet_ntop , iters ) { IPAddressV6 ipv6Addr ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; in6_addr ip = ipv6Addr . toAddr ( ) ; char outputString [ INET@@ 6_@@ ADDRSTRLEN ] = { 0 } ; bool checkResult = ( iters == 1 ) ; while ( iters -- ) { const char * val = inet_ntop ( AF_@@ INET@@ 6 , & ip , outputString , sizeof ( outputString ) ) ; } } BENCHMARK_RELATIVE ( ipv6@@ _to_fully_qualified , iters ) { IPAddressV6 ip ( " F1E0:0ACE : FB94:7ADF : 22E8:6DE6:9672:3725" ) ; string outputString ; while ( iters -- ) { outputString = ip . toFullyQualified ( ) ; } } int main ( int argc , char * argv [ ] ) { gflags :: ParseCommand@@ LineFlags ( & argc , & argv , true ) ; runBenchmark@@ s ( ) ; return 0 ; } </DOCUMENT>
<DOCUMENT_ID="rf@@ loca/@@ MIT@@ K/tree/master/Plugins/org.@@ mitk@@ .gui@@ .qt@@ .diffusionimaging@@ app/src/@@ internal@@ /Perspect@@ ives/@@ QmitkDIAppConnectomicsPerspect@@ ive.cpp"> # include " QmitkDIAppConnectomicsPerspective . h " # include " berr@@ yIViewLayout . h " void QmitkDIAppConnectomicsPerspective :: CreateInitial@@ Layout ( berry :: IPageLayout :: Pointer layout ) { std :: string editorArea = layout -> GetEdit@@ orArea ( ) ; layout -> AddStandaloneView ( " org . mitk . views . datamanager " , false , berry :: IPageLayout :: LEFT , 0.3f , editorArea ) ; layout -> AddStandaloneView ( " org . mitk . views . controlvisualizationpropertiesview " , false , berry :: IPageLayout :: BOTTOM , .15f , " org . mitk . views . datamanager " ) ; berry :: IFolder@@ Layout :: Pointer left = layout -> CreateFolder ( " org . mbi . diffusionimaginginternal . leftcontrols " , berry :: IPageLayout :: BOTTOM , 0.1f , " org . mitk . views . controlvisualizationpropertiesview " ) ; layout -> AddStandalone@@ ViewPlace@@ holder ( " org . mitk . views . imagen@@ avigator " , berry :: IPageLayout :: BOTTOM , .4f , " org . mbi . diffusionimaginginternal . leftcontrols " , false ) ; left -> AddView ( " org . mitk . views . connectomicsstatistics " ) ; berry :: IViewLayout :: Pointer lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsstatistics " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsnetworkoperations " ) ; lo -> SetCloseable ( false ) ; left -> AddView ( " org . mitk . views . connectomicsdata " ) ; lo = layout -> GetViewLayout ( " org . mitk . views . connectomicsdata " ) ; lo -> SetCloseable ( false ) ; } </DOCUMENT>
<DOCUMENT_ID="j@@ errys@@ 123111/@@ pcsx2@@ /tree/master/plugins/@@ GSdx_@@ legacy/@@ linu@@ x_re@@ play.cpp"> # include " stdafx . h " # include < dlfc@@ n . h > static void * handle ; void help ( ) { fprintf ( stderr , " Loader ▁ gs ▁ file \n " ) ; fprintf ( stderr , " ARG1 ▁ GSdx ▁ plugin \n " ) ; fprintf ( stderr , " ARG2 ▁ . gs ▁ file \n " ) ; fprintf ( stderr , " ARG3 ▁ Ini ▁ directory \n " ) ; if ( handle ) { dlclose ( handle ) ; } exit ( 1 ) ; } char * read_env ( const char * var ) { char * v = getenv ( var ) ; if ( ! v ) { fprintf ( stderr , " Failed ▁ to ▁ get ▁ % s \n " , var ) ; help ( ) ; } return v ; } int main ( int argc , char * argv [ ] ) { if ( argc < 1 ) help ( ) ; char * plugin ; char * gs ; if ( argc > 2 ) { plugin = argv [ 1 ] ; gs = argv [ 2 ] ; } else { plugin = read_env ( " GSDUMP _ SO " ) ; gs = argv [ 1 ] ; } handle = dlopen ( plugin , RTLD_@@ LAZY | RTLD_@@ GLOB@@ AL ) ; if ( handle == NULL ) { fprintf ( stderr , " Failed ▁ to ▁ dlopen ▁ plugin ▁ % s \n " , plugin ) ; help ( ) ; } __attribute__ ( ( stdcall ) ) void ( * GSsetSettingsDir_ptr ) ( const char * ) ; __attribute__ ( ( stdcall ) ) void ( * GSReplay_ptr ) ( char * , int ) ; * ( void * * ) ( & GSsetSettingsDir_ptr ) = dlsym ( handle , " GSsetSettings@@ Dir " ) ; * ( void * * ) ( & GSReplay_ptr ) = dlsym ( handle , " GSRepla@@ y " ) ; if ( argc == 2 ) { char * ini = read_env ( " GSDUMP _ CONF " ) ; GSsetSettingsDir_ptr ( ini ) ; } else if ( argc == 4 ) { ( void ) GSsetSettingsDir_ptr ( argv [ 3 ] ) ; } else if ( argc == 3 ) { # ifdef XD@@ G_STD char * val = read_env ( " HOME " ) ; std :: string ini_dir ( val ) ; ini_dir += " / . config / pcs@@ x2 / inis " ; GSsetSettingsDir_ptr ( ini_dir . c_str ( ) ) ; # else fprintf ( stderr , " default ▁ ini ▁ dir ▁ only ▁ supported ▁ on ▁ XD@@ G \n " ) ; help ( ) ; # endif } GSReplay_ptr ( gs , 12 ) ; if ( handle ) { dlclose ( handle ) ; } } </DOCUMENT>
<DOCUMENT_ID="El@@ vishArti@@ san/@@ rivendell@@ /tree/master/ripc@@ d/@@ btsrc8@@ iii.cpp"> # include < stdlib . h > # include < qtimer . h > # include < rdapplication . h > # include " btsrc8@@ iii . h " # include " globals . h " BtSrc8Iii :: BtSrc8Iii ( RDMatrix * matrix , QObject * parent ) : Switch@@ er ( matrix , parent ) { bt_istate = 0 ; for ( int i = 0 ; i < BTSRC8III_@@ GPIO_@@ PIN@@ S ; i ++ ) { bt_gpi_state [ i ] = false ; bt_gpi_mask [ i ] = false ; } bt_matrix = matrix -> matrix ( ) ; bt_gpis = matrix -> gpis ( ) ; bt_gpos = matrix -> gpos ( ) ; RDTty * tty = new RDTty ( rda -> station ( ) -> name ( ) , matrix -> port ( RDMatrix :: Primar@@ y ) ) ; bt_device = new RDTTYDevice ( ) ; if ( tty -> active ( ) ) { bt_device -> setName ( tty -> port ( ) ) ; bt_device -> setSpeed ( tty -> baudRate ( ) ) ; bt_device -> setWord@@ Length ( tty -> dataBits ( ) ) ; bt_device -> setPar@@ ity ( tty -> parity ( ) ) ; bt_device -> open ( QIODevice :: Unbuffer@@ ed | QIODevice :: ReadWrite ) ; } delete tty ; bt_gpi_oneshot = new RDOneShot ( this ) ; connect ( bt_gpi_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpiOneshotData ( int ) ) ) ; bt_gpo_oneshot = new RDOneShot ( this ) ; connect ( bt_gpo_oneshot , SIGNAL ( timeout ( int ) ) , this , SLOT ( gpoOneshotData ( int ) ) ) ; QTimer * timer = new QTimer ( this , " poll _ timer " ) ; connect ( timer , SIGNAL ( timeout ( ) ) , this , SLOT ( processStatus ( ) ) ) ; timer -> start ( BTSRC8III_@@ POLL_INTER@@ VAL ) ; } BtSrc8Iii :: ~ BtSrc8Iii ( ) { delete bt_device ; delete bt_gpi_oneshot ; delete bt_gpo_oneshot ; } RDMatrix :: Type BtSrc8Iii :: type ( ) { return RDMatrix :: BtSrc8III ; } unsigned BtSrc8Iii :: gpiQuantity ( ) { return bt_gpis ; } unsigned BtSrc8Iii :: gpoQuantity ( ) { return bt_gpos ; } bool BtSrc8Iii :: primaryTtyActive ( ) { return true ; } bool BtSrc8Iii :: second@@ aryTtyActive ( ) { return false ; } void BtSrc8Iii :: processCommand ( RDMacro * cmd ) { char str [ 9 ] ; switch ( cmd -> command ( ) ) { case RDMacro :: GO : if ( ( cmd -> argQuantity ( ) != 5 ) || ( ( cmd -> arg ( 1 ) . lower ( ) != " i " ) && ( cmd -> arg ( 1 ) . lower ( ) != " o " ) ) || ( cmd -> arg ( 2 ) . toInt ( ) < 1 ) || ( cmd -> arg ( 3 ) . toInt ( ) > bt_gpos ) || ( cmd -> arg ( 2 ) . toInt ( ) > bt_gpos ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 1 ) . lower ( ) != " i " ) ) || ( ( cmd -> arg ( 3 ) . toInt ( ) != 1 ) && ( cmd -> arg ( 3 ) . toInt ( ) != 0 ) && ( cmd -> arg ( 3 ) . toInt ( ) != - 1 ) && ( cmd -> arg ( 1 ) . lower ( ) == " i " ) ) || ( cmd -> arg ( 4 ) . toInt ( ) < 0 ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; return ; } if ( cmd -> arg ( 3 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dF \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , false ) ; } } else { if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; } return ; } } else { if ( cmd -> arg ( 3 ) . toInt ( ) == - 1 ) { bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = false ; bt_device -> write ( " * 0SPA \n " , 7 ) ; } else { if ( cmd -> arg ( 4 ) . toInt ( ) == 0 ) { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dL \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) ) ; bt_device -> write ( str , 8 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; } } else { if ( cmd -> arg ( 1 ) . lower ( ) == " i " ) { if ( ! bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] ) { emit gpiChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpi_state [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; } bt_gpi_mask [ cmd -> arg ( 2 ) . toInt ( ) - 1 ] = true ; bt_gpi_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } if ( cmd -> arg ( 1 ) . lower ( ) == " o " ) { sprintf ( str , " * % dOR % dP % 02d \n " , BTSRC8III_UNIT_ID , cmd -> arg ( 2 ) . toInt ( ) , cmd -> arg ( 4 ) . toInt ( ) / 100 + 1 ) ; bt_device -> write ( str , 10 ) ; emit gpoChanged ( bt_matrix , cmd -> arg ( 2 ) . toInt ( ) - 1 , true ) ; bt_gpo_oneshot -> start ( cmd -> arg ( 2 ) . toInt ( ) - 1 , 500 ) ; } } } } if ( cmd -> echoRequested ( ) ) { cmd -> acknowledge ( true ) ; emit rmlEcho ( cmd ) ; } break ; default : cmd -> acknowledge ( false ) ; emit rmlEcho ( cmd ) ; break ; } } void BtSrc8Iii :: processStatus ( ) { char buffer [ 256 ] ; int n ; int gpi ; while ( ( n = bt_device -> read ( buffer , 255 ) ) > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { switch ( bt_istate ) { case 0 : if ( buffer [ i ] == ' S ' ) { bt_istate = 1 ; } break ; case 1 : if ( buffer [ i ] == ( BTSRC8III_UNIT_ID + '0' ) ) { bt_istate = 2 ; } else { bt_istate = 0 ; } break ; case 2 : if ( buffer [ i ] == ' P ' ) { bt_istate = 3 ; } else { bt_istate = 0 ; } break ; case 3 : if ( buffer [ i ] == ' , ' ) { bt_istate = 4 ; } else { bt_istate = 0 ; } break ; case 4 : if ( buffer [ i ] == ' A ' ) { bt_istate = 5 ; } else { bt_istate = 0 ; } break ; case 5 : case 7 : case 9 : case 11 : case 13 : case 15 : case 17 : case 19 : if ( buffer [ i ] == ' , ' ) { bt_istate ++ ; } else { bt_istate = 0 ; } break ; case 6 : case 8 : case 10 : case 12 : case 14 : case 16 : case 18 : case 20 : if ( buffer [ i ] == '0' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( bt_gpi_state [ gpi ] && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , false ) ; bt_gpi_state [ gpi ] = false ; } bt_istate ++ ; } if ( buffer [ i ] == '1' ) { gpi = ( bt_istate - 6 ) / 2 ; if ( ( ! bt_gpi_state [ gpi ] ) && ( ! bt_gpi_mask [ gpi ] ) ) { emit gpiChanged ( bt_matrix , gpi , true ) ; bt_gpi_state [ gpi ] = true ; } bt_istate ++ ; } break ; default : bt_istate = 0 ; } } } } void BtSrc8Iii :: gpiOneshotData ( int value ) { bt_gpi_mask [ value ] = false ; bt_device -> write ( " * 0SPA " , 5 ) ; } void BtSrc8Iii :: gpoOneshotData ( int value ) { emit gpoChanged ( bt_matrix , value , false ) ; } </DOCUMENT>
<DOCUMENT_ID="Yela@@ Seamless@@ /my@@ sql-server@@ /tree/master/storage@@ /ndb@@ /test/ndb@@ api/test@@ Limits.cpp"> # include < NDBT . hpp > # include < NDBT_Test . hpp > # include < NdbRestarter . hpp > # define CHECKNOTNULL ( p ) if ( ( p ) == NULL ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } # define CHECKEQUAL ( v , e ) if ( ( e ) != ( v ) ) { ndbout << " Error ▁ at ▁ line ▁ " << __LINE__ << " ▁ expected ▁ " << v << endl ; NDB_ERR ( trans -> getNdbError ( ) ) ; trans -> close ( ) ; return NDBT_FAILED ; } Uint32 setLongVarchar ( char * where , const char * what , Uint32 sz ) { where [ 0 ] = sz & 0xff ; where [ 1 ] = ( sz >> 8 ) & 0xff ; memcpy ( & where [ 2 ] , what , sz ) ; return ( sz + 2 ) ; } int activateErrorInsert ( NdbTransaction * trans , const NdbRecord * record , const NdbDictionary :: Table * tab , const char * buf , NdbRestarter * restarter , Uint32 val ) { if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 1 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } if ( restarter -> insertErrorInAllNodes ( val ) != 0 ) { g_err << " error ▁ insert ▁ 2 ▁ ( " << val << " ) ▁ failed " << endl ; return NDBT_FAILED ; } NdbOperation * insert = trans -> getNdbOperation ( tab ) ; CHECKNOTNULL ( insert ) ; CHECKEQUAL ( 0 , insert -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , insert -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , buf , 0 ) ) ) ; CHECKEQUAL ( 0 , insert -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , buf , 1 ) ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; return NDBT_OK ; } int testSegmentedSectionPk ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 maxKeyBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxAttrBytes = NDBT_Tables :: MaxKeyMaxVarType@@ AttrBytes ; const Uint32 srcBuffBytes = MAX ( maxKeyBytes , maxAttrBytes ) ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char bigAttrRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , maxKeyBytes ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , bigKeyRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) , & srcBuff [ 0 ] , maxAttrBytes ) ; NdbDictionary :: setNull ( record , bigAttrRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigInsert = trans -> insertTuple ( record , bigKeyRowBuf ) ; CHECKNOTNULL ( bigInsert ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsert = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; const NdbOperation * secondOp ; CHECKNOTNULL ( secondOp = trans -> insertTuple ( record , bigAttrRowBuf ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbOperation * bigInsertOldApi ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigKeyRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , bigAttrRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigInsertOldApi = trans -> getNdbOperation ( ctx -> getTab ( ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> insertTuple ( ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) ) ) ; CHECKEQUAL ( 0 , bigInsertOldApi -> setValue ( 1 , NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionIx ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL _ IX " ) != 0 ) return NDBT_OK ; const char * indexName = " WIDE _ 2COL _ IX $ NDBT _ IDX0" ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; const Uint32 srcBuffBytes = NDBT_Tables :: MaxVarTypeKeyBytes ; const Uint32 maxIndexKeyBytes = NDBT_Tables :: MaxKeyMaxVarType@@ AttrBytes@@ Index ; const Uint32 mediumPrimaryKeyBytes = ( 6 * 60 * 4 ) - 2 ; char smallKey [ 50 ] ; char srcBuff [ srcBuffBytes ] ; char smallRowBuf [ maxRowBytes ] ; char bigKeyIxBuf [ maxRowBytes ] ; char bigAttrIxBuf [ maxRowBytes ] ; char bigKeyRowBuf [ maxRowBytes ] ; char resultSpace [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; memset ( srcBuff , ' B ' , srcBuffBytes ) ; Ndb * pNdb = GETNDB ( step ) ; const NdbRecord * baseRecord = ctx -> getTab ( ) -> getDefaultRecord ( ) ; const NdbRecord * ixRecord = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( baseRecord , smallRowBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( ixRecord , bigKeyIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 0 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) , & srcBuff [ 0 ] , maxIndexKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigAttrIxBuf , 1 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 0 ) , & srcBuff [ 0 ] , mediumPrimaryKeyBytes ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( baseRecord , bigKeyRowBuf , 1 ) , " ShortIXKey " , 10 ) ; NdbDictionary :: setNull ( baseRecord , bigKeyRowBuf , 1 , false ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans -> insertTuple ( baseRecord , bigKeyRowBuf ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Commit ) ) ; NdbRestarter restarter ; trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8065 ) ) ; const NdbOperation * bigRead = trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ; CHECKNOTNULL ( bigRead ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKNOTNULL ( trans -> readTuple ( ixRecord , bigKeyIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKNOTNULL ( bigRead = trans -> readTuple ( ixRecord , bigAttrIxBuf , baseRecord , resultSpace ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # if 0 CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; const NdbDictionary :: Index * index ; CHECKNOTNULL ( index = pNdb -> getDictionary ( ) -> getIndex ( indexName , ctx -> getTab ( ) -> getName ( ) ) ) ; NdbIndexOperation * bigReadOldApi ; CHECKNOTNULL ( bigReadOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> readTuple ( ) ) ; CHECKEQUAL ( 0 , bigReadOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( ixRecord , bigKeyIxBuf , 1 ) ) ) ; CHECKNOTNULL ( bigReadOldApi -> getValue ( ( Uint32 ) 1 ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; NdbIndexOperation * bigUpdateOldApi ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8066 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; restarter . insertErrorInAllNodes ( 8067 ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKNOTNULL ( bigUpdateOldApi = trans -> getNdbIndexOperation ( index ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> updateTuple ( ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> equal ( ( Uint32 ) 0 , NdbDictionary :: getValuePtr ( baseRecord , smallRowBuf , 1 ) ) ) ; CHECKEQUAL ( 0 , bigUpdateOldApi -> setValue ( ( Uint32 ) 1 , NdbDictionary :: getValuePtr ( baseRecord , bigAttrIxBuf , 1 ) ) ) ; CHECKEQUAL ( - 1 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 218 , trans -> getNdbError ( ) . code ) trans -> close ( ) ; # endif CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , baseRecord , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; trans -> execute ( NdbTransaction :: Rollback ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testSegmentedSectionScan ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " WIDE _ 2COL " ) != 0 ) return NDBT_OK ; const Uint32 maxRowBytes = NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof ( Uint32 ) ; char smallKey [ 50 ] ; char smallRowBuf [ maxRowBytes ] ; Uint32 smallKeySize = setLongVarchar ( & smallKey [ 0 ] , " ShortKey " , 8 ) ; const NdbRecord * record = ctx -> getTab ( ) -> getDefaultRecord ( ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 0 ) , " ShortKey " , 8 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 0 , false ) ; setLongVarchar ( NdbDictionary :: getValuePtr ( record , smallRowBuf , 1 ) , " ShortData " , 9 ) ; NdbDictionary :: setNull ( record , smallRowBuf , 1 , false ) ; NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; NdbTransaction * trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ; CHECKNOTNULL ( trans ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8066 ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ; for ( Uint32 w = 0 ; w < 2500 ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; CHECKEQUAL ( 217 , scan -> getNdbError ( ) . code ) ; trans -> close ( ) ; CHECKNOTNULL ( trans = pNdb -> startTransaction ( ctx -> getTab ( ) , & smallKey [ 0 ] , smallKeySize ) ) ; CHECKEQUAL ( NDBT_OK , activateErrorInsert ( trans , record , ctx -> getTab ( ) , smallRowBuf , & restarter , 8068 ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: Rollback ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; trans -> close ( ) ; return NDBT_OK ; } int testDropSignalFragments ( NDBT_Context * ctx , NDBT_Step * step ) { NdbRestarter restarter ; Ndb * pNdb = GETNDB ( step ) ; const Uint32 PROG_WORDS = 16500 ; struct SubCase { Uint32 errorInsertCode ; int expectedRc ; } ; const Uint32 numSubCases = 5 ; const SubCase cases [ numSubCases ] = { { 0 , 874 } , { 8074 , 217 } , { 8075 , 217 } , { 8076 , 217 } , { 8077 , 217 } } ; const Uint32 numIterations = 50 ; Uint32 buff [ PROG_WORDS + 10 ] ; for ( Uint32 iteration = 0 ; iteration < ( numIterations * numSubCases ) ; iteration ++ ) { NdbTransaction * trans = pNdb -> startTransaction ( ) ; CHECKNOTNULL ( trans ) ; SubCase subcase = cases [ iteration % numSubCases ] ; Uint32 errorInsertVal = subcase . errorInsertCode ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; CHECKEQUAL ( 0 , restarter . insertErrorInAllNodes ( errorInsertVal ) ) ; NdbScanOperation * scan = trans -> getNdbScanOperation ( ctx -> getTab ( ) ) ; CHECKNOTNULL ( scan ) ; CHECKEQUAL ( 0 , scan -> readTuples ( ) ) ; NdbInterpretedCode prog ( ctx -> getTab ( ) , buff , PROG_WORDS + 10 ) ; for ( Uint32 w = 0 ; w < PROG_WORDS ; w ++ ) CHECKEQUAL ( 0 , prog . load_const_null ( 1 ) ) ; CHECKEQUAL ( 0 , prog . interpret_exit_ok ( ) ) ; CHECKEQUAL ( 0 , prog . finalise ( ) ) ; CHECKEQUAL ( 0 , scan -> setInterpretedCode ( & prog ) ) ; CHECKEQUAL ( 0 , trans -> execute ( NdbTransaction :: NoCommit ) ) ; CHECKEQUAL ( 0 , trans -> getNdbError ( ) . code ) ; CHECKEQUAL ( - 1 , scan -> nextResult ( ) ) ; int expectedResult = subcase . expectedRc ; CHECKEQUAL ( expectedResult , scan -> getNdbError ( ) . code ) ; scan -> close ( ) ; trans -> close ( ) ; } restarter . insertErrorInAllNodes ( 0 ) ; return NDBT_OK ; } int create100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; NdbDictionary :: Table tab ; tab . setName ( tabnameBuff ) ; NdbDictionary :: Column pk ; pk . setName ( " PK " ) ; pk . setType ( NdbDictionary :: Column :: Varchar ) ; pk . setLength ( 20 ) ; pk . setNul@@ lable ( false ) ; pk . setPrimary@@ Key ( true ) ; tab . addColumn ( pk ) ; pNdb -> getDictionary ( ) -> dropTable ( tab . getName ( ) ) ; if ( pNdb -> getDictionary ( ) -> createTable ( tab ) != 0 ) { ndbout << " Create ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; return NDBT_FAILED ; } ndbout << " Created ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } int drop100Tables ( NDBT_Context * ctx , NDBT_Step * step ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; for ( Uint32 t = 0 ; t < 100 ; t ++ ) { char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , t ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } } return NDBT_OK ; } int dropTable ( NDBT_Context * ctx , NDBT_Step * step , Uint32 num ) { Ndb * pNdb = GETNDB ( step ) ; const NdbDictionary :: Table * pTab = ctx -> getTab ( ) ; if ( strcmp ( pTab -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; char tabnameBuff [ 10 ] ; snprintf ( tabnameBuff , sizeof ( tabnameBuff ) , " TAB % u " , num ) ; if ( pNdb -> getDictionary ( ) -> dropTable ( tabnameBuff ) != 0 ) { ndbout << " Drop ▁ table ▁ failed ▁ with ▁ error ▁ : ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . code << " ▁ " << pNdb -> getDictionary ( ) -> getNdbError ( ) . message << endl ; } else { ndbout << " Dropped ▁ table ▁ " << tabnameBuff << endl ; } return NDBT_OK ; } enum Scenarios { DROP_TABLE , RESTART_MASTER , RESTART_SLAVE , NUM_SCENARIOS } ; enum Tasks { WAIT = 0 , DROP_TABLE_REQ = 1 , MASTER_RESTART_REQ = 2 , SLAVE_RESTART_REQ = 3 } ; int testWorker ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; while ( ! ctx -> isTestStopped ( ) ) { ndbout_c ( " Worker ▁ : ▁ waiting ▁ for ▁ request . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 1 ) ; if ( ! ctx -> isTestStopped ( ) ) { Uint32 req = ctx -> getProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; switch ( ( Tasks ) req ) { case DROP_TABLE_REQ : { ndbout_c ( " Worker ▁ : ▁ dropping ▁ table " ) ; if ( dropTable ( ctx , step , 2 ) != NDBT_OK ) { return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ table ▁ dropped . " ) ; break ; } case MASTER_RESTART_REQ : { ndbout_c ( " Worker ▁ : ▁ restarting ▁ Master " ) ; NdbRestarter restarter ; int master_nodeid = restarter . getMasterNodeId ( ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ Master ▁ ( % d ) . . . " , master_nodeid ) ; if ( restarter . restartOneDbNode2 ( master_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & master_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Master . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ master ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & master_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Master ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Master ▁ recovered . " ) ; break ; } case SLAVE_RESTART_REQ : { NdbRestarter restarter ; int slave_nodeid = restarter . getRandom@@ NotMasterNodeId ( rand ( ) ) ; ndbout_c ( " Worker ▁ : ▁ Restarting ▁ non - master ▁ ( % d ) . . . " , slave_nodeid ) ; if ( restarter . restartOneDbNode2 ( slave_nodeid , NdbRestarter :: NRRF_NOSTART | NdbRestarter :: NRRF_FORCE | NdbRestarter :: NRRF_ABORT ) || restarter . waitNodesNoStart ( & slave_nodeid , 1 ) || restarter . startAll ( ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ restarting ▁ Slave . " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Waiting ▁ for ▁ slave ▁ to ▁ recover . . . " ) ; if ( restarter . waitNodesStarted ( & slave_nodeid , 1 ) ) { ndbout_c ( " Worker ▁ : ▁ Error ▁ waiting ▁ for ▁ Slave ▁ restart " ) ; return NDBT_FAILED ; } ndbout_c ( " Worker ▁ : ▁ Slave ▁ recovered . " ) ; break ; } default : { break ; } } } ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) 0 ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 2 ) ; } ndbout_c ( " Worker , ▁ done . " ) ; return NDBT_OK ; } int testSlowDihFileWrites ( NDBT_Context * ctx , NDBT_Step * step ) { if ( strcmp ( ctx -> getTab ( ) -> getName ( ) , " T1" ) != 0 ) return NDBT_OK ; NdbRestarter restarter ; for ( Uint32 scenario = 0 ; scenario < NUM_SCENARIOS ; scenario ++ ) { ndbout_c ( " Inserting ▁ error ▁ 7235" ) ; restarter . insertErrorInAllNodes ( 7235 ) ; ndbout_c ( " Trigger@@ ing ▁ LCP " ) ; int dumpArg = 7099 ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; const Uint32 periodSeconds = 10 ; Uint32 waitPeriods = 6 ; dumpArg = 7032 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { if ( p == 3 ) { switch ( ( Scenarios ) scenario ) { case DROP_TABLE : { ndbout_c ( " Requesting ▁ DROP ▁ TABLE " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) DROP_TABLE_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_MASTER : { ndbout_c ( " Requesting ▁ Master ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) MASTER_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } case RESTART_SLAVE : { ndbout_c ( " Requesting ▁ Slave ▁ restart " ) ; ctx -> setProperty ( " DIHWritesRequestType " , ( Uint32 ) SLAVE_RESTART_REQ ) ; ctx -> setProperty ( " DIHWritesRequest " , ( Uint32 ) 1 ) ; break ; } default : break ; } } ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Clearing ▁ error ▁ insert . . . " ) ; restarter . insertErrorInAllNodes ( 0 ) ; waitPeriods = 2 ; for ( Uint32 p = 0 ; p < waitPeriods ; p ++ ) { ndbout_c ( " Dumping ▁ DIH ▁ page ▁ info ▁ to ▁ ndbd ▁ stdout " ) ; restarter . dumpStateAllNodes ( & dumpArg , 1 ) ; NdbSleep_MilliSleep ( periodSeconds * 1000 ) ; } ndbout_c ( " Waiting ▁ for ▁ worker ▁ to ▁ finish ▁ task . . . " ) ; ctx -> getPropertyWait ( " DIHWritesRequest " , 2 ) ; if ( ctx -> isTestStopped ( ) ) return NDBT_OK ; ndbout_c ( " Done . " ) ; } ctx -> stop@@ Test ( ) ; return NDBT_OK ; } NDBT_TESTSUIT@@ E ( testLimits ) ; TESTCASE ( " ExhaustSegmentedSection@@ Pk " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ PK " ) { INITIALIZER ( testSegmentedSectionPk ) ; } TESTCASE ( " ExhaustSegmentedSection@@ IX " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Unique ▁ index " ) { INITIALIZER ( testSegmentedSectionIx ) ; } TESTCASE ( " ExhaustSegmentedSection@@ Scan " , " Test ▁ behaviour ▁ at ▁ Segmented ▁ Section ▁ exhaustion ▁ for ▁ Scan " ) { INITIALIZER ( testSegmentedSectionScan ) ; } TESTCASE ( " DropSignalFragments " , " Test ▁ behaviour ▁ of ▁ Segmented ▁ Section ▁ exhaustion ▁ with ▁ fragmented ▁ signals " ) { INITIALIZER ( testDropSignalFragments ) ; } TESTCASE ( " SlowDihFileWrites " , " Test ▁ behaviour ▁ of ▁ slow ▁ Dih ▁ table ▁ file ▁ writes " ) { INITIALIZER ( create100Tables ) ; STEP ( testWorker ) ; STEP ( testSlowDihFileWrites ) ; FIN@@ ALIZER ( drop100Tables ) ; } NDBT_TESTSUIT@@ E_END ( testLimits ) ; int main ( int argc , const char * * argv ) { ndb@@ _init ( ) ; NDBT_TESTSUIT@@ E_INSTANCE ( testLimits ) ; return testLimits . execute ( argc , argv ) ; } </DOCUMENT>
<DOCUMENT_ID="Deepa@@ kpat@@ le/phantomjs/tree/master/src/qt/qtwebkit/Source/JavaScriptCore/@@ dfg/@@ DFG@@ AbstractState@@ .cpp"> # include " config . h " # include " DFG@@ AbstractState . h " # if ENABLE ( DFG_@@ JIT ) # include " CodeBlock . h " # include " DFG@@ BasicBlock . h " # include " GetByIdStatus . h " # include " Operations . h " # include " PutByIdStatus . h " # include " StringObject . h " namespace JSC { namespace DFG { AbstractState :: AbstractState ( Graph & graph ) : m_codeBlock ( graph . m_codeBlock ) , m_graph ( graph ) , m_variables ( m_codeBlock -> numParameters ( ) , graph . m_local@@ Vars ) , m_block ( 0 ) { } AbstractState :: ~ AbstractState ( ) { } void AbstractState :: begin@@ BasicBlock ( BasicBlock * basicBlock ) { ASSERT ( ! m_block ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> valuesAtHead . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtTail . numberOfLocals ( ) == basicBlock -> valuesAtTail . numberOfLocals ( ) ) ; ASSERT ( basicBlock -> variablesAtHead . numberOfLocals ( ) == basicBlock -> variablesAtTail . numberOfLocals ( ) ) ; for ( size_t i = 0 ; i < basicBlock -> size ( ) ; i ++ ) forNode ( basicBlock -> at ( i ) ) . clear ( ) ; m_variables = basicBlock -> valuesAtHead ; m_haveStructures = false ; for ( size_t i = 0 ; i < m_variables . numberOfArguments ( ) ; ++ i ) { if ( m_variables . argument ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } for ( size_t i = 0 ; i < m_variables . numberOfLocals ( ) ; ++ i ) { if ( m_variables . local ( i ) . m_currentKnownStructure . isNeitherClearNorTop ( ) ) { m_haveStructures = true ; break ; } } basicBlock -> cfaShouldRevisit = false ; basicBlock -> cfaHasVisited = true ; m_block = basicBlock ; m_isValid = true ; m_foundConstants = false ; m_branchDirection = InvalidBranchDirection ; } void AbstractState :: initialize ( Graph & graph ) { BasicBlock * root = graph . m_blocks [ 0 ] . get ( ) ; root -> cfaShouldRevisit = true ; root -> cfaHasVisited = false ; root -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { Node * node = root -> variablesAtHead . argument ( i ) ; ASSERT ( node -> op ( ) == SetArgument ) ; if ( ! node -> variableAccessData ( ) -> shouldUnbox@@ IfPossible ( ) ) { root -> valuesAtHead . argument ( i ) . makeTop ( ) ; continue ; } SpeculatedType prediction = node -> variableAccessData ( ) -> prediction ( ) ; if ( isInt32Speculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecInt32 ) ; else if ( isBooleanSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecBoolean ) ; else if ( isCellSpeculation ( prediction ) ) root -> valuesAtHead . argument ( i ) . set ( SpecCell ) ; else root -> valuesAtHead . argument ( i ) . makeTop ( ) ; root -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < root -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { Node * node = root -> variablesAtHead . local ( i ) ; if ( node && node -> variableAccessData ( ) -> isCaptured ( ) ) root -> valuesAtHead . local ( i ) . makeTop ( ) ; else root -> valuesAtHead . local ( i ) . clear ( ) ; root -> valuesAtTail . local ( i ) . clear ( ) ; } for ( BlockIndex blockIndex = 1 ; blockIndex < graph . m_blocks . size ( ) ; ++ blockIndex ) { BasicBlock * block = graph . m_blocks [ blockIndex ] . get ( ) ; if ( ! block ) continue ; if ( ! block -> isReachable ) continue ; block -> cfaShouldRevisit = false ; block -> cfaHasVisited = false ; block -> cfaFoundConstants = false ; for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfArguments ( ) ; ++ i ) { block -> valuesAtHead . argument ( i ) . clear ( ) ; block -> valuesAtTail . argument ( i ) . clear ( ) ; } for ( size_t i = 0 ; i < block -> valuesAtHead . numberOfLocals ( ) ; ++ i ) { block -> valuesAtHead . local ( i ) . clear ( ) ; block -> valuesAtTail . local ( i ) . clear ( ) ; } if ( ! block -> isOSR@@ Target ) continue ; if ( block -> bytecodeBegin != graph . m_osr@@ EntryBytecodeIndex ) continue ; for ( size_t i = 0 ; i < graph . m_mustHandleValues . size ( ) ; ++ i ) { AbstractValue value ; value . setMo@@ stSpec@@ ific ( graph . m_mustHandleValues [ i ] ) ; int operand = graph . m_mustHandleValues . operandForIndex ( i ) ; block -> valuesAtHead . operand ( operand ) . merge ( value ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ Initializing ▁ Block ▁ # % u , ▁ operand ▁ r % d , ▁ to ▁ " , blockIndex , operand ) ; block -> valuesAtHead . operand ( operand ) . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif } block -> cfaShouldRevisit = true ; } } bool AbstractState :: endBasicBlock ( Merge@@ Mode mergeMode ) { ASSERT ( m_block ) ; BasicBlock * block = m_block ; block -> cfaFoundConstants = m_foundConstants ; block -> cfaDid@@ Finish = m_isValid ; block -> cfaBranchDirection = m_branchDirection ; if ( ! m_isValid ) { reset ( ) ; return false ; } bool changed = false ; if ( mergeMode != DontMerge || ! ASSERT_DISABLED ) { for ( size_t argument = 0 ; argument < block -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ argument ▁ % zu . \n " , argument ) ; # endif AbstractValue & destination = block -> valuesAtTail . argument ( argument ) ; changed |= mergeStateAtTail ( destination , m_variables . argument ( argument ) , block -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < block -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ state ▁ for ▁ local ▁ % zu . \n " , local ) ; # endif AbstractValue & destination = block -> valuesAtTail . local ( local ) ; changed |= mergeStateAtTail ( destination , m_variables . local ( local ) , block -> variablesAtTail . local ( local ) ) ; } } ASSERT ( mergeMode != DontMerge || ! changed ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Branch ▁ direction ▁ = ▁ % s \n " , branchDire@@ ctionToString ( m_branchDirection ) ) ; # endif reset ( ) ; if ( mergeMode != Merge@@ ToSuccessors ) return changed ; return mergeToSuccessors ( m_graph , block ) ; } void AbstractState :: reset ( ) { m_block = 0 ; m_isValid = false ; m_branchDirection = InvalidBranchDirection ; } AbstractState :: BooleanResult AbstractState :: booleanResult ( Node * node , AbstractValue & value ) { JSValue childConst = value . value ( ) ; if ( childConst ) { if ( childConst . toBoolean ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> globalExec ( ) ) ) return DefinitelyTrue ; return DefinitelyFalse ; } if ( isCellSpeculation ( value . m_type ) && value . m_currentKnownStructure . hasSingleton ( ) ) { Structure * structure = value . m_currentKnownStructure . singleton ( ) ; if ( ! structure -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) && structure -> typeInfo ( ) . type ( ) != StringType ) return DefinitelyTrue ; } return UnknownBooleanResult ; } bool AbstractState :: startExecuting ( Node * node ) { ASSERT ( m_block ) ; ASSERT ( m_isValid ) ; m_didClobber = false ; node -> setCanExit ( false ) ; if ( ! node -> shouldGenerate ( ) ) return false ; return true ; } bool AbstractState :: startExecuting ( unsigned indexInBlock ) { return startExecuting ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: executeEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , filterEdge@@ ByUse ) ; } void AbstractState :: executeEdges ( unsigned indexInBlock ) { executeEdges ( m_block -> at ( indexInBlock ) ) ; } void AbstractState :: verifyEdge ( Node * , Edge edge ) { RELEASE_ASSERT ( ! ( forNode ( edge ) . m_type & ~ typeFilter@@ For ( edge . useKind ( ) ) ) ) ; } void AbstractState :: verifyEdges ( Node * node ) { DFG_NODE_DO_TO_CHILDREN ( m_graph , node , verifyEdge ) ; } bool AbstractState :: executeEffects ( unsigned indexInBlock , Node * node ) { if ( ! ASSERT_DISABLED ) verifyEdges ( node ) ; switch ( node -> op ( ) ) { case JSConstant : case Wea@@ kJSConstant : case Phantom@@ Arguments : { forNode ( node ) . set ( m_graph . valueOfJSConstant ( node ) ) ; break ; } case Identity : { forNode ( node ) = forNode ( node -> child1 ( ) ) ; break ; } case GetLocal : { VariableAccessData * variableAccessData = node -> variableAccessData ( ) ; if ( variableAccessData -> prediction ( ) == SpecNone ) { m_isValid = false ; break ; } AbstractValue value = m_variables . operand ( variableAccessData -> local ( ) ) ; if ( ! variableAccessData -> isCaptured ( ) ) { if ( value . isClear ( ) ) node -> setCanExit ( true ) ; } if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case GetLocal@@ Unlinked : { AbstractValue value = m_variables . operand ( node -> unlink@@ edLocal ( ) ) ; if ( value . value ( ) ) m_foundConstants = true ; forNode ( node ) = value ; break ; } case SetLocal : { m_variables . operand ( node -> local ( ) ) = forNode ( node -> child1 ( ) ) ; break ; } case MovHintAndCheck : { break ; } case MovHint : case Zo@@ mbie@@ Hint : { RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } case SetArgument : ASSERT ( ! m_block -> valuesAtHead . operand ( node -> local ( ) ) . isClear ( ) ) ; break ; case BitAnd : case BitOr : case BitXor : case BitRShift : case BitLShift : case BitURShift : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isInt32 ( ) && right . isInt32 ( ) ) { int32_t a = left . asInt32 ( ) ; int32_t b = right . asInt32 ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case BitAnd : constantWasSet = trySetConstant ( node , JSValue ( a & b ) ) ; break ; case BitOr : constantWasSet = trySetConstant ( node , JSValue ( a | b ) ) ; break ; case BitXor : constantWasSet = trySetConstant ( node , JSValue ( a ^ b ) ) ; break ; case BitRShift : constantWasSet = trySetConstant ( node , JSValue ( a >> static_cast < uint32_t > ( b ) ) ) ; break ; case BitLShift : constantWasSet = trySetConstant ( node , JSValue ( a << static_cast < uint32_t > ( b ) ) ) ; break ; case BitURShift : constantWasSet = trySetConstant ( node , JSValue ( static_cast < uint32_t > ( a ) >> static_cast < uint32_t > ( b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case UInt32ToNumber : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { ASSERT ( child . isInt32 ( ) ) ; if ( trySetConstant ( node , JSValue ( child . asUInt32 ( ) ) ) ) { m_foundConstants = true ; break ; } } if ( ! node -> canSpeculateInteger ( ) ) forNode ( node ) . set ( SpecDouble ) ; else { forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; } break ; } case DoubleAsInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { double asDouble = child . asNumber ( ) ; int32_t asInt = JSC :: toInt32 ( asDouble ) ; if ( bitwise_cast < int64_t > ( static_cast < double > ( asInt ) ) == bitwise_cast < int64_t > ( asDouble ) && trySetConstant ( node , JSValue ( asInt ) ) ) { m_foundConstants = true ; break ; } } node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; } case ValueToInt32 : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) ) { bool constantWasSet ; if ( child . isInt32 ( ) ) constantWasSet = trySetConstant ( node , child ) ; else constantWasSet = trySetConstant ( node , JSValue ( JSC :: toInt32 ( child . asDouble ( ) ) ) ) ; if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecInt32 ) ; break ; } case Int32ToDouble : case Forward@@ Int32ToDouble : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( JSValue :: Encode@@ AsDouble , child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } if ( isInt32Speculation ( forNode ( node -> child1 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; } case ValueAdd : case ArithAdd : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) + right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) && isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT ( node -> op ( ) == ValueAdd ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecString | SpecInt32 | SpecNumber ) ; break ; } break ; } case MakeRope : { forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case ArithSub : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) - right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithNeg@@ ate : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( - child . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithMul : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , JSValue ( left . asNumber ( ) * right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; if ( ! nodeCanTruncateInteger ( node -> arithNodeFlags ( ) ) || ! nodeCan@@ IgnoreNeg@@ ativeZero ( node -> arithNodeFlags ( ) ) ) node -> setCanExit ( true ) ; break ; case NumberUse : if ( isRealNumberSpeculation ( forNode ( node -> child1 ( ) ) . m_type ) || isRealNumberSpeculation ( forNode ( node -> child2 ( ) ) . m_type ) ) forNode ( node ) . set ( SpecDoubleReal ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithIMul : { forNode ( node ) . set ( SpecInt32 ) ; break ; } case ArithDiv : case ArithMin : case ArithMax : case ArithMod : { JSValue left = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue right = forNode ( node -> child2 ( ) ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) ) { double a = left . asNumber ( ) ; double b = right . asNumber ( ) ; bool constantWasSet ; switch ( node -> op ( ) ) { case ArithDiv : constantWasSet = trySetConstant ( node , JSValue ( a / b ) ) ; break ; case ArithMin : constantWasSet = trySetConstant ( node , JSValue ( a < b ? a : ( b <= a ? b : a + b ) ) ) ; break ; case ArithMax : constantWasSet = trySetConstant ( node , JSValue ( a > b ? a : ( b >= a ? b : a + b ) ) ) ; break ; case ArithMod : constantWasSet = trySetConstant ( node , JSValue ( fmod ( a , b ) ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } switch ( node -> binaryUseKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithAbs : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( fabs ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Int32Use : forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( true ) ; break ; case NumberUse : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case ArithSqrt : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && child . isNumber ( ) && trySetConstant ( node , JSValue ( sqrt ( child . asNumber ( ) ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecDouble ) ; break ; } case Logical@@ Not : { bool didSetConstant = false ; switch ( booleanResult ( node , forNode ( node -> child1 ( ) ) ) ) { case DefinitelyTrue : didSetConstant = trySetConstant ( node , jsBoolean ( false ) ) ; break ; case DefinitelyFalse : didSetConstant = trySetConstant ( node , jsBoolean ( true ) ) ; break ; default : break ; } if ( didSetConstant ) { m_foundConstants = true ; break ; } switch ( node -> child1 ( ) . useKind ( ) ) { case Boolean@@ Use : case Int32Use : case NumberUse : case UntypedUse : break ; case ObjectOr@@ OtherUse : node -> setCanExit ( true ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( SpecBoolean ) ; break ; } case IsUndefined : case IsBoolean : case IsNumber : case IsString : case IsObject : case IsFunction : { node -> setCanExit ( node -> op ( ) == IsUndefined && m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child ) { bool constantWasSet ; switch ( node -> op ( ) ) { case IsUndefined : if ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> masqueradesAsUndefinedWatchpoint ( ) -> isStillValid ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? false : child . isUndefined ( ) ) ) ; } else { constantWasSet = trySetConstant ( node , jsBoolean ( child . isCell ( ) ? child . asCell ( ) -> structure ( ) -> masqueradesAsUndefined ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) ) : child . isUndefined ( ) ) ) ; } break ; case IsBoolean : constantWasSet = trySetConstant ( node , jsBoolean ( child . isBoolean ( ) ) ) ; break ; case IsNumber : constantWasSet = trySetConstant ( node , jsBoolean ( child . isNumber ( ) ) ) ; break ; case IsString : constantWasSet = trySetConstant ( node , jsBoolean ( isJS@@ String ( child ) ) ) ; break ; case IsObject : if ( child . isNull ( ) || ! child . isObject ( ) ) { constantWasSet = trySetConstant ( node , jsBoolean ( child . isNull ( ) ) ) ; break ; } default : constantWasSet = false ; break ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } } forNode ( node ) . set ( SpecBoolean ) ; break ; } case TypeOf : { VM * vm = m_codeBlock -> vm ( ) ; JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; AbstractValue & abstractChild = forNode ( node -> child1 ( ) ) ; if ( child ) { JSValue typeString = jsTypeStringFor@@ Value ( * vm , m_codeBlock -> globalObjectFor ( node -> codeOrigin ) , child ) ; if ( trySetConstant ( node , typeString ) ) { m_foundConstants = true ; break ; } } else if ( isNumberSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . numberString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecNumber ) ; m_foundConstants = true ; break ; } } else if ( isString@@ Speculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . stringString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; m_foundConstants = true ; break ; } } else if ( isFinal@@ ObjectSpeculation ( abstractChild . m_type ) || isArray@@ Speculation ( abstractChild . m_type ) || isArguments@@ Speculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . objectString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFinalObject | SpecArray | SpecArguments ) ; m_foundConstants = true ; break ; } } else if ( isFunction@@ Speculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . functionString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecFunction ) ; m_foundConstants = true ; break ; } } else if ( isBooleanSpeculation ( abstractChild . m_type ) ) { if ( trySetConstant ( node , vm -> smallStrings . booleanString ( ) ) ) { forNode ( node -> child1 ( ) ) . filter ( SpecBoolean ) ; m_foundConstants = true ; break ; } } switch ( node -> child1 ( ) . useKind ( ) ) { case StringUse : case CellUse : node -> setCanExit ( true ) ; break ; case UntypedUse : break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case CompareLess : case CompareLessEq : case CompareGreater : case CompareGreaterEq : case CompareEq : case CompareEqConstant : { bool constantWasSet = false ; JSValue leftConst = forNode ( node -> child1 ( ) ) . value ( ) ; JSValue rightConst = forNode ( node -> child2 ( ) ) . value ( ) ; if ( leftConst && rightConst && leftConst . isNumber ( ) && rightConst . isNumber ( ) ) { double a = leftConst . asNumber ( ) ; double b = rightConst . asNumber ( ) ; switch ( node -> op ( ) ) { case CompareLess : constantWasSet = trySetConstant ( node , jsBoolean ( a < b ) ) ; break ; case CompareLessEq : constantWasSet = trySetConstant ( node , jsBoolean ( a <= b ) ) ; break ; case CompareGreater : constantWasSet = trySetConstant ( node , jsBoolean ( a > b ) ) ; break ; case CompareGreaterEq : constantWasSet = trySetConstant ( node , jsBoolean ( a >= b ) ) ; break ; case CompareEq : constantWasSet = trySetConstant ( node , jsBoolean ( a == b ) ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; constantWasSet = false ; break ; } } if ( ! constantWasSet && ( node -> op ( ) == CompareEqConstant || node -> op ( ) == CompareEq ) ) { SpeculatedType leftType = forNode ( node -> child1 ( ) ) . m_type ; SpeculatedType rightType = forNode ( node -> child2 ( ) ) . m_type ; if ( ( isInt32Speculation ( leftType ) && isOtherSpeculation ( rightType ) ) || ( isOtherSpeculation ( leftType ) && isInt32Speculation ( rightType ) ) ) constantWasSet = trySetConstant ( node , jsBoolean ( false ) ) ; } if ( constantWasSet ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case CompareStrict@@ Eq : case CompareStrict@@ EqConstant : { Node * leftNode = node -> child1 ( ) . node ( ) ; Node * rightNode = node -> child2 ( ) . node ( ) ; JSValue left = forNode ( leftNode ) . value ( ) ; JSValue right = forNode ( rightNode ) . value ( ) ; if ( left && right && left . isNumber ( ) && right . isNumber ( ) && trySetConstant ( node , jsBoolean ( left . asNumber ( ) == right . asNumber ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecBoolean ) ; node -> setCanExit ( true ) ; break ; } case StringChar@@ CodeAt : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case StringFromChar@@ Code : forNode ( node ) . set ( SpecString ) ; break ; case StringChar@@ At : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case GetByVal : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: SelectUsing@@ Predictions : case Array :: Unprofile@@ d : case Array :: Undec@@ ided : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: String : forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; case Array :: Arguments : forNode ( node ) . makeTop ( ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) { clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; } else if ( node -> arrayMode ( ) . isSane@@ Chain ( ) ) forNode ( node ) . set ( SpecDouble ) ; else forNode ( node ) . set ( SpecDoubleReal ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Array :: Int8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Int32Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint8ClampedArray : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint16Array : forNode ( node ) . set ( SpecInt32 ) ; break ; case Array :: Uint32Array : if ( node -> shouldSpeculateInteger ( ) ) forNode ( node ) . set ( SpecInt32 ) ; else forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float32Array : forNode ( node ) . set ( SpecDouble ) ; break ; case Array :: Float64Array : forNode ( node ) . set ( SpecDouble ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } break ; } case PutByVal : case PutByVal@@ Alias : { node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . modeForPut ( ) . type ( ) ) { case Array :: ForceExit : m_isValid = false ; break ; case Array :: Generic : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Int32 : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Double : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: Contiguous : case Array :: ArrayStorage : if ( node -> arrayMode ( ) . isOutOfBounds ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case Array :: SlowPutArrayStorage : if ( node -> arrayMode ( ) . may@@ StoreToHo@@ le ( ) ) clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : break ; } break ; } case ArrayPush : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . set ( SpecNumber ) ; break ; case ArrayPop : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case RegExp@@ Exec : forNode ( node ) . makeTop ( ) ; break ; case RegExp@@ Test : forNode ( node ) . set ( SpecBoolean ) ; break ; case Jump : break ; case Branch : { Node * child = node -> child1 ( ) . node ( ) ; BooleanResult result = booleanResult ( node , forNode ( child ) ) ; if ( result == DefinitelyTrue ) { m_branchDirection = TakeTrue ; break ; } if ( result == DefinitelyFalse ) { m_branchDirection = TakeFalse ; break ; } node -> setCanExit ( true ) ; m_branchDirection = TakeBoth ; break ; } case Return : m_isValid = false ; break ; case Throw : case ThrowReferenceError : m_isValid = false ; node -> setCanExit ( true ) ; break ; case ToPrimitive : { JSValue childConst = forNode ( node -> child1 ( ) ) . value ( ) ; if ( childConst && childConst . isNumber ( ) && trySetConstant ( node , childConst ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> child1 ( ) . useKind ( ) == UntypedUse ) ; AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; SpeculatedType type = source . m_type ; if ( type & ~ ( SpecNumber | SpecString | SpecBoolean ) ) { type &= ( SpecNumber | SpecString | SpecBoolean ) ; type |= SpecString ; } destination . set ( type ) ; break ; } case ToString : { switch ( node -> child1 ( ) . useKind ( ) ) { case StringObjectUse : forNode ( node -> child1 ( ) ) . filter ( m_graph . globalObjectFor ( node -> codeOrigin ) -> stringObjectStructure ( ) ) ; node -> setCanExit ( true ) ; break ; case StringOr@@ StringObjectUse : node -> setCanExit ( true ) ; break ; case CellUse : case UntypedUse : clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node ) . set ( m_graph . m_vm . stringStructure . get ( ) ) ; break ; } case NewStringObject : { ASSERT ( node -> structure ( ) -> classInfo ( ) == & StringObject :: s_info ) ; forNode ( node ) . set ( node -> structure ( ) ) ; break ; } case NewArray : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArray@@ Buffer : node -> setCanExit ( true ) ; forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> arrayStructureForIndexingTypeDuringAllocation ( node -> indexingType ( ) ) ) ; m_haveStructures = true ; break ; case NewArray@@ WithSize : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecArray ) ; m_haveStructures = true ; break ; case NewReg@@ exp : forNode ( node ) . set ( m_graph . globalObjectFor ( node -> codeOrigin ) -> regExpStructure ( ) ) ; m_haveStructures = true ; break ; case ConvertThis : { AbstractValue & source = forNode ( node -> child1 ( ) ) ; AbstractValue & destination = forNode ( node ) ; destination = source ; destination . merge ( SpecObjectOther ) ; break ; } case CreateThis : { forNode ( node ) . set ( SpecFinalObject ) ; break ; } case AllocationProfile@@ Watchpoint : node -> setCanExit ( true ) ; break ; case NewObject : forNode ( node ) . set ( node -> structure ( ) ) ; m_haveStructures = true ; break ; case CreateActivation : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> activationStructure ( ) ) ; m_haveStructures = true ; break ; case CreateArguments : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> arguments@@ Structure ( ) ) ; m_haveStructures = true ; break ; case TearOff@@ Activation : case TearOff@@ Arguments : break ; case CheckArguments@@ NotCreated : if ( isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) m_foundConstants = true ; else node -> setCanExit ( true ) ; break ; case GetMyArguments@@ Length : if ( node -> codeOrigin . inlineCallFrame ) forNode ( node ) . set ( jsNumber ( node -> codeOrigin . inlineCallFrame -> arguments . size ( ) - 1 ) ) ; else forNode ( node ) . set ( SpecInt32 ) ; node -> setCanExit ( ! isEmptySpeculation ( m_variables . operand ( m_graph . argumentsRegisterFor ( node -> codeOrigin ) ) . m_type ) ) ; break ; case GetMyArguments@@ LengthSafe : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgument@@ ByVal : node -> setCanExit ( true ) ; forNode ( node ) . makeTop ( ) ; break ; case GetMyArgument@@ ByVal@@ Safe : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case NewFunction : { AbstractValue & value = forNode ( node ) ; value = forNode ( node -> child1 ( ) ) ; if ( ! ( value . m_type & SpecEmpty ) ) { m_foundConstants = true ; break ; } value . set ( ( value . m_type & ~ SpecEmpty ) | SpecFunction ) ; break ; } case NewFunction@@ Expression : case NewFunction@@ NoCheck : forNode ( node ) . set ( m_codeBlock -> globalObjectFor ( node -> codeOrigin ) -> functionStructure ( ) ) ; break ; case GetCallee : forNode ( node ) . set ( SpecFunction ) ; break ; case SetCallee : case SetMy@@ Scope : break ; case GetScope : case GetMy@@ Scope : case SkipTop@@ Scope : forNode ( node ) . set ( SpecCellOther ) ; break ; case SkipScope : { JSValue child = forNode ( node -> child1 ( ) ) . value ( ) ; if ( child && trySetConstant ( node , JSValue ( jsCast < JSScope * > ( child . asCell ( ) ) -> next ( ) ) ) ) { m_foundConstants = true ; break ; } forNode ( node ) . set ( SpecCellOther ) ; break ; } case GetScop@@ eRegister@@ s : forNode ( node ) . clear ( ) ; break ; case GetScopedVar : forNode ( node ) . makeTop ( ) ; break ; case PutScopedVar : clobberCapturedVars ( node -> codeOrigin ) ; break ; case GetById : case GetById@@ Flush : node -> setCanExit ( true ) ; if ( ! node -> prediction ( ) ) { m_isValid = false ; break ; } if ( isCellSpeculation ( node -> child1 ( ) -> prediction ( ) ) ) { if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { GetByIdStatus status = GetByIdStatus :: computeFor ( m_graph . m_vm , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) ) ; if ( status . isSimple ( ) ) { ASSERT ( status . structureSet ( ) . size ( ) == 1 ) ; ASSERT ( status . chain ( ) . isEmpty ( ) ) ; if ( status . specificValue ( ) ) forNode ( node ) . set ( status . specificValue ( ) ) ; else forNode ( node ) . makeTop ( ) ; forNode ( node -> child1 ( ) ) . filter ( status . structureSet ( ) ) ; m_foundConstants = true ; break ; } } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GetArray@@ Length : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecInt32 ) ; break ; case CheckExecut@@ able : { node -> setCanExit ( true ) ; break ; } case CheckStructure : case Forward@@ CheckStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( ! ( value . m_type & ~ SpecCell ) ) ; StructureSet & set = node -> structureSet ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; if ( ! value . m_currentKnownStructure . isSubsetOf ( set ) ) node -> setCanExit ( true ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case StructureTransitionWatchpoint : case Forward@@ StructureTransitionWatchpoint : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; ASSERT ( value . m_futurePossibleStructure . isSubsetOf ( StructureSet ( node -> structure ( ) ) ) ) ; value . filter ( node -> structure ( ) ) ; m_haveStructures = true ; node -> setCanExit ( true ) ; break ; } case PutStructure : case Phantom@@ PutStructure : if ( ! forNode ( node -> child1 ( ) ) . m_currentKnownStructure . isClear ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( node -> structure@@ TransitionData ( ) . newStructure ) ; m_haveStructures = true ; } break ; case GetBut@@ terfly : case Allocate@@ PropertyStorage : case Reallocate@@ PropertyStorage : forNode ( node ) . clear ( ) ; break ; case CheckArray : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } node -> setCanExit ( true ) ; switch ( node -> arrayMode ( ) . type ( ) ) { case Array :: String : forNode ( node -> child1 ( ) ) . filter ( SpecString ) ; break ; case Array :: Int32 : case Array :: Double : case Array :: Contiguous : case Array :: ArrayStorage : case Array :: SlowPutArrayStorage : break ; case Array :: Arguments : forNode ( node -> child1 ( ) ) . filter ( SpecArguments ) ; break ; case Array :: Int8Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt8Array ) ; break ; case Array :: Int16Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt16Array ) ; break ; case Array :: Int32Array : forNode ( node -> child1 ( ) ) . filter ( SpecInt32Array ) ; break ; case Array :: Uint8Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint@@ 8Array ) ; break ; case Array :: Uint8ClampedArray : forNode ( node -> child1 ( ) ) . filter ( SpecUint@@ 8ClampedArray ) ; break ; case Array :: Uint16Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint16Array ) ; break ; case Array :: Uint32Array : forNode ( node -> child1 ( ) ) . filter ( SpecUint@@ 32Array ) ; break ; case Array :: Float32Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat32Array ) ; break ; case Array :: Float64Array : forNode ( node -> child1 ( ) ) . filter ( SpecFloat64Array ) ; break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case Arrayify : { if ( node -> arrayMode ( ) . alreadyChecked ( m_graph , node , forNode ( node -> child1 ( ) ) ) ) { m_foundConstants = true ; break ; } ASSERT ( node -> arrayMode ( ) . conversion ( ) == Array :: Convert || node -> arrayMode ( ) . conversion ( ) == Array :: Rage@@ Convert ) ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . filterArrayModes ( node -> arrayMode ( ) . arrayModesThatPassFiltering ( ) ) ; m_haveStructures = true ; break ; } case ArrayifyToStructure : { AbstractValue & value = forNode ( node -> child1 ( ) ) ; StructureSet set = node -> structure ( ) ; if ( value . m_futurePossibleStructure . isSubsetOf ( set ) || value . m_currentKnownStructure . isSubsetOf ( set ) ) m_foundConstants = true ; node -> setCanExit ( true ) ; clobberStructures ( indexInBlock ) ; value . filter ( set ) ; m_haveStructures = true ; break ; } case GetIndexed@@ PropertyStorage : { forNode ( node ) . clear ( ) ; break ; } case GetByOffset : { forNode ( node ) . makeTop ( ) ; break ; } case PutByOffset : { break ; } case CheckFunction : { JSValue value = forNode ( node -> child1 ( ) ) . value ( ) ; if ( value == node -> function ( ) ) { m_foundConstants = true ; ASSERT ( value ) ; break ; } node -> setCanExit ( true ) ; forNode ( node -> child1 ( ) ) . filterByValue ( node -> function ( ) ) ; break ; } case PutById : case PutByIdDirect : node -> setCanExit ( true ) ; if ( Structure * structure = forNode ( node -> child1 ( ) ) . bestProvenStructure ( ) ) { PutByIdStatus status = PutByIdStatus :: computeFor ( m_graph . m_vm , m_graph . globalObjectFor ( node -> codeOrigin ) , structure , m_graph . m_codeBlock -> identifier ( node -> identifierNumber ( ) ) , node -> op ( ) == PutByIdDirect ) ; if ( status . isSimple@@ Replace ( ) ) { forNode ( node -> child1 ( ) ) . filter ( structure ) ; m_foundConstants = true ; break ; } if ( status . isSimple@@ Transition ( ) ) { clobberStructures ( indexInBlock ) ; forNode ( node -> child1 ( ) ) . set ( status . newStructure ( ) ) ; m_haveStructures = true ; m_foundConstants = true ; break ; } } clobberWorld ( node -> codeOrigin , indexInBlock ) ; break ; case GetGlobal@@ Var : forNode ( node ) . makeTop ( ) ; break ; case GlobalVar@@ Watchpoint : node -> setCanExit ( true ) ; break ; case PutGlobalVar : case PutGlobalVar@@ Check : break ; case CheckHasInstance : node -> setCanExit ( true ) ; break ; case InstanceOf : node -> setCanExit ( true ) ; forNode ( node ) . set ( SpecBoolean ) ; break ; case Phi : case Flush : case PhantomLocal : case Brea@@ kpoint : break ; case Call : case Construct : case Resolve : case Resolve@@ Base : case Resolve@@ BaseStrict@@ Put : case Resolve@@ Global : node -> setCanExit ( true ) ; clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case GarbageValue : clobberWorld ( node -> codeOrigin , indexInBlock ) ; forNode ( node ) . makeTop ( ) ; break ; case Force@@ OSR@@ Exit : node -> setCanExit ( true ) ; m_isValid = false ; break ; case CheckWatch@@ dog@@ Timer : node -> setCanExit ( true ) ; break ; case Phanto@@ m : case Inline@@ Start : case Nop : case CountExecution : break ; case LastNodeType : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } return m_isValid ; } bool AbstractState :: executeEffects ( unsigned indexInBlock ) { return executeEffects ( indexInBlock , m_block -> at ( indexInBlock ) ) ; } bool AbstractState :: execute ( unsigned indexInBlock ) { Node * node = m_block -> at ( indexInBlock ) ; if ( ! startExecuting ( node ) ) return true ; executeEdges ( node ) ; return executeEffects ( indexInBlock , node ) ; } inline void AbstractState :: clobberWorld ( const CodeOrigin & codeOrigin , unsigned indexInBlock ) { clobberCapturedVars ( codeOrigin ) ; clobberStructures ( indexInBlock ) ; } inline void AbstractState :: clobberCapturedVars ( const CodeOrigin & codeOrigin ) { if ( codeOrigin . inlineCallFrame ) { const BitVector & capturedVars = codeOrigin . inlineCallFrame -> capturedVars ; for ( size_t i = capturedVars . size ( ) ; i -- ; ) { if ( ! capturedVars . quick@@ Get ( i ) ) continue ; m_variables . local ( i ) . makeTop ( ) ; } } else { for ( size_t i = m_codeBlock -> m_num@@ Vars ; i -- ; ) { if ( m_codeBlock -> isCaptured ( i ) ) m_variables . local ( i ) . makeTop ( ) ; } } for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) { if ( m_codeBlock -> isCaptured ( argument@@ ToOperand ( i ) ) ) m_variables . argument ( i ) . makeTop ( ) ; } } inline void AbstractState :: clobberStructures ( unsigned indexInBlock ) { if ( ! m_haveStructures ) return ; for ( size_t i = indexInBlock + 1 ; i -- ; ) forNode ( m_block -> at ( i ) ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfArguments ( ) ; i -- ; ) m_variables . argument ( i ) . clobberStructures ( ) ; for ( size_t i = m_variables . numberOfLocals ( ) ; i -- ; ) m_variables . local ( i ) . clobberStructures ( ) ; m_haveStructures = false ; m_didClobber = true ; } inline bool AbstractState :: mergeStateAtTail ( AbstractValue & destination , AbstractValue & inVariable , Node * node ) { if ( ! node ) return false ; AbstractValue source ; if ( node -> variableAccessData ( ) -> isCaptured ( ) ) { source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ last ▁ access ▁ due ▁ to ▁ captured ▁ variable . \n " ) ; # endif } else { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ It ' s ▁ live , ▁ node ▁ @ % u . \n " , node -> index ( ) ) ; # endif switch ( node -> op ( ) ) { case Phi : case SetArgument : case PhantomLocal : case Flush : source = inVariable ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Transfering ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " ▁ from ▁ head ▁ to ▁ tail . \n " ) ; # endif break ; case GetLocal : source = forNode ( node ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Refin@@ ing ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; case SetLocal : if ( node -> variableAccessData ( ) -> shouldUse@@ DoubleFormat ( ) ) { source . set ( SpecDouble ) ; } else source = forNode ( node -> child1 ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Setting ▁ to ▁ " ) ; source . dump ( WTF :: dataFile ( ) ) ; dataLogF ( " \n " ) ; # endif break ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; break ; } } if ( destination == source ) { # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Not ▁ changed ! \n " ) ; # endif return false ; } destination = source ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Changed ! \n " ) ; # endif return true ; } inline bool AbstractState :: merge ( BasicBlock * from , BasicBlock * to ) { ASSERT ( from -> variablesAtTail . numberOfArguments ( ) == to -> variablesAtHead . numberOfArguments ( ) ) ; ASSERT ( from -> variablesAtTail . numberOfLocals ( ) == to -> variablesAtHead . numberOfLocals ( ) ) ; bool changed = false ; for ( size_t argument = 0 ; argument < from -> variablesAtTail . numberOfArguments ( ) ; ++ argument ) { AbstractValue & destination = to -> valuesAtHead . argument ( argument ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . argument ( argument ) , to -> variablesAtHead . argument ( argument ) , from -> variablesAtTail . argument ( argument ) ) ; } for ( size_t local = 0 ; local < from -> variablesAtTail . numberOfLocals ( ) ; ++ local ) { AbstractValue & destination = to -> valuesAtHead . local ( local ) ; changed |= mergeVariableBetweenBlocks ( destination , from -> valuesAtTail . local ( local ) , to -> variablesAtHead . local ( local ) , from -> variablesAtTail . local ( local ) ) ; } if ( ! to -> cfaHasVisited ) changed = true ; to -> cfaShouldRevisit |= changed ; return changed ; } inline bool AbstractState :: mergeToSuccessors ( Graph & graph , BasicBlock * basicBlock ) { Node * terminal = basicBlock -> last ( ) ; ASSERT ( terminal -> isTermin@@ al ( ) ) ; switch ( terminal -> op ( ) ) { case Jump : { ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif return merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; } case Branch : { ASSERT ( basicBlock -> cfaBranchDirection != InvalidBranchDirection ) ; bool changed = false ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> takenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeFalse ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> takenBlockIndex ( ) ] . get ( ) ) ; # if DFG_ENABLE ( DEBUG_PROPAGATION_VERBOSE ) dataLogF ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Merging ▁ to ▁ block ▁ # % u . \n " , terminal -> notTakenBlockIndex ( ) ) ; # endif if ( basicBlock -> cfaBranchDirection != TakeTrue ) changed |= merge ( basicBlock , graph . m_blocks [ terminal -> notTakenBlockIndex ( ) ] . get ( ) ) ; return changed ; } case Return : case Throw : case ThrowReferenceError : ASSERT ( basicBlock -> cfaBranchDirection == InvalidBranchDirection ) ; return false ; default : RELEASE_ASSERT_NOT_REACHED ( ) ; return false ; } } inline bool AbstractState :: mergeVariableBetweenBlocks ( AbstractValue & destination , AbstractValue & source , Node * destinationNode , Node * sourceNode ) { if ( ! destinationNode ) return false ; ASSERT_UNUSED ( sourceNode , sourceNode ) ; return destination . merge ( source ) ; } void AbstractState :: dump ( Print@@ Stream & out ) { bool first = true ; for ( size_t i = 0 ; i < m_block -> size ( ) ; ++ i ) { Node * node = m_block -> at ( i ) ; AbstractValue & value = forNode ( node ) ; if ( value . isClear ( ) ) continue ; if ( first ) first = false ; else out . printf ( " ▁ " ) ; out . printf ( " @ % lu : " , static_cast < unsigned long > ( node -> index ( ) ) ) ; value . dump ( out ) ; } } } } # endif </DOCUMENT>
<DOCUMENT_ID="Steven@@ Black@@ /phantomjs/tree/master/src/qt/qtwebkit/Source/WebCore/platform/@@ audio/@@ AudioFIFO.cpp"> # include " config . h " # if ENABLE ( WEB@@ _AUDI@@ O ) # include " AudioFIFO . h " namespace WebCore { AudioFIFO :: AudioFIFO ( unsigned numberOfChannels , size_t fifoLength ) : m_fifoAudioBus ( AudioBus :: create ( numberOfChannels , fifoLength ) ) , m_fifoLength ( fifoLength ) , m_framesInFifo ( 0 ) , m_readIndex ( 0 ) , m_writeIndex ( 0 ) { } void AudioFIFO :: consume ( AudioBus * destination , size_t framesToConsume ) { bool isGood = destination && ( framesToConsume <= m_fifoLength ) && ( framesToConsume <= m_framesInFifo ) && ( destination -> length ( ) >= framesToConsume ) ; ASSERT ( isGood ) ; if ( ! isGood ) return ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_readIndex , framesToConsume , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destinationData = destination -> channel ( channelIndex ) -> mutableData ( ) ; const float * sourceData = m_fifoAudioBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_readIndex < m_fifoLength ) && ( m_readIndex + part1Length ) <= m_fifoLength && ( part1Length <= destination -> length ( ) ) && ( part1Length + part2Length ) <= destination -> length ( ) ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destinationData , sourceData + m_readIndex , part1Length * sizeof ( * sourceData ) ) ; if ( part2Length ) memcpy ( destinationData + part1Length , sourceData , part2Length * sizeof ( * sourceData ) ) ; } m_readIndex = updateIndex ( m_readIndex , framesToConsume ) ; ASSERT ( m_framesInFifo >= framesToConsume ) ; m_framesInFifo -= framesToConsume ; } void AudioFIFO :: push ( const AudioBus * sourceBus ) { bool isGood = sourceBus && ( m_framesInFifo + sourceBus -> length ( ) <= m_fifoLength ) ; if ( ! isGood ) return ; size_t sourceLength = sourceBus -> length ( ) ; size_t part1Length ; size_t part2Length ; findWrapLengths ( m_writeIndex , sourceLength , part1Length , part2Length ) ; size_t numberOfChannels = m_fifoAudioBus -> numberOfChannels ( ) ; for ( size_t channelIndex = 0 ; channelIndex < numberOfChannels ; ++ channelIndex ) { float * destination = m_fifoAudioBus -> channel ( channelIndex ) -> mutableData ( ) ; const float * source = sourceBus -> channel ( channelIndex ) -> data ( ) ; bool isCopyGood = ( ( m_writeIndex < m_fifoLength ) && ( m_writeIndex + part1Length ) <= m_fifoLength && part2Length < m_fifoLength && part1Length + part2Length <= sourceLength ) ; ASSERT ( isCopyGood ) ; if ( ! isCopyGood ) return ; memcpy ( destination + m_writeIndex , source , part1Length * sizeof ( * destination ) ) ; if ( part2Length ) memcpy ( destination , source + part1Length , part2Length * sizeof ( * destination ) ) ; } m_framesInFifo += sourceLength ; ASSERT ( m_framesInFifo <= m_fifoLength ) ; m_writeIndex = updateIndex ( m_writeIndex , sourceLength ) ; } void AudioFIFO :: findWrapLengths ( size_t index , size_t size , size_t & part1Length , size_t & part2Length ) { ASSERT_WITH_SEC@@ URITY_@@ IMPLICATION ( index < m_fifoLength && size <= m_fifoLength ) ; if ( index < m_fifoLength && size <= m_fifoLength ) { if ( index + size > m_fifoLength ) { part1Length = m_fifoLength - index ; part2Length = size - part1Length ; } else { part1Length = size ; part2Length = 0 ; } } else { part1Length = 0 ; part2Length = 0 ; } } } # endif </DOCUMENT>
<DOCUMENT_ID="thi@@ phari@@ el/@@ navitia@@ /tree/master/source/@@ kra@@ ken/tests/@@ data_manager_@@ test.cpp"> # define BOOST_TEST_@@ DYN_LINK # define BOOST_TEST_@@ MODULE data_manager_@@ test # include < boost / test / unit_test . hpp > # include < boost / optional . hpp > # include " kra@@ ken / data _ manager . h " # include < atomic > class Data { public : bool load ( const std :: string & , const boost :: optional < std :: string > & , const std :: vector < std :: string > & ) { return load_status ; } mut@@ able std :: atomic < bool > is_connected_to_rabbitmq ; static bool load_status ; static bool destructor_called ; size_t data_identifier ; Data ( size_t data_identifier = 0 ) : data_identifier ( data_identifier ) { is_connected_to_rabbitmq = false ; } ~ Data ( ) { Data :: destructor_called = true ; } } ; bool Data :: load_status = true ; bool Data :: destructor_called = false ; struct fixture { fixture ( ) { Data :: load_status = true ; Data :: destructor_called = false ; } } ; BOOST_FIXTURE_@@ TEST_SUITE ( s , fixture ) BOOST_AUTO_TEST_CASE ( get_data ) { DataManager < Data > data_manager ; auto data = data_manager . get_data ( ) ; BOOST_REQUIR@@ E ( data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_success ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; } BOOST_AUTO_TEST_CASE ( load_fail ) { DataManager < Data > data_manager ; auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; Data :: load_status = false ; BOOST_CHECK ( ! data_manager . load ( " " ) ) ; Data :: load_status = true ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , second_data ) ; } BOOST_AUTO_TEST_CASE ( destructor_called ) { DataManager < Data > data_manager ; { auto first_data = data_manager . get_data ( ) ; BOOST_CHECK_EQUAL ( first_data , data_manager . get_data ( ) ) ; BOOST_CHECK ( data_manager . load ( " " ) ) ; auto second_data = data_manager . get_data ( ) ; BOOST_CHECK_NE ( first_data , second_data ) ; BOOST_CHECK_EQUAL ( Data :: destructor_called , false ) ; first_data = boost :: shared_ptr < Data > ( ) ; } BOOST_CHECK_EQUAL ( Data :: destructor_called , true ) ; BOOST_CHECK ( data_manager . get_data ( ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
