<DOCUMENT_ID="@@ LEE@@ lu@@ om@@ an/@@ Ma@@ ze@@ S@@ cr@@ n@@ Save@@ /tree/master/@@ Ma@@ ze@@ S@@ cr@@ n@@ Save@@ /@@ Ma@@ ze@@ .cpp"> # include " Ma@@ z@@ e . h " # include < set > # include < vector > # include < algorithm > using namespace std ; C@@ Ma@@ z@@ e :: C@@ Ma@@ z@@ e ( int n@@ Width , int nHeight , int n@@ Cell@@ Width , int n@@ Cell@@ Height , bool b@@ Copy@@ Scre@@ en ) { m_@@ n@@ Counter = 0 ; m_@@ n@@ Width = n@@ Width ; m_@@ nHeight = nHeight ; m_@@ n@@ Cell@@ Width = n@@ Cell@@ Width ; m_@@ n@@ Cell@@ Height = n@@ Cell@@ Height ; m_@@ n@@ Cols = m_@@ n@@ Width / m_@@ n@@ Cell@@ Width - 1 ; m_@@ n@@ Rows = m_@@ nHeight / m_@@ n@@ Cell@@ Height - 1 ; m_@@ n@@ Offset@@ X = ( m_@@ n@@ Width - m_@@ n@@ Cols * m_@@ n@@ Cell@@ Width ) / 2 ; m_@@ n@@ Offset@@ Y = ( m_@@ nHeight - m_@@ n@@ Rows * m_@@ n@@ Cell@@ Height ) / 2 ; m_b@@ Re@@ Draw@@ Before@@ Generate = FALSE ; m_b@@ Al@@ low@@ Non@@ Solution = FALSE ; m_b@@ Fla@@ sh@@ Path = TRUE ; H@@ DC h@@ Screen@@ D@@ c = Get@@ DC ( NULL ) ; m_h@@ Wor@@ k@@ D@@ c = Create@@ Compatible@@ DC ( NULL ) ; m_h@@ Wor@@ k@@ B@@ mp = Create@@ Compatible@@ Bitmap ( h@@ Screen@@ D@@ c , m_@@ n@@ Width , m_@@ nHeight ) ; m_h@@ Old@@ B@@ mp = Select@@ Object ( m_h@@ Wor@@ k@@ D@@ c , ( H@@ G@@ DI@@ OBJ ) m_h@@ Wor@@ k@@ B@@ mp ) ; m_h@@ Old@@ Pen = Select@@ Object ( m_h@@ Wor@@ k@@ D@@ c , m_ma@@ ze@@ Color . Get@@ Pen ( c@@ l@@ W@@ all ) ) ; if ( b@@ Copy@@ Scre@@ en ) { Bit@@ B@@ lt ( m_h@@ Wor@@ k@@ D@@ c , 0 , 0 , m_@@ n@@ Width , m_@@ nHeight , h@@ Screen@@ D@@ c , 0 , 0 , S@@ RC@@ COP@@ Y ) ; } Release@@ DC ( NULL , h@@ Screen@@ D@@ c ) ; RECT rect = { 0 , 0 , m_@@ n@@ Width , m_@@ nHeight } ; Fill@@ Rect ( m_h@@ Wor@@ k@@ D@@ c , & rect , m_ma@@ ze@@ Color . Get@@ Brush ( c@@ l@@ Back@@ Gro@@ und ) ) ; if ( m_@@ n@@ Cols > 0 && m_@@ n@@ Rows > 0 ) { m_@@ cells = new C@@ Ma@@ ze@@ Cell [ m_@@ n@@ Cols * m_@@ n@@ Rows ] ; Initialize@@ Cell@@ s ( ) ; Reset@@ And@@ Re@@ Draw@@ All@@ Cell@@ s ( ) ; m_@@ state = MS_@@ INITIALIZ@@ ED ; } else { m_@@ state = MS_@@ ERROR ; m_@@ cells = NULL ; } } C@@ Ma@@ z@@ e :: ~ C@@ Ma@@ z@@ e ( void ) { Select@@ Object ( m_h@@ Wor@@ k@@ D@@ c , m_h@@ Old@@ Pen ) ; Select@@ Object ( m_h@@ Wor@@ k@@ D@@ c , m_h@@ Old@@ B@@ mp ) ; Delete@@ DC ( m_h@@ Wor@@ k@@ D@@ c ) ; Delete@@ Object ( m_h@@ Wor@@ k@@ B@@ mp ) ; if ( m_@@ cells != NULL ) { delete [ ] m_@@ cells ; } } C@@ Ma@@ ze@@ Cell * C@@ Ma@@ z@@ e :: Get@@ Cell ( int i , int j ) { if ( i < 0 || j < 0 || i >= m_@@ n@@ Cols || j >= m_@@ n@@ Rows ) { return NULL ; } return & m_@@ cells [ j * m_@@ n@@ Cols + i ] ; } void C@@ Ma@@ z@@ e :: Initialize@@ Cell@@ s ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Set@@ Parent ( this , i , j ) ; } } } void C@@ Ma@@ z@@ e :: Re@@ Draw@@ Si@@ des ( ) { int n@@ P@@ ic@@ Width = m_@@ n@@ Cols * m_@@ n@@ Cell@@ Width ; int n@@ P@@ ic@@ Height = m_@@ n@@ Rows * m_@@ n@@ Cell@@ Height ; Move@@ To@@ Ex ( m_h@@ Wor@@ k@@ D@@ c , m_@@ n@@ Offset@@ X , m_@@ n@@ Offset@@ Y , NULL ) ; LineTo ( m_h@@ Wor@@ k@@ D@@ c , m_@@ n@@ Offset@@ X + n@@ P@@ ic@@ Width , m_@@ n@@ Offset@@ Y ) ; LineTo ( m_h@@ Wor@@ k@@ D@@ c , m_@@ n@@ Offset@@ X + n@@ P@@ ic@@ Width , m_@@ n@@ Offset@@ Y + n@@ P@@ ic@@ Height ) ; LineTo ( m_h@@ Wor@@ k@@ D@@ c , m_@@ n@@ Offset@@ X , m_@@ n@@ Offset@@ Y + n@@ P@@ ic@@ Height ) ; LineTo ( m_h@@ Wor@@ k@@ D@@ c , m_@@ n@@ Offset@@ X , m_@@ n@@ Offset@@ Y ) ; } void C@@ Ma@@ z@@ e :: Reset@@ All@@ Cell@@ s ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Reset ( ) ; } } } void C@@ Ma@@ z@@ e :: Reset@@ And@@ Re@@ Draw@@ All@@ Cell@@ s ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Reset ( ) ; p@@ Cell -> Re@@ Draw ( ) ; } } Re@@ Draw@@ Si@@ des ( ) ; } void C@@ Ma@@ z@@ e :: Re@@ Draw@@ All@@ Cell@@ s ( ) { for ( int i = 0 ; i < m_@@ n@@ Cols ; ++ i ) { for ( int j = 0 ; j < m_@@ n@@ Rows ; ++ j ) { C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( i , j ) ; p@@ Cell -> Re@@ Draw ( ) ; } } Re@@ Draw@@ Si@@ des ( ) ; } void C@@ Ma@@ z@@ e :: Next ( BOOL b@@ Delay ) { DWORD dw@@ De@@ lay@@ Value = 0 ; switch ( m_@@ state ) { case MS_@@ INITIALIZ@@ ED : m_@@ cell@@ Gener@@ ating = Get@@ Random@@ Cell ( ) ; m_@@ cell@@ Stack . Init ( ) ; m_@@ cell@@ Stack . Push ( m_@@ cell@@ Gener@@ ating ) ; m_@@ cell@@ Gener@@ ating -> m_b@@ Gener@@ ated = true ; Change@@ State ( MS_@@ GENER@@ AT@@ ING ) ; break ; case MS_@@ GENER@@ AT@@ ING : if ( m_@@ cell@@ Stack . IsEmpty ( ) ) { Change@@ State ( MS_@@ GENER@@ ATED ) ; } else { bool b@@ Get@@ New@@ Cell = false ; C@@ Ma@@ ze@@ Cell * p@@ Top@@ Cell = m_@@ cell@@ Stack . Top ( ) ; p@@ Top@@ Cell -> Re@@ Draw ( ) ; p@@ Top@@ Cell -> Go@@ Generate ( & b@@ Get@@ New@@ Cell ) ; if ( b@@ Get@@ New@@ Cell ) { } } break ; case MS_@@ GENER@@ ATED : if ( m_b@@ Al@@ low@@ Non@@ Solution && m_@@ n@@ Rows * m_@@ n@@ Cols >= 10 && m_@@ n@@ Cols > 1 && m_@@ n@@ Rows > 1 ) { int n@@ Right@@ Wall@@ sCount = ( m_@@ n@@ Cols - 1 ) * m_@@ n@@ Rows ; int n@@ Botto@@ m@@ Wall@@ sCount = ( m_@@ n@@ Rows - 1 ) * m_@@ n@@ Cols ; int n@@ Wall@@ sCount = n@@ Right@@ Wall@@ sCount + n@@ Botto@@ m@@ Wall@@ sCount ; int n@@ Changed@@ Wall@@ sCount = n@@ Wall@@ sCount * 2 / 100 ; set < int > set@@ Changed@@ Wall@@ s ; vector < int > vector@@ Changed@@ Wall@@ s ; if ( n@@ Changed@@ Wall@@ sCount > 100 ) { n@@ Changed@@ Wall@@ sCount = 100 ; } while ( ( int ) set@@ Changed@@ Wall@@ s . size ( ) < n@@ Changed@@ Wall@@ sCount ) { set@@ Changed@@ Wall@@ s . insert ( Big@@ R@@ and ( ) % n@@ Wall@@ sCount ) ; } vector@@ Changed@@ Wall@@ s . assign ( set@@ Changed@@ Wall@@ s . begin ( ) , set@@ Changed@@ Wall@@ s . end ( ) ) ; random_@@ shuffle ( vector@@ Changed@@ Wall@@ s . begin ( ) , vector@@ Changed@@ Wall@@ s . end ( ) ) ; for ( int i = 0 ; i < n@@ Changed@@ Wall@@ sCount ; ++ i ) { int n@@ Offset = vector@@ Changed@@ Wall@@ s . at ( i ) ; if ( n@@ Offset < n@@ Right@@ Wall@@ sCount ) { int n@@ Row = n@@ Offset / ( m_@@ n@@ Cols - 1 ) ; int n@@ Col = n@@ Offset % ( m_@@ n@@ Cols - 1 ) ; C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( n@@ Col , n@@ Row ) ; p@@ Cell -> Set@@ W@@ all ( DI@@ R_@@ RIGHT , ! p@@ Cell -> Get@@ W@@ all ( DI@@ R_@@ RIGHT ) ) ; } else { n@@ Offset -= n@@ Right@@ Wall@@ sCount ; int n@@ Row = n@@ Offset / m_@@ n@@ Cols ; int n@@ Col = n@@ Offset % m_@@ n@@ Cols ; C@@ Ma@@ ze@@ Cell * p@@ Cell = Get@@ Cell ( n@@ Col , n@@ Row ) ; p@@ Cell -> Set@@ W@@ all ( DI@@ R_@@ BOTTOM , ! p@@ Cell -> Get@@ W@@ all ( DI@@ R_@@ BOTTOM ) ) ; } } } Re@@ Draw@@ All@@ Cell@@ s ( ) ; Change@@ State ( MS@@ _SE@@ TT@@ ING ) ; break ; case MS@@ _SE@@ TT@@ ING : if ( true ) { int n@@ Counter = GetCounter ( ) ; if ( n@@ Counter == 0 ) { if ( rand ( ) % 5 == 0 ) { int b@@ x [ ] = { 0 , 0 , 1 , 1 } ; int by [ ] = { 0 , 1 , 0 , 1 } ; int ex [ ] = { 1 , 1 , 0 , 0 } ; int e@@ y [ ] = { 1 , 0 , 1 , 0 } ; int offset = rand ( ) % 4 ; m_@@ cell@@ Begin = Get@@ Cell ( ( Get@@ Cols ( ) - 1 ) * b@@ x [ offset ] , ( Get@@ Rows ( ) - 1 ) * by [ offset ] ) ; m_@@ cell@@ End = Get@@ Cell ( ( Get@@ Cols ( ) - 1 ) * ex [ offset ] , ( Get@@ Rows ( ) - 1 ) * e@@ y [ offset ] ) ; } else { m_@@ cell@@ Begin = Get@@ Random@@ Cell ( ) ; do { m_@@ cell@@ End = Get@@ Random@@ Cell ( ) ; } while ( m_@@ cell@@ End == m_@@ cell@@ Begin ) ; } m_@@ cell@@ Begin -> m_b@@ Is@@ Begin = true ; m_@@ cell@@ End -> m_b@@ Is@@ End = true ; } else if ( n@@ Counter < 19 ) { m_@@ cell@@ Begin -> m_b@@ Is@@ Begin = ! m_@@ cell@@ Begin -> m_b@@ Is@@ Begin ; m_@@ cell@@ Begin -> Re@@ Draw ( ) ; dw@@ De@@ lay@@ Value = 55 ; } else if ( n@@ Counter < 37 ) { m_@@ cell@@ End -> m_b@@ Is@@ End = ! m_@@ cell@@ End -> m_b@@ Is@@ End ; m_@@ cell@@ End -> Re@@ Draw ( ) ; dw@@ De@@ lay@@ Value = 55 ; } else { Change@@ State ( MS@@ _SET ) ; } } break ; case MS@@ _SET : m_@@ cell@@ Stack . Init ( ) ; m_@@ cell@@ Stack . Push ( m_@@ cell@@ Begin ) ; m_@@ cell@@ Begin -> m_b@@ Visited = true ; Change@@ State ( MS_@@ RES@@ O@@ LV@@ ING ) ; break ; case MS_@@ RES@@ O@@ LV@@ ING : if ( m_@@ cell@@ Stack . IsEmpty ( ) ) { Change@@ State ( MS_@@ RES@@ O@@ LV@@ E@@ FAILED ) ; } else { bool b@@ Get@@ New@@ Cell = false ; C@@ Ma@@ ze@@ Cell * p@@ Top@@ Cell = m_@@ cell@@ Stack . Top ( ) ; p@@ Top@@ Cell -> Re@@ Draw ( ) ; if ( p@@ Top@@ Cell == m_@@ cell@@ End ) { Change@@ State ( MS_@@ RES@@ O@@ LV@@ ED ) ; break ; } p@@ Top@@ Cell -> Go@@ Resolve ( & b@@ Get@@ New@@ Cell ) ; if ( b@@ Get@@ New@@ Cell ) { } } dw@@ De@@ lay@@ Value = 10 ; break ; case MS_@@ RES@@ O@@ LV@@ ED : { int n@@ Counter = GetCounter ( ) ; if ( n@@ Counter > 5 ) { if ( m_b@@ Re@@ Draw@@ Before@@ Generate ) { Reset@@ And@@ Re@@ Draw@@ All@@ Cell@@ s ( ) ; } else { Reset@@ All@@ Cell@@ s ( ) ; } Change@@ State ( MS_@@ INITIALIZ@@ ED ) ; } else { if ( m_b@@ Fla@@ sh@@ Path ) { COLOR@@ REF c@@ l = m_ma@@ ze@@ Color . GetColor ( c@@ l@@ Visited ) ; m_ma@@ ze@@ Color . Set@@ Color ( c@@ l@@ Visited , Get@@ Re@@ verse@@ Color ( c@@ l ) ) ; Re@@ Draw@@ All@@ Cell@@ s ( ) ; } dw@@ De@@ lay@@ Value = 500 ; } } break ; case MS_@@ RES@@ O@@ LV@@ E@@ FAILED : dw@@ De@@ lay@@ Value = 3000 ; if ( m_b@@ Re@@ Draw@@ Before@@ Generate ) { Reset@@ And@@ Re@@ Draw@@ All@@ Cell@@ s ( ) ; } else { Reset@@ All@@ Cell@@ s ( ) ; } Change@@ State ( MS_@@ INITIALIZ@@ ED ) ; case MS_@@ P@@ AU@@ SED : break ; case MS_@@ ERROR : break ; default : break ; } if ( b@@ Delay && dw@@ De@@ lay@@ Value > 0 ) { Sleep ( dw@@ De@@ lay@@ Value ) ; } } H@@ DC C@@ Ma@@ z@@ e :: Get@@ D@@ c ( ) const { return m_h@@ Wor@@ k@@ D@@ c ; } C@@ Ma@@ ze@@ Color & C@@ Ma@@ z@@ e :: Get@@ Color@@ Manager ( ) { return m_ma@@ ze@@ Color ; } Ma@@ ze@@ State C@@ Ma@@ z@@ e :: Get@@ State ( ) const { return m_@@ state ; } C@@ Ma@@ ze@@ Cell * C@@ Ma@@ z@@ e :: Get@@ Random@@ Cell ( ) { return Get@@ Cell ( rand ( ) % m_@@ n@@ Cols , rand ( ) % m_@@ n@@ Rows ) ; } void C@@ Ma@@ z@@ e :: Make@@ Random@@ Begin@@ And@@ End@@ Cell ( ) { m_@@ cell@@ Begin = Get@@ Random@@ Cell ( ) ; m_@@ cell@@ End = Get@@ Random@@ Cell ( ) ; while ( m_@@ cell@@ End == m_@@ cell@@ Begin ) { m_@@ cell@@ End = Get@@ Random@@ Cell ( ) ; } } int C@@ Ma@@ z@@ e :: GetWidth ( ) const { return m_@@ n@@ Width ; } int C@@ Ma@@ z@@ e :: GetHeight ( ) const { return m_@@ nHeight ; } int C@@ Ma@@ z@@ e :: Get@@ Cell@@ Width ( ) const { return m_@@ n@@ Cell@@ Width ; } int C@@ Ma@@ z@@ e :: Get@@ Cell@@ Height ( ) const { return m_@@ n@@ Cell@@ Height ; } int C@@ Ma@@ z@@ e :: Get@@ Rows ( ) const { return m_@@ n@@ Rows ; } int C@@ Ma@@ z@@ e :: Get@@ Cols ( ) const { return m_@@ n@@ Cols ; } int C@@ Ma@@ z@@ e :: Get@@ Offset@@ X ( ) const { return m_@@ n@@ Offset@@ X ; } int C@@ Ma@@ z@@ e :: Get@@ Offset@@ Y ( ) const { return m_@@ n@@ Offset@@ Y ; } C@@ Ma@@ ze@@ Cell@@ Stack & C@@ Ma@@ z@@ e :: Get@@ Cell@@ Stack ( ) { return m_@@ cell@@ Stack ; } void C@@ Ma@@ z@@ e :: Change@@ State ( Ma@@ ze@@ State state ) { if ( m_@@ state != state ) { m_@@ state = state ; m_@@ n@@ Counter = 0 ; } } int C@@ Ma@@ z@@ e :: GetCounter ( ) { return m_@@ n@@ Counter ++ ; } int C@@ Ma@@ z@@ e :: Big@@ R@@ and ( ) { return ( ( ( rand ( ) % 0x@@ 100 ) << 0 ) | ( ( rand ( ) % 0x@@ 100 ) << 8 ) | ( ( rand ( ) % 0x@@ 100 ) << 16 ) | ( ( rand ( ) % 0x@@ 100 ) << 24 ) ) & ( ( unsigned ) - 1 >> 1 ) ; } COLOR@@ REF C@@ Ma@@ z@@ e :: Get@@ Re@@ verse@@ Color ( COLOR@@ REF c@@ l ) { return RGB ( ~ Get@@ R@@ Value ( c@@ l ) , ~ Get@@ G@@ Value ( c@@ l ) , ~ Get@@ B@@ Value ( c@@ l ) ) ; } void C@@ Ma@@ z@@ e :: SetRe@@ Draw@@ Before@@ Generate ( BOOL b@@ Re@@ Draw@@ Before@@ Generate ) { m_b@@ Re@@ Draw@@ Before@@ Generate = b@@ Re@@ Draw@@ Before@@ Generate ; } void C@@ Ma@@ z@@ e :: Set@@ Al@@ low@@ Non@@ Solution ( BOOL b@@ Al@@ low@@ Non@@ Solution ) { m_b@@ Al@@ low@@ Non@@ Solution = b@@ Al@@ low@@ Non@@ Solution ; } void C@@ Ma@@ z@@ e :: SetF@@ lash@@ Path ( BOOL b@@ Fla@@ sh@@ Path ) { m_b@@ Fla@@ sh@@ Path = b@@ Fla@@ sh@@ Path ; } void C@@ Ma@@ z@@ e :: Update@@ Colors ( ) { Select@@ Object ( m_h@@ Wor@@ k@@ D@@ c , m_ma@@ ze@@ Color . Get@@ Pen ( c@@ l@@ W@@ all ) ) ; } void C@@ Ma@@ z@@ e :: Restart ( ) { if ( m_b@@ Re@@ Draw@@ Before@@ Generate ) { Reset@@ And@@ Re@@ Draw@@ All@@ Cell@@ s ( ) ; } else { Reset@@ All@@ Cell@@ s ( ) ; } Change@@ State ( MS_@@ INITIALIZ@@ ED ) ; } </DOCUMENT>
<DOCUMENT_ID="@@ r@@ ex@@ im@@ /@@ be@@ at@@ wave@@ /tree/master/@@ test/@@ core/@@ test@@ animat@@ ed@@ .cpp"> # define CAT@@ CH_@@ CONFIG_@@ MAIN # include < catch . hpp > # include < core / animat@@ ed . hpp > TEST_CASE ( " Animat@@ ing ▁ object ▁ with ▁ nullptr ▁ should ▁ not ▁ cr@@ as@@ h ▁ the ▁ app " , " [ animat@@ ed ] " ) { Animat@@ ed < int > x ( 10 ) ; x . anim@@ ate ( nullptr ) ; } </DOCUMENT>
<DOCUMENT_ID="@@ Gre@@ y@@ man@@ e/@@ Sk@@ y@@ Fire@@ EMU@@ /tree/master/dep/acelite/ace/@@ O@@ S_@@ NS_@@ err@@ no@@ .cpp"> # include " ace / OS _ NS _ errno . h " # if ! defined ( ACE_HAS_@@ IN@@ LIN@@ ED_@@ OS@@ CALL@@ S ) # include " ace / OS _ NS _ errno . in@@ l " # endif </DOCUMENT>
<DOCUMENT_ID="x@@ ho@@ ch@@ y/@@ ar@@ row@@ /tree/master/@@ r@@ ub@@ y/@@ red@@ -@@ ar@@ row@@ /@@ ext@@ /@@ ar@@ row@@ /@@ raw@@ -@@ re@@ cor@@ d@@ s.cpp"> # include " conver@@ ters . hpp " namespace re@@ d_@@ arrow { namespace { class Raw@@ Recor@@ ds@@ Builder : private Con@@ ver@@ ter , public arrow :: Array@@ Visitor { public : explicit Raw@@ Recor@@ ds@@ Builder ( VALUE re@@ cor@@ ds , int n_@@ colum@@ ns ) : Con@@ ver@@ ter ( ) , re@@ cor@@ ds@@ _ ( re@@ cor@@ ds ) , n_@@ colum@@ ns@@ _ ( n_@@ colum@@ ns ) { } void build ( const arrow :: Recor@@ d@@ B@@ atch & re@@ cor@@ d@@ _b@@ atch ) { rb :: prote@@ ct ( [ & ] { const auto n_@@ rows = re@@ cor@@ d@@ _b@@ atch . num_@@ rows ( ) ; for ( int64_t i = 0 ; i < n_@@ rows ; ++ i ) { auto record = rb@@ _@@ ar@@ y_@@ new@@ _c@@ ap@@ a ( n_@@ colum@@ ns@@ _ ) ; rb@@ _@@ ar@@ y_@@ push ( re@@ cor@@ ds@@ _ , record ) ; } row@@ _@@ offset@@ _ = 0 ; for ( int i = 0 ; i < n_@@ colum@@ ns@@ _ ; ++ i ) { const auto array = re@@ cor@@ d@@ _b@@ atch . column ( i ) . get ( ) ; colum@@ n@@ _in@@ d@@ ex@@ _ = i ; check_@@ status ( array -> Accept ( this ) , " [ record - bat@@ ch ] [ raw - re@@ cor@@ ds ] " ) ; } return Q@@ n@@ il ; } ) ; } void build ( const arrow :: Table & table ) { rb :: prote@@ ct ( [ & ] { const auto n_@@ rows = table . num_@@ rows ( ) ; for ( int64_t i = 0 ; i < n_@@ rows ; ++ i ) { auto record = rb@@ _@@ ar@@ y_@@ new@@ _c@@ ap@@ a ( n_@@ colum@@ ns@@ _ ) ; rb@@ _@@ ar@@ y_@@ push ( re@@ cor@@ ds@@ _ , record ) ; } for ( int i = 0 ; i < n_@@ colum@@ ns@@ _ ; ++ i ) { const auto & ch@@ unk@@ ed_@@ array = table . column ( i ) . get ( ) ; colum@@ n@@ _in@@ d@@ ex@@ _ = i ; row@@ _@@ offset@@ _ = 0 ; for ( const auto array : ch@@ unk@@ ed_@@ array -> ch@@ unk@@ s ( ) ) { check_@@ status ( array -> Accept ( this ) , " [ table ] [ raw - re@@ cor@@ ds ] " ) ; row@@ _@@ offset@@ _ += array -> length ( ) ; } } return Q@@ n@@ il ; } ) ; } # define VISI@@ T ( TYPE ) arrow :: Status Vis@@ it ( const arrow :: TYPE ## Array & array ) override { convert ( array ) ; return arrow :: Status :: OK ( ) ; } VISI@@ T ( Null ) VISI@@ T ( Boolean ) VISI@@ T ( Int8 ) VISI@@ T ( Int16 ) VISI@@ T ( Int32 ) VISI@@ T ( Int64 ) VISI@@ T ( UInt8 ) VISI@@ T ( UInt16 ) VISI@@ T ( UInt32 ) VISI@@ T ( U@@ Int64 ) VISI@@ T ( Float ) VISI@@ T ( Double ) VISI@@ T ( Bin@@ ary ) VISI@@ T ( String ) VISI@@ T ( Fix@@ ed@@ Size@@ Bin@@ ary ) VISI@@ T ( Date@@ 32 ) VISI@@ T ( Date@@ 64 ) VISI@@ T ( Time@@ 32 ) VISI@@ T ( Time@@ 64 ) VISI@@ T ( Timestamp ) VISI@@ T ( List ) VISI@@ T ( Struct ) VISI@@ T ( Un@@ ion ) VISI@@ T ( Dictionary ) VISI@@ T ( Dec@@ im@@ al@@ 128 ) # undef VISI@@ T private : template < typename Array@@ Type > void convert ( const Array@@ Type & array ) { const auto n = array . length ( ) ; if ( array . null_@@ count ( ) > 0 ) { for ( int64_t i = 0 , ii = row@@ _@@ offset@@ _ ; i < n ; ++ i , ++ ii ) { auto value = Q@@ n@@ il ; if ( ! array . IsNull ( i ) ) { value = conver@@ t_@@ value ( array , i ) ; } auto record = rb@@ _@@ ar@@ y_@@ entry ( re@@ cor@@ ds@@ _ , ii ) ; rb@@ _@@ ar@@ y_@@ store ( record , colum@@ n@@ _in@@ d@@ ex@@ _ , value ) ; } } else { for ( int64_t i = 0 , ii = row@@ _@@ offset@@ _ ; i < n ; ++ i , ++ ii ) { auto record = rb@@ _@@ ar@@ y_@@ entry ( re@@ cor@@ ds@@ _ , ii ) ; rb@@ _@@ ar@@ y_@@ store ( record , colum@@ n@@ _in@@ d@@ ex@@ _ , conver@@ t_@@ value ( array , i ) ) ; } } } VALUE re@@ cor@@ ds@@ _ ; int colum@@ n@@ _in@@ d@@ ex@@ _ ; int64_t row@@ _@@ offset@@ _ ; const int n_@@ colum@@ ns@@ _ ; } ; } VALUE re@@ cor@@ d@@ _b@@ atch@@ _@@ raw@@ _re@@ cor@@ ds ( VALUE rb@@ _re@@ cor@@ d@@ _b@@ atch ) { auto g@@ ar@@ row@@ _re@@ cor@@ d@@ _b@@ atch = G@@ ARRO@@ W_@@ REC@@ OR@@ D_@@ BAT@@ CH ( R@@ VAL@@ 2@@ G@@ OBJ ( rb@@ _re@@ cor@@ d@@ _b@@ atch ) ) ; auto re@@ cor@@ d@@ _b@@ atch = g@@ ar@@ row@@ _re@@ cor@@ d@@ _b@@ atch@@ _@@ get_@@ raw ( g@@ ar@@ row@@ _re@@ cor@@ d@@ _b@@ atch ) . get ( ) ; const auto n_@@ rows = re@@ cor@@ d@@ _b@@ atch -> num_@@ rows ( ) ; const auto n_@@ colum@@ ns = re@@ cor@@ d@@ _b@@ atch -> num_@@ colum@@ ns ( ) ; auto re@@ cor@@ ds = rb@@ _@@ ar@@ y_@@ new@@ _c@@ ap@@ a ( n_@@ rows ) ; try { Raw@@ Recor@@ ds@@ Builder builder ( re@@ cor@@ ds , n_@@ colum@@ ns ) ; builder . build ( * re@@ cor@@ d@@ _b@@ atch ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return re@@ cor@@ ds ; } VALUE table@@ _@@ raw@@ _re@@ cor@@ ds ( VALUE rb@@ _t@@ able ) { auto g@@ ar@@ row@@ _t@@ able = G@@ ARRO@@ W_@@ TABLE ( R@@ VAL@@ 2@@ G@@ OBJ ( rb@@ _t@@ able ) ) ; auto table = g@@ ar@@ row@@ _t@@ able@@ _@@ get_@@ raw ( g@@ ar@@ row@@ _t@@ able ) . get ( ) ; const auto n_@@ rows = table -> num_@@ rows ( ) ; const auto n_@@ colum@@ ns = table -> num_@@ colum@@ ns ( ) ; auto re@@ cor@@ ds = rb@@ _@@ ar@@ y_@@ new@@ _c@@ ap@@ a ( n_@@ rows ) ; try { Raw@@ Recor@@ ds@@ Builder builder ( re@@ cor@@ ds , n_@@ colum@@ ns ) ; builder . build ( * table ) ; } catch ( rb :: State & state ) { state . jump ( ) ; } return re@@ cor@@ ds ; } } </DOCUMENT>
<DOCUMENT_ID="@@ ho@@ ang@@ t/@@ go@@ b@@ lin@@ -@@ core@@ /tree/master/@@ ris@@ cv@@ /@@ llv@@ m/@@ 3.@@ 5@@ /@@ llvm@@ -3@@ .@@ 5.@@ 0.@@ src/@@ lib@@ /@@ Target@@ /@@ Mip@@ s/@@ Mip@@ s@@ SE@@ Frame@@ Lower@@ ing.cpp"> # include " Mip@@ s@@ SE@@ Frame@@ Lowering . h " # include " M@@ CTarget@@ Desc / Mip@@ s@@ Base@@ Info . h " # include " Mip@@ s@@ Analy@@ ze@@ Imm@@ ediate . h " # include " Mip@@ s@@ MachineFunction . h " # include " Mip@@ s@@ SE@@ Instr@@ Info . h " # include " Mip@@ s@@ Sub@@ target . h " # include " llvm / CodeGen / Machine@@ Frame@@ Info . h " # include " llvm / CodeGen / MachineFunction . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / Machine@@ Module@@ Info . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / CodeGen / Register@@ Sc@@ av@@ eng@@ ing . h " # include " llvm / IR / Data@@ Layout . h " # include " llvm / IR / Function . h " # include " llvm / Support / CommandLine . h " # include " llvm / Target / Target@@ Options . h " using namespace llvm ; namespace { typedef MachineBasicBlock :: iterator Iter ; static std :: pair < unsigned , unsigned > get@@ M@@ F@@ Hi@@ Lo@@ Op@@ c ( unsigned Src ) { if ( Mip@@ s :: ACC@@ 64@@ Reg@@ Class . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mip@@ s :: Pseudo@@ M@@ F@@ H@@ I , ( unsigned ) Mip@@ s :: Pseudo@@ M@@ FL@@ O ) ; if ( Mip@@ s :: ACC@@ 64@@ D@@ SP@@ Reg@@ Class . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mip@@ s :: M@@ F@@ HI@@ _@@ D@@ SP , ( unsigned ) Mip@@ s :: M@@ FLO@@ _@@ D@@ SP ) ; if ( Mip@@ s :: ACC@@ 128@@ Reg@@ Class . contains ( Src ) ) return std :: make_pair ( ( unsigned ) Mip@@ s :: Pseudo@@ M@@ F@@ HI@@ 64 , ( unsigned ) Mip@@ s :: Pseudo@@ M@@ FLO@@ 64 ) ; return std :: make_pair ( 0 , 0 ) ; } class Exp@@ and@@ P@@ seu@@ do { public : Exp@@ and@@ P@@ seu@@ do ( MachineFunction & MF ) ; bool expand ( ) ; private : bool expand@@ In@@ str ( MachineBasicBlock & MBB , Iter I ) ; void expand@@ Load@@ C@@ Con@@ d ( MachineBasicBlock & MBB , Iter I ) ; void expand@@ Store@@ C@@ Con@@ d ( MachineBasicBlock & MBB , Iter I ) ; void expand@@ Load@@ ACC ( MachineBasicBlock & MBB , Iter I , unsigned Reg@@ Size ) ; void expand@@ Store@@ ACC ( MachineBasicBlock & MBB , Iter I , unsigned M@@ F@@ Hi@@ Op@@ c , unsigned M@@ F@@ Lo@@ Op@@ c , unsigned Reg@@ Size ) ; bool expand@@ Copy ( MachineBasicBlock & MBB , Iter I ) ; bool expand@@ Copy@@ ACC ( MachineBasicBlock & MBB , Iter I , unsigned M@@ F@@ Hi@@ Op@@ c , unsigned M@@ F@@ Lo@@ Op@@ c ) ; bool expand@@ Build@@ Pair@@ F@@ 64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool F@@ P@@ 64 ) const ; bool expand@@ Extract@@ Element@@ F@@ 64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool F@@ P@@ 64 ) const ; MachineFunction & MF ; MachineRegisterInfo & MRI ; } ; } Exp@@ and@@ P@@ seu@@ do :: Exp@@ and@@ P@@ seu@@ do ( MachineFunction & M@@ F@@ _ ) : MF ( M@@ F@@ _ ) , MRI ( MF . getReg@@ Info ( ) ) { } bool Exp@@ and@@ P@@ seu@@ do :: expand ( ) { bool Exp@@ anded = false ; for ( MachineFunction :: iterator BB = MF . begin ( ) , BB@@ End = MF . end ( ) ; BB != BB@@ End ; ++ BB ) for ( Iter I = BB -> begin ( ) , End = BB -> end ( ) ; I != End ; ) Exp@@ anded |= expand@@ In@@ str ( * BB , I ++ ) ; return Exp@@ anded ; } bool Exp@@ and@@ P@@ seu@@ do :: expand@@ In@@ str ( MachineBasicBlock & MBB , Iter I ) { switch ( I -> get@@ Opcode ( ) ) { case Mip@@ s :: LOAD_@@ C@@ CON@@ D_@@ D@@ SP : expand@@ Load@@ C@@ Con@@ d ( MBB , I ) ; break ; case Mip@@ s :: ST@@ OR@@ E_@@ C@@ CON@@ D_@@ D@@ SP : expand@@ Store@@ C@@ Con@@ d ( MBB , I ) ; break ; case Mip@@ s :: LOAD_@@ ACC@@ 64 : case Mip@@ s :: LOAD_@@ ACC@@ 64@@ D@@ SP : expand@@ Load@@ ACC ( MBB , I , 4 ) ; break ; case Mip@@ s :: LOAD_@@ ACC@@ 128 : expand@@ Load@@ ACC ( MBB , I , 8 ) ; break ; case Mip@@ s :: ST@@ OR@@ E_ACC@@ 64 : expand@@ Store@@ ACC ( MBB , I , Mip@@ s :: Pseudo@@ M@@ F@@ H@@ I , Mip@@ s :: Pseudo@@ M@@ FL@@ O , 4 ) ; break ; case Mip@@ s :: ST@@ OR@@ E_ACC@@ 64@@ D@@ SP : expand@@ Store@@ ACC ( MBB , I , Mip@@ s :: M@@ F@@ HI@@ _@@ D@@ SP , Mip@@ s :: M@@ FLO@@ _@@ D@@ SP , 4 ) ; break ; case Mip@@ s :: ST@@ OR@@ E_ACC@@ 128 : expand@@ Store@@ ACC ( MBB , I , Mip@@ s :: Pseudo@@ M@@ F@@ HI@@ 64 , Mip@@ s :: Pseudo@@ M@@ FLO@@ 64 , 8 ) ; break ; case Mip@@ s :: Build@@ Pair@@ F@@ 64 : if ( expand@@ Build@@ Pair@@ F@@ 64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mip@@ s :: Build@@ Pair@@ F@@ 64@@ _64 : if ( expand@@ Build@@ Pair@@ F@@ 64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case Mip@@ s :: Extract@@ Element@@ F@@ 64 : if ( expand@@ Extract@@ Element@@ F@@ 64 ( MBB , I , false ) ) MBB . erase ( I ) ; return false ; case Mip@@ s :: Extract@@ Element@@ F@@ 64@@ _64 : if ( expand@@ Extract@@ Element@@ F@@ 64 ( MBB , I , true ) ) MBB . erase ( I ) ; return false ; case TargetOpcode :: COP@@ Y : if ( ! expand@@ Copy ( MBB , I ) ) return false ; break ; default : return false ; } MBB . erase ( I ) ; return true ; } void Exp@@ and@@ P@@ seu@@ do :: expand@@ Load@@ C@@ Con@@ d ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . is@@ Reg ( ) && I -> getOperand ( 1 ) . is@@ F@@ I ( ) ) ; const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & Reg@@ Info = * static_cast < const Mip@@ s@@ RegisterInfo * > ( MF . get@@ Target ( ) . get@@ RegisterInfo ( ) ) ; const TargetRegisterClass * RC = Reg@@ Info . int@@ Reg@@ Class ( 4 ) ; unsigned VR = MRI . createVirtual@@ Register ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , F@@ I = I -> getOperand ( 1 ) . getIndex ( ) ; TII . load@@ Reg@@ From@@ Stack ( MBB , I , VR , F@@ I , RC , & Reg@@ Info , 0 ) ; BuildMI ( MBB , I , I -> get@@ DebugLoc ( ) , TII . get ( TargetOpcode :: COP@@ Y ) , Dst ) . addReg ( VR , Reg@@ State :: Kill ) ; } void Exp@@ and@@ P@@ seu@@ do :: expand@@ Store@@ C@@ Con@@ d ( MachineBasicBlock & MBB , Iter I ) { assert ( I -> getOperand ( 0 ) . is@@ Reg ( ) && I -> getOperand ( 1 ) . is@@ F@@ I ( ) ) ; const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & Reg@@ Info = * static_cast < const Mip@@ s@@ RegisterInfo * > ( MF . get@@ Target ( ) . get@@ RegisterInfo ( ) ) ; const TargetRegisterClass * RC = Reg@@ Info . int@@ Reg@@ Class ( 4 ) ; unsigned VR = MRI . createVirtual@@ Register ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , F@@ I = I -> getOperand ( 1 ) . getIndex ( ) ; BuildMI ( MBB , I , I -> get@@ DebugLoc ( ) , TII . get ( TargetOpcode :: COP@@ Y ) , VR ) . addReg ( Src , get@@ Kill@@ Reg@@ State ( I -> getOperand ( 0 ) . is@@ Kill ( ) ) ) ; TII . store@@ Reg@@ To@@ Stack ( MBB , I , VR , true , F@@ I , RC , & Reg@@ Info , 0 ) ; } void Exp@@ and@@ P@@ seu@@ do :: expand@@ Load@@ ACC ( MachineBasicBlock & MBB , Iter I , unsigned Reg@@ Size ) { assert ( I -> getOperand ( 0 ) . is@@ Reg ( ) && I -> getOperand ( 1 ) . is@@ F@@ I ( ) ) ; const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & Reg@@ Info = * static_cast < const Mip@@ s@@ RegisterInfo * > ( MF . get@@ Target ( ) . get@@ RegisterInfo ( ) ) ; const TargetRegisterClass * RC = Reg@@ Info . int@@ Reg@@ Class ( Reg@@ Size ) ; unsigned V@@ R0 = MRI . createVirtual@@ Register ( RC ) ; unsigned VR@@ 1 = MRI . createVirtual@@ Register ( RC ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , F@@ I = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Lo = Reg@@ Info . getSub@@ Reg ( Dst , Mip@@ s :: sub@@ _@@ lo ) ; unsigned Hi = Reg@@ Info . getSub@@ Reg ( Dst , Mip@@ s :: sub@@ _hi ) ; DebugLoc D@@ L = I -> get@@ DebugLoc ( ) ; const MC@@ Instr@@ Desc & Desc = TII . get ( TargetOpcode :: COP@@ Y ) ; TII . load@@ Reg@@ From@@ Stack ( MBB , I , V@@ R0 , F@@ I , RC , & Reg@@ Info , 0 ) ; BuildMI ( MBB , I , D@@ L , Desc , Lo ) . addReg ( V@@ R0 , Reg@@ State :: Kill ) ; TII . load@@ Reg@@ From@@ Stack ( MBB , I , VR@@ 1 , F@@ I , RC , & Reg@@ Info , Reg@@ Size ) ; BuildMI ( MBB , I , D@@ L , Desc , Hi ) . addReg ( VR@@ 1 , Reg@@ State :: Kill ) ; } void Exp@@ and@@ P@@ seu@@ do :: expand@@ Store@@ ACC ( MachineBasicBlock & MBB , Iter I , unsigned M@@ F@@ Hi@@ Op@@ c , unsigned M@@ F@@ Lo@@ Op@@ c , unsigned Reg@@ Size ) { assert ( I -> getOperand ( 0 ) . is@@ Reg ( ) && I -> getOperand ( 1 ) . is@@ F@@ I ( ) ) ; const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & Reg@@ Info = * static_cast < const Mip@@ s@@ RegisterInfo * > ( MF . get@@ Target ( ) . get@@ RegisterInfo ( ) ) ; const TargetRegisterClass * RC = Reg@@ Info . int@@ Reg@@ Class ( Reg@@ Size ) ; unsigned V@@ R0 = MRI . createVirtual@@ Register ( RC ) ; unsigned VR@@ 1 = MRI . createVirtual@@ Register ( RC ) ; unsigned Src = I -> getOperand ( 0 ) . getReg ( ) , F@@ I = I -> getOperand ( 1 ) . getIndex ( ) ; unsigned Src@@ Kill = get@@ Kill@@ Reg@@ State ( I -> getOperand ( 0 ) . is@@ Kill ( ) ) ; DebugLoc D@@ L = I -> get@@ DebugLoc ( ) ; BuildMI ( MBB , I , D@@ L , TII . get ( M@@ F@@ Lo@@ Op@@ c ) , V@@ R0 ) . addReg ( Src ) ; TII . store@@ Reg@@ To@@ Stack ( MBB , I , V@@ R0 , true , F@@ I , RC , & Reg@@ Info , 0 ) ; BuildMI ( MBB , I , D@@ L , TII . get ( M@@ F@@ Hi@@ Op@@ c ) , VR@@ 1 ) . addReg ( Src , Src@@ Kill ) ; TII . store@@ Reg@@ To@@ Stack ( MBB , I , VR@@ 1 , true , F@@ I , RC , & Reg@@ Info , Reg@@ Size ) ; } bool Exp@@ and@@ P@@ seu@@ do :: expand@@ Copy ( MachineBasicBlock & MBB , Iter I ) { unsigned Src = I -> getOperand ( 1 ) . getReg ( ) ; std :: pair < unsigned , unsigned > Opcodes = get@@ M@@ F@@ Hi@@ Lo@@ Op@@ c ( Src ) ; if ( ! Opcodes . first ) return false ; return expand@@ Copy@@ ACC ( MBB , I , Opcodes . first , Opcodes . second ) ; } bool Exp@@ and@@ P@@ seu@@ do :: expand@@ Copy@@ ACC ( MachineBasicBlock & MBB , Iter I , unsigned M@@ F@@ Hi@@ Op@@ c , unsigned M@@ F@@ Lo@@ Op@@ c ) { const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & Reg@@ Info = * static_cast < const Mip@@ s@@ RegisterInfo * > ( MF . get@@ Target ( ) . get@@ RegisterInfo ( ) ) ; unsigned Dst = I -> getOperand ( 0 ) . getReg ( ) , Src = I -> getOperand ( 1 ) . getReg ( ) ; unsigned VReg@@ Size = Reg@@ Info . get@@ Min@@ im@@ al@@ Ph@@ ys@@ Reg@@ Class ( Dst ) -> getSize ( ) / 2 ; const TargetRegisterClass * RC = Reg@@ Info . int@@ Reg@@ Class ( VReg@@ Size ) ; unsigned V@@ R0 = MRI . createVirtual@@ Register ( RC ) ; unsigned VR@@ 1 = MRI . createVirtual@@ Register ( RC ) ; unsigned Src@@ Kill = get@@ Kill@@ Reg@@ State ( I -> getOperand ( 1 ) . is@@ Kill ( ) ) ; unsigned Dst@@ Lo = Reg@@ Info . getSub@@ Reg ( Dst , Mip@@ s :: sub@@ _@@ lo ) ; unsigned Dst@@ Hi = Reg@@ Info . getSub@@ Reg ( Dst , Mip@@ s :: sub@@ _hi ) ; DebugLoc D@@ L = I -> get@@ DebugLoc ( ) ; BuildMI ( MBB , I , D@@ L , TII . get ( M@@ F@@ Lo@@ Op@@ c ) , V@@ R0 ) . addReg ( Src ) ; BuildMI ( MBB , I , D@@ L , TII . get ( TargetOpcode :: COP@@ Y ) , Dst@@ Lo ) . addReg ( V@@ R0 , Reg@@ State :: Kill ) ; BuildMI ( MBB , I , D@@ L , TII . get ( M@@ F@@ Hi@@ Op@@ c ) , VR@@ 1 ) . addReg ( Src , Src@@ Kill ) ; BuildMI ( MBB , I , D@@ L , TII . get ( TargetOpcode :: COP@@ Y ) , Dst@@ Hi ) . addReg ( VR@@ 1 , Reg@@ State :: Kill ) ; return true ; } bool Exp@@ and@@ P@@ seu@@ do :: expand@@ Build@@ Pair@@ F@@ 64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool F@@ P@@ 64 ) const { const Target@@ Machine & TM = MF . get@@ Target ( ) ; const Mip@@ s@@ Sub@@ target & Sub@@ target = TM . getSub@@ target < Mip@@ s@@ Sub@@ target > ( ) ; if ( ( Sub@@ target . is@@ AB@@ I@@ _F@@ P@@ X@@ X ( ) && ! Sub@@ target . has@@ M@@ TH@@ C@@ 1 ( ) ) || ( F@@ P@@ 64 && ! Sub@@ target . use@@ O@@ dd@@ SP@@ Reg ( ) ) ) { const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( TM . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & TR@@ I = * static_cast < const Mip@@ s@@ RegisterInfo * > ( TM . get@@ RegisterInfo ( ) ) ; unsigned Dst@@ Reg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned Lo@@ Reg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned Hi@@ Reg = I -> getOperand ( 2 ) . getReg ( ) ; assert ( Sub@@ target . is@@ GP@@ 64@@ bit ( ) || Sub@@ target . has@@ M@@ TH@@ C@@ 1 ( ) || ! Sub@@ target . is@@ F@@ P@@ 64@@ bit ( ) ) ; const TargetRegisterClass * RC = & Mip@@ s :: GP@@ R@@ 32@@ Reg@@ Class ; const TargetRegisterClass * RC@@ 2 = F@@ P@@ 64 ? & Mip@@ s :: F@@ GR@@ 64@@ Reg@@ Class : & Mip@@ s :: AF@@ GR@@ 64@@ Reg@@ Class ; int F@@ I = MF . get@@ Info < Mip@@ s@@ Function@@ Info > ( ) -> get@@ Move@@ F@@ 64@@ Vi@@ a@@ Sp@@ ill@@ F@@ I ( RC@@ 2 ) ; TII . store@@ Reg@@ To@@ Stack ( MBB , I , Lo@@ Reg , I -> getOperand ( 1 ) . is@@ Kill ( ) , F@@ I , RC , & TR@@ I , 0 ) ; TII . store@@ Reg@@ To@@ Stack ( MBB , I , Hi@@ Reg , I -> getOperand ( 2 ) . is@@ Kill ( ) , F@@ I , RC , & TR@@ I , 4 ) ; TII . load@@ Reg@@ From@@ Stack ( MBB , I , Dst@@ Reg , F@@ I , RC@@ 2 , & TR@@ I , 0 ) ; return true ; } return false ; } bool Exp@@ and@@ P@@ seu@@ do :: expand@@ Extract@@ Element@@ F@@ 64 ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator I , bool F@@ P@@ 64 ) const { const Target@@ Machine & TM = MF . get@@ Target ( ) ; const Mip@@ s@@ Sub@@ target & Sub@@ target = TM . getSub@@ target < Mip@@ s@@ Sub@@ target > ( ) ; if ( ( Sub@@ target . is@@ AB@@ I@@ _F@@ P@@ X@@ X ( ) && ! Sub@@ target . has@@ M@@ TH@@ C@@ 1 ( ) ) || ( F@@ P@@ 64 && ! Sub@@ target . use@@ O@@ dd@@ SP@@ Reg ( ) ) ) { const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( TM . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & TR@@ I = * static_cast < const Mip@@ s@@ RegisterInfo * > ( TM . get@@ RegisterInfo ( ) ) ; unsigned Dst@@ Reg = I -> getOperand ( 0 ) . getReg ( ) ; unsigned SrcReg = I -> getOperand ( 1 ) . getReg ( ) ; unsigned N = I -> getOperand ( 2 ) . getIm@@ m ( ) ; assert ( Sub@@ target . is@@ GP@@ 64@@ bit ( ) || Sub@@ target . has@@ M@@ TH@@ C@@ 1 ( ) || ! Sub@@ target . is@@ F@@ P@@ 64@@ bit ( ) ) ; const TargetRegisterClass * RC = F@@ P@@ 64 ? & Mip@@ s :: F@@ GR@@ 64@@ Reg@@ Class : & Mip@@ s :: AF@@ GR@@ 64@@ Reg@@ Class ; const TargetRegisterClass * RC@@ 2 = & Mip@@ s :: GP@@ R@@ 32@@ Reg@@ Class ; int F@@ I = MF . get@@ Info < Mip@@ s@@ Function@@ Info > ( ) -> get@@ Move@@ F@@ 64@@ Vi@@ a@@ Sp@@ ill@@ F@@ I ( RC ) ; TII . store@@ Reg@@ To@@ Stack ( MBB , I , SrcReg , I -> getOperand ( 1 ) . is@@ Kill ( ) , F@@ I , RC , & TR@@ I , 0 ) ; TII . load@@ Reg@@ From@@ Stack ( MBB , I , Dst@@ Reg , F@@ I , RC@@ 2 , & TR@@ I , N * 4 ) ; return true ; } return false ; } Mip@@ s@@ SE@@ Frame@@ Lowering :: Mip@@ s@@ SE@@ Frame@@ Lowering ( const Mip@@ s@@ Sub@@ target & ST@@ I ) : Mip@@ s@@ Frame@@ Lowering ( ST@@ I , ST@@ I . stack@@ Alignment ( ) ) { } unsigned Mip@@ s@@ SE@@ Frame@@ Lowering :: e@@ h@@ Data@@ Reg ( unsigned I ) const { static const unsigned E@@ h@@ Data@@ Reg [ ] = { Mip@@ s :: A0 , Mip@@ s :: A1 , Mip@@ s :: A2 , Mip@@ s :: A3 } ; static const unsigned E@@ h@@ Data@@ Reg@@ 64 [ ] = { Mip@@ s :: A@@ 0@@ _64 , Mip@@ s :: A@@ 1_@@ 64 , Mip@@ s :: A2_@@ 64 , Mip@@ s :: A@@ 3@@ _64 } ; return ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? E@@ h@@ Data@@ Reg@@ 64 [ I ] : E@@ h@@ Data@@ Reg [ I ] ; } void Mip@@ s@@ SE@@ Frame@@ Lowering :: em@@ it@@ Pro@@ logue ( MachineFunction & MF ) const { MachineBasicBlock & MBB = MF . front ( ) ; Machine@@ Frame@@ Info * M@@ F@@ I = MF . get@@ Frame@@ Info ( ) ; Mip@@ s@@ Function@@ Info * Mip@@ s@@ F@@ I = MF . get@@ Info < Mip@@ s@@ Function@@ Info > ( ) ; const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & Reg@@ Info = * static_cast < const Mip@@ s@@ RegisterInfo * > ( MF . get@@ Target ( ) . get@@ RegisterInfo ( ) ) ; MachineBasicBlock :: iterator MB@@ B@@ I = MBB . begin ( ) ; DebugLoc dl = MB@@ B@@ I != MBB . end ( ) ? MB@@ B@@ I -> get@@ DebugLoc ( ) : DebugLoc ( ) ; unsigned SP = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: SP_@@ 64 : Mip@@ s :: SP ; unsigned FP = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: F@@ P_@@ 64 : Mip@@ s :: FP ; unsigned ZER@@ O = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: ZERO_@@ 64 : Mip@@ s :: ZER@@ O ; unsigned ADD@@ u = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: D@@ ADD@@ u : Mip@@ s :: ADD@@ u ; uint64_t StackSize = M@@ F@@ I -> get@@ StackSize ( ) ; if ( StackSize == 0 && ! M@@ F@@ I -> adjust@@ s@@ Stack ( ) ) return ; Machine@@ Module@@ Info & M@@ MI = MF . get@@ M@@ MI ( ) ; const MC@@ RegisterInfo * MRI = M@@ MI . get@@ Context ( ) . get@@ RegisterInfo ( ) ; Machine@@ Location Dst@@ ML , Src@@ ML ; TII . adjust@@ Stack@@ Ptr ( SP , - StackSize , MBB , MB@@ B@@ I ) ; unsigned C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Def@@ C@@ fa@@ Offset ( nullptr , - StackSize ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; const std :: vector < Calle@@ eSaved@@ Info > & C@@ SI = M@@ F@@ I -> get@@ Calle@@ eSaved@@ Info ( ) ; if ( C@@ SI . size ( ) ) { for ( unsigned i = 0 ; i < C@@ SI . size ( ) ; ++ i ) ++ MB@@ B@@ I ; for ( std :: vector < Calle@@ eSaved@@ Info > :: const_iterator I = C@@ SI . begin ( ) , E = C@@ SI . end ( ) ; I != E ; ++ I ) { int64_t Offset = M@@ F@@ I -> get@@ Object@@ Offset ( I -> get@@ Frame@@ Idx ( ) ) ; unsigned Reg = I -> getReg ( ) ; if ( Mip@@ s :: AF@@ GR@@ 64@@ Reg@@ Class . contains ( Reg ) ) { unsigned Reg@@ 0 = MRI -> getD@@ w@@ ar@@ f@@ Reg@@ Num ( Reg@@ Info . getSub@@ Reg ( Reg , Mip@@ s :: sub@@ _@@ lo ) , true ) ; unsigned Reg@@ 1 = MRI -> getD@@ w@@ ar@@ f@@ Reg@@ Num ( Reg@@ Info . getSub@@ Reg ( Reg , Mip@@ s :: sub@@ _hi ) , true ) ; if ( ! ST@@ I . is@@ Litt@@ le ( ) ) std :: swap ( Reg@@ 0 , Reg@@ 1 ) ; unsigned C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Offset ( nullptr , Reg@@ 0 , Offset ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Offset ( nullptr , Reg@@ 1 , Offset + 4 ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; } else if ( Mip@@ s :: F@@ GR@@ 64@@ Reg@@ Class . contains ( Reg ) ) { unsigned Reg@@ 0 = MRI -> getD@@ w@@ ar@@ f@@ Reg@@ Num ( Reg , true ) ; unsigned Reg@@ 1 = MRI -> getD@@ w@@ ar@@ f@@ Reg@@ Num ( Reg , true ) + 1 ; if ( ! ST@@ I . is@@ Litt@@ le ( ) ) std :: swap ( Reg@@ 0 , Reg@@ 1 ) ; unsigned C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Offset ( nullptr , Reg@@ 0 , Offset ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Offset ( nullptr , Reg@@ 1 , Offset + 4 ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; } else { unsigned C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Offset ( nullptr , MRI -> getD@@ w@@ ar@@ f@@ Reg@@ Num ( Reg , 1 ) , Offset ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; } } } if ( Mip@@ s@@ F@@ I -> call@@ s@@ E@@ h@@ Return ( ) ) { const TargetRegisterClass * RC = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? & Mip@@ s :: GP@@ R@@ 64@@ Reg@@ Class : & Mip@@ s :: GP@@ R@@ 32@@ Reg@@ Class ; for ( int I = 0 ; I < 4 ; ++ I ) { if ( ! MBB . is@@ Live@@ In ( e@@ h@@ Data@@ Reg ( I ) ) ) MBB . add@@ Live@@ In ( e@@ h@@ Data@@ Reg ( I ) ) ; TII . store@@ Reg@@ To@@ Stack@@ Slot ( MBB , MB@@ B@@ I , e@@ h@@ Data@@ Reg ( I ) , false , Mip@@ s@@ F@@ I -> get@@ E@@ h@@ Data@@ Reg@@ F@@ I ( I ) , RC , & Reg@@ Info ) ; } for ( int I = 0 ; I < 4 ; ++ I ) { int64_t Offset = M@@ F@@ I -> get@@ Object@@ Offset ( Mip@@ s@@ F@@ I -> get@@ E@@ h@@ Data@@ Reg@@ F@@ I ( I ) ) ; unsigned Reg = MRI -> getD@@ w@@ ar@@ f@@ Reg@@ Num ( e@@ h@@ Data@@ Reg ( I ) , true ) ; unsigned C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Offset ( nullptr , Reg , Offset ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; } } if ( has@@ FP ( MF ) ) { BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( ADD@@ u ) , FP ) . addReg ( SP ) . addReg ( ZER@@ O ) . set@@ M@@ IF@@ lag ( MachineInstr :: FrameSet@@ up ) ; unsigned C@@ FI@@ Index = M@@ MI . add@@ Frame@@ Inst ( M@@ CC@@ FI@@ Instruction :: create@@ Def@@ C@@ fa@@ Register ( nullptr , MRI -> getD@@ w@@ ar@@ f@@ Reg@@ Num ( FP , true ) ) ) ; BuildMI ( MBB , MB@@ B@@ I , dl , TII . get ( TargetOpcode :: C@@ FI@@ _IN@@ STR@@ UC@@ TION ) ) . add@@ C@@ FI@@ Index ( C@@ FI@@ Index ) ; } } void Mip@@ s@@ SE@@ Frame@@ Lowering :: em@@ it@@ E@@ pi@@ logue ( MachineFunction & MF , MachineBasicBlock & MBB ) const { MachineBasicBlock :: iterator MB@@ B@@ I = MBB . getLast@@ Non@@ Debug@@ In@@ str ( ) ; Machine@@ Frame@@ Info * M@@ F@@ I = MF . get@@ Frame@@ Info ( ) ; Mip@@ s@@ Function@@ Info * Mip@@ s@@ F@@ I = MF . get@@ Info < Mip@@ s@@ Function@@ Info > ( ) ; const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; const Mip@@ s@@ RegisterInfo & Reg@@ Info = * static_cast < const Mip@@ s@@ RegisterInfo * > ( MF . get@@ Target ( ) . get@@ RegisterInfo ( ) ) ; DebugLoc dl = MB@@ B@@ I -> get@@ DebugLoc ( ) ; unsigned SP = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: SP_@@ 64 : Mip@@ s :: SP ; unsigned FP = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: F@@ P_@@ 64 : Mip@@ s :: FP ; unsigned ZER@@ O = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: ZERO_@@ 64 : Mip@@ s :: ZER@@ O ; unsigned ADD@@ u = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: D@@ ADD@@ u : Mip@@ s :: ADD@@ u ; if ( has@@ FP ( MF ) ) { MachineBasicBlock :: iterator I = MB@@ B@@ I ; for ( unsigned i = 0 ; i < M@@ F@@ I -> get@@ Calle@@ eSaved@@ Info ( ) . size ( ) ; ++ i ) -- I ; BuildMI ( MBB , I , dl , TII . get ( ADD@@ u ) , SP ) . addReg ( FP ) . addReg ( ZER@@ O ) ; } if ( Mip@@ s@@ F@@ I -> call@@ s@@ E@@ h@@ Return ( ) ) { const TargetRegisterClass * RC = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? & Mip@@ s :: GP@@ R@@ 64@@ Reg@@ Class : & Mip@@ s :: GP@@ R@@ 32@@ Reg@@ Class ; MachineBasicBlock :: iterator I = MB@@ B@@ I ; for ( unsigned i = 0 ; i < M@@ F@@ I -> get@@ Calle@@ eSaved@@ Info ( ) . size ( ) ; ++ i ) -- I ; for ( int J = 0 ; J < 4 ; ++ J ) { TII . load@@ Reg@@ From@@ Stack@@ Slot ( MBB , I , e@@ h@@ Data@@ Reg ( J ) , Mip@@ s@@ F@@ I -> get@@ E@@ h@@ Data@@ Reg@@ F@@ I ( J ) , RC , & Reg@@ Info ) ; } } uint64_t StackSize = M@@ F@@ I -> get@@ StackSize ( ) ; if ( ! StackSize ) return ; TII . adjust@@ Stack@@ Ptr ( SP , StackSize , MBB , MB@@ B@@ I ) ; } bool Mip@@ s@@ SE@@ Frame@@ Lowering :: sp@@ ill@@ Calle@@ eSaved@@ Register@@ s ( MachineBasicBlock & MBB , MachineBasicBlock :: iterator MI , const std :: vector < Calle@@ eSaved@@ Info > & C@@ SI , const TargetRegisterInfo * TR@@ I ) const { MachineFunction * MF = MBB . getParent ( ) ; MachineBasicBlock * Entry@@ Block = MF -> begin ( ) ; const TargetInstrInfo & TII = * MF -> get@@ Target ( ) . getIn@@ strInfo ( ) ; for ( unsigned i = 0 , e = C@@ SI . size ( ) ; i != e ; ++ i ) { unsigned Reg = C@@ SI [ i ] . getReg ( ) ; bool Is@@ RA@@ And@@ Ret@@ Addr@@ Is@@ Taken = ( Reg == Mip@@ s :: RA || Reg == Mip@@ s :: R@@ A_@@ 64 ) && MF -> get@@ Frame@@ Info ( ) -> is@@ Return@@ Address@@ Taken ( ) ; if ( ! Is@@ RA@@ And@@ Ret@@ Addr@@ Is@@ Taken ) Entry@@ Block -> add@@ Live@@ In ( Reg ) ; bool Is@@ Kill = ! Is@@ RA@@ And@@ Ret@@ Addr@@ Is@@ Taken ; const TargetRegisterClass * RC = TR@@ I -> get@@ Min@@ im@@ al@@ Ph@@ ys@@ Reg@@ Class ( Reg ) ; TII . store@@ Reg@@ To@@ Stack@@ Slot ( * Entry@@ Block , MI , Reg , Is@@ Kill , C@@ SI [ i ] . get@@ Frame@@ Idx ( ) , RC , TR@@ I ) ; } return true ; } bool Mip@@ s@@ SE@@ Frame@@ Lowering :: has@@ Reser@@ ved@@ CallFrame ( const MachineFunction & MF ) const { const Machine@@ Frame@@ Info * M@@ F@@ I = MF . get@@ Frame@@ Info ( ) ; return is@@ Int < 16 > ( M@@ F@@ I -> get@@ Max@@ Call@@ Frame@@ Size ( ) + get@@ Stack@@ Alignment ( ) ) && ! M@@ F@@ I -> has@@ Var@@ S@@ ized@@ Objects ( ) ; } void Mip@@ s@@ SE@@ Frame@@ Lowering :: elimin@@ ate@@ Call@@ Frame@@ Pseudo@@ In@@ str ( MachineFunction & MF , MachineBasicBlock & MBB , MachineBasicBlock :: iterator I ) const { const Mip@@ s@@ SE@@ Instr@@ Info & TII = * static_cast < const Mip@@ s@@ SE@@ Instr@@ Info * > ( MF . get@@ Target ( ) . getIn@@ strInfo ( ) ) ; if ( ! has@@ Reser@@ ved@@ CallFrame ( MF ) ) { int64_t Amount = I -> getOperand ( 0 ) . getIm@@ m ( ) ; if ( I -> get@@ Opcode ( ) == Mip@@ s :: AD@@ J@@ CALL@@ STACK@@ DOWN ) Amount = - Amount ; unsigned SP = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: SP_@@ 64 : Mip@@ s :: SP ; TII . adjust@@ Stack@@ Ptr ( SP , Amount , MBB , I ) ; } MBB . erase ( I ) ; } void Mip@@ s@@ SE@@ Frame@@ Lowering :: process@@ Function@@ Before@@ Calle@@ eSaved@@ Scan ( MachineFunction & MF , Reg@@ Sc@@ av@@ enger * RS ) const { MachineRegisterInfo & MRI = MF . getReg@@ Info ( ) ; Mip@@ s@@ Function@@ Info * Mip@@ s@@ F@@ I = MF . get@@ Info < Mip@@ s@@ Function@@ Info > ( ) ; unsigned FP = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? Mip@@ s :: F@@ P_@@ 64 : Mip@@ s :: FP ; if ( has@@ FP ( MF ) ) MRI . set@@ Ph@@ ys@@ Reg@@ Used ( FP ) ; if ( Mip@@ s@@ F@@ I -> call@@ s@@ E@@ h@@ Return ( ) ) Mip@@ s@@ F@@ I -> create@@ E@@ h@@ Data@@ Reg@@ s@@ F@@ I ( ) ; if ( Exp@@ and@@ P@@ seu@@ do ( MF ) . expand ( ) ) { const TargetRegisterClass * RC = ST@@ I . has@@ Mip@@ s64 ( ) ? & Mip@@ s :: GP@@ R@@ 64@@ Reg@@ Class : & Mip@@ s :: GP@@ R@@ 32@@ Reg@@ Class ; int F@@ I = MF . get@@ Frame@@ Info ( ) -> Create@@ Stack@@ Object ( RC -> getSize ( ) , RC -> get@@ Alignment ( ) , false ) ; RS -> add@@ Sc@@ av@@ eng@@ ing@@ FrameIndex ( F@@ I ) ; } uint64_t Max@@ SP@@ Offset = MF . get@@ Info < Mip@@ s@@ Function@@ Info > ( ) -> getIncoming@@ Ar@@ g@@ Size ( ) + est@@ imat@@ e@@ StackSize ( MF ) ; if ( is@@ Int < 16 > ( Max@@ SP@@ Offset ) ) return ; const TargetRegisterClass * RC = ST@@ I . is@@ ABI_@@ N@@ 64 ( ) ? & Mip@@ s :: GP@@ R@@ 64@@ Reg@@ Class : & Mip@@ s :: GP@@ R@@ 32@@ Reg@@ Class ; int F@@ I = MF . get@@ Frame@@ Info ( ) -> Create@@ Stack@@ Object ( RC -> getSize ( ) , RC -> get@@ Alignment ( ) , false ) ; RS -> add@@ Sc@@ av@@ eng@@ ing@@ FrameIndex ( F@@ I ) ; } const Mip@@ s@@ Frame@@ Lowering * llvm :: create@@ Mip@@ s@@ SE@@ Frame@@ Lowering ( const Mip@@ s@@ Sub@@ target & ST ) { return new Mip@@ s@@ SE@@ Frame@@ Lowering ( ST ) ; } </DOCUMENT>
<DOCUMENT_ID="@@ Dist@@ ro@@ te@@ ch@@ /xbmc/tree/master/xbmc/@@ android/@@ jni@@ /@@ Base@@ Colum@@ ns@@ .cpp"> # include " Base@@ Columns . h " # include " jutils / jutils - details . hpp " using namespace jni ; std :: string CJ@@ N@@ I@@ Base@@ Columns :: _@@ ID ; std :: string CJ@@ N@@ I@@ Base@@ Columns :: _@@ COUNT ; void CJ@@ N@@ I@@ Base@@ Columns :: Po@@ pu@@ late@@ Static@@ Field@@ s ( ) { j@@ h@@ class cla@@ z@@ z = find_@@ class ( " android / provider / Base@@ Columns " ) ; _@@ ID = ( jcast < std :: string > ( get_@@ static_@@ field < jhstring > ( cla@@ z@@ z , " _ ID " ) ) ) ; _@@ COUNT = ( jcast < std :: string > ( get_@@ static_@@ field < jhstring > ( cla@@ z@@ z , " _ COUNT " ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="p@@ col@@ by@@ /lib@@ q@@ ta@@ w@@ s@@ /tree/master/src/@@ ss@@ m/@@ des@@ cri@@ be@@ instan@@ ce@@ patch@@ stat@@ es@@ respon@@ se@@ .cpp"> # include " des@@ cri@@ be@@ instan@@ ce@@ patch@@ stat@@ es@@ response . h " # include " des@@ cri@@ be@@ instan@@ ce@@ patch@@ stat@@ es@@ response _ p . h " # include < QDebug > # include < Q@@ Network@@ Re@@ ply > # include < QXmlStream@@ Reader > namespace Qt@@ Aws { namespace SS@@ M { Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response :: Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response ( const Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Request & request , Q@@ Network@@ Re@@ ply * const reply , QObject * const parent ) : S@@ sm@@ Response ( new Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response@@ Private ( this ) , parent ) { set@@ Request ( new Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Request ( request ) ) ; set@@ Re@@ ply ( reply ) ; } const Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Request * Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response :: request ( ) const { Q_D ( const Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response ) ; return static_cast < const Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Request * > ( d -> request ) ; } void Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response :: parse@@ Success ( QIODevice & response ) { QXmlStream@@ Reader xml ( & response ) ; } Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response@@ Private :: Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response@@ Private ( Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response * const q ) : S@@ sm@@ Response@@ Private ( q ) { } void Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response@@ Private :: parse@@ Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response ( QXmlStream@@ Reader & xml ) { Q_ASSERT ( xml . name ( ) == QLatin1String ( " Des@@ cri@@ be@@ Instance@@ Patch@@ Stat@@ es@@ Response " ) ) ; Q_UNUSED ( xml ) } } } </DOCUMENT>
<DOCUMENT_ID="@@ mini@@ webkit@@ /@@ src@@ /tree/master/@@ WebCore/@@ xml@@ /@@ XML@@ Serializer.cpp"> # include " config . h " # include " XML@@ Serializer . h " # include " Document . h " # include " ExceptionCode . h " # include " mark@@ up . h " namespace WebCore { String XML@@ Serializer :: serial@@ ize@@ ToString ( Node * node , ExceptionCode & ec ) { if ( ! node ) return String ( ) ; if ( ! node -> document ( ) ) { ASSERT ( node -> nodeType ( ) == Node :: DOCUM@@ ENT_@@ TYPE_@@ NODE ) ; ec = INVALID_@@ ACC@@ ESS_@@ ERR ; return String ( ) ; } return create@@ Mark@@ up ( node ) ; } } </DOCUMENT>
<DOCUMENT_ID="@@ Mic@@ ro@@ so@@ ft@@ /@@ PT@@ V@@ S@@ /tree/master/@@ Python@@ /Tests/@@ G@@ las@@ s@@ Tests/@@ Python@@ Tests/@@ Python@@ /@@ Step@@ Python@@ To@@ N@@ ativ@@ e_@@ Iter@@ Next@@ /cpp@@ _@@ mod@@ .cpp"> # pragma optim@@ ize ( " " , off ) # include < python . h > struct Cpp@@ Obj { PyObject_@@ HEAD } ; PyObject * Cpp@@ Obj@@ _@@ iter@@ next ( PyObject * self ) { Py_@@ RE@@ TUR@@ N_@@ NONE ; } PyTypeObject * Cpp@@ Obj@@ _type ( ) { static PyTypeObject t = { Py@@ Var@@ Object_@@ HE@@ AD_@@ INIT ( NULL , 0 ) } ; t . t@@ p_@@ name = " cpp _ mod . Cpp@@ Obj " ; t . t@@ p@@ _b@@ as@@ ic@@ size = sizeof Cpp@@ Obj ; t . t@@ p_@@ flags = Py_@@ T@@ P@@ FLA@@ GS_@@ DEFAULT ; t . t@@ p_@@ iter@@ next = Cpp@@ Obj@@ _@@ iter@@ next ; return & t ; } Py@@ Method@@ Def methods [ ] = { NULL } ; PyTypeObject * types [ ] = { Cpp@@ Obj@@ _type ( ) , NULL } ; </DOCUMENT>
<DOCUMENT_ID="@@ at@@ i@@ dot@@ 3@@ /@@ Ori@@ zon@@ -@@ 5@@ 10@@ /tree/master/src/server/@@ auth@@ server/@@ Main@@ .cpp"> # include < ace / Dev@@ _@@ Po@@ ll@@ _@@ Re@@ actor . h > # include < ace / T@@ P_@@ Re@@ actor . h > # include < ace / ACE . h > # include < ace / S@@ ig_@@ Handler . h > # include < openssl / open@@ ss@@ l@@ v . h > # include < openssl / crypt@@ o . h > # include " Common . h " # include " Database / Database@@ Env . h " # include " Configuration / Config . h " # include " Log . h " # include " System@@ Config . h " # include " Util . h " # include " Signal@@ Handler . h " # include " Real@@ m@@ List . h " # include " Real@@ m@@ Accept@@ or . h " # ifndef _@@ TR@@ IN@@ ITY_@@ REAL@@ M_@@ CONFIG # define _@@ TR@@ IN@@ ITY_@@ REAL@@ M_@@ CONFIG " auth@@ server . conf " # endif bool Start@@ DB ( ) ; void Stop@@ DB ( ) ; bool stop@@ Event = false ; Log@@ in@@ Database@@ Wor@@ ker@@ Pool LoginDatabase ; class Auth@@ Ser@@ ver@@ Signal@@ Handler : public Trinity :: Signal@@ Handler { public : virtual void Handle@@ Sign@@ al ( int Sig@@ Num ) { switch ( Sig@@ Num ) { case SIG@@ INT : case SIG@@ TER@@ M : stop@@ Event = true ; break ; } } } ; void usa@@ ge ( const char * prog ) { s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Usa@@ ge : ▁ \n ▁ % s ▁ [ < options > ] \n " " ▁ ▁ ▁ ▁ - c ▁ config _ file ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ use ▁ config _ file ▁ as ▁ configuration ▁ file \n " , prog ) ; } extern int main ( int argc , char * * argv ) { char const * cf@@ g_@@ file = _@@ TR@@ IN@@ ITY_@@ REAL@@ M_@@ CONFIG ; int c = 1 ; while ( c < argc ) { if ( strcmp ( argv [ c ] , " - c " ) == 0 ) { if ( ++ c >= argc ) { printf ( " Runtime - Error : ▁ - c ▁ option ▁ requires ▁ an ▁ input ▁ argument \n " ) ; usa@@ ge ( argv [ 0 ] ) ; return 1 ; } else cf@@ g_@@ file = argv [ c ] ; } ++ c ; } if ( ! Config@@ Mgr :: Load ( cf@@ g_@@ file ) ) { printf ( " Invalid ▁ or ▁ missing ▁ configuration ▁ file ▁ : ▁ % s \n " , cf@@ g_@@ file ) ; printf ( " Verify ▁ that ▁ the ▁ file ▁ exists ▁ and ▁ has ▁ \ ' [ auth@@ server ] \ ' ▁ written ▁ in ▁ the ▁ top ▁ of ▁ the ▁ file ! \n " ) ; return 1 ; } s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " % s ▁ ( auth@@ server ) " , _F@@ UL@@ L@@ VERSION ) ; s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " < Ctrl - C > ▁ to ▁ stop . \n " ) ; s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " U@@ sing ▁ configuration ▁ file ▁ % s . " , cf@@ g_@@ file ) ; s@@ Log -> out@@ War@@ n ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " % s ▁ ( Library : ▁ % s ) " , OPEN@@ SS@@ L_@@ VERSION_@@ TEXT , SS@@ Le@@ a@@ y_@@ version ( SS@@ LE@@ AY_@@ VERSION ) ) ; # if defined ( ACE_HAS_@@ EVENT_@@ POL@@ L ) || defined ( ACE_HAS_@@ DEV@@ _@@ POL@@ L ) ACE_@@ Re@@ actor :: instance ( new ACE_@@ Re@@ actor ( new ACE_@@ Dev@@ _@@ Po@@ ll@@ _@@ Re@@ actor ( ACE :: max@@ _h@@ and@@ les ( ) , 1 ) , 1 ) , true ) ; # else ACE_@@ Re@@ actor :: instance ( new ACE_@@ Re@@ actor ( new ACE_@@ T@@ P_@@ Re@@ actor ( ) , true ) , true ) ; # endif s@@ Log -> out@@ Debug ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Max ▁ allowed ▁ open ▁ files ▁ is ▁ % d " , ACE :: max@@ _h@@ and@@ les ( ) ) ; std :: string p@@ id@@ file = Config@@ Mgr :: GetString@@ Default ( " P@@ id@@ File " , " " ) ; if ( ! p@@ id@@ file . empty ( ) ) { uint32 pid = Create@@ P@@ ID@@ File ( p@@ id@@ file ) ; if ( ! pid ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Cannot ▁ create ▁ PID ▁ file ▁ % s . \n " , p@@ id@@ file . c_str ( ) ) ; return 1 ; } s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " D@@ a@@ e@@ mon ▁ PID : ▁ % u \n " , pid ) ; } if ( ! Start@@ DB ( ) ) return 1 ; s@@ Log -> Set@@ Real@@ m@@ ID ( 0 ) ; sRe@@ al@@ m@@ List -> Initialize ( Config@@ Mgr :: GetInt@@ Default ( " Real@@ ms@@ State@@ Update@@ Delay " , 20 ) ) ; if ( sRe@@ al@@ m@@ List -> size ( ) == 0 ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " No ▁ valid ▁ real@@ ms ▁ specified . " ) ; return 1 ; } Real@@ m@@ Accept@@ or accept@@ or ; int32 r@@ mp@@ ort = Config@@ Mgr :: GetInt@@ Default ( " Real@@ m@@ Ser@@ ver@@ Port " , 37@@ 24 ) ; if ( r@@ mp@@ ort < 0 || r@@ mp@@ ort > 0xFFFF ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Specified ▁ port ▁ out ▁ of ▁ allowed ▁ range ▁ ( 1@@ -6@@ 5535 ) " ) ; return 1 ; } std :: string bind@@ _@@ ip = Config@@ Mgr :: GetString@@ Default ( " Bind@@ IP " , "@@ 0.@@ 0.@@ 0.0" ) ; ACE_@@ INE@@ T_@@ Addr bind@@ _addr ( uint16 ( r@@ mp@@ ort ) , bind@@ _@@ ip . c_str ( ) ) ; if ( accept@@ or . open ( bind@@ _addr , ACE_@@ Re@@ actor :: instance ( ) , ACE_@@ NON@@ BLOCK ) == - 1 ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Auth ▁ server ▁ can ▁ not ▁ bind ▁ to ▁ % s : % d " , bind@@ _@@ ip . c_str ( ) , r@@ mp@@ ort ) ; return 1 ; } Auth@@ Ser@@ ver@@ Signal@@ Handler Signal@@ INT , Signal@@ TER@@ M ; ACE_@@ S@@ ig_@@ Handler Handler ; Handler . register@@ _h@@ and@@ ler ( SIG@@ INT , & Signal@@ INT ) ; Handler . register@@ _h@@ and@@ ler ( SIG@@ TER@@ M , & Signal@@ TER@@ M ) ; # ifdef _WIN32 { HANDLE h@@ Process = GetCurrentProcess ( ) ; uint32 Aff = Config@@ Mgr :: GetInt@@ Default ( " Use@@ Processors " , 0 ) ; if ( Aff > 0 ) { UL@@ ON@@ G_@@ PTR app@@ Aff ; UL@@ ON@@ G_@@ PTR sys@@ Aff ; if ( GetProcess@@ Aff@@ init@@ y@@ Mask ( h@@ Process , & app@@ Aff , & sys@@ Aff ) ) { UL@@ ON@@ G_@@ PTR cur@@ Aff = Aff & app@@ Aff ; if ( ! cur@@ Aff ) s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Processors ▁ marked ▁ in ▁ Use@@ Processors ▁ bit@@ mask ▁ ( hex ) ▁ % x ▁ not ▁ ac@@ ces@@ si@@ ble ▁ for ▁ auth@@ server . ▁ Ac@@ ces@@ si@@ ble ▁ process@@ ors ▁ bit@@ mask ▁ ( hex ) : ▁ % x " , Aff , app@@ Aff ) ; else if ( Set@@ Process@@ Aff@@ init@@ y@@ Mask ( h@@ Process , cur@@ Aff ) ) s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " U@@ sing ▁ process@@ ors ▁ ( bit@@ mask , ▁ hex ) : ▁ % x " , cur@@ Aff ) ; else s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Can ' t ▁ set ▁ used ▁ process@@ ors ▁ ( hex ) : ▁ % x " , cur@@ Aff ) ; } } bool Pri@@ o = Config@@ Mgr :: GetBo@@ ol@@ Default ( " Process@@ Pri@@ ority " , false ) ; if ( Pri@@ o ) { if ( Set@@ Pri@@ or@@ ity@@ Class ( h@@ Process , HIG@@ H_@@ PRI@@ OR@@ ITY_@@ CLASS ) ) s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " The ▁ aut@@ h ▁ server ▁ process ▁ priority ▁ class ▁ has ▁ been ▁ set ▁ to ▁ HIGH " ) ; else s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Can ' t ▁ set ▁ aut@@ h ▁ server ▁ process ▁ priority ▁ class . " ) ; } } # endif uint32 num@@ Loop@@ s = ( Config@@ Mgr :: GetInt@@ Default ( " Max@@ P@@ ing@@ Time " , 30 ) * ( MINUTE * 1000000 / 100000 ) ) ; uint32 loop@@ Counter = 0 ; while ( ! stop@@ Event ) { ACE_@@ Tim@@ e_@@ Value interval ( 0 , 100000 ) ; if ( ACE_@@ Re@@ actor :: instance ( ) -> run@@ _@@ rea@@ ct@@ or_@@ ev@@ ent_@@ loop ( interval ) == - 1 ) break ; if ( ( ++ loop@@ Counter ) == num@@ Loop@@ s ) { loop@@ Counter = 0 ; s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " P@@ ing ▁ My@@ SQ@@ L ▁ to ▁ keep ▁ connection ▁ alive " ) ; LoginDatabase . Keep@@ Alive ( ) ; } } Stop@@ DB ( ) ; s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Hal@@ ting ▁ process . . . " ) ; return 0 ; } bool Start@@ DB ( ) { My@@ SQ@@ L :: Lib@@ r@@ ar@@ y_@@ Init ( ) ; std :: string db@@ string = Config@@ Mgr :: GetString@@ Default ( " Log@@ in@@ Database@@ Info " , " " ) ; if ( db@@ string . empty ( ) ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Database ▁ not ▁ specified " ) ; return false ; } int32 work@@ er_@@ threads = Config@@ Mgr :: GetInt@@ Default ( " LoginDatabase . Wor@@ ker@@ Threads " , 1 ) ; if ( work@@ er_@@ threads < 1 || work@@ er_@@ threads > 32 ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Imp@@ ro@@ per ▁ value ▁ specified ▁ for ▁ LoginDatabase . Wor@@ ker@@ Threads , ▁ default@@ ing ▁ to ▁ 1 . " ) ; work@@ er_@@ threads = 1 ; } int32 syn@@ ch@@ _@@ threads = Config@@ Mgr :: GetInt@@ Default ( " LoginDatabase . Syn@@ ch@@ Threads " , 1 ) ; if ( syn@@ ch@@ _@@ threads < 1 || syn@@ ch@@ _@@ threads > 32 ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Imp@@ ro@@ per ▁ value ▁ specified ▁ for ▁ LoginDatabase . Syn@@ ch@@ Threads , ▁ default@@ ing ▁ to ▁ 1 . " ) ; syn@@ ch@@ _@@ threads = 1 ; } if ( ! LoginDatabase . Open ( db@@ string . c_str ( ) , uint8 ( work@@ er_@@ threads ) , uint8 ( syn@@ ch@@ _@@ threads ) ) ) { s@@ Log -> out@@ Error ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Cannot ▁ connect ▁ to ▁ database " ) ; return false ; } s@@ Log -> out@@ Info ( LOG_@@ FIL@@ TER_@@ A@@ UTH@@ S@@ ER@@ VER , " Started ▁ aut@@ h ▁ database ▁ connection ▁ pool . " ) ; s@@ Log -> Enable@@ DB@@ App@@ end@@ ers ( ) ; return true ; } void Stop@@ DB ( ) { LoginDatabase . Close ( ) ; My@@ SQ@@ L :: Lib@@ r@@ ar@@ y_@@ End ( ) ; } </DOCUMENT>
