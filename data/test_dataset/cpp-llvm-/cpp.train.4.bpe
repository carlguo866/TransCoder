<DOCUMENT_ID="d@@ klan@@ n/rivendell@@ /tree/master/lib/@@ rdlist_log@@ s.cpp"> # include " rdapplication . h " # include " rddb . h " # include " rdesc@@ ape _ string . h " # include " rdlist _ logs . h " RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; setMinimum@@ Size ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; list_log_list = new Q3ListView ( this ) ; list_log_list -> setAll@@ ColumnsShow@@ Focus ( true ) ; list_log_list -> setItem@@ Margin ( 5 ) ; list_log_list -> setSelection@@ Mode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( double@@ Clicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; } QSize RDListLogs :: sizeHint ( ) const { return QSize ( 500 , 300 ) ; } QSizePolicy RDListLogs :: sizePolicy ( ) const { return QSizePolicy ( QSizePolicy :: Fixed , QSizePolicy :: Fixed ) ; } void RDListLogs :: close@@ Event ( QClose@@ Event * e ) { done ( 1 ) ; } void RDListLogs :: filterChangedData ( const QString & where_@@ sql ) { RefreshList ( ) ; } void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; } void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; } void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; } void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; } void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIPTION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y\ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000-00-00\ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000-00-00\ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> where@@ Sql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItem@@ Visible ( view_item ) ; } } </DOCUMENT>
<DOCUMENT_ID="ric@@ ardog@@ sil@@ va/@@ QGIS@@ /tree/master/src/core/@@ qgsproxyprogresst@@ ask.cpp"> # include " qgsproxyprogresst@@ ask . h " QgsProxyProgressTask :: QgsProxyProgressTask ( const QString & description ) : QgsTask ( description , QgsTask :: Flags ( ) ) { } void QgsProxyProgressTask :: finalize ( bool result ) { mResult = result ; mNotFinishedWaitCondition . wakeAll ( ) ; } bool QgsProxyProgressTask :: run ( ) { mNotFinishedMutex . lock ( ) ; mNotFinishedWaitCondition . wait ( & mNotFinishedMutex ) ; mNotFinishedMutex . unlock ( ) ; return mResult ; } void QgsProxyProgressTask :: setProxyProgress ( double progress ) { QMeta@@ Object :: invokeMethod ( this , " setProgress " , Qt :: AutoConnection , Q_ARG ( double , progress ) ) ; } QgsScopedProxyProgressTask :: QgsScopedProxyProgressTask ( const QString & description ) : mTask ( new QgsProxyProgressTask ( description ) ) { QgsApplication :: task@@ Manager ( ) -> addTask ( mTask ) ; } QgsScopedProxyProgressTask :: ~ QgsScopedProxyProgressTask ( ) { mTask -> finalize ( true ) ; } void QgsScopedProxyProgressTask :: setProgress ( double progress ) { mTask -> setProxyProgress ( progress ) ; } </DOCUMENT>
<DOCUMENT_ID="j@@ brain@@ s/triv@@ ia/tree/master/C++/@@ GameRun@@ ner.cpp"> # include < stdlib . h > # include " Game . h " static bool notAWinner ; int main ( ) { Game aGame ; aGame . add ( " Chet " ) ; aGame . add ( " Pat " ) ; aGame . add ( " Sue " ) ; do { aGame . roll ( rand ( ) % 5 + 1 ) ; if ( rand ( ) % 9 == 7 ) { notAWinner = aGame . wron@@ gAns@@ wer ( ) ; } else { notAWinner = aGame . wasCor@@ rectlyAns@@ wered ( ) ; } } while ( notAWinner ) ; } </DOCUMENT>
<DOCUMENT_ID="llvm-@@ mirror@@ /cla@@ ng/tree/master/unit@@ tests/@@ Frontend@@ /CodeGen@@ ActionTest.cpp"> # include " clang / CodeGen / CodeGenAction . h " # include " clang / Basic / Lang@@ Standard . h " # include " clang / CodeGen / BackendUtil . h " # include " clang / Frontend / CompilerInstance . h " # include " clang / Lex / Preprocessor@@ Options . h " # include " gtest / gtest . h " using namespace llvm ; using namespace clang ; using namespace clang :: frontend ; namespace { class NullCodeGenAction : public CodeGenAction { public : NullCodeGenAction ( llvm :: LLVMContext * _VMContext = nullptr ) : CodeGenAction ( Backend_@@ EmitMC@@ Null , _VMContext ) { } void ExecuteAction ( ) override { CompilerInstance & CI = getCompilerInstance ( ) ; if ( ! CI . hasPre@@ processor ( ) ) return ; if ( ! CI . hasSema ( ) ) CI . createSema ( getTranslation@@ UnitKind ( ) , nullptr ) ; } } ; TEST ( CodeGenTest , TestNull@@ CodeGen ) { auto Invocation = std :: make_shared < Compiler@@ Invocation > ( ) ; Invocation -> getPreprocessor@@ Opts ( ) . addRe@@ mappedFile ( " test . cc " , MemoryBuffer :: getMem@@ Buffer ( " " ) . release ( ) ) ; Invocation -> getFrontendOpts ( ) . Inputs . push_back ( Frontend@@ InputFile ( " test . cc " , Language :: CXX ) ) ; Invocation -> getFrontendOpts ( ) . ProgramAction = EmitLLVM ; Invocation -> getTarget@@ Opts ( ) . Triple = " i38@@ 6 - unknown - linux - gnu " ; CompilerInstance Compiler ; Compiler . setInvocation ( std :: move ( Invocation ) ) ; Compiler . createDiagnostics ( ) ; EXPECT_TRUE ( Compiler . hasDiagnostics ( ) ) ; std :: unique_ptr < Frontend@@ Action > Act ( new NullCodeGenAction ) ; bool Success = Compiler . ExecuteAction ( * Act ) ; EXPECT_TRUE ( Success ) ; } } </DOCUMENT>
<DOCUMENT_ID="way@@ finder/@@ Way@@ finder-@@ S60@@ -Navig@@ ator/tree/master/@@ CPP/Shared/@@ GuiProt/GeneralParam@@ Receiver.cpp"> # include " arch . h " # include " GuiProt / GuiParameter@@ Enums . h " # include " GuiProt / GuiProtEnums . h " # include " GuiProt / GuiProtMess . h " # include " GuiProt / GeneralParamReceiver . h " # include " GuiProt / GuiProtMessageHandler . h " # include " GenericSetting@@ sData . h " namespace isab { GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; } bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; } bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_auto@@ Reroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBack@@ lightStrategy : { m_settingsData -> m_back@@ lightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_auto@@ Tracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistance@@ Mode : { m_settingsData -> m_distance@@ Mode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavorite@@ Show : { m_settingsData -> m_favorite@@ ShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_route@@ Highways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_route@@ TollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTime@@ Dist : { m_settingsData -> m_route@@ CostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrack@@ ingLevel : { m_settingsData -> m_track@@ ingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrans@@ portationType : { m_settingsData -> m_trans@@ portationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurnSoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTra@@ fficUpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_traffic@@ UpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOld@@ UpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_traffic@@ Update = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOld@@ Update = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomaticRouteOnSMSDest : { m_settingsData -> m_auto@@ RouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeep@@ SMSDestInInbox : { m_settingsData -> m_keep@@ SMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStore@@ SMSDestIn@@ MyDest : { m_settingsData -> m_store@@ SMSDest@@ InFavor@@ ites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPosition@@ Symbol : { m_settingsData -> m_posit@@ ionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheck@@ ForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; } bool GeneralParamReceiver :: GuiProtReceive@@ Message ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramType@@ Int32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getInteger@@ Data ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramType@@ Float : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloat@@ Data ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramType@@ Bin@@ ary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinary@@ Data ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramType@@ String : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramType@@ Invalid : return false ; break ; } } return false ; } } </DOCUMENT>
<DOCUMENT_ID="k@@ youngch@@ inse@@ o/aws-sdk-cpp/tree/master/aws-cpp-sdk-@@ s3@@ /source/model/@@ Delete.cpp"> # include < aws / s3 / model / Delete . h > # include < aws / core / utils / xml / XmlSerializer . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > # include < utility > using namespace Aws :: S3 :: Model ; using namespace Aws :: Utils :: Xml ; using namespace Aws :: Utils ; Delete :: Delete ( ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { } Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; } Delete & Delete :: operator = ( const XmlNode & xmlNode ) { XmlNode resultNode = xmlNode ; if ( ! resultNode . IsNull ( ) ) { XmlNode objectsNode = resultNode . FirstChild ( " Objects " ) ; if ( ! objectsNode . IsNull ( ) ) { XmlNode objectsMember = objectsNode ; while ( ! objectsMember . IsNull ( ) ) { m_objects . push_back ( objectsMember ) ; objectsMember = objectsMember . NextNode ( " Object " ) ; } m_objectsHasBeenSet = true ; } XmlNode quietNode = resultNode . FirstChild ( " Quiet " ) ; if ( quietNode . IsNull ( ) ) { quietNode = resultNode ; } if ( ! quietNode . IsNull ( ) ) { m_quiet = StringUtils :: ConvertTo@@ Bool ( StringUtils :: Trim ( quietNode . GetText ( ) . c_str ( ) ) . c_str ( ) ) ; m_quietHasBeenSet = true ; } } return * this ; } void Delete :: AddToNode ( XmlNode & parentNode ) const { Aws :: StringStream ss ; if ( m_objectsHasBeenSet ) { for ( const auto & item : m_objects ) { XmlNode objectsNode = parentNode . CreateChildElement ( " Object " ) ; item . AddToNode ( objectsNode ) ; } } if ( m_quietHasBeenSet ) { XmlNode quietNode = parentNode . CreateChildElement ( " Object " ) ; ss << m_quiet ; quietNode . SetText ( ss . str ( ) ) ; ss . str ( " " ) ; } } </DOCUMENT>
<DOCUMENT_ID="as@@ maurya@@ 95@@ /My@@ -AC@@ M-@@ ICPC@@ -Hand@@ book/tree/master/Su@@ ffix Array/Na@@ ive Implementation.cpp"> # include < iostream > # include < string > # include < map > # include < algorithm > # include < vector > using namespace std ; int main ( ) { string s ; cin >> s ; map < string , int > m ; vector < string > ar ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string sstr = s . substr ( i , s . size ( ) - i ) ; m [ sstr ] = i ; ar . push_back ( sstr ) ; } sort ( ar . begin ( ) , ar . end ( ) ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { cout << m [ ar [ i ] ] << endl ; } return 0 ; } </DOCUMENT>
<DOCUMENT_ID="da@@ edalu@@ s/iodoom@@ 3/tree/master/neo/tools/materialeditor/@@ MaterialDocManager.cpp"> # include " . . / . . / idlib / precompiled . h " # pragma hdrstop # include " MaterialDocManager . h " # include " MaterialView . h " MaterialDocManager :: MaterialDocManager ( void ) { currentMaterial = NULL ; cutMaterial = false ; } MaterialDocManager :: ~ MaterialDocManager ( void ) { UnRegisterAllMaterialViews ( ) ; ClearUndo ( ) ; ClearRedo ( ) ; } void MaterialDocManager :: RegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; UnRegisterMaterialView ( view ) ; materialViews . Append ( view ) ; view -> SetMaterialDocManager ( this ) ; } void MaterialDocManager :: UnRegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; materialViews . Remove ( view ) ; view -> SetMaterialDocManager ( NULL ) ; } void MaterialDocManager :: UnRegisterAllMaterialViews ( ) { int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { materialViews [ i ] -> SetMaterialDocManager ( NULL ) ; } materialViews . Clear ( ) ; } void MaterialDocManager :: SetSelected@@ Material ( idMaterial * material ) { bool change = false ; if ( material ) { if ( currentMaterial ) { if ( strcmp ( material -> GetName ( ) , currentMaterial -> renderMaterial -> GetName ( ) ) ) { change = true ; } } else { change = true ; } } else { if ( currentMaterial ) { change = true ; } } if ( change ) { if ( currentMaterial ) { if ( ! inProgressMaterials . Get ( currentMaterial -> name . c_str ( ) ) ) { delete currentMaterial ; currentMaterial = NULL ; } } MaterialDoc * * tempDoc ; if ( material && inProgressMaterials . Get ( material -> GetName ( ) , & tempDoc ) ) { currentMaterial = * tempDoc ; } else { currentMaterial = CreateMaterialDoc ( material ) ; } NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } } bool MaterialDocManager :: Does@@ FileNeedApply ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) && ( * pDoc ) -> applyWaiting ) return true ; } return false ; } bool MaterialDocManager :: Does@@ AnyNeedApply ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ( * pDoc ) -> applyWaiting ) return true ; } return false ; } bool MaterialDocManager :: IsFile@@ Modified ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) return true ; } return false ; } bool MaterialDocManager :: IsAny@@ Modified ( ) { return ( inProgressMaterials . Num ( ) > 0 ) ; } void MaterialDocManager :: AddMaterial ( const char * name , const char * filename , const char * sourceText , bool addUndo ) { if ( addUndo ) { AddMaterialModifier * mod = new AddMaterialModifier ( this , name , filename ) ; AddMaterialUndoModifier ( mod ) ; } MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = ( idMaterial * ) declManager -> CreateNew@@ Decl ( DECL_MATERIAL , name , filename ) ; if ( sourceText ) { rendMat -> SetText ( sourceText ) ; } newDoc -> SetRenderMaterial ( rendMat , true , sourceText ? true : false ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } void MaterialDocManager :: Redo@@ AddMaterial ( const char * name , bool clearData ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = const_cast < idMaterial * > ( declManager -> FindMaterial ( name , false ) ) ; if ( clearData ) { rendMat -> SetText ( rendMat -> DefaultDefinition ( ) ) ; } newDoc -> SetRenderMaterial ( rendMat , true , true ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; } void MaterialDocManager :: DeleteMaterial ( MaterialDoc * material , bool addUndo ) { assert ( material ) ; material -> Delete ( ) ; if ( addUndo ) { DeleteMaterialModifier * mod = new DeleteMaterialModifier ( this , material -> name ) ; AddMaterialUndoModifier ( mod ) ; } NotifyViews ( material , MATERIAL_DELETE ) ; } void MaterialDocManager :: ApplyMaterial ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; materialDoc -> ApplyMaterialChanges ( ) ; } void MaterialDocManager :: ApplyFile ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } void MaterialDocManager :: ApplyAll ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> ApplyMaterialChanges ( ) ; } } void MaterialDocManager :: SaveMaterial ( MaterialDoc * material ) { assert ( material ) ; material -> Save ( ) ; } void MaterialDocManager :: SaveFile ( const char * filename ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Save ( ) ; } NotifyViews ( NULL , MATERIAL_SAVE_FILE , filename ) ; } void MaterialDocManager :: SaveAllMaterials ( ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> Save ( ) ; } } void MaterialDocManager :: ReloadFile ( const char * filename ) { declManager -> ReloadFile ( filename , true ) ; for ( int j = inProgressMaterials . Num ( ) - 1 ; j >= 0 ; j -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( j ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) { ( * pDoc ) -> SetRenderMaterial ( ( * pDoc ) -> renderMaterial ) ; inProgressMaterials . Remove ( ( * pDoc ) -> name ) ; } } if ( currentMaterial ) { currentMaterial -> SetRenderMaterial ( currentMaterial -> renderMaterial ) ; NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } NotifyViews ( NULL , FILE_RELOAD , filename ) ; } MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( const char * materialName ) { const idMaterial * material = declManager -> FindMaterial ( materialName ) ; return CreateMaterialDoc ( const_cast < idMaterial * > ( material ) ) ; } MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( idMaterial * material ) { MaterialDoc * existingDoc = GetInProgressDoc ( material ) ; if ( existingDoc ) { return existingDoc ; } if ( currentMaterial && material && ! currentMaterial -> name . Icmp ( material -> GetName ( ) ) ) { return currentMaterial ; } if ( material ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> SetRenderMaterial ( material ) ; return newDoc ; } return NULL ; } MaterialDoc * MaterialDocManager :: GetInProgressDoc ( idMaterial * material ) { if ( material ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! ( * pDoc ) -> name . Icmp ( material -> GetName ( ) ) ) return * pDoc ; } } return NULL ; } void MaterialDocManager :: CopyMaterial ( MaterialDoc * materialDoc , bool cut ) { cutMaterial = cut ; if ( materialDoc ) copyMaterial = materialDoc -> name ; else ClearCopy ( ) ; } void MaterialDocManager :: ClearCopy ( ) { copyMaterial . Empty ( ) ; } bool MaterialDocManager :: IsCopyMaterial ( ) { return ( copyMaterial . Length ( ) ) ? true : false ; } idStr MaterialDocManager :: GetCopy@@ MaterialName ( ) { return copyMaterial ; } void MaterialDocManager :: Paste@@ Material ( const char * name , const char * filename ) { if ( ! IsCopyMaterial ( ) ) { return ; } MaterialDoc * copyMat = CreateMaterialDoc ( copyMaterial ) ; if ( copyMat -> applyWaiting ) { copyMat -> ApplyMaterialChanges ( ) ; } idMaterial * material = copyMat -> renderMaterial ; char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; AddMaterial ( name , filename , declText , ! cutMaterial ) ; if ( cutMaterial ) { MaterialDoc * cutMaterial = CreateMaterialDoc ( material ) ; DeleteMaterial ( cutMaterial , false ) ; MoveMaterialModifier * mod = new MoveMaterialModifier ( this , name , filename , copyMaterial ) ; AddMaterialUndoModifier ( mod ) ; ClearCopy ( ) ; } } void MaterialDocManager :: CopyStage ( MaterialDoc * materialDoc , int stageNum ) { assert ( materialDoc ) ; copyStageMaterial = materialDoc -> name ; copyStage = materialDoc -> GetStage ( stageNum ) ; idStr stageName = copyStage . stageData . GetString ( " name " ) ; } void MaterialDocManager :: ClearCopyStage ( ) { copyStageMaterial . Empty ( ) ; copyStage . stageData . Clear ( ) ; } bool MaterialDocManager :: IsCopyStage ( ) { return ( copyStageMaterial . Length ( ) ) ? true : false ; } void MaterialDocManager :: Paste@@ Stage ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; int stageType = copyStage . stageData . GetInt ( " stagetype " ) ; materialDoc -> AddStage ( stageType , copyStage . stageData . GetString ( " name " ) ) ; materialDoc -> SetData ( materialDoc -> GetStage@@ Count ( ) - 1 , & copyStage . stageData ) ; } void MaterialDocManager :: GetCopy@@ StageInfo ( int & type , idStr & name ) { if ( IsCopyStage ( ) ) { type = copyStage . stageData . GetInt ( " stagetype " ) ; name = copyStage . stageData . GetString ( " name " ) ; } } void MaterialDocManager :: Undo ( ) { if ( IsUndoAvailable ( ) ) { MaterialModifier * mod = undoModifiers [ undoModifiers . Num ( ) - 1 ] ; undoModifiers . RemoveIndex ( undoModifiers . Num ( ) - 1 ) ; mod -> Undo ( ) ; AddMaterialRedoModifier ( mod ) ; } } bool MaterialDocManager :: IsUndoAvailable ( ) { return ( undoModifiers . Num ( ) > 0 ) ; } void MaterialDocManager :: ClearUndo ( ) { int c = undoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete undoModifiers [ i ] ; } undoModifiers . Clear ( ) ; } void MaterialDocManager :: Redo ( ) { if ( IsRedoAvailable ( ) ) { MaterialModifier * mod = redoModifiers [ redoModifiers . Num ( ) - 1 ] ; redoModifiers . RemoveIndex ( redoModifiers . Num ( ) - 1 ) ; mod -> Redo ( ) ; AddMaterialUndoModifier ( mod , false ) ; } } bool MaterialDocManager :: IsRedoAvailable ( ) { return ( redoModifiers . Num ( ) > 0 ) ; } void MaterialDocManager :: ClearRedo ( ) { int c = redoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete redoModifiers [ i ] ; } redoModifiers . Clear ( ) ; } void MaterialDocManager :: AddMaterialUndoModifier ( MaterialModifier * mod , bool clearRedo ) { undoModifiers . Append ( mod ) ; while ( undoModifiers . Num ( ) > MAX_UNDOREDO ) { undoModifiers . RemoveIndex ( 0 ) ; } if ( clearRedo ) { ClearRedo ( ) ; } } void MaterialDocManager :: AddMaterialRedoModifier ( MaterialModifier * mod ) { redoModifiers . Append ( mod ) ; while ( redoModifiers . Num ( ) > MAX_UNDOREDO ) { redoModifiers . RemoveIndex ( 0 ) ; } } bool MaterialDocManager :: FindMaterial ( const char * name , MaterialSearch@@ Data_t * searchData , bool checkName ) { const idMaterial * material = static_cast < const idMaterial * > ( declManager -> FindDecl@@ Without@@ Parsing ( DECL_MATERIAL , name , false ) ) ; if ( material ) { int findPos ; if ( checkName ) { idStr name = material -> GetName ( ) ; findPos = name . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; idStr text = declText ; int start = text . Find ( " { " ) ; if ( start != - 1 ) { text = text . Right ( text . Length ( ) - start ) ; } findPos = text . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } return false ; } idStr MaterialDocManager :: GetUnique@@ MaterialName ( idStr name ) { int num = 0 ; while ( 1 ) { idStr testName ; if ( num == 0 ) testName = name ; else testName = va ( " % s % d " , name . c_str ( ) , num ) ; const idMaterial * mat = declManager -> FindMaterial ( testName . c_str ( ) , false ) ; if ( ! mat ) { return testName ; } else { if ( mat -> GetTextLength ( ) < 1 ) return testName ; } num ++ ; } } void MaterialDocManager :: NotifyViews ( MaterialDoc * materialDoc , int notifyType , ... ) { va_list argptr ; int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { va_start ( argptr , notifyType ) ; switch ( notifyType ) { case SELECTION_CHANGE : materialViews [ i ] -> MV_OnMaterialSelectionChange ( materialDoc ) ; break ; case MATERIAL_CHANGE : materialViews [ i ] -> MV_OnMaterialChange ( materialDoc ) ; break ; case MATERIAL_APPLY : materialViews [ i ] -> MV_OnMaterialApply ( materialDoc ) ; break ; case MATERIAL_SAVE : materialViews [ i ] -> MV_OnMaterialSaved ( materialDoc ) ; break ; case MATERIAL_SAVE_FILE : materialViews [ i ] -> MV_OnMaterialSaveFile ( va_arg ( argptr , const char * ) ) ; break ; case MATERIAL_ADD : materialViews [ i ] -> MV_OnMaterialAdd ( materialDoc ) ; break ; case MATERIAL_DELETE : materialViews [ i ] -> MV_OnMaterialDelete ( materialDoc ) ; break ; case MATERIAL_ADD_STAGE : materialViews [ i ] -> MV_OnMaterialStage@@ Add ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_DELETE_STAGE : materialViews [ i ] -> MV_OnMaterialStage@@ Delete ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_MOVE_STAGE : { int from = va_arg ( argptr , int ) ; int to = va_arg ( argptr , int ) ; materialViews [ i ] -> MV_OnMaterialStage@@ Move ( materialDoc , from , to ) ; } break ; case MATERIAL_ATTRIBUTE_CHANGE : { int stage = va_arg ( argptr , int ) ; const char * attribName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialAttributeChanged ( materialDoc , stage , attribName ) ; } break ; case MATERIAL_NAME_CHANGE : { const char * oldName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialNameChanged ( materialDoc , oldName ) ; } break ; case FILE_RELOAD : { const char * filename = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnFileReload ( filename ) ; } break ; } va_end ( argptr ) ; } } void MaterialDocManager :: MaterialChanged ( MaterialDoc * materialDoc ) { if ( ! inProgressMaterials . Get ( materialDoc -> name . c_str ( ) ) ) { inProgressMaterials . Set ( materialDoc -> name . c_str ( ) , materialDoc ) ; } NotifyViews ( materialDoc , MATERIAL_CHANGE ) ; } void MaterialDocManager :: MaterialApplied ( MaterialDoc * materialDoc ) { NotifyViews ( materialDoc , MATERIAL_APPLY ) ; } void MaterialDocManager :: MaterialSaved ( MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( materialDoc -> name . c_str ( ) , & tempDoc ) ) { idStr name = materialDoc -> name . c_str ( ) ; inProgressMaterials . Remove ( name . c_str ( ) ) ; NotifyViews ( materialDoc , MATERIAL_SAVE ) ; if ( materialDoc != currentMaterial ) delete materialDoc ; } } void MaterialDocManager :: MaterialNameChanged ( const char * oldName , MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( oldName , & tempDoc ) ) { inProgressMaterials . Set ( materialDoc -> name , * tempDoc ) ; inProgressMaterials . Remove ( oldName ) ; } NotifyViews ( materialDoc , MATERIAL_NAME_CHANGE , oldName ) ; } void MaterialDocManager :: StageAdded ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_ADD_STAGE , stageNum ) ; } void MaterialDocManager :: StageDeleted ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_DELETE_STAGE , stageNum ) ; } void MaterialDocManager :: StageMoved ( MaterialDoc * materialDoc , int from , int to ) { NotifyViews ( materialDoc , MATERIAL_MOVE_STAGE , from , to ) ; } void MaterialDocManager :: AttributeChanged ( MaterialDoc * materialDoc , int stage , const char * attribName ) { NotifyViews ( materialDoc , MATERIAL_ATTRIBUTE_CHANGE , stage , attribName ) ; } </DOCUMENT>
<DOCUMENT_ID="wa@@ kash@@ ige/TrinityCore/tree/master/src/server/@@ scripts/EasternKingdoms/@@ zone_arathi_high@@ lands.cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " ScriptedEs@@ cortAI . h " # include " Player . h " enum Profes@@ sorPh@@ izzlethorpe { SAY_PROGRESS_1 = 0 , SAY_PROGRESS_2 = 1 , SAY_PROGRESS_3 = 2 , EMOTE_PROGRESS_4 = 3 , SAY_AGGRO = 4 , SAY_PROGRESS_5 = 5 , SAY_PROGRESS_6 = 6 , SAY_PROGRESS_7 = 7 , EMOTE_PROGRESS_8 = 8 , SAY_PROGRESS_9 = 9 , EVENT_SAY_3 = 1 , EVENT_SAY_6 = 2 , EVENT_SAY_8 = 3 , QUEST_SUNKEN_TREASURE = 665 , QUEST_GOGGLE_BOGGLE = 26050 , NPC_VENGEFUL_SURGE = 2776 , FACTION_SUNKEN_TREASURE = 113 } ; class npc_professor_phizzlethorpe : public CreatureScript { public : npc_professor_phizzlethorpe ( ) : CreatureScript ( " npc _ professor _ phizzlethorpe " ) { } struct npc_professor_phizzlethorpeAI : public npc_escortAI { npc_professor_phizzlethorpeAI ( Creature * creature ) : npc_escortAI ( creature ) { } void Waypoint@@ Reach@@ ed ( uint32 waypointId ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; switch ( waypointId ) { case 6 : Talk ( SAY_PROGRESS_2 , player ) ; events . ScheduleEvent ( EVENT_SAY_3 , 3000 ) ; break ; case 8 : Talk ( EMOTE_PROGRESS_4 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2065@@ .50@@ 5f , - 2136.@@ 88f , 22.20@@ 362f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; me -> SummonCreature ( NPC_VENGEFUL_SURGE , - 2059@@ .249@@ f , - 2134@@ .88f , 21.5@@ 1582f , 1.0f , TEMPSUMMON_CORPSE_DESPAWN , 0 ) ; break ; case 11 : Talk ( SAY_PROGRESS_5 , player ) ; events . ScheduleEvent ( EVENT_SAY_6 , 11000 ) ; break ; case 17 : Talk ( SAY_PROGRESS_7 , player ) ; events . ScheduleEvent ( EVENT_SAY_8 , 6000 ) ; break ; } } void JustSummoned ( Creature * summoned ) override { summoned -> AI ( ) -> AttackStart ( me ) ; } void EnterCombat ( Unit * ) override { Talk ( SAY_AGGRO ) ; } void sQuest@@ Accept ( Player * player , Quest const * quest ) override { if ( quest -> GetQuest@@ Id ( ) == QUEST_SUNKEN_TREASURE ) { Talk ( SAY_PROGRESS_1 , player ) ; npc_escortAI :: Start ( false , false , player -> GetGUID ( ) , quest ) ; me -> setFaction ( FACTION_SUNKEN_TREASURE ) ; } } void UpdateAI ( uint32 diff ) override { Player * player = GetPlayerForEscort ( ) ; if ( ! player ) return ; events . Update ( diff ) ; while ( uint32 event = events . ExecuteEvent ( ) ) { switch ( event ) { case EVENT_SAY_3 : Talk ( SAY_PROGRESS_3 , player ) ; break ; case EVENT_SAY_6 : Talk ( SAY_PROGRESS_6 , player ) ; SetRun ( ) ; break ; case EVENT_SAY_8 : Talk ( EMOTE_PROGRESS_8 ) ; Talk ( SAY_PROGRESS_9 , player ) ; player -> GroupEventHappens ( QUEST_GOGGLE_BOGGLE , me ) ; break ; } } npc_escortAI :: UpdateAI ( diff ) ; } EventMap events ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_professor_phizzlethorpeAI ( creature ) ; } } ; void AddSC_@@ arathi_high@@ lands ( ) { new npc_professor_phizzlethorpe ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Singularity@@ Core/Singularity@@ /tree/master/dep/acelite/ace/@@ Log_Msg_@@ IPC.cpp"> # include " ace / Log _ Msg _ IPC . h " # include " ace / Log _ Record . h " # include " ace / CDR _ Stream . h " # include " ace / Trunc@@ ate . h " ACE_BEGIN_VERSIONED_NAMESPACE_DECL ACE_Log_Msg_IPC :: ACE_Log_Msg_IPC ( void ) { } ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; } int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_@@ CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_@@ ADDR ( logger_key ) ) ; } int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_@@ HANDLE ) { return this -> close ( ) ; } return 0 ; } int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; } ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { size_t const max_payload_size = 4 + 4 + 12 + 4 + 4 # if defined ( ACE_USES_@@ WCHAR ) + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_max@@ bytes ( ) ) # else + log_record . msg_data_len ( ) # endif + ACE_CDR :: MAX_ALIGNMENT ; ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CD@@ R_BY@@ TE_ORDER ) ) ) return - 1 ; if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; # if ( ACE_HAS@@ _STREAM_@@ LOG_MSG_@@ IPC == 1 ) ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAN@@ D ) ; # else return this -> message_queue_ . sendv_n ( iov , 2 ) ; # endif } ACE_END_VERSIONED_NAMESPACE_DECL </DOCUMENT>
<DOCUMENT_ID="D@@ ako@@ 300/Basic@@ TV@@ /tree/master/src/math@@ /number@@ s/math_@@ numbers.cpp"> # include " . . / . . / main . h " # include " . . / . . / util . h " # include " math _ numbers . h " # include " . . / math . h " # include " . . / . . / id / id _ api . h " # define MINOR_SPECIES_MULTIPLIER ( pow ( 2 , 64 ) - 1 ) static void number_sanity_fetch ( void * ptr , uint64_t start , uint64_t size , std :: vector < uint8_t > * data ) { if ( data -> size ( ) < start + size ) { print ( " can ' t ▁ copy , ▁ not ▁ enough ▁ room " , P_ERR ) ; } memcpy ( ptr , data -> data ( ) + start , size ) ; convert :: nbo :: from ( ( uint8_t * ) ptr , size ) ; } static std :: vector < uint8_t > number_sanity_fetch ( std :: vector < uint8_t > * data ) { std :: vector < uint8_t > retval ; if ( data -> size ( ) < 4 ) { print ( " not ▁ enough ▁ room ▁ to ▁ possibly ▁ encode ▁ major / minor ▁ size " , P_ERR ) ; } uint32_t size ; memcpy ( & size , data -> data ( ) , 4 ) ; size = NBO_32 ( size ) ; if ( data -> size ( ) < 4 + size ) { P_V ( size , P_WARN ) ; P_V ( data -> size ( ) , P_WARN ) ; print ( " invalid ▁ size ▁ for ▁ current ▁ number ▁ chunk " , P_ERR ) ; } retval = convert :: nbo :: from ( std :: vector < uint8_t > ( data -> begin ( ) + 4 , data -> begin ( ) + 4 + size ) ) ; data -> erase ( data -> begin ( ) , data -> begin ( ) + 4 + size ) ; return retval ; } uint64_t math :: number :: get :: unit ( std :: vector < uint8_t > data ) { uint64_t retval ; number_sanity_fetch ( & retval , 0 , sizeof ( retval ) , & data ) ; return retval ; } std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > math :: number :: get :: raw_species ( std :: vector < uint8_t > data ) { uint64_t start = sizeof ( math_number_unit_t ) ; if ( data . size ( ) < start ) { return std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > ( { } , { } ) ; } data . erase ( data . begin ( ) , data . begin ( ) + start ) ; std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > retval ; retval . first = number_sanity_fetch ( & data ) ; retval . second = number_sanity_fetch ( & data ) ; return retval ; } long double math :: number :: get :: number ( std :: vector < uint8_t > data ) { long double retval ; std :: pair < std :: vector < uint8_t > , std :: vector < uint8_t > > species = math :: number :: get :: raw_species ( data ) ; if ( species . first . size ( ) > 8 || species . second . size ( ) > 8 ) { print ( " I ▁ need ▁ to ▁ expand ▁ this ▁ beyon@@ d ▁ 64 - bits " , P_ERR ) ; } uint64_t major_int = 0 , minor_int = 0 ; memcpy ( & major_int , species . first . data ( ) , species . first . size ( ) ) ; memcpy ( & minor_int , species . second . data ( ) , species . second . size ( ) ) ; retval = ( long double ) ( major_int ) + ( long double ) ( ( long double ) ( minor_int / MINOR_SPECIES_MULTIPLIER ) ) ; return retval ; } # define NUMBER_CREATE_ADD ( x ) retval . insert ( retval . end ( ) , ( uint8_t * ) & x , ( uint8_t * ) & x + sizeof ( x ) ) std :: vector < uint8_t > math :: number :: create ( long double number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = ( ( uint64_t ) ( long double ) ( number ) ) ; uint32_t major_size = ( 8 ) ; uint64_t minor_int = ( ( ( ( long double ) number - ( long double ) major_int ) * ( long double ) MINOR_SPECIES_MULTIPLIER ) ) ; uint32_t minor_size = ( 8 ) ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( uint64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; uint64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( int64_t number , uint64_t unit ) { std :: vector < uint8_t > retval ; int64_t major_int = number ; uint32_t major_size = 8 ; uint64_t minor_int = 0 ; uint32_t minor_size = 0 ; unit = NBO_64 ( unit ) ; major_int = NBO_64 ( major_int ) ; major_size = NBO_32 ( major_size ) ; minor_int = NBO_64 ( minor_int ) ; minor_size = NBO_32 ( minor_size ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; NUMBER_CREATE_ADD ( major_int ) ; NUMBER_CREATE_ADD ( minor_size ) ; NUMBER_CREATE_ADD ( minor_int ) ; return retval ; } std :: vector < uint8_t > math :: number :: create ( std :: vector < uint8_t > raw_number_data_major , std :: vector < uint8_t > raw_number_data_minor , uint64_t unit ) { std :: vector < uint8_t > retval ; convert :: nbo :: to ( raw_number_data_major . data ( ) , raw_number_data_major . size ( ) ) ; convert :: nbo :: to ( raw_number_data_minor . data ( ) , raw_number_data_minor . size ( ) ) ; ASSERT ( raw_number_data_major . size ( ) <= UINT32_MAX , P_ERR ) ; ASSERT ( raw_number_data_minor . size ( ) <= UINT32_MAX , P_ERR ) ; uint32_t major_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_major . size ( ) ) ) ; uint32_t minor_size = NBO_32 ( static_cast < uint32_t > ( raw_number_data_minor . size ( ) ) ) ; NUMBER_CREATE_ADD ( unit ) ; NUMBER_CREATE_ADD ( major_size ) ; retval . insert ( retval . end ( ) , raw_number_data_major . begin ( ) , raw_number_data_major . end ( ) ) ; NUMBER_CREATE_ADD ( minor_size ) ; retval . insert ( retval . end ( ) , raw_number_data_minor . begin ( ) , raw_number_data_minor . end ( ) ) ; } void math :: number :: add_data_to_set ( std :: vector < std :: vector < uint8_t > > data , id_t@@ _ math_number_set_id ) { math_number_set_t * math_number_set_ptr = PTR@@ _DATA ( math_number_set_id , math_number_set_t ) ; if ( math_number_set_ptr == nullptr ) { print ( " math _ number _ set _ ptr ▁ is ▁ a ▁ nullptr " , P_ERR ) ; } math_number_set_ptr -> add_data ( data ) ; } </DOCUMENT>
<DOCUMENT_ID="f@@ ahhem@@ /m@@ bed@@ -os@@ /tree/master/target@@ s/TARGET_@@ NUVO@@ TON@@ /TARGET_@@ M45@@ 1/devic@@ e/@@ TOOLCHAIN@@ _ARM@@ _STD/@@ sys.cpp"> # ifdef __cplusplus extern " C " { # endif # include < rt_@@ misc . h > # include < stdint . h > extern char Image$$ARM_LIB@@ _STACK@@ $$ZI$$Limit [ ] ; extern char Image$$ARM_LIB_HEAP$$Base [ ] ; extern char Image$$ARM_LIB_HEAP$$ZI$$Limit [ ] ; extern __valu@@ e_in_re@@ gs struct __initial_stackheap __user_@@ setup_@@ stackheap ( uint32_t R0 , uint32_t R1 , uint32_t R2 , uint32_t R3 ) { struct __initial_stackheap r ; r . heap@@ _base = ( uint32_t ) Image$$ARM_LIB_HEAP$$Base ; r . heap_@@ limit = ( uint32_t ) Image$$ARM_LIB_HEAP$$ZI$$Limit ; return r ; } # ifdef __cplusplus } # endif </DOCUMENT>
<DOCUMENT_ID="th@@ ient@@ u/drake@@ /tree/master/util/@@ drakeGeometry@@ Util.cpp"> # include " drakeGeometry@@ Util . h " # include < iostream > # include < cmath > # include < limits > # include < stdexcept > # include < Eigen / Sparse > # include " expmap2quat . h " using namespace Eigen ; double angleDiff ( double phi1 , double phi2 ) { double d = phi2 - phi1 ; if ( d > 0.0 ) { d = fmod ( d + M_PI , 2 * M_PI ) - M_PI ; } else { d = fmod ( d - M_PI , 2 * M_PI ) + M_PI ; } return d ; } Vector4d quatConjugate ( const Eigen :: Vector4d & q ) { Vector4d q_conj ; q_conj << q ( 0 ) , - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; return q_conj ; } Eigen :: Matrix4d dquatConjugate ( ) { Matrix4d dq_conj = Matrix4d :: Identity ( ) ; dq_conj ( 1 , 1 ) = - 1.0 ; dq_conj ( 2 , 2 ) = - 1.0 ; dq_conj ( 3 , 3 ) = - 1.0 ; return dq_conj ; } Eigen :: Vector4d quatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Vector4d r ; r << w1 * w2 - v1 . dot ( v2 ) , v1 . cross ( v2 ) + w1 * v2 + w2 * v1 ; return r ; } Eigen :: Matrix < double , 4 , 8 > dquatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Matrix < double , 4 , 8 > dr ; dr . row ( 0 ) << w2 , - v2 . transpose ( ) , w1 , - v1 . transpose ( ) ; dr . row ( 1 ) << q2 ( 1 ) , q2 ( 0 ) , q2 ( 3 ) , - q2 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) , - q1 ( 3 ) , q1 ( 2 ) ; dr . row ( 2 ) << q2 ( 2 ) , - q2 ( 3 ) , q2 ( 0 ) , q2 ( 1 ) , q1 ( 2 ) , q1 ( 3 ) , q1 ( 0 ) , - q1 ( 1 ) ; dr . row ( 3 ) << q2 ( 3 ) , q2 ( 2 ) , - q2 ( 1 ) , q2 ( 0 ) , q1 ( 3 ) , - q1 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) ; return dr ; } Eigen :: Vector3d quatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Vector4d q_conj = quatConjugate ( q ) ; Vector4d v_rot = quatProduct ( q_times_v , q_conj ) ; Vector3d r = v_rot . bottomRows < 3 > ( ) ; return r ; } Eigen :: Matrix < double , 3 , 7 > dquatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Matrix < double , 4 , 7 > dq ; dq << Matrix4d :: Identity ( ) , MatrixXd :: Zero ( 4 , 3 ) ; Matrix < double , 4 , 7 > dv = Matrix < double , 4 , 7 > :: Zero ( ) ; dv . bottomRight@@ Corner < 3 , 3 > ( ) = Matrix3d :: Identity ( ) ; Matrix < double , 8 , 7 > dqdv ; dqdv << dq , dv ; Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Matrix < double , 4 , 8 > dq_times_v_tmp = dquatProduct ( q , v_quat ) ; Matrix < double , 4 , 7 > dq_times_v = dq_times_v_tmp * dqdv ; Matrix < double , 4 , 7 > dq_conj = dquatConjugate ( ) * dq ; Matrix < double , 8 , 7 > dq_times_v_dq_conj ; dq_times_v_dq_conj << dq_times_v , dq_conj ; Matrix < double , 4 , 8 > dv_rot_tmp = dquatProduct ( q_times_v , quatConjugate ( q ) ) ; Matrix < double , 4 , 7 > dv_rot = dv_rot_tmp * dq_times_v_dq_conj ; Eigen :: Matrix < double , 3 , 7 > dr = dv_rot . bottomRows ( 3 ) ; return dr ; } Eigen :: Vector4d quatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { return quatProduct ( quatConjugate ( q1 ) , q2 ) ; } Eigen :: Matrix < double , 4 , 8 > dquatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { auto dr = dquatProduct ( quatConjugate ( q1 ) , q2 ) ; dr . block < 4 , 3 > ( 0 , 1 ) = - dr . block < 4 , 3 > ( 0 , 1 ) ; return dr ; } double quatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; double e = - 2.0 + 2 * r ( 0 ) * r ( 0 ) + 2 * pow ( u ( 0 ) * r ( 1 ) + u ( 1 ) * r ( 2 ) + u ( 2 ) * r ( 3 ) , 2 ) ; return e ; } Eigen :: Matrix < double , 1 , 11 > dquatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; Matrix < double , 4 , 8 > dr = dquatDiff ( q1 , q2 ) ; Matrix < double , 1 , 11 > de ; const auto & rvec = r . tail < 3 > ( ) ; de << 4.0 * r ( 0 ) * dr . row ( 0 ) + 4.0 * u . transpose ( ) * rvec * u . transpose ( ) * dr . block < 3 , 8 > ( 1 , 0 ) , 4.0 * u . transpose ( ) * rvec * rvec . transpose ( ) ; return de ; } double quatNorm ( const Eigen :: Vector4d & q ) { return std :: acos ( q ( 0 ) ) ; } Eigen :: Vector4d slerp ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , double interpolation_parameter ) { double lambda = ( q1 . transpose ( ) * q2 ) . value ( ) ; int q2_sign ; if ( lambda < 0.0 ) { lambda = - lambda ; q2_sign = - 1 ; } else { q2_sign = 1 ; } double r , s ; if ( std :: abs ( 1.0 - lambda ) < std :: numeric_limits < double > :: epsilon ( ) ) { r = 1.0 - interpolation_parameter ; s = interpolation_parameter ; } else { double alpha = std :: acos ( lambda ) ; double gamma = 1.0 / std :: sin ( alpha ) ; r = std :: sin ( ( 1.0 - interpolation_parameter ) * alpha ) * gamma ; s = std :: sin ( interpolation_parameter * alpha ) * gamma ; } Vector4d ret = q1 * r ; ret += q2_sign * q2 * s ; return ret ; } Vector4d uniformlyRandomAxisAngle ( std :: default_random_engine & generator ) { std :: normal_distribution < double > normal ; std :: unifor@@ m_real_distribution < double > uniform ( - M_PI , M_PI ) ; double angle = uniform ( generator ) ; Vector3d axis = Vector3d ( normal ( generator ) , normal ( generator ) , normal ( generator ) ) ; axis . normalize ( ) ; Vector4d a ; a << axis , angle ; return a ; } Vector4d uniformlyRandomQuat ( std :: default_random_engine & generator ) { return axis2quat ( uniformlyRandomAxisAngle ( generator ) ) ; } Eigen :: Matrix3d uniformlyRandomRotmat ( std :: default_random_engine & generator ) { return axis2rotmat ( uniformlyRandomAxisAngle ( generator ) ) ; } Eigen :: Vector3d uniformlyRandomRPY ( std :: default_random_engine & generator ) { return axis2rpy ( uniformlyRandomAxisAngle ( generator ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > quat2rpy ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > ret ; ret << std :: atan2 ( 2.0 * ( w * x + y * z ) , w * w + z * z - ( x * x + y * y ) ) , std :: asin ( 2.0 * ( w * y - z * x ) ) , std :: atan2 ( 2.0 * ( w * z + x * y ) , w * w + x * x - ( y * y + z * z ) ) ; return ret ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > quat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > M ; M . row ( 0 ) << w * w + x * x - y * y - z * z , 2.0 * x * y - 2.0 * w * z , 2.0 * x * z + 2.0 * w * y ; M . row ( 1 ) << 2.0 * x * y + 2.0 * w * z , w * w + y * y - x * x - z * z , 2.0 * y * z - 2.0 * w * x ; M . row ( 2 ) << 2.0 * x * z - 2.0 * w * y , 2.0 * y * z + 2.0 * w * x , w * w + z * z - x * x - y * y ; return M ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > quat2axis ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto s = std :: sqrt ( 1.0 - q_normalized ( 0 ) * q_normalized ( 0 ) ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > a ; a << q_normalized . template tail < 3 > ( ) / s , 2.0 * std :: acos ( q_normalized ( 0 ) ) ; return a ; } template < typename Derived > Eigen :: Vector4d axis2quat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto axis = a . template head < 3 > ( ) ; auto angle = a ( 3 ) ; auto arg = 0.5 * angle ; auto c = std :: cos ( arg ) ; auto s = std :: sin ( arg ) ; Eigen :: Vector4d ret ; ret << c , s * axis ; return ret ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > axis2rotmat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; const auto & axis = ( a . template head < 3 > ( ) ) / ( a . template head < 3 > ( ) ) . norm ( ) ; const auto & theta = a ( 3 ) ; auto x = axis ( 0 ) ; auto y = axis ( 1 ) ; auto z = axis ( 2 ) ; auto ctheta = std :: cos ( theta ) ; auto stheta = std :: sin ( theta ) ; auto c = 1 - ctheta ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R << ctheta + x * x * c , x * y * c - z * stheta , x * z * c + y * stheta , y * x * c + z * stheta , ctheta + y * y * c , y * z * c - x * stheta , z * x * c - y * stheta , z * y * c + x * stheta , ctheta + z * z * c ; return R ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > axis2rpy ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; return quat2rpy ( axis2quat ( a ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2axis ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; typename Derived :: Scalar theta = std :: acos ( ( R . trace ( ) - 1.0 ) / 2.0 ) ; Vector4d a ; if ( theta > std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ) { a << R ( 2 , 1 ) - R ( 1 , 2 ) , R ( 0 , 2 ) - R ( 2 , 0 ) , R ( 1 , 0 ) - R ( 0 , 1 ) , theta ; a . head < 3 > ( ) *= 1.0 / ( 2.0 * std :: sin ( theta ) ) ; } else { a << 1.0 , 0.0 , 0.0 , 0.0 ; } return a ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2quat ( const Eigen :: MatrixBase < Derived > & M ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Matrix < typename Derived :: Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < typename Derived :: Scalar , 4 , 1 > B = A * M . diagonal ( ) ; typename Matrix < typename Derived :: Scalar , 4 , 1 > :: Index ind , max_col ; typename Derived :: Scalar val = B . maxCoeff ( & ind , & max_col ) ; typename Derived :: Scalar w , x , y , z ; switch ( ind ) { case 0 : { w = sqrt ( 1.0 + val ) / 2.0 ; typename Derived :: Scalar w4 = w * 4.0 ; x = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / w4 ; y = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / w4 ; z = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / w4 ; break ; } case 1 : { double s = 2.0 * sqrt ( 1.0 + val ) ; w = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / s ; x = 0.25 * s ; y = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; z = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; break ; } case 2 : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / s ; x = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; y = 0.25 * s ; z = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; break ; } default : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / s ; x = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; y = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; z = 0.25 * s ; break ; } } Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > q ; q << w , x , y , z ; return q ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rotmat2rpy ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rpy ; rpy << atan2 ( R ( 2 , 1 ) , R ( 2 , 2 ) ) , atan2 ( - R ( 2 , 0 ) , sqrt ( pow ( R ( 2 , 1 ) , 2.0 ) + pow ( R ( 2 , 2 ) , 2.0 ) ) ) , atan2 ( R ( 1 , 0 ) , R ( 0 , 0 ) ) ; return rpy ; } template < typename Derived > DLLEXPORT Eigen :: Matrix < typename Derived :: Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const Eigen :: MatrixBase < Derived > & R , int rotation_type ) { typedef typename Derived :: Scalar Scalar ; Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ret ; switch ( rotation_type ) { case 0 : return Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ( 0 , 1 ) ; case 1 : return rotmat2rpy ( R ) ; case 2 : return rotmat2quat ( R ) ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } } template < typename Scalar > DLLEXPORT GradientVar < Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < Scalar , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) { GradientVar < Scalar , Eigen :: Dynamic , 1 > ret ( rotationRepresentationSize ( rotation_type ) , 1 , R . getNumVariables ( ) , R . maxOrder ( ) ) ; switch ( rotation_type ) { case 0 : break ; case 1 : ret . value ( ) = rotmat2rpy ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2rpy ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; case 2 : ret . value ( ) = rotmat2quat ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2quat ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; } template < typename Derived > GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > expmap2quat ( const Eigen :: MatrixBase < Derived > & v , const int gradient_order ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > ret ( QUAT_SIZE , 1 , EXPMAP@@ _SIZE , gradient_order ) ; auto theta = v . norm ( ) ; if ( theta < pow ( std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) , 0.25 ) ) { ret . value ( ) = expmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } else { ret . value ( ) = expmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } return ret ; } DLLEXPORT int rotationRepresentationSize ( int rotation_type ) { switch ( rotation_type ) { case 0 : return 0 ; break ; case 1 : return 3 ; break ; case 2 : return 4 ; break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2axis ( const Eigen :: MatrixBase < Derived > & rpy ) { return quat2axis ( rpy2quat ( rpy ) ) ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2quat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_2 = ( rpy / 2.0 ) . array ( ) ; auto s = rpy_2 . sin ( ) ; auto c = rpy_2 . cos ( ) ; Vector4d q ; q << c ( 0 ) * c ( 1 ) * c ( 2 ) + s ( 0 ) * s ( 1 ) * s ( 2 ) , s ( 0 ) * c ( 1 ) * c ( 2 ) - c ( 0 ) * s ( 1 ) * s ( 2 ) , c ( 0 ) * s ( 1 ) * c ( 2 ) + s ( 0 ) * c ( 1 ) * s ( 2 ) , c ( 0 ) * c ( 1 ) * s ( 2 ) - s ( 0 ) * s ( 1 ) * c ( 2 ) ; q /= q . norm ( ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; return q ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > rpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R . row ( 0 ) << c ( 2 ) * c ( 1 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; R . row ( 1 ) << s ( 2 ) * c ( 1 ) , s ( 2 ) * s ( 1 ) * s ( 0 ) + c ( 2 ) * c ( 0 ) , s ( 2 ) * s ( 1 ) * c ( 0 ) - c ( 2 ) * s ( 0 ) ; R . row ( 2 ) << - s ( 1 ) , c ( 1 ) * s ( 0 ) , c ( 1 ) * c ( 0 ) ; return R ; } Matrix3d rotz ( double theta ) { Matrix3d M ; double c = cos ( theta ) ; double s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; return M ; } void rotz ( double theta , Matrix3d & M , Matrix3d & dM , Matrix3d & ddM ) { double c = cos ( theta ) , s = sin ( theta ) ; M << c , - s , 0 , s , c , 0 , 0 , 0 , 1 ; dM << - s , - c , 0 , c , - s , 0 , 0 , 0 , 0 ; ddM << - c , s , 0 , - s , - c , 0 , 0 , 0 , 0 ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > dR ; dR . row ( 0 ) << 0 , c ( 2 ) * - s ( 1 ) , c ( 1 ) * - s ( 2 ) ; dR . row ( 1 ) << 0 , - s ( 1 ) * s ( 2 ) , c ( 2 ) * c ( 1 ) ; dR . row ( 2 ) << 0 , - c ( 1 ) , 0 ; dR . row ( 3 ) << c ( 2 ) * s ( 1 ) * c ( 0 ) - s ( 2 ) * - s ( 0 ) , c ( 2 ) * c ( 1 ) * s ( 0 ) , - s ( 2 ) * s ( 1 ) * s ( 0 ) - c ( 2 ) * c ( 0 ) ; dR . row ( 4 ) << s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * - s ( 0 ) , s ( 2 ) * c ( 1 ) * s ( 0 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) ; dR . row ( 5 ) << c ( 1 ) * c ( 0 ) , - s ( 1 ) * s ( 0 ) , 0 ; dR . row ( 6 ) << c ( 2 ) * s ( 1 ) * - s ( 0 ) + s ( 2 ) * c ( 0 ) , c ( 2 ) * c ( 1 ) * c ( 0 ) , - s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * s ( 0 ) ; dR . row ( 7 ) << s ( 2 ) * s ( 1 ) * - s ( 0 ) - c ( 2 ) * c ( 0 ) , s ( 2 ) * c ( 1 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; dR . row ( 8 ) << c ( 1 ) * - s ( 0 ) , - s ( 1 ) * c ( 0 ) , 0 ; return dR ; } template < typename Derived > void normalizeVec ( const Eigen :: MatrixBase < Derived > & x , typename Derived :: PlainObject & x_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 1 > :: type * dx_norm , typename Gradient < Derived , Derived :: RowsAtCompileTime , 2 > :: type * ddx_norm ) { typename Derived :: Scalar xdotx = x . squaredNorm ( ) ; typename Derived :: Scalar norm_x = std :: sqrt ( xdotx ) ; x_norm = x / norm_x ; if ( dx_norm ) { dx_norm -> setIdentity ( x . rows ( ) , x . rows ( ) ) ; ( * dx_norm ) -= x * x . transpose ( ) / xdotx ; ( * dx_norm ) /= norm_x ; if ( ddx_norm ) { auto dx_norm_transpose = transposeGrad ( * dx_norm , x . rows ( ) ) ; auto ddx_norm_times_norm = - matGradM@@ ultMat ( x_norm , x_norm . transpose ( ) , ( * dx_norm ) , dx_norm_transpose ) ; auto dnorm_inv = - x . transpose ( ) / ( xdotx * norm_x ) ; ( * ddx_norm ) = ddx_norm_times_norm / norm_x ; auto temp = ( * dx_norm ) * norm_x ; typename Derived :: Index n = x . rows ( ) ; for ( int col = 0 ; col < n ; col ++ ) { auto column_as_matrix = ( dnorm_inv ( 0 , col ) * temp ) ; for ( int row_block = 0 ; row_block < n ; row_block ++ ) { ddx_norm -> block ( row_block * n , col , n , 1 ) += column_as_matrix . col ( row_block ) ; } } } } } template < typename Derived > typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , QUAT_SIZE ) ; typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type ret ; typename Eigen :: MatrixBase < Derived > :: PlainObject qtilde ; typename Gradient < Derived , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; typedef typename Derived :: Scalar Scalar ; Scalar w = qtilde ( 0 ) ; Scalar x = qtilde ( 1 ) ; Scalar y = qtilde ( 2 ) ; Scalar z = qtilde ( 3 ) ; ret << w , x , - y , - z , z , y , x , w , - y , z , - w , x , - z , y , x , - w , w , - x , y , - z , x , w , z , y , y , z , w , x , - x , - w , z , y , w , - x , - y , z ; ret *= 2.0 ; ret *= dqtilde ; return ret ; } template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2rpy ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typename DerivedDR :: Index nq = dR . cols ( ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; ReturnType drpy ( RPY_SIZE , nq ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Scalar sqterm = R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ; using namespace std ; drpy . row ( 0 ) = ( R ( 2 , 2 ) * dR32_dq - R ( 2 , 1 ) * dR33_dq ) / sqterm ; Scalar sqrt_sqterm = sqrt ( sqterm ) ; drpy . row ( 1 ) = ( - sqrt_sqterm * dR31_dq + R ( 2 , 0 ) / sqrt_sqterm * ( R ( 2 , 1 ) * dR32_dq + R ( 2 , 2 ) * dR33_dq ) ) / ( R ( 2 , 0 ) * R ( 2 , 0 ) + R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ) ; sqterm = R ( 0 , 0 ) * R ( 0 , 0 ) + R ( 1 , 0 ) * R ( 1 , 0 ) ; drpy . row ( 2 ) = ( R ( 0 , 0 ) * dR21_dq - R ( 1 , 0 ) * dR11_dq ) / sqterm ; return drpy ; } template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2quat ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; typename DerivedDR :: Index nq = dR . cols ( ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR12_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 1 , R . rows ( ) ) ; auto dR13_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 2 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR22_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 1 , R . rows ( ) ) ; auto dR23_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 2 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Matrix < Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < Scalar , 4 , 1 > B = A * R . diagonal ( ) ; typename Matrix < Scalar , 4 , 1 > :: Index ind , max_col ; Scalar val = B . maxCoeff ( & ind , & max_col ) ; ReturnType dq ( QUAT_SIZE , nq ) ; using namespace std ; switch ( ind ) { case 0 : { auto dvaldq = dR11_dq + dR22_dq + dR33_dq ; auto dwdq = dvaldq / ( 4.0 * sqrt ( 1.0 + val ) ) ; auto w = sqrt ( 1.0 + val ) / 2.0 ; auto wsquare4 = 4.0 * w * w ; dq . row ( 0 ) = dwdq ; dq . row ( 1 ) = ( ( dR32_dq - dR23_dq ) * w - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dwdq ) / wsquare4 ; dq . row ( 2 ) = ( ( dR13_dq - dR31_dq ) * w - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dwdq ) / wsquare4 ; dq . row ( 3 ) = ( ( dR21_dq - dR12_dq ) * w - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dwdq ) / wsquare4 ; break ; } case 1 : { auto dvaldq = dR11_dq - dR22_dq - dR33_dq ; auto s = 2.0 * sqrt ( 1.0 + val ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR32_dq - dR23_dq ) * s - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = .25 * dsdq ; dq . row ( 2 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; break ; } case 2 : { auto dvaldq = - dR11_dq + dR22_dq - dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR13_dq - dR31_dq ) * s - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = .25 * dsdq ; dq . row ( 3 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; break ; } default : { auto dvaldq = - dR11_dq - dR22_dq + dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR21_dq - dR12_dq ) * s - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = .25 * dsdq ; break ; } } return dq ; } template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Derived > & p ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , SPACE_DIMENSION ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > ret ; ret << 0.0 , - p ( 2 ) , p ( 1 ) , p ( 2 ) , 0.0 , - p ( 0 ) , - p ( 1 ) , p ( 0 ) , 0.0 ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > ret ( 3 , da . cols ( ) ) ; ret . noalias ( ) = da . colwise ( ) . cross ( b ) ; ret . noalias ( ) -= db . colwise ( ) . cross ( a ) ; return ret ; } template < typename DerivedQ , typename DerivedM , typename DerivedDM > void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , Eigen :: MatrixBase < DerivedDM > * dM ) { M . resize ( QUAT_SIZE , SPACE_DIMENSION ) ; M . row ( 0 ) << - q ( 1 ) , - q ( 2 ) , - q ( 3 ) ; M . row ( 1 ) << q ( 0 ) , q ( 3 ) , - q ( 2 ) ; M . row ( 2 ) << - q ( 3 ) , q ( 0 ) , q ( 1 ) ; M . row ( 3 ) << q ( 2 ) , - q ( 1 ) , q ( 0 ) ; M *= 0.5 ; if ( dM ) { ( * dM ) << 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.5 , 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , - 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.5 , 0.0 , 0.0 , 0.0 ; } } template < typename DerivedQ , typename DerivedM > void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedQ > & q , Eigen :: MatrixBase < DerivedM > & M , typename Gradient < DerivedM , QUAT_SIZE , 1 > :: type * dM ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedQ > , QUAT_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedM > , SPACE_DIMENSION , QUAT_SIZE ) ; typename DerivedQ :: PlainObject qtilde ; if ( dM ) { typename Gradient < DerivedQ , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; ( * dM ) << 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , - 2.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , - 2.0 , 0.0 , 0.0 , 2.0 , 0.0 , 0.0 , 0.0 ; ( * dM ) *= dqtilde ; } else { normalizeVec ( q , qtilde ) ; } M << - qtilde ( 1 ) , qtilde ( 0 ) , - qtilde ( 3 ) , qtilde ( 2 ) , - qtilde ( 2 ) , qtilde ( 3 ) , qtilde ( 0 ) , - qtilde ( 1 ) , - qtilde ( 3 ) , - qtilde ( 2 ) , qtilde ( 1 ) , qtilde ( 0 ) ; M *= 2.0 ; } template < typename DerivedRPY , typename DerivedPhi , typename DerivedDPhi , typename DerivedDDPhi > void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , typename Eigen :: MatrixBase < DerivedPhi > & phi , typename Eigen :: MatrixBase < DerivedDPhi > * dphi , typename Eigen :: MatrixBase < DerivedDDPhi > * ddphi ) { phi . resize ( RPY_SIZE , SPACE_DIMENSION ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; using namespace std ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar tp = sp / cp ; phi << cy / cp , sy / cp , 0.0 , - sy , cy , 0.0 , cy * tp , tp * sy , 1.0 ; if ( dphi ) { dphi -> resize ( phi . size ( ) , RPY_SIZE ) ; Scalar sp2 = sp * sp ; Scalar cp2 = cp * cp ; ( * dphi ) << 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy + ( cy * sp2 ) / cp2 , - ( sp * sy ) / cp , 0.0 , ( sp * sy ) / cp2 , cy / cp , 0.0 , 0.0 , - sy , 0.0 , sy + ( sp2 * sy ) / cp2 , ( cy * sp ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; if ( ddphi ) { ddphi -> resize ( dphi -> size ( ) , RPY_SIZE ) ; Scalar cp3 = cp2 * cp ; ( * ddphi ) << 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , - ( cy * ( cp2 - 2.0 ) ) / cp3 , ( sp * sy ) / ( sp2 - 1.0 ) , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * cy * sp ) / cp3 , sy / ( sp2 - 1.0 ) , 0.0 , ( 2.0 * sy - cp2 * sy ) / cp3 , ( cy * sp ) / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , ( 2.0 * sp * sy ) / cp3 , cy / cp2 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , ( sp * sy ) / ( sp2 - 1.0 ) , - cy / cp , 0.0 , 0.0 , sy , 0.0 , sy / ( sp2 - 1.0 ) , - ( cy * sp ) / cp , 0.0 , ( cy * sp ) / cp2 , - sy / cp , 0.0 , 0.0 , - cy , 0.0 , cy / cp2 , - ( sp * sy ) / cp , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } } template < typename Derived > DLLEXPORT GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Derived > & qrot , int gradient_order ) { GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > ret ( qrot . rows ( ) , SPACE_DIMENSION , qrot . rows ( ) , gradient_order ) ; switch ( rotation_type ) { case 0 : break ; case 1 : { if ( gradient_order > 1 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , & ret . gradient ( ) . gradient ( ) . value ( ) ) ; } else if ( gradient_order > 0 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , ( MatrixXd * ) nullptr ) ; } else { angularvel2rpydotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr , ( MatrixXd * ) nullptr ) ; } break ; } case 2 : { if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) . setZero ( ) ; } if ( gradient_order > 0 ) { angularvel2quatdotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) ) ; } else { angularvel2quatdotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr ) ; } break ; } default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; } template < typename DerivedRPY , typename DerivedE > void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < DerivedRPY > & rpy , Eigen :: MatrixBase < DerivedE > & E , typename Gradient < DerivedE , RPY_SIZE , 1 > :: type * dE ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedRPY > , RPY_SIZE ) ; EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedE > , SPACE_DIMENSION , RPY_SIZE ) ; typedef typename DerivedRPY :: Scalar Scalar ; Scalar p = rpy ( 1 ) ; Scalar y = rpy ( 2 ) ; Scalar sp = sin ( p ) ; Scalar cp = cos ( p ) ; Scalar sy = sin ( y ) ; Scalar cy = cos ( y ) ; using namespace std ; E << cp * cy , - sy , 0.0 , cp * sy , cy , 0.0 , - sp , 0.0 , 1.0 ; if ( dE ) { ( * dE ) << 0.0 , - sp * cy , - cp * sy , 0.0 , - sp * sy , cp * cy , 0.0 , - cp , 0.0 , 0.0 , 0.0 , - cy , 0.0 , 0.0 , - sy , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ; } } template < typename DerivedM > typename TransformSpatial < DerivedM > :: type transformSpatialMotion ( const Eigen :: Transform < typename DerivedM :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedM > & M ) { Eigen :: Matrix < typename DerivedM :: Scalar , TWIST_SIZE , DerivedM :: ColsAtCompileTime > ret ( TWIST_SIZE , M . cols ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) = T . linear ( ) * M . template topRows < 3 > ( ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = - ret . template topRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) += T . linear ( ) * M . template bottomRows < 3 > ( ) ; return ret ; } template < typename DerivedF > typename TransformSpatial < DerivedF > :: type transformSpatialForce ( const Eigen :: Transform < typename DerivedF :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedF > & F ) { Eigen :: Matrix < typename DerivedF :: Scalar , TWIST_SIZE , DerivedF :: ColsAtCompileTime > ret ( TWIST_SIZE , F . cols ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = T . linear ( ) * F . template bottomRows < 3 > ( ) . eval ( ) ; ret . template topRows < 3 > ( ) = - ret . template bottomRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) += T . linear ( ) * F . template topRows < 3 > ( ) ; return ret ; } template < typename DerivedI > GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const typename Gradient < typename Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < DerivedI > & I ) { int gradient_order ; typename DerivedI :: Index nq ; if ( dT_current_to_new ) { gradient_order = 1 ; nq = dT_current_to_new -> cols ( ) ; } else { nq = 0 ; gradient_order = 0 ; } GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > ret ( TWIST_SIZE , TWIST_SIZE , nq , gradient_order ) ; auto I_half_transformed = transformSpatialForce ( T_current_to_new , I ) ; ret . value ( ) = transformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) ) ; if ( gradient_order > 0 ) { auto dI = Eigen :: Matrix < typename DerivedI :: Scalar , DerivedI :: SizeAtCompileTime , Eigen :: Dynamic > :: Zero ( I . size ( ) , nq ) . eval ( ) ; auto dI_half_transformed = dTransformSpatialForce ( T_current_to_new , I , * dT_current_to_new , dI ) ; auto dI_half_transformed_transpose = transposeGrad ( dI_half_transformed , I_half_transformed . rows ( ) ) ; ret . gradient ( ) . value ( ) = dTransformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) , * dT_current_to_new , dI_half_transformed_transpose ) ; } return ret ; } template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; } template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template topRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = - da . row ( 2 ) * b [ 1 ] + da . row ( 1 ) * b [ 2 ] - a [ 2 ] * db . row ( 1 ) + a [ 1 ] * db . row ( 2 ) ; ret . row ( 1 ) = da . row ( 2 ) * b [ 0 ] - da . row ( 0 ) * b [ 2 ] + a [ 2 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 2 ) ; ret . row ( 2 ) = - da . row ( 1 ) * b [ 0 ] + da . row ( 0 ) * b [ 1 ] - a [ 1 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 1 ) ; ret . row ( 3 ) = - da . row ( 5 ) * b [ 1 ] + da . row ( 4 ) * b [ 2 ] - da . row ( 2 ) * b [ 4 ] + da . row ( 1 ) * b [ 5 ] - a [ 5 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 2 ) - a [ 2 ] * db . row ( 4 ) + a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = da . row ( 5 ) * b [ 0 ] - da . row ( 3 ) * b [ 2 ] + da . row ( 2 ) * b [ 3 ] - da . row ( 0 ) * b [ 5 ] + a [ 5 ] * db . row ( 0 ) - a [ 3 ] * db . row ( 2 ) + a [ 2 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = - da . row ( 4 ) * b [ 0 ] + da . row ( 3 ) * b [ 1 ] - da . row ( 1 ) * b [ 3 ] + da . row ( 0 ) * b [ 4 ] - a [ 4 ] * db . row ( 0 ) + a [ 3 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 4 ) ; return ret ; } template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = da . row ( 2 ) * b [ 1 ] - da . row ( 1 ) * b [ 2 ] + da . row ( 5 ) * b [ 4 ] - da . row ( 4 ) * b [ 5 ] + a [ 2 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 2 ) + a [ 5 ] * db . row ( 4 ) - a [ 4 ] * db . row ( 5 ) ; ret . row ( 1 ) = - da . row ( 2 ) * b [ 0 ] + da . row ( 0 ) * b [ 2 ] - da . row ( 5 ) * b [ 3 ] + da . row ( 3 ) * b [ 5 ] - a [ 2 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 2 ) - a [ 5 ] * db . row ( 3 ) + a [ 3 ] * db . row ( 5 ) ; ret . row ( 2 ) = da . row ( 1 ) * b [ 0 ] - da . row ( 0 ) * b [ 1 ] + da . row ( 4 ) * b [ 3 ] - da . row ( 3 ) * b [ 4 ] + a [ 1 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 3 ) - a [ 3 ] * db . row ( 4 ) ; ret . row ( 3 ) = da . row ( 2 ) * b [ 4 ] - da . row ( 1 ) * b [ 5 ] + a [ 2 ] * db . row ( 4 ) - a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = - da . row ( 2 ) * b [ 3 ] + da . row ( 0 ) * b [ 5 ] - a [ 2 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = da . row ( 1 ) * b [ 3 ] - da . row ( 0 ) * b [ 4 ] + a [ 1 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 4 ) ; ret = - ret ; return ret ; } template < typename DerivedS , typename DerivedQdotToV > typename DHomogTrans < DerivedQdotToV > :: type dHomogTrans ( const Eigen :: Transform < typename DerivedQdotToV :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedS > & S , const Eigen :: MatrixBase < DerivedQdotToV > & qdot_to_v ) { const int nq_at_compile_time = DerivedQdotToV :: ColsAtCompileTime ; typename DerivedQdotToV :: Index nq = qdot_to_v . cols ( ) ; auto qdot_to_twist = ( S * qdot_to_v ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedQdotToV :: Scalar , numel , nq_at_compile_time > ret ( numel , nq ) ; const auto & Rx = T . linear ( ) . col ( 0 ) ; const auto & Ry = T . linear ( ) . col ( 1 ) ; const auto & Rz = T . linear ( ) . col ( 2 ) ; const auto & qdot_to_omega_x = qdot_to_twist . row ( 0 ) ; const auto & qdot_to_omega_y = qdot_to_twist . row ( 1 ) ; const auto & qdot_to_omega_z = qdot_to_twist . row ( 2 ) ; ret . template middleRows < 3 > ( 0 ) = - Rz * qdot_to_omega_y + Ry * qdot_to_omega_z ; ret . row ( 3 ) . setZero ( ) ; ret . template middleRows < 3 > ( 4 ) = Rz * qdot_to_omega_x - Rx * qdot_to_omega_z ; ret . row ( 7 ) . setZero ( ) ; ret . template middleRows < 3 > ( 8 ) = - Ry * qdot_to_omega_x + Rx * qdot_to_omega_y ; ret . row ( 11 ) . setZero ( ) ; ret . template middleRows < 3 > ( 12 ) = T . linear ( ) * qdot_to_twist . bottomRows ( 3 ) ; ret . row ( 15 ) . setZero ( ) ; return ret ; } template < typename DerivedDT > typename DHomogTrans < DerivedDT > :: type dHomogTransInv ( const Eigen :: Transform < typename DerivedDT :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedDT > & dT ) { typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; auto dinvT_R = transposeGrad ( dR , R . rows ( ) ) ; auto dinvT_p = ( - R . transpose ( ) * dp - matGradMult ( dinvT_R , p ) ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedDT :: Scalar , numel , DerivedDT :: ColsAtCompileTime > ret ( numel , nq ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_R , rows , R_cols , T . Rows ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_p , rows , p_cols , T . Rows ) ; const int last_row = 3 ; for ( int col = 0 ; col < T . HDim ; col ++ ) { ret . row ( last_row + col * T . Rows ) . setZero ( ) ; } return ret ; } template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type dTransformSpatialMotion ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXomega_col = ( R * Xomega_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col + matGradMult ( dR , Xomega_col ) ) . eval ( ) ; auto dv_part_col = ( R * dXv_col + matGradMult ( dR , Xv_col ) ) . eval ( ) ; dv_part_col += dp . colwise ( ) . cross ( RXomega_col ) ; dv_part_col -= domega_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; } template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXv_col = ( R * Xv_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col ) . eval ( ) ; domega_part_col += matGradMult ( dR , Xomega_col ) ; auto dv_part_col = ( R * dXv_col ) . eval ( ) ; dv_part_col += matGradMult ( dR , Xv_col ) ; domega_part_col += dp . colwise ( ) . cross ( RXv_col ) ; domega_part_col -= dv_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; } template < typename Scalar > DLLEXPORT void cylindrical2cartesian ( const Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Matrix < Scalar , 3 , 1 > & cylinder_origin , const Matrix < Scalar , 6 , 1 > & x_cylinder , const Matrix < Scalar , 6 , 1 > & v_cylinder , Matrix < Scalar , 6 , 1 > & x_cartesian , Matrix < Scalar , 6 , 1 > & v_cartesian , Matrix < Scalar , 6 , 6 > & J , Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; double radius = x_cylinder ( 0 ) ; double theta = x_cylinder ( 1 ) ; double c_theta = cos ( theta ) ; double s_theta = sin ( theta ) ; double height = x_cylinder ( 2 ) ; double radius_dot = v_cylinder ( 0 ) ; double theta_dot = v_cylinder ( 1 ) ; double height_dot = v_cylinder ( 2 ) ; Matrix < Scalar , 3 , 1 > x_pos_cartesian ; x_pos_cartesian << radius * c_theta , radius * s_theta , height ; x_pos_cartesian = R_cylinder2cartesian * x_pos_cartesian + cylinder_origin ; Matrix < Scalar , 3 , 1 > v_pos_cartesian ; v_pos_cartesian << radius * - s_theta * theta_dot + radius_dot * c_theta , radius * c_theta * theta_dot + radius_dot * s_theta , height_dot ; v_pos_cartesian = R_cylinder2cartesian * v_pos_cartesian ; Vector3d x_rpy_cylinder = x_cylinder . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_tangent = rpy2rotmat ( x_rpy_cylinder ) ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder_dtheta = dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > R_cylinder = R_tangent2cylinder * R_tangent ; Matrix < Scalar , 3 , 3 > R_cartesian = R_cylinder2cartesian * R_cylinder ; Matrix < Scalar , 3 , 1 > x_rpy_cartesian = rotmat2rpy ( R_cartesian ) ; x_cartesian . block ( 0 , 0 , 3 , 1 ) = x_pos_cartesian ; x_cartesian . block ( 3 , 0 , 3 , 1 ) = x_rpy_cartesian ; v_cartesian . block ( 0 , 0 , 3 , 1 ) = v_pos_cartesian ; v_cartesian . block ( 3 , 0 , 3 , 1 ) = theta_dot * R_cylinder2cartesian . col ( 2 ) + R_cylinder2cartesian * R_tangent2cylinder * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J . block ( 0 , 0 , 3 , 1 ) << c_theta , s_theta , 0 ; J . block ( 0 , 1 , 3 , 1 ) << radius * - s_theta , radius * c_theta , 0 ; J . block ( 0 , 2 , 3 , 1 ) << 0 , 0 , 1 ; J . block ( 0 , 0 , 3 , 3 ) = R_cylinder2cartesian * J . block ( 0 , 0 , 3 , 3 ) ; J . block ( 3 , 1 , 3 , 1 ) = R_cylinder2cartesian . col ( 2 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2cartesian * R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dJ1_dradius = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dradius ( 0 , 1 ) = - s_theta ; dJ1_dradius ( 1 , 1 ) = c_theta ; Matrix < Scalar , 3 , 3 > dJ1_dtheta = Matrix < Scalar , 3 , 3 > :: Zero ( ) ; dJ1_dtheta ( 0 , 0 ) = - s_theta ; dJ1_dtheta ( 0 , 1 ) = - radius * c_theta ; dJ1_dtheta ( 1 , 0 ) = c_theta ; dJ1_dtheta ( 1 , 1 ) = - radius * s_theta ; Jdotv . block ( 0 , 0 , 3 , 1 ) = R_cylinder2cartesian * ( dJ1_dradius * radius_dot + dJ1_dtheta * theta_dot ) * v_cylinder . block ( 0 , 0 , 3 , 1 ) ; Jdotv . block ( 3 , 0 , 3 , 1 ) = R_cylinder2cartesian * dR_tangent2cylinder_dtheta * theta_dot * v_cylinder . block ( 3 , 0 , 3 , 1 ) ; } template < typename Scalar > DLLEXPORT void cartesian2cylindrical ( const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_axis , const Eigen :: Matrix < Scalar , 3 , 1 > & m_cylinder_x_dir , const Eigen :: Matrix < Scalar , 3 , 1 > & cylinder_origin , const Eigen :: Matrix < Scalar , 6 , 1 > & x_cartesian , const Eigen :: Matrix < Scalar , 6 , 1 > & v_cartesian , Eigen :: Matrix < Scalar , 6 , 1 > & x_cylinder , Eigen :: Matrix < Scalar , 6 , 1 > & v_cylinder , Eigen :: Matrix < Scalar , 6 , 6 > & J , Eigen :: Matrix < Scalar , 6 , 1 > & Jdotv ) { Matrix < Scalar , 3 , 1 > cylinder_axis = m_cylinder_axis / m_cylinder_axis . norm ( ) ; Matrix < Scalar , 3 , 1 > cylinder_x_dir = m_cylinder_x_dir / m_cylinder_x_dir . norm ( ) ; Matrix < Scalar , 3 , 3 > R_cylinder2cartesian ; R_cylinder2cartesian . col ( 0 ) = cylinder_x_dir ; R_cylinder2cartesian . col ( 1 ) = cylinder_axis . cross ( cylinder_x_dir ) ; R_cylinder2cartesian . col ( 2 ) = cylinder_axis ; Matrix < Scalar , 3 , 3 > R_cartesian2cylinder = R_cylinder2cartesian . transpose ( ) ; Matrix < Scalar , 3 , 1 > x_pos_cylinder = R_cartesian2cylinder * ( x_cartesian . block ( 0 , 0 , 3 , 1 ) - cylinder_origin ) ; Matrix < Scalar , 3 , 1 > v_pos_cylinder = R_cartesian2cylinder * v_cartesian . block ( 0 , 0 , 3 , 1 ) ; double radius = sqrt ( pow ( x_pos_cylinder ( 0 ) , 2 ) + pow ( x_pos_cylinder ( 1 ) , 2 ) ) ; double radius_dot = ( x_pos_cylinder ( 0 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 1 ) * v_pos_cylinder ( 1 ) ) / radius ; double theta = atan2 ( x_pos_cylinder ( 1 ) , x_pos_cylinder ( 0 ) ) ; double radius_square = pow ( radius , 2 ) ; double radius_cubic = pow ( radius , 3 ) ; double radius_quad = pow ( radius , 4 ) ; double theta_dot = ( - x_pos_cylinder ( 1 ) * v_pos_cylinder ( 0 ) + x_pos_cylinder ( 0 ) * v_pos_cylinder ( 1 ) ) / radius_square ; double height = x_pos_cylinder ( 2 ) ; double height_dot = v_pos_cylinder ( 2 ) ; x_cylinder ( 0 ) = radius ; x_cylinder ( 1 ) = theta ; x_cylinder ( 2 ) = height ; v_cylinder ( 0 ) = radius_dot ; v_cylinder ( 1 ) = theta_dot ; v_cylinder ( 2 ) = height_dot ; Matrix < Scalar , 3 , 3 > R_tangent2cylinder ; Matrix < Scalar , 3 , 3 > dR_tangent2cylinder ; Matrix < Scalar , 3 , 3 > ddR_tangent2cylinder ; rotz ( theta - M_PI / 2 , R_tangent2cylinder , dR_tangent2cylinder , ddR_tangent2cylinder ) ; Matrix < Scalar , 3 , 3 > R_cylinder2tangent = R_tangent2cylinder . transpose ( ) ; Vector3d x_rpy_cartesian = x_cartesian . block ( 3 , 0 , 3 , 1 ) ; Matrix < Scalar , 3 , 3 > R_cartesian = rpy2rotmat ( x_rpy_cartesian ) ; x_cylinder . block ( 3 , 0 , 3 , 1 ) = rotmat2rpy ( R_cylinder2tangent * R_cartesian2cylinder * R_cartesian ) ; J = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; Matrix < Scalar , 6 , 6 > Jdot = Matrix < Scalar , 6 , 6 > :: Zero ( ) ; J ( 0 , 0 ) = x_pos_cylinder ( 0 ) / radius ; J ( 0 , 1 ) = x_pos_cylinder ( 1 ) / radius ; J ( 1 , 0 ) = - x_pos_cylinder ( 1 ) / radius_square ; J ( 1 , 1 ) = x_pos_cylinder ( 0 ) / radius_square ; J ( 2 , 2 ) = 1.0 ; J . block ( 0 , 0 , 3 , 3 ) = J . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; Jdot ( 0 , 0 ) = pow ( x_pos_cylinder ( 1 ) , 2 ) / radius_cubic * v_pos_cylinder ( 0 ) - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 0 , 1 ) = - x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_cubic * v_pos_cylinder ( 0 ) + pow ( x_pos_cylinder ( 0 ) , 2 ) / radius_cubic * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 0 ) = 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 0 ) + ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot ( 1 , 1 ) = ( pow ( x_pos_cylinder ( 1 ) , 2 ) - pow ( x_pos_cylinder ( 0 ) , 2 ) ) / radius_quad * v_pos_cylinder ( 0 ) - 2 * x_pos_cylinder ( 0 ) * x_pos_cylinder ( 1 ) / radius_quad * v_pos_cylinder ( 1 ) ; Jdot . block ( 0 , 0 , 3 , 3 ) = Jdot . block ( 0 , 0 , 3 , 3 ) * R_cartesian2cylinder ; v_cylinder . block ( 3 , 0 , 3 , 1 ) = R_cylinder2tangent * R_cartesian2cylinder * v_cartesian . block ( 3 , 0 , 3 , 1 ) - theta_dot * R_cylinder2tangent . col ( 2 ) ; J . block ( 3 , 0 , 3 , 3 ) = R_cylinder2tangent . col ( 2 ) * - J . block ( 1 , 0 , 1 , 3 ) ; J . block ( 3 , 3 , 3 , 3 ) = R_cylinder2tangent * R_cartesian2cylinder ; Jdot . block ( 3 , 0 , 3 , 3 ) = dR_tangent2cylinder . row ( 2 ) . transpose ( ) * - J . block ( 1 , 0 , 1 , 3 ) * theta_dot + R_cylinder2tangent . col ( 2 ) * - Jdot . block ( 1 , 0 , 1 , 3 ) ; Jdot . block ( 3 , 3 , 3 , 3 ) = dR_tangent2cylinder . transpose ( ) * theta_dot * R_cartesian2cylinder ; Jdotv = Jdot * v_cartesian ; } DLLEXPORT GradientVar < double , 3 , 1 > quat2expmap ( const Ref < const Vector4d > & q , int gradient_order ) { double t = sqrt ( 1 - q ( 0 ) * q ( 0 ) ) ; bool is_degenerate = ( t * t < std :: numeric_limits < double > :: epsilon ( ) ) ; double s = is_degenerate ? 2.0 : 2.0 * acos ( q ( 0 ) ) / t ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 4 , gradient_order ) ; ret . value ( ) = s * q . tail ( 3 ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix < double , 3 , 4 > :: Zero ( ) ; double dsdq1 = is_degenerate ? 0.0 : ( - 2 * t + 2 * acos ( q ( 0 ) ) * q ( 0 ) ) / pow ( t , 3 ) ; ret . gradient ( ) . value ( ) . col ( 0 ) = q . tail ( 3 ) * dsdq1 ; ret . gradient ( ) . value ( ) . block ( 0 , 1 , 3 , 3 ) = Matrix3d :: Identity ( ) * s ; } else if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ quat2expmap " ) ; } return ret ; } DLLEXPORT GradientVar < double , 3 , 1 > flipExpmap ( const Ref < const Vector3d > & expmap , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " gradient _ order > 1 ▁ is ▁ not ▁ supported ▁ in ▁ flipExpmap " ) ; } double expmap_norm = expmap . norm ( ) ; bool is_degenerate = ( expmap_norm < std :: numeric_limits < double > :: epsilon ( ) ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; Matrix3d eye3 = Matrix3d :: Identity ( ) ; if ( is_degenerate ) { ret . value ( ) = expmap ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 ; } } else { ret . value ( ) = expmap - expmap / expmap_norm * 2 * M_PI ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = eye3 - ( expmap_norm * expmap_norm * eye3 - expmap * expmap . transpose ( ) ) / pow ( expmap_norm , 3 ) * 2 * M_PI ; } } return ret ; } DLLEXPORT GradientVar < double , 3 , 1 > unwrap@@ Expmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { auto expmap2_flip = flipExpmap ( expmap2 , gradient_order ) ; double distance1 = ( expmap1 - expmap2 ) . squaredNorm ( ) ; double distance2 = ( expmap1 - expmap2_flip . value ( ) ) . squaredNorm ( ) ; if ( distance1 > distance2 ) { return expmap2_flip ; } else { GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; ret . value ( ) = expmap2 ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } return ret ; } } void quat2expmapSequence ( const Ref < const Matrix < double , 4 , Dynamic >> & quat , const Ref < const Matrix < double , 4 , Dynamic >> & quat_dot , Ref < Matrix < double , 3 , Dynamic >> expmap , Ref < Matrix < double , 3 , Dynamic >> expmap_dot ) { Dense@@ Index N = quat . cols ( ) ; if ( quat_dot . cols ( ) != N ) { throw std :: runtime_error ( " quat _ dot ▁ must ▁ have ▁ the ▁ same ▁ number ▁ of ▁ colum@@ ns ▁ as ▁ quat ▁ in ▁ quat2expmapSequence " ) ; } expmap . resize ( 3 , N ) ; expmap_dot . resize ( 3 , N ) ; for ( int i = 0 ; i < N ; i ++ ) { auto expmap_grad = quat2expmap ( quat . col ( i ) , 1 ) ; expmap . col ( i ) = expmap_grad . value ( ) ; expmap_dot . col ( i ) = expmap_grad . gradient ( ) . value ( ) * quat_dot . col ( i ) ; if ( i >= 1 ) { auto closest_grad = closestExpmap ( expmap . col ( i - 1 ) , expmap . col ( i ) , 1 ) ; expmap . col ( i ) = closest_grad . value ( ) ; expmap_dot . col ( i ) = closest_grad . gradient ( ) . value ( ) * expmap_dot . col ( i ) ; } } } DLLEXPORT GradientVar < double , 3 , 1 > closestExpmap ( const Ref < const Vector3d > & expmap1 , const Ref < const Vector3d > & expmap2 , int gradient_order ) { if ( gradient_order > 1 ) { throw std :: runtime_error ( " closestExpmap ▁ only ▁ supports ▁ first ▁ order ▁ gradient " ) ; } double expmap1_norm = expmap1 . norm ( ) ; double expmap2_norm = expmap2 . norm ( ) ; GradientVar < double , 3 , 1 > ret ( 3 , 1 , 3 , gradient_order ) ; if ( expmap2_norm < std :: numeric_limits < double > :: epsilon ( ) ) { if ( expmap1_norm > std :: numeric_limits < double > :: epsilon ( ) ) { Vector3d expmap1_axis = expmap1 / expmap1_norm ; int expmap1_round = static_cast < int > ( expmap1_norm / ( 2 * M_PI ) + 0.5 ) ; ret . value ( ) = expmap1_axis * expmap1_round * 2 * M_PI ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Zero ( ) ; } return ret ; } else { ret . value ( ) = expmap2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) ; } } } else { Vector3d expmap2_axis = expmap2 / expmap2_norm ; Matrix3d dexpmap2_axis_dexpmap2 = ( expmap2_norm * Matrix3d :: Identity ( ) - expmap2 * expmap2 . transpose ( ) / expmap2_norm ) / pow ( expmap2_norm , 2 ) ; double expmap2_closest_k = ( expmap2_axis . transpose ( ) * expmap1 - expmap2_norm ) / ( 2 * M_PI ) ; int expmap2_closest_k1 ; int expmap2_closest_k2 ; if ( expmap2_closest_k > 0 ) { expmap2_closest_k1 = ( int ) expmap2_closest_k ; } else { expmap2_closest_k1 = ( int ) expmap2_closest_k - 1 ; } expmap2_closest_k2 = expmap2_closest_k1 + 1 ; Vector3d expmap2_closest1 = expmap2 + 2 * expmap2_closest_k1 * M_PI * expmap2_axis ; Vector3d expmap2_closest2 = expmap2 + 2 * expmap2_closest_k2 * M_PI * expmap2_axis ; if ( ( expmap2_closest1 - expmap1 ) . norm ( ) < ( expmap2_closest2 - expmap1 ) . norm ( ) ) { ret . value ( ) = expmap2_closest1 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k1 * M_PI ; } return ret ; } else { ret . value ( ) = expmap2_closest2 ; if ( ret . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = Matrix3d :: Identity ( ) + 2 * dexpmap2_axis_dexpmap2 * ( double ) expmap2_closest_k2 * M_PI ; } return ret ; } } return ret ; } template DLLEXPORT void normalizeVec ( const MatrixBase < Vector3d > & x , Vector3d & x_norm , Gradient < Vector3d , 3 , 1 > :: type * , Gradient < Vector3d , 3 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Vector4d > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Map < Vector4d > > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT void normalizeVec ( const MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & x , Vector4d & x_norm , Gradient < Vector4d , 4 , 1 > :: type * , Gradient < Vector4d , 4 , 2 > :: type * ) ; template DLLEXPORT Vector4d quat2axis ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Vector4d > & q ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q ) ; template DLLEXPORT Matrix < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > :: Scalar , 3 , 3 , 0 , 3 , 3 > quat2rotmat < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > > ( MatrixBase < Map < Matrix < double , 4 , 1 , 0 , 4 , 1 > const , 0 , Stride < 0 , 0 > > > const & ) ; template DLLEXPORT Vector3d quat2rpy ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector4d axis2quat ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Matrix3d axis2rotmat ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector3d axis2rpy ( const MatrixBase < Vector4d > & ) ; template DLLEXPORT Vector4d rotmat2axis ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Vector4d rotmat2quat ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Vector3d rotmat2rpy ( const MatrixBase < Matrix3d > & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > :: Scalar , - 1 , 1 , 0 , - 1 , 1 > rotmat2Representation < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 4 , 4 , 0 , 4 , 4 > , 3 , 3 , false > > const & , int ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < double , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) ; template DLLEXPORT GradientVar < double , QUAT_SIZE , 1 > expmap2quat ( const MatrixBase < Vector3d > & v , const int gradient_order ) ; template DLLEXPORT GradientVar < double , QUAT_SIZE , 1 > expmap2quat ( const MatrixBase < Map < Vector3d >> & v , const int gradient_order ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > :: Scalar , 4 , 1 > expmap2quat < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , int ) ; template DLLEXPORT Vector4d rpy2axis ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Vector4d rpy2quat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false >> & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Vector3d > & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false >> & ) ; template DLLEXPORT Vector4d quat2axis ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Matrix3d quat2rotmat ( const MatrixBase < Map < Vector4d > > & q ) ; template DLLEXPORT Vector3d quat2rpy ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector4d axis2quat ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Matrix3d axis2rotmat ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector3d axis2rpy ( const MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Vector4d rotmat2axis ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector4d rotmat2quat ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector3d rotmat2rpy ( const MatrixBase < Map < Matrix3d > > & ) ; template DLLEXPORT Vector4d rpy2axis ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Vector4d rpy2quat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix3d rpy2rotmat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix < double , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Map < Vector3d > > & ) ; template DLLEXPORT Matrix < Block < Matrix4d const , 3 , 3 , false > :: Scalar , 4 , 1 , 0 , 4 , 1 > rotmat2quat < Block < Matrix4d const , 3 , 3 , false > > ( MatrixBase < Block < Matrix4d const , 3 , 3 , false > > const & ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > transformSpatialMotion ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , 1 > transformSpatialMotion ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & ) ; template DLLEXPORT TransformSpatial < MatrixXd > :: type transformSpatialMotion < MatrixXd > ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < MatrixXd > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > :: type transformSpatialMotion ( const Eigen :: Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 6 , - 1 , false > > & M ) ; template DLLEXPORT TransformSpatial < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > :: type transformSpatialForce < Matrix < double , TWIST_SIZE , Eigen :: Dynamic >> ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT TransformSpatial < MatrixXd > :: type transformSpatialForce < MatrixXd > ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < MatrixXd > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true >> :: type transformSpatialForce ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > :: type transformSpatialForce ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > :: type transformSpatialForce ( const Eigen :: Transform < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > :: Scalar , 3 , 1 , 0 > & , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > const , 6 , 1 , true > > & ) ; template DLLEXPORT TransformSpatial < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > > > :: type transformSpatialForce < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > >> ( const Eigen :: Isometry3d & , const Eigen :: MatrixBase < Map < Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 0 , Stride < 0 , 0 > > > & ) ; template DLLEXPORT GradientVar < double , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const Gradient < Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & I ) ; template DLLEXPORT GradientVar < double , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const Gradient < Eigen :: Transform < double , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < Eigen :: MatrixXd > & I ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & b , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Vector4d > & ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Map < Vector4d > > & ) ; template DLLEXPORT Gradient < Matrix3d , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & ) ; template DLLEXPORT Gradient < Vector3d , Dynamic > :: type drotmat2rpy ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , Dynamic > > & ) ; template DLLEXPORT Gradient < Vector3d , 6 > :: type drotmat2rpy ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , 6 > > & ) ; template DLLEXPORT Gradient < Vector4d , Dynamic > :: type drotmat2quat ( const Eigen :: MatrixBase < Matrix3d > & , const Eigen :: MatrixBase < Matrix < double , RotmatSize , Dynamic > > & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Eigen :: Vector3d > & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Vector3d > & a , const Eigen :: MatrixBase < Vector3d > & b , const Gradient < Vector3d , Eigen :: Dynamic > :: type & da , const Gradient < Vector3d , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > > & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > , 3 , 1 , true > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true >> & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false >> & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 >> & b , const Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , 3 , 1 , false > , Eigen :: Dynamic > :: type & da , const Gradient < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , Eigen :: Dynamic > :: type & db ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > > const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < double , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > > const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > const , 3 , 1 , false > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , 3 , 1 , 0 , 3 , 1 > , 3 , 1 , true > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT Eigen :: Matrix < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > :: Scalar , 3 , - 1 , 0 , 3 , - 1 > dcrossProduct < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > ( Eigen :: MatrixBase < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > > const & , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > > const & , Gradient < Eigen :: Block < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 3 , - 1 , false > , 3 , 1 , true > , - 1 , 1 > :: type const & , Gradient < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , 3 , 1 , false > , - 1 , 1 > :: type const & ) ; template DLLEXPORT DHomogTrans < MatrixXd > :: type dHomogTrans ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT DHomogTrans < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic >> :: type dHomogTransInv ( const Isometry3d & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialMotion ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , 1 > , Dynamic , 1 > :: type dTransformSpatialMotion ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , 1 > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , 1 >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic >> :: type crossSpatialMotion ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , Eigen :: Dynamic > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , 1 >> :: type crossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & b ) ; template DLLEXPORT TransformSpatial < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE >> :: type crossSpatialForce ( const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , 1 > > & a , const Eigen :: MatrixBase < Eigen :: Matrix < double , TWIST_SIZE , TWIST_SIZE > > & b ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialForce ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < Matrix < double , HOMOGENEOUS_TRANSFORM_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Matrix < double , TWIST_SIZE , Dynamic > , Dynamic , 1 > :: type dTransformSpatialForce ( const Isometry3d & , const MatrixBase < Matrix < double , TWIST_SIZE , Dynamic > > & , const MatrixBase < MatrixXd > & , const MatrixBase < MatrixXd > & ) ; template DLLEXPORT Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > > & X , const Eigen :: MatrixBase < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 > > & dT , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > , 6 , - 1 , true > > & dX ) ; template DLLEXPORT Gradient < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 > , Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 > :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Isometry3d & T , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , 1 , 0 , 6 , 1 >> & X , const Eigen :: MatrixBase < Eigen :: Matrix < double , 16 , - 1 , 0 , 16 , - 1 >> & dT , const Eigen :: MatrixBase < Eigen :: Matrix < double , 6 , - 1 , 0 , 6 , - 1 >> & dX ) ; template DLLEXPORT void cylindrical2cartesian ( const Matrix < double , 3 , 1 > & cylinder_axis , const Matrix < double , 3 , 1 > & cylinder_x_dir , const Matrix < double , 3 , 1 > & cylinder_origin , const Matrix < double , 6 , 1 > & x_cylinder , const Matrix < double , 6 , 1 > & v_cylinder , Matrix < double , 6 , 1 > & x_cartesian , Matrix < double , 6 , 1 > & v_cartesian , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & Jdotv ) ; template DLLEXPORT void cartesian2cylindrical ( const Matrix < double , 3 , 1 > & cylinder_axis , const Matrix < double , 3 , 1 > & cylinder_x_dir , const Matrix < double , 3 , 1 > & cylinder_origin , const Matrix < double , 6 , 1 > & x_cartesian , const Matrix < double , 6 , 1 > & v_cartesian , Matrix < double , 6 , 1 > & x_cylinder , Matrix < double , 6 , 1 > & v_cylinder , Matrix < double , 6 , 6 > & J , Matrix < double , 6 , 1 > & Jdotv ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Vector4d > & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Map < Vector4d >> & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2quatdotMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q , Eigen :: MatrixBase < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > > & M , Eigen :: MatrixBase < Gradient < Matrix < double , QUAT_SIZE , SPACE_DIMENSION > , QUAT_SIZE , 1 > :: type > * dM ) ; template DLLEXPORT void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Matrix < double , RPY_SIZE , SPACE_DIMENSION > > & phi , Eigen :: MatrixBase < Gradient < Matrix < double , RPY_SIZE , SPACE_DIMENSION > , RPY_SIZE , 1 > :: type > * dphi , Eigen :: MatrixBase < Gradient < Matrix < double , RPY_SIZE , SPACE_DIMENSION > , RPY_SIZE , 2 > :: type > * ddphi ) ; template DLLEXPORT void angularvel2rpydotMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Matrix < double , RPY_SIZE , SPACE_DIMENSION > > & phi , Eigen :: MatrixBase < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * dphi , Eigen :: MatrixBase < Matrix < double , Eigen :: Dynamic , Eigen :: Dynamic > > * ddphi ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Vector3d > & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Map < Vector3d >> & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT void rpydot2angularvelMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 3 , 1 , false > > & rpy , Eigen :: MatrixBase < Eigen :: Matrix < double , SPACE_DIMENSION , RPY_SIZE > > & E , Gradient < Matrix < double , SPACE_DIMENSION , RPY_SIZE > , RPY_SIZE , 1 > :: type * dE ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < VectorXd > & qrot , int gradient_order ) ; template DLLEXPORT GradientVar < double , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > , - 1 , 1 , false > > & qrot , int gradient_order ) ; template DLLEXPORT GradientVar < double , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT GradientVar < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > :: Scalar , - 1 , 3 > angularvel2RepresentationDotMatrix < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > ( int , Eigen :: MatrixBase < Eigen :: Block < Eigen :: Matrix < double , - 1 , - 1 , 0 , - 1 , - 1 > const , - 1 , 1 , false > > const & , int ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Vector4d > & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Map < Vector4d >> & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; template DLLEXPORT void quatdot2angularvelMatrix ( const Eigen :: MatrixBase < Eigen :: Block < Eigen :: Ref < Eigen :: Matrix < double , - 1 , 1 , 0 , - 1 , 1 > const , 0 , Eigen :: InnerStride < 1 > > const , 4 , 1 , false > > & q , Eigen :: MatrixBase < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > > & M , Gradient < Matrix < double , SPACE_DIMENSION , QUAT_SIZE > , QUAT_SIZE , 1 > :: type * dM ) ; </DOCUMENT>
<DOCUMENT_ID="y@@ xcoin@@ /y@@ xcoin@@ /tree/master/src/boost_1_@@ 55_0/libs/@@ phoenix/test/include/@@ stl/@@ algorithm/@@ querying.cpp"> # include < boost / phoenix / stl / algorithm / querying . hpp > int main ( ) { } </DOCUMENT>
<DOCUMENT_ID="as@@ urad@@ aimao/@@ dolphin/tree/master/Source/Core/@@ Core/PowerPC/@@ Interpreter/@@ Interpreter_@@ Integer.cpp"> # include " Core / PowerPC / Interpreter / Interpreter . h " void Interpreter :: Helper_UpdateCR0 ( u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ 0 ] = cr_val ; } void Interpreter :: Helper_UpdateCRx ( int idx , u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ idx ] = cr_val ; } u32 Interpreter :: Helper_Carry ( u32 _uValue1 , u32 _uValue2 ) { return _uValue2 > ( ~ _uValue1 ) ; } u32 Interpreter :: Helper_Mask ( int mb , int me ) { u32 begin = 0xFFFFFFFF >> mb ; u32 end = me < 31 ? ( 0xFFFFFFFF >> ( me + 1 ) ) : 0 ; u32 mask = begin ^ end ; if ( me < mb ) return ~ mask ; else return mask ; } void Interpreter :: addi ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + _inst . SIMM_16 ; else rGPR [ _inst . RD ] = _inst . SIMM_16 ; } void Interpreter :: addic ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 imm = ( u32 ) ( s32 ) _inst . SIMM_16 ; rGPR [ _inst . RD ] = a + imm ; SetCarry ( Helper_Carry ( a , imm ) ) ; } void Interpreter :: addic_rc ( UGeckoInstruction _inst ) { addic ( _inst ) ; Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addis ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + ( _inst . SIMM_16 << 16 ) ; else rGPR [ _inst . RD ] = ( _inst . SIMM_16 << 16 ) ; } void Interpreter :: andi@@ _rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & _inst . UIMM ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andi@@ s_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ( ( u32 ) _inst . UIMM << 16 ) ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmpi ( UGeckoInstruction _inst ) { Helper_UpdateCRx ( _inst . CRFD , rGPR [ _inst . RA ] - _inst . SIMM_16 ) ; } void Interpreter :: cmpl@@ i ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = _inst . UIMM ; int f ; if ( a < b ) f = 0x8 ; else if ( a > b ) f = 0x4 ; else f = 0x2 ; if ( GetXER_SO ( ) ) f |= 0x1 ; SetCRField ( _inst . CRFD , f ) ; } void Interpreter :: mulli ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( s32 ) rGPR [ _inst . RA ] * _inst . SIMM_16 ; } void Interpreter :: ori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | _inst . UIMM ; } void Interpreter :: oris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( _inst . UIMM << 16 ) ; } void Interpreter :: subfic ( UGeckoInstruction _inst ) { s32 immediate = _inst . SIMM_16 ; rGPR [ _inst . RD ] = immediate - ( int ) rGPR [ _inst . RA ] ; SetCarry ( ( rGPR [ _inst . RA ] == 0 ) || ( Helper_Carry ( 0 - rGPR [ _inst . RA ] , immediate ) ) ) ; } void Interpreter :: twi ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = _inst . SIMM_16 ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " twi ▁ rA ▁ % x ▁ SIMM ▁ % x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xor@@ i ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ _inst . UIMM ; } void Interpreter :: xor@@ is ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ ( _inst . UIMM << 16 ) ; } void Interpreter :: rlw@@ imix ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = ( rGPR [ _inst . RA ] & ~ mask ) | ( _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rl@@ winmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: rl@@ wnmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , rGPR [ _inst . RB ] & 0x1F ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: andcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ~ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: cmp ( UGeckoInstruction _inst ) { s32 a = ( s32 ) rGPR [ _inst . RA ] ; s32 b = ( s32 ) rGPR [ _inst . RB ] ; int fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cmpl ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; } void Interpreter :: cntlz@@ wx ( UGeckoInstruction _inst ) { u32 val = rGPR [ _inst . RS ] ; u32 mask = 0x80000000 ; int i = 0 ; for ( ; i < 32 ; i ++ , mask >>= 1 ) { if ( val & mask ) break ; } rGPR [ _inst . RA ] = i ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: eq@@ vx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extsb@@ x ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s8 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: extshx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s16 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: nandx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: norx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: orcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( ~ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: slwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : rGPR [ _inst . RS ] << ( amount & 0x1f ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: sraw@@ x ( UGeckoInstruction _inst ) { int rb = rGPR [ _inst . RB ] ; if ( rb & 0x20 ) { if ( rGPR [ _inst . RS ] & 0x80000000 ) { rGPR [ _inst . RA ] = 0xFFFFFFFF ; SetCarry ( 1 ) ; } else { rGPR [ _inst . RA ] = 0x00000000 ; SetCarry ( 0 ) ; } } else { int amount = rb & 0x1f ; if ( amount == 0 ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; SetCarry ( 0 ) ; } else { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: sraw@@ ix ( UGeckoInstruction _inst ) { int amount = _inst . SH ; if ( amount != 0 ) { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } else { SetCarry ( 0 ) ; rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: srwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : ( rGPR [ _inst . RS ] >> ( amount & 0x1f ) ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: tw ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " tw ▁ rA ▁ % 0x ▁ rB ▁ % 0x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } } void Interpreter :: xor@@ x ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; } void Interpreter :: addx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + rGPR [ _inst . RB ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b ; SetCarry ( Helper_Carry ( a , b ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; int b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b + carry ; SetCarry ( Helper_Carry ( a , b ) || ( carry != 0 && Helper_Carry ( a + b , carry ) ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addmex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry - 1 ; SetCarry ( Helper_Carry ( a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: addzex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry ; SetCarry ( Helper_Carry ( a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwx ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; if ( b == 0 || ( ( u32 ) a == 0x80000000 && b == - 1 ) ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwx " ) ; } if ( ( ( u32 ) a & 0x80000000 ) && b == 0 ) rGPR [ _inst . RD ] = - 1 ; else rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = ( u32 ) ( a / b ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: divwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; if ( b == 0 ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwux " ) ; } rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = a / b ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulh@@ wx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( u64 ) ( ( ( s64 ) ( s32 ) a * ( s64 ) ( s32 ) b ) ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mulh@@ wux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( ( u64 ) a * ( u64 ) b ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: mullwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( s32 ) a * ( s32 ) b ) ; rGPR [ _inst . RD ] = d ; if ( _inst . OE ) PanicAlert ( " OE : ▁ mullwx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: negx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( ~ rGPR [ _inst . RA ] ) + 1 ; if ( rGPR [ _inst . RD ] == 0x80000000 ) { if ( _inst . OE ) PanicAlert ( " OE : ▁ negx " ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RB ] - rGPR [ _inst . RA ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = b - a ; SetCarry ( a == 0 || Helper_Carry ( b , 0 - a ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + b + carry ; SetCarry ( Helper_Carry ( ~ a , b ) || Helper_Carry ( ( ~ a ) + b , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfmex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry - 1 ; SetCarry ( Helper_Carry ( ~ a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } void Interpreter :: subfzex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry ; SetCarry ( Helper_Carry ( ~ a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; } </DOCUMENT>
<DOCUMENT_ID="sofa@@ -frame@@ work/sofa@@ /tree/master/applic@@ ations/@@ plugins/@@ Sofa@@ Python/PythonScriptController@@ .cpp"> # include " PythonMacros . h " # include " PythonScriptController . h " # include < sofa / core / ObjectFactory . h > # include < sofa / helper / AdvancedTimer . h > using sofa :: helper :: AdvancedTimer ; using sofa :: core :: objectmodel :: Base ; using sofa :: simulation :: Node ; # include " Binding _ PythonScriptController . h " using sofa :: simulation :: PythonEnvironment ; # include " PythonScriptEvent . h " using sofa :: core :: objectmodel :: PythonScriptEvent ; # include < sofa / helper / system / FileMonitor . h > using sofa :: helper :: system :: FileMonitor ; using sofa :: helper :: system :: FileEventListener ; # include < sofa / core / objectmodel / IdleEvent . h > using sofa :: core :: objectmodel :: IdleEvent ; # include " PythonFactory . h " struct ActivableScopedAdvancedTimer { const char * message ; bool m_active ; Base * m_base ; ActivableScopedAdvancedTimer ( bool active , const char * message , Base * base ) : message ( message ) , m_active ( active ) , m_base ( base ) { if ( m_active ) AdvancedTimer :: stepBegin ( message , m_base ) ; } ~ ActivableScopedAdvancedTimer ( ) { if ( m_active ) AdvancedTimer :: stepEnd ( message , m_base ) ; } } ; namespace sofa { namespace component { namespace controller { class MyFileEventListener : public FileEventListener { PythonScriptController * m_controller ; public : MyFileEventListener ( PythonScriptController * psc ) { m_controller = psc ; } ~ MyFileEventListener ( ) override { } virtual void fileHasChanged ( const std :: string & filepath ) override { PythonEnvironment :: gil lock { __func__ } ; if ( ! m_controller -> scriptController@@ Instance ( ) ) { m_controller -> doLoadScript ( ) ; } else { PythonEnvironment :: gil state { __func__ } ; std :: string file = filepath ; SP_CALL_FILE@@ FUNC ( const_cast < char * > ( " onRe@@ impAFile " ) , const_cast < char * > ( " s " ) , const_cast < char * > ( file . data ( ) ) ) ; m_controller -> refreshBinding ( ) ; } } } ; int PythonScriptController@@ Class = core :: RegisterObject ( " A ▁ Sofa ▁ controller ▁ scripted ▁ in ▁ python " ) . add < PythonScriptController > ( ) ; PythonScriptController :: PythonScriptController ( ) : ScriptController ( ) , m_filename ( initData ( & m_filename , " filename " , " Python ▁ script ▁ filename " ) ) , m_classname ( initData ( & m_classname , " classname " , " Python ▁ class ▁ implemented ▁ in ▁ the ▁ script ▁ to ▁ instanci@@ ate ▁ for ▁ the ▁ controller " ) ) , m_variables ( initData ( & m_variables , " variables " , " Array ▁ of ▁ string ▁ variables ▁ ( equiv@@ alent ▁ to ▁ a ▁ c - like ▁ argv ) " ) ) , m_timingEnabled ( initData ( & m_timingEnabled , true , " timingEnabled " , " Set ▁ this ▁ attribute ▁ to ▁ true ▁ or ▁ false ▁ to ▁ activate / deactivate ▁ the ▁ gather@@ ing " " ▁ of ▁ timing ▁ statistics ▁ on ▁ the ▁ python ▁ execution ▁ time . ▁ Default ▁ value ▁ is ▁ set " " to ▁ true . " ) ) , m_doAutoReload ( initData ( & m_doAutoReload , false , " aut@@ oreload " , " Automatic@@ ally ▁ reload ▁ the ▁ file ▁ when ▁ the ▁ source ▁ code ▁ is ▁ changed . ▁ " " Default ▁ value ▁ is ▁ set ▁ to ▁ false " ) ) , m_ScriptControllerClass ( nullptr ) , m_ScriptControllerInstance ( nullptr ) { m_filelistener = new MyFileEventListener ( this ) ; } PythonScriptController :: ~ PythonScriptController ( ) { if ( m_filelistener ) { FileMonitor :: removeListener ( m_filelistener ) ; delete m_filelistener ; } } void PythonScriptController :: setInstance ( PyObject * instance ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_ScriptControllerInstance ) { Py_DECREF ( m_ScriptControllerInstance ) ; } m_ScriptControllerInstance = instance ; m_ScriptControllerClass = ( PyObject * ) instance -> ob_type ; Py_INCRE@@ F ( instance ) ; refreshBinding ( ) ; } void PythonScriptController :: refreshBinding ( ) { BIND_OBJECT_METHOD ( onLoaded ) BIND_OBJECT_METHOD ( createGraph ) BIND_OBJECT_METHOD ( initGraph ) BIND_OBJECT_METHOD ( bwdInitGraph ) BIND_OBJECT_METHOD ( onKeyPressed ) BIND_OBJECT_METHOD ( onKeyReleased ) BIND_OBJECT_METHOD ( onMouseMove ) BIND_OBJECT_METHOD ( onMouseButtonLeft ) BIND_OBJECT_METHOD ( onMouseButtonRight ) BIND_OBJECT_METHOD ( onMouseButtonMiddle ) BIND_OBJECT_METHOD ( onMouseWheel ) BIND_OBJECT_METHOD ( onBeginAnimationStep ) BIND_OBJECT_METHOD ( onEndAnimationStep ) BIND_OBJECT_METHOD ( storeResetState ) BIND_OBJECT_METHOD ( reset ) BIND_OBJECT_METHOD ( cleanup ) BIND_OBJECT_METHOD ( onGUIEvent ) BIND_OBJECT_METHOD ( onScriptEvent ) BIND_OBJECT_METHOD ( draw ) BIND_OBJECT_METHOD ( onIdle ) } bool PythonScriptController :: isDerived@@ From ( const std :: string & name , const std :: string & module ) { PythonEnvironment :: gil lock ( __func__ ) ; PyObject * moduleDict = PyModule_GetDict ( PyImport_AddModule ( module . c_str ( ) ) ) ; PyObject * controllerClass = PyDict_GetItemString ( moduleDict , name . c_str ( ) ) ; return 1 == PyObject_Is@@ Instance ( m_ScriptControllerInstance , controllerClass ) ; } void PythonScriptController :: loadScript ( ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_doAutoReload . getValue ( ) ) { FileMonitor :: addFile ( m_filename . getFullPath ( ) , m_filelistener ) ; } if ( m_filename . isSet ( ) && ! m_filename . getRe@@ lative@@ Path ( ) . empty ( ) && ! PythonEnvironment :: runFile ( m_filename . getFullPath ( ) . c_str ( ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( file ▁ ' " << m_filename . getFullPath ( ) . c_str ( ) << " ' ▁ not ▁ parsable ) " ; return ; } PyObject * pDict = PyModule_GetDict ( PyImport_AddModule ( " _ _ main _ _ " ) ) ; m_ScriptControllerClass = PyDict_GetItemString ( pDict , m_classname . getValueString ( ) . c_str ( ) ) ; if ( ! m_ScriptControllerClass ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ not ▁ found ) . " ; return ; } if ( 1 != PyObject_Is@@ Subclass ( m_ScriptControllerClass , ( PyObject * ) & SP_SOF@@ APYTYPE@@ OBJECT ( PythonScriptController ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ does ▁ not ▁ inher@@ it ▁ from ▁ ' Sofa . PythonScriptController ' ) . " ; return ; } m_ScriptControllerInstance = BuildPySPtr < Base > ( this , ( PyTypeObject * ) m_ScriptControllerClass ) ; if ( ! m_ScriptControllerInstance ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ instanci@@ ation ▁ error ) . " ; return ; } refreshBinding ( ) ; } void PythonScriptController :: doLoadScript ( ) { loadScript ( ) ; } void PythonScriptController :: script_onIdleEvent ( const IdleEvent * ) { FileMonitor :: updates ( 0 ) ; { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_onIdle ) ; } std :: cout . flush ( ) ; std :: cerr . flush ( ) ; } void PythonScriptController :: script_onLoaded ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onLoaded , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_createGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_createGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_initGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_initGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } void PythonScriptController :: script_bwdInitGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_bwdInitGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) } bool PythonScriptController :: script_onKeyPressed ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyPressed " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyPressed , " ( c ) " , c ) ; return b ; } bool PythonScriptController :: script_onKeyReleased ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyReleased " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyReleased , " ( c ) " , c ) ; return b ; } void PythonScriptController :: script_onMouseMove ( const int posX , const int posY ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseMove " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseMove , " ( ii ) " , posX , posY ) ; } void PythonScriptController :: script_onMouseButtonLeft ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonLeft " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonLeft , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonRight ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonRight " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonRight , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseButtonMiddle ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonMiddle " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonMiddle , " ( iiO ) " , posX , posY , pyPressed ) } void PythonScriptController :: script_onMouseWheel ( const int posX , const int posY , const int delta ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseWheel " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseWheel , " ( iii ) " , posX , posY , delta ) } void PythonScriptController :: script_onBeginAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onBeginAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onBeginAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_onEndAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onEndAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onEndAnimationStep , " ( d ) " , dt ) } void PythonScriptController :: script_storeResetState ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_storeResetState ) } void PythonScriptController :: script_reset ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_reset ) } void PythonScriptController :: script_cleanup ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_cleanup ) } void PythonScriptController :: script_onGUIEvent ( const char * controlID , const char * valueName , const char * value ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onGUIEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onGUIEvent , " ( sss ) " , controlID , valueName , value ) ; } void PythonScriptController :: script_onScriptEvent ( core :: objectmodel :: ScriptEvent * event ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onScriptEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PythonScriptEvent * pyEvent = static_cast < PythonScriptEvent * > ( event ) ; SP_CALL_MODULEFUNC ( m_Func_onScriptEvent , " ( OsO ) " , sofa :: PythonFactory :: toPython ( pyEvent -> getSender ( ) . get ( ) ) , pyEvent -> getEvent@@ Name ( ) . c_str ( ) , pyEvent -> getUserData ( ) ) ; } void PythonScriptController :: script_d@@ raw ( const core :: visual :: Visual@@ Params * ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ draw " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_draw ) ; } void PythonScriptController :: handleEvent ( core :: objectmodel :: Event * event ) { if ( PythonScriptEvent :: checkEventType ( event ) ) { script_onScriptEvent ( static_cast < PythonScriptEvent * > ( event ) ) ; } else { ScriptController :: handleEvent ( event ) ; } } } } } </DOCUMENT>
<DOCUMENT_ID="nau@@ coin/CTK/tree/master/Libs/@@ Widgets/@@ Testing/@@ Cpp/ctkExampleUseOfWorkflowWidget@@ UsingSignalsAndSlot@@ s.cpp"> # include < QApplication > # include < QTimer > # include " ctkWorkflow . h " # include " ctkWorkflowTabWidget . h " # include " ctkWorkflowWidgetStep . h " # include " ctkWorkflowGroupBox . h " # include " ctkExampleWorkflowWidgetStepUsingSignalsAndSlots . h " # include < cstdlib > # include < iostream > int ctkExampleUseOfWorkflowWidget@@ UsingSignalsAndSlots ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; bool hideWidgets = false ; ctkWorkflow * workflow = new ctkWorkflow ; ctkWorkflowTabWidget * workflowWidget = new ctkWorkflowTabWidget ; workflowWidget -> setWorkflow ( workflow ) ; ctkWorkflowGroupBox * groupBox = workflowWidget -> workflowGroupBox ( ) ; groupBox -> setPre@@ Text ( " I ▁ am ▁ some ▁ pre - text " ) ; groupBox -> setPost@@ Text ( " I ▁ am ▁ some ▁ post - text " ) ; groupBox -> setHide@@ WidgetsOf@@ NonCurrent@@ Steps ( hideWidgets ) ; ctkWorkflowWidgetStep * testStep1 = new ctkWorkflowWidgetStep ( " Step ▁ 1" ) ; testStep1 -> setName ( " Step ▁ 1" ) ; testStep1 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 1" ) ; workflowWidget -> associateStepWithLabel ( testStep1 , " name ▁ 1" ) ; ctkWorkflowWidgetStep * testStep2 = new ctkWorkflowWidgetStep ( " Step ▁ 2" ) ; testStep2 -> setName ( " Step ▁ 2" ) ; testStep2 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 2" ) ; workflowWidget -> associateStepWithLabel ( testStep2 , " name ▁ 2" ) ; ctkWorkflowWidgetStep * testStep3 = new ctkWorkflowWidgetStep ( " Step ▁ 3" ) ; testStep3 -> setName ( " Step ▁ 3" ) ; testStep3 -> setDescription ( " I ▁ am ▁ in ▁ step ▁ 3" ) ; workflowWidget -> associateStepWith@@ Page ( testStep3 , 1 , " name ▁ 3" ) ; workflow -> addTransition ( testStep1 , testStep2 ) ; workflow -> addTransition ( testStep2 , testStep3 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject1 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep1 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject2 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep2 ) ; ctkExampleWorkflowWidgetStepUsingSignalsAndSlots * qObject3 = new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots ( testStep3 ) ; qObject1 -> setWidget ( testStep1 -> stepArea ( ) ) ; qObject2 -> setWidget ( testStep2 -> stepArea ( ) ) ; qObject3 -> setWidget ( testStep3 -> stepArea ( ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject1 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject2 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeValidateCommand ( QString ) ) , qObject3 , SLOT ( validate ( QString ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnEntryCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onEntry ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject1 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject2 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeOnExitCommand ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) , qObject3 , SLOT ( onExit ( const ctkWorkflowStep * , ctkWorkflowInterstepTransition :: InterstepTransitionType ) ) ) ; QObject :: connect ( testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject1 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject1 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep1 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject2 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject2 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep2 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; QObject :: connect ( testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( invokeCreateUserInterfaceCommand ( ) ) , qObject3 , SLOT ( createUserInterface ( ) ) ) ; QObject :: connect ( qObject3 , SIGNAL ( createUserInterfaceComplete ( ) ) , testStep3 -> ctkWorkflowStepQObject ( ) , SIGNAL ( showUserInterfaceComplete ( ) ) ) ; testStep1 -> setHasValidateCommand ( 1 ) ; testStep1 -> setHasOnEntryCommand ( 1 ) ; testStep1 -> setHasOnExitCommand ( 1 ) ; testStep1 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep2 -> setHasValidateCommand ( 1 ) ; testStep2 -> setHasOnEntryCommand ( 1 ) ; testStep2 -> setHasOnExitCommand ( 1 ) ; testStep2 -> setHasCreateUserInterfaceCommand ( 1 ) ; testStep3 -> setHasValidateCommand ( 1 ) ; testStep3 -> setHasOnEntryCommand ( 1 ) ; testStep3 -> setHasOnExitCommand ( 1 ) ; testStep3 -> setHasCreateUserInterfaceCommand ( 1 ) ; workflow -> setInitial@@ Step ( testStep1 ) ; workflow -> start ( ) ; workflowWidget -> show ( ) ; QTimer :: singleShot ( 500 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; workflow -> stop ( ) ; QTimer :: singleShot ( 100 , & app , SLOT ( quit ( ) ) ) ; app . exec ( ) ; delete workflowWidget ; return EXIT_SUCCESS ; } </DOCUMENT>
<DOCUMENT_ID="Ashamane@@ Project/@@ Ashamane@@ Core/tree/master/dep@@ /Casc@@ Lib/src/@@ CascDe@@ compress.cpp"> # define __CAS@@ CLIB@@ _SEL@@ F__ # include " Casc@@ Lib . h " # include " Casc@@ Common . h " DWORD CascDe@@ compress ( LPBYTE pbOutBuffer , PDWORD pcbOutBuffer , LPBYTE pbInBuffer , DWORD cbInBuffer ) { z_@@ stream z ; DWORD dwErrCode = ERROR_FILE_@@ CORRUP@@ T ; uInt cbOutBuffer = * pcbOutBuffer ; int nResult ; z . next_in = pbInBuffer ; z . avai@@ l_in = cbInBuffer ; z . total_in = cbInBuffer ; z . next_out = pbOutBuffer ; z . avai@@ l_out = cbOutBuffer ; z . total_out = 0 ; z . zalloc = NULL ; z . zfree = NULL ; cbOutBuffer = 0 ; if ( ( nResult = inflate@@ Init ( & z ) ) == Z_OK ) { nResult = inf@@ late ( & z , Z_NO@@ _FL@@ USH ) ; if ( nResult == Z_OK || nResult == Z_STREAM_@@ END ) { cbOutBuffer = z . total_out ; dwErrCode = ERROR_SUCCESS ; } inflate@@ End ( & z ) ; } pcbOutBuffer [ 0 ] = cbOutBuffer ; return dwErrCode ; } </DOCUMENT>
<DOCUMENT_ID="dd@@ ark/@@ ecl/tree/master/src/server/scripts/@@ Northrend/@@ zone_wintergrasp.cpp"> # include " BattlefieldMgr . h " # include " BattlefieldWG . h " # include " Battlefield . h " # include " ScriptSystem . h " # include " WorldSession . h " # include " ObjectMgr . h " # include " Vehicle . h " # include " GameObjectAI . h " # include " ScriptedCreature . h " # include " ScriptedGossip . h " # include " SpellScript . h " # include " Player . h " # define GOSSIP_HELLO_DEMO1 " Build ▁ catapult . " # define GOSSIP_HELLO_DEMO2 " Build ▁ demolisher . " # define GOSSIP_HELLO_DEMO3 " Build ▁ siege ▁ engine . " # define GOSSIP_HELLO_DEMO4 " I ▁ cannot ▁ build ▁ more ! " enum WG@@ queuenpctext { WG_NPCQUEUE_TEXT_H_NOWAR = 14775 , WG_NPCQUEUE_TEXT_H_QUEUE = 14790 , WG_NPCQUEUE_TEXT_H_WAR = 14777 , WG_NPCQUEUE_TEXT_A_NOWAR = 14782 , WG_NPCQUEUE_TEXT_A_QUEUE = 14791 , WG_NPCQUEUE_TEXT_A_WAR = 14781 , WG_NPCQUEUE_TEXTOPTION_JOIN = 20077 , } ; enum Spells { SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE = 6140@@ 9 , SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE = 56662 , SPELL_BUILD_CATAPULT_FORCE = 56664 , SPELL_BUILD_DEMOLISHER_FORCE = 56659 , SPELL_ACTIVATE_CONTROL_ARMS = 49899 , SPELL_RIDE_WG_VEHICLE = 60968 , SPELL_VEHICLE_TELEPORT = 4975@@ 9 , SPELL_CHANNEL_SPIRIT_HEAL = 22011 , } ; enum CreatureIds { NPC_GOBLIN_MECHANIC = 30400 , NPC_GNOMISH_ENGINEER = 30499 , NPC_WINTERGRASP_CONTROL_ARMS = 27852 , NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC = 23472 , } ; enum QuestIds { QUEST_BONES_AND_ARROWS_HORDE_ATT = 131@@ 93 , QUEST_JINXING_THE_WALLS_HORDE_ATT = 13202 , QUEST_SLAY_THEM_ALL_HORDE_ATT = 131@@ 80 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT = 13200 , QUEST_HEALING_WITH_ROSES_HORDE_ATT = 13201 , QUEST_DEFEND_THE_SIEGE_HORDE_ATT = 13223 , QUEST_BONES_AND_ARROWS_HORDE_DEF = 1319@@ 9 , QUEST_WARDING_THE_WALLS_HORDE_DEF = 13192 , QUEST_SLAY_THEM_ALL_HORDE_DEF = 13178 , QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF = 1319@@ 1 , QUEST_HEALING_WITH_ROSES_HORDE_DEF = 13194 , QUEST_TOPPLING_THE_TOWERS_HORDE_DEF = 13539 , QUEST_STOP_THE_SIEGE_HORDE_DEF = 131@@ 85 , QUEST_BONES_AND_ARROWS_ALLIANCE_ATT = 13196 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT = 1319@@ 8 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT = 13179 , QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT = 13222 , QUEST_A_RARE_HERB_ALLIANCE_ATT = 13195 , QUEST_BONES_AND_ARROWS_ALLIANCE_DEF = 13154 , QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF = 13153 , QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF = 13177 , QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF = 13538 , QUEST_STOP_THE_SIEGE_ALLIANCE_DEF = 131@@ 86 , QUEST_A_RARE_HERB_ALLIANCE_DEF = 13156 , } ; uint8 const MAX_WINTERGRASP_VEHICLES = 4 ; uint32 const vehiclesList [ MAX_WINTERGRASP_VEHICLES ] = { NPC_WINTERGRASP_@@ CATAP@@ ULT , NPC_WINTERGRASP_@@ DEMOLISHER , NPC_WINTERGRASP_SIEGE_ENGINE_@@ ALLIANCE , NPC_WINTERGRASP_SIEGE_ENGINE_@@ HORDE } ; class npc_wg_demolisher_engineer : public CreatureScript { public : npc_wg_demolisher_engineer ( ) : CreatureScript ( " npc _ wg _ demolisher _ engineer " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; if ( CanBuild ( creature ) ) { if ( player -> HasAura ( SPELL_COR@@ PORAL ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; else if ( player -> HasAura ( SPELL_LIEUT@@ ENAN@@ T ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO1 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO2 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 1 ) ; player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO3 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 2 ) ; } } else player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , GOSSIP_HELLO_DEMO4 , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + 9 ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * creature , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; if ( CanBuild ( creature ) ) { switch ( action - GOSSIP_ACTION_INFO_DEF ) { case 0 : creature -> CastSpell ( player , SPELL_BUILD_CATAPULT_FORCE , true ) ; break ; case 1 : creature -> CastSpell ( player , SPELL_BUILD_DEMOLISHER_FORCE , true ) ; break ; case 2 : creature -> CastSpell ( player , player -> GetTeamId ( ) == TEAM_ALLIANCE ? SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE : SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE , true ) ; break ; } if ( Creature * controlArms = creature -> FindNearestCreature ( NPC_WINTERGRASP_CONTROL_ARMS , 30.0f , true ) ) creature -> CastSpell ( controlArms , SPELL_ACTIVATE_CONTROL_ARMS , true ) ; } return true ; } private : bool CanBuild ( Creature * creature ) { Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return false ; switch ( creature -> GetEntry ( ) ) { case NPC_GOBLIN_MECHANIC : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_@@ H ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_@@ H ) ) ; case NPC_GNOMISH_ENGINEER : return ( wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_MAX_VEHICLE_@@ A ) > wintergrasp -> GetData ( BATTLEFIELD_WG_DATA_VEHICLE_@@ A ) ) ; default : return false ; } } } ; class npc_wg_spirit_guide : public CreatureScript { public : npc_wg_spirit_guide ( ) : CreatureScript ( " npc _ wg _ spirit _ guide " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; GraveyardVect graveyard = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < graveyard . size ( ) ; i ++ ) if ( graveyard [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( ( ( BfGraveyard@@ WG * ) graveyard [ i ] ) -> GetText@@ Id ( ) ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF + i ) ; player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 action ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( wintergrasp ) { GraveyardVect gy = wintergrasp -> GetGraveyardVector ( ) ; for ( uint8 i = 0 ; i < gy . size ( ) ; i ++ ) if ( action - GOSSIP_ACTION_INFO_DEF == i && gy [ i ] -> GetControlTeamId ( ) == player -> GetTeamId ( ) ) if ( WorldSafeLocsEntry const * safeLoc = sWorldSafeLocsStore . LookupEntry ( gy [ i ] -> GetGraveyard@@ Id ( ) ) ) player -> TeleportTo ( safeLoc -> map_id , safeLoc -> x , safeLoc -> y , safeLoc -> z , 0 ) ; } return true ; } struct npc_wg_spirit_guideAI : public ScriptedAI { npc_wg_spirit_guideAI ( Creature * creature ) : ScriptedAI ( creature ) { } void UpdateAI ( uint32 ) OVERRIDE { if ( ! me -> HasUnitState ( UNIT_STATE_CASTING ) ) DoCast ( me , SPELL_CHANNEL_SPIRIT_HEAL ) ; } } ; CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new npc_wg_spirit_guideAI ( creature ) ; } } ; class npc_wg_queue : public CreatureScript { public : npc_wg_queue ( ) : CreatureScript ( " npc _ wg _ queue " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR , creature -> GetGUID ( ) ) ; } else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; player -> SendUpdateWorldState ( 4354 , time ( NULL ) + timer ) ; if ( timer < 15 * MINUTE ) { player -> ADD_GOSSIP_ITEM ( GOSSIP_ICON_CHAT , sObjectMgr -> GetTrinityStringForDBCLocale ( WG_NPCQUEUE_TEXTOPTION_JOIN ) , GOSSIP_SENDER_MAIN , GOSSIP_ACTION_INFO_DEF ) ; player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE , creature -> GetGUID ( ) ) ; } else player -> SEND_GOSSIP_MENU ( wintergrasp -> GetDefenderTeam ( ) ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR , creature -> GetGUID ( ) ) ; } return true ; } bool OnGossipSelect ( Player * player , Creature * , uint32 , uint32 ) OVERRIDE { player -> CLOSE_GOSSIP_MENU ( ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( wintergrasp -> IsWarTime ( ) ) wintergrasp -> InvitePlayerTo@@ War ( player ) ; else { uint32 timer = wintergrasp -> GetTimer ( ) / 1000 ; if ( timer < 15 * MINUTE ) wintergrasp -> InvitePlayerTo@@ Queue ( player ) ; } return true ; } } ; class go_wg_vehicle_teleporter : public GameObjectScript { public : go_wg_vehicle_teleporter ( ) : GameObjectScript ( " go _ wg _ vehicle _ teleporter " ) { } struct go_wg_vehicle_teleporterAI : public GameObjectAI { go_wg_vehicle_teleporterAI ( GameObject * gameObject ) : GameObjectAI ( gameObject ) , _checkTimer ( 1000 ) { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( _checkTimer <= diff ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) for ( uint8 i = 0 ; i < MAX_WINTERGRASP_VEHICLES ; i ++ ) if ( Creature * vehicleCreature = go -> FindNearestCreature ( vehiclesList [ i ] , 3.0f , true ) ) if ( ! vehicleCreature -> HasAura ( SPELL_VEHICLE_TELEPORT ) && vehicleCreature -> getFaction ( ) == Wintergras@@ pF@@ action [ wg -> GetDefenderTeam ( ) ] ) if ( Creature * teleportTrigger = vehicleCreature -> FindNearestCreature ( NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC , 100.0f , true ) ) teleportTrigger -> CastSpell ( vehicleCreature , SPELL_VEHICLE_TELEPORT , true ) ; _checkTimer = 1000 ; } else _checkTimer -= diff ; } private : uint32 _checkTimer ; } ; GameObjectAI * GetAI ( GameObject * go ) const OVERRIDE { return new go_wg_vehicle_teleporterAI ( go ) ; } } ; class npc_wg_quest_giver : public CreatureScript { public : npc_wg_quest_giver ( ) : CreatureScript ( " npc _ wg _ quest _ giver " ) { } bool OnGossipHello ( Player * player , Creature * creature ) OVERRIDE { if ( creature -> IsQuestGiver ( ) ) player -> PrepareQuestMenu ( creature -> GetGUID ( ) ) ; Battlefield * wintergrasp = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ; if ( ! wintergrasp ) return true ; if ( creature -> IsQuestGiver ( ) ) { QuestRelationBounds objectQR = sObjectMgr -> GetCreature@@ QuestRelationBounds ( creature -> GetEntry ( ) ) ; QuestRelationBounds objectQIR = sObjectMgr -> GetCreature@@ QuestInvol@@ ved@@ RelationBounds ( creature -> GetEntry ( ) ) ; QuestMenu & qm = player -> PlayerTalkClass -> GetQuestMenu ( ) ; qm . ClearMenu ( ) ; for ( QuestRelations :: const_iterator i = objectQIR . first ; i != objectQIR . second ; ++ i ) { uint32 questId = i -> second ; QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( status == QUEST_STATUS_COMPLETE ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_INCOMPLETE ) qm . AddMenuItem ( questId , 4 ) ; } for ( QuestRelations :: const_iterator i = objectQR . first ; i != objectQR . second ; ++ i ) { uint32 questId = i -> second ; Quest const * quest = sObjectMgr -> GetQuest@@ Template ( questId ) ; if ( ! quest ) continue ; switch ( questId ) { case QUEST_BONES_AND_ARROWS_HORDE_ATT : case QUEST_JINXING_THE_WALLS_HORDE_ATT : case QUEST_SLAY_THEM_ALL_HORDE_ATT : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT : case QUEST_HEALING_WITH_ROSES_HORDE_ATT : case QUEST_DEFEND_THE_SIEGE_HORDE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_HORDE_DEF : case QUEST_WARDING_THE_WALLS_HORDE_DEF : case QUEST_SLAY_THEM_ALL_HORDE_DEF : case QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF : case QUEST_HEALING_WITH_ROSES_HORDE_DEF : case QUEST_TOPPLING_THE_TOWERS_HORDE_DEF : case QUEST_STOP_THE_SIEGE_HORDE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_HORDE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_ATT : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT : case QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT : case QUEST_A_RARE_HERB_ALLIANCE_ATT : if ( wintergrasp -> GetAttackerTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; case QUEST_BONES_AND_ARROWS_ALLIANCE_DEF : case QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF : case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF : case QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF : case QUEST_STOP_THE_SIEGE_ALLIANCE_DEF : case QUEST_A_RARE_HERB_ALLIANCE_DEF : if ( wintergrasp -> GetDefenderTeam ( ) == TEAM_ALLIANCE ) { QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; } break ; default : QuestStatus status = player -> GetQuestStatus ( questId ) ; if ( quest -> IsAutoComplete ( ) && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 4 ) ; else if ( status == QUEST_STATUS_NONE && player -> CanTakeQuest ( quest , false ) ) qm . AddMenuItem ( questId , 2 ) ; break ; } } } player -> SEND_GOSSIP_MENU ( player -> GetGossipTextId ( creature ) , creature -> GetGUID ( ) ) ; return true ; } } ; class spell_wintergrasp_force_building : public SpellScriptLoader { public : spell_wintergrasp_force_building ( ) : SpellScriptLoader ( " spell _ wintergrasp _ force _ building " ) { } class spell_wintergrasp_force_building_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_force_building_SpellScript ) ; bool Validate ( SpellInfo const * ) OVERRIDE { if ( ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_CATAPULT_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_DEMOLISHER_FORCE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE ) || ! sSpellMgr -> GetSpellInfo ( SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE ) ) return false ; return true ; } void HandleScript ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetHitUnit ( ) , GetEffect@@ Value ( ) , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_force_building_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_force_building_SpellScript ( ) ; } } ; class spell_wintergrasp_grab_passenger : public SpellScriptLoader { public : spell_wintergrasp_grab_passenger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ grab _ passenger " ) { } class spell_wintergrasp_grab_passenger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_grab_passenger_SpellScript ) ; void HandleScript ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) target -> CastSpell ( GetCaster ( ) , SPELL_RIDE_WG_VEHICLE , false ) ; } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_grab_passenger_SpellScript :: HandleScript , EFFECT_0 , SPELL_EFFECT_SCRIPT_EFFECT ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_grab_passenger_SpellScript ( ) ; } } ; class achievement_wg_didnt_stand_a_chance : public AchievementCriteriaScript { public : achievement_wg_didnt_stand_a_chance ( ) : AchievementCriteriaScript ( " achieve@@ ment _ wg _ didn@@ t _ stand _ a _ chance " ) { } bool OnCheck ( Player * source , Unit * target ) OVERRIDE { if ( ! target ) return false ; if ( Player * victim = target -> ToPlayer ( ) ) { if ( ! victim -> IsMounted ( ) ) return false ; if ( Vehicle * vehicle = source -> GetVehicle ( ) ) if ( vehicle -> GetVehic@@ leInfo ( ) -> m_ID == 244 ) return true ; } return false ; } } ; enum WgTele@@ port { SPELL_WINTERGRASP_TELEPORT_TRIGGER = 54643 , } ; class spell_wintergrasp_defender_teleport : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport " ) { } class spell_wintergrasp_defender_teleport_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_SpellScript ) ; SpellCast@@ Result CheckCast ( ) { if ( Battlefield * wg = sBattlefieldMgr -> GetBattlefieldByBattleId ( BATTLEFIELD_BATTLEID_WG ) ) if ( Player * target = GetExplTarget@@ Unit ( ) -> ToPlayer ( ) ) if ( ( target -> GetZoneId ( ) == 419@@ 7 && target -> GetTeamId ( ) != wg -> GetDefenderTeam ( ) ) || target -> HasAura ( SPELL_WINTERGRASP_TELEPORT_TRIGGER ) ) return SPELL_FAI@@ LED_BAD_@@ TARGET@@ S ; return SPELL_CAST_@@ OK ; } void Register ( ) OVERRIDE { OnCheckCast += SpellCheck@@ CastFn ( spell_wintergrasp_defender_teleport_SpellScript :: CheckCast ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_SpellScript ( ) ; } } ; class spell_wintergrasp_defender_teleport_trigger : public SpellScriptLoader { public : spell_wintergrasp_defender_teleport_trigger ( ) : SpellScriptLoader ( " spell _ wintergrasp _ defender _ teleport _ trigger " ) { } class spell_wintergrasp_defender_teleport_trigger_SpellScript : public SpellScript { PrepareSpellScript ( spell_wintergrasp_defender_teleport_trigger_SpellScript ) ; void HandleDummy ( SpellEffIndex ) { if ( Unit * target = GetHitUnit ( ) ) { WorldLocation loc ; target -> GetPosition ( & loc ) ; SetExplTarget@@ Dest ( loc ) ; } } void Register ( ) OVERRIDE { OnEffectHitTarget += SpellEffectFn ( spell_wintergrasp_defender_teleport_trigger_SpellScript :: HandleDummy , EFFECT_0 , SPELL_EFFECT_@@ DUMMY ) ; } } ; SpellScript * GetSpellScript ( ) const OVERRIDE { return new spell_wintergrasp_defender_teleport_trigger_SpellScript ( ) ; } } ; void AddSC_@@ wintergrasp ( ) { new npc_wg_queue ( ) ; new npc_wg_spirit_guide ( ) ; new npc_wg_demolisher_engineer ( ) ; new go_wg_vehicle_teleporter ( ) ; new npc_wg_quest_giver ( ) ; new spell_wintergrasp_force_building ( ) ; new spell_wintergrasp_grab_passenger ( ) ; new achievement_wg_didnt_stand_a_chance ( ) ; new spell_wintergrasp_defender_teleport ( ) ; new spell_wintergrasp_defender_teleport_trigger ( ) ; } </DOCUMENT>
<DOCUMENT_ID="attack@@ jz/@@ Cocos2d@@ -x_@@ CustomSliderList@@ /tree/master/CustomSliderList@@ /co@@ cos2d/cocos/@@ platform/@@ winrt/CCFreeType@@ Font.cpp"> # include " CCFreeTypeFont . h " # include " base / CCDirector . h " # include " platform / CCFileUtils . h " # if ( CC_TARGET_PLATFORM != CC_PLATFORM_WP8 ) # include < dwrite . h > # endif # include < map > # include < string > # include < sstream > # include < vector > # include < memory > # include < algorithm > using namespace std ; NS_CC_@@ BEGIN static map < std :: string , FontBufferInfo > s_fontsNames ; static FT_Library s_FreeTypeLibrary = nullptr ; CCFreeTypeFont :: CCFreeTypeFont ( ) : m_space ( " ▁ " ) , m_face ( nullptr ) { } CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; } void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_@@ Face ( m_face ) ; m_face = nullptr ; } } unsigned char * CCFreeTypeFont :: initWith@@ String ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWin@@ SizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; # if 0 auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } # endif if ( ! pBuffer ) { pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { return false ; } # if 0 FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; # endif } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init_FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Mem@@ ory_Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select_Char@@ map ( m_face , FT_ENCO@@ DING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char@@ _Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; } unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; } FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_@@ LEFT : pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_@@ RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_@@ RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_@@ LEFT : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CEN@@ TER : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; } void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_@@ To_Bitmap ( & image , FT_RENDER_@@ MODE_@@ NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_@@ Glyph ( image ) ; } } } void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } } void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } } void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; } FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; FT_BBox bbox ; int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; } FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; } void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } } FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_Glyph@@ Slot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToWide@@ Char ( CP_@@ UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_@@ KERN@@ ING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_@@ Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_@@ Kerning ( m_face , previous , glyph_index , FT_KERN@@ ING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } glyph -> pos = pen ; glyph -> index = glyph_index ; error = FT_Load@@ _Glyph ( m_face , glyph_index , FT_LOAD_@@ DEFAULT ) ; if ( error ) continue ; error = FT_Get_@@ Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; FT_Glyph_@@ Transform ( glyph -> image , 0 , & glyph -> pos ) ; pen . x += slot -> advance . x >> 6 ; previous = glyph_index ; numGlyphs ++ ; } CC_SAF@@ E_DELETE_@@ ARRAY ( pwszBuffer ) ; return error ; } void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; bbox . xMin = 32000 ; bbox . xMax = - 32000 ; bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_@@ Get_CBox ( glyph -> image , ft_glyph_bbox_@@ pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } * abbox = bbox ; } unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFile@@ Data ( fullpath . c_str ( ) , " rb " , size ) ; } unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { # if ( CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; # else std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFont@@ Collection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFont@@ File * fontFile = nullptr ; IDWriteFont@@ FileLoader * fontFileLoader = nullptr ; IDWriteFont@@ FileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; hr = DWrite@@ CreateFactory ( DWRITE_@@ FACTORY_TYPE_@@ SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { hr = writeFactory -> GetSystem@@ FontCollection ( & fontCollection , TRUE ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamil@@ yName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirst@@ Match@@ ingFont ( DWRITE_FONT_@@ WEIG@@ HT_REGUL@@ AR , DWRITE_@@ FONT_STRE@@ TCH_@@ NORMAL , DWRITE_FONT_@@ STYLE_@@ NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetReference@@ Key ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStream@@ FromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFile@@ Size ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; # endif } NS_CC_@@ END </DOCUMENT>
<DOCUMENT_ID="g@@ oldcoin/g@@ ldcoin@@ /tree/master/Build@@ Deps/de@@ ps/@@ boost/libs/polygon/@@ example/@@ voronoi_@@ visual@@ izer.cpp"> # include < iostream > # include < vector > # include < QtOpen@@ GL / QGLWidget > # include < QtGui / QtGui > # include < boost / polygon / polygon . hpp > # include < boost / polygon / voronoi . hpp > using namespace boost :: polygon ; # include " voronoi _ visual _ utils . hpp " class GLWidget : public QGLWidget { Q_OBJECT public : explicit GLWidget ( QMainWindow * parent = NULL ) : QGLWidget ( QGL@@ Format ( QGL :: SampleBuffers ) , parent ) , primary_edges_only_ ( false ) , internal_edges_only_ ( false ) { startTimer ( 40 ) ; } QSize sizeHint ( ) const { return QSize ( 600 , 600 ) ; } void build ( const QString & file_path ) { clear ( ) ; read_data ( file_path ) ; if ( ! brect_initialized_ ) { return ; } construct_brect ( ) ; construct_@@ voronoi ( point_data_ . begin ( ) , point_data_ . end ( ) , segment_data_ . begin ( ) , segment_data_ . end ( ) , & vd_ ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( ! it -> is_finite ( ) ) { color_exterior ( & ( * it ) ) ; } } update_view_port ( ) ; } void show_primary_edges_only ( ) { primary_edges_only_ ^= true ; } void show_internal_edges_only ( ) { internal_edges_only_ ^= true ; } protected : void initialize@@ GL ( ) { glHint ( GL_POINT_SMO@@ OTH_@@ HINT , GL_NIC@@ EST ) ; glBlendFunc ( GL_S@@ RC_ALPHA , GL_ONE_@@ MINUS_S@@ RC_ALPHA ) ; glEnable ( GL_BL@@ END ) ; glEnable ( GL_POINT_SMO@@ OTH ) ; } void paintGL ( ) { qglClearColor ( QColor :: fromRgb ( 255 , 255 , 255 ) ) ; glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_@@ BUFFER_BIT ) ; draw_points ( ) ; draw_segments ( ) ; draw_vertices ( ) ; draw_edges ( ) ; } void resizeGL ( int width , int height ) { int side = qMin ( width , height ) ; glViewport ( ( width - side ) / 2 , ( height - side ) / 2 , side , side ) ; } void timerEvent ( QTimer@@ Event * e ) { update ( ) ; } private : typedef double coordinate_type ; typedef point_data < coordinate_type > point_type ; typedef segment_data < coordinate_type > segment_type ; typedef rectangle_@@ data < coordinate_type > rect_type ; typedef voronoi_bu@@ ilder < int > VB ; typedef voronoi_@@ diagram < coordinate_type > VD ; typedef VD :: cell_type cell_type ; typedef VD :: cell_type :: source_index_type source_index_type ; typedef VD :: cell_type :: source_category_type source_category_type ; typedef VD :: edge_type edge_type ; typedef VD :: cell_container_type cell_container_type ; typedef VD :: cell_container_type vertex_container_type ; typedef VD :: edge_container_type edge_container_type ; typedef VD :: const_cell_iterator const_cell_iterator ; typedef VD :: const_vertex_iterator const_vertex_iterator ; typedef VD :: const_edge_iterator const_edge_iterator ; static const std :: size_t EXTERNAL_COLOR = 1 ; void clear ( ) { brect_initialized_ = false ; point_data_ . clear ( ) ; segment_data_ . clear ( ) ; vd_ . clear ( ) ; } void read_data ( const QString & file_path ) { QFile data ( file_path ) ; if ( ! data . open ( QFile :: ReadOnly ) ) { QMessageBox :: warning ( this , tr ( " Voronoi ▁ Visualizer " ) , tr ( " Disable ▁ to ▁ open ▁ file ▁ " ) + file_path ) ; } QTextStream in_stream ( & data ) ; std :: size_t num_points , num_segments ; int x1 , y1 , x2 , y2 ; in_stream >> num_points ; for ( std :: size_t i = 0 ; i < num_points ; ++ i ) { in_stream >> x1 >> y1 ; point_type p ( x1 , y1 ) ; update_brect ( p ) ; point_data_ . push_back ( p ) ; } in_stream >> num_segments ; for ( std :: size_t i = 0 ; i < num_segments ; ++ i ) { in_stream >> x1 >> y1 >> x2 >> y2 ; point_type lp ( x1 , y1 ) ; point_type hp ( x2 , y2 ) ; update_brect ( lp ) ; update_brect ( hp ) ; segment_data_ . push_back ( segment_type ( lp , hp ) ) ; } in_stream . flush ( ) ; } void update_brect ( const point_type & point ) { if ( brect_initialized_ ) { encompass ( brect_ , point ) ; } else { set_points ( brect_ , point , point ) ; brect_initialized_ = true ; } } void construct_brect ( ) { double side = ( std :: max ) ( xh ( brect_ ) - xl ( brect_ ) , yh ( brect_ ) - yl ( brect_ ) ) ; center ( shift_ , brect_ ) ; set_points ( brect_ , shift_ , shift_ ) ; bloa@@ t ( brect_ , side * 1.2 ) ; } void color_exterior ( const VD :: edge_type * edge ) { if ( edge -> color ( ) == EXTERNAL_COLOR ) { return ; } edge -> color ( EXTERNAL_COLOR ) ; edge -> twin ( ) -> color ( EXTERNAL_COLOR ) ; const VD :: vertex_type * v = edge -> vertex1 ( ) ; if ( v == NULL || ! edge -> is_primary ( ) ) { return ; } v -> color ( EXTERNAL_COLOR ) ; const VD :: edge_type * e = v -> incident_edge ( ) ; do { color_exterior ( e ) ; e = e -> rot_@@ next ( ) ; } while ( e != v -> incident_edge ( ) ) ; } void update_view_port ( ) { glMatrixMode ( GL_PROJ@@ ECTION ) ; glLoad@@ Identity ( ) ; rect_type view_rect = brect_ ; deconvolve ( view_rect , shift_ ) ; glOr@@ tho ( xl ( view_rect ) , xh ( view_rect ) , yl ( view_rect ) , yh ( view_rect ) , - 1.0 , 1.0 ) ; glMatrixMode ( GL_MODEL@@ VIE@@ W ) ; } void draw_points ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glPointSize ( 9 ) ; glBegin ( GL_POINTS ) ; for ( std :: size_t i = 0 ; i < point_data_ . size ( ) ; ++ i ) { point_type point = point_data_ [ i ] ; deconvolve ( point , shift_ ) ; glVertex2f ( point . x ( ) , point . y ( ) ) ; } for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_segments ( ) { glColor3f ( 0.0f , 0.5f , 1.0f ) ; glLineWidth ( 2.7f ) ; glBegin ( GL_LINES ) ; for ( std :: size_t i = 0 ; i < segment_data_ . size ( ) ; ++ i ) { point_type lp = low ( segment_data_ [ i ] ) ; lp = deconvolve ( lp , shift_ ) ; glVertex2f ( lp . x ( ) , lp . y ( ) ) ; point_type hp = high ( segment_data_ [ i ] ) ; hp = deconvolve ( hp , shift_ ) ; glVertex2f ( hp . x ( ) , hp . y ( ) ) ; } glEnd ( ) ; } void draw_vertices ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glPointSize ( 6 ) ; glBegin ( GL_POINTS ) ; for ( const_vertex_iterator it = vd_ . vertices ( ) . begin ( ) ; it != vd_ . vertices ( ) . end ( ) ; ++ it ) { if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } point_type vertex ( it -> x ( ) , it -> y ( ) ) ; vertex = deconvolve ( vertex , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } void draw_edges ( ) { glColor3f ( 0.0f , 0.0f , 0.0f ) ; glLineWidth ( 1.7f ) ; for ( const_edge_iterator it = vd_ . edges ( ) . begin ( ) ; it != vd_ . edges ( ) . end ( ) ; ++ it ) { if ( primary_edges_only_ && ! it -> is_primary ( ) ) { continue ; } if ( internal_edges_only_ && ( it -> color ( ) == EXTERNAL_COLOR ) ) { continue ; } std :: vector < point_type > samples ; if ( ! it -> is_finite ( ) ) { clip_infinite_edge ( * it , & samples ) ; } else { point_type vertex0 ( it -> vertex0 ( ) -> x ( ) , it -> vertex0 ( ) -> y ( ) ) ; samples . push_back ( vertex0 ) ; point_type vertex1 ( it -> vertex1 ( ) -> x ( ) , it -> vertex1 ( ) -> y ( ) ) ; samples . push_back ( vertex1 ) ; if ( it -> is_curved ( ) ) { sample_curved_edge ( * it , & samples ) ; } } glBegin ( GL_LINE_@@ STRI@@ P ) ; for ( std :: size_t i = 0 ; i < samples . size ( ) ; ++ i ) { point_type vertex = deconvolve ( samples [ i ] , shift_ ) ; glVertex2f ( vertex . x ( ) , vertex . y ( ) ) ; } glEnd ( ) ; } } void clip_infinite_edge ( const edge_type & edge , std :: vector < point_type > * clipped_edge ) { const cell_type & cell1 = * edge . cell ( ) ; const cell_type & cell2 = * edge . twin ( ) -> cell ( ) ; point_type origin , direction ; if ( cell1 . contains_point ( ) && cell2 . contains_point ( ) ) { point_type p1 = retrieve_point ( cell1 ) ; point_type p2 = retrieve_point ( cell2 ) ; origin . x ( ( p1 . x ( ) + p2 . x ( ) ) * 0.5 ) ; origin . y ( ( p1 . y ( ) + p2 . y ( ) ) * 0.5 ) ; direction . x ( p1 . y ( ) - p2 . y ( ) ) ; direction . y ( p2 . x ( ) - p1 . x ( ) ) ; } else { origin = cell1 . contains_segment ( ) ? retrieve_point ( cell2 ) : retrieve_point ( cell1 ) ; segment_type segment = cell1 . contains_segment ( ) ? retrieve_segment ( cell1 ) : retrieve_segment ( cell2 ) ; coordinate_type dx = high ( segment ) . x ( ) - low ( segment ) . x ( ) ; coordinate_type dy = high ( segment ) . y ( ) - low ( segment ) . y ( ) ; if ( ( low ( segment ) == origin ) ^ cell1 . contains_point ( ) ) { direction . x ( dy ) ; direction . y ( - dx ) ; } else { direction . x ( - dy ) ; direction . y ( dx ) ; } } coordinate_type side = xh ( brect_ ) - xl ( brect_ ) ; coordinate_type koef = side / ( std :: max ) ( fabs ( direction . x ( ) ) , fabs ( direction . y ( ) ) ) ; if ( edge . vertex0 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) - direction . x ( ) * koef , origin . y ( ) - direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex0 ( ) -> x ( ) , edge . vertex0 ( ) -> y ( ) ) ) ; } if ( edge . vertex1 ( ) == NULL ) { clipped_edge -> push_back ( point_type ( origin . x ( ) + direction . x ( ) * koef , origin . y ( ) + direction . y ( ) * koef ) ) ; } else { clipped_edge -> push_back ( point_type ( edge . vertex1 ( ) -> x ( ) , edge . vertex1 ( ) -> y ( ) ) ) ; } } void sample_curved_edge ( const edge_type & edge , std :: vector < point_type > * sampled_edge ) { coordinate_type max_dist = 1E - 3 * ( xh ( brect_ ) - xl ( brect_ ) ) ; point_type point = edge . cell ( ) -> contains_point ( ) ? retrieve_point ( * edge . cell ( ) ) : retrieve_point ( * edge . twin ( ) -> cell ( ) ) ; segment_type segment = edge . cell ( ) -> contains_point ( ) ? retrieve_segment ( * edge . twin ( ) -> cell ( ) ) : retrieve_segment ( * edge . cell ( ) ) ; voronoi_@@ visual_@@ utils < coordinate_type > :: disc@@ retize ( point , segment , max_dist , sampled_edge ) ; } point_type retrieve_point ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) ; source_category_type category = cell . source_category ( ) ; if ( category == SOURCE_CATEGOR@@ Y_SING@@ LE_POINT ) { return point_data_ [ index ] ; } index -= point_data_ . size ( ) ; if ( category == SOURCE_CATEGOR@@ Y_SE@@ GMENT_START_@@ POINT ) { return low ( segment_data_ [ index ] ) ; } else { return high ( segment_data_ [ index ] ) ; } } segment_type retrieve_segment ( const cell_type & cell ) { source_index_type index = cell . source_index ( ) - point_data_ . size ( ) ; return segment_data_ [ index ] ; } point_type shift_ ; std :: vector < point_type > point_data_ ; std :: vector < segment_type > segment_data_ ; rect_type brect_ ; VB vb@@ _ ; VD vd_ ; bool brect_initialized_ ; bool primary_edges_only_ ; bool internal_edges_only_ ; } ; class MainWindow : public QWidget { Q_OBJECT public : MainWindow ( ) { glWidget_ = new GLWidget ( ) ; file_dir_ = QDir ( QDir :: currentPath ( ) , tr ( " * . txt " ) ) ; file_name_ = tr ( " " ) ; QHBoxLayout * centralLayout = new QHBoxLayout ; centralLayout -> addWidget ( glWidget_ ) ; centralLayout -> addLayout ( create_file_layout ( ) ) ; setLayout ( centralLayout ) ; update_file_list ( ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer " ) ) ; layout ( ) -> setSize@@ Constraint ( QLayout :: SetFix@@ edSize ) ; } private slo@@ ts : void primary_edges_only ( ) { glWidget_ -> show_primary_edges_only ( ) ; } void internal_edges_only ( ) { glWidget_ -> show_internal_edges_only ( ) ; } void browse ( ) { QString new_path = QFileDialog :: getExisting@@ Directory ( 0 , tr ( " Choose ▁ Directory " ) , file_dir_ . absolutePath ( ) ) ; if ( new_path . isEmpty ( ) ) { return ; } file_dir_ . setPath ( new_path ) ; update_file_list ( ) ; } void build ( ) { file_name_ = file_list_ -> currentItem ( ) -> text ( ) ; QString file_path = file_dir_ . filePath ( file_name_ ) ; message_label_ -> setText ( " Building . . . " ) ; glWidget_ -> build ( file_path ) ; message_label_ -> setText ( " Double ▁ click ▁ the ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; setWindowTitle ( tr ( " Voronoi ▁ Visualizer ▁ - ▁ " ) + file_path ) ; } void print_scr ( ) { if ( ! file_name_ . isEmpty ( ) ) { QImage screenshot = glWidget_ -> grabFrameBuffer ( true ) ; QString output_file = file_dir_ . absolutePath ( ) + tr ( " / " ) + file_name_ . left ( file_name_ . indexOf ( ' . ' ) ) + tr ( " . png " ) ; screenshot . save ( output_file , 0 , - 1 ) ; } } private : QGridLayout * create_file_layout ( ) { QGridLayout * file_layout = new QGridLayout ; message_label_ = new QLabel ( " Double ▁ click ▁ item ▁ to ▁ build ▁ voronoi ▁ diagram : " ) ; file_list_ = new QListWidget ( ) ; file_list_ -> connect ( file_list_ , SIGNAL ( itemDoubleClicked ( QList@@ WidgetItem * ) ) , this , SLOT ( build ( ) ) ) ; QCheckBox * primary_checkbox = new QCheckBox ( " Show ▁ primary ▁ edges ▁ only . " ) ; connect ( primary_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( primary_edges_only ( ) ) ) ; QCheckBox * internal_checkbox = new QCheckBox ( " Show ▁ internal ▁ edges ▁ only . " ) ; connect ( internal_checkbox , SIGNAL ( clicked ( ) ) , this , SLOT ( internal_edges_only ( ) ) ) ; QPushButton * browse_button = new QPushButton ( tr ( " Browse ▁ Input ▁ Directory " ) ) ; connect ( browse_button , SIGNAL ( clicked ( ) ) , this , SLOT ( browse ( ) ) ) ; browse_button -> setMinimumHeight ( 50 ) ; QPushButton * print_scr_button = new QPushButton ( tr ( " Make ▁ Screenshot " ) ) ; connect ( print_scr_button , SIGNAL ( clicked ( ) ) , this , SLOT ( print_scr ( ) ) ) ; print_scr_button -> setMinimumHeight ( 50 ) ; file_layout -> addWidget ( message_label_ , 0 , 0 ) ; file_layout -> addWidget ( file_list_ , 1 , 0 ) ; file_layout -> addWidget ( primary_checkbox , 2 , 0 ) ; file_layout -> addWidget ( internal_checkbox , 3 , 0 ) ; file_layout -> addWidget ( browse_button , 4 , 0 ) ; file_layout -> addWidget ( print_scr_button , 5 , 0 ) ; return file_layout ; } void update_file_list ( ) { QFileInfoList list = file_dir_ . entryInfoList ( ) ; file_list_ -> clear ( ) ; if ( file_dir_ . count ( ) == 0 ) { return ; } QFileInfoList :: const_iterator it ; for ( it = list . begin ( ) ; it != list . end ( ) ; it ++ ) { file_list_ -> addItem ( it -> fileName ( ) ) ; } file_list_ -> setCurrentRow ( 0 ) ; } QDir file_dir_ ; QString file_name_ ; GLWidget * glWidget_ ; QListWidget * file_list_ ; QLabel * message_label_ ; } ; int main ( int argc , char * argv [ ] ) { QApplication app ( argc , argv ) ; MainWindow window ; window . show ( ) ; return app . exec ( ) ; } # include " voronoi _ visual@@ izer . moc " </DOCUMENT>
<DOCUMENT_ID="door@@ xp@@ /cc@@ json/tree/master/cocos2d/cocos/@@ audio/@@ android/@@ AudioResampler.cpp"> # define LOG_TAG " AudioResampler " # include < stdint . h > # include < stdlib . h > # include < sys / types . h > # include < pthread . h > # include < new > # include " audio / android / cutils / log . h " # include " audio / android / utils / Utils . h " # include " audio / android / audio _ utils / include / audio _ utils / primitives . h " # include " audio / android / AudioResampler . h " # include " audio / android / AudioResamplerCubic . h " namespace cocos@@ 2d { namespace exper@@ iment@@ al { class AudioResamplerOrder1 : public AudioResampler { public : AudioResamplerOrder1 ( int inChannelCount , int32_t sampleRate ) : AudioResampler ( inChannelCount , sampleRate , LOW_QUALITY ) , mX0L ( 0 ) , mX0R ( 0 ) { } virtual size_t resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; private : static const int kNumInterpBits = 15 ; static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits ; void init ( ) { } size_t resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; size_t resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) ; # ifdef ASM_ARM_RESAMP1 void AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; void AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) ; # endif static inline int32_t Interp ( int32_t x0 , int32_t x1 , uint32_t f ) { return x0 + ( ( ( x1 - x0 ) * ( int32_t ) ( f >> kPreInterpShift ) ) >> kNumInterpBits ) ; } static inline void Advance ( size_t * index , uint32_t * frac , uint32_t inc ) { * frac += inc ; * index += ( size_t ) ( * frac >> kNumPhaseBits ) ; * frac &= kPhase@@ Mask ; } int mX0L ; int mX0R ; } ; const double AudioResampler :: kPhaseMultiplier = 1L << AudioResampler :: kNumPhaseBits ; bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } } static pthread_once_t once_control = PTHREAD_@@ ONCE_@@ INIT ; static AudioResampler :: src_quality defaultQuality = AudioResampler :: DEFAULT_QUALITY ; void AudioResampler :: init_routine ( ) { } uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; } } static const uint32_t maxMHz = 130 ; static pthread_mutex@@ _t mutex = PTHREAD_@@ MUTEX_INITIALIZER ; static uint32_t currentMHz = 0 ; AudioResampler * AudioResampler :: create ( audio@@ _format@@ _t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } if ( quality == DEFAULT_QUALITY ) { } pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } resampler -> init ( ) ; return resampler ; } AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; } AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; } void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; } void AudioResampler :: setVolume ( float left , float right ) { mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; } void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; } void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; } int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } } void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; } size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } } size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleStereo16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 ; } size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } # ifdef ASM_ARM_RESAMP1 if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } # endif while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleMono16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; } # ifdef ASM_ARM_RESAMP1 __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmMono16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define MO_PARAM5 "36@@ " asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 16 ] \n " "1 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 2f \n " # define MO_ONE_FRAME " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 1 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r0 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r0 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r0 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " MO_ONE_FRAME MO_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 1b \n " "2 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " MO_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ pc } \n " ) ; } __attribute__ ( ( noinline ) ) void AudioResamplerOrder1 :: AsmStereo16Loop ( int16_t * in , int32_t * maxOutPt , int32_t maxInIdx , size_t & outputIndex , int32_t * out , size_t & inputIndex , int32_t vl , int32_t vr , uint32_t & phaseFraction , uint32_t phaseIncrement ) { ( void ) maxOutPt ; ( void ) maxInIdx ; ( void ) outputIndex ; ( void ) out ; ( void ) inputIndex ; ( void ) vl ; ( void ) vr ; ( void ) phaseFraction ; ( void ) phaseIncrement ; ( void ) in ; # define ST_PARAM5 "40@@ " asm ( " stmfd ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ lr } \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ ldr ▁ r6 , ▁ [ r6 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ ldr ▁ r7 , ▁ [ r7 ] \n " " ▁ ▁ ▁ ldr ▁ r8 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ r0 ] \n " " ▁ ▁ ▁ add ▁ r8 , ▁ r8 , ▁ r0 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r9 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 24 ] \n " " ▁ ▁ ▁ ldr ▁ r10 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 12 ] \n " " ▁ ▁ ▁ ldr ▁ r11 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 16 ] \n " "3 : \n " " ▁ ▁ ▁ cmp ▁ r8 , ▁ r2 \n " " ▁ ▁ ▁ bcs ▁ 4f \n " # define ST_ONE_FRAME " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ add ▁ r0 , ▁ r1 , ▁ r7 , ▁ asl ▁ # 2 \n " " ▁ ▁ ▁ ldrsh ▁ r4 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r5 , ▁ [ r8 ] \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # -4 ] \n " " ▁ ▁ ▁ sub ▁ r4 , ▁ r4 , ▁ r12 \n " " ▁ ▁ ▁ mov ▁ r4 , ▁ r4 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r4 , ▁ r4 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r12 , ▁ r4 \n " " ▁ ▁ ▁ mla ▁ r5 , ▁ r12 , ▁ r10 , ▁ r5 \n " " ▁ ▁ ▁ ldr ▁ r4 , ▁ [ r8 , ▁ # 4 ] \n " " ▁ ▁ ▁ str ▁ r5 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ ldrsh ▁ r12 , ▁ [ r0 , ▁ # + 2 ] \n " " ▁ ▁ ▁ ldrsh ▁ r0 , ▁ [ r0 , ▁ # -2 ] \n " " ▁ ▁ ▁ sub ▁ r12 , ▁ r12 , ▁ r0 \n " " ▁ ▁ ▁ mov ▁ r12 , ▁ r12 , ▁ lsl ▁ # 2 \n " " ▁ ▁ ▁ smulwt ▁ r12 , ▁ r12 , ▁ r6 \n " " ▁ ▁ ▁ add ▁ r12 , ▁ r0 , ▁ r12 \n " " ▁ ▁ ▁ mla ▁ r4 , ▁ r12 , ▁ r11 , ▁ r4 \n " " ▁ ▁ ▁ str ▁ r4 , ▁ [ r8 ] , ▁ # 4 \n " " ▁ ▁ ▁ add ▁ r6 , ▁ r6 , ▁ r9 \n " " ▁ ▁ ▁ add ▁ r7 , ▁ r7 , ▁ r6 , ▁ lsr ▁ # 30 \n " ST_ONE_FRAME ST_ONE_FRAME " ▁ ▁ ▁ cmp ▁ r7 , ▁ r3 \n " " ▁ ▁ ▁ bcc ▁ 3b \n " "4 : \n " " ▁ ▁ ▁ bic ▁ r6 , ▁ r6 , ▁ # 0xC0000000 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 20 ] \n " " ▁ ▁ ▁ str ▁ r6 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 8 ] \n " " ▁ ▁ ▁ str ▁ r7 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 4 ] \n " " ▁ ▁ ▁ sub ▁ r8 , ▁ r0 \n " " ▁ ▁ ▁ asr ▁ r8 , ▁ # 2 \n " " ▁ ▁ ▁ ldr ▁ r0 , ▁ [ sp , ▁ # " ST_PARAM5 " ▁ + ▁ 0 ] \n " " ▁ ▁ ▁ str ▁ r8 , ▁ [ r0 ] \n " " ▁ ▁ ▁ ldmfd ▁ ▁ ▁ sp ! , ▁ { r4 , ▁ r5 , ▁ r6 , ▁ r7 , ▁ r8 , ▁ r9 , ▁ r10 , ▁ r11 , ▁ r12 , ▁ pc } \n " ) ; } # endif } } </DOCUMENT>
<DOCUMENT_ID="H@@ ual/SA@@ -MP@@ -Plu@@ s/tree/master/Common/@@ RakNet/VariableDelta@@ Serializer.cpp"> # include " VariableDeltaSerializer . h " using namespace RakNet ; VariableDeltaSerializer :: VariableDeltaSerializer ( ) { didComparisonThisTick = false ; } VariableDeltaSerializer :: ~ VariableDeltaSerializer ( ) { RemoveRemoteSystemVariableHistory ( ) ; } VariableDeltaSerializer :: SerializationContext :: SerializationContext ( ) { variableHistoryIdentical = 0 ; variableHistoryUnique = 0 ; } VariableDeltaSerializer :: SerializationContext :: ~ SerializationContext ( ) { } void VariableDeltaSerializer :: OnMessage@@ Receipt ( RakNetGUID guid , uint32_t receiptId , bool messageArrived ) { if ( messageArrived ) FreeVarsAssociatedWithReceipt ( guid , receiptId ) ; else DirtyAndFreeVarsAssociatedWithReceipt ( guid , receiptId ) ; } void VariableDeltaSerializer :: BeginUnreli@@ ableAc@@ ked@@ Serialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream , uint32_t _sendReceipt ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> sendReceipt = _sendReceipt ; context -> changedVariables = AllocChangedVariablesList ( ) ; context -> newSystemSend = false ; context -> serializationMode = UNRELIABLE_WITH_ACK_RECEIPT ; } void VariableDeltaSerializer :: BeginUniqueSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> newSystemSend = false ; context -> serializationMode = RELIABLE ; } void VariableDeltaSerializer :: BeginIdentical@@ Serialize ( SerializationContext * context , bool _isFirstSendToRemoteSystem , BitStream * _bitStream ) { context -> anyVariablesWritten = false ; context -> guid = UNASSIGNED_RAKNET_GUID ; context -> bitStream = _bitStream ; context -> serializationMode = RELIABLE ; if ( context -> variableHistoryIdentical == 0 ) context -> variableHistoryIdentical = StartVariableHistoryWrite ( UNASSIGNED_RAKNET_GUID ) ; context -> variableHistory = context -> variableHistoryIdentical ; context -> newSystemSend = _isFirstSendToRemoteSystem ; } void VariableDeltaSerializer :: EndSerialize ( SerializationContext * context ) { if ( context -> serializationMode == UNRELIABLE_WITH_ACK_RECEIPT ) { if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; FreeChangedVariablesList ( context -> changedVariables ) ; return ; } StoreChangedVariablesList ( context -> variableHistory , context -> changedVariables , context -> sendReceipt ) ; } else { if ( context -> variableHistoryIdentical ) { if ( didComparisonThisTick == false ) { didComparisonThisTick = true ; identicalSerializationBs . Reset ( ) ; if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } identicalSerializationBs . Write ( context -> bitStream ) ; context -> bitStream -> ResetReadPointer ( ) ; } else { context -> bitStream -> Write ( & identicalSerializationBs ) ; identicalSerializationBs . ResetReadPointer ( ) ; } } else if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } } } void VariableDeltaSerializer :: BeginDeserialize ( DeserializationContext * context , BitStream * _bitStream ) { context -> bitStream = _bitStream ; } void VariableDeltaSerializer :: EndDeserialize ( DeserializationContext * context ) { ( void ) context ; } void VariableDeltaSerializer :: AddRemoteSystemVariableHistory ( RakNetGUID guid ) { ( void ) guid ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; remoteSystemVariableHistoryList . RemoveAt@@ IndexFast ( idx ) ; return ; } } int RakNet :: VariableDeltaSerializer :: UpdatedVariables@@ ListPtr@@ Comp ( const uint32_t & key , ChangedVariablesList * const & data ) { if ( key < data -> sendReceipt ) return - 1 ; if ( key == data -> sendReceipt ) return 0 ; return 1 ; } void VariableDeltaSerializer :: FreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } void VariableDeltaSerializer :: DirtyAndFreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { vprs -> variableListDeltaTracker . FlagDirty@@ FromBitArray ( vprs -> updatedVariablesHistory [ idx2 ] -> bitField ) ; FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } } unsigned int VariableDeltaSerializer :: GetVarsWrittenPerRemoteSystemListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) return idx ; } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( void ) { unsigned int idx , idx2 ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; } remoteSystemVariableHistoryList . Clear ( false , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: GetRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; return remoteSystemVariableHistoryList [ rshli ] ; } VariableDeltaSerializer :: ChangedVariablesList * VariableDeltaSerializer :: AllocChangedVariablesList ( void ) { VariableDeltaSerializer :: ChangedVariablesList * p = updatedVariablesMemoryPool . Allocate ( _FILE_AND_LINE_ ) ; p -> bitWrite@@ Index = 0 ; p -> bitField [ 0 ] = 0 ; return p ; } void VariableDeltaSerializer :: FreeChangedVariablesList ( ChangedVariablesList * changedVariables ) { updatedVariablesMemoryPool . Release ( changedVariables , _FILE_AND_LINE_ ) ; } void VariableDeltaSerializer :: StoreChangedVariablesList ( RemoteSystemVariableHistory * variableHistory , ChangedVariablesList * changedVariables , uint32_t sendReceipt ) { changedVariables -> sendReceipt = sendReceipt ; variableHistory -> updatedVariablesHistory . Insert ( changedVariables -> sendReceipt , changedVariables , true , _FILE_AND_LINE_ ) ; } VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: StartVariableHistoryWrite ( RakNetGUID guid ) { RemoteSystemVariableHistory * variableHistory ; unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; if ( rshli == ( unsigned int ) - 1 ) { variableHistory = new RemoteSystemVariableHistory ; variableHistory -> guid = guid ; remoteSystemVariableHistoryList . Push ( variableHistory , _FILE_AND_LINE_ ) ; } else { variableHistory = remoteSystemVariableHistoryList [ rshli ] ; } variableHistory -> variableListDeltaTracker . StartWrite ( ) ; return variableHistory ; } unsigned int VariableDeltaSerializer :: GetRemoteSystemHistoryListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { return idx ; } } return ( unsigned int ) - 1 ; } void VariableDeltaSerializer :: OnPre@@ Serialize@@ Tick ( void ) { didComparisonThisTick = false ; } </DOCUMENT>
<DOCUMENT_ID="Char@@ lieMar@@ shall@@ /xbmc/tree/master/xbmc/@@ cores/@@ dvd@@ player/@@ DVD@@ Subtitles/DVDSubtitleTagMicro@@ DVD@@ .cpp"> # include " DVDSubtitleTagMicro@@ DVD . h " # include " DVD@@ Codecs / Overlay / DVDOverlayText . h " # include " utils / StdString . h " # include " utils / StringUtils . h " void CDV@@ DSubtitleTagMicro@@ DVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; } </DOCUMENT>
<DOCUMENT_ID="Thomas@@ Lee969@@ /video_@@ classifier@@ /tree/master/work@@ space/@@ mex@@ opencv/src/@@ +cv@@ /cornerHarri@@ s.cpp"> # include " mexopencv . hpp " using namespace std ; using namespace cv ; void mex@@ Function ( int nlhs , mxArray * plhs [ ] , int nrhs , const mxArray * prhs [ ] ) { narg@@ chk ( nrhs >= 1 && ( nrhs % 2 ) == 1 && nlhs <= 1 ) ; vector < MxArray > rhs ( prhs , prhs + nrhs ) ; int blockSize = 5 ; int ksize = 3 ; double k = 0.04 ; int borderType = cv :: BOR@@ DER_DEFAULT ; for ( int i = 1 ; i < nrhs ; i += 2 ) { string key ( rhs [ i ] . toString ( ) ) ; if ( key == " BlockSize " ) blockSize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " KSize " ) ksize = rhs [ i + 1 ] . toInt ( ) ; else if ( key == " K " ) k = rhs [ i + 1 ] . toDouble ( ) ; else if ( key == " BorderType " ) borderType = BorderType [ rhs [ i + 1 ] . toString ( ) ] ; else mex@@ ErrMsg@@ IdAnd@@ Txt ( " mexopencv : error " , " Unrecognized ▁ option " ) ; } Mat src ( rhs [ 0 ] . toMat ( rhs [ 0 ] . isUint8 ( ) ? CV_8U : CV_32F ) ) , dst ; cornerHarri@@ s ( src , dst , blockSize , ksize , k , borderType ) ; plhs [ 0 ] = MxArray ( dst ) ; } </DOCUMENT>
<DOCUMENT_ID="Green@@ Dam@@ Tan/@@ ppsspp/tree/master/@@ Core/MIPS@@ /x86@@ /As@@ m.cpp"> # include " math / math _ util . h " # include " ABI . h " # include " x64Emitter . h " # include " Core / Core . h " # include " Core / MemMap . h " # include " Core / System . h " # include " Core / MIPS / MIPS . h " # include " Core / CoreTiming . h " # include " Common / MemoryUtil . h " # include " Core / MIPS / JitCommon / JitCommon . h " # include " Core / MIPS / x86 / Asm . h " # include " Core / MIPS / x86 / Jit . h " using namespace Gen ; using namespace X64@@ JitConstants ; static bool enableDebug = false ; extern volatile CoreState coreState ; void ImHere ( ) { DEBUG_LOG ( CPU , " JIT ▁ Here : ▁ % 08x " , currentMIPS -> pc ) ; } void AsmRoutine@@ Manager :: Generate ( MIPS@@ State * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; # ifdef _M_X64 MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFFFFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } # endif MOV ( PTR@@ BITS , R ( CTX@@ REG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcher@@ CheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcher@@ InEA@@ XNoCheck = GetCodePtr ( ) ; # ifdef _M_IX86 AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW@@ 32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDis@@ p ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComp@@ lex ( MEMBASEREG , RAX , SCAL@@ E_1 , 0 ) ) ; # endif MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_@@ JITBLOCK_@@ MASK == 0xFF000000 , " Hard@@ coded ▁ assumption ▁ of ▁ emu@@ hack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_@@ OPCO@@ DE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debug@@ Count ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_@@ VALUE_@@ MASK ) ) ; # ifdef _M_IX86 ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; # endif JMP@@ ptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpoint@@ Bai@@ lout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; } </DOCUMENT>
<DOCUMENT_ID="Res@@ identik/@@ TestingRepo@@ /tree/master/src/server/scripts/EasternKingdoms/@@ Blackrock@@ Mount@@ ain/Blackrock@@ Depths/boss_high_interrogator_gerstahn@@ .cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " enum Spells { SPELL_SHADOWWORDPAIN = 10894 , SPELL_MANABURN = 10876 , SPELL_PSYCHICSCREAM = 8122 , SPELL_SHADOWSHIELD = 22417 } ; class boss_high_interrogator_gerstahn : public CreatureScript { public : boss_high_interrogator_gerstahn ( ) : CreatureScript ( " boss _ high _ interrogator _ gerstah@@ n " ) { } CreatureAI * GetAI ( Creature * creature ) const OVERRIDE { return new boss_high_interrogator_gerstahnAI ( creature ) ; } struct boss_high_interrogator_gerstahnAI : public ScriptedAI { boss_high_interrogator_gerstahnAI ( Creature * creature ) : ScriptedAI ( creature ) { } uint32 ShadowWordPain_Timer ; uint32 ManaBurn_Timer ; uint32 PsychicScream_Timer ; uint32 ShadowShield_Timer ; void Reset ( ) OVERRIDE { ShadowWordPain_Timer = 4000 ; ManaBurn_Timer = 14000 ; PsychicScream_Timer = 32000 ; ShadowShield_Timer = 8000 ; } void EnterCombat ( Unit * ) OVERRIDE { } void UpdateAI ( uint32 diff ) OVERRIDE { if ( ! UpdateVictim ( ) ) return ; if ( ShadowWordPain_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_SHADOWWORDPAIN ) ; ShadowWordPain_Timer = 7000 ; } else ShadowWordPain_Timer -= diff ; if ( ManaBurn_Timer <= diff ) { if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , 100 , true ) ) DoCast ( target , SPELL_MANABURN ) ; ManaBurn_Timer = 10000 ; } else ManaBurn_Timer -= diff ; if ( PsychicScream_Timer <= diff ) { DoCastVictim ( SPELL_PSYCHICSCREAM ) ; PsychicScream_Timer = 30000 ; } else PsychicScream_Timer -= diff ; if ( ShadowShield_Timer <= diff ) { DoCast ( me , SPELL_SHADOWSHIELD ) ; ShadowShield_Timer = 25000 ; } else ShadowShield_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_@@ boss_high_interrogator_gerstahn ( ) { new boss_high_interrogator_gerstahn ( ) ; } </DOCUMENT>
<DOCUMENT_ID="x@@ lmb@@ n/trscoin/tree/master/src/test/@@ multisig_@@ tests.cpp"> # include < boost / assert . hpp > # include < boost / assign / list_of . hpp > # include < boost / assign / list_inserter . hpp > # include < boost / assign / std / vector . hpp > # include < boost / test / unit_test . hpp > # include < boost / foreach . hpp > # include < boost / tuple / tuple . hpp > # include < openssl / ec . h > # include < openssl / err . h > # include " keystore . h " # include " main . h " # include " script . h " # include " wallet . h " using namespace std ; using namespace boost :: assign ; typedef vector < unsigned char > valtype ; extern uint256 SignatureHash ( CScript scriptCode , const CTransaction & txTo , unsigned int nIn , int nHash@@ Type ) ; BOOST_AUTO_TEST_SUITE ( multisig_@@ tests ) CScript sign_multisig ( CScript scriptPubKey , vector < CKey > keys , CTransaction transaction , int whichIn ) { uint256 hash = SignatureHash ( scriptPubKey , transaction , whichIn , SIGHASH_ALL ) ; CScript result ; result << OP_0 ; BOOST_FOREACH ( const CKey & key , keys ) { vector < unsigned char > vchSig ; BOOST_CHECK ( key . Sign ( hash , vchSig ) ) ; vchSig . push_back ( ( unsigned char ) SIGHASH_ALL ) ; result << vchSig ; } return result ; } BOOST_AUTO_TEST_CASE ( multisig_@@ verify ) { unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } vector < CKey > keys ; CScript s ; keys . clear ( ) ; keys += key [ 0 ] , key [ 1 ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK ( VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 1 : ▁ % d " , i ) ) ; keys . clear ( ) ; keys += key [ 1 ] , key [ i ] ; s = sign_multisig ( a_and_b , keys , txTo [ 0 ] , 0 ) ; BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_and_b , txTo [ 0 ] , 0 , flags , 0 ) , strprintf ( " a & b ▁ 2 : ▁ % d " , i ) ) ; } for ( int i = 0 ; i < 4 ; i ++ ) { keys . clear ( ) ; keys += key [ i ] ; s = sign_multisig ( a_or_b , keys , txTo [ 1 ] , 0 ) ; if ( i == 0 || i == 1 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) , strprintf ( " a | b : ▁ % d " , i ) ) ; } s . clear ( ) ; s << OP_0 << OP_0 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; s . clear ( ) ; s << OP_0 << OP_1 ; BOOST_CHECK ( ! VerifyScript ( s , a_or_b , txTo [ 1 ] , 0 , flags , 0 ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) { keys . clear ( ) ; keys += key [ i ] , key [ j ] ; s = sign_multisig ( escrow , keys , txTo [ 2 ] , 0 ) ; if ( i < j && i < 3 && j < 3 ) BOOST_CHECK_MESSAGE ( VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 1 : ▁ % d ▁ % d " , i , j ) ) ; else BOOST_CHECK_MESSAGE ( ! VerifyScript ( s , escrow , txTo [ 2 ] , 0 , flags , 0 ) , strprintf ( " escrow ▁ 2 : ▁ % d ▁ % d " , i , j ) ) ; } } BOOST_AUTO_TEST_CASE ( multisig_@@ IsStandard ) { CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) key [ i ] . MakeNewKey ( true ) ; CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_and_b ) ) ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( a_or_b ) ) ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( :: IsStandard ( escrow ) ) ; CScript one_of_four ; one_of_four << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << key [ 3 ] . GetPubKey ( ) << OP_4 << OP_CHECKMULTISIG ; BOOST_CHECK ( ! :: IsStandard ( one_of_four ) ) ; CScript malformed [ 6 ] ; malformed [ 0 ] << OP_3 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 1 ] << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; malformed [ 2 ] << OP_0 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; malformed [ 3 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_0 << OP_CHECKMULTISIG ; malformed [ 4 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_CHECKMULTISIG ; malformed [ 5 ] << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) BOOST_CHECK ( ! :: IsStandard ( malformed [ i ] ) ) ; } BOOST_AUTO_TEST_CASE ( multisig_S@@ olver1 ) { CBasicKeyStore keystore , emptykeystore , partialkeystore ; CKey key [ 3 ] ; CTxDestination keyaddr [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; keyaddr [ i ] = key [ i ] . GetPubKey ( ) . GetID ( ) ; } partialkeystore . AddKey ( key [ 0 ] ) ; { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << key [ 0 ] . GetPubKey ( ) << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_DUP << OP_HASH@@ 160 << key [ 0 ] . GetPubKey ( ) . GetID ( ) << OP_EQUAL@@ VERIFY << OP_CHECKSIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 1 ) ; CTxDestination addr ; BOOST_CHECK ( ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( addr == keyaddr [ 0 ] ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; CTxDestination addr ; BOOST_CHECK ( ! ExtractDestination ( s , addr ) ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK_EQUAL ( solutions . size ( ) , 4U ) ; vector < CTxDestination > addrs ; int nRequired ; BOOST_CHECK ( ExtractDestinations ( s , whichType , addrs , nRequired ) ) ; BOOST_CHECK ( addrs [ 0 ] == keyaddr [ 0 ] ) ; BOOST_CHECK ( addrs [ 1 ] == keyaddr [ 1 ] ) ; BOOST_CHECK ( nRequired == 1 ) ; BOOST_CHECK ( IsMine ( keystore , s ) ) ; BOOST_CHECK ( ! IsMine ( emptykeystore , s ) ) ; BOOST_CHECK ( ! IsMine ( partialkeystore , s ) ) ; } { vector < valtype > solutions ; txnouttype whichType ; CScript s ; s << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; BOOST_CHECK ( Solver ( s , whichType , solutions ) ) ; BOOST_CHECK ( solutions . size ( ) == 5 ) ; } } BOOST_AUTO_TEST_CASE ( multisig_S@@ ign ) { CBasicKeyStore keystore ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( true ) ; keystore . AddKey ( key [ i ] ) ; } CScript a_and_b ; a_and_b << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript a_or_b ; a_or_b << OP_1 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << OP_2 << OP_CHECKMULTISIG ; CScript escrow ; escrow << OP_2 << key [ 0 ] . GetPubKey ( ) << key [ 1 ] . GetPubKey ( ) << key [ 2 ] . GetPubKey ( ) << OP_3 << OP_CHECKMULTISIG ; CTransaction txFrom ; txFrom . vout . resize ( 3 ) ; txFrom . vout [ 0 ] . scriptPubKey = a_and_b ; txFrom . vout [ 1 ] . scriptPubKey = a_or_b ; txFrom . vout [ 2 ] . scriptPubKey = escrow ; CTransaction txTo [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { txTo [ i ] . vin . resize ( 1 ) ; txTo [ i ] . vout . resize ( 1 ) ; txTo [ i ] . vin [ 0 ] . prevout . n = i ; txTo [ i ] . vin [ 0 ] . prevout . hash = txFrom . GetHash ( ) ; txTo [ i ] . vout [ 0 ] . nValue = 1 ; } for ( int i = 0 ; i < 3 ; i ++ ) { BOOST_CHECK_MESSAGE ( SignSignature ( keystore , txFrom , txTo [ i ] , 0 ) , strprintf ( " SignSignature ▁ % d " , i ) ) ; } } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
