MP4DmaxAtom :: MP4DmaxAtom ( ) : MP4@@ Atom ( " dmax " ) { AddProperty ( new MP4@@ Integer32Property ( " milli@@ Secs " ) ) ; }
SD@@ Thread :: SD@@ Thread ( D@@ at@@ as@@ et@@ D@@ W@@ I * ds , int id ) : m_@@ dat@@ as@@ et ( ds ) , m_id ( id ) { m_@@ dw@@ i = ds -> get@@ Data ( ) ; m_b@@ val@@ s = ds -> get@@ B@@ val@@ s ( ) ; m_b@@ vec@@ s = ds -> get@@ B@@ vec@@ s ( ) ; int nx = ds -> properties ( " ma@@ ing@@ l " ) . get ( Fn :: Property :: D_@@ N@@ X ) . toInt ( ) ; int ny = ds -> properties ( " ma@@ ing@@ l " ) . get ( Fn :: Property :: D_@@ NY ) . toInt ( ) ; int nz = ds -> properties ( " ma@@ ing@@ l " ) . get ( Fn :: Property :: D_@@ NZ ) . toInt ( ) ; m_@@ blockSize = nx * ny * nz ; }
void SD@@ Thread :: run ( ) { int num@@ Threads = GL@@ Functions :: ide@@ al@@ Thread@@ Count ; int pro@@ g@@ ress@@ Counter = 0 ; for ( int i = m_id ; i < m_@@ blockSize ; i += num@@ Threads ) { calc@@ SD ( i ) ; ++ pro@@ g@@ ress@@ Counter ; if ( pro@@ g@@ ress@@ Counter == 100 ) { emit ( progress ( ) ) ; pro@@ g@@ ress@@ Counter = 0 ; } } emit ( finished ( ) ) ; }
Column@@ Vector SD@@ Thread :: calc@@ SD ( int id ) { return Column@@ Vector ( 20 ) ; }
void Accumulator :: addOperand ( const intr@@ usive_@@ ptr < Expression > & pExpression ) { uassert ( 15943 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; }
void AN@@ N@@ k@@ d_@@ tree :: an@@ n@@ k@@ Pri@@ Search ( AN@@ N@@ point q , int k , AN@@ N@@ idx@@ Array n@@ n_@@ idx , AN@@ N@@ dist@@ Array dd , double e@@ ps ) { AN@@ N@@ pr@@ Max@@ Err = AN@@ N_@@ PO@@ W ( 1.0 + e@@ ps ) ; AN@@ N@@ _FLO@@ P ( 2 ) AN@@ N@@ pr@@ Dim = di@@ m ; AN@@ N@@ pr@@ Q = q ; AN@@ N@@ pr@@ P@@ ts = pts ; AN@@ N@@ pt@@ s@@ Visited = 0 ; AN@@ N@@ pr@@ Point@@ M@@ K = new AN@@ N@@ min_@@ k ( k ) ; AN@@ N@@ dist box_@@ dist = an@@ n@@ Box@@ Di@@ stance ( q , bn@@ d_@@ box_@@ lo , bn@@ d_@@ box_@@ h@@ i , di@@ m ) ; AN@@ N@@ pr@@ Box@@ P@@ Q = new AN@@ N@@ pr@@ _queue ( n_@@ pts ) ; AN@@ N@@ pr@@ Box@@ P@@ Q -> insert ( box_@@ dist , root ) ; while ( AN@@ N@@ pr@@ Box@@ P@@ Q -> non_@@ empty ( ) && ( ! ( AN@@ N@@ max@@ P@@ ts@@ Visited != 0 && AN@@ N@@ pt@@ s@@ Visited > AN@@ N@@ max@@ P@@ ts@@ Visited ) ) ) { AN@@ N@@ k@@ d_ptr n@@ p ; AN@@ N@@ pr@@ Box@@ P@@ Q -> extr@@ _@@ min ( box_@@ dist , ( void * & ) n@@ p ) ; AN@@ N@@ _FLO@@ P ( 2 ) if ( box_@@ dist * AN@@ N@@ pr@@ Max@@ Err >= AN@@ N@@ pr@@ Point@@ M@@ K -> max_@@ key ( ) ) break ; n@@ p -> an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( box_@@ dist ) ; } for ( int i = 0 ; i < k ; i ++ ) { dd [ i ] = AN@@ N@@ pr@@ Point@@ M@@ K -> ith@@ _@@ smalle@@ st_@@ key ( i ) ; n@@ n_@@ idx [ i ] = AN@@ N@@ pr@@ Point@@ M@@ K -> ith@@ _@@ smallest@@ _info ( i ) ; } delete AN@@ N@@ pr@@ Point@@ M@@ K ; delete AN@@ N@@ pr@@ Box@@ P@@ Q ; }
void AN@@ N@@ k@@ d_@@ split :: an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( AN@@ N@@ dist box_@@ dist ) { AN@@ N@@ dist new_@@ dist ; AN@@ N@@ co@@ ord c@@ ut_@@ diff = AN@@ N@@ pr@@ Q [ c@@ ut_@@ di@@ m ] - c@@ ut_@@ val ; if ( c@@ ut_@@ diff < 0 ) { AN@@ N@@ co@@ ord box_@@ diff = cd@@ _b@@ n@@ ds [ AN@@ N_@@ LO ] - AN@@ N@@ pr@@ Q [ c@@ ut_@@ di@@ m ] ; if ( box_@@ diff < 0 ) box_@@ diff = 0 ; new_@@ dist = ( AN@@ N@@ dist ) AN@@ N@@ _SU@@ M ( box_@@ dist , AN@@ N_@@ D@@ IF@@ F ( AN@@ N_@@ PO@@ W ( box_@@ diff ) , AN@@ N_@@ PO@@ W ( c@@ ut_@@ diff ) ) ) ; if ( child [ AN@@ N_@@ H@@ I ] != K@@ D_@@ TRI@@ VI@@ AL ) AN@@ N@@ pr@@ Box@@ P@@ Q -> insert ( new_@@ dist , child [ AN@@ N_@@ H@@ I ] ) ; child [ AN@@ N_@@ LO ] -> an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( box_@@ dist ) ; } else { AN@@ N@@ co@@ ord box_@@ diff = AN@@ N@@ pr@@ Q [ c@@ ut_@@ di@@ m ] - cd@@ _b@@ n@@ ds [ AN@@ N_@@ H@@ I ] ; if ( box_@@ diff < 0 ) box_@@ diff = 0 ; new_@@ dist = ( AN@@ N@@ dist ) AN@@ N@@ _SU@@ M ( box_@@ dist , AN@@ N_@@ D@@ IF@@ F ( AN@@ N_@@ PO@@ W ( box_@@ diff ) , AN@@ N_@@ PO@@ W ( c@@ ut_@@ diff ) ) ) ; if ( child [ AN@@ N_@@ LO ] != K@@ D_@@ TRI@@ VI@@ AL ) AN@@ N@@ pr@@ Box@@ P@@ Q -> insert ( new_@@ dist , child [ AN@@ N_@@ LO ] ) ; child [ AN@@ N_@@ H@@ I ] -> an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( box_@@ dist ) ; } AN@@ N@@ _SP@@ L ( 1 ) AN@@ N@@ _FLO@@ P ( 8 ) }
void AN@@ N@@ k@@ d_@@ le@@ af :: an@@ n@@ _p@@ ri@@ _@@ se@@ arch ( AN@@ N@@ dist box_@@ dist ) { regi@@ ster AN@@ N@@ dist dist ; regi@@ ster AN@@ N@@ co@@ ord * pp ; regi@@ ster AN@@ N@@ co@@ ord * q@@ q ; regi@@ ster AN@@ N@@ dist min_@@ dist ; regi@@ ster AN@@ N@@ co@@ ord t ; regi@@ ster int d ; min_@@ dist = AN@@ N@@ pr@@ Point@@ M@@ K -> max_@@ key ( ) ; for ( int i = 0 ; i < n_@@ pts ; i ++ ) { pp = AN@@ N@@ pr@@ P@@ ts [ b@@ k@@ t [ i ] ] ; q@@ q = AN@@ N@@ pr@@ Q ; dist = 0 ; for ( d = 0 ; d < AN@@ N@@ pr@@ Dim ; d ++ ) { AN@@ N_@@ CO@@ OR@@ D ( 1 ) AN@@ N@@ _FLO@@ P ( 4 ) t = * ( q@@ q ++ ) - * ( pp ++ ) ; if ( ( dist = AN@@ N@@ _SU@@ M ( dist , AN@@ N_@@ PO@@ W ( t ) ) ) > min_@@ dist ) { break ; } } if ( d >= AN@@ N@@ pr@@ Dim && ( AN@@ N_@@ ALLO@@ W_S@@ EL@@ F_@@ MATCH || dist != 0 ) ) { AN@@ N@@ pr@@ Point@@ M@@ K -> insert ( dist , b@@ k@@ t [ i ] ) ; min_@@ dist = AN@@ N@@ pr@@ Point@@ M@@ K -> max_@@ key ( ) ; } } AN@@ N_@@ LEA@@ F ( 1 ) AN@@ N_@@ PTS ( n_@@ pts ) AN@@ N@@ pt@@ s@@ Visited += n_@@ pts ; }
void CDV@@ DSubtitleTagMicro@@ DVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; }
Highlighter :: Highlighter ( Editor * text , Dictionary * dictionary ) : QSyntaxHighlighter ( text -> document ( ) ) , m_dictionary ( dictionary ) , m_text ( text ) , m_enabled ( true ) , m_misspelled ( " # ff0000" ) { connect ( m_text , SIGNAL ( cursorPositionChanged ( ) ) , this , SLOT ( cursorPositionChanged ( ) ) ) ; m_text -> viewport ( ) -> installEventFilter ( this ) ; m_add_action = new QAction ( tr ( " Add " ) , this ) ; m_check_action = new QAction ( tr ( " Check ▁ Spelling . . . " ) , this ) ; }
void Highlighter :: setEnabled ( bool enabled ) { m_enabled = enabled ; rehighlight ( ) ; }
void Highlighter :: setMis@@ spelledColor ( const QColor & color ) { m_misspelled = color ; rehighlight ( ) ; }
bool Highlighter :: eventFilter ( QObject * watched , QEvent * event ) { if ( watched != m_text -> viewport ( ) || event -> type ( ) != QEvent :: ContextMenu || ! m_enabled ) { return QSyntaxHighlighter :: eventFilter ( watched , event ) ; } else { QContextMenuEvent * context_event = static_cast < QContextMenuEvent * > ( event ) ; m_start_cursor = m_text -> cursorForPosition ( context_event -> pos ( ) ) ; QTextBlock block = m_start_cursor . block ( ) ; int cursor = m_start_cursor . position ( ) - block . position ( ) ; bool under_mouse = false ; QStringRef word ; QVector < QStringRef > words = static_cast < BlockStats * > ( block . userData ( ) ) -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta >= 0 && delta <= word . length ( ) ) { under_mouse = true ; break ; } } if ( ! under_mouse ) { return false ; } else { m_cursor = m_start_cursor ; m_cursor . setPosition ( word . position ( ) + block . position ( ) ) ; m_cursor . setPosition ( m_cursor . position ( ) + word . length ( ) , QTextCursor :: Keep@@ Anchor ) ; m_word = m_cursor . selectedText ( ) ; m_text -> setTextCursor ( m_cursor ) ; QMenu * menu = new QMenu ; QStringList guesses = m_dictionary -> suggestions ( m_word ) ; if ( ! guesses . isEmpty ( ) ) { foreach ( const QString & guess , guesses ) { menu -> addAction ( guess ) ; } } else { QAction * none_action = menu -> addAction ( tr ( " ( No ▁ suggestions ▁ found ) " ) ) ; none_action -> setEnabled ( false ) ; } menu -> addSeparator ( ) ; menu -> addAction ( m_add_action ) ; menu -> addSeparator ( ) ; menu -> addAction ( m_check_action ) ; connect ( menu , SIGNAL ( triggered ( QAction * ) ) , this , SLOT ( suggestion ( QAction * ) ) ) ; menu -> exec ( context_event -> globalPos ( ) ) ; delete menu ; return true ; } } }
void Highlighter :: highlightBlock ( const QString & text ) { QTextCharFormat hformat ; QTextBlockFormat blockformat = currentBlock ( ) . blockFormat ( ) ; if ( blockformat . hasProperty ( QTextFormat :: UserProperty ) ) { hformat . setProperty ( QTextFormat :: FontWeight , blockformat . property ( QTextFormat :: FontWeight ) ) ; hformat . setProperty ( QTextFormat :: FontItalic , blockformat . property ( QTextFormat :: FontItalic ) ) ; hformat . setProperty ( QTextFormat :: FontSizeAdjustment , blockformat . property ( QTextFormat :: FontSizeAdjustment ) ) ; setFormat ( 0 , text . length ( ) , hformat ) ; } if ( ! m_enabled ) { return ; } int cursor = m_text -> textCursor ( ) . position ( ) - currentBlock ( ) . position ( ) ; BlockStats * stats = static_cast < BlockStats * > ( currentBlockUserData ( ) ) ; if ( ! stats ) { stats = new BlockStats ( text , m_dictionary ) ; setCurrentBlockUserData ( stats ) ; } QTextCharFormat error ; error . setUnderline@@ Color ( m_misspelled ) ; error . setUnderline@@ Style ( QTextCharFormat :: SpellCheck@@ Under@@ line ) ; error . merge ( hformat ) ; QVector < QStringRef > words = stats -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { const QStringRef & word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta < 0 || delta > word . length ( ) ) { setFormat ( word . position ( ) , word . length ( ) , error ) ; } } }
void Highlighter :: cursorPositionChanged ( ) { QTextBlock current = m_text -> textCursor ( ) . block ( ) ; if ( m_current != current ) { if ( m_current . isValid ( ) && m_text -> document ( ) -> blockCount ( ) > m_current . blockNumber ( ) ) { rehighlightBlock ( m_current ) ; } m_current = current ; } rehighlightBlock ( m_current ) ; }
void Highlighter :: suggestion ( QAction * action ) { if ( action == m_add_action ) { m_text -> setTextCursor ( m_start_cursor ) ; m_dictionary -> add ( m_word ) ; } else if ( action == m_check_action ) { m_text -> setTextCursor ( m_start_cursor ) ; SpellChecker :: checkDocument ( m_text ) ; } else { m_cursor . insertText ( action -> text ( ) ) ; } }
