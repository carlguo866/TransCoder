<DOCUMENT_ID="B@@ aha/@@ z3@@ /tree/master/src/qe/@@ qe_arith@@ _plugin.cpp"> # include " qe . h " # include " ast _ pp . h " # include " expr _ safe _ replace . h " # include " bool _ rewriter . h " # include " bv _ decl _ plugin . h " # include " arith _ decl _ plugin . h " # include " arith _ eq _ solver . h " # include " arith _ rewriter . h " # include " th _ rewriter . h " # include " factor _ rewriter . h " # include " obj _ pair _ hashtable . h " # include " nlarith _ util . h " # include " model _ evaluator . h " # include " smt _ ker@@ nel . h " namespace qe { class bound { rational m_coeff ; expr_ref m_term ; bool m_is_strict ; public : bound ( ast_manager & m , rational const & n , expr * t , bool is_strict ) : m_coeff ( n ) , m_term ( t , m ) , m_is_strict ( is_strict ) { } bool is_strict ( ) const { return m_is_strict ; } expr * term ( ) const { return m_term . get ( ) ; } rational const & coeff ( ) const { return m_coeff ; } void update ( rational const & k , expr * t ) { m_coeff = k ; m_term = t ; } void pp ( std :: ostream & out , app * x ) { ast_manager & m = m_term . get_manager ( ) ; out << " ( < = ▁ ( + ▁ ( * ▁ " << coeff ( ) << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( term ( ) , m ) << " ) ▁ 0 ) " ; } } ; typedef rational numeral ; class div_constraint { numeral m_k ; numeral m_a ; expr * m_term ; public : div_constraint ( numeral const & k , numeral const & a , expr * t ) : m_k ( k ) , m_a ( a ) , m_term ( t ) { } numeral const & a ( ) const { return m_a ; } numeral const & k ( ) const { return m_k ; } expr * t ( ) const { return m_term ; } numeral & a_ref ( ) { return m_a ; } numeral & k_ref ( ) { return m_k ; } expr * & t_ref ( ) { return m_term ; } } ; typedef vector < div_constraint > div_constraints ; class arith_qe_util { ast_manager & m ; i_solver_context & m_ctx ; public : arith_util m_arith ; th_rewriter simplify ; private : arith_eq_@@ solver m_arith_solver ; bv_@@ util m_bv ; expr_ref m_zero_i ; expr_ref m_one_i ; expr_ref m_minus_one_i ; expr_ref m_zero_r ; expr_ref m_one_r ; expr_ref m_tmp ; public : expr_safe_replace m_replace ; bool_rewriter m_bool_rewriter ; arith_rewriter m_arith_rewriter ; arith_qe_util ( ast_manager & m , smt_params & p , i_solver_context & ctx ) : m ( m ) , m_ctx ( ctx ) , m_arith ( m ) , simplify ( m ) , m_arith_solver ( m ) , m_bv ( m ) , m_zero_i ( m_arith . mk_numeral ( numeral ( 0 ) , true ) , m ) , m_one_i ( m_arith . mk_numeral ( numeral ( 1 ) , true ) , m ) , m_minus_one_i ( m_arith . mk_numeral ( numeral ( - 1 ) , true ) , m ) , m_zero_r ( m_arith . mk_numeral ( numeral ( 0 ) , false ) , m ) , m_one_r ( m_arith . mk_numeral ( numeral ( 1 ) , false ) , m ) , m_tmp ( m ) , m_replace ( m ) , m_bool_rewriter ( m ) , m_arith_rewriter ( m ) { } ast_manager & get_manager ( ) { return m ; } bool get_coeff ( contains_app & contains_x , expr * p , rational & k , expr_ref & rest ) { app * x = contains_x . x ( ) ; ptr_vector < expr > restl , todo ; todo . push_back ( p ) ; bool found = false ; expr * e1 , * e2 ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( e ) ) { for ( unsigned i = 0 ; i < to_app ( e ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( e ) -> get_arg ( i ) ) ; } } else if ( e == x ) { k = numeral ( 1 ) ; found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e1 == x && m_arith . is_numeral ( e2 , k ) ) { found = true ; break ; } else if ( m_arith . is_mul ( e , e1 , e2 ) && e2 == x && m_arith . is_numeral ( e1 , k ) ) { found = true ; break ; } else { restl . push_back ( e ) ; } } if ( ! found ) { TRACE ( " qe _ verbose " , tout << " Did ▁ not ▁ find : ▁ " << mk_pp ( x , m ) << " ▁ in ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( x ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } if ( contains_x ( rest ) ) { return false ; } TRACE ( " qe _ verbose " , tout << mk_pp ( p , m ) << " ▁ = ▁ " << " ( + ▁ ( * ▁ " << k << " ▁ " << mk_pp ( x , m ) << " ) ▁ " << mk_pp ( rest , m ) << " ) \n " ; ) ; return true ; } void get_const ( expr * p , rational & k , expr_ref & rest ) { ptr_vector < expr > todo , restl ; todo . push_back ( p ) ; k = numeral ( 0 ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_numeral ( p , k ) ) { break ; } else { restl . push_back ( p ) ; } } while ( ! todo . empty ( ) ) { restl . push_back ( todo . back ( ) ) ; todo . pop_back ( ) ; } if ( restl . empty ( ) ) { rest = mk_zero ( p ) ; } else { rest = m_arith . mk_add ( restl . size ( ) , restl . c_ptr ( ) ) ; } } bool is_neg ( app * e , expr_ref & ne ) { if ( m . is_not ( e ) ) { ne = to_app ( e ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_le ( app * e , expr_ref & p ) { return is_le_ge_core < 1 > ( e , p ) ; } bool is_ge ( app * e , expr_ref & p ) { return is_le_ge_core < 0 > ( e , p ) ; } bool is_lt ( app * e , expr_ref & p ) { numeral k ; expr * a1 , * a2 ; if ( m_arith . is_lt ( e , a1 , a2 ) || m_arith . is_gt ( e , a2 , a1 ) ) { p = a1 ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_divides ( app * e , numeral & k , expr_ref & p ) { expr * e1 , * e2 ; if ( ! m . is_eq ( e , e1 , e2 ) ) { return false ; } return is_divides ( e1 , e2 , k , p ) || is_divides ( e2 , e1 , k , p ) ; } bool is_divides ( expr * e1 , expr * e2 , numeral & k , expr_ref & p ) { if ( m_arith . is_mod ( e2 ) && m_arith . is_numeral ( e1 , k ) && k . is_zero ( ) && m_arith . is_numeral ( to_app ( e2 ) -> get_arg ( 1 ) , k ) ) { p = to_app ( e2 ) -> get_arg ( 0 ) ; return true ; } return false ; } bool is_not_divides ( app * e , app_ref & n , numeral & k , expr_ref & p ) { if ( ! m . is_not ( e ) ) { return false ; } if ( ! is_app ( to_app ( e ) -> get_arg ( 0 ) ) ) { return false ; } n = to_app ( to_app ( e ) -> get_arg ( 0 ) ) ; return is_divides ( n , k , p ) ; } bool is_real ( app * x ) const { return m_arith . is_real ( x ) ; } template < bool is_strict > void mk_bound_aux ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { SASSERT ( a . is_neg ( ) == b . is_neg ( ) ) ; expr_ref tt ( t , m ) , ss ( s , m ) , e ( m ) ; rational abs_a ( a ) ; rational abs_b ( b ) ; if ( abs_a . is_neg ( ) ) abs_a . neg ( ) ; if ( abs_b . is_neg ( ) ) abs_b . neg ( ) ; ss = mk_mul ( abs_a , ss ) ; tt = mk_mul ( abs_b , tt ) ; if ( a . is_neg ( ) ) { e = mk_sub ( tt , ss ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } else { e = mk_sub ( ss , tt ) ; if ( is_strict ) { if ( m_arith . is_int ( e ) ) { e = mk_add ( e , m_one_i ) ; mk_le ( e , result ) ; } else { mk_lt ( e , result ) ; } } else { mk_le ( e , result ) ; } } } void mk_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < false > ( a , t , b , s , result ) ; } void mk_strict_bound ( rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { mk_bound_aux < true > ( a , t , b , s , result ) ; } void mk_divides ( numeral n , expr * e , expr_ref & result ) { SASSERT ( n . is_int ( ) ) ; expr_ref tmp1 ( e , m ) , tmp2 ( m ) ; simplify ( tmp1 ) ; m_arith_rewriter . mk_mod ( tmp1 , mk_numeral ( n ) , tmp2 ) ; m_bool_rewriter . mk_eq ( m_zero_i , tmp2 , result ) ; } void mk_div ( expr * a , numeral const & k , expr_ref & result ) { result = m_arith . mk_div ( a , m_arith . mk_numeral ( k , false ) ) ; simplify ( result ) ; } expr * mk_numeral ( numeral const & k , bool is_int = true ) { return m_arith . mk_numeral ( k , is_int ) ; } expr * mk_numeral ( int k , bool is_int ) { return mk_numeral ( numeral ( k ) , is_int ) ; } expr * mk_uminus ( expr * e ) { return m_arith . mk_uminus ( e ) ; } expr * mk_abs ( expr * e ) { rational val ; if ( m_arith . is_numeral ( e , val ) ) { if ( val . is_neg ( ) ) { return m_arith . mk_uminus ( e ) ; } else { return e ; } } else { return m . mk_ite ( m_arith . mk_le ( mk_zero ( e ) , e ) , e , m_arith . mk_uminus ( e ) ) ; } } template < bool is_max > expr_ref mk_min_max ( unsigned num_args , expr * const * args ) { SASSERT ( num_args > 0 ) ; if ( num_args == 1 ) { return expr_ref ( args [ 0 ] , m ) ; } else { expr_ref e2 = mk_min_max < is_max > ( num_args - 1 , args + 1 ) ; expr * e1 = args [ 0 ] ; expr * cmp = is_max ? m_arith . mk_le ( e1 , e2 ) : m_arith . mk_le ( e2 , e1 ) ; return expr_ref ( m . mk_ite ( cmp , e2 , e1 ) , m ) ; } } expr_ref mk_max ( unsigned num_args , expr * const * args ) { return mk_min_max < true > ( num_args , args ) ; } expr_ref mk_min ( unsigned num_args , expr * const * args ) { return mk_min_max < false > ( num_args , args ) ; } expr * mk_mul ( expr * a , expr * b ) { return m_arith . mk_mul ( a , b ) ; } expr * mk_add ( expr * a , expr * b ) { return m_arith . mk_add ( a , b ) ; } expr * mk_sub ( expr * a , expr * b ) { return m_arith . mk_sub ( a , b ) ; } expr * mk_mul ( numeral const & a , expr * b ) { if ( a . is_one ( ) ) return b ; return m_arith . mk_mul ( mk_numeral ( a , m_arith . is_int ( b ) ) , b ) ; } expr * mk_zero ( sort * s ) { return m_arith . is_int ( s ) ? m_zero_i : m_zero_r ; } expr * mk_zero ( expr * e ) { return m_arith . is_int ( e ) ? m_zero_i : m_zero_r ; } expr * mk_one ( sort * s ) { return m_arith . is_int ( s ) ? m_one_i : m_one_r ; } expr * mk_one ( expr * e ) { return m_arith . is_int ( e ) ? m_one_i : m_one_r ; } void mk_le ( expr * e , expr_ref & result ) { expr_ref tmp ( e , m ) ; simplify ( tmp ) ; m_arith_rewriter . mk_le ( tmp , mk_zero ( e ) , result ) ; } void mk_lt ( expr * e , expr_ref & result ) { rational r ; if ( m_arith . is_numeral ( e , r ) ) { if ( r . is_neg ( ) ) { result = m . mk_true ( ) ; } else { result = m . mk_false ( ) ; } } else if ( m_arith . is_int ( e ) ) { result = m_arith . mk_le ( e , m_minus_one_i ) ; } else { result = m . mk_not ( m_arith . mk_le ( mk_zero ( e ) , e ) ) ; } simplify ( result ) ; TRACE ( " qe _ verbose " , tout << " mk _ lt ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_eq ( rational const & a , app * x , expr * t , expr_ref & result ) { result = m_arith . mk_eq ( mk_add ( mk_mul ( a , x ) , t ) , mk_zero ( x ) ) ; } void mk_and ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_and ( sz , args , result ) ; } void mk_and ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_and ( e1 , e2 , result ) ; } void add_and ( expr * e , ptr_vector < expr > & conjs ) { if ( m . is_and ( e ) ) { conjs . append ( to_app ( e ) -> get_num_args ( ) , to_app ( e ) -> get_args ( ) ) ; } else { conjs . push_back ( e ) ; } } void mk_flat_and ( expr * e1 , expr * e2 , expr_ref & result ) { ptr_vector < expr > conjs ; add_and ( e1 , conjs ) ; add_and ( e2 , conjs ) ; m_bool_rewriter . mk_and ( conjs . size ( ) , conjs . c_ptr ( ) , result ) ; } void mk_or ( unsigned sz , expr * const * args , expr_ref & result ) { m_bool_rewriter . mk_or ( sz , args , result ) ; } void mk_or ( expr * e1 , expr * e2 , expr_ref & result ) { m_bool_rewriter . mk_or ( e1 , e2 , result ) ; } void mk_resolve ( app * x , bool is_strict , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { rational abs_a ( abs ( a ) ) , abs_b ( abs ( b ) ) ; SASSERT ( a . is_neg ( ) == b . is_pos ( ) ) ; SASSERT ( ! is_strict || ( abs_a . is_one ( ) && abs_b . is_one ( ) ) ) ; expr_ref bt ( mk_mul ( abs_b , t ) , m ) ; expr_ref as ( mk_mul ( abs_a , s ) , m ) ; expr_ref as_bt ( mk_add ( as , bt ) , m ) ; if ( is_strict ) { mk_lt ( as_bt , result ) ; } else { mk_le ( as_bt , result ) ; } if ( ! abs_a . is_one ( ) && ! abs_b . is_one ( ) ) { SASSERT ( ! is_strict ) ; SASSERT ( abs_a > rational :: one ( ) && abs_b > rational :: one ( ) ) ; expr_ref slack ( mk_numeral ( ( abs_a - numeral ( 1 ) ) * ( abs_b - numeral ( 1 ) ) , true ) , m ) ; expr_ref result1 ( m ) , result2 ( m ) ; expr_ref as_bt_le_0 ( result , m ) , tmp2 ( m ) , asz_bt_le_0 ( m ) , tmp3 ( m ) , tmp4 ( m ) ; expr_ref b_divides_sz ( m ) ; tmp2 = m_arith . mk_add ( as_bt , slack ) ; mk_le ( tmp2 , result1 ) ; rational a1 = a , b1 = b ; if ( abs_a < abs_b ) { std :: swap ( abs_a , abs_b ) ; std :: swap ( a1 , b1 ) ; std :: swap ( s , t ) ; std :: swap ( as , bt ) ; } SASSERT ( abs_a >= abs_b ) ; expr_ref sz ( mk_add ( s , x ) , m ) ; if ( b1 . is_pos ( ) ) { sz = m_arith . mk_uminus ( sz ) ; } tmp4 = mk_add ( mk_mul ( a1 , sz ) , bt ) ; mk_le ( tmp4 , asz_bt_le_0 ) ; if ( to_app ( asz_bt_le_0 ) -> get_arg ( 0 ) == x && m_arith . is_zero ( to_app ( asz_bt_le_0 ) -> get_arg ( 1 ) ) ) { mk_divides ( abs_b , s , tmp2 ) ; } else { mk_divides ( abs_b , sz , b_divides_sz ) ; mk_and ( b_divides_sz , asz_bt_le_0 , tmp4 ) ; mk_big_or ( abs_b - numeral ( 2 ) , x , tmp4 , tmp2 ) ; TRACE ( " qe " , tout << " b ▁ | ▁ s ▁ + ▁ z : ▁ " << mk_pp ( b_divides_sz , m ) << " \n " ; tout << " a ( s + z ) ▁ + ▁ bt ▁ < = ▁ 0 : ▁ " << mk_pp ( asz_bt_le_0 , m ) << " \n " ; ) ; } mk_flat_and ( as_bt_le_0 , tmp2 , result2 ) ; mk_or ( result1 , result2 , result ) ; simplify ( result ) ; } TRACE ( " qe " , { tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; bound ( m , a , t , false ) . pp ( tout , x ) ; tout << " \n " ; bound ( m , b , s , false ) . pp ( tout , x ) ; tout << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } struct mul_lt { arith_util & u ; mul_lt ( arith_qe_util & u ) : u ( u . m_arith ) { } bool operator ( ) ( expr * n1 , expr * n2 ) const { expr * x , * y ; if ( u . is_mul ( n1 , x , y ) && u . is_numeral ( x ) ) { n1 = y ; } if ( u . is_mul ( n2 , x , y ) && u . is_numeral ( x ) ) { n2 = y ; } return n1 -> get_id ( ) < n2 -> get_id ( ) ; } } ; void normalize_sum ( expr_ref & p ) { simplify ( p ) ; if ( ! m_arith . is_add ( p ) ) { return ; } unsigned sz = to_app ( p ) -> get_num_args ( ) ; ptr_buffer < expr > args ; for ( unsigned i = 0 ; i < sz ; ++ i ) { args . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } std :: sort ( args . begin ( ) , args . end ( ) , mul_lt ( * this ) ) ; p = m_arith . mk_add ( args . size ( ) , args . c_ptr ( ) ) ; } void pp_div ( std :: ostream & out , app * x , div_constraint const & div ) { out << div . k ( ) << " ▁ | ▁ ( " << div . a ( ) << " * " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( div . t ( ) , m ) << " ) ▁ " ; } void pp_@@ divs ( std :: ostream & out , app * x , div_constraints const & divs ) { for ( unsigned i = 0 ; i < divs . size ( ) ; ++ i ) { pp_div ( out , x , divs [ i ] ) ; out << " ▁ " ; } } bool mk_atom ( expr * e , bool p , expr_ref & result ) { if ( ! is_app ( e ) ) { return false ; } app * a = to_app ( e ) ; expr_ref t1 ( m ) , t2 ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; rational k ; expr * a0 , * a1 ; if ( p && is_divides ( a , k , tmp1 ) ) { result = e ; } else if ( ! p && is_divides ( a , k , tmp1 ) ) { m_bool_rewriter . mk_not ( e , result ) ; } else if ( p && m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_and ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_int ( a0 ) ) { tmp1 = mk_sub ( a0 , a1 ) ; t1 = mk_add ( mk_one ( a0 ) , tmp1 ) ; simplify ( t1 ) ; t2 = mk_sub ( mk_one ( a0 ) , tmp1 ) ; simplify ( t2 ) ; mk_le ( t1 , tmp1 ) ; mk_le ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && m . is_eq ( e , a0 , a1 ) && m_arith . is_real ( a0 ) ) { t1 = mk_sub ( a0 , a1 ) ; simplify ( t1 ) ; t2 = mk_sub ( a1 , a0 ) ; simplify ( t2 ) ; mk_lt ( t1 , tmp1 ) ; mk_lt ( t2 , tmp2 ) ; mk_or ( tmp1 , tmp2 , result ) ; } else if ( ! p && ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_lt ( tmp1 , result ) ; } else if ( p && ( m_arith . is_le ( e ) || m_arith . is_ge ( e ) ) ) { result = e ; } else if ( p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a0 , a1 ) ; mk_lt ( tmp1 , result ) ; } else if ( ! p && ( m_arith . is_lt ( e , a0 , a1 ) || m_arith . is_gt ( e , a1 , a0 ) ) ) { tmp1 = mk_sub ( a1 , a0 ) ; mk_le ( tmp1 , result ) ; } else { return false ; } TRACE ( " qe _ verbose " , tout << " Atom : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } void mk_bounded_var ( rational const & n , app_ref & z_bv , app_ref & z ) { rational two ( 2 ) , b ( n ) ; unsigned sz = 0 ; do { ++ sz ; b = div ( b , two ) ; } while ( b . is_pos ( ) ) ; sort * s = m_bv . mk_sort ( sz ) ; z_bv = m . mk_fresh_const ( " z " , s ) ; expr_ref tmp ( m ) ; z = m_bv . mk_bv2@@ int ( z_bv ) ; } bool solve ( conj_enum & conjs , expr * fml ) { expr_ref_vector eqs ( m ) ; extract_equalities ( conjs , eqs ) ; return reduce_equations ( eqs . size ( ) , eqs . c_ptr ( ) , fml ) ; } void extract_equalities ( conj_enum & conjs , expr_ref_vector & eqs ) { obj_hashtable < expr > leqs ; expr_ref_vector trail ( m ) ; expr_ref tmp1 ( m ) , tmp2 ( m ) ; expr * a0 , * a1 ; eqs . reset ( ) ; conj_enum :: iterator it = conjs . begin ( ) , end = conjs . end ( ) ; for ( ; it != end ; ++ it ) { expr * e = * it ; bool is_leq = false ; if ( m . is_eq ( e , a0 , a1 ) && is_arith ( a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; simplify ( tmp1 ) ; eqs . push_back ( tmp1 ) ; } else if ( m_arith . is_le ( e , a0 , a1 ) || m_arith . is_ge ( e , a1 , a0 ) ) { m_arith_rewriter . mk_sub ( a0 , a1 , tmp1 ) ; is_leq = true ; } else { } if ( is_leq ) { normalize_sum ( tmp1 ) ; tmp2 = m_arith . mk_uminus ( tmp1 ) ; normalize_sum ( tmp2 ) ; if ( leqs . contains ( tmp2 ) ) { eqs . push_back ( tmp1 ) ; TRACE ( " qe " , tout << " found : ▁ ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } else { trail . push_back ( tmp1 ) ; leqs . insert ( tmp1 ) ; TRACE ( " qe _ verbose " , tout << " insert : ▁ " << mk_pp ( tmp1 , m ) << " \n " ; ) ; } } } } private : template < unsigned IS_LE > bool is_le_ge_core ( app * e , expr_ref & p ) { numeral k ; expr_ref tmp ( m ) ; expr * a2 ; if ( m_arith . is_le ( e ) ) { p = e -> get_arg ( 1 - IS_LE ) ; a2 = e -> get_arg ( IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else if ( m_arith . is_ge ( e ) ) { p = e -> get_arg ( IS_LE ) ; a2 = e -> get_arg ( 1 - IS_LE ) ; if ( m_arith . is_numeral ( a2 , k ) && k . is_zero ( ) ) { return true ; } } else { return false ; } p = mk_sub ( p , a2 ) ; simplify ( p ) ; return true ; } bool is_arith ( expr * e ) { return m_arith . is_int ( e ) || m_arith . is_real ( e ) ; } void mk_big_or ( numeral up , app * x , expr * body , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( x , m ) << " ▁ " << mk_pp ( body , m ) << " \n " ; ) ; if ( numeral ( 1 ) >= up ) { mk_big_or_blast ( up , x , body , result ) ; } else { mk_big_or_symbolic_blast ( up , x , body , result ) ; } } void mk_big_or_blast ( numeral up , app * x , expr * body , expr_ref & result ) { expr_ref_vector ors ( m ) ; numeral index ( 0 ) ; while ( index <= up ) { expr * n = mk_numeral ( index ) ; result = body ; m_replace . apply_substitution ( x , n , result ) ; ors . push_back ( result ) ; ++ index ; } mk_or ( ors . size ( ) , ors . c_ptr ( ) , result ) ; TRACE ( " qe " , tout << " [ 0 ▁ " << up << " ] ▁ " << mk_pp ( x , m ) << " \n " << mk_pp ( body , m ) << " \n " << mk_pp ( result , m ) << " \n " ; ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . add_var ( z_bv ) ; } void mk_big_or_symbolic_blast ( numeral up , app * x , expr * body , expr_ref & result ) { app_ref z_bv ( m ) ; mk_big_or_symbolic ( up , x , body , z_bv , result ) ; m_ctx . blast_@@ or ( z_bv , result ) ; } void mk_big_or_symbolic ( numeral up , app * x , expr * body , app_ref & z_bv , expr_ref & result ) { expr * e1 = m_arith . mk_le ( x , m_arith . mk_numeral ( up , true ) ) ; mk_flat_and ( e1 , body , result ) ; app_ref z ( m ) ; mk_bounded_var ( up , z_bv , z ) ; m_replace . apply_substitution ( x , z , result ) ; } bool isolate_x ( expr * p , app * x , contains_app & contains_x , numeral & coeff ) { numeral k ; while ( m_arith . is_add ( p ) ) { bool found_x = false ; expr * next_p = 0 ; for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { expr * arg = to_app ( p ) -> get_arg ( i ) ; if ( contains_x ( arg ) ) { if ( found_x ) { return false ; } found_x = true ; next_p = arg ; } } if ( ! next_p ) { return false ; } p = next_p ; } expr * e1 , * e2 ; if ( p == x ) { coeff = numeral ( 1 ) ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && e2 == x ) { coeff = k ; return true ; } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && e1 == x ) { coeff = k ; return true ; } return false ; } bool reduce_equations ( unsigned num_eqs , expr * const * eqs , expr * fml ) { for ( unsigned i = 0 ; i < num_eqs ; ++ i ) { if ( reduce_equation ( eqs [ i ] , fml ) ) { return true ; } } return false ; } bool solve_singular ( unsigned var_idx , expr * p , expr * fml ) { rational k ; expr_ref e ( m ) , tmp ( m ) ; app * x = m_ctx . get_var ( var_idx ) ; if ( ! isolate_x ( p , x , m_ctx . contains ( var_idx ) , k ) ) { return false ; } if ( m_arith . is_int ( x ) && ! ( abs ( k ) . is_one ( ) ) ) { return false ; } if ( abs ( k ) . is_one ( ) ) { if ( k . is_neg ( ) ) { e = m_arith . mk_add ( p , x ) ; } else { e = m_arith . mk_sub ( x , p ) ; } } else { SASSERT ( ! m_arith . is_int ( x ) ) ; expr * ke = m_arith . mk_numeral ( - k , false ) ; tmp = m_arith . mk_mul ( ke , x ) ; tmp = m_arith . mk_add ( p , tmp ) ; e = m_arith . mk_div ( tmp , ke ) ; } TRACE ( " qe " , tout << " is ▁ singular : \n " << mk_pp ( p , m ) << " \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( e , m ) << " \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , e , result ) ; simplify ( result ) ; TRACE ( " qe " , tout << " singular ▁ solved : \n " << mk_pp ( result , m ) << " \n " ; ) ; m_ctx . elim_var ( var_idx , result , e ) ; return true ; } bool solve_singular ( expr * p , expr * fml ) { unsigned num_vars = m_ctx . get_num_vars ( ) ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( solve_singular ( i , p , fml ) ) { return true ; } } return false ; } bool solve_linear ( expr * p , expr * fml ) { vector < numeral > values ; unsigned num_vars = m_ctx . get_num_vars ( ) ; app * const * vars_ptr = m_ctx . get_vars ( ) ; if ( ! is_linear ( p , num_vars , vars_ptr , values ) ) { return false ; } TRACE ( " qe " , tout << " is ▁ linear : ▁ " << mk_pp ( p , m ) << " \n " ; ) ; SASSERT ( values . size ( ) == num_vars + 1 ) ; SASSERT ( num_vars > 0 ) ; unsigned index ; bool is_aux ; VERIFY ( m_arith_solver . solve_integ@@ er_equation ( values , index , is_aux ) ) ; SASSERT ( 1 <= index && index <= num_vars ) ; app_ref x ( m_ctx . get_var ( index - 1 ) , m ) ; app_ref z ( m ) ; expr_ref p1 ( m ) ; if ( is_aux ) { SASSERT ( values [ index ] >= rational ( 3 ) ) ; z = m . mk_fresh_const ( " x " , m_arith . mk_int ( ) ) ; m_ctx . add_var ( z ) ; p1 = m_arith . mk_mul ( m_arith . mk_numeral ( values [ index ] , true ) , z ) ; } else { p1 = m_arith . mk_numeral ( numeral ( 0 ) , true ) ; } for ( unsigned i = 1 ; i <= num_vars ; ++ i ) { numeral k = values [ i ] ; if ( ! k . is_zero ( ) && i != index ) { p1 = m_arith . mk_add ( p1 , m_arith . mk_mul ( m_arith . mk_numeral ( k , true ) , m_ctx . get_var ( i - 1 ) ) ) ; } } p1 = m_arith . mk_add ( p1 , m_arith . mk_numeral ( values [ 0 ] , true ) ) ; TRACE ( " qe " , tout << " is ▁ linear : \n " << mk_pp ( fml , m ) << " \n " << mk_pp ( p , m ) << " \n " << mk_pp ( x , m ) << " ▁ = ▁ " << mk_pp ( p1 , m ) << " \n " ; tout << values [ 0 ] << " ▁ + ▁ " ; for ( unsigned i = 0 ; i < num_vars ; ++ i ) { tout << " ▁ + ▁ " << values [ i + 1 ] << " ▁ * ▁ " << mk_pp ( m_ctx . get_var ( i ) , m ) << " ▁ " ; } tout << " ▁ = ▁ 0 \n " ; ) ; expr_ref result ( fml , m ) ; m_replace . apply_substitution ( x , p1 , result ) ; simplify ( result ) ; m_ctx . elim_var ( index - 1 , result , p1 ) ; TRACE ( " qe " , tout << " Reduced : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; return true ; } bool reduce_equation ( expr * p , expr * fml ) { numeral k ; if ( m_arith . is_numeral ( p , k ) && k . is_zero ( ) ) { return false ; } return solve_singular ( p , fml ) || solve_linear ( p , fml ) ; } bool find_variable ( expr * p , unsigned num_vars , app * const * vars , numeral * values , numeral const & k ) { if ( ! is_app ( p ) || to_app ( p ) -> get_num_args ( ) > 0 ) { return false ; } for ( unsigned i = 0 ; i < num_vars ; ++ i ) { if ( p == vars [ i ] ) { values [ i ] += k ; return true ; } } return false ; } bool is_linear ( expr * p , unsigned num_vars , app * const * vars , vector < numeral > & values ) { if ( num_vars == 0 ) { return false ; } values . reset ( ) ; for ( unsigned i = 0 ; i <= num_vars ; ++ i ) { values . push_back ( numeral ( 0 ) ) ; } numeral * vars_ptr = values . c_ptr ( ) + 1 ; ptr_vector < expr > todo ; numeral k ; expr * e1 , * e2 ; todo . push_back ( p ) ; while ( ! todo . empty ( ) ) { p = todo . back ( ) ; todo . pop_back ( ) ; if ( m_arith . is_add ( p ) ) { for ( unsigned i = 0 ; i < to_app ( p ) -> get_num_args ( ) ; ++ i ) { todo . push_back ( to_app ( p ) -> get_arg ( i ) ) ; } } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e1 , k ) && find_variable ( e2 , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_mul ( p , e1 , e2 ) && m_arith . is_numeral ( e2 , k ) && find_variable ( e1 , num_vars , vars , vars_ptr , k ) ) { } else if ( find_variable ( p , num_vars , vars , vars_ptr , k ) ) { } else if ( m_arith . is_numeral ( p , k ) ) { values [ 0 ] += k ; } else { TRACE ( " qe _ verbose " , tout << " non - linear ▁ " << mk_pp ( p , m ) << " \n " ; ) ; return false ; } } return true ; } } ; class bounds_proc { arith_qe_util & m_util ; ast_mark m_mark ; expr_ref_vector m_le_terms , m_ge_terms , m_lt_terms , m_gt_terms ; vector < rational > m_le_coeffs , m_ge_coeffs , m_lt_coeffs , m_gt_coeffs ; app_ref_vector m_le_atoms , m_ge_atoms , m_lt_atoms , m_gt_atoms ; expr_ref_vector m_div_terms ; vector < rational > m_div_coeffs , m_div_divisors ; app_ref_vector m_div_atoms ; app_ref m_div_z ; expr_ref_vector m_nested_div_terms ; vector < rational > m_nested_div_coeffs , m_nested_div_divisors ; app_ref_vector m_nested_div_atoms ; app_ref_vector m_nested_div_z ; rational m_d ; public : bounds_proc ( arith_qe_util & u ) : m_util ( u ) , m_le_terms ( u . get_manager ( ) ) , m_ge_terms ( u . get_manager ( ) ) , m_lt_terms ( u . get_manager ( ) ) , m_gt_terms ( u . get_manager ( ) ) , m_le_atoms ( u . get_manager ( ) ) , m_ge_atoms ( u . get_manager ( ) ) , m_lt_atoms ( u . get_manager ( ) ) , m_gt_atoms ( u . get_manager ( ) ) , m_div_terms ( u . get_manager ( ) ) , m_div_atoms ( u . get_manager ( ) ) , m_div_z ( u . get_manager ( ) ) , m_nested_div_terms ( u . get_manager ( ) ) , m_nested_div_atoms ( u . get_manager ( ) ) , m_nested_div_z ( u . get_manager ( ) ) { reset ( ) ; } bool get_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; app * x = contains_x . x ( ) ; if ( m_mark . is_marked ( a ) || get_le_bound ( contains_x , a ) || get_lt_bound ( contains_x , a ) || get_divides ( contains_x , a ) || get_nested_divs ( contains_x , a ) ) { TRACE ( " qe _ verbose " , tout << " Bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; m_mark . mark ( a , true ) ; return true ; } else { TRACE ( " qe " , tout << " No ▁ bound ▁ for ▁ " << mk_pp ( x , m ) << " ▁ within ▁ " << mk_pp ( a , m ) << " \n " ; ) ; return false ; } } unsigned lt_size ( ) { return m_lt_terms . size ( ) ; } unsigned le_size ( ) { return m_le_terms . size ( ) ; } unsigned gt_size ( ) { return m_gt_terms . size ( ) ; } unsigned ge_size ( ) { return m_ge_terms . size ( ) ; } unsigned t_size ( bool is_l ) { return is_l ? lt_size ( ) : gt_size ( ) ; } unsigned e_size ( bool is_l ) { return is_l ? le_size ( ) : ge_size ( ) ; } unsigned size ( bool is_strict , bool is_l ) { return is_strict ? t_size ( is_l ) : e_size ( is_l ) ; } expr * const * lt ( ) { return m_lt_terms . c_ptr ( ) ; } expr * const * le ( ) { return m_le_terms . c_ptr ( ) ; } expr * const * gt ( ) { return m_gt_terms . c_ptr ( ) ; } expr * const * ge ( ) { return m_ge_terms . c_ptr ( ) ; } expr * const * t ( bool is_l ) { return is_l ? lt ( ) : gt ( ) ; } expr * const * e ( bool is_l ) { return is_l ? le ( ) : ge ( ) ; } expr * const * exprs ( bool is_strict , bool is_l ) { return is_strict ? t ( is_l ) : e ( is_l ) ; } rational const * lt_coeffs ( ) { return m_lt_coeffs . c_ptr ( ) ; } rational const * le_coeffs ( ) { return m_le_coeffs . c_ptr ( ) ; } rational const * gt_coeffs ( ) { return m_gt_coeffs . c_ptr ( ) ; } rational const * ge_coeffs ( ) { return m_ge_coeffs . c_ptr ( ) ; } rational const * t_coeffs ( bool is_l ) { return is_l ? lt_coeffs ( ) : gt_coeffs ( ) ; } rational const * e_coeffs ( bool is_l ) { return is_l ? le_coeffs ( ) : ge_coeffs ( ) ; } rational const * coeffs ( bool is_strict , bool is_l ) { return is_strict ? t_coeffs ( is_l ) : e_coeffs ( is_l ) ; } app * const * lt_atoms ( ) { return m_lt_atoms . c_ptr ( ) ; } app * const * le_atoms ( ) { return m_le_atoms . c_ptr ( ) ; } app * const * gt_atoms ( ) { return m_gt_atoms . c_ptr ( ) ; } app * const * ge_atoms ( ) { return m_ge_atoms . c_ptr ( ) ; } app * const * t_atoms ( bool is_l ) { return is_l ? lt_atoms ( ) : gt_atoms ( ) ; } app * const * e_atoms ( bool is_l ) { return is_l ? le_atoms ( ) : ge_atoms ( ) ; } app * const * atoms ( bool is_strict , bool is_l ) { return is_strict ? t_atoms ( is_l ) : e_atoms ( is_l ) ; } unsigned div_size ( ) const { return m_div_terms . size ( ) ; } app * const * div_atoms ( ) { return m_div_atoms . c_ptr ( ) ; } rational const * div_coeffs ( ) { return m_div_coeffs . c_ptr ( ) ; } expr * const * div_terms ( ) { return m_div_terms . c_ptr ( ) ; } rational const * divisors ( ) { return m_div_divisors . c_ptr ( ) ; } bool div_z ( rational & d , app_ref & z_bv , app_ref & z ) { if ( m_div_z . get ( ) ) { z = m_div_z ; z_bv = to_app ( z -> get_arg ( 0 ) ) ; d = m_d ; return true ; } if ( m_div_terms . empty ( ) && m_nested_div_terms . empty ( ) ) { return false ; } m_d = rational ( 1 ) ; for ( unsigned i = 0 ; i < m_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_div_divisors [ i ] , m_d ) ; } for ( unsigned i = 0 ; i < m_nested_div_divisors . size ( ) ; ++ i ) { m_d = lcm ( m_nested_div_divisors [ i ] , m_d ) ; } if ( abs ( m_d ) . is_one ( ) ) { return false ; } m_util . mk_bounded_var ( m_d , z_bv , m_div_z ) ; z = m_div_z ; d = m_d ; return true ; } unsigned nested_div_size ( ) const { return m_nested_div_terms . size ( ) ; } app * nested_div_atom ( unsigned idx ) { return m_nested_div_atoms [ idx ] . get ( ) ; } rational const & nested_div_coeff ( unsigned idx ) { return m_nested_div_coeffs [ idx ] ; } expr * nested_div_term ( unsigned idx ) { return m_nested_div_terms [ idx ] . get ( ) ; } rational const & nested_divisor ( unsigned idx ) { return m_nested_div_divisors [ idx ] ; } app * nested_div_z ( unsigned idx ) { return m_nested_div_z [ idx ] . get ( ) ; } app * nested_div_z_bv ( unsigned idx ) { return to_app ( m_nested_div_z [ idx ] -> get_arg ( 0 ) ) ; } void reset ( ) { m_lt_terms . reset ( ) ; m_gt_terms . reset ( ) ; m_ge_terms . reset ( ) ; m_le_terms . reset ( ) ; m_gt_coeffs . reset ( ) ; m_lt_coeffs . reset ( ) ; m_ge_coeffs . reset ( ) ; m_le_coeffs . reset ( ) ; m_lt_atoms . reset ( ) ; m_gt_atoms . reset ( ) ; m_le_atoms . reset ( ) ; m_ge_atoms . reset ( ) ; m_div_terms . reset ( ) ; m_div_coeffs . reset ( ) ; m_div_divisors . reset ( ) ; m_div_atoms . reset ( ) ; m_div_z = 0 ; m_nested_div_terms . reset ( ) ; m_nested_div_coeffs . reset ( ) ; m_nested_div_divisors . reset ( ) ; m_nested_div_atoms . reset ( ) ; m_nested_div_z . reset ( ) ; } private : bool get_nested_divs ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; ptr_vector < expr > todo ; todo . push_back ( a ) ; rational k1 , k2 ; expr_ref rest ( m ) ; while ( ! todo . empty ( ) ) { expr * e = todo . back ( ) ; todo . pop_back ( ) ; if ( m_mark . is_marked ( e ) ) { continue ; } m_mark . mark ( e , true ) ; if ( ! contains_x ( e ) ) { continue ; } if ( contains_x . x ( ) == e ) { return false ; } if ( ! is_app ( e ) ) { return false ; } a = to_app ( e ) ; if ( m_util . m_arith . is_mod ( e ) && m_util . m_arith . is_numeral ( to_app ( e ) -> get_arg ( 1 ) , k1 ) && m_util . get_coeff ( contains_x , to_app ( e ) -> get_arg ( 0 ) , k2 , rest ) ) { app_ref z ( m ) , z_bv ( m ) ; m_util . mk_bounded_var ( k1 , z_bv , z ) ; m_nested_div_terms . push_back ( rest ) ; m_nested_div_divisors . push_back ( k1 ) ; m_nested_div_coeffs . push_back ( k2 ) ; m_nested_div_atoms . push_back ( a ) ; m_nested_div_z . push_back ( z ) ; continue ; } unsigned num_args = a -> get_num_args ( ) ; for ( unsigned i = 0 ; i < num_args ; ++ i ) { todo . push_back ( a -> get_arg ( i ) ) ; } } return true ; } bool get_le_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; rational k ; if ( m_util . is_le ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { if ( m_util . is_real ( contains_x . x ( ) ) ) { m_util . mk_div ( rest , abs ( k ) , rest ) ; k = k . is_pos ( ) ? rational :: one ( ) : rational :: minus_one ( ) ; } if ( k . is_neg ( ) ) { m_le_terms . push_back ( rest ) ; m_le_coeffs . push_back ( k ) ; m_le_atoms . push_back ( a ) ; } else { m_ge_terms . push_back ( rest ) ; m_ge_coeffs . push_back ( k ) ; m_ge_atoms . push_back ( a ) ; } return true ; } return false ; } bool get_lt_bound ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) , na ( m ) ; rational k ; if ( m_util . is_lt ( a , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else if ( m_util . is_neg ( a , na ) && is_app ( na ) && m_util . is_ge ( to_app ( na ) , p ) && m_util . get_coeff ( contains_x , p , k , rest ) ) { } else { return false ; } SASSERT ( m_util . is_real ( contains_x . x ( ) ) ) ; m_util . mk_div ( rest , abs ( k ) , rest ) ; if ( k . is_neg ( ) ) { m_lt_terms . push_back ( rest ) ; m_lt_coeffs . push_back ( rational :: minus_one ( ) ) ; m_lt_atoms . push_back ( a ) ; } else { m_gt_terms . push_back ( rest ) ; m_gt_coeffs . push_back ( rational :: one ( ) ) ; m_gt_atoms . push_back ( a ) ; } return true ; } bool get_divides ( contains_app & contains_x , app * a ) { ast_manager & m = m_util . get_manager ( ) ; expr_ref p ( m ) , rest ( m ) ; app_ref a2 ( m ) ; numeral k , k2 ; if ( m_util . is_divides ( a , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a ) ; return true ; } if ( m_util . is_not_divides ( a , a2 , k , p ) && m_util . get_coeff ( contains_x , p , k2 , rest ) ) { m_div_terms . push_back ( rest ) ; m_div_divisors . push_back ( k ) ; m_div_coeffs . push_back ( k2 ) ; m_div_atoms . push_back ( a2 ) ; return true ; } return false ; } public : void display ( std :: ostream & out ) { ast_manager & m = m_util . get_manager ( ) ; for ( unsigned i = 0 ; i < lt_size ( ) ; ++ i ) { out << mk_pp ( lt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < le_size ( ) ; ++ i ) { out << mk_pp ( le ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < gt_size ( ) ; ++ i ) { out << mk_pp ( gt ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } for ( unsigned i = 0 ; i < ge_size ( ) ; ++ i ) { out << mk_pp ( ge ( ) [ i ] , m ) << " ▁ < ▁ 0 \n " ; } } } ; class x_subst { arith_qe_util & m_super ; expr_ref m_t ; rational m_coeff ; public : x_subst ( arith_qe_util & s ) : m_super ( s ) , m_t ( s . get_manager ( ) ) , m_coeff ( rational :: one ( ) ) { } void set_term ( expr * t ) { m_t = t ; } void set_coeff ( rational const & k ) { m_coeff = k ; } expr * get_term ( ) const { return m_t ; } rational get_coeff ( ) const { return m_coeff ; } expr_ref mk_term ( rational const & c , expr * t ) { ast_manager & m = m_super . get_manager ( ) ; if ( m_t . get ( ) ) { return expr_ref ( m_super . mk_add ( m_super . mk_mul ( c , m_t ) , t ) , m ) ; } else { return expr_ref ( t , m ) ; } } rational mk_coeff ( rational const & k ) { return k * m_coeff ; } } ; struct branch_formula { expr * m_fml ; app * m_var ; unsigned m_branch ; expr * m_result ; rational m_coeff ; expr * m_term ; branch_formula ( ) : m_fml ( 0 ) , m_var ( 0 ) , m_branch ( 0 ) , m_result ( 0 ) , m_term ( 0 ) { } branch_formula ( expr * fml , app * var , unsigned b , expr * r , rational coeff , expr * term ) : m_fml ( fml ) , m_var ( var ) , m_branch ( b ) , m_result ( r ) , m_coeff ( coeff ) , m_term ( term ) { } unsigned mk_hash ( ) const { return mk_mix ( m_fml ? m_fml -> hash ( ) : 0 , m_var ? m_var -> hash ( ) : 0 , m_branch ) ; } bool mk_eq ( branch_formula const & other ) const { return m_fml == other . m_fml && m_var == other . m_var && m_branch == other . m_branch ; } struct hash { typedef branch_formula data ; unsigned operator ( ) ( data const & d ) const { return d . mk_hash ( ) ; } } ; struct eq { typedef branch_formula data ; bool operator ( ) ( data const & x , data const & y ) const { return x . mk_eq ( y ) ; } } ; } ; class arith_plugin : public qe_solver_plugin { typedef obj_pair_map < app , expr , bounds_proc * > bounds_cache ; typedef obj_pair_map < expr , expr , expr * > resolve_cache ; typedef hashtable < branch_formula , branch_formula :: hash , branch_formula :: eq > subst_cache ; arith_qe_util m_util ; expr_ref_vector m_trail ; bounds_cache m_bounds_cache ; subst_cache m_subst ; public : arith_plugin ( i_solver_context & ctx , ast_manager & m , smt_params & p ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_util ( m , p , ctx ) , m_trail ( m ) { } ~ arith_plugin ( ) { bounds_cache :: iterator it = m_bounds_cache . begin ( ) , end = m_bounds_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } } virtual void assign ( contains_app & contains_x , expr * fml , rational const & vl ) { SASSERT ( vl . is_unsigned ( ) ) ; app * x = contains_x . x ( ) ; unsigned v = vl . get_unsigned ( ) ; expr_ref result ( fml , m ) ; unsigned t_size , e_size ; x_subst x_t ( m_util ) ; if ( get_cache ( x , fml , v , result ) ) { return ; } bounds_proc & bounds = get_bounds ( x , fml ) ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; assign_nested_divs ( contains_x , bounds , result ) ; assign_divs ( contains_x , bounds , x_t , result ) ; if ( v == 0 ) { mk_non_bounds ( bounds , true , is_lower , result ) ; mk_non_bounds ( bounds , false , is_lower , result ) ; mk_non_resolve ( bounds , true , is_lower , result ) ; mk_non_resolve ( bounds , false , is_lower , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( x , m ) << " ▁ inf@@ inite ▁ case \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; return ; } unsigned index = v - 1 ; bool is_strict = e_size <= index ; bool is_eq = false ; SASSERT ( index < t_size + e_size ) ; if ( is_strict ) { index -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; is_eq = ( 0 == ( index & 0x1 ) ) ; index /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || index < e_size ) ; SASSERT ( ! is_strict || index < t_size ) ; SASSERT ( index < bounds . size ( is_strict , is_lower ) ) ; expr_ref t ( bounds . exprs ( is_strict , is_lower ) [ index ] , m ) ; rational a = bounds . coeffs ( is_strict , is_lower ) [ index ] ; mk_bounds ( bounds , x , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_bounds ( bounds , x , false , is_eq , is_strict , is_lower , index , a , t , result ) ; t = x_t . mk_term ( a , t ) ; a = x_t . mk_coeff ( a ) ; mk_resolve ( bounds , x , x_t , true , is_eq , is_strict , is_lower , index , a , t , result ) ; mk_resolve ( bounds , x , x_t , false , is_eq , is_strict , is_lower , index , a , t , result ) ; m_util . simplify ( result ) ; add_cache ( x , fml , v , result , x_t . get_coeff ( ) , x_t . get_term ( ) ) ; TRACE ( " qe " , { tout << vl << " ▁ " << mk_pp ( bounds . atoms ( is_strict , is_lower ) [ index ] , m ) << " \n " ; tout << mk_pp ( fml , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; } ) ; } virtual bool get_num_branches ( contains_app & contains_x , expr * fml , rational & nb ) { app * x = contains_x . x ( ) ; if ( ! update_bounds ( contains_x , fml ) ) { return false ; } bounds_proc & bounds = get_bounds ( x , fml ) ; unsigned t_size , e_size ; get_bound_sizes ( bounds , x , t_size , e_size ) ; nb = rational ( t_size + e_size + 1 ) ; return true ; } virtual void subst ( contains_app & contains_x , rational const & vl , expr_ref & fml , expr_ref * def ) { SASSERT ( vl . is_unsigned ( ) ) ; if ( def ) { get_def ( contains_x , vl . get_unsigned ( ) , fml , * def ) ; } VERIFY ( get_cache ( contains_x . x ( ) , fml , vl . get_unsigned ( ) , fml ) ) ; TRACE ( " qe " , tout << mk_pp ( contains_x . x ( ) , m ) << " ▁ " << vl << " \n " << mk_pp ( fml , m ) << " \n " ; ) ; } virtual bool project ( contains_app & x , model_ref & model , expr_ref & fml ) { if ( ! update_bounds ( x , fml ) ) { TRACE ( " qe " , tout << mk_pp ( x . x ( ) , m ) << " ▁ failed ▁ to ▁ update ▁ bounds \n " ; ) ; return false ; } if ( m_util . m_arith . is_real ( x . x ( ) ) ) { return project_real ( x , model , fml ) ; } else { return project_int ( x , model , fml ) ; } } virtual unsigned get_weight ( contains_app & contains_x , expr * fml ) { return 2 ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return m_util . solve ( conjs , fml ) ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return m_util . mk_atom ( e , p , result ) ; } virtual bool is_uninterpreted ( app * f ) { switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MOD : if ( m_util . m_arith . is_numeral ( f -> get_arg ( 1 ) ) ) { return false ; } return true ; case OP_MUL : { arith_util & a = m_util . m_arith ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } } private : expr_ref mk_idiv ( expr * e , numeral k ) { SASSERT ( ! k . is_zero ( ) ) ; arith_util & a = m_util . m_arith ; if ( k . is_one ( ) ) { return expr_ref ( e , m ) ; } if ( k . is_minus_one ( ) ) { return expr_ref ( a . mk_uminus ( e ) , m ) ; } SASSERT ( a . is_int ( e ) ) ; return expr_ref ( a . mk_idiv ( e , a . mk_numeral ( k , true ) ) , m ) ; } void get_def ( contains_app & contains_x , unsigned v , expr * fml , expr_ref & def ) { app * x = contains_x . x ( ) ; x_subst x_t ( m_util ) ; bounds_proc & bounds = get_bounds ( x , fml ) ; branch_formula bf ; VERIFY ( m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) ; x_t . set_term ( bf . m_term ) ; x_t . set_coeff ( bf . m_coeff ) ; CTRACE ( " qe " , x_t . get_term ( ) , tout << x_t . get_coeff ( ) << " ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; unsigned t_size , e_size , sz ; bool is_lower = get_bound_sizes ( bounds , x , t_size , e_size ) ; bool is_strict ; if ( v == 0 ) { is_strict = false ; sz = bounds . size ( is_strict , ! is_lower ) ; expr_ref_vector terms ( m ) ; if ( sz == 0 ) { terms . push_back ( m_util . mk_zero ( x ) ) ; } for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational a = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; term = m_util . mk_add ( term , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } TRACE ( " qe " , tout << a << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( term , m ) << " ▁ < = ▁ 0 \n " ; ) ; SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower == a . is_pos ( ) ) ; term = m_util . mk_uminus ( term ) ; term = mk_idiv ( term , a ) ; terms . push_back ( term ) ; TRACE ( " qe " , tout << " a : ▁ " << a << " ▁ term : ▁ " << mk_pp ( term , m ) << " \n " ; ) ; } is_strict = true ; sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { expr_ref term ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; SASSERT ( abs ( bounds . coeffs ( is_strict , ! is_lower ) [ i ] ) . is_one ( ) ) ; if ( is_lower ) { term = m_util . mk_uminus ( m_util . mk_add ( term , m_util . mk_one ( x ) ) ) ; } else { term = m_util . mk_add ( term , m_util . mk_one ( x ) ) ; } terms . push_back ( term ) ; } if ( is_lower ) { def = m_util . mk_min ( terms . size ( ) , terms . c_ptr ( ) ) ; } else { def = m_util . mk_max ( terms . size ( ) , terms . c_ptr ( ) ) ; } if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } m_util . simplify ( def ) ; return ; } -- v ; is_strict = e_size <= v ; SASSERT ( v < t_size + e_size ) ; if ( is_strict ) { v -= e_size ; TRACE ( " qe _ verbose " , bounds . display ( tout ) ; ) ; } else if ( m_util . is_real ( x ) ) { SASSERT ( 0 == ( e_size & 0x1 ) ) ; v /= 2 ; e_size /= 2 ; } SASSERT ( is_strict || v < e_size ) ; SASSERT ( ! is_strict || v < t_size ) ; SASSERT ( v < bounds . size ( is_strict , is_lower ) ) ; def = bounds . exprs ( is_strict , is_lower ) [ v ] ; rational a = bounds . coeffs ( is_strict , is_lower ) [ v ] ; if ( x_t . get_term ( ) ) { TRACE ( " qe " , tout << x_t . get_coeff ( ) << " * ▁ " << mk_pp ( x , m ) << " ▁ + ▁ " << mk_pp ( x_t . get_term ( ) , m ) << " \n " ; ) ; SASSERT ( x_t . get_coeff ( ) . is_pos ( ) ) ; def = m_util . mk_add ( def , m_util . mk_mul ( a , x_t . get_term ( ) ) ) ; a = a * x_t . get_coeff ( ) ; } SASSERT ( a . is_int ( ) ) ; SASSERT ( is_lower != a . is_pos ( ) ) ; def = m_util . mk_uminus ( def ) ; def = mk_idiv ( def , a ) ; if ( x_t . get_term ( ) ) { def = m_util . mk_add ( m_util . mk_mul ( x_t . get_coeff ( ) , def ) , x_t . get_term ( ) ) ; } if ( is_strict ) { SASSERT ( m_util . m_arith . is_real ( x ) ) ; def = m_util . mk_sub ( def , m_util . mk_one ( x ) ) ; } m_util . simplify ( def ) ; TRACE ( " qe " , tout << " TB@@ D ▁ ( for ▁ Real ) : ▁ " << a << " ▁ " << mk_pp ( def , m ) << " \n " ; ) ; } expr_ref mk_not ( expr * e ) { expr * r ; if ( m . is_not ( e , r ) ) { return expr_ref ( r , m ) ; } return expr_ref ( m . mk_not ( e ) , m ) ; } bool project_real ( contains_app & x , model_ref & model , expr_ref & fml ) { SASSERT ( m_util . m_arith . is_real ( x . x ( ) ) ) ; model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; bool is_lower = bounds . le_size ( ) + bounds . lt_size ( ) < bounds . ge_size ( ) + bounds . gt_size ( ) ; unsigned e_size = bounds . e_size ( is_lower ) ; numeral bound1 , bound2 , vl , x_val ; unsigned idx1 , idx2 ; bool found1 = find_min_max ( is_lower , false , bounds , model_eval , bound1 , idx1 ) ; bool found2 = find_min_max ( is_lower , true , bounds , model_eval , bound2 , idx2 ) ; if ( ! found1 && ! found2 ) { vl = numeral ( 0 ) ; } else if ( found2 && ( ! found1 || bound2 <= bound1 ) ) { vl = numeral ( 1 + 2 * e_size + idx2 ) ; } else if ( found1 && ( ! found2 || bound1 < bound2 ) ) { expr_ref val_x ( m ) ; model_eval ( x . x ( ) , val_x ) ; VERIFY ( m_util . m_arith . is_numeral ( val_x , x_val ) ) ; if ( x_val == bound1 ) { vl = numeral ( 1 + 2 * idx1 ) ; } else { vl = numeral ( 1 + 2 * idx1 + 1 ) ; } } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool project_int ( contains_app & x , model_ref & model , expr_ref & fml ) { model_evaluator model_eval ( * model ) ; bounds_proc & bounds = get_bounds ( x . x ( ) , fml ) ; SASSERT ( m_util . m_arith . is_int ( x . x ( ) ) ) ; SASSERT ( bounds . lt_size ( ) == 0 && bounds . gt_size ( ) == 0 ) ; bool is_lower = bounds . le_size ( ) < bounds . ge_size ( ) ; numeral bound , vl , x_val ; unsigned idx = bounds . le_size ( ) + bounds . ge_size ( ) ; bool found = find_min_max ( is_lower , false , bounds , model_eval , bound , idx ) ; if ( found ) { SASSERT ( idx < bounds . size ( false , is_lower ) ) ; vl = numeral ( 1 + idx ) ; } else { vl = numeral ( 0 ) ; } assign ( x , fml , vl ) ; subst ( x , vl , fml , 0 ) ; TRACE ( " qe " , tout << mk_pp ( fml , m ) << " \n " ; ) ; return true ; } bool find_min_max ( bool is_lower , bool is_strict , bounds_proc & bounds , model_evaluator & eval , rational & bound , unsigned & idx ) { bool found = false ; unsigned num_bounds = bounds . size ( is_strict , is_lower ) ; rational num ; for ( unsigned i = 0 ; i < num_bounds ; ++ i ) { expr_ref vl ( m ) ; eval ( bounds . atoms ( is_strict , is_lower ) [ i ] , vl ) ; if ( ! m . is_true ( vl ) ) { continue ; } eval ( bounds . exprs ( is_strict , is_lower ) [ i ] , vl ) ; VERIFY ( m_util . m_arith . is_numeral ( vl , num ) ) ; num /= abs ( bounds . coeffs ( is_strict , is_lower ) [ i ] ) ; if ( found ) { if ( is_lower ? ( num < bound ) : ( num > bound ) ) { bound = num ; idx = i ; } } else { found = true ; idx = i ; bound = num ; } } return found ; } bool get_bound_sizes ( bounds_proc & bounds , app * x , unsigned & t_size , unsigned & e_size ) { unsigned le_size = bounds . le_size ( ) ; unsigned ge_size = bounds . ge_size ( ) ; if ( m_util . is_real ( x ) ) { le_size *= 2 ; ge_size *= 2 ; } if ( le_size + bounds . lt_size ( ) < ge_size + bounds . gt_size ( ) ) { e_size = le_size ; t_size = bounds . lt_size ( ) ; return true ; } else { e_size = ge_size ; t_size = bounds . gt_size ( ) ; return false ; } } void add_cache ( app * x , expr * fml , unsigned v , expr * result , rational coeff , expr * term ) { m_trail . push_back ( x ) ; m_trail . push_back ( fml ) ; m_trail . push_back ( result ) ; if ( term ) m_trail . push_back ( term ) ; m_subst . insert ( branch_formula ( fml , x , v , result , coeff , term ) ) ; } bool get_cache ( app * x , expr * fml , unsigned v , expr_ref & result ) { branch_formula bf ; if ( ! m_subst . find ( branch_formula ( fml , x , v , 0 , rational :: zero ( ) , 0 ) , bf ) ) { return false ; } SASSERT ( bf . m_result ) ; result = bf . m_result ; return true ; } void assign_divs ( contains_app & contains_x , bounds_proc & bounds , x_subst & x_t , expr_ref & result ) { app * x = contains_x . x ( ) ; app_ref z ( m ) , z_bv ( m ) ; rational d ; if ( ! bounds . div_z ( d , z_bv , z ) ) { return ; } m_ctx . add_var ( z_bv ) ; expr * z_lt_d = m_util . m_arith . mk_le ( z , m_util . m_arith . mk_numeral ( d - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_d ) ; SASSERT ( ! abs ( d ) . is_one ( ) ) ; rational d1 = d - rational ( 1 ) ; expr_ref tmp ( m ) ; m_util . m_arith_rewriter . mk_le ( z , m_util . m_arith . mk_numeral ( d1 , true ) , tmp ) ; m_util . m_bool_rewriter . mk_and ( result , tmp , result ) ; expr_ref t1 ( m ) , new_atom ( m ) ; t1 = m_util . mk_sub ( x , z ) ; m_util . mk_divides ( d , t1 , new_atom ) ; m_ctx . add_constraint ( false , new_atom ) ; mk_div_equivs ( bounds , z , result ) ; x_t . set_term ( z ) ; x_t . set_coeff ( d ) ; } void mk_div_equivs ( bounds_proc & bounds , expr * z , expr_ref & result ) { unsigned sz = bounds . div_size ( ) ; app * const * atoms = bounds . div_atoms ( ) ; rational const * coeffs = bounds . div_coeffs ( ) ; expr * const * terms = bounds . div_terms ( ) ; rational const * divisors = bounds . divisors ( ) ; expr_ref new_atom ( m ) , t1 ( m ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * atm = atoms [ i ] ; t1 = m_util . mk_add ( m_util . mk_mul ( coeffs [ i ] , z ) , terms [ i ] ) ; m_util . mk_divides ( divisors [ i ] , t1 , new_atom ) ; m_util . m_replace . apply_substitution ( atm , new_atom . get ( ) , result ) ; m_ctx . add_constraint ( false , mk_not ( atm ) , new_atom ) ; m_ctx . add_constraint ( false , mk_not ( new_atom ) , atm ) ; } } void assign_nested_divs ( contains_app & contains_x , bounds_proc & bounds , expr_ref & result ) { unsigned num_nested_divs = bounds . nested_div_size ( ) ; if ( num_nested_divs == 0 ) { return ; } app_ref z ( m ) , z_bv ( m ) ; rational d ; VERIFY ( bounds . div_z ( d , z_bv , z ) ) ; for ( unsigned i = 0 ; i < num_nested_divs ; ++ i ) { app * atm = bounds . nested_div_atom ( i ) ; rational const & k = bounds . nested_divisor ( i ) ; app * z1_bv = bounds . nested_div_z_bv ( i ) ; app * z1 = bounds . nested_div_z ( i ) ; m_ctx . add_var ( z1_bv ) ; expr * z_lt_k = m_util . m_arith . mk_le ( z1 , m_util . m_arith . mk_numeral ( k - rational ( 1 ) , true ) ) ; m_ctx . add_constraint ( false , z_lt_k ) ; expr * e1 = m_util . m_arith . mk_sub ( atm -> get_arg ( 0 ) , z1 ) ; expr * e2 = atm -> get_arg ( 1 ) ; expr_ref mod_term2 ( m_util . m_arith . mk_mod ( e1 , e2 ) , m ) ; m_util . simplify ( mod_term2 ) ; m_ctx . add_constraint ( false , m . mk_eq ( mod_term2 , m_util . mk_zero ( mod_term2 ) ) ) ; m_util . m_replace . apply_substitution ( atm , z1 , result ) ; expr_ref mod_eq ( m ) , tmp1 ( m ) , tmp2 ( m ) ; tmp2 = m_util . mk_numeral ( bounds . nested_div_coeff ( i ) , true ) ; tmp1 = m_util . m_arith . mk_mul ( tmp2 , z1 ) ; tmp2 = m_util . m_arith . mk_sub ( bounds . nested_div_term ( i ) , z ) ; tmp2 = m_util . m_arith . mk_add ( tmp1 , tmp2 ) ; tmp1 = m_util . m_arith . mk_mod ( tmp2 , bounds . nested_div_atom ( i ) -> get_arg ( 1 ) ) ; mod_eq = m . mk_eq ( tmp1 , m_util . mk_zero ( z ) ) ; m_util . simplify ( mod_eq ) ; result = m . mk_and ( result , mod_eq ) ; TRACE ( " qe " , tout << mk_pp ( mod_eq , m ) << " \n " ; ) ; } } bounds_proc & get_bounds ( app * x , expr * fml ) { bounds_proc * result = 0 ; VERIFY ( m_bounds_cache . find ( x , fml , result ) ) ; return * result ; } void mk_non_bounds ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; m_ctx . add_constraint ( true , mk_not ( e ) ) ; m_util . m_replace . apply_substitution ( e , m . mk_false ( ) , result ) ; } } void mk_non_resolve ( bounds_proc & bounds , bool is_strict , bool is_lower , expr_ref & result ) { unsigned sz = bounds . size ( is_strict , ! is_lower ) ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; m_ctx . add_constraint ( true , e ) ; m_util . m_replace . apply_substitution ( e , m . mk_true ( ) , result ) ; } } void mk_bound ( bool is_strict , bool is_lower , rational const & a , expr * t , rational const & b , expr * s , expr_ref & result ) { if ( is_strict ) { if ( is_lower ) { m_util . mk_strict_bound ( b , s , a , t , result ) ; } else { m_util . mk_strict_bound ( a , t , b , s , result ) ; } } else { if ( is_lower ) { m_util . mk_bound ( b , s , a , t , result ) ; } else { m_util . mk_bound ( a , t , b , s , result ) ; } } m_util . simplify ( result ) ; TRACE ( " qe " , tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << ( is_lower ? " is - lower " : " is - upper " ) << " \n " ; tout << " a : ▁ " << a << " ▁ " << mk_pp ( t , m ) << " \n " ; tout << " b : ▁ " << b << " ▁ " << mk_pp ( s , m ) << " \n " ; tout << mk_pp ( result , m ) << " \n " ; ) ; } void mk_bounds ( bounds_proc & bounds , app * x , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { TRACE ( " qe " , tout << mk_pp ( t , m ) << " \n " ; ) ; SASSERT ( ! is_eq_ctx || ! is_strict_ctx ) ; unsigned sz = bounds . size ( is_strict , is_lower ) ; expr_ref tmp ( m ) , eq ( m ) ; bool same_strict = ( is_strict == is_strict_ctx ) ; bool non_strict_real = m_util . is_real ( x ) && ! is_strict_ctx ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , is_lower ) [ i ] ; if ( same_strict && i == index ) { if ( non_strict_real ) { m_util . mk_eq ( a , x , t , eq ) ; TRACE ( " qe " , tout << " a : " << a << " ▁ x : ▁ " << mk_pp ( x , m ) << " t : ▁ " << mk_pp ( t , m ) << " ▁ eq : ▁ " << mk_pp ( eq , m ) << " \n " ; ) ; if ( is_eq_ctx ) { m_ctx . add_constraint ( true , eq ) ; } else { m_ctx . add_constraint ( true , mk_not ( eq ) ) ; m_ctx . add_constraint ( true , e ) ; } } else { m_ctx . add_constraint ( true , e ) ; } m_util . m_replace . apply_substitution ( atm , m . mk_true ( ) , result ) ; continue ; } bool result_is_strict = ( non_strict_real && is_eq_ctx && is_strict ) || ( same_strict && i < index ) ; mk_bound ( result_is_strict , is_lower , a , t , b , s , tmp ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; TRACE ( " qe " , tout << ( result_is_strict ? " strict ▁ result " : " non - strict ▁ result " ) << " \n " ; tout << ( is_strict ? " strict " : " non - strict " ) << " \n " ; tout << mk_pp ( atm , m ) << " ▁ & ▁ " ; tout << mk_pp ( e , m ) << " ▁ - - > ▁ " ; tout << mk_pp ( tmp . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; } } void mk_resolve ( bounds_proc & bounds , app * x , x_subst & x_t , bool is_strict , bool is_eq_ctx , bool is_strict_ctx , bool is_lower , unsigned index , rational const & a , expr * t , expr_ref & result ) { expr_ref tmp ( m ) ; unsigned sz = bounds . size ( is_strict , ! is_lower ) ; bool is_strict_real = ! is_eq_ctx && m_util . is_real ( x ) && ! is_strict_ctx ; bool strict_resolve = is_strict || is_strict_ctx || is_strict_real ; app * atm = bounds . atoms ( is_strict_ctx , is_lower ) [ index ] ; for ( unsigned i = 0 ; i < sz ; ++ i ) { app * e = bounds . atoms ( is_strict , ! is_lower ) [ i ] ; expr_ref s ( bounds . exprs ( is_strict , ! is_lower ) [ i ] , m ) ; rational b = bounds . coeffs ( is_strict , ! is_lower ) [ i ] ; SASSERT ( ! b . is_zero ( ) ) ; SASSERT ( b . is_pos ( ) != a . is_pos ( ) ) ; s = x_t . mk_term ( b , s ) ; b = x_t . mk_coeff ( b ) ; m_util . mk_resolve ( x , strict_resolve , a , t , b , s , tmp ) ; expr_ref save_result ( result ) ; m_util . m_replace . apply_substitution ( e , tmp . get ( ) , result ) ; m_ctx . add_constraint ( true , mk_not ( e ) , tmp ) ; TRACE ( " qe _ verbose " , tout << mk_pp ( atm , m ) << " ▁ " ; tout << mk_pp ( e , m ) << " ▁ = = > \n " ; tout << mk_pp ( tmp , m ) << " \n " ; tout << " old ▁ fml : ▁ " << mk_pp ( save_result , m ) << " \n " ; tout << " new ▁ fml : ▁ " << mk_pp ( result , m ) << " \n " ; ) ; } } bool update_bounds ( bounds_proc & bounds , contains_app & contains_x , expr * fml , atom_set const & tbl , bool is_pos ) { app_ref tmp ( m ) ; atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; if ( ! contains_x ( e ) ) { continue ; } if ( ! is_pos ) { SASSERT ( ! m . is_not ( e ) ) ; tmp = m . mk_not ( e ) ; e = tmp ; } if ( ! bounds . get_bound ( contains_x , e ) ) { return false ; } } return true ; } bool update_bounds ( contains_app & contains_x , expr * fml ) { bounds_proc * bounds = 0 ; if ( m_bounds_cache . find ( contains_x . x ( ) , fml , bounds ) ) { return true ; } bounds = alloc ( bounds_proc , m_util ) ; if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . pos_atoms ( ) , true ) ) { dealloc ( bounds ) ; return false ; } if ( ! update_bounds ( * bounds , contains_x , fml , m_ctx . neg_atoms ( ) , false ) ) { dealloc ( bounds ) ; return false ; } m_trail . push_back ( contains_x . x ( ) ) ; m_trail . push_back ( fml ) ; m_bounds_cache . insert ( contains_x . x ( ) , fml , bounds ) ; return true ; } } ; class nlarith_plugin : public qe_solver_plugin { typedef obj_map < app , unsigned > weight_m ; typedef obj_pair_map < expr , expr , nlarith :: branch_conditions * > bcs_t ; typedef obj_map < expr , weight_m * > weights_t ; bcs_t m_cache ; weights_t m_weights ; th_rewriter m_rewriter ; nlarith :: util m_util ; expr_safe_replace m_replace ; expr_ref_vector m_trail ; factor_rewrit@@ er_star m_factor_rw ; bool m_produce_models ; public : nlarith_plugin ( i_solver_context & ctx , ast_manager & m , bool produce_models ) : qe_solver_plugin ( m , m . mk_family_id ( " arith " ) , ctx ) , m_rewriter ( m ) , m_util ( m ) , m_replace ( m ) , m_trail ( m ) , m_factor_rw ( m ) , m_produce_models ( produce_models ) { TRACE ( " qe " , tout << " produce ▁ models : ▁ " << produce_models << " \n " ; ) ; m_util . set_enable@@ _linear ( true ) ; } virtual ~ nlarith_plugin ( ) { bcs_t :: iterator it = m_cache . begin ( ) , end = m_cache . end ( ) ; for ( ; it != end ; ++ it ) { dealloc ( it -> get_value ( ) ) ; } weights_t :: iterator it2 = m_weights . begin ( ) , e2 = m_weights . end ( ) ; for ( ; it2 != e2 ; ++ it2 ) { dealloc ( it2 -> get_value ( ) ) ; } } virtual bool simplify ( expr_ref & fml ) { expr_ref tmp ( m ) , tmp2 ( m ) ; m_factor_rw ( fml , tmp ) ; m_rewriter ( tmp , tmp2 ) ; if ( fml . get ( ) != tmp2 . get ( ) ) { fml = tmp2 ; return true ; } return false ; } virtual void assign ( contains_app & x , expr * fml , rational const & vl ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; expr * branch_fml = brs -> branches ( vl . get_unsigned ( ) ) ; expr_ref result ( m ) , tmp ( m ) ; m_factor_rw ( branch_fml , tmp ) ; m_rewriter ( tmp , result ) ; TRACE ( " qe " , tout << vl << " ▁ " << mk_pp ( result . get ( ) , m ) << " \n " ; ) ; m_ctx . add_constraint ( true , result ) ; } virtual bool get_num_branches ( contains_app & x , expr * fml , rational & num_branches ) { nlarith :: branch_conditions * brs ; if ( m_cache . find ( x . x ( ) , fml , brs ) ) { num_branches = rational ( brs -> size ( ) ) ; return true ; } expr_ref_vector lits ( m ) ; update_bounds ( lits , m_ctx . pos_atoms ( ) , true ) ; update_bounds ( lits , m_ctx . neg_atoms ( ) , false ) ; brs = alloc ( nlarith :: branch_conditions , m ) ; TRACE ( " nlarith " , tout << mk_pp ( fml , m ) << " \n " ; ) ; if ( ! m_util . create_branches ( x . x ( ) , lits . size ( ) , lits . c_ptr ( ) , * brs ) ) { TRACE ( " nlarith " , tout << " no ▁ branches ▁ for ▁ " << mk_pp ( x . x ( ) , m ) << " \n " ; ) ; dealloc ( brs ) ; return false ; } num_branches = rational ( brs -> size ( ) ) ; insert_cache ( x . x ( ) , fml , brs ) ; return true ; } virtual void subst ( contains_app & x , rational const & vl , expr_ref & fml , expr_ref * def ) { nlarith :: branch_conditions * brs ; VERIFY ( m_cache . find ( x . x ( ) , fml , brs ) ) ; SASSERT ( vl . is_unsigned ( ) ) ; SASSERT ( vl . get_unsigned ( ) < brs -> size ( ) ) ; unsigned j = vl . get_unsigned ( ) ; m_replace . reset ( ) ; for ( unsigned i = 0 ; i < brs -> preds ( ) . size ( ) ; ++ i ) { m_replace . insert ( brs -> preds ( i ) , brs -> subst ( j ) [ i ] ) ; } m_replace ( fml ) ; expr_ref tmp ( m . mk_and ( brs -> constraints ( j ) , fml ) , m ) ; m_factor_rw ( tmp , fml ) ; if ( def ) { m_factor_rw ( brs -> def ( j ) , * def ) ; } } virtual unsigned get_weight ( contains_app & x , expr * fml ) { obj_map < app , unsigned > * weights = 0 ; unsigned weight = 0 ; if ( ! m_weights . find ( fml , weights ) ) { weights = alloc ( weight_m ) ; m_weights . insert ( fml , weights ) ; m_trail . push_back ( fml ) ; ptr_vector < app > nl_vars ; m_util . extract_non_linear ( to_app ( fml ) , nl_vars ) ; for ( unsigned i = 0 ; i < nl_vars . size ( ) ; ++ i ) { weights -> insert ( nl_vars [ i ] , 100 ) ; } } if ( weights -> find ( x . x ( ) , weight ) ) { return weight ; } return UINT_MAX ; } virtual bool solve ( conj_enum & conjs , expr * fml ) { return false ; } virtual bool mk_atom ( expr * e , bool p , expr_ref & result ) { return false ; } virtual bool is_uninterpreted ( app * f ) { if ( m_produce_models ) { return true ; } switch ( f -> get_decl_kind ( ) ) { case OP_NUM : case OP_LE : case OP_LT : case OP_GE : case OP_GT : case OP_ADD : case OP_SUB : case OP_UMINUS : return false ; case OP_MUL : { arith_util a ( m ) ; expr * m , * n ; if ( a . is_mul ( f , m , n ) && ( a . is_numeral ( m ) || a . is_numeral ( n ) ) ) { return false ; } return true ; } default : return true ; } return true ; } private : void insert_cache ( app * x , expr * e , nlarith :: branch_conditions * brs ) { m_trail . push_back ( x ) ; m_trail . push_back ( e ) ; m_cache . insert ( x , e , brs ) ; } void update_bounds ( expr_ref_vector & lits , atom_set const & tbl , bool is_pos ) { atom_set :: iterator it = tbl . begin ( ) , end = tbl . end ( ) ; for ( ; it != end ; ++ it ) { app * e = * it ; lits . push_back ( is_pos ? e : m . mk_not ( e ) ) ; } } } ; qe_solver_plugin * mk_arith_plugin ( i_solver_context & ctx , bool produce_models , smt_params & p ) { if ( p . m_nl@@ quant_@@ eli@@ m ) { return alloc ( nlarith_plugin , ctx , ctx . get_manager ( ) , produce_models ) ; } else { return alloc ( arith_plugin , ctx , ctx . get_manager ( ) , p ) ; } } } </DOCUMENT>
<DOCUMENT_ID="ge@@ odynamics/@@ gal@@ e/tree/master/@@ boost/libs/regex/per@@ formance@@ /time_@@ gret@@ a.cpp"> # include " regex _ compar@@ ison . hpp " # if defined ( BOOST_HAS_@@ GRE@@ TA ) # include < cassert > # include < boost / timer . hpp > # include " regexpr2 . h " namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; assert ( e . match ( text , what ) ) ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text , what ) ; } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { regex :: rpattern e ( re , ( icase ? regex :: MULTILINE | regex :: NORMALIZE | regex :: NOCASE : regex :: MULTILINE | regex :: NORMALIZE ) ) ; regex :: match_results what ; boost :: timer tim ; int iter = 1 ; int counter , repeats ; double result = 0 ; double run ; do { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } result = tim . elapsed ( ) ; iter *= 2 ; } while ( result < 0.5 ) ; iter /= 2 ; if ( result > 10 ) return result / iter ; for ( repeats = 0 ; repeats < REPEAT_COUNT ; ++ repeats ) { tim . restart ( ) ; for ( counter = 0 ; counter < iter ; ++ counter ) { e . match ( text . begin ( ) , text . end ( ) , what ) ; while ( what . backref ( 0 ) . matched ) { e . match ( what . backref ( 0 ) . end ( ) , text . end ( ) , what ) ; } } run = tim . elapsed ( ) ; result = ( std :: min ) ( run , result ) ; } return result / iter ; } } # else namespace g { double time_match ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } double time_find_all ( const std :: string & re , const std :: string & text , bool icase ) { return - 1 ; } } # endif </DOCUMENT>
<DOCUMENT_ID="dolphin@@ -emu@@ /dolphin/tree/master/Source/Core/@@ VideoCommon/@@ OnScreen@@ Display.cpp"> # include " VideoCommon / OnScreen@@ Display . h " # include < algorithm > # include < map > # include < mutex > # include < string > # include < fmt / format . h > # include < imgui . h > # include " Common / CommonTypes . h " # include " Common / Timer . h " # include " Core / ConfigManager . h " namespace OSD { constexpr float LEFT_MARGIN = 10.0f ; constexpr float TOP_MARGIN = 10.0f ; constexpr float WINDOW_PADDING = 4.0f ; struct Message { Message ( ) = default ; Message ( std :: string text_ , u32 timestamp_ , u32 color_ ) : text ( std :: move ( text_ ) ) , timestamp ( timestamp_ ) , color ( color_ ) { } std :: string text ; u32 timestamp = 0 ; u32 color = 0 ; } ; static std :: multimap < MessageType , Message > s_messages ; static std :: mutex s_messages_mutex ; static ImVec4 RGBAToImVec4 ( const u32 rgba ) { return ImVec4 ( static_cast < float > ( ( rgba >> 16 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 8 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 0 ) & 0xFF ) / 255.0f , static_cast < float > ( ( rgba >> 24 ) & 0xFF ) / 255.0f ) ; } static float DrawMessage ( int index , const Message & msg , const ImVec2 & position , int time_left ) { const std :: string window_name = fmt :: format ( " osd _ { } " , index ) ; ImGui :: SetNextWindow@@ Pos ( position ) ; ImGui :: SetNextWindow@@ Size ( ImVec2 ( 0.0f , 0.0f ) ) ; const float alpha = std :: min ( 1.0f , std :: max ( 0.0f , time_left / 1024@@ .0f ) ) ; ImGui :: PushStyleVar ( ImGuiStyleVar_Alpha , alpha ) ; float window_height = 0.0f ; if ( ImGui :: Begin ( window_name . c_str ( ) , nullptr , ImGuiWindowFlags_NoTitle@@ Bar | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNa@@ v | ImGuiWindowFlags_Always@@ AutoResize | ImGuiWindowFlags_NoFocusOnAppear@@ ing ) ) { ImGui :: TextColored ( RGBAToImVec4 ( msg . color ) , " % s " , msg . text . c_str ( ) ) ; window_height = ImGui :: GetWindowSize ( ) . y + ( WINDOW_PADDING * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ) ; } ImGui :: End ( ) ; ImGui :: PopStyleVar ( ) ; return window_height ; } void AddTyp@@ edMessage ( MessageType type , std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . erase ( type ) ; s_messages . emplace ( type , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void AddMessage ( std :: string message , u32 ms , u32 rgba ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . emplace ( MessageType :: Typeless , Message ( std :: move ( message ) , Common :: Timer :: GetTimeMs ( ) + ms , rgba ) ) ; } void DrawMessages ( ) { if ( ! SConfig :: GetInstance ( ) . bOn@@ ScreenDisplayMessages ) return ; { std :: lock_guard lock { s_messages_mutex } ; const u32 now = Common :: Timer :: GetTimeMs ( ) ; float current_x = LEFT_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . x ; float current_y = TOP_MARGIN * ImGui :: GetIO ( ) . DisplayFramebufferScale . y ; int index = 0 ; auto it = s_messages . begin ( ) ; while ( it != s_messages . end ( ) ) { const Message & msg = it -> second ; const int time_left = static_cast < int > ( msg . timestamp - now ) ; current_y += DrawMessage ( index ++ , msg , ImVec2 ( current_x , current_y ) , time_left ) ; if ( time_left <= 0 ) it = s_messages . erase ( it ) ; else ++ it ; } } } void ClearMessages ( ) { std :: lock_guard lock { s_messages_mutex } ; s_messages . clear ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="R@@ udi@@ 9719@@ /cur@@ ly-oct@@ o-@@ barn@@ acle/tree/master/Trinity@@ Core/src/@@ server/scripts/Northrend/@@ Nexus/@@ Nexus/@@ boss_ormorok@@ .cpp"> # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " nex@@ us . h " # include " SpellScript . h " enum Spells { SPELL_SPELL_REFLECTION = 479@@ 81 , SPELL_TRAMPLE = 48016 , SPELL_FRENZY = 48017 , SPELL_SUMMON_CRYSTALLINE_TANGLER = 61564 , SPELL_CRYSTAL_SPIKES = 479@@ 58 , } ; enum Yell@@ s { SAY_AGGRO = 1 , SAY_DEATH = 2 , SAY_REFLECT = 3 , SAY_CRYSTAL_SPIKES = 4 , SAY_KILL = 5 , SAY_FRENZY = 6 } ; enum Events { EVENT_CRYSTAL_SPIKES = 1 , EVENT_TRAMPLE = 2 , EVENT_SPELL_REFLECTION = 3 , EVENT_CRYSTALLINE_TANGLER = 4 , } ; class OrmorokTanglerPredicate { public : OrmorokTanglerPredicate ( Unit * unit ) : me ( unit ) { } bool operator ( ) ( WorldObject * object ) const { return object -> GetDistance@@ 2d ( me ) >= 5.0f ; } private : Unit * me ; } ; class boss_ormorok : public CreatureScript { public : boss_ormorok ( ) : CreatureScript ( " boss _ ormorok " ) { } struct boss_ormorokAI : public BossAI { boss_ormorokAI ( Creature * creature ) : BossAI ( creature , DATA_ORMO@@ ROK ) { Initialize ( ) ; } void Initialize ( ) { frenzy = false ; } void Reset ( ) override { BossAI :: Reset ( ) ; Initialize ( ) ; } void EnterCombat ( Unit * ) override { _EnterCombat ( ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; if ( IsHero@@ ic ( ) ) events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; Talk ( SAY_AGGRO ) ; } void DamageTaken ( Unit * , uint32 & ) override { if ( ! frenzy && HealthBe@@ lowPct ( 25 ) ) { Talk ( SAY_FRENZY ) ; DoCast ( me , SPELL_FRENZY ) ; frenzy = true ; } } void JustDied ( Unit * ) override { _JustDied ( ) ; Talk ( SAY_DEATH ) ; } void KilledUnit ( Unit * who ) override { if ( who -> GetTypeId ( ) == TYPEID_PLAYER ) Talk ( SAY_KILL ) ; } void UpdateAI ( uint32 diff ) override { if ( ! UpdateVictim ( ) ) return ; events . Update ( diff ) ; if ( me -> HasUnitState ( UNIT_STATE_CASTING ) ) return ; while ( uint32 eventId = events . ExecuteEvent ( ) ) { switch ( eventId ) { case EVENT_TRAMPLE : DoCast ( me , SPELL_TRAMPLE ) ; events . ScheduleEvent ( EVENT_TRAMPLE , 10000 ) ; break ; case EVENT_SPELL_REFLECTION : Talk ( SAY_REFLECT ) ; DoCast ( me , SPELL_SPELL_REFLECTION ) ; events . ScheduleEvent ( EVENT_SPELL_REFLECTION , 30000 ) ; break ; case EVENT_CRYSTAL_SPIKES : Talk ( SAY_CRYSTAL_SPIKES ) ; DoCast ( SPELL_CRYSTAL_SPIKES ) ; events . ScheduleEvent ( EVENT_CRYSTAL_SPIKES , 12000 ) ; break ; case EVENT_CRYSTALLINE_TANGLER : if ( Unit * target = SelectTarget ( SELECT_TARGET_RANDOM , 0 , OrmorokTanglerPredicate ( me ) ) ) DoCast ( target , SPELL_SUMMON_CRYSTALLINE_TANGLER ) ; events . ScheduleEvent ( EVENT_CRYSTALLINE_TANGLER , 17000 ) ; break ; default : break ; } } DoMeleeAttackIfReady ( ) ; } private : bool frenzy ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return GetInstance@@ AI < boss_ormorokAI > ( creature ) ; } } ; enum Crystal@@ Spikes { NPC_CRYSTAL_SPIKE_INITIAL = 27101 , NPC_CRYSTAL_SPIKE_TRIGGER = 270@@ 79 , DATA_COUNT = 1 , MAX_COUNT = 5 , SPELL_CRYSTAL_SPIKE_@@ DAMAGE = 47944 , GO_CRYSTAL_SPIKE_TRAP = 1885@@ 37 , } ; uint32 const crystalSpikeSummon [ 3 ] = { 479@@ 36 , 479@@ 42 , 479@@ 43 } ; class npc_crystal_spike_trigger : public CreatureScript { public : npc_crystal_spike_trigger ( ) : CreatureScript ( " npc _ crystal _ spike _ trigger " ) { } struct npc_crystal_spike_triggerAI : public ScriptedAI { npc_crystal_spike_triggerAI ( Creature * creature ) : ScriptedAI ( creature ) { _count = 0 ; _despawntimer = 0 ; } void IsSummonedBy ( Unit * owner ) override { switch ( me -> GetEntry ( ) ) { case NPC_CRYSTAL_SPIKE_INITIAL : _count = 0 ; me -> SetFacingToObject ( owner ) ; break ; case NPC_CRYSTAL_SPIKE_TRIGGER : if ( Creature * trigger = owner -> ToCreature ( ) ) _count = trigger -> AI ( ) -> GetData ( DATA_COUNT ) + 1 ; break ; default : _count = MAX_COUNT ; break ; } if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Use ( me ) ; _despawntimer = 2000 ; } uint32 GetData ( uint32 type ) const override { return type == DATA_COUNT ? _count : 0 ; } void UpdateAI ( uint32 diff ) override { if ( _despawntimer <= diff ) { if ( me -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( GameObject * trap = me -> FindNearestGameObject ( GO_CRYSTAL_SPIKE_TRAP , 1.0f ) ) trap -> Delete ( ) ; me -> DespawnOrUnsummon ( ) ; } else _despawntimer -= diff ; } private : uint32 _count ; uint32 _despawntimer ; } ; CreatureAI * GetAI ( Creature * creature ) const override { return new npc_crystal_spike_triggerAI ( creature ) ; } } ; class spell_crystal_spike : public SpellScriptLoader { public : spell_crystal_spike ( ) : SpellScriptLoader ( " spell _ crystal _ spike " ) { } class spell_crystal_spike_AuraScript : public AuraScript { PrepareAuraScript ( spell_crystal_spike_AuraScript ) ; void HandlePeriodic ( AuraEffect const * ) { Unit * target = GetTarget ( ) ; if ( target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL || target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_TRIGGER ) if ( Creature * trigger = target -> ToCreature ( ) ) { uint32 spell = target -> GetEntry ( ) == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon [ 0 ] : crystalSpikeSummon [ urand ( 0 , 2 ) ] ; if ( trigger -> AI ( ) -> GetData ( DATA_COUNT ) < MAX_COUNT ) trigger -> CastSpell ( trigger , spell , true ) ; } } void Register ( ) override { OnEffectPeriodic += AuraEffectPeriodicFn ( spell_crystal_spike_AuraScript :: HandlePeriodic , EFFECT_0 , SPELL_AURA_PERIODIC_@@ DUMMY ) ; } } ; AuraScript * GetAuraScript ( ) const override { return new spell_crystal_spike_AuraScript ( ) ; } } ; void AddSC_@@ boss_ormorok ( ) { new boss_ormorok ( ) ; new npc_crystal_spike_trigger ( ) ; new spell_crystal_spike ( ) ; } </DOCUMENT>
<DOCUMENT_ID="tj@@ affri/ms@@ iot-samples/tree/master/@@ AllJoyn/Samples/@@ ZWave@@ Adapter@@ /open@@ -zwave@@ /cpp/src/@@ command_@@ classes/@@ UserCode.cpp"> # include " tinyxml . h " # include " command _ classes / CommandClasses . h " # include " command _ classes / UserCode . h " # include " Node . h " # include " Options . h " # include " platform / Log . h " # include " value _ classes / ValueByte . h " # include " value _ classes / ValueRaw . h " using namespace OpenZWave ; enum UserCodeCmd { UserCodeCmd_Set = 0x01 , UserCodeCmd_Get = 0x02 , UserCodeCmd_Report = 0x03 , UserNumberCmd_Get = 0x04 , UserNumberCmd_Report = 0x05 } ; enum { UserCodeIndex_Refresh = 254 , UserCodeIndex_Count = 255 } ; const uint8 UserCodeLength = 10 ; UserCode :: UserCode ( uint32 const _homeId , uint8 const _nodeId ) : CommandClass ( _homeId , _nodeId ) , m_queryAll ( false ) , m_currentCode ( 0 ) , m_userCodeCount ( 0 ) , m_refreshUserCodes ( false ) { SetStaticRequest ( StaticRequest_Values ) ; memset ( m_userCodesStatus , 0xff , sizeof ( m_userCodesStatus ) ) ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } void UserCode :: ReadXML ( TiXmlElement const * _ccElement ) { int32 intVal ; CommandClass :: ReadXML ( _ccElement ) ; if ( TIXML_SUCCESS == _ccElement -> QueryIntAttribute ( " codes " , & intVal ) ) { m_userCodeCount = intVal ; } } void UserCode :: WriteXML ( TiXmlElement * _ccElement ) { char str [ 32 ] ; CommandClass :: WriteXML ( _ccElement ) ; snprintf ( str , sizeof ( str ) , " % d " , m_userCodeCount ) ; _ccElement -> SetAttribute ( " codes " , str ) ; } bool UserCode :: RequestState ( uint32 const _requestFlags , uint8 const _instance , Driver :: MsgQueue const _queue ) { bool requests = false ; if ( ( _requestFlags & RequestFlag_@@ Static ) && HasStaticRequest ( StaticRequest_Values ) ) { requests |= RequestValue ( _requestFlags , UserCodeIndex_Count , _instance , _queue ) ; } if ( _requestFlags & RequestFlag_@@ Session ) { if ( m_userCodeCount > 0 ) { m_queryAll = true ; m_currentCode = 1 ; requests |= RequestValue ( _requestFlags , m_currentCode , _instance , _queue ) ; } } return requests ; } bool UserCode :: RequestValue ( uint32 const _requestFlags , uint8 const _userCodeIdx , uint8 const _instance , Driver :: MsgQueue const _queue ) { if ( _instance != 1 ) { return false ; } if ( ! IsGetSupported ( ) ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " UserNumberCmd _ Get ▁ Not ▁ Supported ▁ on ▁ this ▁ node " ) ; return false ; } if ( _userCodeIdx == UserCodeIndex_Count ) { Msg * msg = new Msg ( " UserNumberCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 2 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserNumberCmd_Get ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } if ( _userCodeIdx == 0 ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " UserCodeCmd _ Get ▁ with ▁ Index ▁ 0 ▁ not ▁ Supported " ) ; return false ; } Msg * msg = new Msg ( " UserCodeCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 3 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Get ) ; msg -> Append ( _userCodeIdx ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } bool UserCode :: HandleMsg ( uint8 const * _data , uint32 const _length , uint32 const _instance ) { if ( UserNumberCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { m_userCodeCount = _data [ 1 ] ; if ( m_userCodeCount > 254 ) { m_userCodeCount = 254 ; } ClearStaticRequest ( StaticRequest_Values ) ; if ( m_userCodeCount == 0 ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Not ▁ supported " , GetNodeId ( ) ) ; } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Supported ▁ Codes ▁ % d ▁ ( % d ) " , GetNodeId ( ) , m_userCodeCount , _data [ 1 ] ) ; } if ( ValueByte * value = static_cast < ValueByte * > ( GetValue ( _instance , UserCodeIndex_Count ) ) ) { value -> OnValueRefreshed ( m_userCodeCount ) ; value -> Release ( ) ; } if ( Node * node = GetNodeUnsafe ( ) ) { uint8 data [ UserCodeLength ] ; memset ( data , 0 , UserCodeLength ) ; for ( uint8 i = 0 ; i <= m_userCodeCount ; i ++ ) { char str [ 16 ] ; if ( i == 0 ) { snprintf ( str , sizeof ( str ) , " Enroll@@ ment ▁ Code " ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , true , false , data , UserCodeLength , 0 ) ; } else { snprintf ( str , sizeof ( str ) , " Code ▁ % d : " , i ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , false , false , data , UserCodeLength , 0 ) ; } } } return true ; } else if ( UserCodeCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { int i = _data [ 1 ] ; if ( ValueRaw * value = static_cast < ValueRaw * > ( GetValue ( _instance , i ) ) ) { uint8 data [ UserCodeLength ] ; uint8 size = _length - 4 ; if ( size > UserCodeLength ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " User ▁ Code ▁ length ▁ % d ▁ is ▁ larger ▁ then ▁ maximum ▁ % d " , size , UserCodeLength ) ; size = UserCodeLength ; } m_userCodesStatus [ i ] = _data [ 2 ] ; memcpy ( data , & _data [ 3 ] , size ) ; value -> OnValueRefreshed ( data , size ) ; value -> Release ( ) ; } Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Code ▁ Report ▁ from ▁ node ▁ % d ▁ for ▁ User ▁ Code ▁ % d ▁ ( % s ) " , GetNodeId ( ) , i , CodeStatus ( _data [ 2 ] ) . c_str ( ) ) ; if ( m_queryAll && i == m_currentCode ) { if ( m_refreshUserCodes || ( _data [ 2 ] != UserCode_@@ Available ) ) { if ( ++ i <= m_userCodeCount ) { m_currentCode = i ; RequestValue ( 0 , m_currentCode , _instance , Driver :: MsgQueue_Query ) ; } else { m_queryAll = false ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Not ▁ Requesting ▁ addition@@ al ▁ UserCode ▁ Slots ▁ as ▁ RefreshAllUserCodes ▁ is ▁ false , ▁ and ▁ slot ▁ % d ▁ is ▁ available " , i ) ; m_queryAll = false ; } } return true ; } return false ; } bool UserCode :: SetValue ( Value const & _value ) { if ( ( ValueID :: ValueType_@@ Raw == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) < UserCodeIndex_Refresh ) ) { ValueRaw const * value = static_cast < ValueRaw const * > ( & _value ) ; uint8 * s = value -> GetValue ( ) ; uint8 len = value -> GetLength ( ) ; if ( len > UserCodeLength ) { return false ; } m_userCodesStatus [ value -> GetID ( ) . GetIndex ( ) ] = UserCode_Occupied ; Msg * msg = new Msg ( " UserCodeCmd _ Set " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true ) ; msg -> SetInstance ( this , _value . GetID ( ) . GetInstance ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 4 + len ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Set ) ; msg -> Append ( value -> GetID ( ) . GetIndex ( ) ) ; msg -> Append ( UserCode_Occupied ) ; for ( uint8 i = 0 ; i < len ; i ++ ) { msg -> Append ( s [ i ] ) ; } msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , Driver :: MsgQueue_@@ Send ) ; return true ; } if ( ( ValueID :: ValueType_@@ Button == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) == UserCodeIndex_Refresh ) ) { m_refreshUserCodes = true ; m_currentCode = 1 ; m_queryAll = true ; RequestValue ( 0 , m_currentCode , _value . GetID ( ) . GetInstance ( ) , Driver :: MsgQueue_Query ) ; return true ; } return false ; } void UserCode :: CreateVars ( uint8 const _instance ) { if ( Node * node = GetNodeUnsafe ( ) ) { node -> CreateValueByte ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Count , " Code ▁ Count " , " " , true , false , 0 , 0 ) ; node -> CreateValueButton ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Refresh , " Refresh ▁ All ▁ UserCodes " , 0 ) ; } } </DOCUMENT>
<DOCUMENT_ID="E@@ arlz@@ /do@@ bbscoin@@ -source@@ /tree/master/src/test/@@ transaction@@ _tests.cpp"> # include " data / tx _ invalid . json . h " # include " data / tx _ valid . json . h " # include " clientversion . h " # include " key . h " # include " keystore . h " # include " main . h " # include " script / script . h " # include " script / script _ error . h " # include " core _ io . h " # include < map > # include < string > # include < boost / algorithm / string / classification . hpp > # include < boost / algorithm / string / split . hpp > # include < boost / test / unit_test . hpp > # include < boost / assign / list_of . hpp > # include " json / json _ spirit _ writer _ template . h " using namespace std ; using namespace json_spirit ; using namespace boost :: algorithm ; extern Array read_json ( const std :: string & jsondata ) ; static std :: map < string , unsigned int > mapFlagNames = boost :: assign :: map_list_of ( string ( " NONE " ) , ( unsigned int ) SCRIPT_VERIFY_NONE ) ( string ( " P2SH " ) , ( unsigned int ) SCRIPT_VERIFY_P2SH ) ( string ( " STRICTENC " ) , ( unsigned int ) SCRIPT_VERIFY_STRICTENC ) ( string ( " DERSIG " ) , ( unsigned int ) SCRIPT_VERIFY_DERSIG ) ( string ( " LOW _ S " ) , ( unsigned int ) SCRIPT_VERIFY_LOW_S ) ( string ( " SIGPUSHONLY " ) , ( unsigned int ) SCRIPT_VERIF@@ Y_SI@@ GPUSHONLY ) ( string ( " MINIMALDATA " ) , ( unsigned int ) SCRIPT_VERIFY_MINIMALDATA ) ( string ( " NULLDUMMY " ) , ( unsigned int ) SCRIPT_VERIFY_NULLDUMMY ) ( string ( " DISCOUR@@ AGE _ UPGRAD@@ ABLE _ NOPS " ) , ( unsigned int ) SCRIPT_VERIFY_DISCOUR@@ AGE_UPGRAD@@ ABLE_NOPS ) ; unsigned int ParseScriptFlags ( string strFlags ) { if ( strFlags . empty ( ) ) { return 0 ; } unsigned int flags = 0 ; vector < string > words ; split ( words , strFlags , is_any_@@ of ( " , " ) ) ; BOOST_FOREACH ( string word , words ) { if ( ! mapFlagNames . count ( word ) ) BOOST_ERROR ( " Bad ▁ test : ▁ unknown ▁ verification ▁ flag ▁ ' " << word << " ' " ) ; flags |= mapFlagNames [ word ] ; } return flags ; } string FormatScriptFlags ( unsigned int flags ) { if ( flags == 0 ) { return " " ; } string ret ; std :: map < string , unsigned int > :: const_iterator it = mapFlagNames . begin ( ) ; while ( it != mapFlagNames . end ( ) ) { if ( flags & it -> second ) { ret += it -> first + " , " ; } it ++ ; } return ret . substr ( 0 , ret . size ( ) - 1 ) ; } BOOST_AUTO_TEST_SUITE ( transaction_tests ) BOOST_AUTO_TEST_CASE ( tx_valid ) { Array tests = read_json ( std :: string ( json_tests :: tx_valid , json_tests :: tx_valid + sizeof ( json_tests :: tx_valid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) , strTest ) ; BOOST_CHECK ( state . IsValid ( ) ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; BOOST_CHECK_MESSAGE ( VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) , strTest ) ; BOOST_CHECK_MESSAGE ( err == SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } } BOOST_AUTO_TEST_CASE ( tx_invalid ) { Array tests = read_json ( std :: string ( json_tests :: tx_invalid , json_tests :: tx_invalid + sizeof ( json_tests :: tx_invalid ) ) ) ; ScriptError err ; BOOST_FOREACH ( Value & tv , tests ) { Array test = tv . get_array ( ) ; string strTest = write_string ( tv , false ) ; if ( test [ 0 ] . type ( ) == array_type ) { if ( test . size ( ) != 3 || test [ 1 ] . type ( ) != str_type || test [ 2 ] . type ( ) != str_type ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } map < COutPoint , CScript > mapprevOutScriptPubKeys ; Array inputs = test [ 0 ] . get_array ( ) ; bool fValid = true ; BOOST_FOREACH ( Value & input , inputs ) { if ( input . type ( ) != array_type ) { fValid = false ; break ; } Array vinput = input . get_array ( ) ; if ( vinput . size ( ) != 3 ) { fValid = false ; break ; } mapprevOutScriptPubKeys [ COutPoint ( uint256 ( vinput [ 0 ] . get_str ( ) ) , vinput [ 1 ] . get_int ( ) ) ] = ParseScript ( vinput [ 2 ] . get_str ( ) ) ; } if ( ! fValid ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; continue ; } string transaction = test [ 1 ] . get_str ( ) ; CDataStream stream ( ParseHex ( transaction ) , SER_NETWORK , PROTOCOL_VERSION ) ; CTransaction tx ; stream >> tx ; CValidationState state ; fValid = CheckTransaction ( tx , state ) && state . IsValid ( ) ; for ( unsigned int i = 0 ; i < tx . vin . size ( ) && fValid ; i ++ ) { if ( ! mapprevOutScriptPubKeys . count ( tx . vin [ i ] . prevout ) ) { BOOST_ERROR ( " Bad ▁ test : ▁ " << strTest ) ; break ; } unsigned int verify_flags = ParseScriptFlags ( test [ 2 ] . get_str ( ) ) ; fValid = VerifyScript ( tx . vin [ i ] . scriptSig , mapprevOutScriptPubKeys [ tx . vin [ i ] . prevout ] , verify_flags , TransactionSignatureChecker ( & tx , i ) , & err ) ; } BOOST_CHECK_MESSAGE ( ! fValid , strTest ) ; BOOST_CHECK_MESSAGE ( err != SCRIPT_ERR_OK , ScriptErrorString ( err ) ) ; } } } BOOST_AUTO_TEST_CASE ( basic_@@ transaction_tests ) { unsigned char ch [ ] = { 0x01 , 0x00 , 0x00 , 0x00 , 0x01 , 0x6b , 0xff , 0x7f , 0xcd , 0x4f , 0x85 , 0x65 , 0xef , 0x40 , 0x6d , 0xd5 , 0xd6 , 0x3d , 0x4f , 0xf9 , 0x4f , 0x31 , 0x8f , 0xe@@ 8 , 0x20 , 0x27 , 0xfd , 0x4d , 0xc4 , 0x51 , 0xb0 , 0x44 , 0x74 , 0x01 , 0x9f , 0x74 , 0xb4 , 0x00 , 0x00 , 0x00 , 0x00 , 0x8c , 0x49 , 0x30 , 0x46 , 0x02 , 0x21 , 0x00 , 0xda , 0x0d , 0xc6 , 0xae , 0xce , 0xfe , 0x1e , 0x06 , 0xef , 0xdf , 0x05 , 0x77 , 0x37 , 0x57 , 0xde , 0xb1 , 0x68 , 0x82 , 0x09 , 0x30 , 0xe@@ 3 , 0xb0 , 0xd0 , 0x3f , 0x46 , 0xf5 , 0xfc , 0xf1 , 0x50 , 0xbf , 0x99 , 0x0c , 0x02 , 0x21 , 0x00 , 0xd2 , 0x5b , 0x5c , 0x87 , 0x04 , 0x00 , 0x76 , 0xe@@ 4 , 0xf2 , 0x53 , 0xf8 , 0x26 , 0x2e , 0x76 , 0x3e , 0x2d , 0xd5 , 0x1e , 0x7f , 0xf0 , 0xbe , 0x15 , 0x77 , 0x27 , 0xc4 , 0xbc , 0x42 , 0x80 , 0x7f , 0x17 , 0xbd , 0x39 , 0x01 , 0x41 , 0x04 , 0xe@@ 6 , 0xc2 , 0x6e , 0xf6 , 0x7d , 0xc6 , 0x10 , 0xd2 , 0xcd , 0x19 , 0x24 , 0x84 , 0x78 , 0x9a , 0x6c , 0xf9 , 0xae , 0xa9 , 0x93 , 0x0b , 0x94 , 0x4b , 0x7e , 0x2d , 0xb5 , 0x34 , 0x2b , 0x9d , 0x9e , 0x5b , 0x9f , 0xf7 , 0x9a , 0xff , 0x9a , 0x2e , 0xe1 , 0x97 , 0x8d , 0xd7 , 0xfd , 0x01 , 0xdf , 0xc5 , 0x22 , 0xee , 0x02 , 0x28 , 0x3d , 0x3b , 0x06 , 0xa9 , 0xd0 , 0x3a , 0xcf , 0x80 , 0x96 , 0x96 , 0x8d , 0x7d , 0xbb , 0x0f , 0x91 , 0x78 , 0xff , 0xff , 0xff , 0xff , 0x02 , 0x8b , 0xa7 , 0x94 , 0x0e , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xba , 0xde , 0xec , 0xfd , 0xef , 0x05 , 0x07 , 0x24 , 0x7f , 0xc8 , 0xf7 , 0x42 , 0x41 , 0xd7 , 0x3b , 0xc0 , 0x39 , 0x97 , 0x2d , 0x7b , 0x88 , 0xac , 0x40 , 0x94 , 0xa8 , 0x02 , 0x00 , 0x00 , 0x00 , 0x00 , 0x19 , 0x76 , 0xa9 , 0x14 , 0xc1 , 0x09 , 0x32 , 0x48 , 0x3f , 0xec , 0x93 , 0xed , 0x51 , 0xf5 , 0xfe , 0x95 , 0xe@@ 7 , 0x25 , 0x59 , 0xf2 , 0xcc , 0x70 , 0x43 , 0xf9 , 0x88 , 0xac , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; vector < unsigned char > vch ( ch , ch + sizeof ( ch ) - 1 ) ; CDataStream stream ( vch , SER_@@ DISK , CLIENT_VERSION ) ; CMutableTransaction tx ; stream >> tx ; CValidationState state ; BOOST_CHECK_MESSAGE ( CheckTransaction ( tx , state ) && state . IsValid ( ) , " Simple ▁ deserial@@ ized ▁ transaction ▁ should ▁ be ▁ valid . " ) ; tx . vin . push_back ( tx . vin [ 0 ] ) ; BOOST_CHECK_MESSAGE ( ! CheckTransaction ( tx , state ) || ! state . IsValid ( ) , " Transaction ▁ with ▁ duplic@@ ate ▁ txins ▁ should ▁ be ▁ invalid . " ) ; } static std :: vector < CMutableTransaction > SetupDummyInputs ( CBasicKeyStore & keystoreRet , CCoinsViewCache & coinsRet ) { std :: vector < CMutableTransaction > dummyTransactions ; dummyTransactions . resize ( 2 ) ; CKey key [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { key [ i ] . MakeNewKey ( i % 2 ) ; keystoreRet . AddKey ( key [ i ] ) ; } dummyTransactions [ 0 ] . vout . resize ( 2 ) ; dummyTransactions [ 0 ] . vout [ 0 ] . nValue = 11 * CENT ; dummyTransactions [ 0 ] . vout [ 0 ] . scriptPubKey << ToByteVector ( key [ 0 ] . GetPubKey ( ) ) << OP_CHECKSIG ; dummyTransactions [ 0 ] . vout [ 1 ] . nValue = 50 * CENT ; dummyTransactions [ 0 ] . vout [ 1 ] . scriptPubKey << ToByteVector ( key [ 1 ] . GetPubKey ( ) ) << OP_CHECKSIG ; coinsRet . ModifyCoins ( dummyTransactions [ 0 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 0 ] , 0 ) ; dummyTransactions [ 1 ] . vout . resize ( 2 ) ; dummyTransactions [ 1 ] . vout [ 0 ] . nValue = 21 * CENT ; dummyTransactions [ 1 ] . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key [ 2 ] . GetPubKey ( ) . GetID ( ) ) ; dummyTransactions [ 1 ] . vout [ 1 ] . nValue = 22 * CENT ; dummyTransactions [ 1 ] . vout [ 1 ] . scriptPubKey = GetScriptForDestination ( key [ 3 ] . GetPubKey ( ) . GetID ( ) ) ; coinsRet . ModifyCoins ( dummyTransactions [ 1 ] . GetHash ( ) ) -> FromTx ( dummyTransactions [ 1 ] , 0 ) ; return dummyTransactions ; } BOOST_AUTO_TEST_CASE ( test_Get ) { CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t1 ; t1 . vin . resize ( 3 ) ; t1 . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t1 . vin [ 0 ] . prevout . n = 1 ; t1 . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t1 . vin [ 1 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 1 ] . prevout . n = 0 ; t1 . vin [ 1 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vin [ 2 ] . prevout . hash = dummyTransactions [ 1 ] . GetHash ( ) ; t1 . vin [ 2 ] . prevout . n = 1 ; t1 . vin [ 2 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) << std :: vector < unsigned char > ( 33 , 4 ) ; t1 . vout . resize ( 2 ) ; t1 . vout [ 0 ] . nValue = 90 * CENT ; t1 . vout [ 0 ] . scriptPubKey << OP_1 ; BOOST_CHECK ( AreInputsStandard ( t1 , coins ) ) ; BOOST_CHECK_EQUAL ( coins . GetValueIn ( t1 ) , ( 50 + 21 + 22 ) * CENT ) ; t1 . vin [ 0 ] . scriptSig << OP_11 ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; t1 . vin [ 0 ] . scriptSig = CScript ( ) ; BOOST_CHECK ( ! AreInputsStandard ( t1 , coins ) ) ; } BOOST_AUTO_TEST_CASE ( test_IsStandard ) { LOCK ( cs_main ) ; CBasicKeyStore keystore ; CCoinsView coinsDummy ; CCoinsViewCache coins ( & coinsDummy ) ; std :: vector < CMutableTransaction > dummyTransactions = SetupDummyInputs ( keystore , coins ) ; CMutableTransaction t ; t . vin . resize ( 1 ) ; t . vin [ 0 ] . prevout . hash = dummyTransactions [ 0 ] . GetHash ( ) ; t . vin [ 0 ] . prevout . n = 1 ; t . vin [ 0 ] . scriptSig << std :: vector < unsigned char > ( 65 , 0 ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . nValue = 90 * CENT ; CKey key ; key . MakeNewKey ( true ) ; t . vout [ 0 ] . scriptPubKey = GetScriptForDestination ( key . GetPubKey ( ) . GetID ( ) ) ; string reason ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 501 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . nValue = 601 ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_1 ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef@@ 3800" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout . resize ( 1 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( IsStandardTx ( t , reason ) ) ; t . vout . resize ( 2 ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN << ParseHex ( "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38" ) ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; t . vout [ 0 ] . scriptPubKey = CScript ( ) << OP_RETURN ; t . vout [ 1 ] . scriptPubKey = CScript ( ) << OP_RETURN ; BOOST_CHECK ( ! IsStandardTx ( t , reason ) ) ; } BOOST_AUTO_TEST_SUITE_END ( ) </DOCUMENT>
<DOCUMENT_ID="eric@@ zho@@ u2008@@ /WinObjC/tree/master/deps/3rdparty/iculegacy/source/@@ common/@@ parsepos@@ .cpp"> # include " unicode / parsepos . h " U_NAMESPACE_BEGIN UOBJECT_DEFINE_RTTI_IMPLEMENTATION ( ParsePosition ) ParsePosition :: ~ ParsePosition ( ) { } ParsePosition * ParsePosition :: clone ( ) const { return new ParsePosition ( * this ) ; } U_NAMESPACE_END </DOCUMENT>
<DOCUMENT_ID="Poxle@@ it/s-@@ core/tree/master/src/scriptdev2/@@ scripts/eastern_@@ kingdoms/@@ shadowfang_keep/instan@@ ce_shadowfang_keep.cpp"> # include " precompiled . h " # include " shadowfang _ keep . h " instance_shadowfang_keep :: instance_shadowfang_keep ( Map * pMap ) : ScriptedInstance ( pMap ) { Initialize ( ) ; } void instance_shadowfang_keep :: Initialize ( ) { memset ( & m_auiEncounter , 0 , sizeof ( m_auiEncounter ) ) ; } void instance_shadowfang_keep :: OnCreature@@ Create ( Creature * pCreature ) { switch ( pCreature -> GetEntry ( ) ) { case NPC_ASH : case NPC_ADA : case NPC_FENRUS : break ; case NPC_VIN@@ CENT : if ( m_auiEncounter [ 4 ] == DONE ) pCreature -> SetStandState ( UNIT_STAND_STATE_@@ DEAD ) ; break ; default : return ; } m_m@@ NpcEntryGuidStore [ pCreature -> GetEntry ( ) ] = pCreature -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: OnObjectCreate ( GameObject * pGo ) { switch ( pGo -> GetEntry ( ) ) { case GO_COURTYARD_DOOR : if ( m_auiEncounter [ 0 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_SORCERER_DOOR : if ( m_auiEncounter [ 2 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_DOOR : if ( m_auiEncounter [ 3 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUG@@ AL_F@@ OCUS : break ; default : return ; } m_m@@ GoEntryGuidStore [ pGo -> GetEntry ( ) ] = pGo -> GetObjectGuid ( ) ; } void instance_shadowfang_keep :: DoSpeech ( ) { Creature * pAda = GetSingleCreatureFromStorage ( NPC_ADA ) ; Creature * pAsh = GetSingleCreatureFromStorage ( NPC_ASH ) ; if ( pAda && pAda -> isAlive ( ) && pAsh && pAsh -> isAlive ( ) ) { DoScriptText ( SAY_BOSS_DIE_@@ AD , pAda ) ; DoScriptText ( SAY_BOSS_DIE_@@ AS , pAsh ) ; } } void instance_shadowfang_keep :: SetData ( uint32 uiType , uint32 uiData ) { switch ( uiType ) { case TYPE_FREE_NPC : if ( uiData == DONE ) DoUseDoorOrButton ( GO_COURTYARD_DOOR ) ; m_auiEncounter [ 0 ] = uiData ; break ; case TYPE_RETHILGORE : if ( uiData == DONE ) DoSpeech ( ) ; m_auiEncounter [ 1 ] = uiData ; break ; case TYPE_FENRUS : if ( uiData == DONE ) { if ( Creature * pFenrus = GetSingleCreatureFromStorage ( NPC_FENRUS ) ) pFenrus -> SummonCreature ( NPC_ARCH@@ MAGE_@@ ARUG@@ AL , - 136.@@ 89f , 2169@@ .17@@ f , 136.@@ 58f , 2.794f , TEMPSUMMON_TIMED_@@ DESPAWN , 30000 ) ; } m_auiEncounter [ 2 ] = uiData ; break ; case TYPE_NANDOS : if ( uiData == DONE ) DoUseDoorOrButton ( GO_ARUGAL_DOOR ) ; m_auiEncounter [ 3 ] = uiData ; break ; case TYPE_INTRO : m_auiEncounter [ 4 ] = uiData ; break ; case TYPE_VO@@ IDWAL@@ KER : if ( uiData == DONE ) { m_auiEncounter [ 5 ] ++ ; if ( m_auiEncounter [ 5 ] > 3 ) DoUseDoorOrButton ( GO_SORCERER_DOOR ) ; } break ; } if ( uiData == DONE ) { OUT_SAVE_INST_@@ DATA ; std :: ostringstream saveStream ; saveStream << m_auiEncounter [ 0 ] << " ▁ " << m_auiEncounter [ 1 ] << " ▁ " << m_auiEncounter [ 2 ] << " ▁ " << m_auiEncounter [ 3 ] << " ▁ " << m_auiEncounter [ 4 ] << " ▁ " << m_auiEncounter [ 5 ] ; m_strInst@@ Data = saveStream . str ( ) ; SaveToDB ( ) ; OUT_SAVE_INST_@@ DATA_COMPLETE ; } } uint32 instance_shadowfang_keep :: GetData ( uint32 uiType ) const { switch ( uiType ) { case TYPE_FREE_NPC : return m_auiEncounter [ 0 ] ; case TYPE_RETHILGORE : return m_auiEncounter [ 1 ] ; case TYPE_FENRUS : return m_auiEncounter [ 2 ] ; case TYPE_NANDOS : return m_auiEncounter [ 3 ] ; case TYPE_INTRO : return m_auiEncounter [ 4 ] ; default : return 0 ; } } void instance_shadowfang_keep :: Load ( const char * chrIn ) { if ( ! chrIn ) { OUT_LOAD_INST_@@ DATA_FAIL ; return ; } OUT_LOAD_INST_@@ DATA ( chrIn ) ; std :: istringstream loadStream ( chrIn ) ; loadStream >> m_auiEncounter [ 0 ] >> m_auiEncounter [ 1 ] >> m_auiEncounter [ 2 ] >> m_auiEncounter [ 3 ] >> m_auiEncounter [ 4 ] >> m_auiEncounter [ 5 ] ; for ( uint8 i = 0 ; i < MAX_ENCOUN@@ TER ; ++ i ) { if ( m_auiEncounter [ i ] == IN_PROGRESS ) m_auiEncounter [ i ] = NOT_STARTED ; } OUT_LOAD_INST_@@ DATA_COMPLETE ; } InstanceData * GetInstanceData_instance_shadowfang_keep ( Map * pMap ) { return new instance_shadowfang_keep ( pMap ) ; } void AddSC@@ _instance_shadowfang_keep ( ) { Script * pNewScript ; pNewScript = new Script ; pNewScript -> Name = " instance _ shadowfang _ keep " ; pNewScript -> GetInstance@@ Data = & GetInstanceData_instance_shadowfang_keep ; pNewScript -> RegisterSelf ( ) ; } </DOCUMENT>
<DOCUMENT_ID="k@@ zh@@ ong@@ 1991/Flight@@ -AR@@ .D@@ rone@@ -2/tree/master/src/@@ 3rdparty/Qt4.@@ 8.4/src/3rdparty/webkit/Source/WebCore/@@ platform/@@ graphics/@@ mac/GlyphPage@@ TreeNode@@ Mac.cpp"> # include " config . h " # include " GlyphPage@@ TreeNode . h " # include " Font . h " # include " SimpleFontData . h " # include " WebCore@@ SystemInterface . h " # include < ApplicationServices / ApplicationServices . h > namespace WebCore { static bool shouldUseCoreText ( UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { if ( fontData -> platformData ( ) . width@@ Variant ( ) != Regu@@ larWidth || fontData -> hasVerticalGlyphs ( ) ) { for ( unsigned i = 0 ; i < bufferLength ; ++ i ) { if ( ! Font :: isCJ@@ KIdeo@@ graph ( buffer [ i ] ) ) return true ; } } return false ; } bool GlyphPage :: fill ( unsigned offset , unsigned length , UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { bool haveGlyphs = false ; if ( ! shouldUseCoreText ( buffer , bufferLength , fontData ) ) { Vector < CGGlyph , 512 > glyphs ( bufferLength ) ; wk@@ GetGlyph@@ sFor@@ Characters ( fontData -> platformData ( ) . cgFont ( ) , buffer , glyphs . data ( ) , bufferLength ) ; for ( unsigned i = 0 ; i < length ; ++ i ) { if ( ! glyphs [ i ] ) setGlyphDataForIndex ( offset + i , 0 , 0 ) ; else { setGlyphDataForIndex ( offset + i , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } else { RetainPtr < CFStringRef > string ( AdoptCF , CFStringCreateWith@@ CharactersNo@@ Copy ( kCFAllocatorDefault , buffer , bufferLength , kCFAllocator@@ Null ) ) ; RetainPtr < CFAttributedString@@ Ref > attributedString ( AdoptCF , CFAttributedString@@ Create ( kCFAllocatorDefault , string . get ( ) , fontData -> getCFString@@ Attributes ( 0 , fontData -> hasVerticalGlyphs ( ) ? Vertical : Horizontal ) ) ) ; RetainPtr < CTLine@@ Ref > line ( AdoptCF , CTLine@@ CreateWith@@ AttributedString ( attributedString . get ( ) ) ) ; CFArray@@ Ref runArray = CTLine@@ GetGlyph@@ Runs ( line . get ( ) ) ; CFIndex runCount = CFArray@@ GetCount ( runArray ) ; for ( unsigned index = 0 ; index < length ; ++ index ) setGlyphDataForIndex ( offset + index , 0 , 0 ) ; Vector < CGGlyph , 512 > glyphVector ; Vector < CFIndex , 512 > indexVector ; bool done = false ; RetainPtr < CGFontRef > cgFont ( AdoptCF , CTFontCopyGraphicsFont ( fontData -> platformData ( ) . ctFont ( ) , 0 ) ) ; for ( CFIndex r = 0 ; r < runCount && ! done ; ++ r ) { CTRunRef ctRun = static_cast < CTRunRef > ( CFArray@@ GetValueAtIndex ( runArray , r ) ) ; ASSERT ( CFGetTypeID ( ctRun ) == CTRunGetTypeID ( ) ) ; CFDictionary@@ Ref attributes = CTRunGet@@ Attributes ( ctRun ) ; CTFontRef runFont = static_cast < CTFontRef > ( CFDictionary@@ GetValue ( attributes , kCTFont@@ AttributeName ) ) ; RetainPtr < CGFontRef > runCGFont ( AdoptCF , CTFontCopyGraphicsFont ( runFont , 0 ) ) ; if ( CFE@@ qual ( cgFont . get ( ) , runCGFont . get ( ) ) ) { CFIndex glyphCount = CTRunGetGlyph@@ Count ( ctRun ) ; const CGGlyph * glyphs = CTRunGetGlyph@@ sPtr ( ctRun ) ; if ( ! glyphs ) { glyphVector . resize ( glyphCount ) ; CTRunGet@@ Glyphs ( ctRun , CFRangeMake ( 0 , 0 ) , glyphVector . data ( ) ) ; glyphs = glyphVector . data ( ) ; } const CFIndex * stringIndices = CTRunGetString@@ Indices@@ Ptr ( ctRun ) ; if ( ! stringIndices ) { indexVector . resize ( glyphCount ) ; CTRunGetString@@ Indices ( ctRun , CFRangeMake ( 0 , 0 ) , indexVector . data ( ) ) ; stringIndices = indexVector . data ( ) ; } for ( CFIndex i = 0 ; i < glyphCount ; ++ i ) { if ( stringIndices [ i ] >= static_cast < CFIndex > ( length ) ) { done = true ; break ; } if ( glyphs [ i ] ) { setGlyphDataForIndex ( offset + stringIndices [ i ] , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } } } return haveGlyphs ; } } </DOCUMENT>
<DOCUMENT_ID="tectr@@ onics/@@ mysql@@ -par@@ allel-@@ rep@@ lication/tree/master/@@ extra@@ /y@@ assl/t@@ aoc@@ rypt/src/@@ hash.cpp"> # include " runtime . hpp " # include < string . h > # include < assert . h > # include " hash . hpp " namespace TaoC@@ rypt { HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASHwithTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # ifdef WORD64_AVAILABLE HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; } void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; } void HASH64withTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } } void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; } # endif } </DOCUMENT>
<DOCUMENT_ID="m@@ gser@@ gio@@ /om@@ im/tree/master/base/@@ osm_id@@ .cpp"> # include " base / osm _ id . hpp " # include " base / assert . hpp " # include < sstream > namespace osm { static const uint64_t NODE = 0x4000000000000000ULL ; static const uint64_t WAY = 0x8000000000000000ULL ; static const uint64_t RELATION = 0xC000000000000000ULL ; static const uint64_t RESET = ~ ( NODE | WAY | RELATION ) ; Id :: Id ( uint64_t encodedId ) : m_encodedId ( encodedId ) { } Id Id :: Node ( uint64_t id ) { return Id ( id | NODE ) ; } Id Id :: Way ( uint64_t id ) { return Id ( id | WAY ) ; } Id Id :: Relation ( uint64_t id ) { return Id ( id | RELATION ) ; } uint64_t Id :: OsmId ( ) const { return m_encodedId & RESET ; } uint64_t Id :: Encoded@@ Id ( ) const { return m_encodedId ; } bool Id :: IsNode ( ) const { return ( ( m_encodedId & NODE ) == NODE ) ; } bool Id :: IsWay ( ) const { return ( ( m_encodedId & WAY ) == WAY ) ; } bool Id :: IsRelation ( ) const { return ( ( m_encodedId & RELATION ) == RELATION ) ; } std :: string Id :: Type ( ) const { if ( ( m_encodedId & RELATION ) == RELATION ) return " relation " ; else if ( ( m_encodedId & NODE ) == NODE ) return " node " ; else if ( ( m_encodedId & WAY ) == WAY ) return " way " ; else return " ERROR : ▁ Not ▁ initialized ▁ Osm ▁ ID " ; } std :: string DebugPrint ( osm :: Id const & id ) { std :: ostringstream stream ; stream << id . Type ( ) << " ▁ " << id . OsmId ( ) ; return stream . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="R@@ izta@@ zz@@ /tr@@ initycore@@ -m4@@ a/tree/master/src/server/scripts/EasternKingdoms/@@ Strathol@@ me/@@ boss_nerubenkan@@ .cpp"> # include " stdafx . hpp " # include " ScriptMgr . h " # include " ScriptedCreature . h " # include " strathol@@ me . h " enum Spells { SPELL_ENCASINGWEBS = 4962 , SPELL_PIERCEARMOR = 6016 , SPELL_CRYPT_SCARABS = 31602 , SPELL_RAI@@ SEUNDEAD@@ SCARAB = 172@@ 35 } ; class boss_nerubenkan : public CreatureScript { public : boss_nerubenkan ( ) : CreatureScript ( " boss _ nerubenkan " ) { } CreatureAI * GetAI ( Creature * creature ) const { return new boss_nerubenkanAI ( creature ) ; } struct boss_nerubenkanAI : public ScriptedAI { boss_nerubenkanAI ( Creature * creature ) : ScriptedAI ( creature ) { instance = me -> GetInstanceScript ( ) ; } InstanceScript * instance ; uint32 EncasingWebs_Timer ; uint32 PierceArmor_Timer ; uint32 CryptScarabs_Timer ; uint32 RaiseUndeadScarab_Timer ; void Reset ( ) { CryptScarabs_Timer = 3000 ; EncasingWebs_Timer = 7000 ; PierceArmor_Timer = 19000 ; RaiseUndeadScarab_Timer = 3000 ; } void EnterCombat ( Unit * ) { } void JustDied ( Unit * ) { if ( instance ) instance -> SetData ( TYPE_N@@ ERUB , IN_PROGRESS ) ; } void RaiseUndeadScarab ( Unit * victim ) { if ( Creature * pUndeadScarab = DoSpawn@@ Creature ( 10876 , float ( irand ( - 9 , 9 ) ) , float ( irand ( - 9 , 9 ) ) , 0 , 0 , TEMPSUMMON_TIMED_@@ OR_CORPSE_DESPAWN , 180000 ) ) if ( pUndeadScarab -> AI ( ) ) pUndeadScarab -> AI ( ) -> AttackStart ( victim ) ; } void UpdateAI ( const uint32 diff ) { if ( ! UpdateVictim ( ) ) return ; if ( EncasingWebs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_ENCASINGWEBS ) ; EncasingWebs_Timer = 30000 ; } else EncasingWebs_Timer -= diff ; if ( PierceArmor_Timer <= diff ) { if ( urand ( 0 , 3 ) < 2 ) DoCast ( me -> getVictim ( ) , SPELL_PIERCEARMOR ) ; PierceArmor_Timer = 35000 ; } else PierceArmor_Timer -= diff ; if ( CryptScarabs_Timer <= diff ) { DoCast ( me -> getVictim ( ) , SPELL_CRYPT_SCARABS ) ; CryptScarabs_Timer = 20000 ; } else CryptScarabs_Timer -= diff ; if ( RaiseUndeadScarab_Timer <= diff ) { RaiseUndeadScarab ( me -> getVictim ( ) ) ; RaiseUndeadScarab_Timer = 16000 ; } else RaiseUndeadScarab_Timer -= diff ; DoMeleeAttackIfReady ( ) ; } } ; } ; void AddSC_@@ boss_nerubenkan ( ) { new boss_nerubenkan ( ) ; } </DOCUMENT>
<DOCUMENT_ID="s@@ litvin@@ ov/@@ lammp@@ s-sph@@ -multi@@ phase/tree/master/src/ASPH@@ ERE/compute_@@ temp_asphere.cpp"> # include " mpi . h " # include " string . h " # include " compute _ temp _ asphere . h " # include " math _ extra . h " # include " atom . h " # include " atom _ vec _ ellipsoid . h " # include " update . h " # include " force . h " # include " domain . h " # include " modify . h " # include " group . h " # include " memory . h " # include " error . h " using namespace LAMMP@@ S_NS ; enum { ROTATE , ALL } ; # define INERTIA 0.2 ComputeTempAsphere :: ComputeTempAsphere ( LAMMP@@ S * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_@@ flag = vector@@ _flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; } ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; } void ComputeTempAsphere :: init ( ) { avec = ( AtomVecEllipsoid * ) atom -> style_@@ match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ partic@@ les " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } } void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; } void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adju@@ st_dof_@@ fix ( ) ; double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimen@@ sion == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_re@@ move_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extr@@ a_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> bolt@@ z ) ; else tfactor = 0.0 ; } double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; } void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; } void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; } void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; } </DOCUMENT>
<DOCUMENT_ID="MobW@@ iMet@@ ro/gba@@ 10/tree/master/@@ GBA10@@ /V@@ BAM@@ /gb@@ a/gbafilter@@ .cpp"> # include " gba@@ filter . h " # include < math . h > extern int systemColorDepth ; extern int systemRedShift ; extern int systemGreenShift ; extern int systemBlueShift ; extern u16 systemColorMap@@ 16 [ 0x10000 ] ; extern u32 systemColorMap@@ 32 [ 0x10000 ] ; static const unsigned char curve [ 32 ] = { 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0e , 0x10 , 0x12 , 0x14 , 0x16 , 0x18 , 0x1c , 0x20 , 0x28 , 0x30 , 0x38 , 0x40 , 0x48 , 0x50 , 0x58 , 0x60 , 0x68 , 0x70 , 0x80 , 0x88 , 0x90 , 0xa0 , 0xb0 , 0xc0 , 0xd0 , 0xe0 , 0xf0 } ; static const unsigned char influence [ 3 * 3 ] = { 16 , 4 , 4 , 8 , 16 , 8 , 0 , 8 , 16 } ; inline void swap ( short & a , short & b ) { short temp = a ; a = b ; b = temp ; } void gbafilter_p@@ al ( u16 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 17 ) + 4 ; if ( red > 31 ) red = 31 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 17 ) + 4 ; if ( blue > 31 ) blue = 31 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 17 ) + 4 ; if ( green > 31 ) green = 31 ; pix = red << systemRedShift ; pix += green << systemGreenShift ; pix += blue << systemBlueShift ; * buf ++ = pix ; } } void gbafilter_p@@ al32 ( u32 * buf , int count ) { short temp [ 3 * 3 ] , s ; unsigned pix ; u8 red , green , blue ; while ( count -- ) { pix = * buf ; s = curve [ ( pix >> systemGreenShift ) & 0x1f ] ; temp [ 3 ] = s * influence [ 3 ] ; temp [ 4 ] = s * influence [ 4 ] ; temp [ 5 ] = s * influence [ 5 ] ; s = curve [ ( pix >> systemRedShift ) & 0x1f ] ; temp [ 0 ] = s * influence [ 0 ] ; temp [ 1 ] = s * influence [ 1 ] ; temp [ 2 ] = s * influence [ 2 ] ; s = curve [ ( pix >> systemBlueShift ) & 0x1f ] ; temp [ 6 ] = s * influence [ 6 ] ; temp [ 7 ] = s * influence [ 7 ] ; temp [ 8 ] = s * influence [ 8 ] ; if ( temp [ 0 ] < temp [ 3 ] ) swap ( temp [ 0 ] , temp [ 3 ] ) ; if ( temp [ 0 ] < temp [ 6 ] ) swap ( temp [ 0 ] , temp [ 6 ] ) ; if ( temp [ 3 ] < temp [ 6 ] ) swap ( temp [ 3 ] , temp [ 6 ] ) ; temp [ 3 ] <<= 1 ; temp [ 0 ] <<= 2 ; temp [ 0 ] += temp [ 3 ] + temp [ 6 ] ; red = ( ( int ( temp [ 0 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 2 ] < temp [ 5 ] ) swap ( temp [ 2 ] , temp [ 5 ] ) ; if ( temp [ 2 ] < temp [ 8 ] ) swap ( temp [ 2 ] , temp [ 8 ] ) ; if ( temp [ 5 ] < temp [ 8 ] ) swap ( temp [ 5 ] , temp [ 8 ] ) ; temp [ 5 ] <<= 1 ; temp [ 2 ] <<= 2 ; temp [ 2 ] += temp [ 5 ] + temp [ 8 ] ; blue = ( ( int ( temp [ 2 ] ) * 160 ) >> 14 ) + 32 ; if ( temp [ 1 ] < temp [ 4 ] ) swap ( temp [ 1 ] , temp [ 4 ] ) ; if ( temp [ 1 ] < temp [ 7 ] ) swap ( temp [ 1 ] , temp [ 7 ] ) ; if ( temp [ 4 ] < temp [ 7 ] ) swap ( temp [ 4 ] , temp [ 7 ] ) ; temp [ 4 ] <<= 1 ; temp [ 1 ] <<= 2 ; temp [ 1 ] += temp [ 4 ] + temp [ 7 ] ; green = ( ( int ( temp [ 1 ] ) * 160 ) >> 14 ) + 32 ; pix = red << ( systemRedShift - 3 ) ; pix += green << ( systemGreenShift - 3 ) ; pix += blue << ( systemBlueShift - 3 ) ; * buf ++ = pix ; } } void gbafilter_p@@ ad ( u8 * buf , int count ) { union { struct { u8 r ; u8 g ; u8 b ; u8 a ; } part ; unsigned whole ; } mask ; mask . whole = 0x1f << systemRedShift ; mask . whole += 0x1f << systemGreenShift ; mask . whole += 0x1f << systemBlueShift ; switch ( systemColorDepth ) { case 24 : while ( count -- ) { * buf ++ &= mask . part . r ; * buf ++ &= mask . part . g ; * buf ++ &= mask . part . b ; } break ; case 32 : while ( count -- ) { * ( ( u32 * ) buf ) &= mask . whole ; buf += 4 ; } } } </DOCUMENT>
<DOCUMENT_ID="arangodb@@ /arangodb/tree/master/3rdParty/boost/@@ 1.71.0/libs/@@ hana/@@ example/@@ chain@@ .cpp"> # include < boost / hana / assert . hpp > # include < boost / hana / chain . hpp > # include < boost / hana / config . hpp > # include < boost / hana / equal . hpp > # include < boost / hana / optional . hpp > namespace hana = boost :: hana ; BOOST_HANA_CONSTEXPR_LAMBDA auto deref = [ ] ( auto x ) -> decltype ( * x ) { return * x ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto age = [ ] ( auto x ) -> decltype ( x . age ) { return x . age ; } ; BOOST_HANA_CONSTEXPR_LAMBDA auto f = [ ] ( auto x ) { return hana :: chain ( hana :: sfinae ( deref ) ( x ) , hana :: sfinae ( age ) ) ; } ; struct Person { unsigned int age ; } ; int main ( ) { constexpr Person john { 30 } ; BOOST_HANA_CONSTANT_CHECK ( f ( john ) == hana :: nothing ) ; BOOST_HANA_CONSTANT_CHECK ( f ( 1 ) == hana :: nothing ) ; BOOST_HANA_CONSTEXPR_@@ CHECK ( f ( & john ) == hana :: just ( 30u ) ) ; } </DOCUMENT>
<DOCUMENT_ID="jo@@ bermay@@ r/@@ pcsx2@@ /tree/master/3rdparty/@@ wxwidget@@ s3.@@ 0/src/@@ common/@@ filectr@@ lcm@@ n.cpp"> # include " wx / wxprec . h " # ifdef __BORLANDC__ # pragma hdrstop # endif # if wxUSE_FILECTRL # include " wx / filectrl . h " # ifndef WX_PRECOMP # include " wx / debug . h " # endif const char wxFileCtrlNameStr [ ] = " wxfilectrl " ; wxDEFINE_EVENT ( wxEVT_FILECTRL_SELECTIONCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILEACTIVATED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FOLDERCHANGED , wxFileCtrlEvent ) ; wxDEFINE_EVENT ( wxEVT_FILECTRL_FILTERCHANGED , wxFileCtrlEvent ) ; IMPLEMENT_DYNAMIC_CLASS ( wxFileCtrlEvent , wxCommandEvent ) void GenerateFilter@@ ChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILTERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetFilterIndex ( fileCtrl -> GetFilterIndex ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFolder@@ ChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FOLDERCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateSelectionChangedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_SELECTIONCHANGED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; fileCtrl -> GetFilenames ( filenames ) ; event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } void GenerateFileActiv@@ atedEvent ( wxFileCtrlBase * fileCtrl , wxWindow * wnd , const wxString filename ) { wxFileCtrlEvent event ( wxEVT_FILECTRL_FILEACTIVATED , wnd , wnd -> GetId ( ) ) ; event . SetDirectory ( fileCtrl -> GetDirectory ( ) ) ; wxArrayString filenames ; if ( filename . empty ( ) ) { fileCtrl -> GetFilenames ( filenames ) ; } else { filenames . Add ( filename ) ; } event . SetFiles ( filenames ) ; wnd -> GetEventHandler ( ) -> ProcessEvent ( event ) ; } wxString wxFileCtrlEvent :: GetFile ( ) const { wxASSERT_MSG ( ! wxDynamicCast ( GetEventObject ( ) , wxFileCtrl ) -> HasMultiple@@ FileSelection ( ) , wxT ( " Please ▁ use ▁ GetFiles ( ) ▁ to ▁ get ▁ all ▁ files ▁ instead ▁ of ▁ this ▁ function " ) ) ; wxString string ; if ( m_files . Count ( ) != 0 ) string = m_files [ 0 ] ; return string ; } # endif </DOCUMENT>
<DOCUMENT_ID="l@@ unastor@@ m/wis@@ sbi@@ /tree/master/3r@@ d_party/@@ libcxx/test/@@ strings/basic@@ .string@@ /string@@ .mod@@ ifier@@ s/string_@@ append/pointer@@ .pass.cpp"> # include < string > # include < stdexcept > # include < cassert > template < class S > void test ( S s , const typename S :: value_type * str , S expected ) { s . append ( str ) ; assert ( s . __invarian@@ ts ( ) ) ; assert ( s == expected ) ; } int main ( ) { typedef std :: string S ; test ( S ( ) , " " , S ( ) ) ; test ( S ( ) , "12345" , S ( "12345" ) ) ; test ( S ( ) , "12345678901234567890" , S ( "12345678901234567890" ) ) ; test ( S ( "12345" ) , " " , S ( "12345" ) ) ; test ( S ( "12345" ) , "12345" , S ( "1234512345" ) ) ; test ( S ( "12345" ) , "1234567890" , S ( "123451234567890" ) ) ; test ( S ( "12345678901234567890" ) , " " , S ( "12345678901234567890" ) ) ; test ( S ( "12345678901234567890" ) , "12345" , S ( "1234567890123456789012345" ) ) ; test ( S ( "12345678901234567890" ) , "12345678901234567890" , S ( "1234567890123456789012345678901234567890" ) ) ; } </DOCUMENT>
<DOCUMENT_ID="pa@@ ulfit@@ z/phantomjs/tree/master/src/qt/qt@@ webkit/Tool@@ s/Dump@@ RenderTree/@@ TestNet@@ scapePlugIn@@ /Tests/@@ GetURLWithJavaScriptURLDestroying@@ Plugin.cpp"> # include " PluginTest . h " using namespace std ; class GetURLWithJavaScriptURLDestroyingPlugin : public PluginTest { public : GetURLWithJavaScriptURLDestroyingPlugin ( NPP npp , const string & identifier ) : PluginTest ( npp , identifier ) { } private : virtual NPError NPP_New ( NPMIME@@ Type plugin@@ Type , uint16_t mode , int16_t argc , char * argn [ ] , char * argv [ ] , NPSaved@@ Data * saved ) { NPN_@@ GetURL ( " javascript : removePlugin ( ) " , 0 ) ; return NPERR_@@ NO_ERROR ; } } ; static PluginTest :: Register < GetURLWithJavaScriptURLDestroyingPlugin > getURLWithJavaScriptURLDestroying@@ Plugin ( " get - url - with - javascript - url - destroy@@ ing - plugin " ) ; </DOCUMENT>
<DOCUMENT_ID="p@@ lexinc/p@@ lex-home@@ -th@@ eater-@@ public/tree/master/@@ plex@@ /Update@@ -Inst@@ aller/@@ external/@@ win32cpp@@ /tutorial@@ s/Tutorial@@ 8/@@ View.cpp"> # include " view . h " # include " GDI . h " # include " file . h " # include " resource . h " using namespace std ; CView :: CView ( ) : m_PenColor ( RGB ( 0 , 0 , 0 ) ) { m_Brush . CreateSol@@ idBrush ( RGB ( 255 , 255 , 230 ) ) ; } CView :: ~ CView ( ) { } void CView :: ClearPoints ( ) { m_points . clear ( ) ; Invalidate ( ) ; } void CView :: DrawLine ( int x , int y ) { CClient@@ DC dcClient ( this ) ; dcClient . CreatePen ( PS_SOLID , 1 , m_points . back ( ) . color ) ; dcClient . MoveTo ( m_points . back ( ) . x , m_points . back ( ) . y ) ; dcClient . LineTo ( x , y ) ; } void CView :: OnDraw ( CDC * pDC ) { if ( m_points . size ( ) > 0 ) { bool bDraw = false ; for ( unsigned int i = 0 ; i < m_points . size ( ) ; i ++ ) { pDC -> CreatePen ( PS_SOLID , 1 , m_points [ i ] . color ) ; if ( bDraw ) pDC -> LineTo ( m_points [ i ] . x , m_points [ i ] . y ) ; else pDC -> MoveTo ( m_points [ i ] . x , m_points [ i ] . y ) ; bDraw = m_points [ i ] . PenDown ; } } } void CView :: PreCreate ( CREATESTRUCT & cs ) { cs . dwExStyle = WS_EX_CLIENTEDGE ; } void CView :: PreRegisterClass ( WNDCLASS & wc ) { wc . hbr@@ Background = m_Brush ; wc . lpszClassName = _T ( " Scri@@ bble ▁ Window " ) ; wc . hCursor = :: LoadCursor ( GetApp ( ) -> GetInstance@@ Handle ( ) , MAKE@@ INTR@@ ESOURCE ( IDC_@@ CURS@@ OR1 ) ) ; } BOOL CView :: FileOpen ( LPCTSTR szFilename ) { m_points . clear ( ) ; DWORD nBytesRead ; BOOL bResult = FALSE ; CFile File ; if ( File . Open ( szFilename , OPEN_EXISTING ) ) { do { PlotPoint pp ; nBytesRead = File . Read ( & pp , sizeof ( PlotPoint ) ) ; if ( nBytesRead == sizeof ( PlotPoint ) ) m_points . push_back ( pp ) ; } while ( nBytesRead == sizeof ( PlotPoint ) ) ; if ( ( 0 != nBytesRead ) || ( m_points . empty ( ) ) ) { m_points . clear ( ) ; :: MessageBox ( 0 , _T ( " Invalid ▁ data ▁ in ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } else bResult = TRUE ; } else { tString tsErrMsg = _T ( " Failed ▁ to ▁ open ▁ file ▁ " ) ; tsErrMsg += szFilename ; :: MessageBox ( 0 , tsErrMsg . c_str ( ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } Invalidate ( ) ; return bResult ; } BOOL CView :: FileSave ( LPCTSTR szFilename ) { BOOL bResult = TRUE ; CFile hFile ; if ( ! hFile . Open ( szFilename , CREATE_ALWAY@@ S ) ) { :: MessageBox ( 0 , _T ( " Failed ▁ to ▁ open ▁ file ▁ for ▁ writing " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } if ( bResult ) { for ( size_t i = 0 ; i < m_points . size ( ) ; ++ i ) { if ( ! hFile . Write ( & m_points [ i ] , sizeof ( PlotPoint ) ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; break ; } } if ( hFile . GetLength ( ) != m_points . size ( ) * sizeof ( PlotPoint ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } } return bResult ; } void CView :: SetPen ( COLOR@@ REF color ) { m_PenColor = color ; } void CView :: StorePoint ( int x , int y , bool PenDown ) { PlotPoint P1 ; P1 . x = x ; P1 . y = y ; P1 . PenDown = PenDown ; P1 . color = m_PenColor ; m_points . push_back ( P1 ) ; } void CView :: OnLButtonDown ( LPARAM lParam ) { SetCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } void CView :: OnLButtonUp ( LPARAM lParam ) { { ReleaseCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , false ) ; } } void CView :: OnMouseMove ( WPARAM wParam , LPARAM lParam ) { if ( ( wParam & MK_@@ LBUTTON ) && ( GetCapture ( ) == this ) ) { DrawLine ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } } LRESULT CView :: WndProc ( UINT uMsg , WPARAM wParam , LPARAM lParam ) { switch ( uMsg ) { case WM_LBUTTONDOWN : OnLButtonDown ( lParam ) ; break ; case WM_MOUSE@@ MOVE : OnMouseMove ( wParam , lParam ) ; break ; case WM_LBUTTON@@ UP : OnLButtonUp ( lParam ) ; break ; } return WndProc@@ Default ( uMsg , wParam , lParam ) ; } </DOCUMENT>
<DOCUMENT_ID="o@@ stash@@ /qt-@@ creator-i18@@ n-@@ uk@@ /tree/master/src/plugins/@@ help/xbel@@ support@@ .cpp"> # include " xbel@@ support . h " # include " bookmark@@ manager . h " # include < QCoreApplication > using namespace Help :: Internal ; struct Bookmark { QString title ; QString url ; bool folded ; } ; XbelWriter :: XbelWriter ( BookmarkModel * model ) : QXmlStream@@ Writer ( ) , treeModel ( model ) { setAuto@@ Formatting ( true ) ; } void XbelWriter :: writeTo@@ File ( QIODevice * device ) { setDevice ( device ) ; writeStart@@ Document ( ) ; writeDT@@ D ( QLatin1String ( " < ! DOCTYPE ▁ xbel > " ) ) ; writeStartElement ( QLatin1String ( " xbel " ) ) ; writeAttribute ( QLatin1String ( " version " ) , QLatin1String ( "1.0" ) ) ; QStandardItem * root = treeModel -> invis@@ ible@@ RootItem ( ) ; for ( int i = 0 ; i < root -> rowCount ( ) ; ++ i ) writeData ( root -> child ( i ) ) ; writeEnd@@ Document ( ) ; } void XbelWriter :: writeData ( QStandardItem * child ) { Bookmark entry ; entry . title = child -> data ( Qt :: DisplayRole ) . toString ( ) ; entry . url = child -> data ( Qt :: UserRole + 10 ) . toString ( ) ; if ( entry . url == QLatin1String ( " Folder " ) ) { writeStartElement ( QLatin1String ( " folder " ) ) ; entry . folded = ! child -> data ( Qt :: UserRole + 11 ) . toBool ( ) ; writeAttribute ( QLatin1String ( " folded " ) , entry . folded ? QLatin1String ( " yes " ) : QLatin1String ( " no " ) ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; for ( int i = 0 ; i < child -> rowCount ( ) ; ++ i ) writeData ( child -> child ( i ) ) ; writeEndElement ( ) ; } else { writeStartElement ( QLatin1String ( " bookmark " ) ) ; writeAttribute ( QLatin1String ( " href " ) , entry . url ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; writeEndElement ( ) ; } } XbelReader :: XbelReader ( BookmarkModel * tree , BookmarkModel * list ) : QXmlStream@@ Reader ( ) , treeModel ( tree ) , listModel ( list ) { bookmarkIcon = QIcon ( QLatin1String ( " : / help / images / bookmark . png " ) ) ; folderIcon = QApplication :: style ( ) -> standardIcon ( QStyle :: SP_Dir@@ ClosedIcon ) ; } bool XbelReader :: readFromFile ( QIODevice * device ) { setDevice ( device ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " xbel " ) && attributes ( ) . value ( QLatin1String ( " version " ) ) == QLatin1String ( "1.0" ) ) { readXBEL ( ) ; } else { raise@@ Error ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " The ▁ file ▁ is ▁ not ▁ an ▁ XBEL ▁ version ▁ 1.0 ▁ file . " ) ) ; } } } return ! error ( ) ; } void XbelReader :: readXBEL ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( 0 ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( 0 ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readUnknownElement ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) readUnknownElement ( ) ; } } void XbelReader :: readFolder ( QStandardItem * item ) { QStandardItem * folder = createChildItem ( item ) ; folder -> setIcon ( folderIcon ) ; folder -> setData ( QLatin1String ( " Folder " ) , Qt :: UserRole + 10 ) ; bool expanded = ( attributes ( ) . value ( QLatin1String ( " folded " ) ) != QLatin1String ( " no " ) ) ; folder -> setData ( expanded , Qt :: UserRole + 11 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) folder -> setText ( readElementText ( ) ) ; else if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( folder ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( folder ) ; else readUnknownElement ( ) ; } } } void XbelReader :: readBookmark ( QStandardItem * item ) { QStandardItem * bookmark = createChildItem ( item ) ; bookmark -> setIcon ( bookmarkIcon ) ; bookmark -> setText ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " Unknown ▁ title " ) ) ; bookmark -> setData ( attributes ( ) . value ( QLatin1String ( " href " ) ) . toString ( ) , Qt :: UserRole + 10 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) bookmark -> setText ( readElementText ( ) ) ; else readUnknownElement ( ) ; } } listModel -> appendRow ( bookmark -> clone ( ) ) ; } QStandardItem * XbelReader :: createChildItem ( QStandardItem * item ) { QStandardItem * childItem = new QStandardItem ( ) ; childItem -> setEditable ( false ) ; if ( item ) item -> appendRow ( childItem ) ; else treeModel -> appendRow ( childItem ) ; return childItem ; } </DOCUMENT>
<DOCUMENT_ID="s@@ unbl@@ ithe@@ /qt-@@ ever@@ ywhere@@ -open@@ source-src@@ -4.7.@@ 1/tree/master/src/gui/@@ kernel/@@ qevent@@ dispatcher@@ _x11.cpp"> # include " qevent@@ dispatcher _ x11 _ p . h " # include " qapplication . h " # include " qx11@@ info _ x11 . h " # include " qt _ x11 _ p . h " # include < private / qevent@@ dispatcher_unix@@ _p . h > QT_BEGIN_NAMESPACE class QEventDispatcherX11Private : public QEventDispatcherUNIX@@ Private { Q_DECLARE_@@ PUBLIC ( QEventDispatcherX11 ) public : inline QEventDispatcherX11Private ( ) : xfd ( - 1 ) { } int xfd ; QList < XEvent > queuedUserInputEvents ; } ; QEventDispatcherX11 :: QEventDispatcherX11 ( QObject * parent ) : QEventDispatcherUNIX ( * new QEventDispatcherX11Private , parent ) { } QEventDispatcherX11 :: ~ QEventDispatcherX11 ( ) { } bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEvents@@ Flags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNext@@ Request ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { event = d -> queuedUserInputEvents . take@@ First ( ) ; } else if ( XEventsQueued ( X11 -> display , Queued@@ Already ) ) { XNext@@ Event ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case Leave@@ Notify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTO@@ COLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_@@ FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _Q@@ T_SC@@ ROLL_@@ DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { break ; } if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11@@ ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: Exclude@@ Socket@@ Notifiers | QEventLoop :: X11@@ Exclude@@ Timers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; } bool QEventDispatcherX11 :: hasPending@@ Events ( ) { extern uint qGlobalPostedEventsCount ( ) ; return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; } void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; } void QEventDispatcherX11 :: starting@@ Up ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnection@@ Number ( X11 -> display ) ; } void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; } int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; } QT_END_NAMESPACE </DOCUMENT>
<DOCUMENT_ID="shadow@@ ofre@@ ality/@@ ShadowCore/tree/master/src/server/game/@@ Handlers/@@ Misc@@ Handler.cpp"> # include " Common . h " # include " Language . h " # include " Database@@ Env . h " # include " WorldPacket . h " # include " Opcodes . h " # include " Log . h " # include " Player . h " # include " GameTime . h " # include " GossipDef . h " # include " World . h " # include " ObjectMgr . h " # include " GuildMgr . h " # include " WorldSession . h " # include " Chat . h " # include " zlib . h " # include " ObjectAccessor . h " # include " Object . h " # include " Battleground . h " # include " OutdoorPvP . h " # include " AccountMgr . h " # include " DBC@@ Enums . h " # include " ScriptMgr . h " # include " MapManager . h " # include " GameObjectAI . h " # include " Group . h " # include " Spell . h " # include " BattlegroundMgr . h " # include " Battlefield . h " # include " BattlefieldMgr . h " # include " WhoList@@ Storage . h " void WorldSession :: HandleRepopRequestOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ REPO@@ P _ REQUEST ▁ Message " ) ; recvData . read_skip < uint8 > ( ) ; if ( GetPlayer ( ) -> IsAlive ( ) || GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; if ( GetPlayer ( ) -> HasAura@@ Type ( SPELL_AURA_@@ PR@@ EVENT_RESUR@@ RECTION ) ) return ; if ( GetPlayer ( ) -> getDe@@ athState ( ) == JU@@ ST_DIED ) { TC_LOG_DEBUG ( " network " , " HandleRepopRequestOpcode : ▁ got ▁ request ▁ after ▁ player ▁ % s ( % d ) ▁ was ▁ kil@@ led ▁ and ▁ before ▁ he ▁ was ▁ updated " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; GetPlayer ( ) -> Kill@@ Player ( ) ; } GetPlayer ( ) -> RemoveGho@@ ul ( ) ; GetPlayer ( ) -> RemovePet ( NULL , PET_SAVE_@@ NOT_IN_S@@ LOT , true ) ; GetPlayer ( ) -> BuildPlayerRepop ( ) ; GetPlayer ( ) -> RepopAtGraveyard ( ) ; } void WorldSession :: HandleGossipSelectOptionOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ GOSSIP _ SELECT _ OPTION " ) ; uint32 gossipListId ; uint32 menuId ; ObjectGuid guid ; std :: string code = " " ; recvData >> guid >> menuId >> gossipListId ; if ( ! _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetItem ( gossipListId ) ) { recvData . rfinish ( ) ; return ; } if ( _player -> PlayerTalkClass -> IsGossip@@ OptionCoded ( gossipListId ) ) recvData >> code ; if ( _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetSender@@ GUID ( ) != guid ) return ; Creature * unit = NULL ; GameObject * go = NULL ; if ( guid . IsCreature@@ OrVehicle ( ) ) { unit = GetPlayer ( ) -> GetNP@@ CIfCanInteractWith ( guid , UNIT_NPC_FLAG_GOSSIP ) ; if ( ! unit ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ him . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else if ( guid . IsGameObject ( ) ) { go = _player -> GetGameObject@@ IfCanInteractWith ( guid ) ; if ( ! go ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ it . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ unsupported ▁ % s . " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( GetPlayer ( ) -> HasUnitState ( UNIT_STATE_DIED ) ) GetPlayer ( ) -> RemoveAurasByType ( SPELL_AUR@@ A_FEIGN_DEATH ) ; if ( ( unit && unit -> GetScriptId ( ) != unit -> LastUsedScriptID ) || ( go && go -> GetScriptId ( ) != go -> LastUsedScriptID ) ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ Script ▁ reloaded ▁ while ▁ in ▁ use , ▁ ignoring ▁ and ▁ set ▁ new ▁ sci@@ pt ▁ id " ) ; if ( unit ) unit -> LastUsedScriptID = unit -> GetScriptId ( ) ; if ( go ) go -> LastUsedScriptID = go -> GetScriptId ( ) ; _player -> PlayerTalkClass -> SendCloseGossip ( ) ; return ; } if ( ! code . empty ( ) ) { if ( unit ) { unit -> AI ( ) -> sGossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } else { if ( unit ) { unit -> AI ( ) -> sGossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } } void WorldSession :: HandleWho@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ WHO ▁ Message " ) ; uint32 matchCount = 0 ; uint32 levelMin , levelMax , racemask , classmask , zonesCount , strCount ; uint32 zoneids [ 10 ] ; std :: string packetPlayerName , packetGuildName ; recvData >> levelMin ; recvData >> levelMax ; recvData >> packetPlayerName ; recvData >> packetGuildName ; recvData >> racemask ; recvData >> classmask ; recvData >> zonesCount ; if ( zonesCount > 10 ) return ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { uint32 temp ; recvData >> temp ; zoneids [ i ] = temp ; TC_LOG_DEBUG ( " network " , " Zone ▁ % u : ▁ % u " , i , zoneids [ i ] ) ; } recvData >> strCount ; if ( strCount > 4 ) return ; TC_LOG_DEBUG ( " network " , " Minlvl ▁ % u , ▁ maxlvl ▁ % u , ▁ name ▁ % s , ▁ guild ▁ % s , ▁ racemask ▁ % u , ▁ classmask ▁ % u , ▁ zones ▁ % u , ▁ strings ▁ % u " , levelMin , levelMax , packetPlayerName . c_str ( ) , packetGuildName . c_str ( ) , racemask , classmask , zonesCount , strCount ) ; std :: wstring str [ 4 ] ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { std :: string temp ; recvData >> temp ; if ( ! Utf8toWStr ( temp , str [ i ] ) ) continue ; wstrToLower ( str [ i ] ) ; TC_LOG_DEBUG ( " network " , " String ▁ % u : ▁ % s " , i , temp . c_str ( ) ) ; } std :: wstring wpacketPlayerName ; std :: wstring wpacketGuildName ; if ( ! ( Utf8toWStr ( packetPlayerName , wpacketPlayerName ) && Utf8toWStr ( packetGuildName , wpacketGuildName ) ) ) return ; wstrToLower ( wpacketPlayerName ) ; wstrToLower ( wpacketGuildName ) ; if ( levelMax >= MAX_LEVEL ) levelMax = STRON@@ G_MAX_LEVEL ; uint32 team = _player -> GetTeam ( ) ; uint32 gmLevelInWhoList = sWorld -> getIntConfig ( CONFIG_GM_@@ LEVEL_IN_WHO_LIST ) ; uint32 displayCount = 0 ; WorldPacket data ( SMSG_WHO , 500 ) ; data << uint32 ( matchCount ) ; data << uint32 ( displayCount ) ; WhoList@@ InfoVector const & whoList = sWhoList@@ Storage@@ Mgr -> GetWhoList ( ) ; for ( WhoList@@ PlayerInfo const & target : whoList ) { if ( target . GetTeam ( ) != team && ! HasPermission ( rbac :: RBAC_PERM_@@ TWO_S@@ IDE_@@ WHO_LIST ) ) continue ; if ( ! HasPermission ( rbac :: RBAC_PERM_@@ WHO@@ _SEE_AL@@ L_SEC_LEV@@ ELS ) && target . GetSecurity ( ) > AccountTypes ( gmLevelInWhoList ) ) continue ; if ( _player -> GetGUID ( ) != target . GetGuid ( ) && ! target . IsVisible ( ) ) if ( AccountMgr :: IsPlayer@@ Account ( _player -> GetSession ( ) -> GetSecurity ( ) ) || target . GetSecurity ( ) > _player -> GetSession ( ) -> GetSecurity ( ) ) continue ; uint8 lvl = target . GetLevel ( ) ; if ( lvl < levelMin || lvl > levelMax ) continue ; uint8 class_ = target . GetClass ( ) ; if ( ! ( classmask & ( 1 << class_ ) ) ) continue ; uint32 race = target . GetRace ( ) ; if ( ! ( racemask & ( 1 << race ) ) ) continue ; uint32 playerZoneId = target . GetZoneId ( ) ; uint8 gender = target . GetGen@@ der ( ) ; bool showZones = true ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { if ( zoneids [ i ] == playerZoneId ) { showZones = true ; break ; } showZones = false ; } if ( ! showZones ) continue ; std :: wstring const & wideplayername = target . GetWide@@ PlayerName ( ) ; if ( ! ( wpacketPlayerName . empty ( ) || wideplayername . find ( wpacketPlayerName ) != std :: wstring :: npos ) ) continue ; std :: wstring const & wideguildname = target . GetWide@@ GuildName ( ) ; if ( ! ( wpacketGuildName . empty ( ) || wideguildname . find ( wpacketGuildName ) != std :: wstring :: npos ) ) continue ; std :: string aname ; if ( AreaTableEntry const * areaEntry = sAreaTableStore . LookupEntry ( playerZoneId ) ) aname = areaEntry -> area_name [ GetSessionDbcLocale ( ) ] ; bool s_show = true ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { if ( ! str [ i ] . empty ( ) ) { if ( wideguildname . find ( str [ i ] ) != std :: wstring :: npos || wideplayername . find ( str [ i ] ) != std :: wstring :: npos || Utf8@@ Fit@@ To ( aname , str [ i ] ) ) { s_show = true ; break ; } s_show = false ; } } if ( ! s_show ) continue ; if ( ( matchCount ++ ) >= sWorld -> getIntConfig ( CONFIG_MAX_WHO ) ) continue ; data << target . GetPlayerName ( ) ; data << target . GetGuildName ( ) ; data << uint32 ( lvl ) ; data << uint32 ( class_ ) ; data << uint32 ( race ) ; data << uint8 ( gender ) ; data << uint32 ( playerZoneId ) ; ++ displayCount ; } data . put ( 0 , displayCount ) ; data . put ( 4 , matchCount ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Send ▁ SMSG _ WHO ▁ Message " ) ; } void WorldSession :: HandleLogout@@ RequestOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ REQUEST ▁ Message , ▁ security ▁ - ▁ % u " , GetSecurity ( ) ) ; if ( ObjectGuid lguid = GetPlayer ( ) -> GetLoot@@ GUID ( ) ) DoLoot@@ Release ( lguid ) ; bool instantLogout = ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) && ! GetPlayer ( ) -> IsInCombat ( ) ) || GetPlayer ( ) -> IsInFlight ( ) || HasPermission ( rbac :: RBAC_PERM_@@ INSTANT_@@ LOGOUT ) ; bool canLogoutInCombat = GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) ; uint32 reason = 0 ; if ( GetPlayer ( ) -> IsInCombat ( ) && ! canLogoutInCombat ) reason = 1 ; else if ( GetPlayer ( ) -> m_movementInfo . HasMovement@@ Flag ( MOVEMENTFLAG_FAL@@ LING | MOVEMENTFLAG_FAL@@ LING_@@ FAR ) ) reason = 3 ; else if ( GetPlayer ( ) -> duel || GetPlayer ( ) -> HasAura ( 9454 ) ) reason = 2 ; WorldPacket data ( SMSG_LOGOUT_@@ RESPONSE , 1 + 4 ) ; data << uint32 ( reason ) ; data << uint8 ( instantLogout ) ; SendPacket ( & data ) ; if ( reason ) { LogoutRequest ( 0 ) ; return ; } if ( instantLogout ) { LogoutPlayer ( true ) ; return ; } if ( GetPlayer ( ) -> CanFreeMove ( ) ) { if ( GetPlayer ( ) -> GetStandState ( ) == UNIT_STAND_STATE_STAND ) GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_@@ SIT ) ; WorldPacket data ( SMSG_FORCE_MOVE_@@ ROOT , ( 8 + 4 ) ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << ( uint32 ) 2 ; SendPacket ( & data ) ; GetPlayer ( ) -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } LogoutRequest ( time ( NULL ) ) ; } void WorldSession :: HandlePlayer@@ LogoutOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ PLAYER _ LOGOUT ▁ Message " ) ; } void WorldSession :: HandleLogout@@ Cancel@@ Opcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ CANCEL ▁ Message " ) ; if ( ! GetPlayer ( ) ) return ; LogoutRequest ( 0 ) ; WorldPacket data ( SMSG_LOGOUT_@@ CANCEL_@@ ACK , 0 ) ; SendPacket ( & data ) ; if ( GetPlayer ( ) -> CanFreeMove ( ) ) { data . Initialize ( SMSG_FORCE_MOVE_@@ UNROOT , 8 ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_STAND ) ; GetPlayer ( ) -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } } void WorldSession :: HandleToggle@@ PvP ( WorldPacket & recvData ) { if ( recvData . size ( ) == 1 ) { bool newPvPStatus ; recvData >> newPvPStatus ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP , newPvPStatus ) ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER , ! newPvPStatus ) ; } else { GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ; GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER ) ; } if ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ) { if ( ! GetPlayer ( ) -> IsPvP ( ) || GetPlayer ( ) -> pvpInfo . EndTimer ) GetPlayer ( ) -> UpdatePvP ( true , true ) ; } else { if ( ! GetPlayer ( ) -> pvpInfo . IsHost@@ ile && GetPlayer ( ) -> IsPvP ( ) ) GetPlayer ( ) -> pvpInfo . EndTimer = time ( NULL ) ; } } void WorldSession :: HandleZone@@ UpdateOpcode ( WorldPacket & recvData ) { uint32 newZone ; recvData >> newZone ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ ZONE _ UPDATE : ▁ % u " , newZone ) ; GetPlayer ( ) -> SetNeeds@@ ZoneUpdate ( true ) ; } void WorldSession :: HandleSetSelectionOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; _player -> SetSelection ( guid ) ; } void WorldSession :: HandleStand@@ StateChange@@ Opcode ( WorldPacket & recvData ) { uint32 animstate ; recvData >> animstate ; _player -> SetStandState ( animstate ) ; } void WorldSession :: HandleBugOpcode ( WorldPacket & recvData ) { uint32 suggestion , contentlen , typelen ; std :: string content , type ; recvData >> suggestion >> contentlen >> content ; recvData >> typelen >> type ; if ( suggestion == 0 ) TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Bug ▁ Report ] " ) ; else TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Suggest@@ ion ] " ) ; TC_LOG_DEBUG ( " network " , " % s " , type . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " % s " , content . c_str ( ) ) ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_@@ BUG_REPORT ) ; stmt -> setString ( 0 , type ) ; stmt -> setString ( 1 , content ) ; CharacterDatabase . Execute ( stmt ) ; } void WorldSession :: HandleRe@@ claim@@ Corpse@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RECLA@@ IM _ CORPSE " ) ; ObjectGuid guid ; recvData >> guid ; if ( _player -> IsAlive ( ) ) return ; if ( _player -> InAr@@ ena ( ) ) return ; if ( ! _player -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; Corpse * corpse = _player -> GetCorpse ( ) ; if ( ! corpse ) return ; if ( time_t ( corpse -> GetGhost@@ Time ( ) + _player -> GetCorpse@@ Reclaim@@ Delay ( corpse -> GetType ( ) == CORPSE_RESUR@@ RECT@@ ABLE_PVP ) ) > time_t ( time ( NULL ) ) ) return ; if ( ! corpse -> IsWithinDistInMap ( _player , CORPSE_RECLA@@ IM_@@ RADIUS , true ) ) return ; _player -> ResurrectPlayer ( _player -> InBattleground ( ) ? 1.0f : 0.5f ) ; _player -> SpawnCorpseBones ( ) ; } void WorldSession :: HandleResurrect@@ ResponseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RESUR@@ RECT _ RESPONSE " ) ; ObjectGuid guid ; uint8 status ; recvData >> guid ; recvData >> status ; if ( GetPlayer ( ) -> IsAlive ( ) ) return ; if ( status == 0 ) { GetPlayer ( ) -> ClearResurrect@@ RequestData ( ) ; return ; } if ( ! GetPlayer ( ) -> IsResurrect@@ RequestedBy ( guid ) ) return ; GetPlayer ( ) -> ResurrectUsingRequestData ( ) ; } void WorldSession :: SendAreaTrigger@@ Message ( const char * Text , ... ) { va_list ap ; char szStr [ 1024 ] ; szStr [ 0 ] = ' \0' ; va_start ( ap , Text ) ; vsnprintf ( szStr , 1024 , Text , ap ) ; va_end ( ap ) ; uint32 length = strlen ( szStr ) + 1 ; WorldPacket data ( SMSG_AREA_@@ TRIGGER_@@ MESSAGE , 4 + length ) ; data << length ; data << szStr ; SendPacket ( & data ) ; } void WorldSession :: HandleAreaTriggerOpcode ( WorldPacket & recvData ) { uint32 triggerId ; recvData >> triggerId ; TC_LOG_DEBUG ( " network " , " CMSG _ AREATRIG@@ GER . ▁ Trigger ▁ ID : ▁ % u " , triggerId ) ; Player * player = GetPlayer ( ) ; if ( player -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } AreaTriggerEntry const * atEntry = sAreaTrigger@@ Store . LookupEntry ( triggerId ) ; if ( ! atEntry ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ send ▁ unknown ▁ ( by ▁ DBC ) ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( ! player -> IsInAreaTriggerRadius ( atEntry ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ too ▁ far , ▁ ignore ▁ Area ▁ Trigger ▁ ID : ▁ % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( player -> isDebug@@ AreaTriggers ) ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( LANG_DEBUG_@@ AREATRIG@@ GER_REACHED , triggerId ) ; if ( sScriptMgr -> OnAreaTrigger ( player , atEntry ) ) return ; if ( player -> IsAlive ( ) ) if ( uint32 questId = sObjectMgr -> GetQuest@@ ForAreaTrigger ( triggerId ) ) if ( player -> GetQuestStatus ( questId ) == QUEST_STATUS_INCOMPLETE ) player -> AreaExplored@@ OrEventHappens ( questId ) ; if ( sObjectMgr -> IsTa@@ vernAreaTrigger ( triggerId ) ) { player -> SetRestFlag ( REST_@@ FLAG_IN_TAVERN , atEntry -> id ) ; if ( sWorld -> IsFFAP@@ vP@@ Realm ( ) ) player -> RemoveByteFlag ( UNIT_FIELD_@@ BYTES_@@ 2 , UNIT_BYTES_@@ 2_OFFSET_@@ PVP_FLA@@ G , UNIT_BY@@ TE2_FLAG_@@ FFA_@@ PVP ) ; return ; } if ( Battleground * bg = player -> GetBattleground ( ) ) if ( bg -> GetStatus ( ) == STATUS_IN_PROGRESS ) bg -> HandleAreaTrigger ( player , triggerId ) ; if ( OutdoorPvP * pvp = player -> GetOutdoorPvP ( ) ) if ( pvp -> HandleAreaTrigger ( _player , triggerId ) ) return ; AreaTrigger const * at = sObjectMgr -> GetAreaTrigger ( triggerId ) ; if ( ! at ) return ; bool teleported = false ; if ( player -> GetMapId ( ) != at -> target_mapId ) { if ( Map :: EnterState denyReason = sMap@@ Mgr -> PlayerCannot@@ Enter ( at -> target_mapId , player , false ) ) { bool reviveAtTrigger = false ; switch ( denyReason ) { case Map :: CANNOT_ENTER_NO_ENTRY : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ map ▁ with ▁ id ▁ % d ▁ which ▁ has ▁ no ▁ entry " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_UNINSTANC@@ ED_DUNGEON : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ dunge@@ on ▁ map ▁ % d ▁ but ▁ no ▁ instance ▁ template ▁ was ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_DIFFICULTY_@@ UNAVAILABLE : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ instance ▁ map ▁ % d ▁ but ▁ the ▁ requested ▁ difficulty ▁ was ▁ not ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) player -> SendTransferAborted ( entry -> MapID , TRANSFER_ABORT_@@ DIFFICULTY , player -> GetDifficulty ( entry -> IsRaid ( ) ) ) ; break ; case Map :: CANNOT_ENTER_NOT_IN_RAID : { WorldPacket data ( SMSG_RAID_@@ GROUP_ONLY , 4 + 4 ) ; data << uint32 ( 0 ) ; data << uint32 ( 2 ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ must ▁ be ▁ in ▁ a ▁ raid ▁ group ▁ to ▁ enter ▁ instance ▁ map ▁ % d " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; } case Map :: CANNOT_ENTER_CORPSE_@@ IN_DIFFERENT_@@ INSTANCE : { WorldPacket data ( SMSG_CORPSE_@@ NOT_IN_INSTANCE ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ does ▁ not ▁ have ▁ a ▁ corpse ▁ in ▁ instance ▁ map ▁ % d ▁ and ▁ cannot ▁ enter " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; } case Map :: CANNOT_ENTER_INSTANCE_BIND_MISMATCH : if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) { char const * mapName = entry -> name [ player -> GetSession ( ) -> GetSessionDbcLocale ( ) ] ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ ' % s ' ▁ because ▁ their ▁ perman@@ ent ▁ bind ▁ is ▁ incomp@@ atible ▁ with ▁ their ▁ group ' s " , player -> GetName ( ) . c_str ( ) , mapName ) ; ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( player -> GetSession ( ) -> GetTrinityString ( LANG_INSTANCE_BIND_MISMATCH ) , mapName ) ; } reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_TOO_MANY_INSTANCES : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_@@ TOO_MANY_INSTANCES ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ % d ▁ because ▁ he ▁ has ▁ exceeded ▁ the ▁ maximum ▁ number ▁ of ▁ instances ▁ per ▁ hour . " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_MAX_PLAYERS : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_@@ MAX_PLAYERS ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_ZONE_IN_COMBAT : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_@@ ZONE_IN_COMBAT ) ; reviveAtTrigger = true ; break ; default : break ; } if ( reviveAtTrigger ) if ( ! player -> IsAlive ( ) && player -> HasCor@@ pse ( ) ) if ( player -> GetCorpse@@ Location ( ) . GetMapId ( ) == at -> target_mapId ) { player -> ResurrectPlayer ( 0.5f ) ; player -> SpawnCorpseBones ( ) ; } return ; } if ( Group * group = player -> GetGroup ( ) ) if ( group -> isLF@@ GGroup ( ) && player -> GetMap ( ) -> IsDungeon ( ) ) teleported = player -> Teleport@@ ToBG@@ EntryPoint ( ) ; } if ( ! teleported ) player -> TeleportTo ( at -> target_mapId , at -> target_X , at -> target_Y , at -> target_Z , at -> target_Orientation , TEL@@ E_TO_@@ NOT_LEAVE_@@ TRANSPORT ) ; } void WorldSession :: HandleUpdate@@ AccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ UPDATE _ ACCOUNT _ DATA " ) ; uint32 type , timestamp , decompressedSize ; recvData >> type >> timestamp >> decompressedSize ; TC_LOG_DEBUG ( " network " , " UAD : ▁ type ▁ % u , ▁ time ▁ % u , ▁ decompressedSize ▁ % u " , type , timestamp , decompressedSize ) ; if ( type > NUM_ACCOUNT_DATA_TYPES ) return ; if ( decompressedSize == 0 ) { SetAccountData ( AccountDataType ( type ) , 0 , " " ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; return ; } if ( decompressedSize > 0xFFFF ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Account ▁ data ▁ packet ▁ too ▁ big , ▁ size ▁ % u " , decompressedSize ) ; return ; } ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + recvData . rpos ( ) , recvData . size ( ) - recvData . rpos ( ) ) != Z_OK ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Failed ▁ to ▁ decompress ▁ account ▁ data " ) ; return ; } recvData . rfinish ( ) ; std :: string adata ; dest >> adata ; SetAccountData ( AccountDataType ( type ) , timestamp , adata ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; } void WorldSession :: HandleRequest@@ AccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ REQUEST _ ACCOUNT _ DATA " ) ; uint32 type ; recvData >> type ; TC_LOG_DEBUG ( " network " , " RAD : ▁ type ▁ % u " , type ) ; if ( type >= NUM_ACCOUNT_DATA_TYPES ) return ; AccountData * adata = GetAccountData ( AccountDataType ( type ) ) ; uint32 size = adata -> Data . size ( ) ; uLongf destSize = compressBound ( size ) ; ByteBuffer dest ; dest . resize ( destSize ) ; if ( size && compress ( dest . contents ( ) , & destSize , ( uint8 const * ) adata -> Data . c_str ( ) , size ) != Z_OK ) { TC_LOG_DEBUG ( " network " , " RAD : ▁ Failed ▁ to ▁ compress ▁ account ▁ data " ) ; return ; } dest . resize ( destSize ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_@@ DATA , 8 + 4 + 4 + 4 + destSize ) ; data << uint64 ( _player ? _player -> GetGUID ( ) : ObjectGuid :: Empty ) ; data << uint32 ( type ) ; data << uint32 ( adata -> Time ) ; data << uint32 ( size ) ; data . append ( dest ) ; SendPacket ( & data ) ; } void WorldSession :: HandleSetAction@@ ButtonOpcode ( WorldPacket & recvData ) { uint8 button ; uint32 packetData ; recvData >> button >> packetData ; TC_LOG_DEBUG ( " network " , " CMSG _ SET _ ACTION _ BUTTON ▁ Button : ▁ % u ▁ Data : ▁ % u " , button , packetData ) ; if ( ! packetData ) GetPlayer ( ) -> removeActionButton ( button ) ; else GetPlayer ( ) -> addActionButton ( button , ACTION_BUTTON_@@ ACTION ( packetData ) , ACTION_BUTTON_@@ TYPE ( packetData ) ) ; } void WorldSession :: HandleComplete@@ Cinematic ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> EndCinematic ( ) ; } void WorldSession :: HandleNext@@ Cinematic@@ Camera ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> BeginCinematic ( ) ; } void WorldSession :: HandleMove@@ TimeSkipp@@ edOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ MOVE _ TIME _ SKIPPED " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; } void WorldSession :: HandleFe@@ ather@@ Fall@@ Ack ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ FEATHER _ FALL _ ACK " ) ; recvData . rfinish ( ) ; } void WorldSession :: HandleMove@@ UnRootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; } void WorldSession :: HandleMove@@ RootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; } void WorldSession :: HandleSetActionBarToggles ( WorldPacket & recvData ) { uint8 actionBar ; recvData >> actionBar ; if ( ! GetPlayer ( ) ) { if ( actionBar != 0 ) TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetActionBarToggles ▁ in ▁ not ▁ logg@@ ed ▁ state ▁ with ▁ value : ▁ % u , ▁ ignored " , uint32 ( actionBar ) ) ; return ; } GetPlayer ( ) -> SetByte@@ Value ( PLAYER_FIELD_@@ BYTES , PLAYER_FIELD_@@ BYTES_@@ OFFSET_@@ ACTION_BAR_@@ TOGG@@ LES , actionBar ) ; } void WorldSession :: HandlePlayedTime ( WorldPacket & recvData ) { uint8 unk1 ; recvData >> unk1 ; WorldPacket data ( SMSG_PLAYED_TIME , 4 + 4 + 1 ) ; data << uint32 ( _player -> GetTotal@@ PlayedTime ( ) ) ; data << uint32 ( _player -> GetLevel@@ PlayedTime ( ) ) ; data << uint8 ( unk1 ) ; SendPacket ( & data ) ; } void WorldSession :: HandleInspect@@ Opcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ INSPECT " ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " CMSG _ INSPECT : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; uint32 talent_points = 0x47 ; uint32 guid_size = player -> GetPackGUID ( ) . size ( ) ; WorldPacket data ( SMSG_INSPECT_@@ TALENT , guid_size + 4 + talent_points ) ; data << player -> GetPackGUID ( ) ; if ( GetPlayer ( ) -> CanBeGameMaster ( ) || sWorld -> getIntConfig ( CONFIG_TAL@@ ENTS_@@ INSPECTING ) + ( GetPlayer ( ) -> GetTeamId ( ) == player -> GetTeamId ( ) ) > 1 ) player -> BuildPlayer@@ TalentsInfoData ( & data ) ; else { data << uint32 ( 0 ) ; data << uint8 ( 0 ) ; data << uint8 ( 0 ) ; } player -> BuildEnchan@@ tment@@ sInfoData ( & data ) ; SendPacket ( & data ) ; } void WorldSession :: HandleInspect@@ HonorStatsOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " MSG _ INSPECT _ HON@@ OR _ STATS : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; WorldPacket data ( MSG_INSPECT_@@ HONOR@@ _STATS , 8 + 1 + 4 * 4 ) ; data << uint64 ( player -> GetGUID ( ) ) ; data << uint8 ( player -> GetHonor@@ Points ( ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ KILLS ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ TODAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ YES@@ TERDAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ LIFE@@ TIME_@@ HONORABLE_@@ KILLS ) ) ; SendPacket ( & data ) ; } void WorldSession :: HandleWorld@@ Teleport@@ Opcode ( WorldPacket & recvData ) { uint32 time ; uint32 mapid ; float PositionX ; float PositionY ; float PositionZ ; float Orientation ; recvData >> time ; recvData >> mapid ; recvData >> PositionX ; recvData >> PositionY ; recvData >> PositionZ ; recvData >> Orientation ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ WORLD _ TELEPORT " ) ; if ( GetPlayer ( ) -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ worldport ▁ command . " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; return ; } TC_LOG_DEBUG ( " network " , " CMSG _ WORLD _ TELEPORT : ▁ Player ▁ = ▁ % s , ▁ Time ▁ = ▁ % u , ▁ map ▁ = ▁ % u , ▁ x ▁ = ▁ % f , ▁ y ▁ = ▁ % f , ▁ z ▁ = ▁ % f , ▁ o ▁ = ▁ % f " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , time , mapid , PositionX , PositionY , PositionZ , Orientation ) ; if ( HasPermission ( rbac :: RBAC_PERM_OPCODE_@@ WORLD_@@ TELEPORT ) ) GetPlayer ( ) -> TeleportTo ( mapid , PositionX , PositionY , PositionZ , Orientation ) ; else SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; } void WorldSession :: HandleWho@@ isOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " Received ▁ opcode ▁ CMSG _ WHOIS " ) ; std :: string charname ; recvData >> charname ; if ( ! HasPermission ( rbac :: RBAC_PERM_OPCODE_@@ WHOIS ) ) { SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; return ; } if ( charname . empty ( ) || ! normalizePlayerName ( charname ) ) { SendNotification ( LANG_NEED_@@ CHARACTER_NAME ) ; return ; } Player * player = ObjectAccessor :: FindConnected@@ PlayerByName ( charname ) ; if ( ! player ) { SendNotification ( LANG_PLAYER_@@ NOT_EXI@@ ST_OR_@@ OFFLINE , charname . c_str ( ) ) ; return ; } uint32 accid = player -> GetSession ( ) -> GetAccountId ( ) ; PreparedStatement * stmt = LoginDatabase . GetPreparedStatement ( LOGIN_SE@@ L_ACCOUNT_@@ WHOIS ) ; stmt -> setUInt32 ( 0 , accid ) ; PreparedQueryResult result = LoginDatabase . Query ( stmt ) ; if ( ! result ) { SendNotification ( LANG_ACCOUNT_@@ FOR_PLAYER_@@ NOT_FOUND , charname . c_str ( ) ) ; return ; } Field * fields = result -> Fetch ( ) ; std :: string acc = fields [ 0 ] . GetString ( ) ; if ( acc . empty ( ) ) acc = " Unknown " ; std :: string email = fields [ 1 ] . GetString ( ) ; if ( email . empty ( ) ) email = " Unknown " ; std :: string lastip = fields [ 2 ] . GetString ( ) ; if ( lastip . empty ( ) ) lastip = " Unknown " ; std :: string msg = charname + " ' s ▁ " + " account ▁ is ▁ " + acc + " , ▁ e - mail : ▁ " + email + " , ▁ last ▁ ip : ▁ " + lastip ; WorldPacket data ( SMSG_WHOIS , msg . size ( ) + 1 ) ; data << msg ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " Received ▁ whois ▁ command ▁ from ▁ player ▁ % s ▁ for ▁ character ▁ % s " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , charname . c_str ( ) ) ; } void WorldSession :: HandleCompla@@ inOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ COMPLA@@ IN " ) ; uint8 spam_type ; ObjectGuid spammer_guid ; uint32 unk1 = 0 ; uint32 unk2 = 0 ; uint32 unk3 = 0 ; uint32 unk4 = 0 ; std :: string description = " " ; recvData >> spam_type ; recvData >> spammer_guid ; switch ( spam_type ) { case 0 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; break ; case 1 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; recvData >> unk4 ; recvData >> description ; break ; } WorldPacket data ( SMSG_COMPLA@@ IN_RESULT , 1 ) ; data << uint8 ( 0 ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " REPORT ▁ SPAM : ▁ type ▁ % u , ▁ % s , ▁ unk1 ▁ % u , ▁ unk2 ▁ % u , ▁ unk3 ▁ % u , ▁ unk4 ▁ % u , ▁ message ▁ % s " , spam_type , spammer_guid . ToString ( ) . c_str ( ) , unk1 , unk2 , unk3 , unk4 , description . c_str ( ) ) ; } void WorldSession :: HandleReal@@ mSplit@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ REAL@@ M _ SPLIT " ) ; uint32 unk ; std :: string split_date = "01/@@ 01/@@ 01" ; recvData >> unk ; WorldPacket data ( SMSG_REAL@@ M_SP@@ LIT , 4 + 4 + split_date . size ( ) + 1 ) ; data << unk ; data << uint32 ( 0x00000000 ) ; data << split_date ; SendPacket ( & data ) ; } void WorldSession :: HandleFarS@@ ightOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ FAR _ SIGHT " ) ; bool apply ; recvData >> apply ; if ( apply ) { TC_LOG_DEBUG ( " network " , " Added ▁ FarS@@ ight ▁ % s ▁ to ▁ player ▁ % u " , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; if ( WorldObject * target = _player -> GetView@@ point ( ) ) _player -> SetSeer ( target ) ; else TC_LOG_DEBUG ( " network " , " Player ▁ % s ▁ ( % s ) ▁ requests ▁ non - existing ▁ seer ▁ % s " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) ) ; } else { TC_LOG_DEBUG ( " network " , " Player ▁ % u ▁ set ▁ vision ▁ to ▁ self " , _player -> GetGUID ( ) . GetCounter ( ) ) ; _player -> SetSeer ( _player ) ; } GetPlayer ( ) -> UpdateVisibility@@ ForPlayer ( ) ; } void WorldSession :: HandleSetTitle@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ SET _ TITLE " ) ; int32 title ; recvData >> title ; if ( title > 0 && title < MAX_TIT@@ LE_INDEX ) { if ( ! GetPlayer ( ) -> HasTitle ( title ) ) return ; } else title = 0 ; GetPlayer ( ) -> SetUInt32Value ( PLAYER_@@ CHOS@@ EN_TITLE , title ) ; } void WorldSession :: HandleTimeSync@@ Resp ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ TIME _ SYNC _ RESP " ) ; uint32 counter , clientTicks ; recvData >> counter >> clientTicks ; if ( counter != _player -> m_timeSync@@ Counter - 1 ) TC_LOG_DEBUG ( " network " , " Wron@@ g ▁ time ▁ sync ▁ counter ▁ from ▁ player ▁ % s ▁ ( cheat@@ er ? ) " , _player -> GetName ( ) . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " Time ▁ sync ▁ received : ▁ counter ▁ % u , ▁ client ▁ ticks ▁ % u , ▁ time ▁ since ▁ last ▁ sync ▁ % u " , counter , clientTicks , clientTicks - _player -> m_timeSyncClient ) ; uint32 ourTicks = clientTicks + ( GameTime :: GetGame@@ TimeMS ( ) - _player -> m_timeSync@@ Server ) ; TC_LOG_DEBUG ( " network " , " Our ▁ ticks : ▁ % u , ▁ diff ▁ % u , ▁ latency ▁ % u " , ourTicks , ourTicks - clientTicks , GetLatency ( ) ) ; _player -> m_timeSyncClient = clientTicks ; } void WorldSession :: HandleResetInstan@@ cesOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ RESET _ INSTANCES " ) ; if ( Group * group = _player -> GetGroup ( ) ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) group -> ResetInstances ( INSTANCE_RESET_ALL , false , _player ) ; } else _player -> ResetInstances ( INSTANCE_RESET_ALL , false ) ; } void WorldSession :: HandleSetDungeonDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ DUNGEON _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_DUNGEON_@@ DIFFICULTY ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } if ( Difficulty ( mode ) == _player -> GetDungeonDifficulty ( ) ) return ; Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ player ▁ is ▁ inside ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsNon@@ RaidDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ group ▁ member ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ is ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) , groupGuy -> GetName ( ) . c_str ( ) , groupGuy -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false , _player ) ; group -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false ) ; _player -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } void WorldSession :: HandleSetRaidDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ RAID _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_RAID_@@ DIFFICULTY ) { TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( Difficulty ( mode ) == _player -> GetRaidDifficulty ( ) ) return ; Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsRaid ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true , _player ) ; group -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true ) ; _player -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } void WorldSession :: HandleCancel@@ Mount@@ AuraOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ CANCEL _ MOUN@@ T _ AURA " ) ; if ( ! _player -> IsMounted ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_CHAR_@@ NON_@@ MOUNTED ) ; return ; } if ( _player -> IsInFlight ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_YOU_@@ IN_F@@ LIGHT ) ; return ; } _player -> RemoveAurasByType ( SPELL_AURA_@@ MOUNTED ) ; } void WorldSession :: HandleMove@@ SetCan@@ Fly@@ AckOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ SET _ CAN _ FLY _ ACK " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; MovementInfo movementInfo ; movementInfo . guid = guid ; ReadMovementInfo ( recvData , & movementInfo ) ; recvData . read_skip < float > ( ) ; _player -> m_unit@@ MovedBy@@ Me -> m_movementInfo . flags = movementInfo . GetMovement@@ Flags ( ) ; } void WorldSession :: HandleRequest@@ Pet@@ InfoOpcode ( WorldPacket & ) { } void WorldSession :: HandleSetTax@@ iBenchmark@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ SET _ TAX@@ I _ BENCHMARK _ MODE " ) ; uint8 mode ; recvData >> mode ; mode ? _player -> SetFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) : _player -> RemoveFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) ; TC_LOG_DEBUG ( " network " , " Client ▁ used ▁ \ " / timete@@ st ▁ % d\ " ▁ command " , mode ) ; } void WorldSession :: HandleQuery@@ InspectAchievements ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; TC_LOG_DEBUG ( " network " , " CMSG _ QUERY _ INSPECT _ ACHIEVE@@ MENTS ▁ [ % s ] ▁ Insp@@ ected ▁ Player ▁ [ % s ] " , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , guid . ToString ( ) . c_str ( ) ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) return ; if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; player -> SendRespon@@ dInspectAchievements ( _player ) ; } void WorldSession :: HandleWorld@@ StateUI@@ Timer@@ Update ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ WORLD _ STATE _ UI _ TIMER _ UPDATE " ) ; WorldPacket data ( SMSG_WORLD@@ _STATE_UI_@@ TIMER_@@ UPDATE , 4 ) ; data << uint32 ( time ( NULL ) ) ; SendPacket ( & data ) ; } void WorldSession :: HandleRead@@ yFor@@ AccountDataTimes ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ READY _ FOR _ ACCOUNT _ DATA _ TIME@@ S " ) ; SendAccountDataTimes ( GLOBAL_@@ CACHE_@@ MASK ) ; } void WorldSession :: SendSetPhaseShift ( uint32 PhaseShift ) { WorldPacket data ( SMSG@@ _SET_PHASE_@@ SHIFT , 4 ) ; data << uint32 ( PhaseShift ) ; SendPacket ( & data ) ; } void WorldSession :: HandleAreaSpiritHealerQueryOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUERY " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) sBattlegroundMgr -> SendAreaSpiritHealerQueryOpcode ( _player , bg , guid ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> SendAreaSpiritHealerQueryOpcode ( _player , guid ) ; } void WorldSession :: HandleAreaSpiritHealer@@ QueueOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUEUE " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) bg -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; } void WorldSession :: HandleHearth@@ AndResur@@ rect ( WorldPacket & ) { if ( _player -> IsInFlight ( ) ) return ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) { bf -> PlayerAskTo@@ Leave ( _player ) ; return ; } AreaTableEntry const * atEntry = sAreaTableStore . LookupEntry ( _player -> GetArea@@ Id ( ) ) ; if ( ! atEntry || ! ( atEntry -> flags & AREA_FLAG_WINTERGRASP_@@ 2 ) ) return ; _player -> BuildPlayerRepop ( ) ; _player -> ResurrectPlayer ( 1.0f ) ; _player -> TeleportTo ( _player -> m_homebind@@ MapId , _player -> m_homebind@@ X , _player -> m_homebind@@ Y , _player -> m_homebind@@ Z , _player -> GetOrientation ( ) ) ; } void WorldSession :: HandleInstanceLockResponse ( WorldPacket & recvPacket ) { uint8 accept ; recvPacket >> accept ; if ( ! _player -> HasPendingBind ( ) ) { TC_LOG_INFO ( " network " , " InstanceLockResponse : ▁ Player ▁ % s ▁ ( guid ▁ % u ) ▁ tried ▁ to ▁ bind ▁ himself / teleport ▁ to ▁ graveyard ▁ without ▁ a ▁ pending ▁ bind ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( accept ) _player -> BindToInstance ( ) ; else _player -> RepopAtGraveyard ( ) ; _player -> SetPendingBind ( 0 , 0 ) ; } void WorldSession :: HandleUpdate@@ MissileTrajectory ( WorldPacket & recvPacket ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ UPDATE _ MISSI@@ LE _ TRA@@ JECTORY " ) ; ObjectGuid guid ; uint32 spellId ; float elevation , speed ; float curX , curY , curZ ; float targetX , targetY , targetZ ; uint8 moveStop ; recvPacket >> guid >> spellId >> elevation >> speed ; recvPacket >> curX >> curY >> curZ ; recvPacket >> targetX >> targetY >> targetZ ; recvPacket >> moveStop ; Unit * caster = ObjectAccessor :: GetUnit ( * _player , guid ) ; Spell * spell = caster ? caster -> GetCurrentSpell ( CURRENT_@@ GENERIC_SPELL ) : NULL ; if ( ! spell || spell -> m_spellInfo -> Id != spellId || ! spell -> m_targets . HasDst ( ) || ! spell -> m_targets . HasSrc ( ) ) { recvPacket . rfinish ( ) ; return ; } Position pos = * spell -> m_targets . GetSrc@@ Pos ( ) ; pos . Relocate ( curX , curY , curZ ) ; spell -> m_targets . ModSrc ( pos ) ; pos = * spell -> m_targets . GetDst@@ Pos ( ) ; pos . Relocate ( targetX , targetY , targetZ ) ; spell -> m_targets . ModDst ( pos ) ; spell -> m_targets . SetEle@@ vation ( elevation ) ; spell -> m_targets . SetSpeed ( speed ) ; if ( moveStop ) { uint32 opcode ; recvPacket >> opcode ; recvPacket . SetOpcode ( opcode ) ; HandleMovement@@ Opcodes ( recvPacket ) ; } } </DOCUMENT>
<DOCUMENT_ID="S@@ lava@@ Ra/coreclr/tree/master/src/@@ binder/variables.cpp"> # include " variables . hpp " # include " ex . h " namespace BINDER@@ _SPACE { # ifdef FEATURE_VERSIONING_LOG namespace { HRESULT CheckFileExistence ( LPC@@ WSTR pwzFile , LPDWORD pdwAttrib ) { HRESULT hr = S_FALSE ; DWORD dwRet = 0 ; _ASSER@@ TE ( pwzFile && pdwAttrib ) ; * pdwAttrib = 0 ; dwRet = Wsz@@ GetFile@@ Attributes ( pwzFile ) ; if ( dwRet == INVALID_FILE_@@ ATTRIBUTES ) { hr = HRESULT_FROM_@@ GetLast@@ Error ( ) ; if ( ( hr == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) ) || ( hr == HRESULT_FROM_WIN32 ( ERROR_PATH_@@ NOT_FOUND ) ) ) { GO_WITH_HRESULT ( S_FALSE ) ; } } else { * pdwAttrib = dwRet ; GO_WITH_HRESULT ( S_OK ) ; } Exit : return hr ; } } ; # endif Variables * g_Bind@@ erVariables = NULL ; Variables :: Variables ( ) { } Variables :: ~ Variables ( ) { } HRESULT Variables :: Init ( ) { HRESULT hr = S_OK ; EX_TRY { http@@ URLPrefix . SetLiteral ( W ( " http : // " ) ) ; architecture@@ MSIL . SetLiteral ( W ( " MSIL " ) ) ; architecture@@ X86 . SetLiteral ( W ( " x86" ) ) ; architecture@@ AMD@@ 64 . SetLiteral ( W ( " AMD@@ 64" ) ) ; architecture@@ ARM . SetLiteral ( W ( " ARM " ) ) ; architecture@@ ARM64 . SetLiteral ( W ( " ARM@@ 64" ) ) ; cult@@ ureNe@@ utral . SetLiteral ( W ( " neutral " ) ) ; mscorlib . SetLiteral ( W ( " mscorlib " ) ) ; emptyString . Clear ( ) ; # ifdef FEATURE_VERSIONING_LOG REGUTIL :: CORConfigLevel kCorConfigLevel = static_cast < REGUTIL :: CORConfigLevel > ( REGUTIL :: COR_@@ CONFIG_ENV | REGUTIL :: COR_@@ CONFIG_FU@@ SION ) ; DWORD dwLoggingNeeded = REGUTIL :: GetConfig@@ DWORD_@@ DontUse_ ( CLRConfig :: EXTERNAL_Force@@ Log , 0 , kCorConfigLevel , TRUE ) ; fLoggingNeeded = ( dwLoggingNeeded ? TRUE : FALSE ) ; NewArray@@ Holder < WCHAR > pwzLogDirectory = REGUTIL :: GetConfig@@ String_@@ DontUse_ ( CLRConfig :: INTERNAL_@@ LogPath , TRUE , kCorConfigLevel , FALSE ) ; if ( pwzLogDirectory == NULL ) { fLoggingNeeded = FALSE ; } else { DWORD dwAttr = 0 ; hr = CheckFileExistence ( pwzLogDirectory , & dwAttr ) ; if ( ( hr == S_OK ) && ( ( dwAttr & FILE_ATTRIBUTE_@@ DIRECTORY ) != 0 ) ) { logPath . Set ( pwzLogDirectory ) ; } else { hr = S_OK ; fLoggingNeeded = FALSE ; } } # endif } EX_CAT@@ CH_HRESULT ( hr ) ; return hr ; } } ; </DOCUMENT>
<DOCUMENT_ID="vic@@ tor@@ zh@@ ao/@@ miniblink49@@ /tree/master/third_party/@@ WebKit@@ /Source/core/@@ html/@@ HTMLContentElement.cpp"> # include " config . h " # include " core / ht@@ ml / HTMLContentElement . h " # include " core / HTMLNames . h " # include " core / css / SelectorChecker . h " # include " core / css / parser / CSSParser . h " # include " core / dom / QualifiedName . h " # include " core / dom / shadow / ElementShadow . h " # include " core / dom / shadow / ShadowRoot . h " # include " platform / RuntimeEnabledFeatures . h " namespace blink { using namespace HTMLNames ; PassRefPtrWillBeRawPtr < HTMLContentElement > HTMLContentElement :: create ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) { return adoptRefWillBe@@ Noop ( new HTMLContentElement ( document , filter ) ) ; } inline HTMLContentElement :: HTMLContentElement ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) : InsertionPoint ( contentTag , document ) , m_shouldParseSelect ( false ) , m_isValidSelector ( true ) , m_filter ( filter ) { } HTMLContentElement :: ~ HTMLContentElement ( ) { } DEFINE_TRACE ( HTMLContentElement ) { visitor -> trace ( m_filter ) ; InsertionPoint :: trace ( visitor ) ; } void HTMLContentElement :: parseSelect ( ) { ASSERT ( m_shouldParseSelect ) ; CSSParser :: parseSelector ( CSSParser@@ Context ( document ( ) , 0 ) , m_select , m_selectorList ) ; m_shouldParseSelect = false ; m_isValidSelector = validateSelect ( ) ; if ( ! m_isValidSelector ) { CSSSelectorList emptyList ; m_selectorList . adopt ( emptyList ) ; } } void HTMLContentElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == selectAttr ) { if ( ShadowRoot * root = containingShadowRoot ( ) ) root -> owner ( ) -> willAffectSelector ( ) ; m_shouldParseSelect = true ; m_select = value ; } else { InsertionPoint :: parseAttribute ( name , value ) ; } } static inline bool includesDisallowedPseudoClass ( const CSSSelector & selector ) { if ( selector . pseudoType ( ) == CSSSelector :: PseudoNot ) { const CSSSelector * subSelector = selector . selectorList ( ) -> first ( ) ; return subSelector -> match ( ) == CSSSelector :: PseudoClass ; } return selector . match ( ) == CSSSelector :: PseudoClass ; } bool HTMLContentElement :: validateSelect ( ) const { ASSERT ( ! m_shouldParseSelect ) ; if ( m_select . isNull ( ) || m_select . isEmpty ( ) ) return true ; if ( ! m_selectorList . isValid ( ) ) return false ; for ( const CSSSelector * selector = m_selectorList . first ( ) ; selector ; selector = m_selectorList . next ( * selector ) ) { if ( ! selector -> isComp@@ ound ( ) ) return false ; for ( const CSSSelector * subSelector = selector ; subSelector ; subSelector = subSelector -> tagHistory ( ) ) { if ( includesDisallowedPseudoClass ( * subSelector ) ) return false ; } } return true ; } bool HTMLContentElement :: matchSelector ( Element & element ) const { SelectorChecker selectorChecker ( SelectorChecker :: QueryingRules ) ; SelectorChecker :: SelectorCheck@@ ingContext context ( & element , SelectorChecker :: Visited@@ Match@@ Disabled ) ; for ( const CSSSelector * selector = selectorList ( ) . first ( ) ; selector ; selector = CSSSelectorList :: next ( * selector ) ) { context . selector = selector ; if ( selectorChecker . match ( context ) ) return true ; } return false ; } } </DOCUMENT>
<DOCUMENT_ID="native@@ -m/@@ sl@@ math@@ /tree/master/source/@@ intersect_@@ util.cpp"> # include < sl@@ m / intersect_@@ util . h > SLMATH_@@ BEGIN ( ) intersectLineBox_Line :: intersectLineBox_Line ( const vec3 & origin , const vec3 & direction ) : o ( origin ) , d ( direction ) , inv_d ( fabsf ( direction . x ) > FLT_MIN ? 1 . f / direction . x : FLT_MAX , fabsf ( direction . y ) > FLT_MIN ? 1 . f / direction . y : FLT_MAX , fabsf ( direction . z ) > FLT_MIN ? 1 . f / direction . z : FLT_MAX ) , signx ( direction . x < 0 . f ) , signy ( direction . y < 0 . f ) , signz ( direction . z < 0 . f ) { } bool intersectLineTri ( const vec3 & o , const vec3 & d , const vec3 & v0 , const vec3 & v1 , const vec3 & v2 , float * t ) { const vec3 e1 = v1 - v0 ; const vec3 e2 = v2 - v0 ; const vec3 pvec = cross ( d , e2 ) ; const float det = dot ( e1 , pvec ) ; if ( fabsf ( det ) <= FLT_MIN ) return false ; const float invdet = 1 . f / det ; const vec3 tvec = o - v0 ; const float u = dot ( tvec , pvec ) * invdet ; if ( 0 . f > u || 1 . f < u ) return false ; const vec3 qvec = cross ( tvec , e1 ) ; const float v = dot ( d , qvec ) * invdet ; if ( 0 . f > v || 1 . f < u + v ) return false ; const float s = dot ( e2 , qvec ) * invdet ; if ( s < 0 . f || s >= 1 . f ) return false ; if ( t ) * t = s ; assert ( s >= 0 . f && s <= 1 . f ) ; return true ; } bool intersectLineBox ( const intersectLineBox_Line & r , const vec3 * boxminmax ) { const float t0 = 0.0f ; const float t1 = 1.0f ; const int * const sign = & r . signx ; regi@@ ster float tmin , tmax , tymin , tymax , tzmin , tzmax ; tmin = ( boxminmax [ sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tmax = ( boxminmax [ 1 - sign [ 0 ] ] . x - r . o . x ) * r . inv_d . x ; tymin = ( boxminmax [ sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; tymax = ( boxminmax [ 1 - sign [ 1 ] ] . y - r . o . y ) * r . inv_d . y ; if ( ( tmin > tymax ) || ( tymin > tmax ) ) return false ; if ( tymin > tmin ) tmin = tymin ; if ( tymax < tmax ) tmax = tymax ; tzmin = ( boxminmax [ sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; tzmax = ( boxminmax [ 1 - sign [ 2 ] ] . z - r . o . z ) * r . inv_d . z ; if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false ; if ( tzmin > tmin ) tmin = tzmin ; if ( tzmax < tmax ) tmax = tzmax ; return ( ( tmin < t1 ) && ( tmax > t0 ) ) ; } bool intersectLineBox ( const vec3 & o , const vec3 & d , const vec3 & boxmin , const vec3 & boxmax ) { intersectLineBox_Line line ( o , d ) ; const vec3 boxminmax [ 2 ] = { boxmin , boxmax } ; return intersectLineBox ( line , boxminmax ) ; } SLMATH_@@ END ( ) </DOCUMENT>
<DOCUMENT_ID="K@@ oncept@@ Gee@@ k/moses@@ decoder@@ /tree/master/mer@@ t/@@ TER/infosHash@@ er.cpp"> # include " infosHasher . h " using namespace std ; using namespace TERCPPNS_@@ Tools ; namespace TERCPPNS_@@ HashMap@@ Space { infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; } long infosHasher :: getHash@@ Key ( ) { return m_hashKey ; } string infosHasher :: getKey ( ) { return m_key ; } vector < int > infosHasher :: getValue ( ) { return m_value ; } void infosHasher :: setValue ( vector < int > value ) { m_value = value ; } string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vector@@ ToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; } } </DOCUMENT>
<DOCUMENT_ID="z@@ eli@@ ard/aws-sdk-cpp/tree/master/aws-cpp-sdk-@@ iam@@ /source/model/@@ ListGroups@@ Request.cpp"> # include < aws / iam / model / ListGroupsRequest . h > # include < aws / core / utils / StringUtils . h > # include < aws / core / utils / memory / stl / AWSStringStream . h > using namespace Aws :: IAM :: Model ; using namespace Aws :: Utils ; ListGroupsRequest :: ListGroupsRequest ( ) : m_pathPrefixHasBeenSet ( false ) , m_markerHasBeenSet ( false ) , m_maxItems ( 0 ) , m_maxItemsHasBeenSet ( false ) { } Aws :: String ListGroupsRequest :: Serialize@@ Pay@@ load ( ) const { Aws :: StringStream ss ; ss << " Action = ListGroups & " ; if ( m_pathPrefixHasBeenSet ) { ss << " PathPrefix = " << StringUtils :: URLEncode ( m_pathPrefix . c_str ( ) ) << " & " ; } if ( m_markerHasBeenSet ) { ss << " Marker = " << StringUtils :: URLEncode ( m_marker . c_str ( ) ) << " & " ; } if ( m_maxItemsHasBeenSet ) { ss << " MaxItems = " << m_maxItems << " & " ; } ss << " Version = 2010@@ -05@@ -08@@ " ; return ss . str ( ) ; } </DOCUMENT>
<DOCUMENT_ID="o@@ mazap@@ a/root-@@ old/tree/master/interpreter/llvm/src/@@ lib/CodeGen@@ /MachineSSA@@ Updater.cpp"> # include " llvm / CodeGen / MachineSSAUpdater . h " # include " llvm / ADT / DenseMap . h " # include " llvm / ADT / SmallVector . h " # include " llvm / CodeGen / MachineInstr . h " # include " llvm / CodeGen / MachineInstrBuilder . h " # include " llvm / CodeGen / MachineRegisterInfo . h " # include " llvm / Support / AlignOf . h " # include " llvm / Support / Allocator . h " # include " llvm / Support / Debug . h " # include " llvm / Support / ErrorHandling . h " # include " llvm / Support / raw _ ostream . h " # include " llvm / Target / TargetInstrInfo . h " # include " llvm / Target / TargetRegisterInfo . h " # include " llvm / Target / TargetSubtarget@@ Info . h " # include " llvm / Transforms / Utils / SSAUpdaterImpl . h " using namespace llvm ; # define DEBUG_TYPE " machine - ssa@@ updater " typedef DenseMap < MachineBasicBlock * , unsigned > AvailableValsTy ; static AvailableValsTy & getAvailableVals ( void * AV ) { return * static_cast < AvailableValsTy * > ( AV ) ; } MachineSSAUpdater :: MachineSSAUpdater ( MachineFunction & MF , SmallVectorImpl < MachineInstr * > * NewPHI ) : AV ( nullptr ) , InsertedPHIs ( NewPHI ) { TII = MF . getSub@@ target ( ) . getIn@@ strInfo ( ) ; MRI = & MF . getReg@@ Info ( ) ; } MachineSSAUpdater :: ~ MachineSSAUpdater ( ) { delete static_cast < AvailableValsTy * > ( AV ) ; } void MachineSSAUpdater :: Initialize ( unsigned V ) { if ( ! AV ) AV = new AvailableValsTy ( ) ; else getAvailableVals ( AV ) . clear ( ) ; VR = V ; VRC = MRI -> getReg@@ Class ( VR ) ; } bool MachineSSAUpdater :: HasValueForBlock ( MachineBasicBlock * BB ) const { return getAvailableVals ( AV ) . count ( BB ) ; } void MachineSSAUpdater :: AddAvailable@@ Value ( MachineBasicBlock * BB , unsigned V ) { getAvailableVals ( AV ) [ BB ] = V ; } unsigned MachineSSAUpdater :: GetValueAtEnd@@ OfBlock ( MachineBasicBlock * BB ) { return GetValueAtEndOfBlockInternal ( BB ) ; } static unsigned LookForIdenticalPHI ( MachineBasicBlock * BB , SmallVectorImpl < std :: pair < MachineBasicBlock * , unsigned > > & PredValues ) { if ( BB -> empty ( ) ) return 0 ; MachineBasicBlock :: iterator I = BB -> begin ( ) ; if ( ! I -> isPHI ( ) ) return 0 ; AvailableValsTy AVals ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) AVals [ PredValues [ i ] . first ] = PredValues [ i ] . second ; while ( I != BB -> end ( ) && I -> isPHI ( ) ) { bool Same = true ; for ( unsigned i = 1 , e = I -> getNumOperands ( ) ; i != e ; i += 2 ) { unsigned SrcReg = I -> getOperand ( i ) . getReg ( ) ; MachineBasicBlock * SrcBB = I -> getOperand ( i + 1 ) . getMBB ( ) ; if ( AVals [ SrcBB ] != SrcReg ) { Same = false ; break ; } } if ( Same ) return I -> getOperand ( 0 ) . getReg ( ) ; ++ I ; } return 0 ; } static MachineInstrBuilder InsertNewDef ( unsigned Opcode , MachineBasicBlock * BB , MachineBasicBlock :: iterator I , const TargetRegisterClass * RC , MachineRegisterInfo * MRI , const TargetInstrInfo * TII ) { unsigned NewVR = MRI -> createVirtual@@ Register ( RC ) ; return BuildMI ( * BB , I , DebugLoc ( ) , TII -> get ( Opcode ) , NewVR ) ; } unsigned MachineSSAUpdater :: GetValueInMiddleOfBlock ( MachineBasicBlock * BB ) { if ( ! HasValueForBlock ( BB ) ) return GetValueAtEndOfBlockInternal ( BB ) ; if ( BB -> pred_empty ( ) ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , VRC , MRI , TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } SmallVector < std :: pair < MachineBasicBlock * , unsigned > , 8 > PredValues ; unsigned SingularValue = 0 ; bool isFirstPred = true ; for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) { MachineBasicBlock * PredBB = * PI ; unsigned PredVal = GetValueAtEndOfBlockInternal ( PredBB ) ; PredValues . push_back ( std :: make_pair ( PredBB , PredVal ) ) ; if ( isFirstPred ) { SingularValue = PredVal ; isFirstPred = false ; } else if ( PredVal != SingularValue ) SingularValue = 0 ; } if ( SingularValue != 0 ) return SingularValue ; unsigned DupPHI = LookForIdenticalPHI ( BB , PredValues ) ; if ( DupPHI ) return DupPHI ; MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstrBuilder InsertedPHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , VRC , MRI , TII ) ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) InsertedPHI . addReg ( PredValues [ i ] . second ) . addMBB ( PredValues [ i ] . first ) ; if ( unsigned ConstVal = InsertedPHI -> isConstant@@ ValuePHI ( ) ) { InsertedPHI -> eraseFromParent ( ) ; return ConstVal ; } if ( InsertedPHIs ) InsertedPHIs -> push_back ( InsertedPHI ) ; DEBUG ( dbgs ( ) << " ▁ ▁ Inserted ▁ PHI : ▁ " << * InsertedPHI << " \n " ) ; return InsertedPHI -> getOperand ( 0 ) . getReg ( ) ; } static MachineBasicBlock * findCorrespondingPred ( const MachineInstr * MI , MachineOperand * U ) { for ( unsigned i = 1 , e = MI -> getNumOperands ( ) ; i != e ; i += 2 ) { if ( & MI -> getOperand ( i ) == U ) return MI -> getOperand ( i + 1 ) . getMBB ( ) ; } llvm_un@@ reachable ( " MachineOperand : : getParent ( ) ▁ fail@@ ure ? " ) ; } void MachineSSAUpdater :: Rewrite@@ Use ( MachineOperand & U ) { MachineInstr * UseMI = U . getParent ( ) ; unsigned NewVR = 0 ; if ( UseMI -> isPHI ( ) ) { MachineBasicBlock * SourceBB = findCorrespondingPred ( UseMI , & U ) ; NewVR = GetValueAtEndOfBlockInternal ( SourceBB ) ; } else { NewVR = GetValueInMiddleOfBlock ( UseMI -> getParent ( ) ) ; } U . setReg ( NewVR ) ; } namespace llvm { template < > class SSAUpdater@@ Traits < MachineSSAUpdater > { public : typedef MachineBasicBlock BlkT ; typedef unsigned ValT ; typedef MachineInstr PhiT ; typedef MachineBasicBlock :: succ_@@ iterator BlkSucc_iterator ; static BlkSucc_iterator BlkSucc_@@ begin ( BlkT * BB ) { return BB -> succ_@@ begin ( ) ; } static BlkSucc_iterator BlkSucc_@@ end ( BlkT * BB ) { return BB -> succ_@@ end ( ) ; } class PHI_iterator { private : MachineInstr * PHI ; unsigned idx ; public : explicit PHI_iterator ( MachineInstr * P ) : PHI ( P ) , idx ( 1 ) { } PHI_iterator ( MachineInstr * P , bool ) : PHI ( P ) , idx ( PHI -> getNumOperands ( ) ) { } PHI_iterator & operator ++ ( ) { idx += 2 ; return * this ; } bool operator == ( const PHI_iterator & x ) const { return idx == x . idx ; } bool operator != ( const PHI_iterator & x ) const { return ! operator == ( x ) ; } unsigned getIncoming@@ Value ( ) { return PHI -> getOperand ( idx ) . getReg ( ) ; } MachineBasicBlock * getIncoming@@ Block ( ) { return PHI -> getOperand ( idx + 1 ) . getMBB ( ) ; } } ; static inline PHI_iterator PHI_@@ begin ( PhiT * PHI ) { return PHI_iterator ( PHI ) ; } static inline PHI_iterator PHI_@@ end ( PhiT * PHI ) { return PHI_iterator ( PHI , true ) ; } static void FindPredecess@@ orBlocks ( MachineBasicBlock * BB , SmallVectorImpl < MachineBasicBlock * > * Preds ) { for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) Preds -> push_back ( * PI ) ; } static unsigned GetUn@@ defVal ( MachineBasicBlock * BB , MachineSSAUpdater * Updater ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } static unsigned CreateEmpty@@ PHI ( MachineBasicBlock * BB , unsigned NumPreds , MachineSSAUpdater * Updater ) { MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstr * PHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , Updater -> VRC , Updater -> MRI , Updater -> TII ) ; return PHI -> getOperand ( 0 ) . getReg ( ) ; } static void AddPHI@@ Operand ( MachineInstr * PHI , unsigned Val , MachineBasicBlock * Pred ) { MachineInstrBuilder ( * Pred -> getParent ( ) , PHI ) . addReg ( Val ) . addMBB ( Pred ) ; } static MachineInstr * InstrIsPHI ( MachineInstr * I ) { if ( I && I -> isPHI ( ) ) return I ; return nullptr ; } static MachineInstr * ValueIsPHI ( unsigned Val , MachineSSAUpdater * Updater ) { return InstrIsPHI ( Updater -> MRI -> getVReg@@ Def ( Val ) ) ; } static MachineInstr * ValueIsNewPHI ( unsigned Val , MachineSSAUpdater * Updater ) { MachineInstr * PHI = ValueIsPHI ( Val , Updater ) ; if ( PHI && PHI -> getNumOperands ( ) <= 1 ) return PHI ; return nullptr ; } static unsigned GetPHI@@ Value ( MachineInstr * PHI ) { return PHI -> getOperand ( 0 ) . getReg ( ) ; } } ; } unsigned MachineSSAUpdater :: GetValueAtEndOfBlockInternal ( MachineBasicBlock * BB ) { AvailableValsTy & AvailableVals = getAvailableVals ( AV ) ; if ( unsigned V = AvailableVals [ BB ] ) return V ; SSAUpdaterImpl < MachineSSAUpdater > Impl ( this , & AvailableVals , InsertedPHIs ) ; return Impl . GetValue ( BB ) ; } </DOCUMENT>
