Scenario_Document1 :: Scenario_Document1 ( ) { InitializeComponent ( ) ; }
void Scenario_Document1 :: Pag@@ e_Loaded ( Platform :: Object ^ sender , Windows :: UI :: Xaml :: Route@@ dEvent@@ Args ^ e ) { this -> FontFamily = ref new Windows :: UI :: Xaml :: Media :: FontFamily ( " Neue ▁ Haas ▁ Grotesk ▁ Text ▁ Pro " ) ; }
void Accumulator :: addOperand ( const intr@@ usive_@@ ptr < Expression > & pExpression ) { uassert ( 15943 , str :: stream ( ) << " group ▁ accumulator ▁ " << getOpName ( ) << " ▁ only ▁ accepts ▁ one ▁ operand " , vpOperand . size ( ) < 1 ) ; ExpressionNary :: addOperand ( pExpression ) ; }
ViewProviderTrajectory :: ~ ViewProviderTrajectory ( ) { pcTrajectoryRoot -> unref ( ) ; pcCoords -> unref ( ) ; pcDrawStyle -> unref ( ) ; pcLines -> unref ( ) ; }
void ViewProviderTrajectory :: attach ( App :: DocumentObject * pcObj ) { ViewProviderDocumentObject :: attach ( pcObj ) ; SoSeparator * linesep = new SoSeparator ; SoBaseColor * basecol = new SoBaseColor ; basecol -> rgb . setValue ( 1.0f , 0.5f , 0.0f ) ; linesep -> addChild ( basecol ) ; linesep -> addChild ( pcCoords ) ; linesep -> addChild ( pcLines ) ; SoBaseColor * markcol = new SoBaseColor ; markcol -> rgb . setValue ( 1.0f , 1.0f , 0.0f ) ; SoMarkerSet * marker = new SoMarkerSet ; marker -> marker@@ Index = SoMarkerSet :: CROSS_@@ 5_@@ 5 ; linesep -> addChild ( markcol ) ; linesep -> addChild ( marker ) ; pcTrajectoryRoot -> addChild ( linesep ) ; addDisplay@@ MaskMode ( pcTrajectoryRoot , " Waypoints " ) ; pcTrajectoryRoot -> objectName = pcObj -> getName@@ InDocument ( ) ; pcTrajectoryRoot -> documentName = pcObj -> getDocument ( ) -> getName ( ) ; pcTrajectoryRoot -> subElementName = " Main " ; }
void ViewProviderTrajectory :: setDisplayMode ( const char * ModeName ) { if ( strcmp ( " Waypoints " , ModeName ) == 0 ) setDisplay@@ MaskMode ( " Waypoints " ) ; ViewProviderGeometryObject :: setDisplayMode ( ModeName ) ; }
void ViewProviderTrajectory :: updateData ( const App :: Property * prop ) { Robot :: TrajectoryObject * pcTracObj = static_cast < Robot :: TrajectoryObject * > ( pcObject ) ; if ( prop == & pcTracObj -> Trajectory ) { const Trajectory & trak = pcTracObj -> Trajectory . getValue ( ) ; pcCoords -> point . deleteValues ( 0 ) ; pcCoords -> point . setNum ( trak . getSize ( ) ) ; for ( unsigned int i = 0 ; i < trak . getSize ( ) ; ++ i ) { Base :: Vector3d pos = trak . getWa@@ ypoint ( i ) . EndPos . getPosition ( ) ; pcCoords -> point . set1Value ( i , pos . x , pos . y , pos . z ) ; } pcLines -> numVertices . set1Value ( 0 , trak . getSize ( ) ) ; } else if ( prop == & pcTracObj -> Base ) { Base :: Placement loc = * ( & pcTracObj -> Base . getValue ( ) ) ; } }
Cylinder * TrashHolder :: __query@@ Destination ( int32_t & , const Thing * , Item * * , uint32_t & ) { return this ; }
void TrashHolder :: __addThing ( Thing * thing ) { return __addThing ( 0 , thing ) ; }
void TrashHolder :: __addThing ( int32_t , Thing * thing ) { Item * item = thing -> getItem ( ) ; if ( ! item ) { return ; } if ( item == this || ! item -> hasProperty ( CONST_PROP_MOVEABLE ) ) { return ; } if ( item -> isHangable ( ) && isGround@@ Tile ( ) ) { Tile * tile = dynamic_cast < Tile * > ( getParent ( ) ) ; if ( tile && tile -> hasFlag ( TILESTATE_SUPPORTS_@@ HANGABLE ) ) { return ; } } g_game . internal@@ RemoveItem ( item ) ; const ItemType & it = Item :: items [ getID ( ) ] ; if ( it . magicEffect != CONST_ME_NONE ) { g_game . addMagicEffect ( getPosition ( ) , it . magicEffect ) ; } }
void TrashHolder :: postAddNotification ( Thing * thing , const Cylinder * oldParent , int32_t index , cylinderlink_t ) { getParent ( ) -> postAddNotification ( thing , oldParent , index , LINK_PARENT ) ; }
void TrashHolder :: postRemoveNotification ( Thing * thing , const Cylinder * newParent , int32_t index , bool isCompleteRemoval , cylinderlink_t ) { getParent ( ) -> postRemoveNotification ( thing , newParent , index , isCompleteRemoval , LINK_PARENT ) ; }
inline SVGFontFaceUriElement :: SVGFontFaceUriElement ( Document & document ) : SVGElement ( fon@@ t_face_@@ uriTag , document ) { ScriptWrappable :: init ( this ) ; }
void SVGFontFaceUriElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name . matches ( XLinkNames :: hrefAttr ) ) loadFont ( ) ; else SVGElement :: parseAttribute ( name , value ) ; }
void SVGFontFaceUriElement :: childrenChanged ( const Children@@ Change & change ) { SVGElement :: childrenChanged ( change ) ; if ( ! isSVGFontFace@@ SrcElement ( parentNode ( ) ) ) return ; ContainerNode * grandparent = parentNode ( ) -> parentNode ( ) ; if ( isSVGFontFaceElement ( grandparent ) ) toSVGFontFaceElement ( * grandparent ) . rebuild@@ FontFace ( ) ; }
Node :: InsertionNotificationRequest SVGFontFaceUriElement :: insertedInto ( ContainerNode * rootParent ) { loadFont ( ) ; return SVGElement :: insertedInto ( rootParent ) ; }
void SVGFontFaceUriElement :: loadFont ( ) { if ( m_resource ) m_resource -> removeClient ( this ) ; const AtomicString & href = getAttribute ( XLinkNames :: hrefAttr ) ; if ( ! href . isNull ( ) ) { ResourceFetcher * fetcher = document ( ) . fetcher ( ) ; FetchRequest request ( Resource@@ Request ( document ( ) . completeURL ( href ) ) , localName ( ) ) ; m_resource = fetcher -> fetch@@ Font ( request ) ; if ( m_resource ) { m_resource -> addClient ( this ) ; m_resource -> begin@@ LoadIf@@ Needed ( fetcher ) ; } } else { m_resource = 0 ; } }
Highlighter :: Highlighter ( Editor * text , Dictionary * dictionary ) : QSyntaxHighlighter ( text -> document ( ) ) , m_dictionary ( dictionary ) , m_text ( text ) , m_enabled ( true ) , m_misspelled ( " # ff0000" ) { connect ( m_text , SIGNAL ( cursorPositionChanged ( ) ) , this , SLOT ( cursorPositionChanged ( ) ) ) ; m_text -> viewport ( ) -> installEventFilter ( this ) ; m_add_action = new QAction ( tr ( " Add " ) , this ) ; m_check_action = new QAction ( tr ( " Check ▁ Spelling . . . " ) , this ) ; }
void Highlighter :: setEnabled ( bool enabled ) { m_enabled = enabled ; rehighlight ( ) ; }
void Highlighter :: setMis@@ spelledColor ( const QColor & color ) { m_misspelled = color ; rehighlight ( ) ; }
bool Highlighter :: eventFilter ( QObject * watched , QEvent * event ) { if ( watched != m_text -> viewport ( ) || event -> type ( ) != QEvent :: ContextMenu || ! m_enabled ) { return QSyntaxHighlighter :: eventFilter ( watched , event ) ; } else { QContextMenuEvent * context_event = static_cast < QContextMenuEvent * > ( event ) ; m_start_cursor = m_text -> cursorForPosition ( context_event -> pos ( ) ) ; QTextBlock block = m_start_cursor . block ( ) ; int cursor = m_start_cursor . position ( ) - block . position ( ) ; bool under_mouse = false ; QStringRef word ; QVector < QStringRef > words = static_cast < BlockStats * > ( block . userData ( ) ) -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta >= 0 && delta <= word . length ( ) ) { under_mouse = true ; break ; } } if ( ! under_mouse ) { return false ; } else { m_cursor = m_start_cursor ; m_cursor . setPosition ( word . position ( ) + block . position ( ) ) ; m_cursor . setPosition ( m_cursor . position ( ) + word . length ( ) , QTextCursor :: Keep@@ Anchor ) ; m_word = m_cursor . selectedText ( ) ; m_text -> setTextCursor ( m_cursor ) ; QMenu * menu = new QMenu ; QStringList guesses = m_dictionary -> suggestions ( m_word ) ; if ( ! guesses . isEmpty ( ) ) { foreach ( const QString & guess , guesses ) { menu -> addAction ( guess ) ; } } else { QAction * none_action = menu -> addAction ( tr ( " ( No ▁ suggestions ▁ found ) " ) ) ; none_action -> setEnabled ( false ) ; } menu -> addSeparator ( ) ; menu -> addAction ( m_add_action ) ; menu -> addSeparator ( ) ; menu -> addAction ( m_check_action ) ; connect ( menu , SIGNAL ( triggered ( QAction * ) ) , this , SLOT ( suggestion ( QAction * ) ) ) ; menu -> exec ( context_event -> globalPos ( ) ) ; delete menu ; return true ; } } }
void Highlighter :: highlightBlock ( const QString & text ) { QTextCharFormat hformat ; QTextBlockFormat blockformat = currentBlock ( ) . blockFormat ( ) ; if ( blockformat . hasProperty ( QTextFormat :: UserProperty ) ) { hformat . setProperty ( QTextFormat :: FontWeight , blockformat . property ( QTextFormat :: FontWeight ) ) ; hformat . setProperty ( QTextFormat :: FontItalic , blockformat . property ( QTextFormat :: FontItalic ) ) ; hformat . setProperty ( QTextFormat :: FontSizeAdjustment , blockformat . property ( QTextFormat :: FontSizeAdjustment ) ) ; setFormat ( 0 , text . length ( ) , hformat ) ; } if ( ! m_enabled ) { return ; } int cursor = m_text -> textCursor ( ) . position ( ) - currentBlock ( ) . position ( ) ; BlockStats * stats = static_cast < BlockStats * > ( currentBlockUserData ( ) ) ; if ( ! stats ) { stats = new BlockStats ( text , m_dictionary ) ; setCurrentBlockUserData ( stats ) ; } QTextCharFormat error ; error . setUnderline@@ Color ( m_misspelled ) ; error . setUnderline@@ Style ( QTextCharFormat :: SpellCheck@@ Under@@ line ) ; error . merge ( hformat ) ; QVector < QStringRef > words = stats -> misspelled ( ) ; for ( int i = 0 ; i < words . count ( ) ; ++ i ) { const QStringRef & word = words . at ( i ) ; int delta = cursor - word . position ( ) ; if ( delta < 0 || delta > word . length ( ) ) { setFormat ( word . position ( ) , word . length ( ) , error ) ; } } }
void Highlighter :: cursorPositionChanged ( ) { QTextBlock current = m_text -> textCursor ( ) . block ( ) ; if ( m_current != current ) { if ( m_current . isValid ( ) && m_text -> document ( ) -> blockCount ( ) > m_current . blockNumber ( ) ) { rehighlightBlock ( m_current ) ; } m_current = current ; } rehighlightBlock ( m_current ) ; }
void Highlighter :: suggestion ( QAction * action ) { if ( action == m_add_action ) { m_text -> setTextCursor ( m_start_cursor ) ; m_dictionary -> add ( m_word ) ; } else if ( action == m_check_action ) { m_text -> setTextCursor ( m_start_cursor ) ; SpellChecker :: checkDocument ( m_text ) ; } else { m_cursor . insertText ( action -> text ( ) ) ; } }
template < class T > void PointMovementGenerator < T > :: DoInitialize ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( id == EVENT_CHARGE_PREPATH ) return ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; }
template < class T > bool PointMovementGenerator < T > :: DoUpdate ( T * unit , uint32 ) { if ( ! unit ) return false ; if ( unit -> HasUnitState ( UNIT_STATE_ROOT | UNIT_STATE_STUNNED ) ) { unit -> ClearUnitState ( UNIT_STATE_ROAMING_MOVE ) ; return true ; } unit -> AddUnitState ( UNIT_STATE_ROAMING_MOVE ) ; if ( id != EVENT_CHARGE_PREPATH && i_recalculateSpeed && ! unit -> movespline -> Finalized ( ) ) { i_recalculateSpeed = false ; Movement :: MoveSplineInit init ( unit ) ; init . MoveTo ( i_x , i_y , i_z , m_generatePath ) ; if ( speed > 0.0f ) init . SetVelocity ( speed ) ; init . Launch ( ) ; } return ! unit -> movespline -> Finalized ( ) ; }
template < class T > void PointMovementGenerator < T > :: DoFinalize ( T * unit ) { if ( unit -> HasUnitState ( UNIT_STATE_CHAR@@ GING ) ) unit -> ClearUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; if ( unit -> movespline -> Finalized ( ) ) MovementInform ( unit ) ; }
template < class T > void PointMovementGenerator < T > :: DoReset ( T * unit ) { if ( ! unit -> IsStopped ( ) ) unit -> StopMoving ( ) ; unit -> AddUnitState ( UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE ) ; }
template < > void PointMovementGenerator < Creature > :: MovementInform ( Creature * unit ) { if ( unit -> AI ( ) ) unit -> AI ( ) -> MovementInform ( POINT_MOTION_TYPE , id ) ; }
void Assistance@@ MovementGenerator :: Finalize ( Unit * unit ) { unit -> ToCreature ( ) -> SetNo@@ CallAssistance ( false ) ; unit -> ToCreature ( ) -> CallAssistance ( ) ; if ( unit -> isAlive ( ) ) unit -> GetMotionMaster ( ) -> MoveSeek@@ Assistance@@ Distract ( sWorld -> getIntConfig ( CONFIG_CREATURE_@@ FAM@@ ILY_ASSI@@ STANCE_@@ DELAY ) ) ; }
bool EffectMovementGenerator :: Update ( Unit * unit , uint32 ) { return ! unit -> movespline -> Finalized ( ) ; }
void EffectMovementGenerator :: Finalize ( Unit * unit ) { if ( unit -> GetTypeId ( ) != TYPEID_UNIT ) return ; if ( unit -> isAlive ( ) && ! unit -> HasUnitState ( UNIT_STATE_CONFU@@ SED | UNIT_STATE_FLEE@@ ING ) ) { if ( Unit * victim = unit -> getVictim ( ) ) unit -> GetMotionMaster ( ) -> MoveChase ( victim ) ; else unit -> GetMotionMaster ( ) -> Initialize ( ) ; } if ( unit -> ToCreature ( ) -> AI ( ) ) unit -> ToCreature ( ) -> AI ( ) -> MovementInform ( EFFECT_MOTION_TYPE , m_Id ) ; }
void WorldSession :: HandleGMTicket@@ CreateOpcode ( WorldPacket & recvData ) { if ( sTicketMgr -> GetStatus ( ) == GMTICKET_QUEUE_STATUS_DISABLED ) return ; if ( GetPlayer ( ) -> getLevel ( ) < sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) { SendNotification ( GetTrinityString ( LANG_TICKET_@@ REQ ) , sWorld -> getIntConfig ( CONFIG_TICKET_LEVEL_REQ ) ) ; return ; } GMTicketResponse response = GMTICKET_RESPONSE_CREATE_@@ ERROR ; GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ; if ( ticket && ticket -> IsCompleted ( ) ) sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; ; if ( ! ticket || ticket -> IsClosed ( ) ) { ticket = new GmTicket ( GetPlayer ( ) , recvData ) ; uint32 count ; std :: list < uint32 > times ; uint32 decompressedSize ; std :: string chatLog ; recvData >> count ; for ( uint32 i = 0 ; i < count ; i ++ ) { uint32 time ; recvData >> time ; times . push_back ( time ) ; } recvData >> decompressedSize ; if ( count && decompressedSize && decompressedSize < 0xFFFF ) { uint32 pos = recvData . rpos ( ) ; ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + pos , recvData . size ( ) - pos ) == Z_OK ) { dest >> chatLog ; ticket -> SetChat@@ Log ( times , chatLog ) ; } else { TC_LOG_ERROR ( " network " , " CMSG _ GMTICKET _ CREATE ▁ possibly ▁ corrupt . ▁ Uncompression ▁ failed . " ) ; recvData . rfinish ( ) ; delete ticket ; return ; } recvData . rfinish ( ) ; } sTicketMgr -> AddTicket ( ticket ) ; sTicketMgr -> UpdateLast@@ Change ( ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKET@@ NEW , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_CREATE_@@ SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_@@ CREATE , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleGMTicket@@ UpdateOpcode ( WorldPacket & recvData ) { std :: string message ; recvData >> message ; GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_@@ ERROR ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { SQLTransaction trans = SQLTransaction ( NULL ) ; ticket -> SetMessage ( message ) ; ticket -> SaveToDB ( trans ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKET@@ UPDATED , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; response = GMTICKET_RESPONSE_UPDATE_@@ SUCCESS ; } WorldPacket data ( SMSG_GMTICKET_@@ UPDATETEXT , 4 ) ; data << uint32 ( response ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleGMTicket@@ DeleteOpcode ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { WorldPacket data ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data ) ; sWorld -> SendGMText ( LANG_COMMAND_TICKET@@ PLAYER@@ ABANDO@@ N , GetPlayer ( ) -> GetName ( ) . c_str ( ) , ticket -> GetId ( ) ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } }
void WorldSession :: HandleGMTicket@@ GetTicket@@ Opcode ( WorldPacket & ) { SendQuery@@ TimeResponse ( ) ; if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { if ( ticket -> IsCompleted ( ) ) ticket -> SendResponse ( this ) ; else sTicketMgr -> SendTicket ( this , ticket ) ; } else sTicketMgr -> SendTicket ( this , NULL ) ; }
void WorldSession :: HandleGMTicket@@ SystemStatus@@ Opcode ( WorldPacket & ) { WorldPacket data ( SMSG_GM@@ TICKET_SYSTEM@@ STATUS , 4 ) ; data << uint32 ( sTicketMgr -> GetStatus ( ) ? GMTICKET_QUEUE_STATUS_@@ ENABLED : GMTICKET_QUEUE_STATUS_DISABLED ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleGMS@@ urvey@@ Submit ( WorldPacket & recvData ) { uint32 nextSurveyID = sTicketMgr -> GetNextSurveyID ( ) ; uint32 mainSurvey ; recvData >> mainSurvey ; for ( uint8 i = 0 ; i < 15 ; i ++ ) { uint32 subSurveyId ; recvData >> subSurveyId ; if ( ! subSurveyId ) break ; uint8 rank ; recvData >> rank ; std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_@@ GM_SUBS@@ URVEY ) ; stmt -> setUInt32 ( 0 , nextSurveyID ) ; stmt -> setUInt32 ( 1 , subSurveyId ) ; stmt -> setUInt32 ( 2 , rank ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; } std :: string comment ; recvData >> comment ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_@@ GM_SURVEY ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt32 ( 1 , nextSurveyID ) ; stmt -> setUInt32 ( 2 , mainSurvey ) ; stmt -> setString ( 3 , comment ) ; CharacterDatabase . Execute ( stmt ) ; }
void WorldSession :: HandleRe@@ portLag ( WorldPacket & recvData ) { uint32 lagType , mapId ; recvData >> lagType ; recvData >> mapId ; float x , y , z ; recvData >> x ; recvData >> y ; recvData >> z ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_@@ LAG_REPORT ) ; stmt -> setUInt32 ( 0 , GUID_LOPART ( GetPlayer ( ) -> GetGUID ( ) ) ) ; stmt -> setUInt8 ( 1 , lagType ) ; stmt -> setUInt16 ( 2 , mapId ) ; stmt -> setFloat ( 3 , x ) ; stmt -> setFloat ( 4 , y ) ; stmt -> setFloat ( 5 , z ) ; stmt -> setUInt32 ( 6 , GetLatency ( ) ) ; stmt -> setUInt32 ( 7 , time ( NULL ) ) ; CharacterDatabase . Execute ( stmt ) ; }
void WorldSession :: HandleGM@@ ResponseResolve ( WorldPacket & ) { if ( GmTicket * ticket = sTicketMgr -> GetTicketByPlayer ( GetPlayer ( ) -> GetGUID ( ) ) ) { uint8 getSurvey = 0 ; if ( float ( rand_@@ chance ( ) ) < sWorld -> getFloat@@ Config ( CONFIG_CHANCE_@@ OF_GM_SURVEY ) ) getSurvey = 1 ; WorldPacket data ( SMSG_GM@@ RESPONSE_STATUS_UPDATE , 4 ) ; data << uint8 ( getSurvey ) ; SendPacket ( & data ) ; WorldPacket data2 ( SMSG_GMTICKET_DELETETICKET , 4 ) ; data2 << uint32 ( GMTICKET_RESPONSE_TICKET_DELETED ) ; SendPacket ( & data2 ) ; sTicketMgr -> CloseTicket ( ticket -> GetId ( ) , GetPlayer ( ) -> GetGUID ( ) ) ; sTicketMgr -> SendTicket ( this , NULL ) ; } }
FunctionHintProposalWidgetPrivate :: FunctionHintProposalWidgetPrivate ( ) : m_underlyingWidget ( 0 ) , m_assistant ( 0 ) , m_model ( 0 ) , m_popupFrame ( new Utils :: FakeToolTip ) , m_numberLabel ( new QLabel ) , m_hintLabel ( new QLabel ) , m_pager ( new QWidget ) , m_currentHint ( - 1 ) , m_totalHints ( 0 ) , m_currentArgument ( - 1 ) , m_escapePressed ( false ) { m_hintLabel -> setText@@ Format ( Qt :: Rich@@ Text ) ; }
FunctionHintProposalWidget :: FunctionHintProposalWidget ( ) : m_d ( new FunctionHintProposalWidgetPrivate ) { QToolButton * downArrow = new QToolButton ; downArrow -> setArrowType ( Qt :: Down@@ Arrow ) ; downArrow -> setFixedSize ( 16 , 16 ) ; downArrow -> setAutoRaise ( true ) ; QToolButton * upArrow = new QToolButton ; upArrow -> setArrowType ( Qt :: UpArrow ) ; upArrow -> setFixedSize ( 16 , 16 ) ; upArrow -> setAutoRaise ( true ) ; QHBoxLayout * pagerLayout = new QHBoxLayout ( m_d -> m_pager ) ; pagerLayout -> setMargin ( 0 ) ; pagerLayout -> setSpacing ( 0 ) ; pagerLayout -> addWidget ( upArrow ) ; pagerLayout -> addWidget ( m_d -> m_numberLabel ) ; pagerLayout -> addWidget ( downArrow ) ; QHBoxLayout * popupLayout = new QHBoxLayout ( m_d -> m_popupFrame ) ; popupLayout -> setMargin ( 0 ) ; popupLayout -> setSpacing ( 0 ) ; popupLayout -> addWidget ( m_d -> m_pager ) ; popupLayout -> addWidget ( m_d -> m_hintLabel ) ; connect ( upArrow , SIGNAL ( clicked ( ) ) , SLOT ( previousPage ( ) ) ) ; connect ( downArrow , SIGNAL ( clicked ( ) ) , SLOT ( nextPage ( ) ) ) ; qApp -> installEventFilter ( this ) ; setFocusPolicy ( Qt :: NoFocus ) ; }
FunctionHintProposalWidget :: ~ FunctionHintProposalWidget ( ) { delete m_d -> m_model ; }
void FunctionHintProposalWidget :: setAssistant ( CodeAssistant * assistant ) { m_d -> m_assistant = assistant ; }
void FunctionHintProposalWidget :: setReason ( Assist@@ Reason reason ) { Q_UNUSED ( reason ) ; }
void FunctionHintProposalWidget :: setUnder@@ lyingWidget ( const QWidget * underlyingWidget ) { m_d -> m_underlyingWidget = underlyingWidget ; }
void FunctionHintProposalWidget :: setModel ( IAssist@@ ProposalModel * model ) { m_d -> m_model = static_cast < IFunctionHintProposalModel * > ( model ) ; }
void FunctionHintProposalWidget :: setDisplay@@ Rect ( const QRect & rect ) { m_d -> m_displayRect = rect ; }
void FunctionHintProposalWidget :: showProposal ( const QString & prefix ) { m_d -> m_totalHints = m_d -> m_model -> size ( ) ; if ( m_d -> m_totalHints == 0 ) { abort ( ) ; return ; } m_d -> m_pager -> setVisible ( m_d -> m_totalHints > 1 ) ; m_d -> m_currentHint = 0 ; if ( ! updateAndCheck ( prefix ) ) { abort ( ) ; return ; } m_d -> m_popupFrame -> show ( ) ; }
void FunctionHintProposalWidget :: updateProposal ( const QString & prefix ) { updateAndCheck ( prefix ) ; }
void FunctionHintProposalWidget :: close@@ Proposal ( ) { abort ( ) ; }
void FunctionHintProposalWidget :: abort ( ) { if ( m_d -> m_popupFrame -> isVisible ( ) ) m_d -> m_popupFrame -> close ( ) ; deleteLater ( ) ; }
bool FunctionHintProposalWidget :: eventFilter ( QObject * obj , QEvent * e ) { switch ( e -> type ( ) ) { case QEvent :: ShortcutOverride : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_Escape ) { m_d -> m_escapePressed = true ; } break ; case QEvent :: KeyPress : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_Escape ) { m_d -> m_escapePressed = true ; } if ( m_d -> m_model -> size ( ) > 1 ) { QKeyEvent * ke = static_cast < QKeyEvent * > ( e ) ; if ( ke -> key ( ) == Qt :: Key_Up ) { previousPage ( ) ; return true ; } else if ( ke -> key ( ) == Qt :: Key_Down ) { nextPage ( ) ; return true ; } return false ; } break ; case QEvent :: KeyRelease : if ( static_cast < QKeyEvent * > ( e ) -> key ( ) == Qt :: Key_Escape && m_d -> m_escapePressed ) { abort ( ) ; return false ; } m_d -> m_assistant -> notify@@ Change ( ) ; break ; case QEvent :: WindowDeactivate : case QEvent :: FocusOut : if ( obj != m_d -> m_underlyingWidget ) { break ; } abort ( ) ; break ; case QEvent :: MouseButton@@ Press : case QEvent :: MouseButton@@ Release : case QEvent :: MouseButton@@ Dbl@@ Clic@@ k : case QEvent :: Wheel : { QWidget * widget = qobject_cast < QWidget * > ( obj ) ; if ( ! ( widget == this || isAn@@ cestorOf ( widget ) ) ) { abort ( ) ; } } break ; default : break ; } return false ; }
void FunctionHintProposalWidget :: nextPage ( ) { m_d -> m_currentHint = ( m_d -> m_currentHint + 1 ) % m_d -> m_totalHints ; updateContent ( ) ; }
void FunctionHintProposalWidget :: previousPage ( ) { if ( m_d -> m_currentHint == 0 ) m_d -> m_currentHint = m_d -> m_totalHints - 1 ; else -- m_d -> m_currentHint ; updateContent ( ) ; }
bool FunctionHintProposalWidget :: updateAndCheck ( const QString & prefix ) { const int activeArgument = m_d -> m_model -> activeArgument ( prefix ) ; if ( activeArgument == - 1 ) { abort ( ) ; return false ; } else if ( activeArgument != m_d -> m_currentArgument ) { m_d -> m_currentArgument = activeArgument ; updateContent ( ) ; } return true ; }
void FunctionHintProposalWidget :: updateContent ( ) { m_d -> m_hintLabel -> setText ( m_d -> m_model -> text ( m_d -> m_currentHint ) ) ; m_d -> m_numberLabel -> setText ( tr ( " % 1 ▁ of ▁ % 2" ) . arg ( m_d -> m_currentHint + 1 ) . arg ( m_d -> m_totalHints ) ) ; updatePosition ( ) ; }
void FunctionHintProposalWidget :: updatePosition ( ) { const QDesktopWidget * desktop = QApplication :: desktop ( ) ; const QRect & screen = desktop -> availableGeometry ( desktop -> screenNumber ( m_d -> m_underlyingWidget ) ) ; const QRect & screen = desktop -> screen@@ Geometry ( desktop -> screenNumber ( m_d -> m_underlyingWidget ) ) ; m_d -> m_pager -> setFixedWidth ( m_d -> m_pager -> minimumSizeHint ( ) . width ( ) ) ; m_d -> m_hintLabel -> setWordWrap ( false ) ; const int maxDesiredWidth = screen . width ( ) - 10 ; const QSize & minHint = m_d -> m_popupFrame -> minimumSizeHint ( ) ; if ( minHint . width ( ) > maxDesiredWidth ) { m_d -> m_hintLabel -> setWordWrap ( true ) ; m_d -> m_popupFrame -> setFixedWidth ( maxDesiredWidth ) ; const int extra = m_d -> m_popupFrame -> contentsMargins ( ) . bottom ( ) + m_d -> m_popupFrame -> contentsMargins ( ) . top ( ) ; m_d -> m_popupFrame -> setFixed@@ Height ( m_d -> m_hintLabel -> height@@ ForWidth ( maxDesiredWidth - m_d -> m_pager -> width ( ) ) + extra ) ; } else { m_d -> m_popupFrame -> setFixedSize ( minHint ) ; } const QSize & sz = m_d -> m_popupFrame -> size ( ) ; QPoint pos = m_d -> m_displayRect . topLeft ( ) ; pos . setY ( pos . y ( ) - sz . height ( ) - 1 ) ; if ( pos . x ( ) + sz . width ( ) > screen . right ( ) ) pos . setX ( screen . right ( ) - sz . width ( ) ) ; m_d -> m_popupFrame -> move ( pos ) ; }
void MarginalCovarianceCholesky :: setCholesk@@ yFact@@ or ( int n , int * Lp , int * Li , double * Lx , int * permInv ) { _n = n ; _Ap = Lp ; _Ai = Li ; _Ax = Lx ; _perm = permInv ; _diag . resize ( n ) ; for ( int r = 0 ; r < n ; ++ r ) { const int & sc = _Ap [ r ] ; assert ( r == _Ai [ sc ] && " Error ▁ in ▁ CCS ▁ storage ▁ of ▁ L " ) ; _diag [ r ] = 1.0 / _Ax [ sc ] ; } }
double MarginalCovarianceCholesky :: computeEntry ( int r , int c ) { assert ( r <= c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; if ( foundIt != _map . end ( ) ) { return foundIt -> second ; } double s = 0. ; const int & sc = _Ap [ r ] ; const int & ec = _Ap [ r + 1 ] ; for ( int j = sc + 1 ; j < ec ; ++ j ) { const int & rr = _Ai [ j ] ; double val = rr < c ? computeEntry ( rr , c ) : computeEntry ( c , rr ) ; s += val * _Ax [ j ] ; } double result ; if ( r == c ) { const double & diagElem = _diag [ r ] ; result = diagElem * ( diagElem - s ) ; } else { result = - s * _diag [ r ] ; } _map [ idx ] = result ; return result ; }
void MarginalCovarianceCholesky :: computeCovariance ( double * * covBlocks , const std :: vector < int > & blockIndices ) { _map . clear ( ) ; int base = 0 ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } base = nbase ; } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } base = 0 ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int nbase = blockIndices [ i ] ; int vdim = nbase - base ; double * cov = covBlocks [ i ] ; for ( int rr = 0 ; rr < vdim ; ++ rr ) for ( int cc = rr ; cc < vdim ; ++ cc ) { int r = _perm ? _perm [ rr + base ] : rr + base ; int c = _perm ? _perm [ cc + base ] : cc + base ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; cov [ rr * vdim + cc ] = foundIt -> second ; if ( rr != cc ) cov [ cc * vdim + rr ] = foundIt -> second ; } base = nbase ; } }
void MarginalCovarianceCholesky :: computeCovariance ( SparseBlockMatrix < MatrixXd > & spinv , const std :: vector < int > & rowBlockIndices , const std :: vector < std :: pair < int , int > > & blockIndices ) { spinv = SparseBlockMatrix < MatrixXd > ( & rowBlockIndices [ 0 ] , & rowBlockIndices [ 0 ] , rowBlockIndices . size ( ) , rowBlockIndices . size ( ) , true ) ; _map . clear ( ) ; vector < MatrixElem > elemsToCompute ; for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; assert ( blockRow >= 0 ) ; assert ( blockRow < ( int ) rowBlockIndices . size ( ) ) ; assert ( blockCol >= 0 ) ; assert ( blockCol < ( int ) rowBlockIndices . size ( ) ) ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol , true ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; elemsToCompute . push_back ( MatrixElem ( r , c ) ) ; } } sort ( elemsToCompute . begin ( ) , elemsToCompute . end ( ) ) ; for ( size_t i = 0 ; i < elemsToCompute . size ( ) ; ++ i ) { const MatrixElem & me = elemsToCompute [ i ] ; computeEntry ( me . r , me . c ) ; } for ( size_t i = 0 ; i < blockIndices . size ( ) ; ++ i ) { int blockRow = blockIndices [ i ] . first ; int blockCol = blockIndices [ i ] . second ; int rowBase = spinv . rowBaseOfBlock ( blockRow ) ; int colBase = spinv . colBaseOfBlock ( blockCol ) ; MatrixXd * block = spinv . block ( blockRow , blockCol ) ; assert ( block ) ; for ( int iRow = 0 ; iRow < block -> rows ( ) ; ++ iRow ) for ( int iCol = 0 ; iCol < block -> cols ( ) ; ++ iCol ) { int rr = rowBase + iRow ; int cc = colBase + iCol ; int r = _perm ? _perm [ rr ] : rr ; int c = _perm ? _perm [ cc ] : cc ; if ( r > c ) swap ( r , c ) ; int idx = computeIndex ( r , c ) ; LookupMap :: const_iterator foundIt = _map . find ( idx ) ; assert ( foundIt != _map . end ( ) ) ; ( * block ) ( iRow , iCol ) = foundIt -> second ; } } }
mpeg4_p2_video_packetizer_c :: mpeg4_p2_video_packetizer_c ( generic_@@ reader_@@ c * p_reader , track_info@@ _c & p_ti , double fps , int width , int height , bool input_is_native ) : video_for_windows_packetizer_c ( p_reader , p_ti , fps , width , height ) , m_timecodes_generated ( 0 ) , m_previous_timecode ( 0 ) , m_aspect_ratio_extracted ( false ) , m_input_is_native ( input_is_native ) , m_output_is_native ( hack@@ _eng@@ aged ( ENGAGE_@@ NATI@@ VE_MPEG4 ) || input_is_native ) , m_size_extracted ( false ) { if ( ! m_output_is_native ) m_timestamp_factory_application_mode = TF@@ A_SHOR@@ T_QUEUEING ; else { set_codec_@@ id ( MK@@ V_V_@@ MPEG@@ 4_ASP ) ; if ( ! m_input_is_native ) m_ti . m_private_data . reset ( ) ; if ( m_ti . m_ext_@@ timecodes . empty ( ) ) m_timestamp_@@ factory . reset ( ) ; if ( m_default_duration_forced ) m_fps = 1000000000.0 / m_htrack_default_duration ; else if ( 0.0 != m_fps ) m_htrack_default_duration = static_cast < int64_t > ( 100000000@@ 0ll / m_fps ) ; m_timestamp_factory_application_mode = TF@@ A_FULL_@@ QUEUEING ; } }
mpeg4_p2_video_packetizer_c :: ~ mpeg4_p2_video_packetizer_c ( ) { if ( ! debugg@@ ing_c :: requested ( " mpeg4 _ p2 _ statistics " ) ) return ; mxinfo ( boost :: format ( " mpeg4 _ p2 _ video _ packetizer _ c ▁ statistics : \n " " ▁ ▁ # ▁ I ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 1 % \n " " ▁ ▁ # ▁ P ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 2 % \n " " ▁ ▁ # ▁ B ▁ frames : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 3 % \n " " ▁ ▁ # ▁ NV@@ OPs : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ % 4 % \n " " ▁ ▁ # ▁ generated ▁ timecodes : ▁ % 5 % \n " " ▁ ▁ # ▁ dropped ▁ timecodes : ▁ ▁ ▁ % 6 % \n " ) % m_statistics . m_num_i_frames % m_statistics . m_num_p_frames % m_statistics . m_num_b_frames % m_statistics . m_num_n_vops % m_statistics . m_num_generated_timecodes % m_statistics . m_num_dropped_timecodes ) ; }
int mpeg4_p2_video_packetizer_c :: process ( packet_cptr packet ) { extract_size ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; extract_aspect_ratio ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) ) ; int result = m_input_is_native == m_output_is_native ? video_for_windows_packetizer_c :: process ( packet ) : m_input_is_native ? process_native ( packet ) : process_non_native ( packet ) ; ++ m_frames_output ; return result ; }
int mpeg4_p2_video_packetizer_c :: process_non_native ( packet_cptr packet ) { extract_config_data ( packet ) ; if ( - 1 != packet -> timecode ) { if ( ! m_default_duration_forced ) m_available_timecodes . push_back ( timecode_duration_t ( packet -> timecode , packet -> duration ) ) ; else { m_available_timecodes . push_back ( timecode_duration_t ( m_timecodes_generated * m_htrack_default_duration , m_htrack_default_duration ) ) ; ++ m_timecodes_generated ; } } else if ( 0.0 == m_fps ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Cannot ▁ convert ▁ non - native ▁ MPEG4 ▁ video ▁ frames ▁ into ▁ native ▁ ones ▁ if ▁ the ▁ source ▁ container ▁ " " provi@@ des ▁ neith@@ er ▁ timecodes ▁ nor ▁ a ▁ number ▁ of ▁ frames ▁ per ▁ second . \n " ) ) ; std :: vector < video_frame_t > frames ; mpeg4 :: p2 :: find_frame_@@ types ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , frames , m_config_data ) ; for ( auto & frame : frames ) { if ( ! frame . is_coded ) { ++ m_statistics . m_num_n_vops ; int num_surplus_timecodes = static_cast < int > ( m_available_timecodes . size ( ) ) - static_cast < int > ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ; if ( 0 < num_surplus_timecodes ) { std :: deque < timecode_duration_t > :: iterator start = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) ; std :: deque < timecode_duration_t > :: iterator end = start + num_surplus_timecodes ; if ( 0 != ( m_ref_frames . size ( ) + m_b_frames . size ( ) ) ) { std :: deque < timecode_duration_t > :: iterator last = m_available_timecodes . begin ( ) + m_ref_frames . size ( ) + m_b_frames . size ( ) - 1 ; std :: deque < timecode_duration_t > :: iterator cur = start ; while ( cur != end ) { last -> m_duration = std :: max ( last -> m_duration , static_cast < int64_t > ( 0 ) ) + std :: max ( cur -> m_duration , static_cast < int64_t > ( 0 ) ) ; ++ cur ; } } m_available_timecodes . erase ( start , end ) ; m_statistics . m_num_dropped_timecodes += num_surplus_timecodes ; } continue ; } if ( FRAME_TYPE_@@ I == frame . type ) ++ m_statistics . m_num_i_frames ; else if ( FRAME_TYPE_P == frame . type ) ++ m_statistics . m_num_p_frames ; else ++ m_statistics . m_num_b_frames ; if ( FRAME_TYPE_B != frame . type ) flush_frames ( false ) ; frame . data = ( unsigned char * ) safememdup ( packet -> data -> get_buffer ( ) + frame . pos , frame . size ) ; frame . timecode = - 1 ; if ( FRAME_TYPE_B == frame . type ) m_b_frames . push_back ( frame ) ; else m_ref_frames . push_back ( frame ) ; } m_previous_timecode = m_available_timecodes . back ( ) . m_timecode ; return FILE_STATUS_MOREDATA ; }
void mpeg4_p2_video_packetizer_c :: extract_config_data ( packet_cptr & packet ) { if ( m_ti . m_private_data ) return ; m_ti . m_private_data = memory_@@ cptr { mpeg4 :: p2 :: parse_@@ config_data ( packet -> data -> get_buffer ( ) , packet -> data -> get_size ( ) , m_config_data ) } ; if ( ! m_ti . m_private_data ) mxerror_tid ( m_ti . m_fname , m_ti . m_id , Y ( " Could ▁ not ▁ find ▁ the ▁ codec ▁ configuration ▁ data ▁ in ▁ the ▁ first ▁ MPEG - 4 ▁ part ▁ 2 ▁ video ▁ frame . ▁ This ▁ track ▁ cannot ▁ be ▁ stored ▁ in ▁ native ▁ mode . \n " ) ) ; fix_codec_string ( ) ; set_codec_private ( m_ti . m_private_data ) ; rerender_track_headers ( ) ; }
void mpeg4_p2_video_packetizer_c :: fix_codec_string ( ) { static const unsigned char start_code [ 4 ] = { 0x00 , 0x00 , 0x01 , 0xb2 } ; if ( ! m_ti . m_private_data || ( 0 == m_ti . m_private_data -> get_size ( ) ) ) return ; auto private_data = m_ti . m_private_data -> get_buffer ( ) ; int size = m_ti . m_private_data -> get_size ( ) ; int i ; for ( i = 0 ; 9 < size ; ) { if ( memcmp ( & private_data [ i ] , start_code , 4 ) != 0 ) { ++ i ; -- size ; continue ; } i += 8 ; size -= 8 ; if ( strncasecmp ( ( const char * ) & private_data [ i - 4 ] , " divx " , 4 ) != 0 ) continue ; unsigned char * end_pos = ( unsigned char * ) memchr ( & private_data [ i ] , 0 , size ) ; if ( ! end_pos ) end_pos = & private_data [ i + size ] ; -- end_pos ; if ( ' p ' == * end_pos ) * end_pos = ' n ' ; return ; } }
int mpeg4_p2_video_packetizer_c :: process_native ( packet_cptr ) { return FILE_STATUS_MOREDATA ; }
void mpeg4_p2_video_packetizer_c :: generate_timecode_and_duration ( ) { if ( 0.0 >= m_fps ) { mxexit ( 1 ) ; } if ( m_available_timecodes . empty ( ) ) { m_previous_timecode = ( int64_t ) ( m_previous_timecode + 1000000000.0 / m_fps ) ; m_available_timecodes . push_back ( timecode_duration_t ( m_previous_timecode , ( int64_t ) ( 1000000000.0 / m_fps ) ) ) ; mxverb ( 3 , boost :: format ( " mpeg4 _ p2 : : flush _ frames ( ) : ▁ Needed ▁ new ▁ timecode ▁ % 1 % \n " ) % m_previous_timecode ) ; ++ m_statistics . m_num_generated_timecodes ; } }
void mpeg4_p2_video_packetizer_c :: get_next_timecode_and_duration ( int64_t & timecode , int64_t & duration ) { if ( m_available_timecodes . empty ( ) ) generate_timecode_and_duration ( ) ; timecode = m_available_timecodes . front ( ) . m_timecode ; duration = m_available_timecodes . front ( ) . m_duration ; m_available_timecodes . pop_front ( ) ; }
void mpeg4_p2_video_packetizer_c :: flush_frames ( bool end_of_file ) { if ( m_ref_frames . empty ( ) ) return ; if ( m_ref_frames . size ( ) == 1 ) { video_frame_t & frame = m_ref_frames . front ( ) ; if ( - 1 == frame . timecode ) { get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration ) ) ; } return ; } video_frame_t & bref_frame = m_ref_frames . front ( ) ; video_frame_t & fref_frame = m_ref_frames . back ( ) ; for ( auto & frame : m_b_frames ) get_next_timecode_and_duration ( frame . timecode , frame . duration ) ; get_next_timecode_and_duration ( fref_frame . timecode , fref_frame . duration ) ; add_packet ( new packet_t ( new memory_c ( fref_frame . data , fref_frame . size , true ) , fref_frame . timecode , fref_frame . duration , FRAME_TYPE_P == fref_frame . type ? bref_frame . timecode : VFT_@@ IFRAME ) ) ; for ( auto & frame : m_b_frames ) add_packet ( new packet_t ( new memory_c ( frame . data , frame . size , true ) , frame . timecode , frame . duration , bref_frame . timecode , fref_frame . timecode ) ) ; m_ref_frames . pop_front ( ) ; m_b_frames . clear ( ) ; if ( end_of_file ) m_ref_frames . clear ( ) ; }
void mpeg4_p2_video_packetizer_c :: flush@@ _impl ( ) { flush_frames ( true ) ; }
void mpeg4_p2_video_packetizer_c :: extract_aspect_ratio ( const unsigned char * buffer , int size ) { if ( m_aspect_ratio_extracted ) return ; if ( ( 0 != m_connected_to ) || display_di@@ mens@@ ions_@@ or_aspect_ratio_@@ set ( ) ) { m_aspect_ratio_extracted = true ; return ; } uint32_t num , den ; if ( mpeg4 :: p2 :: extract_par ( buffer , size , num , den ) ) { m_aspect_ratio_extracted = true ; set_video_@@ aspect_ratio ( ( double ) m_hvideo_pixel_width / ( double ) m_hvideo_pixel_height * ( double ) num / ( double ) den , false , OPTION@@ _SOURCE_@@ BITSTREAM ) ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " Extracted ▁ the ▁ aspect ▁ ratio ▁ information ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ and ▁ set ▁ the ▁ display ▁ dimensions ▁ to ▁ % 1 % / %2 % . \n " ) ) % m_hvideo_display_width % m_hvideo_display_height ) ; } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; }
void mpeg4_p2_video_packetizer_c :: extract_size ( const unsigned char * buffer , int size ) { if ( m_size_extracted ) return ; if ( 0 != m_connected_to ) { m_size_extracted = true ; return ; } uint32_t xtr_width , xtr_height ; if ( mpeg4 :: p2 :: extract_size ( buffer , size , xtr_width , xtr_height ) ) { m_size_extracted = true ; if ( ! m_reader -> m_append@@ ing && ( ( xtr_width != static_cast < uint32_t > ( m_hvideo_pixel_width ) ) || ( xtr_height != static_cast < uint32_t > ( m_hvideo_pixel_height ) ) ) ) { set_video_pixel@@ _width ( xtr_width ) ; set_video_pixel@@ _height ( xtr_height ) ; if ( ! m_output_is_native && m_ti . m_private_data && ( sizeof ( alBITMAPINFOHEADER ) <= m_ti . m_private_data -> get_size ( ) ) ) { auto bih = reinterpret_cast < alBITMAPINFOHEADER * > ( m_ti . m_private_data -> get_buffer ( ) ) ; put_uint32_le ( & bih -> bi_@@ width , xtr_width ) ; put_uint32_le ( & bih -> bi_@@ height , xtr_height ) ; set_codec_private ( m_ti . m_private_data ) ; } m_hvideo_display_width = - 1 ; m_hvideo_display_height = - 1 ; generic_packetizer_c :: set_headers ( ) ; rerender_track_headers ( ) ; mxinfo_tid ( m_ti . m_fname , m_ti . m_id , boost :: format ( Y ( " The ▁ extracted ▁ values ▁ for ▁ video ▁ width ▁ and ▁ height ▁ from ▁ the ▁ MPEG4 ▁ layer ▁ 2 ▁ video ▁ data ▁ bitstream ▁ diff@@ er ▁ from ▁ what ▁ the ▁ values ▁ " " in ▁ the ▁ source ▁ container . ▁ The ▁ ones ▁ from ▁ the ▁ video ▁ data ▁ bitstream ▁ ( %1 % x % 2 % ) ▁ will ▁ be ▁ used . \n " ) ) % xtr_width % xtr_height ) ; } } else if ( 50 <= m_frames_output ) m_aspect_ratio_extracted = true ; }
void UniqueExpireCacheTest :: testClear ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , IntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; assert ( aCache . get ( 3 ) -> value == 4 ) ; assert ( aCache . get ( 5 ) -> value == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; }
void UniqueExpireCacheTest :: testAccessClear ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( aCache . get ( 3 ) -> value ( ) == 4 ) ; assert ( aCache . get ( 5 ) -> value ( ) == 6 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; }
void UniqueExpireCacheTest :: testAccessUpdate ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; aCache . add ( 3 , DIntVal ( 4 , DURSLEEP ) ) ; aCache . add ( 5 , DIntVal ( 6 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( aCache . has ( 5 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; Thread :: sleep ( DURSLEEP / 2 ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; Thread :: sleep ( DURSLEEP * 2 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( ! aCache . has ( 5 ) ) ; aCache . remove ( 666 ) ; }
void UniqueExpireCacheTest :: testExpire0 ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , 0 ) ) ; assert ( ! aCache . has ( 1 ) ) ; }
void UniqueExpireCacheTest :: testAccessExpire0 ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , Timespan ( 0 , 0 ) ) ) ; assert ( ! aCache . has ( 1 ) ) ; }
void UniqueExpireCacheTest :: testExpireN ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; SharedPtr < IntVal > tmp = aCache . get ( 1 ) ; assert ( ! tmp . isNull ( ) ) ; assert ( tmp -> value == 2 ) ; Thread :: sleep ( DURWAIT ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( tmp -> value == 2 ) ; tmp = aCache . get ( 1 ) ; assert ( tmp . isNull ( ) ) ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; Thread :: sleep ( DURHALFSLEEP ) ; aCache . add ( 3 , IntVal ( 4 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; tmp = aCache . get ( 1 ) ; SharedPtr < IntVal > tmp2 = aCache . get ( 3 ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 1 ) ) ; assert ( aCache . has ( 3 ) ) ; assert ( tmp -> value == 2 ) ; assert ( tmp2 -> value == 4 ) ; tmp2 = aCache . get ( 3 ) ; assert ( tmp2 -> value == 4 ) ; Thread :: sleep ( DURHALFSLEEP + 25 ) ; assert ( ! aCache . has ( 3 ) ) ; assert ( tmp2 -> value == 4 ) ; tmp = aCache . get ( 1 ) ; tmp2 = aCache . get ( 3 ) ; assert ( ! tmp ) ; assert ( ! tmp2 ) ; aCache . remove ( 666 ) ; aCache . clear ( ) ; assert ( ! aCache . has ( 5 ) ) ; assert ( ! aCache . has ( 3 ) ) ; }
void UniqueExpireCacheTest :: testDuplicateAdd ( ) { UniqueExpireCache < int , IntVal > aCache ; aCache . add ( 1 , IntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 2 ) ; aCache . add ( 1 , IntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value == 3 ) ; }
void UniqueExpireCacheTest :: testAccessDuplicateAdd ( ) { UniqueAccessExpireCache < int , DIntVal > aCache ; aCache . add ( 1 , DIntVal ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , DIntVal ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; }
void UniqueExpireCacheTest :: testExpirationDecorator ( ) { typedef ExpirationDecorator < int > ExpireInt ; UniqueExpireCache < int , ExpireInt > aCache ; aCache . add ( 1 , ExpireInt ( 2 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 2 ) ; aCache . add ( 1 , ExpireInt ( 3 , DURSLEEP ) ) ; assert ( aCache . has ( 1 ) ) ; assert ( aCache . get ( 1 ) -> value ( ) == 3 ) ; }
CppUnit :: Test * UniqueExpireCacheTest :: suite ( ) { CppUnit :: TestSuite * pSuite = new CppUnit :: TestSuite ( " UniqueExpireCacheTest " ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessClear ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessUpdate ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessExpire0 ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpireN ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testAccessDuplicateAdd ) ; CppUnit_addTest ( pSuite , UniqueExpireCacheTest , testExpirationDecorator ) ; return pSuite ; }
QgsNewHttpConnection :: QgsNewHttpConnection ( QWidget * parent , const QString & baseKey , const QString & connName , Qt :: WindowFlags fl ) : QDialog ( parent , fl ) , mBaseKey ( baseKey ) , mOriginalConnName ( connName ) , mAuthConfigSelect ( nullptr ) { setupUi ( this ) ; QString service = baseKey . mid ( 18 , 3 ) . toUpper ( ) ; setWindowTitle ( tr ( " Create ▁ a ▁ new ▁ % 1 ▁ connection " ) . arg ( service ) ) ; mCredentialsBaseKey = mBaseKey . split ( ' - ' ) . last ( ) . toUpper ( ) ; txtName -> setValidator ( new QRegExpValidator ( QRegExp ( " [ ^ \\ / ] + " ) , txtName ) ) ; cmbDpiMode -> clear ( ) ; cmbDpiMode -> addItem ( tr ( " all " ) ) ; cmbDpiMode -> addItem ( tr ( " off " ) ) ; cmbDpiMode -> addItem ( tr ( " QGI@@ S " ) ) ; cmbDpiMode -> addItem ( tr ( " UMN " ) ) ; cmbDpiMode -> addItem ( tr ( " GeoServer " ) ) ; cmbVersion -> clear ( ) ; cmbVersion -> addItem ( tr ( " Auto - detect " ) ) ; cmbVersion -> addItem ( tr ( "1.0" ) ) ; cmbVersion -> addItem ( tr ( "1.1" ) ) ; cmbVersion -> addItem ( tr ( "2.@@ 0" ) ) ; mAuthConfigSelect = new QgsAuthConfigSelect ( this ) ; tabAuth -> insertTab ( 1 , mAuthConfigSelect , tr ( " Configurations " ) ) ; if ( ! connName . isEmpty ( ) ) { QSettings settings ; QString key = mBaseKey + connName ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + connName ; txtName -> setText ( connName ) ; txtUrl -> setText ( settings . value ( key + " / url " ) . toString ( ) ) ; cbxIgnoreGetMapURI -> setChecked ( settings . value ( key + " / ignoreGetMapURI " , false ) . toBool ( ) ) ; cbxIgnoreAxisOrientation -> setChecked ( settings . value ( key + " / ignoreAxisOrientation " , false ) . toBool ( ) ) ; cbxInvertAxisOrientation -> setChecked ( settings . value ( key + " / invertAxisOrientation " , false ) . toBool ( ) ) ; cbxIgnoreGetFeatureInfoURI -> setChecked ( settings . value ( key + " / ignoreGetFeatureInfoURI " , false ) . toBool ( ) ) ; cbxSmoothPixmapTransform -> setChecked ( settings . value ( key + " / smoothPixmapTransform " , false ) . toBool ( ) ) ; int dpiIdx ; switch ( settings . value ( key + " / dpiMode " , 7 ) . toInt ( ) ) { case 0 : dpiIdx = 1 ; break ; case 1 : dpiIdx = 2 ; break ; case 2 : dpiIdx = 3 ; break ; case 4 : dpiIdx = 4 ; break ; default : dpiIdx = 0 ; break ; } cmbDpiMode -> setCurrentIndex ( dpiIdx ) ; QString version = settings . value ( key + " / version " ) . toString ( ) ; int versionIdx = 0 ; if ( version == "1.0.0" ) versionIdx = 1 ; else if ( version == "1.1.0" ) versionIdx = 2 ; else if ( version == "2.0.0" ) versionIdx = 3 ; cmbVersion -> setCurrentIndex ( versionIdx ) ; txtReferer -> setText ( settings . value ( key + " / referer " ) . toString ( ) ) ; txtMaxNumFeatures -> setText ( settings . value ( key + " / maxnumfeatures " ) . toString ( ) ) ; txtUserName -> setText ( settings . value ( credentialsKey + " / username " ) . toString ( ) ) ; txtPassword -> setText ( settings . value ( credentialsKey + " / password " ) . toString ( ) ) ; QString authcfg = settings . value ( credentialsKey + " / authcfg " ) . toString ( ) ; mAuthConfigSelect -> setConfig@@ Id ( authcfg ) ; if ( ! authcfg . isEmpty ( ) ) { tabAuth -> setCurrentIndex ( tabAuth -> indexOf ( mAuthConfigSelect ) ) ; } } if ( mBaseKey != " / Qgis / connections - wms / " ) { if ( mBaseKey != " / Qgis / connections - wcs / " && mBaseKey != " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setVisible ( false ) ; cbxInvertAxisOrientation -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreAxisOrientation ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxInvertAxisOrientation ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation ▁ ( WFS ▁ 1.1 / WFS ▁ 2.0 ) " ) ) ; } if ( mBaseKey == " / Qgis / connections - wcs / " ) { cbxIgnoreGetMapURI -> setText ( tr ( " Ignore ▁ GetCoverage ▁ URI ▁ reported ▁ in ▁ capabilities " ) ) ; cbxIgnoreAxisOrientation -> setText ( tr ( " Ignore ▁ axis ▁ orientation " ) ) ; } else { cbxIgnoreGetMapURI -> setVisible ( false ) ; cbxSmoothPixmapTransform -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetMapURI ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxSmoothPixmapTransform ) ; } cbxIgnoreGetFeatureInfoURI -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cbxIgnoreGetFeatureInfoURI ) ; cmbDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbDpiMode ) ; lblDpiMode -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblDpiMode ) ; txtReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtReferer ) ; lblReferer -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblReferer ) ; } if ( mBaseKey != " / Qgis / connections - wfs / " ) { cmbVersion -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( cmbVersion ) ; lblMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( lblMaxNumFeatures ) ; txtMaxNumFeatures -> setVisible ( false ) ; mGroupBox -> layout ( ) -> removeWidget ( txtMaxNumFeatures ) ; } int w = width ( ) ; adjust@@ Size ( ) ; resize ( w , height ( ) ) ; on_txtName_textChanged ( connName ) ; }
void QgsNewHttpConnection :: on_txtName_textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; }
void QgsNewHttpConnection :: on_@@ txtU@@ rl_@@ textChanged ( const QString & text ) { Q_UNUSED ( text ) ; buttonBox -> button ( QDialogButtonBox :: Ok ) -> setDisabled ( txtName -> text ( ) . isEmpty ( ) || txtUrl -> text ( ) . isEmpty ( ) ) ; }
void QgsNewHttpConnection :: accept ( ) { QSettings settings ; QString key = mBaseKey + txtName -> text ( ) ; QString credentialsKey = " / Qgis / " + mCredentialsBaseKey + ' / ' + txtName -> text ( ) ; if ( ( mOriginalConnName . isNull ( ) || mOriginalConnName . compare ( txtName -> text ( ) , Qt :: CaseInsensitive ) != 0 ) && settings . contains ( key + " / url " ) && QMessageBox :: question ( this , tr ( " Save ▁ connection " ) , tr ( " Should ▁ the ▁ existing ▁ connection ▁ % 1 ▁ be ▁ overwritten ? " ) . arg ( txtName -> text ( ) ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! txtPassword -> text ( ) . isEmpty ( ) && QMessageBox :: question ( this , tr ( " Saving ▁ passwords " ) , tr ( " WARNING : ▁ You ▁ have ▁ entered ▁ a ▁ password . ▁ It ▁ will ▁ be ▁ stored ▁ in ▁ plain ▁ text ▁ in ▁ your ▁ project ▁ files ▁ and ▁ in ▁ your ▁ home ▁ directory ▁ on ▁ Unix - like ▁ systems , ▁ or ▁ in ▁ your ▁ user ▁ profile ▁ on ▁ Windows . ▁ If ▁ you ▁ do ▁ not ▁ want ▁ this ▁ to ▁ happen , ▁ please ▁ press ▁ the ▁ Cancel ▁ button . \n Note : ▁ giv@@ ing ▁ the ▁ password ▁ is ▁ optional . ▁ It ▁ will ▁ be ▁ requested ▁ interactiv@@ ly , ▁ when ▁ needed . " ) , QMessageBox :: Ok | QMessageBox :: Cancel ) == QMessageBox :: Cancel ) { return ; } if ( ! mOriginalConnName . isNull ( ) && mOriginalConnName != key ) { settings . remove ( mBaseKey + mOriginalConnName ) ; settings . remove ( " / Qgis / " + mCredentialsBaseKey + ' / ' + mOriginalConnName ) ; settings . sync ( ) ; } QUrl url ( txtUrl -> text ( ) . trimmed ( ) ) ; const QList < QPair < QByteArray , QByteArray > > & items = url . encodedQueryItems ( ) ; QHash < QString , QPair < QByteArray , QByteArray > > params ; for ( QList < QPair < QByteArray , QByteArray > > :: const_iterator it = items . constBegin ( ) ; it != items . constEnd ( ) ; ++ it ) { params . insert ( QString ( it -> first ) . toUpper ( ) , * it ) ; } if ( params [ " SERVICE " ] . second . toUpper ( ) == " WMS " || params [ " SERVICE " ] . second . toUpper ( ) == " WFS " || params [ " SERVICE " ] . second . toUpper ( ) == " WCS " ) { url . removeEncodedQueryItem ( params [ " SERVICE " ] . first ) ; url . removeEncodedQueryItem ( params [ " REQUEST " ] . first ) ; url . removeEncodedQueryItem ( params [ " FORMAT " ] . first ) ; } if ( url . encodedPath ( ) . isEmpty ( ) ) { url . setEncoded@@ Path ( " / " ) ; } settings . setValue ( key + " / url " , url . toString ( ) ) ; if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " || mBaseKey == " / Qgis / connections - wfs / " ) { settings . setValue ( key + " / ignoreAxisOrientation " , cbxIgnoreAxisOrientation -> isChecked ( ) ) ; settings . setValue ( key + " / invertAxisOrientation " , cbxInvertAxisOrientation -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wms / " || mBaseKey == " / Qgis / connections - wcs / " ) { settings . setValue ( key + " / ignoreGetMapURI " , cbxIgnoreGetMapURI -> isChecked ( ) ) ; settings . setValue ( key + " / smoothPixmapTransform " , cbxSmoothPixmapTransform -> isChecked ( ) ) ; int dpiMode = 0 ; switch ( cmbDpiMode -> currentIndex ( ) ) { case 0 : dpiMode = 7 ; break ; case 1 : dpiMode = 0 ; break ; case 2 : dpiMode = 1 ; break ; case 3 : dpiMode = 2 ; break ; case 4 : dpiMode = 4 ; break ; } settings . setValue ( key + " / dpiMode " , dpiMode ) ; } if ( mBaseKey == " / Qgis / connections - wms / " ) { settings . setValue ( key + " / ignoreGetFeatureInfoURI " , cbxIgnoreGetFeatureInfoURI -> isChecked ( ) ) ; } if ( mBaseKey == " / Qgis / connections - wfs / " ) { QString version = " auto " ; switch ( cmbVersion -> currentIndex ( ) ) { case 0 : version = " auto " ; break ; case 1 : version = "1.0.0" ; break ; case 2 : version = "1.1.0" ; break ; case 3 : version = "2.0.0" ; break ; } settings . setValue ( key + " / version " , version ) ; settings . setValue ( key + " / maxnumfeatures " , txtMaxNumFeatures -> text ( ) ) ; } settings . setValue ( key + " / referer " , txtReferer -> text ( ) ) ; settings . setValue ( credentialsKey + " / username " , txtUserName -> text ( ) ) ; settings . setValue ( credentialsKey + " / password " , txtPassword -> text ( ) ) ; settings . setValue ( credentialsKey + " / authcfg " , mAuthConfigSelect -> configId ( ) ) ; settings . setValue ( mBaseKey + " / selected " , txtName -> text ( ) ) ; QDialog :: accept ( ) ; }
void V8VideoTrackList :: visitDOMWrapper ( v8 :: Isolate * isolate , ScriptWrappable * scriptWrappable , const v8 :: Persistent < v8 :: Object > & wrapper ) { VideoTrackList * impl = scriptWrappable -> toImpl < VideoTrackList > ( ) ; if ( Node * owner = WTF :: getPtr ( impl -> owner ( ) ) ) { Node * root = V8GCController :: opaque@@ RootForGC ( isolate , owner ) ; isolate -> SetReference@@ FromGroup ( v8 :: UniqueId ( reinterpret_cast < intptr_t > ( root ) ) , wrapper ) ; return ; } }
v8 :: Local < v8 :: FunctionTemplate > V8VideoTrackList :: domTemplate ( v8 :: Isolate * isolate ) { return V8DOMConfiguration :: domClassTemplate ( isolate , const_cast < WrapperTypeInfo * > ( & wrapperTypeInfo ) , installV8VideoTrackListTemplate ) ; }
bool V8VideoTrackList :: hasInstance ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> hasInstance ( & wrapperTypeInfo , v8Value ) ; }
v8 :: Local < v8 :: Object > V8VideoTrackList :: findInstanceInPrototypeChain ( v8 :: Local < v8 :: Value > v8Value , v8 :: Isolate * isolate ) { return V8PerIsolateData :: from ( isolate ) -> findInstanceInPrototypeChain ( & wrapperTypeInfo , v8Value ) ; }
VideoTrackList * V8VideoTrackList :: toImpl@@ WithTypeCheck ( v8 :: Isolate * isolate , v8 :: Local < v8 :: Value > value ) { return hasInstance ( value , isolate ) ? toImpl ( v8 :: Local < v8 :: Object > :: Cast ( value ) ) : 0 ; }
void V8VideoTrackList :: refObject ( ScriptWrappable * scriptWrappable ) { ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> ref ( ) ; }
void V8VideoTrackList :: derefObject ( ScriptWrappable * scriptWrappable ) { ENABLE ( OILPAN ) scriptWrappable -> toImpl < VideoTrackList > ( ) -> deref ( ) ; }
bool CBOINCGUIApp :: OnInit ( ) { g_use_sandbox = true ; g_use_sandbox = false ; s_bSkipExitConfirmation = false ; m_bFilterEvents = false ; m_pLocale = NULL ; m_pSkinManager = NULL ; m_pFrame = NULL ; m_pDocument = NULL ; m_pTaskBarIcon = NULL ; m_pEventLog = NULL ; m_pMacSystemMenu = NULL ; m_strBOINCMGRExecutableName = wxEmptyString ; m_strBOINCMGRRootDirectory = wxEmptyString ; m_strBOINCMGRDataDirectory = wxEmptyString ; m_strHostNameArg = wxEmptyString ; m_strPasswordArg = wxEmptyString ; m_iRPCPortArg = GUI_RPC_PORT ; m_strBOINCArguments = wxEmptyString ; m_bGUIVisible = true ; m_bDebugSkins = false ; m_bMultipleInstancesOK = false ; m_bBOINCMGRAutoStarted = false ; m_iBOINCMGRDisableAutoStart = 0 ; m_iShutdownCoreClient = 0 ; m_iDisplayExitDialog = 1 ; m_iGUISelected = BOINC_SIMPLEGUI ; m_bSafeMessageBoxDisplayed = 0 ; m_hClient@@ Library@@ Dll = NULL ; int iErrorCode = 0 ; int iSelectedLanguage = 0 ; bool bOpenEventLog = false ; wxString strDesiredSkinName = wxEmptyString ; wxString strDialogMessage = wxEmptyString ; bool success = false ; wxSystemOptions :: SetOption ( wxT ( " msw . staticbox . optim@@ ized - paint " ) , 0 ) ; wxSystemOptions :: SetOption ( wxT ( " mac . listctrl . always _ use _ generic " ) , 1 ) ; AEInstallEventHandler ( kCore@@ EventClass , kAE@@ Quit@@ Application , NewAE@@ EventHandlerUPP ( ( AEEventHandler@@ ProcPtr ) QuitAppleEventHandler ) , 0 , false ) ; GetCurrentProcess ( & m_psnCurrentProcess ) ; if ( ! wxApp :: OnInit ( ) ) { return false ; } if ( g_use_sandbox ) { wxCHANGE_@@ UMASK ( 2 ) ; } SetAppName ( wxT ( " BOINC ▁ Manager " ) ) ; SetVend@@ orName ( wxT ( " Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkele@@ y " ) ) ; m_pConfig = new wxConfig ( GetAppName ( ) ) ; wxConfig@@ Base :: Set ( m_pConfig ) ; wxASSERT ( m_pConfig ) ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " AutomaticallyShutdownClient " ) , & m_iShutdownCoreClient , 0L ) ; m_pConfig -> Read ( wxT ( " DisplayShutdownClientDialog " ) , & m_iDisplayExitDialog , 1L ) ; m_pConfig -> Read ( wxT ( " DisableAutoStart " ) , & m_iBOINCMGRDisableAutoStart , 0L ) ; m_pConfig -> Read ( wxT ( " Language " ) , & iSelectedLanguage , 0L ) ; m_pConfig -> Read ( wxT ( " GUISelection " ) , & m_iGUISelected , BOINC_SIMPLEGUI ) ; m_pConfig -> Read ( wxT ( " EventLog@@ Open " ) , & bOpenEventLog ) ; if ( m_bBOINCMGRAutoStarted && m_iBOINCMGRDisableAutoStart ) { return false ; } DetectExecutableName ( ) ; DetectRootDirectory ( ) ; DetectDataDirectory ( ) ; if ( ! GetDataDirectory ( ) . IsEmpty ( ) ) { success = wxSetWor@@ kingDirectory ( GetDataDirectory ( ) ) ; if ( ! success ) { if ( ! g_use_sandbox ) { if ( ! wxDir@@ Exists ( GetDataDirectory ( ) ) ) { success = wxMk@@ dir ( GetDataDirectory ( ) , 0777 ) ; } } } } if ( ! success ) iErrorCode = - 1016 ; int dwDiagnosticsFlags = BOINC_DIAG_@@ DUM@@ PCALL@@ STACK@@ ENABLED | BOINC_DIAG_@@ HEAP@@ CHECKENABLED | BOINC_DIAG_@@ MEMORYLEA@@ KCHECKENABLED | || defined ( __WXMAC__ ) BOINC_DIAG_REDIRECT@@ STDERR | BOINC_DIAG_REDIRECT@@ STDOUT | BOINC_DIAG_@@ TRACETO@@ STDOUT ; diagnostics_@@ init ( dwDiagnosticsFlags , " stdo@@ utgui " , " stderrgui " ) ; m_pLog = new wxLog@@ BOINC ( ) ; wxLog :: SetActiveTarget ( m_pLog ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Start / End " ) ) ; m_pLog -> AddTraceMask ( wxT ( " Function ▁ Status " ) ) ; _config@@ threadlocale ( _ENABLE_@@ PER_THREAD_LOCAL@@ E ) ; m_pLocale = new wxLocale ( ) ; wxASSERT ( m_pLocale ) ; m_pLocale -> Init ( iSelectedLanguage ) ; if ( ! m_strBOINCMGRRootDirectory . IsEmpty ( ) ) { m_pLocale -> AddCatalogLookupPathPrefix ( wxString ( m_strBOINCMGRRootDirectory + wxT ( " locale " ) ) ) ; } m_pLocale -> AddCatalogLookupPathPrefix ( wxT ( " locale " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Manager " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Client " ) ) ; m_pLocale -> AddCatalog ( wxT ( " BOINC - Web " ) ) ; InitSupportedLanguages ( ) ; wxHelp@@ Provider :: Set ( new wxHelp@@ ControllerHelp@@ Provider ( ) ) ; wxInit@@ AllImage@@ Handlers ( ) ; wxFileSystem :: AddHandler ( new wxMemory@@ FSHandler ) ; m_pInternetFSHandler = new CBOINCInternetFSHandler ; wxFileSystem :: AddHandler ( m_pInternetFSHandler ) ; m_pSkinManager = new CSkinManager ( m_bDebugSkins ) ; wxASSERT ( m_pSkinManager ) ; m_pConfig -> Read ( wxT ( " Skin " ) , & strDesiredSkinName , m_pSkinManager -> GetDefault@@ SkinName ( ) ) ; m_pSkinManager -> ReloadSkin ( strDesiredSkinName ) ; char path_to_error [ MAXPATHLEN ] ; path_to_error [ 0 ] = ' \0' ; if ( ! iErrorCode ) { defined ( __WXMAC__ ) && defined ( _DEBUG ) ) if ( check_security ( g_use_sandbox , true ) ) { CreateBOINC@@ UsersAnd@@ Groups ( ) ; SetBOINC@@ DataOwnersGroupsAndPermissions ( ) ; SetBOINC@@ AppOwnersGroupsAndPermissions ( NULL ) ; } iErrorCode = check_security ( g_use_sandbox , true , path_to_error ) ; } if ( iErrorCode ) { ShowApplication ( true ) ; if ( iErrorCode == - 1099 ) { strDialogMessage . Printf ( _ ( " You ▁ currently ▁ are ▁ not ▁ authorized ▁ to ▁ manage ▁ the ▁ client . \n \n To ▁ run ▁ % s ▁ as ▁ this ▁ user , ▁ please : \n ▁ ▁ - ▁ reinstall ▁ % s ▁ answer@@ ing ▁ \ " Yes \ " ▁ to ▁ the ▁ question ▁ about \n ▁ ▁ ▁ ▁ ▁ non - administr@@ ative ▁ users \n ▁ or \n ▁ ▁ - ▁ contact ▁ your ▁ administr@@ ator ▁ to ▁ add ▁ you ▁ to ▁ the ▁ ' boinc _ master ' \n ▁ ▁ ▁ ▁ ▁ user ▁ group . " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) ) ; } else { strDialogMessage . Printf ( _ ( " % s ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % s . \n ( Error ▁ code ▁ % d " ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode ) ; if ( path_to_error [ 0 ] ) { strDialogMessage += _ ( " ▁ at ▁ " ) ; strDialogMessage += wxString :: FromUTF8 ( path_to_error ) ; } strDialogMessage += _ ( " ) " ) ; fprintf ( stderr , " % ls ▁ ownership ▁ or ▁ permissions ▁ are ▁ not ▁ set ▁ properly ; ▁ please ▁ reinstall ▁ % ls . \n ( Error ▁ code ▁ % d ▁ at ▁ % s ) " , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationShortName ( ) . c_str ( ) , iErrorCode , path_to_error ) ; } wxMessageDialog * pDlg = new wxMessageDialog ( NULL , strDialogMessage , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , wxOK ) ; pDlg -> ShowModal ( ) ; if ( pDlg ) pDlg -> Destroy ( ) ; return false ; } wxString strRebootPendingFile = GetRootDirectory ( ) + wxFileName :: GetPathSeparator ( ) + wxT ( " Reboot@@ Pending . txt " ) ; if ( wxFile :: Exists ( strRebootPendingFile ) ) { wxMessageDialog dialog ( NULL , _ ( " A ▁ reboot ▁ is ▁ required ▁ in ▁ order ▁ for ▁ BOINC ▁ to ▁ run ▁ properly . \n Please ▁ reboot ▁ your ▁ computer ▁ and ▁ try ▁ again . " ) , _ ( " BOINC ▁ Manager " ) , wxOK | wxICON_@@ ERROR ) ; dialog . ShowModal ( ) ; return false ; } if ( ! m_bMultipleInstancesOK ) { if ( DetectDuplicateInstance ( ) ) { return false ; } } m_pDocument = new CMainDocument ( ) ; wxASSERT ( m_pDocument ) ; m_pDocument -> OnInit ( ) ; if ( BOINC_SIMPLEGUI == m_iGUISelected ) { if ( wxGetDisplaySize ( ) . GetHeight ( ) < 600 ) { m_iGUISelected = BOINC_ADVANCEDGUI ; } } m_pTaskBarIcon = new CTaskBarIcon ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pTaskBarIcon ) ; m_pMacSystemMenu = new CMacSystemMenu ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationDisconnectedIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationSnoozeIcon ( ) ) ; wxASSERT ( m_pMacSystemMenu ) ; IdleTrackerAttach ( ) ; ProcessSerialNumber psn ; ProcessInfoRec pInfo ; OSStatus err ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & m_psnCurrentProcess , & pInfo ) ; if ( ! err ) { psn = pInfo . processLaun@@ cher ; memset ( & pInfo , 0 , sizeof ( pInfo ) ) ; pInfo . processInfoLength = sizeof ( ProcessInfoRec ) ; err = GetProcessInformation ( & psn , & pInfo ) ; } if ( pInfo . processSignature == ' lgn@@ w ' ) { m_bGUIVisible = false ; sleep ( 10 ) ; } SetActiveGUI ( m_iGUISelected , false ) ; if ( m_bGUIVisible ) { SetActiveGUI ( m_iGUISelected ) ; } else { ShowApplication ( false ) ; } if ( bOpenEventLog ) { DisplayEventLog ( m_bGUIVisible ) ; m_pFrame -> Raise ( ) ; } return true ; }
int CBOINCGUIApp :: OnExit ( ) { IdleTrackerDetach ( ) ; if ( m_pDocument ) { m_pDocument -> OnExit ( ) ; delete m_pDocument ; m_pDocument = NULL ; } m_pConfig -> SetPath ( wxT ( " / " ) ) ; if ( m_pSkinManager ) { m_pConfig -> Write ( wxT ( " Skin " ) , m_pSkinManager -> GetSelected@@ Skin ( ) ) ; delete m_pSkinManager ; } if ( m_pLocale ) { delete m_pLocale ; m_pLocale = NULL ; } if ( m_pEventLog ) { m_pEventLog -> Destroy ( ) ; m_pEventLog = NULL ; } m_pConfig -> Write ( wxT ( " AutomaticallyShutdownClient " ) , m_iShutdownCoreClient ) ; m_pConfig -> Write ( wxT ( " DisplayShutdownClientDialog " ) , m_iDisplayExitDialog ) ; m_pConfig -> Write ( wxT ( " DisableAutoStart " ) , m_iBOINCMGRDisableAutoStart ) ; diagnostics_@@ finish ( ) ; return wxApp :: OnExit ( ) ; }
void CBOINCGUIApp :: OnInitCmdLine ( wxCmdLineParser & parser ) { wxApp :: OnInitCmdLine ( parser ) ; static const wxCmdLine@@ EntryDesc cmdLineDesc [ ] = { { wxCMD_LINE_SWITCH , wxT ( " a " ) , wxT ( " autostart " ) , _ ( " BOINC ▁ Manager ▁ was ▁ started ▁ by ▁ the ▁ operating ▁ system ▁ auto@@ matically " ) } , || defined ( __WXMAC__ ) { wxCMD_LINE_SWITCH , wxT ( " s " ) , wxT ( " systray " ) , _ ( " Startup ▁ BOINC ▁ so ▁ only ▁ the ▁ system ▁ tray ▁ icon ▁ is ▁ visible " ) } , { wxCMD_LINE_OPTION , wxT ( " e " ) , wxT ( " clientdir " ) , _ ( " Directory ▁ containing ▁ the ▁ BOINC ▁ Client ▁ executable " ) } , { wxCMD_LINE_OPTION , wxT ( " d " ) , wxT ( " datadir " ) , _ ( " BOINC ▁ data ▁ directory " ) } , { wxCMD_LINE_OPTION , wxT ( " n " ) , wxT ( " namehost " ) , _ ( " Host ▁ name ▁ or ▁ IP ▁ address " ) } , { wxCMD_LINE_OPTION , wxT ( " g " ) , wxT ( " gui _ rpc _ port " ) , _ ( " GUI ▁ RPC ▁ port ▁ number " ) } , { wxCMD_LINE_OPTION , wxT ( " p " ) , wxT ( " password " ) , _ ( " Password " ) } , { wxCMD_LINE_OPTION , wxT ( " b " ) , wxT ( " boincargs " ) , _ ( " Startup ▁ BOINC ▁ with ▁ these ▁ optional ▁ arguments " ) } , { wxCMD_LINE_SWITCH , wxT ( " i " ) , wxT ( " insecure " ) , _ ( " disable ▁ BOINC ▁ security ▁ users ▁ and ▁ permissions " ) } , { wxCMD_LINE_SWITCH , wxT ( " c " ) , wxT ( " checkskins " ) , _ ( " set ▁ skin ▁ debugg@@ ing ▁ mode ▁ to ▁ enable ▁ skin ▁ manager ▁ error ▁ messages " ) } , { wxCMD_LINE_SWITCH , wxT ( " m " ) , wxT ( " multiple " ) , _ ( " multiple ▁ instances ▁ of ▁ BOINC ▁ Manager ▁ allowed " ) } , defined ( __WXMAC__ ) && defined ( _DEBUG ) ) { wxCMD_LINE_OPTION , wxT ( " NSDocument@@ Revis@@ ionsDebug@@ Mode " ) , NULL , _ ( " Not ▁ used : ▁ workaround ▁ for ▁ bug ▁ in ▁ XCode ▁ 4.2" ) } , { wxCMD_LINE_NONE } } ; parser . SetDesc ( cmdLineDesc ) ; }
bool CBOINCGUIApp :: OnCmdLineParsed ( wxCmdLineParser & parser ) { wxApp :: OnCmdLineParsed ( parser ) ; wxString portNum = wxEmptyString ; long longPort ; bool hostNameSpecified = false ; bool passwordSpecified = false ; parser . Found ( wxT ( " boincargs " ) , & m_strBOINCArguments ) ; if ( parser . Found ( wxT ( " autostart " ) ) ) { m_bBOINCMGRAutoStarted = true ; } || defined ( __WXMAC__ ) if ( parser . Found ( wxT ( " systray " ) ) ) { m_bGUIVisible = false ; } if ( parser . Found ( wxT ( " insecure " ) ) ) { g_use_sandbox = false ; } if ( parser . Found ( wxT ( " checkskins " ) ) ) { m_bDebugSkins = true ; } if ( parser . Found ( wxT ( " multiple " ) ) ) { m_bMultipleInstancesOK = true ; } ( defined ( __WXMSW__ ) || defined ( __WXMAC__ ) ) if ( ! parser . Found ( wxT ( " clientdir " ) , & m_strBOINCMGRRootDirectory ) ) { m_strBOINCMGRRootDirectory = :: wxGetCwd ( ) ; } if ( m_strBOINCMGRRootDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRRootDirectory . Append ( ' / ' ) ; } if ( ! parser . Found ( wxT ( " datadir " ) , & m_strBOINCMGRDataDirectory ) ) { m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory ; } if ( m_strBOINCMGRDataDirectory . Last ( ) != ' / ' ) { m_strBOINCMGRDataDirectory . Append ( ' / ' ) ; } if ( parser . Found ( wxT ( " namehost " ) , & m_strHostNameArg ) ) { hostNameSpecified = true ; } else { m_strHostNameArg = wxT ( " localhost " ) ; } if ( parser . Found ( wxT ( " gui _ rpc _ port " ) , & portNum ) ) { if ( portNum . ToLong ( & longPort ) ) { m_iRPCPortArg = longPort ; } else { m_iRPCPortArg = GUI_RPC_PORT ; } } else { m_iRPCPortArg = GUI_RPC_PORT ; } if ( parser . Found ( wxT ( " password " ) , & m_strPasswordArg ) ) { passwordSpecified = true ; } else { m_strPasswordArg = wxEmptyString ; } if ( hostNameSpecified && passwordSpecified ) { m_bMultipleInstancesOK = true ; } return true ; }
bool CBOINCGUIApp :: DetectDuplicateInstance ( ) { if ( CTaskBarIcon :: Fire@@ AppRestore ( ) ) { return true ; } ProcessSerialNumber PSN ; int iInstanceID = wxGetApp ( ) . IsAnotherInstanceRunning ( ) ; if ( iInstanceID ) { OSStatus err = GetProcess@@ ForPID ( iInstanceID , & PSN ) ; if ( ! err ) SetFrontProcess ( & PSN ) ; return true ; } return false ; }
void CBOINCGUIApp :: DetectExecutableName ( ) { TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { pszProg ++ ; } m_strBOINCMGRExecutableName = pszProg ; }
void CBOINCGUIApp :: DetectRootDirectory ( ) { TCHAR szPath [ MAX_PATH - 1 ] ; GetModuleFileName ( NULL , szPath , ( sizeof ( szPath ) / sizeof ( TCHAR ) ) ) ; TCHAR * pszProg = _tcsrchr ( szPath , ' \\ ' ) ; if ( pszProg ) { szPath [ pszProg - szPath + 1 ] = 0 ; } m_strBOINCMGRRootDirectory = szPath ; }
void CBOINCGUIApp :: DetectDataDirectory ( ) { LONG lReturnValue ; HKEY hkSetupHive ; LPTSTR lpszRegistryValue = NULL ; DWORD dwSize = 0 ; lReturnValue = RegOpen@@ KeyEx ( HKEY_@@ LOCAL_@@ MACH@@ INE , _T ( " SOF@@ TWAR@@ E\\@@ Space ▁ Sciences ▁ Laboratory , ▁ U . C . ▁ Berkele@@ y\\@@ BOINC ▁ Setup " ) , 0 , KEY_@@ READ , & hkSetupHive ) ; if ( lReturnValue == ERROR_SUCCESS ) { lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , NULL , & dwSize ) ; if ( lReturnValue != ERROR_FILE_NOT_FOUND ) { lpszRegistryValue = ( LPTSTR ) malloc ( dwSize ) ; ( * lpszRegistryValue ) = NULL ; lReturnValue = RegQueryValueEx ( hkSetupHive , _T ( " DATADIR " ) , NULL , NULL , ( LPBYTE ) lpszRegistryValue , & dwSize ) ; m_strBOINCMGRDataDirectory = lpszRegistryValue ; } } if ( hkSetupHive ) RegClose@@ Key ( hkSetupHive ) ; if ( lpszRegistryValue ) free ( lpszRegistryValue ) ; m_strBOINCMGRDataDirectory = wxT ( " / Library / Application ▁ Support / BOINC ▁ Data " ) ; }
void CBOINCGUIApp :: InitSupportedLanguages ( ) { wxInt32 iIndex = 0 ; const wxLanguageInfo * liLanguage = NULL ; m_astrLanguages . Insert ( wxEmptyString , 0 , wxLANGUAGE_USER_DEFINED + 1 ) ; m_astrLanguages [ wxLANGUAGE_@@ DEFAULT ] = _ ( " ( Automatic ▁ Detection ) " ) ; m_astrLanguages [ wxLANGUAGE_@@ UNKNOWN ] = _ ( " ( Unknown ) " ) ; m_astrLanguages [ wxLANGUAGE_USER_DEFINED ] = _ ( " ( User ▁ Defined ) " ) ; for ( iIndex = 0 ; iIndex <= wxLANGUAGE_USER_DEFINED ; iIndex ++ ) { liLanguage = wxLocale :: GetLanguageInfo ( iIndex ) ; if ( liLanguage ) { m_astrLanguages [ iIndex ] = liLanguage -> Description ; } } }
int CBOINCGUIApp :: IdleTrackerAttach ( ) { :: attach_idle_monitor ( ) ; return 0 ; }
int CBOINCGUIApp :: IdleTrackerDetach ( ) { :: detach_idle_monitor ( ) ; return 0 ; }
void CBOINCGUIApp :: OnActivateApp ( wxActivate@@ Event & event ) { if ( IsModalDialogDisplayed ( ) ) { event . Skip ( ) ; return ; } if ( event . GetActive ( ) ) { if ( m_pEventLog && ! m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) m_pFrame -> Raise ( ) ; } event . Skip ( ) ; }
void CBOINCGUIApp :: OnRPCFinished ( CRPC@@ FinishedEvent & event ) { CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxASSERT ( pDoc ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; pDoc -> OnRPC@@ Complete ( event ) ; }
int CBOINCGUIApp :: UpdateSystem@@ IdleDetection ( ) { return get_idle_@@ tick_count ( ) ; return TRUE ; }
int CBOINCGUIApp :: StartBOINC@@ ScreensaverTest ( ) { wxString strExecute = wxEmptyString ; wxChar szExecutableDirectory [ 4096 ] ; memset ( szExecutableDirectory , 0 , sizeof ( szExecutableDirectory ) ) ; GetWindowsDirectory ( szExecutableDirectory , ( sizeof ( szExecutableDirectory ) / sizeof ( wxChar ) ) ) ; strExecute = wxT ( " \ " " ) + wxString ( szExecutableDirectory ) + wxT ( " \ \ boinc . scr \ " ▁ / t " ) ; :: wxExecute ( strExecute ) ; return 0 ; }
int CBOINCGUIApp :: StartBOINC@@ DefaultScreensaverTest ( ) { wxString strExecute = wxEmptyString ; strExecute = wxT ( " \ " " ) + m_strBOINCMGRRootDirectory + wxT ( " \ \ boinc@@ scr . exe \ " ▁ - - test " ) ; :: wxExecute ( strExecute ) ; return 0 ; }
void CBOINCGUIApp :: DisplayEventLog ( bool bShowWindow ) { if ( m_pEventLog ) { if ( bShowWindow ) { if ( m_pEventLog -> IsIconized ( ) ) { m_pEventLog -> Iconize ( false ) ; } m_pEventLog -> Raise ( ) ; } } else { m_pEventLog = new CDlg@@ EventLog ( ) ; if ( m_pEventLog ) { m_pEventLog -> Show ( bShowWindow ) ; if ( bShowWindow ) { m_pEventLog -> Raise ( ) ; } if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } } } }
void CBOINCGUIApp :: OnEventLog@@ Close ( ) { m_pEventLog = NULL ; if ( m_pFrame ) { m_pFrame -> UpdateRefreshTimerInterval ( ) ; } }
void CBOINCGUIApp :: FireReloadSkin ( ) { if ( m_pFrame ) { m_pFrame -> FireReloadSkin ( ) ; } if ( m_pTaskBarIcon ) { m_pTaskBarIcon -> FireReloadSkin ( ) ; } }
bool CBOINCGUIApp :: SetActiveGUI ( int iGUISelection , bool bShowWindow ) { wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ Begin " ) ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ GUI ▁ Selection : ▁ ' % d ' , ▁ Show : ▁ % d ' " ) , iGUISelection , ( int ) bShowWindow ) ; CBOINCBaseFrame * pNewFrame = NULL ; CBOINCBaseFrame * pOldFrame = m_pFrame ; wxInt32 iTop = 0 ; wxInt32 iLeft = 0 ; wxInt32 iHeight = 0 ; wxInt32 iWidth = 0 ; if ( ( iGUISelection != m_iGUISelected ) || ! m_pFrame ) { if ( BOINC_ADVANCEDGUI == iGUISelection ) { m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; m_pConfig -> Read ( wxT ( " Width " ) , & iWidth , 800 ) ; m_pConfig -> Read ( wxT ( " Height " ) , & iHeight , 600 ) ; } else { m_pConfig -> SetPath ( wxT ( " / Simple " ) ) ; m_pConfig -> Read ( wxT ( " YPos " ) , & iTop , 30 ) ; m_pConfig -> Read ( wxT ( " XPos " ) , & iLeft , 30 ) ; iWidth = 409 ; iHeight = 561 ; iWidth = 416 ; iHeight = 570 ; } if ( ! IsWindow@@ OnScre@@ en ( iLeft , iTop , iWidth , iHeight ) ) { iTop = iLeft = 30 ; } if ( iLeft < 0 ) iLeft = 30 ; if ( iTop < 0 ) iTop = 30 ; wxInt32 iMaxWidth = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_@@ X ) ; wxInt32 iMaxHeight = wxSystemSettings :: GetMetric ( wxSYS_SCREEN_@@ Y ) ; if ( iLeft + iWidth > iMaxWidth ) iLeft = iMaxWidth - iWidth ; if ( iTop + iHeight > iMaxHeight ) iTop = iMaxHeight - iHeight ; if ( BOINC_ADVANCEDGUI == iGUISelection ) { pNewFrame = new CAdvancedFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } else { pNewFrame = new CSimpleFrame ( m_pSkinManager -> GetAdvanced ( ) -> GetApplicationName ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon ( ) , m_pSkinManager -> GetAdvanced ( ) -> GetApplicationIcon32 ( ) , wxPoint ( iLeft , iTop ) , wxSize ( iWidth , iHeight ) ) ; } wxASSERT ( pNewFrame ) ; if ( pNewFrame ) { SetTop@@ Window ( pNewFrame ) ; m_pFrame = pNewFrame ; if ( pOldFrame ) pOldFrame -> Hide ( ) ; if ( pOldFrame ) pOldFrame -> Destroy ( ) ; } } if ( m_pFrame && bShowWindow ) { if ( m_pEventLog ) { m_pEventLog -> Show ( ) ; m_pEventLog -> Raise ( ) ; :: SetForegroundWindow ( ( HWND ) m_pEventLog -> GetHWND ( ) ) ; } if ( ! m_pFrame -> IsShown ( ) ) { m_pFrame -> Show ( ) ; } if ( m_pFrame -> IsIconized ( ) ) { m_pFrame -> Maximize ( false ) ; } m_pFrame -> Raise ( ) ; :: SetForegroundWindow ( ( HWND ) m_pFrame -> GetHWND ( ) ) ; } m_iGUISelected = iGUISelection ; m_pConfig -> SetPath ( wxT ( " / " ) ) ; m_pConfig -> Write ( wxT ( " GUISelection " ) , iGUISelection ) ; wxLogTrace ( wxT ( " Function ▁ Start / End " ) , wxT ( " CBOINCGUIApp : : SetActiveGUI ▁ - ▁ Function ▁ End " ) ) ; return true ; }
int CBOINCGUIApp :: ConfirmExit ( ) { CSkinAdvanced * pSkinAdvanced = wxGetApp ( ) . GetSkinManager ( ) -> GetAdvanced ( ) ; CMainDocument * pDoc = wxGetApp ( ) . GetDocument ( ) ; wxString strConnectedCompter = wxEmptyString ; bool bWasVisible ; int retval = 0 ; wxASSERT ( pDoc ) ; wxASSERT ( pSkinAdvanced ) ; wxASSERT ( wxDynamicCast ( pDoc , CMainDocument ) ) ; wxASSERT ( wxDynamicCast ( pSkinAdvanced , CSkinAdvanced ) ) ; pDoc -> GetConnectedComputer@@ Name ( strConnectedCompter ) ; if ( ! pDoc -> IsComputer@@ NameLocal ( strConnectedCompter ) ) { return 1 ; } if ( s_bSkipExitConfirmation ) return 1 ; if ( IsMgr@@ MultipleInstance ( ) ) return 1 ; if ( ! m_iDisplayExitDialog ) { return 1 ; } bWasVisible = IsApplicationVisible ( ) ; ShowApplication ( true ) ; CDlg@@ ExitMessage dlg ( NULL ) ; if ( ! pSkinAdvanced -> GetExitMessage ( ) . IsEmpty ( ) ) { dlg . m_Dialog@@ ExitMessage -> SetLabel ( pSkinAdvanced -> GetExitMessage ( ) ) ; } if ( m_iShutdownCoreClient ) { dlg . m_DialogShutdownCoreClient -> SetValue ( TRUE ) ; } if ( m_iDisplayExitDialog ) { dlg . m_DialogDisplay -> SetValue ( FALSE ) ; } dlg . Fit ( ) ; dlg . Cent@@ re ( ) ; if ( wxID_@@ OK == dlg . ShowModal ( ) ) { s_bSkipExitConfirmation = true ; m_iShutdownCoreClient = dlg . m_DialogShutdownCoreClient -> GetValue ( ) ; m_iDisplayExitDialog = ! dlg . m_DialogDisplay -> GetValue ( ) ; retval = true ; } if ( ! bWasVisible ) { ShowApplication ( false ) ; } return retval ; }
int CBOINCGUIApp :: SafeMessageBox ( const wxString & message , const wxString & caption , long style , wxWindow * parent , int x , int y ) { int retval ; m_bSafeMessageBoxDisplayed ++ ; retval = wxMessageBox ( message , caption , style , parent , x , y ) ; m_bSafeMessageBoxDisplayed -- ; return retval ; }
int CBOINCGUIApp :: IsAnotherInstanceRunning ( ) { PROC_MAP pm ; int retval ; char myName [ 256 ] ; int otherInstanceID = 0 ; int myPid ; retval = proc@@ info_setup ( pm ) ; if ( retval ) return false ; myPid = ( int ) GetCurrentProcessId ( ) ; myPid = getpid ( ) ; myName [ 0 ] = 0 ; PROC_MAP :: iterator i ; for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) { strncpy ( myName , pi . command , sizeof ( myName ) ) ; break ; } } if ( myName [ 0 ] == 0 ) { return false ; } for ( i = pm . begin ( ) ; i != pm . end ( ) ; i ++ ) { PROCINFO & pi = i -> second ; if ( pi . id == myPid ) continue ; if ( ! strcmp ( pi . command , myName ) ) { otherInstanceID = pi . id ; break ; } } return otherInstanceID ; }
bool CBOINCGUIApp :: IsApplicationVisible ( ) { if ( IsProcess@@ Visible ( & m_psnCurrentProcess ) ) { return true ; } return false ; }
void CBOINCGUIApp :: ShowApplication ( bool bShow ) { if ( bShow ) { SetFrontProcess ( & m_psnCurrentProcess ) ; } else { ShowHide@@ Process ( & m_psnCurrentProcess , false ) ; } }
bool CBOINCGUIApp :: ShowInterface ( ) { return SetActiveGUI ( m_iGUISelected , true ) ; }
bool CBOINCGUIApp :: ShowNotific@@ ations ( ) { bool retval = false ; retval = SetActiveGUI ( m_iGUISelected , true ) ; if ( retval ) { GetFrame ( ) -> Fire@@ Notification ( ) ; GetDocument ( ) -> UpdateUnread@@ Notice@@ State ( ) ; } return retval ; }
bool CBOINCGUIApp :: IsModalDialogDisplayed ( ) { if ( m_bSafeMessageBoxDisplayed ) return true ; if ( wxDynamicCast ( wxWindow :: FindWindowById ( ID_ANYDI@@ ALOG ) , wxDialog ) ) { return true ; } if ( m_pDocument ) { if ( m_pDocument -> WaitingForRPC ( ) ) { return true ; } } return false ; }
void CBOINCGUIApp :: DeleteTaskBarIcon ( ) { if ( m_pTaskBarIcon ) { delete m_pTaskBarIcon ; } m_pTaskBarIcon = NULL ; }
void CBOINCGUIApp :: DeleteMacSystemMenu ( ) { if ( m_pMacSystemMenu ) { delete m_pMacSystemMenu ; } m_pMacSystemMenu = NULL ; }
int CBOINCGUIApp :: FilterEvent ( wxEvent & event ) { int theEventType ; wxDialog * theRPCWaitDialog ; wxObject * theObject ; if ( ! m_pDocument ) return - 1 ; theEventType = event . GetEventType ( ) ; if ( m_pDocument -> WaitingForRPC ( ) ) { if ( ( theEventType == wxEVT_COMMAND_@@ MENU_SEL@@ ECTED ) && ( event . GetId ( ) == wxID_@@ OPEN ) ) { return - 1 ; } theRPCWaitDialog = m_pDocument -> GetRPCWaitDialog ( ) ; theObject = event . GetEventObject ( ) ; while ( theObject ) { if ( ! theObject -> IsKind@@ Of ( CLASS@@ INFO ( wxWindow ) ) ) break ; if ( theObject == theRPCWaitDialog ) return - 1 ; theObject = ( ( wxWindow * ) theObject ) -> GetParent ( ) ; } } else { if ( ! m_bFilterEvents ) return - 1 ; } if ( event . IsCommandEvent ( ) ) { return false ; } if ( theEventType == wxEVT_TIMER ) { return false ; } if ( theEventType == wxEVT_TAS@@ KBAR_@@ MOVE ) { return false ; } return - 1 ; }
void TestIDNA :: debug ( const UChar * src , int32_t srcLength , int32_t options ) { UParseError parseError ; UErrorCode transStatus = U_ZERO_ERROR ; UErrorCode prepStatus = U_ZERO_ERROR ; NamePrepTransform * trans = NamePrepTransform :: createInstance ( parseError , transStatus ) ; int32_t prepOptions = ( ( ( options & UIDNA_ALLOW_UNASSIGNED ) != 0 ) ? USPREP_@@ ALLOW_UNASSIGNED : 0 ) ; LocalUString@@ PrepProfile@@ Pointer prep ( usprep_@@ openByType ( USPREP_@@ RFC@@ 349@@ 1_NAMEP@@ REP , & prepStatus ) ) ; UChar * transOut = NULL , * prepOut = NULL ; int32_t transOutLength = 0 , prepOutLength = 0 ; transOutLength = trans -> process ( src , srcLength , transOut , 0 , prepOptions > 0 , & parseError , transStatus ) ; if ( transStatus == U_BUFFER_OVERFLOW_ERROR ) { transStatus = U_ZERO_ERROR ; transOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * transOutLength ) ; transOutLength = trans -> process ( src , srcLength , transOut , transOutLength , prepOptions > 0 , & parseError , transStatus ) ; } prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , 0 , prepOptions , & parseError , & prepStatus ) ; if ( prepStatus == U_BUFFER_OVERFLOW_ERROR ) { prepStatus = U_ZERO_ERROR ; prepOut = ( UChar * ) malloc ( U_SIZEOF_UCHAR * prepOutLength ) ; prepOutLength = usprep_prepare ( prep . getAlias ( ) , src , srcLength , prepOut , prepOutLength , prepOptions , & parseError , & prepStatus ) ; } if ( UnicodeString ( transOut , transOutLength ) != UnicodeString ( prepOut , prepOutLength ) ) { errln ( " Failed . ▁ Expected : ▁ " + prettify ( UnicodeString ( transOut , transOutLength ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( prepOut , prepOutLength ) ) ) ; } free ( transOut ) ; free ( prepOut ) ; delete trans ; }
void TestIDNA :: testAPI ( const UChar * src , const UChar * expected , const char * testName , UBool useSTD3ASCIIRules , UErrorCode expectedStatus , UBool doCompare , UBool testUnassigned , TestFunc func , UBool testSTD3ASCIIRules ) { UErrorCode status = U_ZERO_ERROR ; UChar destStack [ MAX_DEST_SIZE ] ; int32_t destLen = 0 ; UChar * dest = NULL ; int32_t expectedLen = ( expected != NULL ) ? u_strlen ( expected ) : 0 ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; int32_t tSrcLen = 0 ; UChar * tSrc = NULL ; if ( src != NULL ) { tSrcLen = u_strlen ( src ) ; tSrc = ( UChar * ) malloc ( U_SIZEOF_UCHAR * tSrcLen ) ; memcpy ( tSrc , src , tSrcLen * U_SIZEOF_UCHAR ) ; } destLen = func ( src , - 1 , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected ▁ : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errcheckln ( status , " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; free ( tSrc ) ; return ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ " + prettify ( src ) + " ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) + " Got : ▁ " + prettify ( UnicodeString ( dest , destLen ) ) ) ; debug ( src , - 1 , options | UIDNA_ALLOW_UNASSIGNED ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } if ( testUnassigned ) { status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } status = U_ZERO_ERROR ; if ( testSTD3ASCIIRules == TRUE ) { destLen = func ( src , - 1 , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , - 1 , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ both ▁ options ▁ set . ▁ Expected : ▁ " + prettify ( UnicodeString ( expected , expectedLen ) ) ) ; } } else { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } status = U_ZERO_ERROR ; destLen = func ( tSrc , tSrcLen , NULL , 0 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; if ( destLen + 1 < MAX_DEST_SIZE ) { dest = destStack ; destLen = func ( src , u_strlen ( src ) , dest , destLen + 1 , options | UIDNA_USE_STD3_RULES , & parseError , & status ) ; if ( U_SUCCESS ( status ) && ( doCompare == TRUE ) && u_strCaseCompare ( dest , destLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ source ▁ length ▁ and ▁ both ▁ options ▁ set . \n " , testName ) ; } } else { errln ( " % s ▁ with ▁ source ▁ length ▁ ▁ failed . ▁ Requires ▁ destCapacity ▁ > ▁ 300 \n " , testName ) ; } } if ( status != expectedStatus && expectedStatus != U_IDNA_UNASSIGNED_ERROR ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ error ▁ for ▁ " + UnicodeString ( testName ) + " ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set . ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expectedStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( status ) ) + " ▁ Source : ▁ " + prettify ( UnicodeString ( src ) ) ) ; } } free ( tSrc ) ; }
void TestIDNA :: testCompare ( const UChar * s1 , int32_t s1Len , const UChar * s2 , int32_t s2Len , const char * testName , CompareFunc func , UBool isEqual ) { UErrorCode status = U_ZERO_ERROR ; int32_t retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , - 1 , s2 , - 1 , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ null ▁ termniated ▁ strings ▁ with ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ and ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_DEFAULT , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } status = U_ZERO_ERROR ; retVal = func ( s1 , s1Len , s2 , s2Len , UIDNA_ALLOW_UNASSIGNED , & status ) ; if ( isEqual == TRUE && retVal != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ result ▁ for ▁ % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . \n " , testName ) ; } if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ with ▁ string ▁ length ▁ and ▁ options ▁ set . ▁ Error : ▁ % s " , u_errorName ( status ) , testName ) ; } }
void TestIDNA :: testToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( unicodeIn [ i ] , buf , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } }
void TestIDNA :: testToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testAPI ( buf , unicodeIn [ i ] , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; } }
void TestIDNA :: testIDNToUnicode ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } }
void TestIDNA :: testIDNToASCII ( const char * testName , TestFunc func ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; UErrorCode status = U_ZERO_ERROR ; int32_t bufLen = 0 ; UParseError parseError ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( domainNames ) / sizeof ( domainNames [ 0 ] ) ) ; i ++ ) { bufLen = ( int32_t ) strlen ( domainNames [ i ] ) ; bufLen = u_unescape ( domainNames [ i ] , buf , bufLen + 1 ) ; func ( buf , bufLen , expected , MAX_DEST_SIZE , UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s " , testName , i , u_errorName ( status ) ) ; break ; } testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , TRUE , TRUE , func ) ; testAPI ( buf , expected , testName , FALSE , U_ZERO_ERROR , FALSE , TRUE , func ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ failed ▁ to ▁ convert ▁ domainNames [ % i ] . Error : ▁ % s ▁ \n " , testName , i , u_errorName ( status ) ) ; break ; } } }
void TestIDNA :: testCompare ( const char * testName , CompareFunc func ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } }
void TestIDNA :: testErrorCases ( const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { UChar buf [ MAX_DEST_SIZE ] ; int32_t bufLen = 0 ; for ( int32_t i = 0 ; i < ( int32_t ) ( sizeof ( errorCases ) / sizeof ( errorCases [ 0 ] ) ) ; i ++ ) { ErrorCases errorCase = errorCases [ i ] ; UChar * src = NULL ; if ( errorCase . ascii != NULL ) { bufLen = ( int32_t ) strlen ( errorCase . ascii ) ; u_charsToUChars ( errorCase . ascii , buf , bufLen + 1 ) ; } else { bufLen = 1 ; memset ( buf , 0 , U_SIZEOF_UCHAR * MAX_DEST_SIZE ) ; } if ( errorCase . unicode [ 0 ] != 0 ) { src = errorCase . unicode ; } testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToASCII ) ; if ( errorCase . testLabel == TRUE ) { testAPI ( src , buf , IDNToASCIIName , errorCase . useSTD3ASCIIRules , errorCase . expected , FALSE , TRUE , IDNToASCII ) ; } if ( errorCase . testToUnicode == TRUE ) { testAPI ( ( src == NULL ) ? NULL : buf , src , IDNToUnicodeName , errorCase . useSTD3ASCIIRules , errorCase . expected , TRUE , TRUE , IDNToUnicode ) ; } } }
void TestIDNA :: testChaining ( const UChar * src , int32_t numIterations , const char * testName , UBool useSTD3ASCIIRules , UBool caseInsensitive , TestFunc func ) { UChar even [ MAX_DEST_SIZE ] ; UChar odd [ MAX_DEST_SIZE ] ; UChar expected [ MAX_DEST_SIZE ] ; int32_t i = 0 , evenLen = 0 , oddLen = 0 , expectedLen = 0 ; UErrorCode status = U_ZERO_ERROR ; int32_t srcLen = u_strlen ( src ) ; int32_t options = ( useSTD3ASCIIRules == TRUE ) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT ; UParseError parseError ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , - 1 , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , - 1 , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , - 1 , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errln ( " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ source ▁ with ▁ source ▁ length ▁ failed \n " , testName ) ; } } status = U_ZERO_ERROR ; expectedLen = func ( src , srcLen , expected , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ null ▁ terminated ▁ source ▁ with ▁ options ▁ set ▁ failed . ▁ Error : ▁ % s " , testName , u_errorName ( status ) ) ; } memcpy ( odd , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; memcpy ( even , expected , ( expectedLen + 1 ) * U_SIZEOF_UCHAR ) ; for ( ; i <= numIterations ; i ++ ) { if ( ( i % 2 ) == 0 ) { evenLen = func ( odd , oddLen , even , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } else { oddLen = func ( even , evenLen , odd , MAX_DEST_SIZE , options | UIDNA_ALLOW_UNASSIGNED , & parseError , & status ) ; if ( U_FAILURE ( status ) ) { errcheckln ( status , " % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed ▁ - ▁ % s " , testName , u_errorName ( status ) ) ; break ; } } } if ( caseInsensitive == TRUE ) { if ( u_strCaseCompare ( even , evenLen , expected , expectedLen , 0 , & status ) != 0 || u_strCaseCompare ( odd , oddLen , expected , expectedLen , 0 , & status ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } else { if ( u_strncmp ( even , expected , expectedLen ) != 0 || u_strncmp ( odd , expected , expectedLen ) != 0 ) { errln ( " Chaining ▁ for ▁ % s ▁ ▁ source ▁ with ▁ source ▁ length ▁ and ▁ options ▁ set ▁ failed \n " , testName ) ; } } }
void TestIDNA :: testChaining ( const char * toASCIIName , TestFunc toASCII , const char * toUnicodeName , TestFunc toUnicode ) { int32_t i ; UChar buf [ MAX_DEST_SIZE ] ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( asciiIn ) / sizeof ( asciiIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; testChaining ( buf , 5 , toUnicodeName , FALSE , FALSE , toUnicode ) ; } for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { testChaining ( unicodeIn [ i ] , 5 , toASCIIName , FALSE , TRUE , toASCII ) ; } }
void TestIDNA :: testRootLabelSeparator ( const char * testName , CompareFunc func , const char * IDNToASCIIName , TestFunc IDNToASCII , const char * IDNToUnicodeName , TestFunc IDNToUnicode ) { int32_t i ; UChar www [ ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UChar com [ ] = { 0x002E , 0x0043 , 0x004F , 0x004D , 0x002E , 0x0000 } ; UChar buf [ MAX_DEST_SIZE ] = { 0x0057 , 0x0057 , 0x0057 , 0x002E , 0x0000 } ; UnicodeString source ( www ) , uni0 ( www ) , uni1 ( www ) , ascii0 ( www ) , ascii1 ( www ) ; uni0 . append ( unicodeIn [ 0 ] ) ; uni0 . append ( com ) ; uni0 . append ( ( UChar ) 0x0000 ) ; uni1 . append ( unicodeIn [ 1 ] ) ; uni1 . append ( com ) ; uni1 . append ( ( UChar ) 0x0000 ) ; ascii0 . append ( asciiIn [ 0 ] ) ; ascii0 . append ( com ) ; ascii0 . append ( ( UChar ) 0x0000 ) ; ascii1 . append ( asciiIn [ 1 ] ) ; ascii1 . append ( com ) ; ascii1 . append ( ( UChar ) 0x0000 ) ; for ( i = 0 ; i < ( int32_t ) ( sizeof ( unicodeIn ) / sizeof ( unicodeIn [ 0 ] ) ) ; i ++ ) { u_charsToUChars ( asciiIn [ i ] , buf + 4 , ( int32_t ) ( strlen ( asciiIn [ i ] ) + 1 ) ) ; u_strcat ( buf , com ) ; source . truncate ( 4 ) ; source . append ( unicodeIn [ i ] ) ; source . append ( com ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; int32_t srcLen = u_strlen ( src ) ; testCompare ( src , srcLen , buf , u_strlen ( buf ) , testName , func , TRUE ) ; testCompare ( src , srcLen , src , srcLen , testName , func , TRUE ) ; testAPI ( src , buf , IDNToASCIIName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToASCII ) ; testAPI ( buf , src , IDNToUnicodeName , FALSE , U_ZERO_ERROR , TRUE , TRUE , IDNToUnicode ) ; if ( i == 0 ) { testCompare ( src , srcLen , uni1 . getBuffer ( ) , uni1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , uni0 . getBuffer ( ) , uni0 . length ( ) - 1 , testName , func , FALSE ) ; } if ( i == 0 ) { testCompare ( src , srcLen , ascii1 . getBuffer ( ) , ascii1 . length ( ) - 1 , testName , func , FALSE ) ; } else { testCompare ( src , srcLen , ascii0 . getBuffer ( ) , ascii0 . length ( ) - 1 , testName , func , FALSE ) ; } } }
void TestIDNA :: runIndexedTest ( int32_t index , UBool exec , const char * & name , char * par ) { if ( exec ) logln ( ( UnicodeString ) " TestSuite ▁ IDNA ▁ API ▁ " ) ; switch ( index ) { case 0 : name = " TestToASCII " ; if ( exec ) TestToASCII ( ) ; break ; case 1 : name = " TestToUnicode " ; if ( exec ) TestToUnicode ( ) ; break ; case 2 : name = " TestIDNToASCII " ; if ( exec ) TestIDNToASCII ( ) ; break ; case 3 : name = " TestIDNToUnicode " ; if ( exec ) TestIDNToUnicode ( ) ; break ; case 4 : name = " TestCompare " ; if ( exec ) TestCompare ( ) ; break ; case 5 : name = " TestErrorCases " ; if ( exec ) TestErrorCases ( ) ; break ; case 6 : name = " TestChaining " ; if ( exec ) TestChaining ( ) ; break ; case 7 : name = " TestRootLabelSeparator " ; if ( exec ) TestRootLabelSeparator ( ) ; break ; case 8 : name = " TestCompareReferenceImpl " ; if ( exec ) TestCompareReferenceImpl ( ) ; break ; case 9 : name = " TestDataFile " ; if ( exec ) TestDataFile ( ) ; break ; UCONFIG_NO@@ _FILE_IO && ! UCONFIG_NO_LEGAC@@ Y_CONVERSION case 10 : name = " TestRefIDNA " ; if ( exec ) TestRefIDNA ( ) ; break ; case 11 : name = " TestIDNAMonkeyTest " ; if ( exec ) TestIDNAMonkeyTest ( ) ; break ; case 10 : case 11 : name = " skip " ; break ; case 12 : { name = " TestConformance@@ TestVector@@ s " ; if ( exec ) { logln ( " TestSuite ▁ IDNA ▁ conf - - - - " ) ; logln ( ) ; Idna@@ ConfTest test ; callTest ( test , par ) ; } break ; } case 13 : name = " UTS46Test " ; if ( exec ) { logln ( " TestSuite ▁ UTS46Test - - - " ) ; logln ( ) ; LocalPointer < IntlTest > test ( createUTS46Test ( ) ) ; callTest ( * test , par ) ; } break ; default : name = " " ; break ; } }
void TestIDNA :: TestToASCII ( ) { testToASCII ( " uidna _ toASCII " , uidna_toASCII ) ; }
void TestIDNA :: TestToUnicode ( ) { testToUnicode ( " uidna _ toUnicode " , uidna_toUnicode ) ; }
void TestIDNA :: TestIDNToASCII ( ) { testIDNToASCII ( " uidna _ IDNToASCII " , uidna_IDNToASCII ) ; }
void TestIDNA :: TestIDNToUnicode ( ) { testIDNToUnicode ( " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestCompare ( ) { testCompare ( " uidna _ compare " , uidna_compare ) ; }
void TestIDNA :: TestErrorCases ( ) { testErrorCases ( " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestRootLabelSeparator ( ) { testRootLabelSeparator ( " uidna _ compare " , uidna_compare , " uidna _ IDNToASCII " , uidna_IDNToASCII , " uidna _ IDNToUnicode " , uidna_IDNToUnicode ) ; }
void TestIDNA :: TestChaining ( ) { testChaining ( " uidna _ toASCII " , uidna_toASCII , " uidna _ toUnicode " , uidna_toUnicode ) ; }
UnicodeString TestIDNA :: testCompareReferenceImpl ( UnicodeString & src , TestFunc refIDNA , const char * refIDNAName , TestFunc uIDNA , const char * uIDNAName , int32_t options ) { const UChar * srcUChars = src . getBuffer ( ) ; UChar exp [ MAX_DEST_SIZE ] = { 0 } ; int32_t expCap = MAX_DEST_SIZE , expLen = 0 ; UErrorCode expStatus = U_ZERO_ERROR ; UParseError parseError ; logln ( " Comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; expLen = refIDNA ( srcUChars , src . length ( ) - 1 , exp , expCap , options , & parseError , & expStatus ) ; UChar got [ MAX_DEST_SIZE ] = { 0 } ; int32_t gotCap = MAX_DEST_SIZE , gotLen = 0 ; UErrorCode gotStatus = U_ZERO_ERROR ; gotLen = uIDNA ( srcUChars , src . length ( ) - 1 , got , gotCap , options , & parseError , & gotStatus ) ; if ( expStatus != gotStatus ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ status ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + UnicodeString ( u_errorName ( expStatus ) ) + " ▁ Got : ▁ " + UnicodeString ( u_errorName ( gotStatus ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; return UnicodeString ( " " ) ; } if ( U_SUCCESS ( expStatus ) ) { if ( u_strCompare ( exp , expLen , got , gotLen , TRUE ) != 0 ) { errln ( " Did ▁ not ▁ get ▁ the ▁ expected ▁ output ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ Expected : ▁ " + prettify ( UnicodeString ( exp , expLen ) ) + " ▁ Got : ▁ " + prettify ( UnicodeString ( got , gotLen ) ) + " ▁ for ▁ Source : ▁ " + prettify ( srcUChars ) + " ▁ Options : ▁ " + options ) ; } return UnicodeString ( exp , expLen ) ; } else { logln ( " Got ▁ the ▁ same ▁ error ▁ while ▁ comparing ▁ " + UnicodeString ( refIDNAName ) + " ▁ with ▁ " + UnicodeString ( uIDNAName ) + " ▁ for ▁ input : ▁ " + prettify ( srcUChars ) ) ; } return UnicodeString ( " " ) ; }
void TestIDNA :: testCompareReferenceImpl ( const UChar * src , int32_t srcLen ) { UnicodeString label ( src , srcLen ) ; label . append ( ( UChar ) 0x0000 ) ; UnicodeString asciiLabel = testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( label , idnaref_toASCII , " idnaref _ toASCII " , uidna_toASCII , " uidna _ toASCII " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; if ( asciiLabel . length ( ) != 0 ) { asciiLabel . append ( ( UChar ) 0x0000 ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_ALLOW_UNASSIGNED ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_DEFAULT ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES ) ; testCompareReferenceImpl ( asciiLabel , idnaref_toUnicode , " idnaref _ toUnicode " , uidna_toUnicode , " uidna _ toUnicode " , UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED ) ; } }
void TestIDNA :: TestIDNAMonkeyTest ( ) { UnicodeString source ; UErrorCode status = U_ZERO_ERROR ; int i ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; return ; } for ( i = 0 ; i < loopCount ; i ++ ) { source . truncate ( 0 ) ; getTestSource ( source ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } for ( i = 0 ; i < ( int ) ( sizeof ( failures ) / sizeof ( failures [ 0 ] ) ) ; i ++ ) { source . truncate ( 0 ) ; source . append ( UnicodeString ( failures [ i ] , - 1 , US_INV ) ) ; source = source . unescape ( ) ; source . append ( ( UChar ) 0x0000 ) ; const UChar * src = source . getBuffer ( ) ; testCompareReferenceImpl ( src , source . length ( ) - 1 ) ; } source . truncate ( 0 ) ; source . append ( UNICODE_@@ STRING@@ _SIMPLE ( " \\uCF@@ 18\\U0002@@ 1161\\U000@@ EEF11@@ \\U0002@@ BB82\\U000@@ 1D@@ 63@@ C " ) ) ; debug ( source . getBuffer ( ) , source . length ( ) , UIDNA_ALLOW_UNASSIGNED ) ; { UnicodeString source ( " \\u043f\\u00@@ AD\\u@@ 034f\\u043e\\u04@@ 47\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; source = source . unescape ( ) ; UnicodeString expected ( " \\u043f\\u043e\\u04@@ 47\\u0435\\u043c\\u0443\\u0436\\u0435\\u043e\\u043d\\u0438\\u043d\\u0435\\u0433\\u043e\\u0432\\u043e\\u0440\\u044f\\u0442\\u043f\\u043e\\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0000" , - 1 , US_INV ) ; expected = expected . unescape ( ) ; UnicodeString ascii ( " xn - - b1abfaaepdrnnbgefbadotcwatmq2g4l " ) ; ascii . append ( ( UChar ) 0x0000 ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " uidna _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , uidna_toASCII ) ; testAPI ( source . getBuffer ( ) , ascii . getBuffer ( ) , " idnaref _ toASCII " , FALSE , U_ZERO_ERROR , TRUE , TRUE , idnaref_toASCII ) ; testCompareReferenceImpl ( source . getBuffer ( ) , source . length ( ) - 1 ) ; } }
void TestIDNA :: TestCompareReferenceImpl ( ) { UChar src [ 2 ] = { 0 , 0 } ; int32_t srcLen = 0 ; for ( int32_t i = 0x40000 ; i < 0x10ffff ; i ++ ) { if ( quick == TRUE && i > 0x1FFFF ) { return ; } if ( i >= 0x30000 && i <= 0xF@@ 0000 ) { i += 0xB0000 ; } if ( i > 0xFFFF ) { src [ 0 ] = U16_@@ LEAD ( i ) ; src [ 1 ] = U16_@@ TRAIL ( i ) ; srcLen = 2 ; } else { src [ 0 ] = ( UChar ) i ; src [ 1 ] = 0 ; srcLen = 1 ; } testCompareReferenceImpl ( src , srcLen ) ; } }
void TestIDNA :: TestRefIDNA ( ) { UErrorCode status = U_ZERO_ERROR ; getInstance ( status ) ; if ( U_FAILURE ( status ) ) { if ( status == U_FILE_ACCESS_ERROR ) { dataerrln ( " Test ▁ could ▁ not ▁ initialize . ▁ Got ▁ % s " , u_errorName ( status ) ) ; } return ; } testToASCII ( " idnaref _ toASCII " , idnaref_toASCII ) ; testToUnicode ( " idnaref _ toUnicode " , idnaref_toUnicode ) ; testIDNToASCII ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII ) ; testIDNToUnicode ( " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testCompare ( " idnaref _ compare " , idnaref_compare ) ; testErrorCases ( " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; testRootLabelSeparator ( " idnaref _ compare " , idnaref_compare , " idnaref _ IDNToASCII " , idnaref_IDNToASCII , " idnaref _ IDNToUnicode " , idnaref_IDNToUnicode ) ; testChaining ( " idnaref _ toASCII " , idnaref_toASCII , " idnaref _ toUnicode " , idnaref_toUnicode ) ; }
void TestIDNA :: TestDataFile ( ) { testData ( * this ) ; }
TestIDNA :: ~ TestIDNA ( ) { if ( gPrep != NULL ) { delete gPrep ; gPrep = NULL ; } }
NamePrepTransform * TestIDNA :: getInstance ( UErrorCode & status ) { if ( TestIDNA :: gPrep == NULL ) { UParseError parseError ; TestIDNA :: gPrep = NamePrepTransform :: createInstance ( parseError , status ) ; if ( TestIDNA :: gPrep == NULL ) { return NULL ; } } return TestIDNA :: gPrep ; }
