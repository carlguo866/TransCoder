void DistanceStatComputer :: Calc@@ Speed ( DistanceStat & data , fixed time ) { if ( positive ( time ) && data . IsDefined ( ) ) data . speed = data . GetDi@@ stance ( ) / time ; else data . speed = fixed ( 0 ) ; }
void Lowering :: LowerRotate ( GenTreePtr tree ) { NYI_ARM ( " ARM ▁ Lowering ▁ for ▁ ROL ▁ and ▁ ROR " ) ; }
void Lowering :: TreeNode@@ InfoInit ( GenTree * stmt ) { NY@@ I ( " ARM ▁ TreeNodInfoInit " ) ; }
bool Lowering :: isRM@@ WReg@@ Oper ( GenTreePtr tree ) { return false ; }
bool Lowering :: IsCall@@ TargetInRange ( void * addr ) { return comp -> codeGen -> validImm@@ ForBL ( ( ssize_t ) addr ) ; }
bool Lowering :: IsContainableImmed ( GenTree * parentNode , GenTree * childNode ) { NYI_ARM ( " ARM ▁ IsContainableImmed " ) ; return false ; }
return std :: count_if ( m_employees . cbegin ( ) , m_employees . cend ( ) , [ this , & teamName ] ( const Person & p ) { return teamNameFor ( p ) == teamName ; }
bool DictionaryPopupInfo :: decode ( CoreIPC :: ArgumentDecoder * decoder , DictionaryPopupInfo & result ) { if ( ! decoder -> decode ( result . origin ) ) return false ; if ( ! decoder -> decode ( result . fontInfo ) ) return false ; if ( ! decoder -> decode@@ Enum ( result . type ) ) return false ; ( MAC ) && ! defined ( BUILDING_ON_SNOW_LEOPARD ) if ( ! CoreIPC :: decode ( decoder , result . options ) ) return false ; return true ; }
void ctkPluginGeneratorUiPlugin :: start ( ctkPluginContext * context ) { mainExtension = new ctkPluginGeneratorMainExtension ( ) ; ctkDictionary props ; props . insert ( ctkPluginConstants :: SERVICE_RANKING , 0 ) ; context -> registerService ( QStringList ( " ctkPluginGeneratorAbstractUi@@ Extension " ) , mainExtension , props ) ; qDebug ( ) << " Registered ▁ Main ▁ Extension " ; }
void ctkPluginGeneratorUiPlugin :: stop ( ctkPluginContext * context ) { Q_UNUSED ( context ) delete mainExtension ; }
void CIconNavReceive :: save ( SimpleFile * file , int indent ) { file -> writeNumber@@ Line ( 1 , indent ) ; CPetGraphic :: save ( file , indent ) ; }
void CIconNavReceive :: load ( SimpleFile * file ) { file -> readNumber ( ) ; CPetGraphic :: load ( file ) ; }
b2StackAllocator :: b2StackAllocator ( ) { m_index = 0 ; m_allocation = 0 ; m_maxAllocation = 0 ; m_entryCount = 0 ; }
b2StackAllocator :: ~ b2StackAllocator ( ) { b2Assert ( m_index == 0 ) ; b2Assert ( m_entryCount == 0 ) ; }
void * b2StackAllocator :: Allocate ( int32 size ) { b2Assert ( m_entryCount < b2_@@ maxStack@@ Entries ) ; b2StackEntry * entry = m_entries + m_entryCount ; entry -> size = size ; if ( m_index + size > b2_@@ stackSize ) { entry -> data = ( char * ) b2Alloc ( size ) ; entry -> usedMalloc = true ; } else { entry -> data = m_data + m_index ; entry -> usedMalloc = false ; m_index += size ; } m_allocation += size ; m_maxAllocation = b2Max ( m_maxAllocation , m_allocation ) ; ++ m_entryCount ; return entry -> data ; }
void b2StackAllocator :: Free ( void * p ) { b2Assert ( m_entryCount > 0 ) ; b2StackEntry * entry = m_entries + m_entryCount - 1 ; b2Assert ( p == entry -> data ) ; if ( entry -> usedMalloc ) { b2Free ( p ) ; } else { m_index -= entry -> size ; } m_allocation -= entry -> size ; -- m_entryCount ; p = NULL ; }
AAnnihilator :: AAnnihilator ( const FObjectInitializer & ObjectInitializer ) : Super ( ObjectInitializer ) { static ConstructorHelpers :: FObjectFinder < USkeletalMesh > SkeletalMeshObject ( TEXT ( " SkeletalMesh ' / Game / VFX / sphere _ skeletal . sphere _ skeletal ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > StaticMeshObject ( TEXT ( " StaticMesh ' / Game / Weapons / Ranged / Anni . Anni ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UStaticMesh > Offhand@@ MeshObject ( TEXT ( " StaticMesh ' / Game / VFX / sphere . sphere ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > LargeIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator . WeaponIcon _ Annihilator ' " ) ) ; static ConstructorHelpers :: FObjectFinder < UTexture2D > SmallIconObject ( TEXT ( " Texture2D ' / Game / Blueprints / Widgets / UI - Images / Icons _ Gear / WeaponIcon _ Annihilator - small . WeaponIcon _ Annihilator - small ' " ) ) ; Name = EMasterGear@@ List :: GL_Annihilator ; NameText = LOCTEXT ( " Annihilator@@ Name " , " Annihilator " ) ; Type = EMasterGear@@ Types :: GT_@@ Ranged ; TypeText = LOCTEXT ( " Annihilator@@ Type " , " Ranged " ) ; Description = " An ▁ embodi@@ ment ▁ of ▁ the ▁ Ethereal ▁ Virt@@ ue : ▁ Wrath . " ; Price = 40000 ; MPCost = 0.0f ; ATK = 50.0f ; DEF = 40.0f ; SPD = 20.0f ; HP = 500.0f ; MP = 250.0f ; Large@@ Icon = LargeIconObject . Object ; SmallIcon = SmallIconObject . Object ; SK_WeaponSkeletalMesh = SkeletalMeshObject . Object ; SM_WeaponStaticMesh = StaticMeshObject . Object ; SM_WeaponOffhandMesh = StaticMeshObject . Object ; WeaponSkeletalMesh -> SetSkeletalMesh ( SK_WeaponSkeletalMesh ) ; WeaponSkeletalMesh -> SetHiddenInGame ( true ) ; WeaponStaticMesh -> SetStaticMesh ( SM_WeaponStaticMesh ) ; WeaponStaticMesh -> SetWorld@@ Scale3D ( FVector ( 0.15f , 0.15f , 0.15f ) ) ; WeaponStaticMesh -> SetRelative@@ Location ( FVector ( 20 , - 2 , - 2 ) ) ; WeaponStaticMesh -> SetRelative@@ Rotation ( FRot@@ ator ( - 12 , - 90 , - 75 ) ) ; WeaponOffhandMesh -> SetStaticMesh ( SM_WeaponOffhandMesh ) ; WeaponOffhandMesh -> SetHiddenInGame ( true ) ; }
void AAnnihilator :: BeginPlay ( ) { Super :: BeginPlay ( ) ; OnBind@@ Gear . AddDynamic ( this , & AAnnihilator :: BindWeapon ) ; }
void AAnnihilator :: BindWeapon ( ) { if ( IsShown ) { ShowWeapon ( false , true , false ) ; } }
QgsFieldValidator :: QgsFieldValidator ( QObject * parent , const QgsField & field , QString dateFormat ) : QValidator ( parent ) , mField ( field ) , mDateFormat ( dateFormat ) { switch ( mField . type ( ) ) { case QVariant :: Int : { if ( mField . length ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QInt@@ Validator ( parent ) ; } } break ; case QVariant :: Double : { if ( mField . length ( ) > 0 && mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } ( \\ . \\d { 0 , % 2 } ) ? " ) . arg ( mField . length ( ) - mField . precision ( ) ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . length ( ) > 0 && mField . precision ( ) == 0 ) { QString re = QString ( " - ? \\d { 0 , % 1 } " ) . arg ( mField . length ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else if ( mField . precision ( ) > 0 ) { QString re = QString ( " - ? \\d * ( \\ . \\d { 0 , % 1 } ) ? " ) . arg ( mField . precision ( ) ) ; mValidator = new QRegExpValidator ( QRegExp ( re ) , parent ) ; } else { mValidator = new QDouble@@ Validator ( parent ) ; } } break ; case QVariant :: LongLong : mValidator = new QgsLong@@ LongValidator ( parent ) ; break ; default : mValidator = 0 ; } QSettings settings ; mNullValue = settings . value ( " qgis / nullValue " , " NULL " ) . toString ( ) ; }
QgsFieldValidator :: ~ QgsFieldValidator ( ) { delete mValidator ; }
void JSDocument :: setLocation ( ExecState * exec , JSValue value ) { Frame * frame = static_cast < Document * > ( impl ( ) ) -> frame ( ) ; if ( ! frame ) return ; String locationString = value . toString ( exec ) -> value ( exec ) ; if ( exec -> had@@ Exception ( ) ) return ; if ( Location * location = frame -> document ( ) -> domWindow ( ) -> location ( ) ) location -> setH@@ ref ( locationString , activeDOMWindow ( exec ) , firstDOMWindow ( exec ) ) ; }
mscorlib :: System :: String SoapNmtoken :: GetXsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " GetXsdType " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; }
mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken SoapNmtoken :: Parse ( const char * value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( " mscorlib " , " System " , " String " ) ; __parameters__ [ 0 ] = mono@@ _string_@@ new ( Global :: GetDo@@ main ( ) , value ) ; MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " Parse " , NullMonoObject , 1 , __parameter_types__ , __parameters__ , NULL ) ; return mscorlib :: System :: Runtime :: Remoting :: Metadata :: W3cXsd2001 :: SoapNmtoken ( __result__ ) ; }
mscorlib :: System :: String SoapNmtoken :: ToString ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " ToString " , __native_object__ , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
void SoapNmtoken :: set_Value ( mscorlib :: System :: String value ) { MonoType * __parameter_types__ [ 1 ] ; void * __parameters__ [ 1 ] ; __parameter_types__ [ 0 ] = Global :: GetType ( typeid ( value ) . name ( ) ) ; __parameters__ [ 0 ] = ( MonoObject * ) value ; Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " set _ Value " , __native_object__ , 1 , __parameter_types__ , __parameters__ , NULL ) ; }
mscorlib :: System :: String SoapNmtoken :: get_XsdType ( ) { MonoObject * __result__ = Global :: InvokeMethod ( " mscorlib " , " System . Runtime . Remoting . Metadata . W3cXsd2001" , " SoapNmtoken " , 0 , NULL , " get _ XsdType " , NullMonoObject , 0 , NULL , NULL , NULL ) ; return mscorlib :: System :: String ( __result__ ) ; }
void SoapNmtoken :: set_XsdType ( mscorlib :: System :: String value ) { throw ; }
bool JlCompress :: compressFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QFile inFile ; inFile . setFileName ( fileName ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) ) return false ; QuaZipFile outFile ( zip ) ; if ( ! outFile . open ( QIODevice :: WriteOnly , QuaZip@@ NewInfo ( fileDest , inFile . fileName ( ) ) ) ) return false ; if ( ! copyData ( inFile , outFile ) || outFile . getZipError ( ) != UNZ_OK ) { return false ; } outFile . close ( ) ; if ( outFile . getZipError ( ) != UNZ_OK ) return false ; inFile . close ( ) ; return true ; }
bool JlCompress :: compressSubDir ( QuaZip * zip , QString dir , QString origDir , bool recursive ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdCreate && zip -> getMode ( ) != QuaZip :: mdAppend && zip -> getMode ( ) != QuaZip :: mdAdd ) return false ; QDir directory ( dir ) ; if ( ! directory . exists ( ) ) return false ; if ( recursive ) { QFileInfoList files = directory . entryInfoList ( QDir :: AllDirs | QDir :: NoDot@@ AndDot@@ Dot ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! compressSubDir ( zip , file . absoluteFilePath ( ) , origDir , recursive ) ) return false ; } } QFileInfoList files = directory . entryInfoList ( QDir :: Files ) ; QDir origDirectory ( origDir ) ; Q_FOREACH ( QFileInfo file , files ) { if ( ! file . isFile ( ) || file . absoluteFilePath ( ) == zip -> getZipName ( ) ) continue ; QString filename = origDirectory . relative@@ FilePath ( file . absoluteFilePath ( ) ) ; if ( ! compressFile ( zip , file . absoluteFilePath ( ) , filename ) ) return false ; } return true ; }
bool JlCompress :: extractFile ( QuaZip * zip , QString fileName , QString fileDest ) { if ( ! zip ) return false ; if ( zip -> getMode ( ) != QuaZip :: mdUnzip ) return false ; if ( ! fileName . isEmpty ( ) ) zip -> setCurrentFile ( fileName ) ; QuaZipFile inFile ( zip ) ; if ( ! inFile . open ( QIODevice :: ReadOnly ) || inFile . getZipError ( ) != UNZ_OK ) return false ; QDir curDir ; if ( ! curDir . mkpath ( QFileInfo ( fileDest ) . absolutePath ( ) ) ) { return false ; } if ( QFileInfo ( fileDest ) . isDir ( ) ) return true ; QFile outFile ; outFile . setFileName ( fileDest ) ; if ( ! outFile . open ( QIODevice :: WriteOnly ) ) return false ; if ( ! copyData ( inFile , outFile ) || inFile . getZipError ( ) != UNZ_OK ) { outFile . close ( ) ; removeFile ( QStringList ( fileDest ) ) ; return false ; } outFile . close ( ) ; inFile . close ( ) ; if ( inFile . getZipError ( ) != UNZ_OK ) { removeFile ( QStringList ( fileDest ) ) ; return false ; } return true ; }
bool JlCompress :: removeFile ( QStringList listFile ) { bool ret = true ; for ( int i = 0 ; i < listFile . count ( ) ; i ++ ) { ret = ret && QFile :: remove ( listFile . at ( i ) ) ; } return ret ; }
bool JlCompress :: compressFile ( QString fileCompressed , QString file ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressFile ( & zip , file , QFileInfo ( file ) . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; }
bool JlCompress :: compressFiles ( QString fileCompressed , QStringList files ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } QFileInfo info ; Q_FOREACH ( QString file , files ) { info . setFile ( file ) ; if ( ! info . exists ( ) || ! compressFile ( & zip , file , info . fileName ( ) ) ) { QFile :: remove ( fileCompressed ) ; return false ; } } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; }
bool JlCompress :: compressDir ( QString fileCompressed , QString dir , bool recursive ) { QuaZip zip ( fileCompressed ) ; QDir ( ) . mkpath ( QFileInfo ( fileCompressed ) . absolutePath ( ) ) ; if ( ! zip . open ( QuaZip :: mdCreate ) ) { QFile :: remove ( fileCompressed ) ; return false ; } if ( ! compressSubDir ( & zip , dir , dir , recursive ) ) { QFile :: remove ( fileCompressed ) ; return false ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { QFile :: remove ( fileCompressed ) ; return false ; } return true ; }
QString JlCompress :: extractFile ( QString fileCompressed , QString fileName , QString fileDest ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QString ( ) ; } if ( fileDest . isEmpty ( ) ) fileDest = fileName ; if ( ! extractFile ( & zip , fileName , fileDest ) ) { return QString ( ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( QStringList ( fileDest ) ) ; return QString ( ) ; } return QFileInfo ( fileDest ) . absoluteFilePath ( ) ; }
QStringList JlCompress :: extractFiles ( QString fileCompressed , QStringList files , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QStringList extracted ; for ( int i = 0 ; i < files . count ( ) ; i ++ ) { QString absPath = QDir ( dir ) . absoluteFilePath ( files . at ( i ) ) ; if ( ! extractFile ( & zip , files . at ( i ) , absPath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absPath ) ; } zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; }
QStringList JlCompress :: extractDir ( QString fileCompressed , QString dir ) { QuaZip zip ( fileCompressed ) ; if ( ! zip . open ( QuaZip :: mdUnzip ) ) { return QStringList ( ) ; } QDir directory ( dir ) ; QStringList extracted ; if ( ! zip . goToFirstFile ( ) ) { return QStringList ( ) ; } do { QString name = zip . getCurrentFileName ( ) ; QString absFilePath = directory . absoluteFilePath ( name ) ; if ( ! extractFile ( & zip , " " , absFilePath ) ) { removeFile ( extracted ) ; return QStringList ( ) ; } extracted . append ( absFilePath ) ; } while ( zip . goToNextFile ( ) ) ; zip . close ( ) ; if ( zip . getZipError ( ) != 0 ) { removeFile ( extracted ) ; return QStringList ( ) ; } return extracted ; }
QStringList JlCompress :: getFile@@ List ( QString fileCompressed ) { QuaZip * zip = new QuaZip ( QFileInfo ( fileCompressed ) . absoluteFilePath ( ) ) ; if ( ! zip -> open ( QuaZip :: mdUnzip ) ) { delete zip ; return QStringList ( ) ; } QStringList lst ; QuaZip@@ FileInfo info ; for ( bool more = zip -> goToFirstFile ( ) ; more ; more = zip -> goToNextFile ( ) ) { if ( ! zip -> getCurrentFileInfo ( & info ) ) { delete zip ; return QStringList ( ) ; } lst << info . name ; } zip -> close ( ) ; if ( zip -> getZipError ( ) != 0 ) { delete zip ; return QStringList ( ) ; } delete zip ; return lst ; }
GameLobbyStage :: GameLobbyStage ( ) { networkconnection = nullptr ; currentinfo = new GameInfo ( true ) ; selection = 0 ; selectionteamisblue = true ; }
GameLobbyStage :: GameLobbyStage ( Network * Connection ) { selection = 0 ; networkconnection = Connection ; currentinfo = new GameInfo ( Connection -> IsServer ( ) ) ; if ( ! Connection -> IsServer ( ) ) { } }
void GameLobbyStage :: Begin ( ) { optionfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 32 ) ; helpfont = FontCache :: LoadFont ( " resources / armalite . ttf " , 16 ) ; }
void GameLobbyStage :: Finish ( ) { AUDIO -> StopMus@@ ic ( ) ; if ( networkconnection != nullptr ) { delete networkconnection ; networkconnection = nullptr ; } }
void GameLobbyStage :: EventOccur@@ red ( Event * e ) { InputItems :: ItemSet inputevent = InputItems :: NONE ; if ( e -> Type == EVENT_KEY_@@ DOWN ) { if ( e -> Data . Keyboard . KeyCode == ALLE@@ GRO_KEY_@@ ESCAPE ) { delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; } inputevent = Input :: GetItemFromEvent ( e ) ; } if ( e -> Type == EVENT_JO@@ YSTIC@@ K_BUTTON_@@ DOWN && inputevent == InputItems :: NONE ) { inputevent = Input :: GetItemFromEvent ( e ) ; } if ( inputevent != InputItems :: NONE ) { InputEvent ( inputevent ) ; } NetworkEvent ( e ) ; }
void GameLobbyStage :: InputEvent ( InputItems :: ItemSet inputevent ) { switch ( inputevent ) { case InputItems :: UP : if ( selection > 0 ) { selection -- ; } break ; case InputItems :: DOWN : if ( selection < 2 ) { selection ++ ; } break ; case InputItems :: LEFT : selectionteamisblue = true ; break ; case InputItems :: RIGHT : selectionteamisblue = false ; break ; case InputItems :: SELECT : delete FRAMEWORK -> ProgramStages -> Pop ( ) ; return ; break ; case InputItems :: X : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { currentinfo -> BlueTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> BlueTeam [ selection ] ; } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { currentinfo -> RedTeam [ selection ] = new PlayerInfo ( " " , true , false ) ; } p = currentinfo -> RedTeam [ selection ] ; } p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; FRAMEWORK -> ProgramStages -> Push ( new GameLobbyAddLocal@@ Stage ( p ) ) ; } break ; case InputItems :: B : if ( networkconnection == nullptr ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { if ( currentinfo -> BlueTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> BlueTeam [ selection ] = p ; } } else { if ( currentinfo -> RedTeam [ selection ] == nullptr ) { p = new PlayerInfo ( " CPU " , true , true ) ; currentinfo -> RedTeam [ selection ] = p ; } } if ( p != nullptr ) { p -> BlueTeam = selectionteamisblue ; p -> TeamIndex = selection ; p -> GameData = currentinfo ; } } break ; case InputItems :: Y : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { PlayerInfo * p = nullptr ; if ( selectionteamisblue ) { p = currentinfo -> BlueTeam [ selection ] ; currentinfo -> BlueTeam [ selection ] = nullptr ; } else { p = currentinfo -> RedTeam [ selection ] ; currentinfo -> RedTeam [ selection ] = nullptr ; } if ( p != nullptr ) { if ( ! p -> Local ) { } delete p ; } } break ; case InputItems :: START : if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { GameStage * g = new GameStage ( currentinfo ) ; delete FRAMEWORK -> ProgramStages -> Pop ( ) ; FRAMEWORK -> ProgramStages -> Push ( g ) ; } break ; } }
void GameLobbyStage :: NetworkEvent ( Event * e ) { if ( e -> Type == EVENT_NETWORK_@@ CONNECTION_@@ REQUEST ) { bool freeslot = false ; for ( int i = 0 ; i < 3 ; i ++ ) { freeslot = ( currentinfo -> BlueTeam [ i ] == nullptr ? true : freeslot ) ; freeslot = ( currentinfo -> RedTeam [ i ] == nullptr ? true : freeslot ) ; } if ( freeslot ) { } } if ( e -> Type == EVENT_NETWORK_@@ CONNECTED ) { } if ( e -> Type == EVENT_NETWORK_@@ DISCONNECTED ) { } if ( e -> Type == EVENT_NETWORK_@@ PAC@@ KET_RECE@@ IV@@ ED ) { } }
void GameLobbyStage :: Render ( ) { al_clear@@ _to_color ( al_map_rgb ( 255 , 220 , 128 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) + 2 , 12 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; optionfont -> DrawString ( ( DISPLAY -> GetWidth ( ) / 2 ) , 10 , " Lobby " , FontHAlign :: CENTRE , al_map_rgb ( 255 , 255 , 0 ) ) ; GameResources :: DrawPanel ( GameResources :: BluePanel , 5 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 15 , 85 , " Blue ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( true , 0 , 15 , 140 ) ; RenderPlayerSlot ( true , 1 , 15 , 192 ) ; RenderPlayerSlot ( true , 2 , 15 , 244 ) ; GameResources :: DrawPanel ( GameResources :: RedPanel , 405 , 80 , 13 , 8 , 8 ) ; optionfont -> DrawString ( 415 , 85 , " Red ▁ Team " , FontHAlign :: LEFT , al_map_rgb ( 255 , 255 , 255 ) ) ; RenderPlayerSlot ( false , 0 , 415 , 140 ) ; RenderPlayerSlot ( false , 1 , 415 , 192 ) ; RenderPlayerSlot ( false , 2 , 415 , 244 ) ; int textoff = ( 50 - helpfont -> GetFontHeight ( ) ) / 2 ; if ( networkconnection == nullptr ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: X ) , 10 , 320 , 0 ) ; helpfont -> DrawString ( 64 , 320 + textoff , " Add ▁ Local ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: B ) , 10 , 370 , 0 ) ; helpfont -> DrawString ( 64 , 370 + textoff , " Add ▁ CPU ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { al_draw_bitmap ( Input :: GetIcon ( InputItems :: Y ) , 10 , 420 , 0 ) ; helpfont -> DrawString ( 64 , 420 + textoff , " Kick ▁ Player " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; al_draw_bitmap ( Input :: GetIcon ( InputItems :: START ) , 500 , 370 , 0 ) ; helpfont -> DrawString ( 554 , 370 + textoff , " Start " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; } al_draw_bitmap ( Input :: GetIcon ( InputItems :: SELECT ) , 500 , 420 , 0 ) ; helpfont -> DrawString ( 554 , 420 + textoff , " Quit " , FontHAlign :: LEFT , al_map_rgb ( 0 , 0 , 0 ) ) ; }
bool GameLobbyStage :: IsTransition ( ) { return false ; }
void GameLobbyStage :: RenderPlayerSlot ( bool BlueTeam , int Index , int X , int Y ) { ButtonColours :: Colours colour = ButtonColours :: WHITE ; bool btnup = false ; PlayerInfo * p = ( BlueTeam ? currentinfo -> BlueTeam [ Index ] : currentinfo -> RedTeam [ Index ] ) ; if ( p != nullptr ) { colour = ( BlueTeam ? ButtonColours :: BLUE : ButtonColours :: RED ) ; } if ( networkconnection == nullptr || networkconnection -> IsServer ( ) ) { if ( selection == Index && selectionteamisblue == BlueTeam ) { colour = ButtonColours :: YEL@@ LOW ; btnup = true ; } } GameResources :: DrawButton ( colour , btnup , X , Y , 23 , 3 ) ; if ( p != nullptr ) { helpfont -> DrawString ( X + 184 , Y + 24 - ( helpfont -> GetFontHeight ( ) / 2 ) + ( ! btnup ? 4 : 0 ) , p -> Name , FontHAlign :: CENTRE , al_map_rgb ( 0 , 0 , 0 ) ) ; } }
void ACE_Stream_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Stream _ Node : : apply " ) ; const ACE_Service_Type * sst = this -> node_ -> record ( config ) ; if ( sst == 0 ) const_cast < ACE_Static_Node * > ( this -> node_ ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) return ; sst = this -> node_ -> record ( config ) ; ACE_Stream_Type * st = dynamic_cast < ACE_Stream_Type * > ( const_cast < ACE_Service_Type_Impl * > ( sst -> type ( ) ) ) ; std :: list < const ACE_Static_Node * > mod_list ; const ACE_Static_Node * module ; for ( module = dynamic_cast < const ACE_Static_Node * > ( this -> mods_ ) ; module != 0 ; module = dynamic_cast < ACE_Static_Node * > ( module -> link ( ) ) ) mod_list . push_front ( module ) ; std :: list < const ACE_Static_Node * > :: const_iterator iter ; for ( iter = mod_list . begin ( ) ; iter != mod_list . end ( ) ; ++ iter ) { module = * iter ; ACE_ARGV args ( module -> parameters ( ) ) ; const ACE_Service_Type * mst = module -> record ( config ) ; if ( mst == 0 ) const_cast < ACE_Static_Node * > ( module ) -> apply ( config , yyerrno ) ; if ( yyerrno != 0 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Module ▁ % s \n " ) , module -> name ( ) ) ) ; } ++ yyerrno ; continue ; } ACE_Module_Type const * const mt1 = static_cast < ACE_Module_Type const * > ( module -> record ( config ) -> type ( ) ) ; ACE_Module_Type * mt = const_cast < ACE_Module_Type * > ( mt1 ) ; if ( st -> push ( mt ) == - 1 ) { if ( ACE :: debug ( ) ) { ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " dynamic ▁ initialization ▁ failed ▁ for ▁ Stream ▁ % s \n " ) , this -> node_ -> name ( ) ) ) ; } ++ yyerrno ; } } if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ( % P | % t ) ▁ Did ▁ stream ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> node_ -> name ( ) , yyerrno ) ) ; }
void ACE_Parse_Node :: link ( ACE_Parse_Node * n ) { ACE_TRACE ( " ACE _ Parse _ Node : : link " ) ; ACE_Parse_Node * t = this ; while ( t -> next_ != 0 ) t = t -> next_ ; t -> next_ = n ; }
ACE_Stream_Node :: ACE_Stream_Node ( const ACE_Static_Node * str_ops , const ACE_Parse_Node * str_mods ) : ACE_Parse_Node ( ( str_ops == 0 ? ACE_TEXT ( " < unknown > " ) : str_ops -> name ( ) ) ) , node_ ( str_ops ) , mods_ ( str_mods ) { ACE_TRACE ( " ACE _ Stream _ Node : : ACE _ Stream _ Node " ) ; }
ACE_Stream_Node :: ~ ACE_Stream_Node ( void ) { ACE_TRACE ( " ACE _ Stream _ Node : : ~ ACE _ Stream _ Node " ) ; ACE_Static_Node * n = const_cast < ACE_Static_Node * > ( this -> node_ ) ; delete n ; ACE_Parse_Node * m = const_cast < ACE_Parse_Node * > ( this -> mods_ ) ; delete m ; }
ACE_Parse_Node :: ACE_Parse_Node ( void ) : name_ ( 0 ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; }
ACE_Parse_Node :: ACE_Parse_Node ( const ACE_TCHAR * nm ) : name_ ( ACE :: strnew ( nm ) ) , next_ ( 0 ) { ACE_TRACE ( " ACE _ Parse _ Node : : ACE _ Parse _ Node " ) ; }
ACE_Parse_Node :: ~ ACE_Parse_Node ( void ) { ACE_TRACE ( " ACE _ Parse _ Node : : ~ ACE _ Parse _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> name_ ) ; delete this -> next_ ; }
ACE_Suspend_Node :: ACE_Suspend_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Suspend _ Node : : ACE _ Suspend _ Node " ) ; }
ACE_Resume_Node :: ACE_Resume_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Resume _ Node : : ACE _ Resume _ Node " ) ; }
void ACE_Suspend_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Suspend _ Node : : apply " ) ; if ( config -> suspend ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ suspend ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; }
void ACE_Resume_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Resume _ Node : : apply " ) ; if ( config -> resume ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " did ▁ resume ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Remove_Node :: ACE_Remove_Node ( const ACE_TCHAR * name ) : ACE_Parse_Node ( name ) { ACE_TRACE ( " ACE _ Remove _ Node : : ACE _ Remove _ Node " ) ; }
void ACE_Remove_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Remove _ Node : : apply " ) ; if ( config -> remove ( this -> name ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Remove _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ did ▁ remove ▁ on ▁ % s , ▁ error ▁ = ▁ % d \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Dynamic_Node :: ACE_Dynamic_Node ( ACE_Service_Type_Factory const * stf , ACE_TCHAR * parms ) : ACE_Static_Node ( stf -> name ( ) , parms ) , factory_ ( stf ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ACE _ Dynamic _ Node " ) ; }
void ACE_Dynamic_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : apply " ) ; if ( config -> initialize ( this -> factory_ . get ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Dynamic _ Node : : apply " ) ACE_TEXT ( " ▁ - ▁ Did ▁ dynamic ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Dynamic_Node :: ~ ACE_Dynamic_Node ( void ) { ACE_TRACE ( " ACE _ Dynamic _ Node : : ~ ACE _ Dynamic _ Node " ) ; }
ACE_Static_Node :: ACE_Static_Node ( const ACE_TCHAR * nm , ACE_TCHAR * params ) : ACE_Parse_Node ( nm ) , parameters_ ( ACE :: strnew ( params ) ) { ACE_TRACE ( " ACE _ Static _ Node : : ACE _ Static _ Node " ) ; }
void ACE_Static_Node :: apply ( ACE_Service_Gestalt * config , int & yyerrno ) { ACE_TRACE ( " ACE _ Static _ Node : : apply " ) ; if ( config -> initialize ( this -> name ( ) , this -> parameters ( ) ) == - 1 ) ++ yyerrno ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ Static _ Node : : apply ▁ - " ) ACE_TEXT ( " ▁ Did ▁ static ▁ on ▁ % s ▁ ( yyerrno = % d ) \n " ) , this -> name ( ) , yyerrno ) ) ; }
ACE_Static_Node :: ~ ACE_Static_Node ( void ) { ACE_TRACE ( " ACE _ Static _ Node : : ~ ACE _ Static _ Node " ) ; delete [ ] this -> parameters_ ; }
ACE_Location_Node :: ACE_Location_Node ( void ) : pathname_ ( 0 ) , dll_ ( ) , symbol_ ( 0 ) { ACE_TRACE ( " ACE _ Location _ Node : : ACE _ Location _ Node " ) ; }
ACE_Location_Node :: ~ ACE_Location_Node ( void ) { ACE_TRACE ( " ACE _ Location _ Node : : ~ ACE _ Location _ Node " ) ; }
const ACE_DLL & ACE_Location_Node :: dll ( void ) { return this -> dll_ ; }
void ACE_Location_Node :: pathname ( const ACE_TCHAR * p ) { ACE_TRACE ( " ACE _ Location _ Node : : pathname " ) ; this -> pathname_ = p ; }
int ACE_Location_Node :: open_dll ( int & yyerrno ) { ACE_TRACE ( " ACE _ Location _ Node : : open _ dll " ) ; if ( ACE :: debug ( ) ) ACE_DEBUG ( ( LM_DEBUG , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ path = % s \n " ) , this -> pathname ( ) ) ) ; if ( - 1 == this -> dll_ . open ( this -> pathname ( ) ) ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ LN : : open _ dll ▁ - ▁ Failed ▁ to ▁ open ▁ % s : ▁ % s \n " ) , this -> pathname ( ) , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } return - 1 ; } return 0 ; }
void ACE_Location_Node :: set_symbol ( void * s ) { ACE_TRACE ( " ACE _ Location _ Node : : set _ symbol " ) ; this -> symbol_ = s ; }
ACE_Object_Node :: ACE_Object_Node ( const ACE_TCHAR * path , const ACE_TCHAR * obj_name ) : object_name_ ( ACE :: strnew ( obj_name ) ) { ACE_TRACE ( " ACE _ Object _ Node : : ACE _ Object _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 0 ; }
void * ACE_Object_Node :: symbol ( ACE_Service_Gestalt * , int & yyerrno , ACE_Service_Object_Exterminator * ) { ACE_TRACE ( " ACE _ Object _ Node : : symbol " ) ; if ( this -> open_dll ( yyerrno ) == 0 ) { ACE_TCHAR * object_name = const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; this -> symbol_ = this -> dll_ . symbol ( object_name ) ; if ( this -> symbol_ == 0 ) { ++ yyerrno ; if ( ACE :: debug ( ) ) { ACE_TCHAR * errmsg = this -> dll_ . error ( ) ; ACE_ERROR ( ( LM_ERROR , ACE_TEXT ( " ACE ▁ ( % P | % t ) ▁ DLL : : symbol ▁ - " ) ACE_TEXT ( " ▁ Failed ▁ for ▁ object ▁ % s : ▁ % s \n " ) , object_name , errmsg ? errmsg : ACE_TEXT ( " no ▁ error ▁ reported " ) ) ) ; } return 0 ; } return this -> symbol_ ; } return 0 ; }
ACE_Object_Node :: ~ ACE_Object_Node ( void ) { ACE_TRACE ( " ACE _ Object _ Node : : ~ ACE _ Object _ Node " ) ; delete [ ] const_cast < ACE_TCHAR * > ( this -> object_name_ ) ; }
ACE_Function_Node :: ACE_Function_Node ( const ACE_TCHAR * path , const ACE_TCHAR * func_name ) : function_name_ ( make_func_name ( func_name ) ) { ACE_TRACE ( " ACE _ Function _ Node : : ACE _ Function _ Node " ) ; this -> pathname ( ACE :: strnew ( path ) ) ; this -> must_delete_ = 1 ; }
ACE_TCHAR * ACE_Function_Node :: make_func_name ( ACE_TCHAR const * func_name ) { && ACE_HAS_VERSIONED_NAMESPACE == 1 ; }
void AP_Frsky_Telem :: init ( const AP_SerialManager & serial_manager , const uint8_t mav_type , const uint32_t * ap_valuep ) { if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_D , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_D ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort ; } else if ( ( _port = serial_manager . find_serial ( AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough , 0 ) ) ) { _protocol = AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ; gcs ( ) . register_@@ frsky_@@ telemetry_@@ callback ( this ) ; if ( _frame_string == nullptr ) { queue_message ( MAV_SEVERITY_INFO , AP :: fwversion ( ) . fw_string ) ; } else { char firmware_buf [ MAVLINK_@@ MSG_ST@@ ATUST@@ EXT_@@ FIELD_TEXT_@@ LEN + 1 ] ; snprintf ( firmware_buf , sizeof ( firmware_buf ) , " % s ▁ % s " , AP :: fwversion ( ) . fw_string , _frame_string ) ; queue_message ( MAV_SEVERITY_INFO , firmware_buf ) ; } _params . mav_type = mav_type ; if ( ap_valuep == nullptr ) { _ap . value = 0x2000 ; _ap . valuep = & _ap . value ; } else { _ap . valuep = ap_valuep ; } } if ( _port != nullptr ) { hal . scheduler -> register_@@ io_pro@@ cess ( FUNCTOR_@@ BIND_MEMBER ( & AP_Frsky_Telem :: tick , void ) ) ; _port -> set_flow@@ _control ( AP_HAL :: UAR@@ TDriver :: FLOW_CONTROL_DISABLE ) ; } }
void AP_Frsky_Telem :: send_SPort_Passthrough ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } uint8_t prev_byte = 0 ; for ( int16_t i = 0 ; i < numc ; i ++ ) { prev_byte = _passthrough . new_byte ; _passthrough . new_byte = _port -> read ( ) ; } if ( ( prev_byte == START_STOP_SPORT ) && ( _passthrough . new_byte == SENSOR_ID_@@ 28 ) ) { if ( _passthrough . send_attiandrng ) { _passthrough . send_attiandrng = false ; } else { _passthrough . send_attiandrng = true ; uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - _passthrough . params_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 7 , calc_param ( ) ) ; _passthrough . params_timer = AP_HAL :: millis ( ) ; return ; } check_sensor_status_flags ( ) ; check_ekf_status ( ) ; if ( get_next_msg_chunk ( ) ) { send_uint32 ( DIY_FIRST_ID , _msg_chunk . chunk ) ; return ; } if ( ( now - _passthrough . ap_status_timer ) >= 500 ) { if ( ( ( * _ap . valuep ) & AP_INITIALIZ@@ ED_FLAG ) > 0 ) { send_uint32 ( DIY_FIRST_ID + 1 , calc_ap_status ( ) ) ; _passthrough . ap_status_timer = AP_HAL :: millis ( ) ; } return ; } if ( ( now - _passthrough . batt_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 3 , calc_batt ( 0 ) ) ; _passthrough . batt_timer = AP_HAL :: millis ( ) ; return ; } if ( _battery . num_instances ( ) > 1 ) { if ( ( now - _passthrough . batt_timer2 ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 8 , calc_batt ( 1 ) ) ; _passthrough . batt_timer2 = AP_HAL :: millis ( ) ; return ; } } if ( ( now - _passthrough . gps_status_timer ) >= 1000 ) { send_uint32 ( DIY_FIRST_ID + 2 , calc_gps_status ( ) ) ; _passthrough . gps_status_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . home_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 4 , calc_home ( ) ) ; _passthrough . home_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . velandyaw_timer ) >= 500 ) { send_uint32 ( DIY_FIRST_ID + 5 , calc_velandyaw ( ) ) ; _passthrough . velandyaw_timer = AP_HAL :: millis ( ) ; return ; } if ( ( now - _passthrough . gps_latlng_timer ) >= 1000 ) { send_uint32 ( GPS_LONG_@@ LATI@@ _FIRST_ID , calc_gps_latlng ( & _passthrough . send_latitude ) ) ; if ( ! _passthrough . send_latitude ) { _passthrough . gps_latlng_timer = AP_HAL :: millis ( ) ; } return ; } } send_uint32 ( DIY_FIRST_ID + 6 , calc_attiandrng ( ) ) ; } }
void AP_Frsky_Telem :: send_SPort ( void ) { int16_t numc ; numc = _port -> available ( ) ; if ( numc < 0 ) { return ; } if ( _port -> txspace ( ) < 19 ) { return ; } for ( int16_t i = 0 ; i < numc ; i ++ ) { int16_t readbyte = _port -> read ( ) ; if ( _SPort . sport_status == false ) { if ( readbyte == START_STOP_SPORT ) { _SPort . sport_status = true ; } } else { switch ( readbyte ) { case SENSOR_@@ ID_F@@ AS : switch ( _SPort . fas_call ) { case 0 : send_uint32 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; break ; case 2 : send_uint32 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; break ; } if ( _SPort . fas_call ++ > 2 ) _SPort . fas_call = 0 ; break ; case SENSOR_ID_@@ GPS : switch ( _SPort . gps_call ) { case 0 : calc_gps_position ( ) ; send_uint32 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; break ; case 1 : send_uint32 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; break ; case 2 : send_uint32 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; break ; case 3 : send_uint32 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; break ; case 4 : send_uint32 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; break ; case 5 : send_uint32 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; break ; case 6 : send_uint32 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; break ; case 7 : send_uint32 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; break ; case 8 : send_uint32 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; break ; case 9 : send_uint32 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; break ; case 10 : send_uint32 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; break ; } if ( _SPort . gps_call ++ > 10 ) _SPort . gps_call = 0 ; break ; case SENSOR_ID_@@ VARIO : switch ( _SPort . vario_call ) { case 0 : calc_nav_alt ( ) ; send_uint32 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; break ; case 1 : send_uint32 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; break ; } if ( _SPort . vario_call ++ > 1 ) _SPort . vario_call = 0 ; break ; case SENSOR_@@ ID_SP@@ 2U@@ R : switch ( _SPort . various_call ) { case 0 : send_uint32 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; break ; case 1 : send_uint32 ( DATA_ID_TEMP1 , _ap . control_mode ) ; break ; } if ( _SPort . various_call ++ > 1 ) _SPort . various_call = 0 ; break ; } _SPort . sport_status = false ; } } }
void AP_Frsky_Telem :: send_D ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( now - _D . last_200ms_frame >= 200 ) { _D . last_200ms_frame = now ; send_uint16 ( DATA_ID_TEMP2 , ( uint16_t ) ( AP :: gps ( ) . num_sats ( ) * 10 + AP :: gps ( ) . status ( ) ) ) ; send_uint16 ( DATA_ID_TEMP1 , _ap . control_mode ) ; send_uint16 ( DATA_ID_FUEL , ( uint16_t ) roundf ( _battery . capacity_remaining_pct ( ) ) ) ; send_uint16 ( DATA_ID_VFAS , ( uint16_t ) roundf ( _battery . voltage ( ) * 10.0f ) ) ; send_uint16 ( DATA_ID_CURRENT , ( uint16_t ) roundf ( _battery . current_amps ( ) * 10.0f ) ) ; calc_nav_alt ( ) ; send_uint16 ( DATA_ID_BARO_ALT_BP , _gps . alt_nav_meters ) ; send_uint16 ( DATA_ID_BARO_ALT_AP , _gps . alt_nav_cm ) ; } if ( now - _D . last_1000ms_frame >= 1000 ) { _D . last_1000ms_frame = now ; send_uint16 ( DATA_ID_GPS_COURS_BP , ( uint16_t ) ( ( _ahrs . yaw_sensor / 100 ) % 360 ) ) ; calc_gps_position ( ) ; if ( AP :: gps ( ) . status ( ) >= 3 ) { send_uint16 ( DATA_ID_GPS_LAT_BP , _gps . latdddmm ) ; send_uint16 ( DATA_ID_GPS_LAT_AP , _gps . latmmmm ) ; send_uint16 ( DATA_ID_GPS_LAT_NS , _gps . lat_ns ) ; send_uint16 ( DATA_ID_GPS_LONG_BP , _gps . londddmm ) ; send_uint16 ( DATA_ID_GPS_LONG_AP , _gps . lonmmmm ) ; send_uint16 ( DATA_ID_GPS_LONG_EW , _gps . lon_ew ) ; send_uint16 ( DATA_ID_GPS_SPEED_BP , _gps . speed_in_meter ) ; send_uint16 ( DATA_ID_GPS_SPEED_AP , _gps . speed_in_centimeter ) ; send_uint16 ( DATA_ID_GPS_ALT_BP , _gps . alt_gps_meters ) ; send_uint16 ( DATA_ID_GPS_ALT_AP , _gps . alt_gps_cm ) ; } } }
void AP_Frsky_Telem :: tick ( void ) { if ( ! _initialised_uart ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { _port -> begin ( AP_SERIALMANAGER_FRSKY_@@ D_BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } else { _port -> begin ( AP_SERIALMANAGER_FRSK@@ Y_SP@@ ORT_@@ BAUD , AP_SERIALMANAGER_FRSKY_BUFSIZE_RX , AP_SERIALMANAGER_FRSKY_BUFSIZE_TX ) ; } _initialised_uart = true ; } if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { send_D ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort ) { send_SPort ( ) ; } else if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_SPort_Passthrough ) { send_SPort_Passthrough ( ) ; } }
void AP_Frsky_Telem :: calc_crc ( uint8_t byte ) { _crc += byte ; _crc += _crc >> 8 ; _crc &= 0xFF ; }
void AP_Frsky_Telem :: send_crc ( void ) { send_byte ( 0xFF - _crc ) ; _crc = 0 ; }
void AP_Frsky_Telem :: send_byte ( uint8_t byte ) { if ( _protocol == AP_SerialManager :: SerialProtocol_FrSky_D ) { if ( byte == START_STOP_D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3E ) ; } else if ( byte == BYTESTUFF@@ _D ) { _port -> write ( 0x5D ) ; _port -> write ( 0x3D ) ; } else { _port -> write ( byte ) ; } } else { if ( byte == START_STOP_SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5E ) ; } else if ( byte == BYTESTUFF@@ _SPORT ) { _port -> write ( 0x7D ) ; _port -> write ( 0x5D ) ; } else { _port -> write ( byte ) ; } calc_crc ( byte ) ; } }
void AP_Frsky_Telem :: send_uint32 ( uint16_t id , uint32_t data ) { send_byte ( 0x10 ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; send_byte ( bytes [ 2 ] ) ; send_byte ( bytes [ 3 ] ) ; send_crc ( ) ; }
void AP_Frsky_Telem :: send_uint16 ( uint16_t id , uint16_t data ) { _port -> write ( START_STOP_D ) ; uint8_t * bytes = ( uint8_t * ) & id ; send_byte ( bytes [ 0 ] ) ; bytes = ( uint8_t * ) & data ; send_byte ( bytes [ 0 ] ) ; send_byte ( bytes [ 1 ] ) ; }
bool AP_Frsky_Telem :: get_next_msg_chunk ( void ) { if ( _statustext_queue . empty ( ) ) { return false ; } if ( _msg_chunk . repeats == 0 ) { uint8_t character = 0 ; _msg_chunk . chunk = 0 ; for ( int i = 3 ; i > - 1 && _msg_chunk . char_index < sizeof ( _statustext_queue [ 0 ] -> text ) ; i -- ) { character = _statustext_queue [ 0 ] -> text [ _msg_chunk . char_index ++ ] ; if ( ! character ) { break ; } _msg_chunk . chunk |= character << i * 8 ; } if ( ! character || ( _msg_chunk . char_index == sizeof ( _statustext_queue [ 0 ] -> text ) ) ) { _msg_chunk . char_index = 0 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x4 ) << 21 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x2 ) << 14 ; _msg_chunk . chunk |= ( _statustext_queue [ 0 ] -> severity & 0x1 ) << 7 ; } } if ( _msg_chunk . repeats ++ > 2 ) { _msg_chunk . repeats = 0 ; if ( _msg_chunk . char_index == 0 ) { _statustext_queue . remove ( 0 ) ; } } return true ; }
void AP_Frsky_Telem :: queue_message ( MAV_SEVERITY severity , const char * text ) { mavlink_statustext_t statustext { } ; statustext . severity = severity ; strncpy ( statustext . text , text , sizeof ( statustext . text ) ) ; _statustext_queue . push_for@@ ce ( statustext ) ; }
void AP_Frsky_Telem :: check_sensor_status_flags ( void ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_sensor_status_timer ) >= 5000 ) { if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ GPS ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_@@ GYRO ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Gyro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_@@ ACCEL ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Accel ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_@@ MAG ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Compass ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABSOL@@ UTE_PRESSURE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Baro ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_LAS@@ ER_POSITION ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ LiDAR ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTICAL@@ _FLOW ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ OptFlow ▁ Health " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ TERRAIN ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ or ▁ No ▁ Terrain ▁ Data " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ GEOF@@ ENCE ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Geof@@ ence ▁ Bre@@ ach " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ AHRS ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ AHRS " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_@@ RECE@@ IVER ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " No ▁ RC ▁ Receiver " ) ; check_sensor_status_timer = now ; } else if ( ( _ap . sensor_status_flags & MAV_SYS_STATUS_@@ LOGGING ) > 0 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Bad ▁ Logging " ) ; check_sensor_status_timer = now ; } } }
void AP_Frsky_Telem :: check_ekf_status ( void ) { float velVar , posVar , hgtVar , tasVar ; Vector3f magVar ; Vector2f offset ; if ( _ahrs . get_vari@@ ances ( velVar , posVar , hgtVar , magVar , tasVar , offset ) ) { uint32_t now = AP_HAL :: millis ( ) ; if ( ( now - check_ekf_status_timer ) >= 10000 ) { if ( velVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ velocity ▁ variance " ) ; check_ekf_status_timer = now ; } if ( posVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ hori@@ z ▁ variance " ) ; check_ekf_status_timer = now ; } if ( hgtVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ pos ▁ vert ▁ variance " ) ; check_ekf_status_timer = now ; } if ( magVar . length ( ) >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ compass ▁ variance " ) ; check_ekf_status_timer = now ; } if ( tasVar >= 1 ) { queue_message ( MAV_SEVERITY_CRITICAL , " Error ▁ terrain ▁ alt ▁ variance " ) ; check_ekf_status_timer = now ; } } } }
uint32_t AP_Frsky_Telem :: calc_param ( void ) { uint32_t param = 0 ; if ( _paramID >= 5 ) { _paramID = 0 ; } _paramID ++ ; switch ( _paramID ) { case 1 : param = _params . mav_type ; break ; case 2 : case 3 : break ; case 4 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 0 ) ) ; break ; case 5 : param = ( uint32_t ) roundf ( _battery . pack_capacity_mah ( 1 ) ) ; break ; } param = ( _paramID << PARAM_ID_OFFSET ) | ( param & PARAM_VALUE_@@ LIMIT ) ; return param ; }
uint32_t AP_Frsky_Telem :: calc_gps_latlng ( bool * send_latitude ) { uint32_t latlng ; const Location & loc = AP :: gps ( ) . location ( 0 ) ; if ( ( * send_latitude ) == true ) { if ( loc . lat < 0 ) { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) | 0x40000000 ; } else { latlng = ( ( labs ( loc . lat ) / 100 ) * 6 ) ; } ( * send_latitude ) = false ; } else { if ( loc . lng < 0 ) { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0xC0000000 ; } else { latlng = ( ( labs ( loc . lng ) / 100 ) * 6 ) | 0x80000000 ; } ( * send_latitude ) = true ; } return latlng ; }
uint32_t AP_Frsky_Telem :: calc_gps_status ( void ) { const AP_GPS & gps = AP :: gps ( ) ; uint32_t gps_status ; gps_status = ( gps . num_sats ( ) < GPS_SATS_LIMIT ) ? gps . num_sats ( ) : GPS_SATS_LIMIT ; gps_status |= ( ( gps . status ( ) < GPS_STATUS_LIMIT ) ? gps . status ( ) : GPS_STATUS_LIMIT ) << GPS_STATUS_@@ OFFSET ; gps_status |= prep_number ( roundf ( gps . get_h@@ dop ( ) * 0.1f ) , 2 , 1 ) << GPS_HDO@@ P_OFFSET ; gps_status |= ( ( gps . status ( ) > GPS_STATUS_LIMIT ) ? gps . status ( ) - GPS_STATUS_LIMIT : 0 ) << GPS_ADV@@ STATUS_OFFSET ; const Location & loc = gps . location ( ) ; gps_status |= prep_number ( roundf ( loc . alt * 0.1f ) , 2 , 2 ) << GPS_ALT@@ MSL_OFFSET ; return gps_status ; }
uint32_t AP_Frsky_Telem :: calc_batt ( uint8_t instance ) { uint32_t batt ; batt = ( ( ( uint16_t ) roundf ( _battery . voltage ( instance ) * 10.0f ) ) & BATT_VOL@@ TAGE_@@ LIMIT ) ; batt |= prep_number ( roundf ( _battery . current_amps ( instance ) * 10.0f ) , 2 , 1 ) << BATT_@@ CURRENT_@@ OFFSET ; batt |= ( ( _battery . consumed_mah ( instance ) < BATT_TOTALMAH_LIMIT ) ? ( ( uint16_t ) roundf ( _battery . consumed_mah ( instance ) ) & BATT_TOTALMAH_LIMIT ) : BATT_TOTALMAH_LIMIT ) << BATT_TOTALMAH_@@ OFFSET ; return batt ; }
uint32_t AP_Frsky_Telem :: calc_ap_status ( void ) { uint32_t ap_status ; uint8_t imu_temp = ( uint8_t ) roundf ( constrain_float ( AP :: ins ( ) . get_temperature ( 0 ) , AP_IMU_TEMP_MIN , AP_IMU_TEMP_@@ MAX ) - AP_IMU_TEMP_MIN ) ; ap_status = ( uint8_t ) ( ( _ap . control_mode + 1 ) & AP_CONTROL_@@ MODE_@@ LIMIT ) ; ap_status |= ( uint8_t ) ( ( * _ap . valuep ) & AP_SSIMPLE_@@ FLAGS ) << AP_SSIMPLE_@@ OFFSET ; ap_status |= ( uint8_t ) ( ( ( * _ap . valuep ) & AP_LANDCOMPLETE_FLAG ) ^ AP_LANDCOMPLETE_FLAG ) ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . arm@@ ed ) << AP_ARMED_@@ OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . fail@@ safe_battery ) << AP_BATT_@@ FS_OFFSET ; ap_status |= ( uint8_t ) ( AP_Notify :: flags . ekf_bad ) << AP_EK@@ F_F@@ S_OFFSET ; ap_status |= imu_temp << AP_IMU_TEMP_@@ OFFSET ; return ap_status ; }
uint32_t AP_Frsky_Telem :: calc_home ( void ) { uint32_t home = 0 ; Location loc ; float _relative_home_altitude = 0 ; if ( _ahrs . get_position ( loc ) ) { const Location & home_loc = _ahrs . get_home ( ) ; if ( home_loc . lat != 0 || home_loc . lng != 0 ) { home = prep_number ( roundf ( get_distance ( home_loc , loc ) ) , 3 , 2 ) ; home |= ( ( ( uint8_t ) roundf ( get_bear@@ ing_cd ( loc , home_loc ) * 0.0033@@ 3f ) ) & HOME_BEARING_@@ LIMIT ) << HOME_BEARING_@@ OFFSET ; } _relative_home_altitude = loc . alt ; if ( ! loc . flags . relative_alt ) { _relative_home_altitude -= _ahrs . get_home ( ) . alt ; } } home |= prep_number ( roundf ( _relative_home_altitude * 0.1f ) , 3 , 2 ) << HOME_@@ ALT_OFFSET ; return home ; }
uint32_t AP_Frsky_Telem :: calc_velandyaw ( void ) { uint32_t velandyaw ; Vector3f velNED { } ; _ahrs . get_veloc@@ ity_NED ( velNED ) ; velandyaw = prep_number ( roundf ( - velNED . z * 10 ) , 2 , 1 ) ; const AP_Air@@ speed * aspeed = _ahrs . get_airspeed ( ) ; if ( aspeed && aspeed -> enabled ( ) ) { velandyaw |= prep_number ( roundf ( aspeed -> get_airspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } else { velandyaw |= prep_number ( roundf ( _ahrs . groundspeed ( ) * 10 ) , 2 , 1 ) << VELANDYAW_XYVEL_OFFSET ; } velandyaw |= ( ( uint16_t ) roundf ( _ahrs . yaw_sensor * 0.05f ) & VELANDYAW_YAW_@@ LIMIT ) << VELANDYAW_YAW_@@ OFFSET ; return velandyaw ; }
uint32_t AP_Frsky_Telem :: calc_attiandrng ( void ) { uint32_t attiandrng ; attiandrng = ( ( uint16_t ) roundf ( ( _ahrs . roll_sensor + 18000 ) * 0.05f ) & ATTIANDRNG_@@ ROLL_@@ LIMIT ) ; attiandrng |= ( ( uint16_t ) roundf ( ( _ahrs . pit@@ ch_sensor + 9000 ) * 0.05f ) & ATTIANDRNG_PITCH_@@ LIMIT ) << ATTIANDRNG_PITCH_@@ OFFSET ; attiandrng |= prep_number ( _rng . distan@@ ce_cm_@@ orient ( ROT@@ ATION_PITCH_@@ 270 ) , 3 , 1 ) << ATTIANDRNG_@@ RN@@ GF@@ ND_@@ OFFSET ; return attiandrng ; }
uint16_t AP_Frsky_Telem :: prep_number ( int32_t number , uint8_t digits , uint8_t power ) { uint16_t res = 0 ; uint32_t abs_number = abs ( number ) ; if ( ( digits == 2 ) && ( power == 1 ) ) { if ( abs_number < 100 ) { res = abs_number << 1 ; } else if ( abs_number < 1270 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0xFF ; } if ( number < 0 ) { res |= 0x1 << 8 ; } } else if ( ( digits == 2 ) && ( power == 2 ) ) { if ( abs_number < 100 ) { res = abs_number << 2 ; } else if ( abs_number < 1000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 10000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 127000 ) { res = ( ( uint8_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0x1FF ; } if ( number < 0 ) { res |= 0x1 << 9 ; } } else if ( ( digits == 3 ) && ( power == 1 ) ) { if ( abs_number < 1000 ) { res = abs_number << 1 ; } else if ( abs_number < 10240 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 1 ) | 0x1 ; } else { res = 0x7FF ; } if ( number < 0 ) { res |= 0x1 << 11 ; } } else if ( ( digits == 3 ) && ( power == 2 ) ) { if ( abs_number < 1000 ) { res = abs_number << 2 ; } else if ( abs_number < 10000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.1f ) << 2 ) | 0x1 ; } else if ( abs_number < 100000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.01f ) << 2 ) | 0x2 ; } else if ( abs_number < 1024@@ 000 ) { res = ( ( uint16_t ) roundf ( abs_number * 0.001f ) << 2 ) | 0x3 ; } else { res = 0xFFF ; } if ( number < 0 ) { res |= 0x1 << 12 ; } } return res ; }
void AP_Frsky_Telem :: calc_nav_alt ( void ) { Location loc ; float current_height = 0 ; if ( _ahrs . get_position ( loc ) ) { current_height = loc . alt * 0.01f ; if ( ! loc . flags . relative_alt ) { current_height -= _ahrs . get_home ( ) . alt * 0.01f ; } } _gps . alt_nav_meters = ( int16_t ) current_height ; _gps . alt_nav_cm = ( current_height - _gps . alt_nav_meters ) * 100 ; }
float AP_Frsky_Telem :: format_gps ( float dec ) { uint8_t dm_deg = ( uint8_t ) dec ; return ( dm_deg * 100.0f ) + ( dec - dm_deg ) * 60 ; }
void AP_Frsky_Telem :: calc_gps_position ( void ) { float lat ; float lon ; float alt ; float speed ; if ( AP :: gps ( ) . status ( ) >= 3 ) { const Location & loc = AP :: gps ( ) . location ( ) ; lat = format_gps ( fabsf ( loc . lat / 10000000.0f ) ) ; _gps . latdddmm = lat ; _gps . latmmmm = ( lat - _gps . latdddmm ) * 10000 ; _gps . lat_ns = ( loc . lat < 0 ) ? ' S ' : ' N ' ; lon = format_gps ( fabsf ( loc . lng / 10000000.0f ) ) ; _gps . londddmm = lon ; _gps . lonmmmm = ( lon - _gps . londddmm ) * 10000 ; _gps . lon_ew = ( loc . lng < 0 ) ? ' W ' : ' E ' ; alt = loc . alt * 0.01f ; _gps . alt_gps_meters = ( int16_t ) alt ; _gps . alt_gps_cm = ( alt - _gps . alt_gps_meters ) * 100 ; speed = AP :: gps ( ) . ground_speed ( ) ; _gps . speed_in_meter = speed ; _gps . speed_in_centimeter = ( speed - _gps . speed_in_meter ) * 100 ; } else { _gps . latdddmm = 0 ; _gps . latmmmm = 0 ; _gps . lat_ns = 0 ; _gps . londddmm = 0 ; _gps . lonmmmm = 0 ; _gps . alt_gps_meters = 0 ; _gps . alt_gps_cm = 0 ; _gps . speed_in_meter = 0 ; _gps . speed_in_centimeter = 0 ; } }
RuleBasedTimeZone :: RuleBasedTimeZone ( const RuleBasedTimeZone & source ) : BasicTimeZone ( source ) , fInitialRule ( source . fInitialRule -> clone ( ) ) , fHistoricTransitions ( NULL ) , fUpToDate ( FALSE ) { fHistoricRules = copyRules ( source . fHistoricRules ) ; fFinalRules = copyRules ( source . fFinalRules ) ; if ( source . fUpToDate ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; } }
RuleBasedTimeZone :: ~ RuleBasedTimeZone ( ) { deleteTransitions ( ) ; deleteRules ( ) ; }
void RuleBasedTimeZone :: addTransition@@ Rule ( TimeZoneRule * rule , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } AnnualTimeZoneRule * atzrule = dynamic_cast < AnnualTimeZoneRule * > ( rule ) ; if ( atzrule != NULL && atzrule -> getEnd@@ Year ( ) == AnnualTimeZoneRule :: MAX_YEAR ) { if ( fFinalRules == NULL ) { fFinalRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } else if ( fFinalRules -> size ( ) >= 2 ) { status = U_INVALID_STATE_ERROR ; return ; } fFinalRules -> addElement ( ( void * ) rule , status ) ; } else { if ( fHistoricRules == NULL ) { fHistoricRules = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { return ; } } fHistoricRules -> addElement ( ( void * ) rule , status ) ; } fUpToDate = FALSE ; }
void RuleBasedTimeZone :: complete ( UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } if ( fUpToDate ) { return ; } if ( fFinalRules != NULL && fFinalRules -> size ( ) != 2 ) { status = U_INVALID_STATE_ERROR ; return ; } UBool * done = NULL ; if ( fHistoricRules != NULL || fFinalRules != NULL ) { TimeZoneRule * curRule = fInitialRule ; UDate lastTransitionTime = MIN_@@ MILLIS ; if ( fHistoricRules != NULL && fHistoricRules -> size ( ) > 0 ) { int32_t i ; int32_t historicCount = fHistoricRules -> size ( ) ; done = ( UBool * ) uprv_malloc ( sizeof ( UBool ) * historicCount ) ; if ( done == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } for ( i = 0 ; i < historicCount ; i ++ ) { done [ i ] = FALSE ; } while ( TRUE ) { int32_t curStdOffset = curRule -> getRawOffset ( ) ; int32_t curDstSavings = curRule -> getDSTSavings ( ) ; UDate nextTransitionTime = MAX_MILLIS ; TimeZoneRule * nextRule = NULL ; TimeZoneRule * r = NULL ; UBool avail ; UDate tt ; UnicodeString curName , name ; curRule -> getName ( curName ) ; for ( i = 0 ; i < historicCount ; i ++ ) { if ( done [ i ] ) { continue ; } r = ( TimeZoneRule * ) fHistoricRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( ! avail ) { done [ i ] = TRUE ; } else { r -> getName ( name ) ; if ( * r == * curRule || ( name == curName && r -> getRawOffset ( ) == curRule -> getRawOffset ( ) && r -> getDSTSavings ( ) == curRule -> getDSTSavings ( ) ) ) { continue ; } if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } if ( nextRule == NULL ) { UBool bDoneAll = TRUE ; for ( int32_t j = 0 ; j < historicCount ; j ++ ) { if ( ! done [ j ] ) { bDoneAll = FALSE ; break ; } } if ( bDoneAll ) { break ; } } if ( fFinalRules != NULL ) { for ( i = 0 ; i < 2 ; i ++ ) { TimeZoneRule * fr = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; if ( * fr == * curRule ) { continue ; } r = ( TimeZoneRule * ) fFinalRules -> elementAt ( i ) ; avail = r -> getNextStart ( lastTransitionTime , curStdOffset , curDstSavings , false , tt ) ; if ( avail ) { if ( tt < nextTransitionTime ) { nextTransitionTime = tt ; nextRule = r ; } } } } if ( nextRule == NULL ) { break ; } if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } Transition * trst = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( trst == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } trst -> time = nextTransitionTime ; trst -> from = curRule ; trst -> to = nextRule ; fHistoricTransitions -> addElement ( trst , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } lastTransitionTime = nextTransitionTime ; curRule = nextRule ; } } if ( fFinalRules != NULL ) { if ( fHistoricTransitions == NULL ) { fHistoricTransitions = new UVector ( status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } TimeZoneRule * rule0 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 0 ) ; TimeZoneRule * rule1 = ( TimeZoneRule * ) fFinalRules -> elementAt ( 1 ) ; UDate tt0 , tt1 ; UBool avail0 = rule0 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt0 ) ; UBool avail1 = rule1 -> getNextStart ( lastTransitionTime , curRule -> getRawOffset ( ) , curRule -> getDSTSavings ( ) , false , tt1 ) ; if ( ! avail0 || ! avail1 ) { status = U_INVALID_STATE_ERROR ; goto cleanup ; } Transition * final0 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final0 == NULL ) { status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } Transition * final1 = ( Transition * ) uprv_malloc ( sizeof ( Transition ) ) ; if ( final1 == NULL ) { uprv_free ( final0 ) ; status = U_MEMORY_ALLOCATION_ERROR ; goto cleanup ; } if ( tt0 < tt1 ) { final0 -> time = tt0 ; final0 -> from = curRule ; final0 -> to = rule0 ; rule1 -> getNextStart ( tt0 , rule0 -> getRawOffset ( ) , rule0 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule0 ; final1 -> to = rule1 ; } else { final0 -> time = tt1 ; final0 -> from = curRule ; final0 -> to = rule1 ; rule0 -> getNextStart ( tt1 , rule1 -> getRawOffset ( ) , rule1 -> getDSTSavings ( ) , false , final1 -> time ) ; final1 -> from = rule1 ; final1 -> to = rule0 ; } fHistoricTransitions -> addElement ( final0 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } fHistoricTransitions -> addElement ( final1 , status ) ; if ( U_FAILURE ( status ) ) { goto cleanup ; } } } fUpToDate = TRUE ; if ( done != NULL ) { uprv_free ( done ) ; } return ; cleanup : deleteTransitions ( ) ; if ( done != NULL ) { uprv_free ( done ) ; } fUpToDate = FALSE ; }
void RuleBasedTimeZone :: getOffset@@ FromLocal ( UDate date , int32_t nonExistingTimeOpt , int32_t duplicatedTimeOpt , int32_t & rawOffset , int32_t & dstOffset , UErrorCode & status ) { getOffsetInternal ( date , TRUE , nonExistingTimeOpt , duplicatedTimeOpt , rawOffset , dstOffset , status ) ; }
UBool RuleBasedTimeZone :: getNextTransition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findNext ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; }
UBool RuleBasedTimeZone :: getPrevious@@ Transition ( UDate base , UBool inclusive , TimeZoneTransition & result ) { UErrorCode status = U_ZERO_ERROR ; complete ( status ) ; if ( U_FAILURE ( status ) ) { return FALSE ; } UDate transitionTime ; TimeZoneRule * fromRule , * toRule ; UBool found = findPrev ( base , inclusive , transitionTime , fromRule , toRule ) ; if ( found ) { result . setTime ( transitionTime ) ; result . setFrom ( ( const TimeZoneRule & ) * fromRule ) ; result . setTo ( ( const TimeZoneRule & ) * toRule ) ; return TRUE ; } return FALSE ; }
int32_t RuleBasedTimeZone :: countTransitionRules ( UErrorCode & ) { int32_t count = 0 ; if ( fHistoricRules != NULL ) { count += fHistoricRules -> size ( ) ; } if ( fFinalRules != NULL ) { count += fFinalRules -> size ( ) ; } return count ; }
void RuleBasedTimeZone :: getTimeZone@@ Rules ( const InitialTimeZoneRule * & initial , const TimeZoneRule * trsrules [ ] , int32_t & trscount , UErrorCode & status ) { if ( U_FAILURE ( status ) ) { return ; } initial = fInitialRule ; int32_t cnt = 0 ; int32_t idx ; if ( fHistoricRules != NULL && cnt < trscount ) { int32_t historicCount = fHistoricRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < historicCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fHistoricRules -> elementAt ( idx ++ ) ; } } if ( fFinalRules != NULL && cnt < trscount ) { int32_t finalCount = fFinalRules -> size ( ) ; idx = 0 ; while ( cnt < trscount && idx < finalCount ) { trsrules [ cnt ++ ] = ( const TimeZoneRule * ) fFinalRules -> elementAt ( idx ++ ) ; } } trscount = cnt ; }
void RuleBasedTimeZone :: deleteRules ( void ) { delete fInitialRule ; fInitialRule = NULL ; if ( fHistoricRules != NULL ) { while ( ! fHistoricRules -> isEmpty ( ) ) { delete ( TimeZoneRule * ) ( fHistoricRules -> orphanElementAt ( 0 ) ) ; } delete fHistoricRules ; fHistoricRules = NULL ; } if ( fFinalRules != NULL ) { while ( ! fFinalRules -> isEmpty ( ) ) { delete ( AnnualTimeZoneRule * ) ( fFinalRules -> orphanElementAt ( 0 ) ) ; } delete fFinalRules ; fFinalRules = NULL ; } }
void RuleBasedTimeZone :: deleteTransitions ( void ) { if ( fHistoricTransitions != NULL ) { while ( ! fHistoricTransitions -> isEmpty ( ) ) { Transition * trs = ( Transition * ) fHistoricTransitions -> orphanElementAt ( 0 ) ; uprv_free ( trs ) ; } delete fHistoricTransitions ; } fHistoricTransitions = NULL ; }
UVector * RuleBasedTimeZone :: copyRules ( UVector * source ) { if ( source == NULL ) { return NULL ; } UErrorCode ec = U_ZERO_ERROR ; int32_t size = source -> size ( ) ; UVector * rules = new UVector ( size , ec ) ; if ( U_FAILURE ( ec ) ) { return NULL ; } int32_t i ; for ( i = 0 ; i < size ; i ++ ) { rules -> addElement ( ( ( TimeZoneRule * ) source -> elementAt ( i ) ) -> clone ( ) , ec ) ; if ( U_FAILURE ( ec ) ) { break ; } } if ( U_FAILURE ( ec ) ) { for ( i = 0 ; i < rules -> size ( ) ; i ++ ) { TimeZoneRule * rule = ( TimeZoneRule * ) rules -> orphanElementAt ( i ) ; delete rule ; } delete rules ; return NULL ; } return rules ; }
ProximityGrid :: ~ ProximityGrid ( ) { dtFree ( m_buckets ) ; dtFree ( m_pool ) ; }
bool ProximityGrid :: init ( const int maxItems , const float cellSize ) { dtAssert ( maxItems > 0 ) ; dtAssert ( cellSize > 0.0f ) ; m_cellSize = cellSize ; m_invCellSize = 1.0f / m_cellSize ; m_bucketsSize = dtNext@@ Pow2 ( maxItems ) ; m_buckets = ( unsigned short * ) dtAlloc ( sizeof ( unsigned short ) * m_bucketsSize , DT_ALLOC_PERM ) ; if ( ! m_buckets ) return false ; m_poolSize = maxItems * 4 ; m_poolHead = 0 ; m_pool = ( Item * ) dtAlloc ( sizeof ( Item ) * m_poolSize , DT_ALLOC_PERM ) ; if ( ! m_pool ) return false ; clear ( ) ; return true ; }
void ProximityGrid :: clear ( ) { memset ( m_buckets , 0xff , sizeof ( unsigned short ) * m_bucketsSize ) ; m_poolHead = 0 ; m_bounds [ 0 ] = 0xffff ; m_bounds [ 1 ] = 0xffff ; m_bounds [ 2 ] = - 0xffff ; m_bounds [ 3 ] = - 0xffff ; }
void ProximityGrid :: addItem ( const unsigned short id , const float minx , const float miny , const float maxx , const float maxy ) { const int iminx = ( int ) floorf ( minx * m_invCellSize ) ; const int iminy = ( int ) floorf ( miny * m_invCellSize ) ; const int imaxx = ( int ) floorf ( maxx * m_invCellSize ) ; const int imaxy = ( int ) floorf ( maxy * m_invCellSize ) ; m_bounds [ 0 ] = dtMin ( m_bounds [ 0 ] , iminx ) ; m_bounds [ 1 ] = dtMin ( m_bounds [ 1 ] , iminy ) ; m_bounds [ 2 ] = dtMax ( m_bounds [ 2 ] , imaxx ) ; m_bounds [ 3 ] = dtMax ( m_bounds [ 3 ] , imaxy ) ; for ( int y = iminy ; y <= imaxy ; ++ y ) { for ( int x = iminx ; x <= imaxx ; ++ x ) { if ( m_poolHead < m_poolSize ) { const int h = hashPos2 ( x , y , m_bucketsSize ) ; const unsigned short idx = ( unsigned short ) m_poolHead ; m_poolHead ++ ; Item & item = m_pool [ idx ] ; item . x = ( short ) x ; item . y = ( short ) y ; item . id = id ; item . next = m_buckets [ h ] ; m_buckets [ h ] = idx ; } } } }
int asCScriptEngine :: SetEngineProperty ( asEEngineProp property , asPWORD value ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : ep . allowUnsafeReferences = value ? true : false ; break ; case asEP_OPTIMIZE_BYTECODE : ep . optimizeByteCode = value ? true : false ; break ; case asEP_COPY_SCRIPT_SECTIONS : ep . copyScriptSections = value ? true : false ; break ; case asEP_MAX_STACK_SIZE : ep . maximumContextStackSize = ( int ) value / 4 ; if ( initialContextStackSize > ep . maximumContextStackSize ) initialContextStackSize = ep . maximumContextStackSize ; break ; case asEP_USE_CHARACTER_LITERALS : ep . useCharacterLiterals = value ? true : false ; break ; case asEP_ALLOW_MULTILINE_STRINGS : ep . allowMultilineStrings = value ? true : false ; break ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : ep . allowImplicitHandleTypes = value ? true : false ; break ; case asEP_BUILD_WITHOUT_LINE_CUES : ep . buildWithoutLineCues = value ? true : false ; break ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : ep . initGlobalVarsAfterBuild = value ? true : false ; break ; case asEP_REQUIRE_ENUM_SCOPE : ep . requireEnumScope = value ? true : false ; break ; case asEP_SCRIPT_SCANNER : if ( value <= 1 ) ep . scanner = ( int ) value ; else return asINVALID_ARG ; break ; case asEP_INCLUDE_JIT_INSTRUCTIONS : ep . includeJitInstructions = value ? true : false ; break ; case asEP_STRING_ENCODING : if ( value <= 1 ) ep . stringEncoding = ( int ) value ; else return asINVALID_ARG ; break ; default : return asINVALID_ARG ; } return asSUCCESS ; }
asPWORD asCScriptEngine :: GetEngineProperty ( asEEngineProp property ) { switch ( property ) { case asEP_ALLOW_UNSAFE_REFERENCES : return ep . allowUnsafeReferences ; case asEP_OPTIMIZE_BYTECODE : return ep . optimizeByteCode ; case asEP_COPY_SCRIPT_SECTIONS : return ep . copyScriptSections ; case asEP_MAX_STACK_SIZE : return ep . maximumContextStackSize * 4 ; case asEP_USE_CHARACTER_LITERALS : return ep . useCharacterLiterals ; case asEP_ALLOW_MULTILINE_STRINGS : return ep . allowMultilineStrings ; case asEP_ALLOW_IMPLICIT_HANDLE_TYPES : return ep . allowImplicitHandleTypes ; case asEP_BUILD_WITHOUT_LINE_CUES : return ep . buildWithoutLineCues ; case asEP_INIT_GLOBAL_VARS_AFTER_BUILD : return ep . initGlobalVarsAfterBuild ; case asEP_REQUIRE_ENUM_SCOPE : return ep . requireEnumScope ; case asEP_SCRIPT_SCANNER : return ep . scanner ; case asEP_INCLUDE_JIT_INSTRUCTIONS : return ep . includeJitInstructions ; case asEP_STRING_ENCODING : return ep . stringEncoding ; } return 0 ; }
asCScriptEngine :: asCScriptEngine ( ) { if ( threadManager == 0 ) threadManager = asNEW ( asCThread@@ Manager ) ; else threadManager -> AddRef ( ) ; ep . allowUnsafeReferences = false ; ep . optimizeByteCode = true ; ep . copyScriptSections = true ; ep . maximumContextStackSize = 0 ; ep . useCharacterLiterals = false ; ep . allowMultilineStrings = false ; ep . allowImplicitHandleTypes = false ; ep . buildWithoutLineCues = false ; ep . initGlobalVarsAfterBuild = true ; ep . requireEnumScope = false ; ep . scanner = 1 ; ep . includeJitInstructions = false ; ep . stringEncoding = 0 ; gc . engine = this ; refCount . set ( 1 ) ; stringFactory = 0 ; configFailed = false ; isPrepared = false ; isBuilding = false ; lastModule = 0 ; userData = 0 ; initialContextStackSize = 1024 ; typeIdSeqNbr = 0 ; currentGroup = & defaultGroup ; msgCallback = 0 ; jitCompiler = 0 ; scriptFunctions . PushLast ( 0 ) ; int id ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ; asASSERT ( id == asTYPEID_VO@@ ID ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ; asASSERT ( id == asTYPEID_BOOL ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt8 , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt16 , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttInt64 , false ) ) ; asASSERT ( id == asTYPEID_INT@@ 64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt8 , false ) ) ; asASSERT ( id == asTYPEID_UINT@@ 8 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt16 , false ) ) ; asASSERT ( id == asTYPEID_UINT@@ 16 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt , false ) ) ; asASSERT ( id == asTYPEID_UINT32 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttUInt64 , false ) ) ; asASSERT ( id == asTYPEID_UINT@@ 64 ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttFloat , false ) ) ; asASSERT ( id == asTYPE@@ ID_FLOAT ) ; id = GetTypeIdFromDataType ( asCDataType :: CreatePrimitive ( ttDouble , false ) ) ; asASSERT ( id == asTYPEID_DOUBLE ) ; defaultArrayObjectType = 0 ; RegisterArray@@ Object ( this ) ; RegisterScriptObject ( this ) ; RegisterScriptFunction ( this ) ; RegisterObject@@ TypeGC@@ Behaviours ( this ) ; }
asCScriptEngine :: ~ asCScriptEngine ( ) { asASSERT ( refCount . get ( ) == 0 ) ; asUINT n ; for ( n = ( asUINT ) scriptModules . GetLength ( ) ; n -- > 0 ; ) { if ( scriptModules [ n ] ) { asDELETE ( scriptModules [ n ] , asCModule ) ; } } scriptModules . SetLength ( 0 ) ; GarbageCollect ( asGC_FULL_CYCLE ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { asUINT f ; for ( f = 0 ; f < templateTypes [ n ] -> beh . factories . GetLength ( ) ; f ++ ) { scriptFunctions [ templateTypes [ n ] -> beh . factories [ f ] ] -> Release ( ) ; } templateTypes [ n ] -> beh . factories . Allocate ( 0 , false ) ; for ( f = 1 ; f < templateTypes [ n ] -> beh . operators . GetLength ( ) ; f += 2 ) { if ( scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> objectType == templateTypes [ n ] ) { scriptFunctions [ templateTypes [ n ] -> beh . operators [ f ] ] -> Release ( ) ; templateTypes [ n ] -> beh . operators [ f ] = 0 ; } } } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; for ( n = 0 ; n < classTypes . GetLength ( ) ; n ++ ) { if ( classTypes [ n ] ) classTypes [ n ] -> ReleaseAllFunctions ( ) ; if ( classTypes [ n ] -> derivedFrom ) { classTypes [ n ] -> derivedFrom -> Release ( ) ; classTypes [ n ] -> derivedFrom = 0 ; } } GarbageCollect ( asGC_FULL_CYCLE ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; asSMapNode < int , asCDataType * > * cursor = 0 ; while ( mapTypeIdToDataType . MoveFirst ( & cursor ) ) { asDELETE ( mapTypeIdToDataType . GetValue ( cursor ) , asCDataType ) ; mapTypeIdToDataType . Erase ( cursor ) ; } defaultGroup . RemoveConfiguration ( this ) ; while ( configGroups . GetLength ( ) ) { asCConfigGroup * grp = configGroups . PopLast ( ) ; if ( grp ) { asDELETE ( grp , asCConfigGroup ) ; } } for ( n = 0 ; n < registeredGlobalProps . GetLength ( ) ; n ++ ) { if ( registeredGlobalProps [ n ] ) { asDELETE ( registeredGlobalProps [ n ] , asCGlobalProperty ) ; } } registeredGlobalProps . SetLength ( 0 ) ; FreeUnusedGlobalProperties ( ) ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] ) { templateTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( templateTypes [ n ] , asCObjectType ) ; } } templateTypes . SetLength ( 0 ) ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] ) { objectTypes [ n ] -> templateSubType = asCDataType :: CreateNullHandle ( ) ; asDELETE ( objectTypes [ n ] , asCObjectType ) ; } } objectTypes . SetLength ( 0 ) ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] ) { asDELETE ( templateSubTypes [ n ] , asCObjectType ) ; } } templateSubTypes . SetLength ( 0 ) ; registeredTypeDefs . SetLength ( 0 ) ; registeredEnums . SetLength ( 0 ) ; registeredObjTypes . SetLength ( 0 ) ; for ( n = 0 ; n < registeredGlobalFuncs . GetLength ( ) ; n ++ ) { if ( registeredGlobalFuncs [ n ] ) registeredGlobalFuncs [ n ] -> Release ( ) ; } registeredGlobalFuncs . SetLength ( 0 ) ; scriptTypeBehaviours . ReleaseAllFunctions ( ) ; functionBehaviours . ReleaseAllFunctions ( ) ; objectTypeBehaviours . ReleaseAllFunctions ( ) ; for ( n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { asDELETE ( stringConstants [ n ] , asCString ) ; } stringConstants . SetLength ( 0 ) ; for ( n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { asDELETE ( scriptSectionNames [ n ] , asCString ) ; } scriptSectionNames . SetLength ( 0 ) ; threadManager -> Release ( ) ; }
int asCScriptEngine :: AddRef ( ) { return refCount . atomic@@ Inc ( ) ; }
int asCScriptEngine :: Release ( ) { int r = refCount . atomic@@ Dec ( ) ; if ( r == 0 ) { asDELETE ( this , asCScriptEngine ) ; return 0 ; } return r ; }
void * asCScriptEngine :: SetUserData ( void * data ) { void * old = userData ; userData = data ; return old ; }
void * asCScriptEngine :: GetUserData ( ) { return userData ; }
int asCScriptEngine :: SetMessageCallback ( const asSFuncPtr & callback , void * obj , asDWORD callConv ) { msgCallback = true ; msgCallbackObj = obj ; bool isObj = false ; if ( ( unsigned ) callConv == asCALL_GENERIC ) { msgCallback = false ; return asNOT_SUPPORTED ; } if ( ( unsigned ) callConv >= asCALL_THISCALL ) { isObj = true ; if ( obj == 0 ) { msgCallback = false ; return asINVALID_ARG ; } } int r = DetectCallingConvention ( isObj , callback , callConv , & msgCallbackFunc ) ; if ( r < 0 ) msgCallback = false ; return r ; }
int asCScriptEngine :: ClearMessageCallback ( ) { msgCallback = false ; return 0 ; }
int asCScriptEngine :: WriteMessage ( const char * section , int row , int col , asEMsg@@ Type type , const char * message ) { if ( section == 0 || message == 0 ) return asINVALID_ARG ; if ( ! msgCallback ) return 0 ; asSMessageInfo msg ; msg . section = section ; msg . row = row ; msg . col = col ; msg . type = type ; msg . message = message ; if ( msgCallbackFunc . callConv < ICC_THISCALL ) CallGlobalFunction ( & msg , msgCallbackObj , & msgCallbackFunc , 0 ) ; else CallObjectMethod ( msgCallbackObj , & msg , & msgCallbackFunc , 0 ) ; return 0 ; }
int asCScriptEngine :: SetJITCompiler ( asIJITCompiler * compiler ) { jitCompiler = compiler ; return asSUCCESS ; }
asIJITCompiler * asCScriptEngine :: GetJITCompiler ( ) { return jitCompiler ; }
asETokenClass asCScriptEngine :: ParseToken ( const char * string , size_t stringLength , int * tokenLength ) { if ( stringLength == 0 ) stringLength = strlen ( string ) ; size_t len ; asCTokenizer t ; asETokenClass tc ; t . GetToken ( string , stringLength , & len , & tc ) ; if ( tokenLength ) * tokenLength = ( int ) len ; return tc ; }
asIScriptModule * asCScriptEngine :: GetModule ( const char * module , asEGM@@ Flags flag ) { asCModule * mod = GetModule ( module , false ) ; if ( flag == asGM_@@ ALWAYS_CREATE ) { if ( mod != 0 ) { asDELETE ( mod , asCModule ) ; } return GetModule ( module , true ) ; } if ( mod == 0 && flag == asGM_@@ CREATE_IF_NOT_EXI@@ STS ) { return GetModule ( module , true ) ; } return mod ; }
int asCScriptEngine :: DiscardModule ( const char * module ) { asCModule * mod = GetModule ( module , false ) ; if ( mod == 0 ) return asNO_@@ MODULE ; asDELETE ( mod , asCModule ) ; FreeUnusedGlobalProperties ( ) ; ClearUnusedTypes ( ) ; return 0 ; }
void asCScriptEngine :: ClearUnusedTypes ( ) { asCArray < asCObjectType * > types ; types = classTypes ; types . Concat@@ enate ( templateInstanceTypes ) ; asUINT n ; for ( n = 0 ; n < scriptModules . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCModule * mod = scriptModules [ n ] ; if ( mod ) { asUINT m ; for ( m = 0 ; m < mod -> classTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> classTypes [ m ] ) ; for ( m = 0 ; m < mod -> enumTypes . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> enumTypes [ m ] ) ; for ( m = 0 ; m < mod -> typeDefs . GetLength ( ) && types . GetLength ( ) ; m ++ ) RemoveTypeAndRelatedFromList ( types , mod -> typeDefs [ m ] ) ; } } for ( n = 0 ; n < scriptFunctions . GetLength ( ) && types . GetLength ( ) ; n ++ ) { asCScriptFunction * func = scriptFunctions [ n ] ; if ( func ) { if ( func -> name == " factstub " ) continue ; asCObjectType * ot = func -> returnType . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { ot = func -> parameterTypes [ p ] . GetObjectType ( ) ; if ( ot != 0 && ot != func -> objectType ) if ( func -> name != ot -> name ) RemoveTypeAndRelatedFromList ( types , ot ) ; } } } for ( n = 0 ; n < globalProperties . GetLength ( ) && types . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> type . GetObjectType ( ) ) RemoveTypeAndRelatedFromList ( types , globalProperties [ n ] -> type . GetObjectType ( ) ) ; } for ( ; ; ) { bool didClearTemplateInstanceType = false ; for ( n = 0 ; n < types . GetLength ( ) ; n ++ ) { int refCount = ( ( types [ n ] -> flags & asOBJ_TEMPLATE ) || ( types [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) ? 2 * ( int ) types [ n ] -> beh . factories . GetLength ( ) : 0 ; if ( types [ n ] -> GetRefCount ( ) == refCount ) { if ( types [ n ] -> flags & asOBJ_TEMPLATE ) { didClearTemplateInstanceType = true ; RemoveTemplateInstanceType ( types [ n ] ) ; } else { RemoveFromTypeIdMap ( types [ n ] ) ; asDELETE ( types [ n ] , asCObjectType ) ; int i = classTypes . IndexOf ( types [ n ] ) ; if ( i == ( signed ) classTypes . GetLength ( ) - 1 ) classTypes . PopLast ( ) ; else classTypes [ i ] = classTypes . PopLast ( ) ; } if ( n < types . GetLength ( ) - 1 ) types [ n ] = types . PopLast ( ) ; else types . PopLast ( ) ; n -- ; } } if ( didClearTemplateInstanceType == false ) break ; } }
void asCScriptEngine :: RemoveTypeAndRelatedFromList ( asCArray < asCObjectType * > & types , asCObjectType * ot ) { int i = types . IndexOf ( ot ) ; if ( i == - 1 ) return ; if ( i == ( signed ) types . GetLength ( ) - 1 ) types . PopLast ( ) ; else types [ i ] = types . PopLast ( ) ; if ( ot -> templateSubType . GetObjectType ( ) ) { while ( ot -> templateSubType . GetObjectType ( ) ) { ot = ot -> templateSubType . GetObjectType ( ) ; RemoveTypeAndRelatedFromList ( types , ot ) ; } return ; } if ( ot -> properties . GetLength ( ) ) { for ( asUINT n = 0 ; n < ot -> properties . GetLength ( ) ; n ++ ) RemoveTypeAndRelatedFromList ( types , ot -> properties [ n ] -> type . GetObjectType ( ) ) ; } }
int asCScriptEngine :: GetFactory@@ IdByDecl ( const asCObjectType * ot , const char * decl ) { asCModule * mod = 0 ; if ( ot -> flags & asOBJ_SCRIPT_OBJECT && ot -> size > 0 ) mod = scriptFunctions [ ot -> beh . factory ] -> module ; asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> beh . factories . GetLength ( ) ; n ++ ) { asCScriptFunction * f = scriptFunctions [ ot -> beh . factories [ n ] ] ; if ( f -> IsSignatureEqual ( & func ) ) { id = ot -> beh . factories [ n ] ; break ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; }
int asCScriptEngine :: GetMethod@@ IdByDecl ( const asCObjectType * ot , const char * decl , asCModule * mod ) { asCBuilder bld ( this , mod ) ; asCScriptFunction func ( this , mod , - 1 ) ; int r = bld . ParseFunctionDeclaration ( 0 , decl , & func , false ) ; if ( r < 0 ) return asINVALID_DECLARATION ; func . objectType = const_cast < asCObjectType * > ( ot ) ; int id = - 1 ; for ( size_t n = 0 ; n < ot -> methods . GetLength ( ) ; ++ n ) { if ( func . IsSignatureEqual ( scriptFunctions [ ot -> methods [ n ] ] ) ) { if ( id == - 1 ) id = ot -> methods [ n ] ; else return asMULTIP@@ LE_FUNC@@ TIONS ; } } if ( id == - 1 ) return asNO_FUNCTION ; return id ; }
asCString asCScriptEngine :: GetFunctionDeclaration ( int funcID ) { asCString str ; asCScriptFunction * func = GetScriptFunction ( funcID ) ; if ( func ) str = func -> GetDeclar@@ ationStr ( ) ; return str ; }
asCScriptFunction * asCScriptEngine :: GetScriptFunction ( int funcId ) { if ( funcId < 0 || funcId >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; return scriptFunctions [ funcId ] ; }
asIScriptContext * asCScriptEngine :: CreateContext ( ) { asIScriptContext * ctx = 0 ; CreateContext ( & ctx , false ) ; return ctx ; }
int asCScriptEngine :: CreateContext ( asIScriptContext * * context , bool isInternal ) { * context = asNEW ( asCContext ) ( this , ! isInternal ) ; PrepareEngine ( ) ; return 0 ; }
int asCScriptEngine :: RegisterObject@@ Property ( const char * obj , const char * declaration , int byteOffset ) { int r ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( currentGroup -> FindType ( dt . GetObjectType ( ) -> name . AddressOf ( ) ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType type ; asCString name ; if ( ( r = bld . VerifyProperty ( & dt , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_OBJECT ) ; asCObjectProperty * prop = asNEW ( asCObjectProperty ) ; prop -> name = name ; prop -> type = type ; prop -> byteOffset = byteOffset ; dt . GetObjectType ( ) -> properties . PushLast ( prop ) ; currentGroup -> RefConfigGroup ( FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ) ; return asSUCCESS ; }
int asCScriptEngine :: RegisterInterface ( const char * name ) { if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; } asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; st -> flags = asOBJ_REF | asOBJ_SCRIPT_OBJECT ; st -> size = 0 ; st -> name = name ; st -> beh . factory = 0 ; st -> beh . addref = scriptTypeBehaviours . beh . addref ; scriptFunctions [ st -> beh . addref ] -> AddRef ( ) ; st -> beh . release = scriptTypeBehaviours . beh . release ; scriptFunctions [ st -> beh . release ] -> AddRef ( ) ; st -> beh . copy = 0 ; objectTypes . PushLast ( st ) ; registeredObjTypes . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; }
int asCScriptEngine :: RegisterInterface@@ Method ( const char * intf , const char * declaration ) { if ( currentGroup -> FindType ( intf ) == 0 ) return ConfigError ( asWRONG_CONFIG_GROUP ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( intf , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_@@ INTERFACE ) ; func -> objectType = dt . GetObjectType ( ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , false ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflictMember ( dt , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; func -> objectType -> methods . PushLast ( func -> id ) ; func -> ComputeSignature@@ Id ( ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; }
int asCScriptEngine :: RegisterObjectType ( const char * name , int byteSize , asDWORD flags ) { int r ; isPrepared = false ; if ( flags & asOBJ_REF ) { if ( flags & ~ ( asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_GC ) && ( flags & ( asOBJ_NOHANDLE | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_NOHANDLE ) && ( flags & ( asOBJ_GC | asOBJ_SCOPED ) ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_SCOPED ) && ( flags & ( asOBJ_GC | asOBJ_NOHANDLE ) ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_VALUE ) { if ( flags & ( asOBJ_REF | asOBJ_GC | asOBJ_SCOPED ) ) return ConfigError ( asINVALID_ARG ) ; if ( flags & asOBJ_APP_CLASS ) { if ( flags & ( asOBJ_APP_PRIMITIVE | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_PRIMITIVE ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_FLOAT ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & asOBJ_APP_FLOAT ) { if ( flags & ( asOBJ_APP_CLASS | asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT | asOBJ_APP_PRIMITIVE ) ) return ConfigError ( asINVALID_ARG ) ; } else if ( flags & ( asOBJ_APP_CLASS_CONSTRUCTOR | asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_ASSIGNMENT ) ) { return ConfigError ( asINVALID_ARG ) ; } } else return ConfigError ( asINVALID_ARG ) ; if ( flags - ( flags & asOBJ_MAS@@ K_VAL@@ ID_FLA@@ GS ) ) return ConfigError ( asINVALID_ARG ) ; if ( ( flags & asOBJ_VALUE ) && byteSize == 0 ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_VALUE_@@ TYPE_MU@@ ST_HAVE_@@ SIZE ) ; return ConfigError ( asINVALID_ARG ) ; } if ( name == 0 ) return ConfigError ( asINVALID_NAME ) ; asCString typeName ; asCBuilder bld ( this , 0 ) ; if ( flags & asOBJ_TEMPLATE ) { asCString subtypeName ; r = bld . ParseTemplate@@ Decl ( name , & typeName , & subtypeName ) ; if ( r < 0 ) return r ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; asCObjectType * subtype = 0 ; for ( n = 0 ; n < templateSubTypes . GetLength ( ) ; n ++ ) { if ( templateSubTypes [ n ] -> name == subtypeName ) { subtype = templateSubTypes [ n ] ; break ; } } if ( subtype == 0 ) { subtype = asNEW ( asCObjectType ) ( this ) ; subtype -> name = subtypeName ; subtype -> size = 0 ; subtype -> flags = asOBJ_TEMPLATE_@@ SUBTYPE ; templateSubTypes . PushLast ( subtype ) ; subtype -> AddRef ( ) ; } type -> templateSubType = asCDataType :: CreateObject ( subtype , false ) ; subtype -> AddRef ( ) ; currentGroup -> objTypes . PushLast ( type ) ; if ( defaultArrayObjectType == 0 ) { defaultArrayObjectType = type ; type -> AddRef ( ) ; } else { registeredObjTypes . PushLast ( type ) ; } } else { typeName = name ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == typeName ) return asALREADY_REGISTERED ; } asCObjectType * mostRecentTemplateInstanceType = 0 ; if ( templateInstanceTypes . GetLength ( ) ) mostRecentTemplateInstanceType = templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] ; asCDataType dt ; bool oldMsgCallback = msgCallback ; msgCallback = false ; r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r < 0 ) { asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , typeName . GetLength ( ) , & tokenLen ) ; if ( token != ttIdentifier || typeName . GetLength ( ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; int r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = typeName ; type -> size = byteSize ; type -> flags = flags ; objectTypes . PushLast ( type ) ; registeredObjTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; } else { if ( dt . GetSubType ( ) . IsTemplate ( ) ) return ConfigError ( asLO@@ WER_ARRAY_@@ DIMENSION_@@ NOT_REGISTERED ) ; if ( dt . IsReadOnly ( ) || dt . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; if ( templateInstanceTypes [ templateInstanceTypes . GetLength ( ) - 1 ] == mostRecentTemplateInstanceType || mostRecentTemplateInstanceType == dt . GetObjectType ( ) ) return ConfigError ( asNOT_SUPPORTED ) ; asCObjectType * type = asNEW ( asCObjectType ) ( this ) ; type -> name = dt . GetObjectType ( ) -> name ; type -> templateSubType = dt . GetSubType ( ) ; if ( type -> templateSubType . GetObjectType ( ) ) type -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; type -> size = byteSize ; type -> flags = flags ; templateTypes . PushLast ( type ) ; currentGroup -> objTypes . PushLast ( type ) ; RemoveTemplateInstanceType ( dt . GetObjectType ( ) ) ; } } return asSUCCESS ; }
int asCScriptEngine :: RegisterObject@@ Behaviour ( const char * datatype , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( datatype == 0 ) return ConfigError ( asINVALID_ARG ) ; asCBuilder bld ( this , 0 ) ; asCDataType type ; int r = bld . ParseDataType ( datatype , & type ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( type . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_TYPE ) ; if ( type . IsReadOnly ( ) || type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; return RegisterBehaviourToObjectType ( type . GetObjectType ( ) , behaviour , decl , funcPointer , callConv ) ; }
int asCScriptEngine :: RegisterBehaviourToObjectType ( asCObjectType * objectType , asEBehaviours behaviour , const char * decl , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; if ( behaviour == asBEHAVE_FACTORY || behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } else { if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; } isPrepared = false ; asST@@ ypeBehaviour * beh = & objectType -> beh ; asCScriptFunction func ( this , 0 , - 1 ) ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseFunctionDeclaration ( objectType , decl , & func , true , & internal . paramAutoHandles , & internal . returnAutoHandle ) ; if ( r < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . name . Format ( " _ beh _ % d _ " , behaviour ) ; if ( behaviour != asBEHAVE_FACTORY ) func . objectType = objectType ; if ( objectType -> flags & asOBJ_TEMPLATE ) { if ( func . returnType . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . returnType . IsObjectHandle ( ) ) objectType -> acceptValueSubType = false ; else if ( ! func . returnType . IsReference ( ) ) objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { if ( func . parameterTypes [ n ] . GetObjectType ( ) == objectType -> templateSubType . GetObjectType ( ) ) { if ( func . parameterTypes [ n ] . IsObjectHandle ( ) || ( func . parameterTypes [ n ] . IsReference ( ) && func . inOutFlags [ n ] == asTM_INOUTREF ) ) objectType -> acceptValueSubType = false ; else if ( ! func . parameterTypes [ n ] . IsReference ( ) ) objectType -> acceptRefSubType = false ; } } } if ( behaviour == asBEHAVE_CONSTR@@ UCT ) { if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( objectType -> flags & asOBJ_SCRIPT_OBJECT ) { asASSERT ( func . parameterTypes . GetLength ( ) == 1 ) ; beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> factory = beh -> construct ; scriptFunctions [ beh -> factory ] -> AddRef ( ) ; beh -> constructors . PushLast ( beh -> construct ) ; beh -> factories . PushLast ( beh -> factory ) ; func . id = beh -> construct ; } else { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . parameterTypes . GetLength ( ) == 0 ) { func . id = beh -> construct = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( beh -> construct ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> constructors . PushLast ( func . id ) ; } } } else if ( behaviour == asBEHAVE_DESTRUC@@ T ) { if ( ! ( func . objectType -> flags & asOBJ_VALUE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> destruct ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> destruct = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_FACTORY ) { if ( ! ( objectType -> flags & asOBJ_REF ) || ( objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( func . returnType != asCDataType :: CreateObjectHandle ( objectType , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( objectType -> flags & asOBJ_TEMPLATE ) && ( func . parameterTypes . GetLength ( ) == 0 || ! func . parameterTypes [ 0 ] . IsReference ( ) ) ) { return ConfigError ( asINVALID_DECLARATION ) ; } if ( ( func . parameterTypes . GetLength ( ) == 0 ) || ( func . parameterTypes . GetLength ( ) == 1 && ( objectType -> flags & asOBJ_TEMPLATE ) ) ) { func . id = beh -> factory = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( beh -> factory ) ; } else { func . id = AddBehaviourFunction ( func , internal ) ; beh -> factories . PushLast ( func . id ) ; } } else if ( behaviour == asBEHAVE_ADDREF ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) || ( func . objectType -> flags & asOBJ_SCOPED ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> addref ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> addref = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_RELEAS@@ E ) { if ( ! ( func . objectType -> flags & asOBJ_REF ) || ( func . objectType -> flags & asOBJ_NOHANDLE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> release ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) > 0 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> release = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_TEMPLATE_CALLBACK ) { if ( ! ( func . objectType -> flags & asOBJ_TEMPLATE ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( beh -> templateCallback ) return ConfigError ( asALREADY_REGISTERED ) ; if ( func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; func . id = beh -> templateCallback = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_INDEX ) { if ( VerifyVarTypeNotInFunction ( & func ) < 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . GetTokenType ( ) == ttVoid ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour >= asBEHAVE_FIRST_@@ GC && behaviour <= asBEHAVE_LAS@@ T_GC ) { if ( ! ( func . objectType -> flags & asOBJ_GC ) ) { WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE ) ; return ConfigError ( asILLEGAL_BEHAVIOUR_FOR_TYPE ) ; } if ( ( behaviour == asBEHAVE_GETREFCOUNT || behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_GETGCFLAG ) && func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . parameterTypes . GetLength ( ) != 1 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT && func . returnType != asCDataType :: CreatePrimitive ( ttInt , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETGCFLAG && func . returnType != asCDataType :: CreatePrimitive ( ttBool , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ( behaviour == asBEHAVE_SETGCFLAG || behaviour == asBEHAVE_ENUMREFS || behaviour == asBEHAVE_RELEASEREFS ) && func . returnType != asCDataType :: CreatePrimitive ( ttVoid , false ) ) return ConfigError ( asINVALID_DECLARATION ) ; if ( behaviour == asBEHAVE_GETREFCOUNT ) func . id = beh -> gcGetRefCount = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_SETGCFLAG ) func . id = beh -> gcSetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_GETGCFLAG ) func . id = beh -> gcGetFlag = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_ENUMREFS ) func . id = beh -> gcEnumReferences = AddBehaviourFunction ( func , internal ) ; else if ( behaviour == asBEHAVE_RELEASEREFS ) func . id = beh -> gcReleaseAllReferences = AddBehaviourFunction ( func , internal ) ; } else if ( behaviour == asBEHAVE_IMPLICIT_@@ VALUE_CAST || behaviour == asBEHAVE_VALUE_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttBool , false ) ) ) return ConfigError ( asNOT_SUPPORTED ) ; if ( func . returnType . IsEqualExceptRefAndConst ( asCDataType :: CreatePrimitive ( ttVoid , false ) ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else if ( behaviour == asBEHAVE_REF_CAST || behaviour == asBEHAVE_IMPLICIT_@@ REF_CAST ) { if ( func . parameterTypes . GetLength ( ) != 0 ) return ConfigError ( asINVALID_DECLARATION ) ; if ( ! func . returnType . IsObjectHandle ( ) ) return ConfigError ( asINVALID_DECLARATION ) ; beh -> operators . PushLast ( behaviour ) ; func . id = AddBehaviourFunction ( func , internal ) ; beh -> operators . PushLast ( func . id ) ; } else { asASSERT ( false ) ; return ConfigError ( asINVALID_ARG ) ; } return func . id ; }
int asCScriptEngine :: VerifyVarTypeNotInFunction ( asCScriptFunction * func ) { if ( func -> returnType . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; for ( unsigned int n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) if ( func -> parameterTypes [ n ] . GetTokenType ( ) == ttQuestion ) return asINVALID_DECLARATION ; return 0 ; }
int asCScriptEngine :: AddBehaviourFunction ( asCScriptFunction & func , asSSystemFunctionInterface & internal ) { asUINT n ; int id = GetNextScriptFunctionId ( ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ; newInterface -> func = internal . func ; newInterface -> baseOffset = internal . baseOffset ; newInterface -> callConv = internal . callConv ; newInterface -> scriptReturnSize = internal . scriptReturnSize ; newInterface -> hostReturnInMemory = internal . hostReturnInMemory ; newInterface -> hostReturnFloat = internal . hostReturnFloat ; newInterface -> hostReturnSize = internal . hostReturnSize ; newInterface -> paramSize = internal . paramSize ; newInterface -> takesObjByVal = internal . takesObjByVal ; newInterface -> paramAutoHandles = internal . paramAutoHandles ; newInterface -> returnAutoHandle = internal . returnAutoHandle ; newInterface -> hasAutoHandles = internal . hasAutoHandles ; asCScriptFunction * f = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; asASSERT ( func . name != " " && func . name != " f " ) ; f -> name = func . name ; f -> sysFuncIntf = newInterface ; f -> returnType = func . returnType ; f -> objectType = func . objectType ; f -> id = id ; f -> isReadOnly = func . isReadOnly ; for ( n = 0 ; n < func . parameterTypes . GetLength ( ) ; n ++ ) { f -> parameterTypes . PushLast ( func . parameterTypes [ n ] ) ; f -> inOutFlags . PushLast ( func . inOutFlags [ n ] ) ; } SetScriptFunction ( f ) ; if ( f -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( n = 0 ; n < f -> parameterTypes . GetLength ( ) ; n ++ ) { if ( f -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( f -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return id ; }
int asCScriptEngine :: RegisterGlobalProperty ( const char * declaration , void * pointer ) { asCDataType type ; asCString name ; int r ; asCBuilder bld ( this , 0 ) ; if ( ( r = bld . VerifyProperty ( 0 , declaration , name , type ) ) < 0 ) return ConfigError ( r ) ; if ( type . IsReference ( ) ) return ConfigError ( asINVALID_TYPE ) ; asCGlobalProperty * prop = AllocateGlobalProperty ( ) ; prop -> name = name ; prop -> type = type ; prop -> SetRegister@@ edAddress ( pointer ) ; registeredGlobalProps . PushLast ( prop ) ; currentGroup -> globalProps . PushLast ( prop ) ; if ( type . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( type . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } return asSUCCESS ; }
asCGlobalProperty * asCScriptEngine :: AllocateGlobalProperty ( ) { asCGlobalProperty * prop = asNEW ( asCGlobalProperty ) ; if ( freeGlobalPropertyIds . GetLength ( ) ) { prop -> id = freeGlobalPropertyIds . PopLast ( ) ; globalProperties [ prop -> id ] = prop ; return prop ; } prop -> id = ( asUINT ) globalProperties . GetLength ( ) ; globalProperties . PushLast ( prop ) ; return prop ; }
void asCScriptEngine :: FreeUnusedGlobalProperties ( ) { for ( asUINT n = 0 ; n < globalProperties . GetLength ( ) ; n ++ ) { if ( globalProperties [ n ] && globalProperties [ n ] -> refCount . get ( ) == 0 ) { freeGlobalPropertyIds . PushLast ( n ) ; asDELETE ( globalProperties [ n ] , asCGlobalProperty ) ; globalProperties [ n ] = 0 ; } } }
int asCScriptEngine :: GetGlobalProperty@@ Count ( ) { return ( int ) registeredGlobalProps . GetLength ( ) ; }
int asCScriptEngine :: GetGlobalProperty@@ ByIndex ( asUINT index , const char * * name , int * typeId , bool * isConst , const char * * configGroup , void * * pointer ) { if ( index >= registeredGlobalProps . GetLength ( ) ) return asINVALID_ARG ; if ( name ) * name = registeredGlobalProps [ index ] -> name . AddressOf ( ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForGlobalVar ( index ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( typeId ) * typeId = GetTypeIdFromDataType ( registeredGlobalProps [ index ] -> type ) ; if ( isConst ) * isConst = registeredGlobalProps [ index ] -> type . IsReadOnly ( ) ; if ( pointer ) * pointer = registeredGlobalProps [ index ] -> realAddress ; return asSUCCESS ; }
int asCScriptEngine :: RegisterObject@@ Method ( const char * obj , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { if ( obj == 0 ) return ConfigError ( asINVALID_ARG ) ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( obj , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( dt . GetObjectType ( ) == 0 ) return ConfigError ( asINVALID_ARG ) ; return RegisterMethodToObjectType ( dt . GetObjectType ( ) , declaration , funcPointer , callConv ) ; }
int asCScriptEngine :: RegisterMethodToObjectType ( asCObjectType * objectType , const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( true , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_THISCALL && callConv != asCALL_CDECL_OBJLAST && callConv != asCALL_CDECL_OBJFIRST && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; func -> objectType = objectType ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( func -> objectType , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } asCDataType x = asCDataType :: CreateObject ( objectType , false ) ; r = bld . CheckNameConflictMember ( x , func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; func -> objectType -> methods . PushLast ( func -> id ) ; SetScriptFunction ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } if ( func -> objectType -> flags & asOBJ_TEMPLATE ) { if ( func -> returnType . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> returnType . IsObjectHandle ( ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> returnType . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) == func -> objectType -> templateSubType . GetObjectType ( ) ) { if ( func -> parameterTypes [ n ] . IsObjectHandle ( ) || ( func -> parameterTypes [ n ] . IsReference ( ) && func -> inOutFlags [ n ] == asTM_INOUTREF ) ) func -> objectType -> acceptValueSubType = false ; else if ( ! func -> parameterTypes [ n ] . IsReference ( ) ) func -> objectType -> acceptRefSubType = false ; } } } if ( func -> name == " opAssign " && func -> parameterTypes . GetLength ( ) == 1 && func -> isReadOnly == false && ( objectType -> flags & asOBJ_SCRIPT_OBJECT || func -> parameterTypes [ 0 ] . IsEqualExceptRefAndConst ( asCDataType :: CreateObject ( func -> objectType , false ) ) ) ) { func -> objectType -> beh . copy = func -> id ; func -> AddRef ( ) ; } return func -> id ; }
int asCScriptEngine :: RegisterGlobalFunction ( const char * declaration , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; isPrepared = false ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; r = bld . ParseFunctionDeclaration ( 0 , declaration , func , true , & newInterface -> paramAutoHandles , & newInterface -> returnAutoHandle ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_DECLARATION ) ; } r = bld . CheckNameConflict ( func -> name . AddressOf ( ) , 0 , 0 ) ; if ( r < 0 ) { asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asNAME_TAKEN ) ; } func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; currentGroup -> scriptFunctions . PushLast ( func ) ; registeredGlobalFuncs . PushLast ( func ) ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } for ( asUINT n = 0 ; n < func -> parameterTypes . GetLength ( ) ; n ++ ) { if ( func -> parameterTypes [ n ] . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> parameterTypes [ n ] . GetObjectType ( ) ) ; currentGroup -> RefConfigGroup ( group ) ; } } return func -> id ; }
int asCScriptEngine :: GetGlobalFunction@@ Count ( ) { return ( int ) registeredGlobalFuncs . GetLength ( ) ; }
int asCScriptEngine :: GetGlobalFunction@@ IdByIndex ( asUINT index ) { if ( index >= registeredGlobalFuncs . GetLength ( ) ) return asINVALID_ARG ; return registeredGlobalFuncs [ index ] -> id ; }
asCObjectType * asCScriptEngine :: GetObjectType ( const char * type ) { for ( asUINT n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return objectTypes [ n ] ; return 0 ; }
void asCScriptEngine :: PrepareEngine ( ) { if ( isPrepared ) return ; if ( configFailed ) return ; asUINT n ; for ( n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> funcType == asFUNC_SYSTEM ) { if ( scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_FUNC || scriptFunctions [ n ] -> sysFuncIntf -> callConv == ICC_GENERIC_METHOD ) PrepareSystemFunction@@ Generic ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; else PrepareSystemFunction ( scriptFunctions [ n ] , scriptFunctions [ n ] -> sysFuncIntf , this ) ; } } for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && ! ( objectTypes [ n ] -> flags & asOBJ_SCRIPT_OBJECT ) ) { bool missingBehaviour = false ; const char * infoMsg = 0 ; if ( objectTypes [ n ] -> flags & asOBJ_GC ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 || objectTypes [ n ] -> beh . gcGetRefCount == 0 || objectTypes [ n ] -> beh . gcSetFlag == 0 || objectTypes [ n ] -> beh . gcGetFlag == 0 || objectTypes [ n ] -> beh . gcEnumReferences == 0 || objectTypes [ n ] -> beh . gcReleaseAllReferences == 0 ) { infoMsg = TXT_GC_@@ REQUIRE_ADD_REL_@@ GC_BEHAVIOUR ; missingBehaviour = true ; } } else if ( objectTypes [ n ] -> flags & asOBJ_SCOPED ) { if ( objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_S@@ COPE_REQUIR@@ E_REL_BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_REF ) && ! ( objectTypes [ n ] -> flags & asOBJ_NOHANDLE ) ) { if ( objectTypes [ n ] -> beh . addref == 0 || objectTypes [ n ] -> beh . release == 0 ) { infoMsg = TXT_REF_@@ REQUIRE_ADD_REL_@@ BEHAVIOUR ; missingBehaviour = true ; } } else if ( ( objectTypes [ n ] -> flags & asOBJ_VALUE ) && ! ( objectTypes [ n ] -> flags & asOBJ_POD ) ) { if ( objectTypes [ n ] -> beh . construct == 0 || objectTypes [ n ] -> beh . destruct == 0 ) { infoMsg = TXT_NON_@@ POD_REQUIRE_@@ CONSTR@@ _DESTR@@ _BEHAVIOUR ; missingBehaviour = true ; } } if ( missingBehaviour ) { asCString str ; str . Format ( TXT_TYPE_s_IS_@@ MISS@@ ING_BEHAVIOUR@@ S , objectTypes [ n ] -> name . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , str . AddressOf ( ) ) ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_INFOR@@ MATION , infoMsg ) ; ConfigError ( asINVALID_CONFIGURATION ) ; } } } isPrepared = true ; }
int asCScriptEngine :: ConfigError ( int err ) { configFailed = true ; return err ; }
int asCScriptEngine :: RegisterStringFactory ( const char * datatype , const asSFuncPtr & funcPointer , asDWORD callConv ) { asSSystemFunctionInterface internal ; int r = DetectCallingConvention ( false , funcPointer , callConv , & internal ) ; if ( r < 0 ) return ConfigError ( r ) ; if ( callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; if ( callConv != asCALL_CDECL && callConv != asCALL_STDCALL && callConv != asCALL_GENERIC ) return ConfigError ( asNOT_SUPPORTED ) ; asSSystemFunctionInterface * newInterface = asNEW ( asSSystemFunctionInterface ) ( internal ) ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SYSTEM ) ; func -> name = " _ string _ factory _ " ; func -> sysFuncIntf = newInterface ; asCBuilder bld ( this , 0 ) ; asCDataType dt ; r = bld . ParseDataType ( datatype , & dt ) ; if ( r < 0 ) { func -> funcType = - 1 ; asDELETE ( func , asCScriptFunction ) ; return ConfigError ( asINVALID_TYPE ) ; } func -> returnType = dt ; func -> parameterTypes . PushLast ( asCDataType :: CreatePrimitive ( ttInt , true ) ) ; asCDataType parm1 = asCDataType :: CreatePrimitive ( ttUInt8 , true ) ; parm1 . MakeReference ( true ) ; func -> parameterTypes . PushLast ( parm1 ) ; func -> id = GetNextScriptFunctionId ( ) ; SetScriptFunction ( func ) ; stringFactory = func ; if ( func -> returnType . GetObjectType ( ) ) { asCConfigGroup * group = FindConfigGroupForObjectType ( func -> returnType . GetObjectType ( ) ) ; if ( group == 0 ) group = & defaultGroup ; group -> scriptFunctions . PushLast ( func ) ; } return func -> id ; }
int asCScriptEngine :: GetStringFactory@@ ReturnTypeId ( ) { if ( stringFactory == 0 ) return asNO_FUNCTION ; return GetTypeIdFromDataType ( stringFactory -> returnType ) ; }
asCModule * asCScriptEngine :: GetModule ( const char * _name , bool create ) { const char * name = " " ; if ( _name != 0 ) name = _name ; if ( lastModule && lastModule -> name == name ) return lastModule ; for ( asUINT n = 0 ; n < scriptModules . GetLength ( ) ; ++ n ) if ( scriptModules [ n ] && scriptModules [ n ] -> name == name ) { lastModule = scriptModules [ n ] ; return lastModule ; } if ( create ) { asCModule * module = asNEW ( asCModule ) ( name , this ) ; scriptModules . PushLast ( module ) ; lastModule = module ; return lastModule ; } return 0 ; }
asCModule * asCScriptEngine :: GetModule@@ FromFunc@@ Id ( int id ) { if ( id < 0 ) return 0 ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return 0 ; asCScriptFunction * func = scriptFunctions [ id ] ; if ( func == 0 ) return 0 ; return func -> module ; }
int asCScriptEngine :: RequestBuild ( ) { ENTERCRITICAL@@ SECTION ( engineCritical ) ; if ( isBuilding ) { LEAVECRITICALSECTION ( engineCritical ) ; return asBUILD_@@ IN_PROGRESS ; } isBuilding = true ; LEAVECRITICALSECTION ( engineCritical ) ; return 0 ; }
void asCScriptEngine :: BuildCompleted ( ) { memory@@ Mgr . FreeUnused@@ Memory ( ) ; isBuilding = false ; }
int asCScriptEngine :: ExecuteString ( const char * module , const char * script , asIScriptContext * * ctx , asDWORD flags ) { int r ; if ( ( r = RequestBuild ( ) ) < 0 ) return r ; PrepareEngine ( ) ; if ( configFailed ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; WriteMessage ( " " , 0 , 0 , asMSGTYPE_ERROR , TXT_INVALID_CONFIGURATION ) ; isBuilding = false ; return asINVALID_CONFIGURATION ; } asIScriptContext * exec = 0 ; if ( ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { int r = CreateContext ( & exec , false ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) * ctx = 0 ; isBuilding = false ; return r ; } if ( ctx ) { * ctx = exec ; exec -> AddRef ( ) ; } } else { if ( * ctx == 0 ) { isBuilding = false ; return asINVALID_ARG ; } exec = * ctx ; exec -> AddRef ( ) ; } exec -> Unprepare ( ) ; asCModule * mod = GetModule ( module , true ) ; asCBuilder builder ( this , mod ) ; asCString str = script ; str = " void ▁ ExecuteString ( ) { \n " + str + " \n ; } " ; r = builder . BuildString ( str . AddressOf ( ) , ( asCContext * ) exec ) ; BuildCompleted ( ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return asERROR ; } r = ( ( asCContext * ) exec ) -> Prepare ( ( ( asCContext * ) exec ) -> stringFunction -> id ) ; if ( r < 0 ) { if ( ctx && ! ( flags & asEXECSTRING_USE_MY_CONTEXT ) ) { ( * ctx ) -> Release ( ) ; * ctx = 0 ; } exec -> Release ( ) ; return r ; } if ( flags & asEXECSTRING_@@ ONLY_@@ PREPAR@@ E ) r = asEXECUTION_@@ PREPAR@@ ED ; else r = exec -> Execute ( ) ; exec -> Release ( ) ; return r ; }
void asCScriptEngine :: RemoveTemplateInstanceType ( asCObjectType * t ) { int n ; for ( n = 0 ; n < ( int ) t -> beh . factories . GetLength ( ) ; n ++ ) { scriptFunctions [ t -> beh . factories [ n ] ] -> ReleaseAllHandles ( this ) ; scriptFunctions [ t -> beh . factories [ n ] ] -> Release ( ) ; } t -> beh . factories . SetLength ( 0 ) ; for ( n = 1 ; n < ( int ) t -> beh . operators . GetLength ( ) ; n += 2 ) { if ( t -> beh . operators [ n ] && scriptFunctions [ t -> beh . operators [ n ] ] -> objectType == t ) { scriptFunctions [ t -> beh . operators [ n ] ] -> Release ( ) ; } } t -> beh . operators . SetLength ( 0 ) ; for ( n = ( int ) templateTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateTypes [ n ] == t ) { if ( n == ( signed ) templateTypes . GetLength ( ) - 1 ) templateTypes . PopLast ( ) ; else templateTypes [ n ] = templateTypes . PopLast ( ) ; } } for ( n = ( int ) templateInstanceTypes . GetLength ( ) - 1 ; n >= 0 ; n -- ) { if ( templateInstanceTypes [ n ] == t ) { if ( n == ( signed ) templateInstanceTypes . GetLength ( ) - 1 ) templateInstanceTypes . PopLast ( ) ; else templateInstanceTypes [ n ] = templateInstanceTypes . PopLast ( ) ; } } asDELETE ( t , asCObjectType ) ; }
asCObjectType * asCScriptEngine :: GetTemplateInstanceType ( asCObjectType * templateType , asCDataType & subType ) { asUINT n ; for ( n = 0 ; n < templateTypes . GetLength ( ) ; n ++ ) { if ( templateTypes [ n ] && templateTypes [ n ] -> name == templateType -> name && templateTypes [ n ] -> templateSubType == subType ) return templateTypes [ n ] ; } if ( ! templateType -> acceptValueSubType && ( subType . IsPrimitive ( ) || ( subType . GetObjectType ( ) -> flags & asOBJ_VALUE ) ) ) return 0 ; if ( ! templateType -> acceptRefSubType && ( subType . IsObject ( ) && ( subType . GetObjectType ( ) -> flags & asOBJ_REF ) ) ) return 0 ; asCObjectType * ot = asNEW ( asCObjectType ) ( this ) ; ot -> templateSubType = subType ; ot -> flags = templateType -> flags ; ot -> size = templateType -> size ; ot -> name = templateType -> name ; if ( templateType -> beh . templateCallback ) { asCScriptFunction * callback = scriptFunctions [ templateType -> beh . templateCallback ] ; if ( ! CallGlobalFunctionRetBool ( ot , 0 , callback -> sysFuncIntf , callback ) ) { ot -> templateSubType = asCDataType ( ) ; asDELETE ( ot , asCObjectType ) ; return 0 ; } } ot -> methods = templateType -> methods ; for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> methods [ n ] ] -> AddRef ( ) ; ot -> beh . construct = templateType -> beh . factory ; ot -> beh . constructors = templateType -> beh . factories ; for ( n = 0 ; n < ot -> beh . constructors . GetLength ( ) ; n ++ ) scriptFunctions [ ot -> beh . constructors [ n ] ] -> AddRef ( ) ; for ( n = 0 ; n < templateType -> beh . factories . GetLength ( ) ; n ++ ) { int factoryId = templateType -> beh . factories [ n ] ; asCScriptFunction * factory = scriptFunctions [ factoryId ] ; asCScriptFunction * func = asNEW ( asCScriptFunction ) ( this , 0 , asFUNC_SCRIP@@ T ) ; func -> name = " factstub " ; func -> id = GetNextScriptFunctionId ( ) ; func -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; for ( asUINT p = 1 ; p < factory -> parameterTypes . GetLength ( ) ; p ++ ) { func -> parameterTypes . PushLast ( factory -> parameterTypes [ p ] ) ; func -> inOutFlags . PushLast ( factory -> inOutFlags [ p ] ) ; } SetScriptFunction ( func ) ; asCBuilder builder ( this , 0 ) ; asCCompiler compiler ( this ) ; compiler . CompileTemplate@@ Factory@@ Stub ( & builder , factoryId , ot , func ) ; ot -> beh . factories . PushLast ( func -> id ) ; } if ( ot -> beh . factories . GetLength ( ) ) ot -> beh . factory = ot -> beh . factories [ 0 ] ; else { asASSERT ( false ) ; ot -> beh . factory = templateType -> beh . factory ; } ot -> beh . addref = templateType -> beh . addref ; if ( scriptFunctions [ ot -> beh . addref ] ) scriptFunctions [ ot -> beh . addref ] -> AddRef ( ) ; ot -> beh . release = templateType -> beh . release ; if ( scriptFunctions [ ot -> beh . release ] ) scriptFunctions [ ot -> beh . release ] -> AddRef ( ) ; ot -> beh . copy = templateType -> beh . copy ; if ( scriptFunctions [ ot -> beh . copy ] ) scriptFunctions [ ot -> beh . copy ] -> AddRef ( ) ; ot -> beh . operators = templateType -> beh . operators ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> AddRef ( ) ; } ot -> beh . gcGetRefCount = templateType -> beh . gcGetRefCount ; if ( scriptFunctions [ ot -> beh . gcGetRefCount ] ) scriptFunctions [ ot -> beh . gcGetRefCount ] -> AddRef ( ) ; ot -> beh . gcSetFlag = templateType -> beh . gcSetFlag ; if ( scriptFunctions [ ot -> beh . gcSetFlag ] ) scriptFunctions [ ot -> beh . gcSetFlag ] -> AddRef ( ) ; ot -> beh . gcGetFlag = templateType -> beh . gcGetFlag ; if ( scriptFunctions [ ot -> beh . gcGetFlag ] ) scriptFunctions [ ot -> beh . gcGetFlag ] -> AddRef ( ) ; ot -> beh . gcEnumReferences = templateType -> beh . gcEnumReferences ; if ( scriptFunctions [ ot -> beh . gcEnumReferences ] ) scriptFunctions [ ot -> beh . gcEnumReferences ] -> AddRef ( ) ; ot -> beh . gcReleaseAllReferences = templateType -> beh . gcReleaseAllReferences ; if ( scriptFunctions [ ot -> beh . gcReleaseAllReferences ] ) scriptFunctions [ ot -> beh . gcReleaseAllReferences ] -> AddRef ( ) ; for ( n = 1 ; n < ot -> beh . operators . GetLength ( ) ; n += 2 ) { int funcId = ot -> beh . operators [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> beh . operators [ n ] ] -> Release ( ) ; ot -> beh . operators [ n ] = func -> id ; } } for ( n = 0 ; n < ot -> methods . GetLength ( ) ; n ++ ) { int funcId = ot -> methods [ n ] ; asCScriptFunction * func = scriptFunctions [ funcId ] ; if ( GenerateNewTemplateFunction ( templateType , ot , subType , func , & func ) ) { scriptFunctions [ ot -> methods [ n ] ] -> Release ( ) ; ot -> methods [ n ] = func -> id ; } } if ( ot -> templateSubType . GetObjectType ( ) ) ot -> templateSubType . GetObjectType ( ) -> AddRef ( ) ; if ( ot -> templateSubType . GetObjectType ( ) && ( ot -> templateSubType . GetObjectType ( ) -> flags & asOBJ_GC ) ) ot -> flags |= asOBJ_GC ; else if ( ot -> name == defaultArrayObjectType -> name ) ot -> flags &= ~ asOBJ_GC ; templateTypes . PushLast ( ot ) ; templateInstanceTypes . PushLast ( ot ) ; return ot ; }
bool asCScriptEngine :: GenerateNewTemplateFunction ( asCObjectType * templateType , asCObjectType * ot , asCDataType & subType , asCScriptFunction * func , asCScriptFunction * * newFunc ) { bool needNewFunc = false ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> returnType . GetObjectType ( ) == templateType ) needNewFunc = true ; else { for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) || func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { needNewFunc = true ; break ; } } } if ( needNewFunc ) { asCScriptFunction * func2 = asNEW ( asCScriptFunction ) ( this , 0 , func -> funcType ) ; func2 -> name = func -> name ; func2 -> id = GetNextScriptFunctionId ( ) ; if ( func -> returnType . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> returnType = subType ; if ( func -> returnType . IsObjectHandle ( ) ) func2 -> returnType . MakeHandle ( true , true ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else if ( func -> returnType . GetObjectType ( ) == templateType ) { if ( func2 -> returnType . IsObjectHandle ( ) ) func2 -> returnType = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> returnType = asCDataType :: CreateObject ( ot , false ) ; func2 -> returnType . MakeReference ( func -> returnType . IsReference ( ) ) ; func2 -> returnType . MakeReadOnly ( func -> returnType . IsReadOnly ( ) ) ; } else func2 -> returnType = func -> returnType ; func2 -> parameterTypes . SetLength ( func -> parameterTypes . GetLength ( ) ) ; for ( asUINT p = 0 ; p < func -> parameterTypes . GetLength ( ) ; p ++ ) { if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType -> templateSubType . GetObjectType ( ) ) { func2 -> parameterTypes [ p ] = subType ; if ( func -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] . MakeHandle ( true ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReference ( ) ) ; } else if ( func -> parameterTypes [ p ] . GetObjectType ( ) == templateType ) { if ( func2 -> parameterTypes [ p ] . IsObjectHandle ( ) ) func2 -> parameterTypes [ p ] = asCDataType :: CreateObjectHandle ( ot , false ) ; else func2 -> parameterTypes [ p ] = asCDataType :: CreateObject ( ot , false ) ; func2 -> parameterTypes [ p ] . MakeReference ( func -> parameterTypes [ p ] . IsReference ( ) ) ; func2 -> parameterTypes [ p ] . MakeReadOnly ( func -> parameterTypes [ p ] . IsReadOnly ( ) ) ; } else func2 -> parameterTypes [ p ] = func -> parameterTypes [ p ] ; } func2 -> inOutFlags = func -> inOutFlags ; func2 -> isReadOnly = func -> isReadOnly ; func2 -> objectType = ot ; func2 -> stackNeeded = func -> stackNeeded ; func2 -> sysFuncIntf = asNEW ( asSSystemFunctionInterface ) ( * func -> sysFuncIntf ) ; SetScriptFunction ( func2 ) ; * newFunc = func2 ; } return needNewFunc ; }
void asCScriptEngine :: CallObjectMethod ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , s -> sysFuncIntf , s ) ; }
void asCScriptEngine :: CallObjectMethod ( void * obj , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asPWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = asPWORD ( i -> baseOffset ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( ) = p . mthd ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * ) = ( void ( * ) ( void * ) ) ( i -> func ) ; f ( obj ) ; } }
bool asCScriptEngine :: CallObjectMethodRet@@ Bool ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; bool ( asCSimpleDummy :: * f ) ( ) = ( bool ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } else { bool ( * f ) ( void * ) = ( bool ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } }
int asCScriptEngine :: CallObjectMethodRet@@ Int ( void * obj , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; asSSystemFunctionInterface * i = s -> sysFuncIntf ; if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else if ( i -> callConv == ICC_VIRTUAL_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; struct { asFUNCTION_t func ; asDWORD baseOffset ; } f ; } p ; p . f . func = ( void ( * ) ( ) ) ( i -> func ) ; p . f . baseOffset = i -> baseOffset ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) ( p . mthd ) ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; int ( asCSimpleDummy :: * f ) ( ) = ( int ( asCSimpleDummy :: * ) ( ) ) p . mthd ; return ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( int * ) gen . GetReturnPointer ( ) ; } else { int ( * f ) ( void * ) = ( int ( * ) ( void * ) ) ( i -> func ) ; return f ( obj ) ; } }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s ) ; }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( int func , void * param1 ) { asCScriptFunction * s = scriptFunctions [ func ] ; return CallGlobalFunctionRetPtr ( s -> sysFuncIntf , s , param1 ) ; }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( ) = ( void * ( * ) ( ) ) ( i -> func ) ; return f ( ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( ) = ( void * ( STDCALL * ) ( ) ) ( i -> func ) ; return f ( ) ; } else { asCGeneric gen ( this , s , 0 , 0 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } }
void * asCScriptEngine :: CallGlobalFunctionRetPtr ( asSSystemFunctionInterface * i , asCScriptFunction * s , void * param1 ) { if ( i -> callConv == ICC_CDECL ) { void * ( * f ) ( void * ) = ( void * ( * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void * ( STDCALL * f ) ( void * ) = ( void * ( STDCALL * ) ( void * ) ) ( i -> func ) ; return f ( param1 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( void * * ) gen . GetReturnPointer ( ) ; } }
void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , int func ) { asCScriptFunction * s = scriptFunctions [ func ] ; CallObjectMethod ( obj , param , s -> sysFuncIntf , s ) ; }
void asCScriptEngine :: CallObjectMethod ( void * obj , void * param , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } if ( i -> callConv == ICC_THISCALL ) { union { asSIMPLEMETHOD_t mthd ; asFUNCTION_t func ; } p ; p . func = ( void ( * ) ( ) ) ( i -> func ) ; void ( asCSimpleDummy :: * f ) ( void * ) = ( void ( asCSimpleDummy :: * ) ( void * ) ) ( p . mthd ) ; ( ( ( asCSimpleDummy * ) obj ) ->* f ) ( param ) ; } else if ( i -> callConv == ICC_CDECL_OBJLAST ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param , obj ) ; } else if ( i -> callConv == ICC_GENERIC_METHOD ) { asCGeneric gen ( this , s , obj , ( asDWORD * ) & param ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } else { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( obj , param ) ; } }
void asCScriptEngine :: CallGlobalFunction ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { void ( * f ) ( void * , void * ) = ( void ( * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { void ( STDCALL * f ) ( void * , void * ) = ( void ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; } }
bool asCScriptEngine :: CallGlobalFunctionRetBool ( void * param1 , void * param2 , asSSystemFunctionInterface * i , asCScriptFunction * s ) { if ( i -> callConv == ICC_CDECL ) { bool ( * f ) ( void * , void * ) = ( bool ( * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else if ( i -> callConv == ICC_STDCALL ) { bool ( STDCALL * f ) ( void * , void * ) = ( bool ( STDCALL * ) ( void * , void * ) ) ( i -> func ) ; return f ( param1 , param2 ) ; } else { asCGeneric gen ( this , s , 0 , ( asDWORD * ) & param1 ) ; void ( * f ) ( asIScriptGeneric * ) = ( void ( * ) ( asIScriptGeneric * ) ) ( i -> func ) ; f ( & gen ) ; return * ( bool * ) gen . GetReturnPointer ( ) ; } }
void * asCScriptEngine :: CallAlloc ( asCObjectType * type ) { return ( ( asALLO@@ CFUNC@@ DEBUG_t ) ( userAlloc ) ) ( type -> size < 4 ? 4 : type -> size , __FILE__ , __LINE__ ) ; return userAlloc ( type -> size < 4 ? 4 : type -> size ) ; }
void asCScriptEngine :: CallFree ( void * obj ) { userFree ( obj ) ; }
void asCScriptEngine :: NotifyGarbageCollect@@ orOf@@ NewObject ( void * obj , int typeId ) { asCObjectType * objType = GetObjectTypeFromTypeId ( typeId ) ; gc . AddScriptObject@@ ToGC ( obj , objType ) ; }
int asCScriptEngine :: GarbageCollect ( asDWORD flags ) { return gc . GarbageCollect ( flags ) ; }
void asCScriptEngine :: GetGC@@ Statistics ( asUINT * currentSize , asUINT * totalDestroyed , asUINT * totalDetected ) { gc . GetStatistics ( currentSize , totalDestroyed , totalDetected ) ; }
void asCScriptEngine :: GCEnumCallback ( void * reference ) { gc . GCEnumCallback ( reference ) ; }
int asCScriptEngine :: GetTypeIdFromDataType ( const asCDataType & dt ) { if ( dt . IsNullHandle ( ) ) return 0 ; asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { if ( mapTypeIdToDataType . GetValue ( cursor ) -> IsEqualExceptRefAndConst ( dt ) ) return mapTypeIdToDataType . GetKey ( cursor ) ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; } int typeId = typeIdSeqNbr ++ ; if ( dt . GetObjectType ( ) ) { if ( dt . GetObjectType ( ) -> flags & asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIP@@ TOBJECT ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIP@@ TARRAY ; else if ( dt . GetObjectType ( ) -> flags & asOBJ_ENUM ) ; else typeId |= asTYPEID_APP@@ OBJECT ; } asCDataType * newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( false ) ; mapTypeIdToDataType . Insert ( typeId , newDt ) ; if ( dt . IsObject ( ) && dt . GetObjectType ( ) -> beh . release ) { newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( false ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE , newDt ) ; newDt = asNEW ( asCDataType ) ( dt ) ; newDt -> MakeReference ( false ) ; newDt -> MakeReadOnly ( false ) ; newDt -> MakeHandle ( true ) ; newDt -> MakeHandleToConst ( true ) ; mapTypeIdToDataType . Insert ( typeId | asTYPEID_OBJHANDLE | asTYPEID_HAND@@ LETO@@ CONST , newDt ) ; } return GetTypeIdFromDataType ( dt ) ; }
const asCDataType * asCScriptEngine :: GetDataTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) ; return 0 ; }
asCObjectType * asCScriptEngine :: GetObjectTypeFromTypeId ( int typeId ) { asSMapNode < int , asCDataType * > * cursor = 0 ; if ( mapTypeIdToDataType . MoveTo ( & cursor , typeId ) ) return mapTypeIdToDataType . GetValue ( cursor ) -> GetObjectType ( ) ; return 0 ; }
void asCScriptEngine :: RemoveFromTypeIdMap ( asCObjectType * type ) { asSMapNode < int , asCDataType * > * cursor = 0 ; mapTypeIdToDataType . MoveFirst ( & cursor ) ; while ( cursor ) { asCDataType * dt = mapTypeIdToDataType . GetValue ( cursor ) ; asSMapNode < int , asCDataType * > * old = cursor ; mapTypeIdToDataType . MoveNext ( & cursor , cursor ) ; if ( dt -> GetObjectType ( ) == type ) { asDELETE ( dt , asCDataType ) ; mapTypeIdToDataType . Erase ( old ) ; } } }
int asCScriptEngine :: GetTypeIdByDecl ( const char * decl ) { asCDataType dt ; asCBuilder bld ( this , 0 ) ; int r = bld . ParseDataType ( decl , & dt ) ; if ( r < 0 ) return asINVALID_TYPE ; return GetTypeIdFromDataType ( dt ) ; }
const char * asCScriptEngine :: GetType@@ Declaration ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; asASSERT ( threadManager ) ; asCString * tempString = & threadManager -> GetLocal@@ Data ( ) -> string ; * tempString = dt -> Format ( ) ; return tempString -> AddressOf ( ) ; }
int asCScriptEngine :: GetSize@@ OfPrimit@@ iveType ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( dt == 0 ) return 0 ; if ( ! dt -> IsPrimitive ( ) ) return 0 ; return dt -> GetSizeInMemoryBytes ( ) ; }
void * asCScriptEngine :: CreateScriptObject ( int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return 0 ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return 0 ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; asCObjectType * objType = dt -> GetObjectType ( ) ; void * ptr = 0 ; if ( objType -> flags & asOBJ_SCRIPT_OBJECT ) ptr = ScriptObject@@ Factory ( objType , this ) ; else if ( objType -> flags & asOBJ_TEMPLATE ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . construct , objType ) ; else if ( objType -> flags & asOBJ_REF ) ptr = CallGlobalFunctionRetPtr ( objType -> beh . factory ) ; else { ptr = CallAlloc ( objType ) ; int funcIndex = objType -> beh . construct ; if ( funcIndex ) CallObjectMethod ( ptr , funcIndex ) ; } return ptr ; }
void * asCScriptEngine :: CreateScriptObject@@ Copy ( void * origObj , int typeId ) { void * newObj = CreateScriptObject ( typeId ) ; if ( newObj == 0 ) return 0 ; CopyScriptObject ( newObj , origObj , typeId ) ; return newObj ; }
void asCScriptEngine :: CopyScriptObject ( void * dstObj , void * srcObj , int typeId ) { if ( ( typeId & ( asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR ) ) != typeId ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . copy ) { CallObjectMethod ( dstObj , srcObj , objType -> beh . copy ) ; } else if ( objType -> size ) { memcpy ( dstObj , srcObj , objType -> size ) ; } }
void asCScriptEngine :: AddRef@@ ScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . addref ) { CallObjectMethod ( obj , objType -> beh . addref ) ; } }
void asCScriptEngine :: ReleaseScriptObject ( void * obj , int typeId ) { if ( obj == 0 ) return ; if ( ( typeId & asTYPEID_MASK_OBJECT ) == 0 ) return ; const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return ; asCObjectType * objType = dt -> GetObjectType ( ) ; if ( objType -> beh . release ) { CallObjectMethod ( obj , objType -> beh . release ) ; } else { if ( objType -> beh . destruct ) CallObjectMethod ( obj , objType -> beh . destruct ) ; CallFree ( obj ) ; } }
bool asCScriptEngine :: IsHandle@@ Compatible@@ WithObject ( void * obj , int objTypeId , int handleTypeId ) { if ( objTypeId == handleTypeId ) return true ; const asCDataType * objDt = GetDataTypeFromTypeId ( objTypeId ) ; const asCDataType * hdlDt = GetDataTypeFromTypeId ( handleTypeId ) ; if ( objDt -> IsHandleToConst ( ) && ! hdlDt -> IsHandleToConst ( ) ) return false ; if ( objDt -> GetObjectType ( ) == hdlDt -> GetObjectType ( ) ) { return true ; } else if ( objDt -> IsScriptObject ( ) && obj ) { asCObjectType * objType = ( ( asCScriptObject * ) obj ) -> objType ; if ( objType -> Imple@@ ments ( hdlDt -> GetObjectType ( ) ) ) return true ; } return false ; }
int asCScriptEngine :: BeginConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) return asNAME_TAKEN ; } if ( currentGroup != & defaultGroup ) return asNOT_SUPPORTED ; asCConfigGroup * group = asNEW ( asCConfigGroup ) ( ) ; group -> groupName = groupName ; configGroups . PushLast ( group ) ; currentGroup = group ; return 0 ; }
int asCScriptEngine :: EndConfigGroup ( ) { if ( currentGroup == & defaultGroup ) return asNOT_SUPPORTED ; currentGroup = & defaultGroup ; return 0 ; }
int asCScriptEngine :: RemoveConfigGroup ( const char * groupName ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { asCConfigGroup * group = configGroups [ n ] ; if ( group -> refCount > 0 ) return asCONFIG_GROUP_IS_IN_USE ; if ( group -> HasLive@@ Objects ( ) ) return asCONFIG_GROUP_IS_IN_USE ; if ( n == configGroups . GetLength ( ) - 1 ) configGroups . PopLast ( ) ; else configGroups [ n ] = configGroups . PopLast ( ) ; group -> RemoveConfiguration ( this ) ; asDELETE ( group , asCConfigGroup ) ; } } return 0 ; }
asCConfigGroup * asCScriptEngine :: FindConfigGroupForFunction ( int funcId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { asUINT m ; for ( m = 0 ; m < configGroups [ n ] -> scriptFunctions . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> scriptFunctions [ m ] -> id == funcId ) return configGroups [ n ] ; } } return 0 ; }
asCConfigGroup * asCScriptEngine :: FindConfigGroupForGlobalVar ( int gvarId ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> globalProps . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> globalProps [ m ] -> id == gvarId ) return configGroups [ n ] ; } } return 0 ; }
asCConfigGroup * asCScriptEngine :: FindConfigGroupForObjectType ( const asCObjectType * objType ) { for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { for ( asUINT m = 0 ; m < configGroups [ n ] -> objTypes . GetLength ( ) ; m ++ ) { if ( configGroups [ n ] -> objTypes [ m ] == objType ) return configGroups [ n ] ; } } return 0 ; }
int asCScriptEngine :: SetConfigGroup@@ ModuleAccess ( const char * groupName , const char * module , bool hasAccess ) { asCConfigGroup * group = 0 ; for ( asUINT n = 0 ; n < configGroups . GetLength ( ) ; n ++ ) { if ( configGroups [ n ] -> groupName == groupName ) { group = configGroups [ n ] ; break ; } } if ( group == 0 ) return asWRONG_CONFIG_GROUP ; return group -> SetModuleAccess ( module , hasAccess ) ; }
int asCScriptEngine :: GetNextScriptFunctionId ( ) { if ( freeScriptFunctionIds . GetLength ( ) ) return freeScriptFunctionIds . PopLast ( ) ; int id = ( int ) scriptFunctions . GetLength ( ) ; scriptFunctions . PushLast ( 0 ) ; return id ; }
void asCScriptEngine :: SetScriptFunction ( asCScriptFunction * func ) { scriptFunctions [ func -> id ] = func ; }
void asCScriptEngine :: FreeScriptFunctionId ( int id ) { if ( id < 0 ) return ; id &= 0xFFFF ; if ( id >= ( int ) scriptFunctions . GetLength ( ) ) return ; if ( scriptFunctions [ id ] ) { asCScriptFunction * func = scriptFunctions [ id ] ; if ( id == ( int ) scriptFunctions . GetLength ( ) - 1 ) { scriptFunctions . PopLast ( ) ; } else { scriptFunctions [ id ] = 0 ; freeScriptFunctionIds . PushLast ( id ) ; } if ( func -> signatureId == id ) { signatureIds . RemoveValue ( func ) ; int newSigId = 0 ; for ( asUINT n = 0 ; n < scriptFunctions . GetLength ( ) ; n ++ ) { if ( scriptFunctions [ n ] && scriptFunctions [ n ] -> signatureId == id ) { if ( newSigId == 0 ) { newSigId = scriptFunctions [ n ] -> id ; signatureIds . PushLast ( scriptFunctions [ n ] ) ; } scriptFunctions [ n ] -> signatureId = newSigId ; } } } } }
int asCScriptEngine :: RegisterTypedef ( const char * type , const char * decl ) { if ( type == 0 ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == type ) return asALREADY_REGISTERED ; } asCTokenizer t ; size_t tokenLen ; eTokenType token ; asCDataType dataType ; token = t . GetToken ( decl , strlen ( decl ) , & tokenLen ) ; switch ( token ) { case ttBool : case ttInt : case ttInt8 : case ttInt16 : case ttInt64 : case ttUInt : case ttUInt8 : case ttUInt16 : case ttUInt64 : case ttFloat : case ttDouble : if ( strlen ( decl ) != tokenLen ) { return ConfigError ( asINVALID_TYPE ) ; } break ; default : return ConfigError ( asINVALID_TYPE ) ; } dataType = asCDataType :: CreatePrimitive ( token , false ) ; token = t . GetToken ( type , strlen ( type ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( type ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; asCBuilder bld ( this , 0 ) ; int r = bld . CheckNameConflict ( type , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * object = asNEW ( asCObjectType ) ( this ) ; object -> flags = asOBJ_TYPE@@ DEF ; object -> size = dataType . GetSizeInMemoryBytes ( ) ; object -> name = type ; object -> templateSubType = dataType ; objectTypes . PushLast ( object ) ; registeredTypeDefs . PushLast ( object ) ; currentGroup -> objTypes . PushLast ( object ) ; return asSUCCESS ; }
int asCScriptEngine :: GetTypedef@@ Count ( ) { return ( int ) registeredTypeDefs . GetLength ( ) ; }
const char * asCScriptEngine :: GetTypedef@@ ByIndex ( asUINT index , int * typeId , const char * * configGroup ) { if ( index >= registeredTypeDefs . GetLength ( ) ) return 0 ; if ( typeId ) * typeId = GetTypeIdByDecl ( registeredTypeDefs [ index ] -> name . AddressOf ( ) ) ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredTypeDefs [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } return registeredTypeDefs [ index ] -> name . AddressOf ( ) ; }
int asCScriptEngine :: RegisterEnum ( const char * name ) { if ( NULL == name ) return ConfigError ( asINVALID_NAME ) ; asUINT n ; for ( n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) return asALREADY_REGISTERED ; asCDataType dt ; asCBuilder bld ( this , 0 ) ; bool oldMsgCallback = msgCallback ; msgCallback = false ; int r = bld . ParseDataType ( name , & dt ) ; msgCallback = oldMsgCallback ; if ( r >= 0 ) return ConfigError ( asERROR ) ; asCTokenizer t ; size_t tokenLen ; int token = t . GetToken ( name , strlen ( name ) , & tokenLen ) ; if ( token != ttIdentifier || strlen ( name ) != tokenLen ) return ConfigError ( asINVALID_NAME ) ; r = bld . CheckNameConflict ( name , 0 , 0 ) ; if ( r < 0 ) return ConfigError ( asNAME_TAKEN ) ; asCObjectType * st = asNEW ( asCObjectType ) ( this ) ; asCDataType dataType ; dataType . CreatePrimitive ( ttInt , false ) ; st -> flags = asOBJ_ENUM ; st -> size = dataType . GetSizeInMemoryBytes ( ) ; st -> name = name ; objectTypes . PushLast ( st ) ; registeredEnums . PushLast ( st ) ; currentGroup -> objTypes . PushLast ( st ) ; return asSUCCESS ; }
int asCScriptEngine :: RegisterEnumValue ( const char * typeName , const char * valueName , int value ) { if ( currentGroup -> FindType ( typeName ) == 0 ) return asWRONG_CONFIG_GROUP ; asCDataType dt ; int r ; asCBuilder bld ( this , 0 ) ; r = bld . ParseDataType ( typeName , & dt ) ; if ( r < 0 ) return ConfigError ( r ) ; asCObjectType * ot = dt . GetObjectType ( ) ; if ( ot == 0 || ! ( ot -> flags & asOBJ_ENUM ) ) return ConfigError ( asINVALID_TYPE ) ; if ( NULL == valueName ) return ConfigError ( asINVALID_NAME ) ; for ( unsigned int n = 0 ; n < ot -> enumValues . GetLength ( ) ; n ++ ) { if ( ot -> enumValues [ n ] -> name == valueName ) return ConfigError ( asALREADY_REGISTERED ) ; } asSEnumValue * e = asNEW ( asSEnumValue ) ; e -> name = valueName ; e -> value = value ; ot -> enumValues . PushLast ( e ) ; return asSUCCESS ; }
int asCScriptEngine :: GetEnum@@ Count ( ) { return ( int ) registeredEnums . GetLength ( ) ; }
const char * asCScriptEngine :: GetEnum@@ ByIndex ( asUINT index , int * enumTypeId , const char * * configGroup ) { if ( index >= registeredEnums . GetLength ( ) ) return 0 ; if ( configGroup ) { asCConfigGroup * group = FindConfigGroupForObjectType ( registeredEnums [ index ] ) ; if ( group ) * configGroup = group -> groupName . AddressOf ( ) ; else * configGroup = 0 ; } if ( enumTypeId ) * enumTypeId = GetTypeIdByDecl ( registeredEnums [ index ] -> name . AddressOf ( ) ) ; return registeredEnums [ index ] -> name . AddressOf ( ) ; }
int asCScriptEngine :: GetEnumValue@@ Count ( int enumTypeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return asINVALID_TYPE ; return ( int ) t -> enumValues . GetLength ( ) ; }
const char * asCScriptEngine :: GetEnumValue@@ ByIndex ( int enumTypeId , asUINT index , int * outValue ) { const asCDataType * dt = GetDataTypeFromTypeId ( enumTypeId ) ; asCObjectType * t = dt -> GetObjectType ( ) ; if ( t == 0 || ! ( t -> GetFlags ( ) & asOBJ_ENUM ) ) return 0 ; if ( index >= t -> enumValues . GetLength ( ) ) return 0 ; if ( outValue ) * outValue = t -> enumValues [ index ] -> value ; return t -> enumValues [ index ] -> name . AddressOf ( ) ; }
int asCScriptEngine :: GetObject@@ TypeCount ( ) { return ( int ) registeredObjTypes . GetLength ( ) ; }
asIObjectType * asCScriptEngine :: GetObjectType@@ ByIndex ( asUINT index ) { if ( index >= registeredObjTypes . GetLength ( ) ) return 0 ; return registeredObjTypes [ index ] ; }
asIObjectType * asCScriptEngine :: GetObjectType@@ ById ( int typeId ) { const asCDataType * dt = GetDataTypeFromTypeId ( typeId ) ; if ( ! dt ) return 0 ; if ( dt -> GetObjectType ( ) && dt -> GetObjectType ( ) -> GetFlags ( ) & asOBJ_ENUM ) return 0 ; return dt -> GetObjectType ( ) ; }
asIScriptFunction * asCScriptEngine :: GetFunction@@ DescriptorById ( int funcId ) { return GetScriptFunction ( funcId ) ; }
bool asCScriptEngine :: IsTemplate@@ Type ( const char * name ) { for ( unsigned int n = 0 ; n < objectTypes . GetLength ( ) ; n ++ ) { if ( objectTypes [ n ] && objectTypes [ n ] -> name == name ) { return objectTypes [ n ] -> flags & asOBJ_TEMPLATE ? true : false ; } } return false ; }
int asCScriptEngine :: AddConstantString ( const char * str , size_t len ) { for ( size_t n = 0 ; n < stringConstants . GetLength ( ) ; n ++ ) { if ( stringConstants [ n ] -> Compare ( str , len ) == 0 ) { return ( int ) n ; } } asCString * cstr = asNEW ( asCString ) ( str , len ) ; stringConstants . PushLast ( cstr ) ; asASSERT ( stringConstants . GetLength ( ) <= 65536 ) ; return ( int ) stringConstants . GetLength ( ) - 1 ; }
const asCString & asCScriptEngine :: GetConstantString ( int id ) { return * stringConstants [ id ] ; }
int asCScriptEngine :: GetScriptSectionNameIndex ( const char * name ) { for ( asUINT n = 0 ; n < scriptSectionNames . GetLength ( ) ; n ++ ) { if ( scriptSectionNames [ n ] -> Compare ( name ) == 0 ) return n ; } scriptSectionNames . PushLast ( asNEW ( asCString ) ( name ) ) ; return int ( scriptSectionNames . GetLength ( ) - 1 ) ; }
