infosHasher :: infosHasher ( long cle , string cleTxt , vector < int > valueVecInt ) { m_hashKey = cle ; m_key = cleTxt ; m_value = valueVecInt ; }
long infosHasher :: getHash@@ Key ( ) { return m_hashKey ; }
string infosHasher :: getKey ( ) { return m_key ; }
vector < int > infosHasher :: getValue ( ) { return m_value ; }
void infosHasher :: setValue ( vector < int > value ) { m_value = value ; }
string infosHasher :: toString ( ) { stringstream to_return ; to_return << m_hashKey << " \t " << m_key << " \t " << vector@@ ToString ( m_value , " \t " ) << endl ; return to_return . str ( ) ; }
Id Id :: Node ( uint64_t id ) { return Id ( id | NODE ) ; }
Id Id :: Way ( uint64_t id ) { return Id ( id | WAY ) ; }
Id Id :: Relation ( uint64_t id ) { return Id ( id | RELATION ) ; }
std :: string DebugPrint ( osm :: Id const & id ) { std :: ostringstream stream ; stream << id . Type ( ) << " ▁ " << id . OsmId ( ) ; return stream . str ( ) ; }
PassRefPtrWillBeRawPtr < HTMLContentElement > HTMLContentElement :: create ( Document & document , PassOwnPtrWillBeRawPtr < HTMLContentSelectFilter > filter ) { return adoptRefWillBe@@ Noop ( new HTMLContentElement ( document , filter ) ) ; }
void HTMLContentElement :: parseSelect ( ) { ASSERT ( m_shouldParseSelect ) ; CSSParser :: parseSelector ( CSSParser@@ Context ( document ( ) , 0 ) , m_select , m_selectorList ) ; m_shouldParseSelect = false ; m_isValidSelector = validateSelect ( ) ; if ( ! m_isValidSelector ) { CSSSelectorList emptyList ; m_selectorList . adopt ( emptyList ) ; } }
void HTMLContentElement :: parseAttribute ( const QualifiedName & name , const AtomicString & value ) { if ( name == selectAttr ) { if ( ShadowRoot * root = containingShadowRoot ( ) ) root -> owner ( ) -> willAffectSelector ( ) ; m_shouldParseSelect = true ; m_select = value ; } else { InsertionPoint :: parseAttribute ( name , value ) ; } }
selector = CSSSelectorList :: next ( * selector ) ) { context . selector = selector ; if ( selectorChecker . match ( context ) ) return true ; }
HRESULT Variables :: Init ( ) { HRESULT hr = S_OK ; EX_TRY { http@@ URLPrefix . SetLiteral ( W ( " http : // " ) ) ; architecture@@ MSIL . SetLiteral ( W ( " MSIL " ) ) ; architecture@@ X86 . SetLiteral ( W ( " x86" ) ) ; architecture@@ AMD@@ 64 . SetLiteral ( W ( " AMD@@ 64" ) ) ; architecture@@ ARM . SetLiteral ( W ( " ARM " ) ) ; architecture@@ ARM64 . SetLiteral ( W ( " ARM@@ 64" ) ) ; cult@@ ureNe@@ utral . SetLiteral ( W ( " neutral " ) ) ; mscorlib . SetLiteral ( W ( " mscorlib " ) ) ; emptyString . Clear ( ) ; REGUTIL :: CORConfigLevel kCorConfigLevel = static_cast < REGUTIL :: CORConfigLevel > ( REGUTIL :: COR_@@ CONFIG_ENV | REGUTIL :: COR_@@ CONFIG_FU@@ SION ) ; DWORD dwLoggingNeeded = REGUTIL :: GetConfig@@ DWORD_@@ DontUse_ ( CLRConfig :: EXTERNAL_Force@@ Log , 0 , kCorConfigLevel , TRUE ) ; fLoggingNeeded = ( dwLoggingNeeded ? TRUE : FALSE ) ; NewArray@@ Holder < WCHAR > pwzLogDirectory = REGUTIL :: GetConfig@@ String_@@ DontUse_ ( CLRConfig :: INTERNAL_@@ LogPath , TRUE , kCorConfigLevel , FALSE ) ; if ( pwzLogDirectory == NULL ) { fLoggingNeeded = FALSE ; } else { DWORD dwAttr = 0 ; hr = CheckFileExistence ( pwzLogDirectory , & dwAttr ) ; if ( ( hr == S_OK ) && ( ( dwAttr & FILE_ATTRIBUTE_@@ DIRECTORY ) != 0 ) ) { logPath . Set ( pwzLogDirectory ) ; } else { hr = S_OK ; fLoggingNeeded = FALSE ; } } } EX_CAT@@ CH_HRESULT ( hr ) ; return hr ; }
HASHwithTransform :: HASHwithTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; }
void HASHwithTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; }
void HASHwithTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( local , local , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } }
void HASHwithTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( local , local , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( local , local , blockSz , order ) ; memcpy ( & local [ padSz ] , order ? & preHiLen : & preLoLen , sizeof ( preLoLen ) ) ; memcpy ( & local [ padSz + 4 ] , order ? & preLoLen : & preHiLen , sizeof ( preLoLen ) ) ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; }
HASH64withTransform :: HASH64withTransform ( word32 digSz , word32 buffSz ) { assert ( digSz <= MaxDigestSz ) ; assert ( buffSz <= MaxBufferSz ) ; }
void HASH64withTransform :: AddLength ( word32 len ) { HashLengthType tmp = loLen_ ; if ( ( loLen_ += len ) < tmp ) hiLen_ ++ ; hiLen_ += SafeRightShift < 8 * sizeof ( HashLengthType ) > ( len ) ; }
void HASH64withTransform :: Update ( const byte * data , word32 len ) { word32 blockSz = getBlockSize ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; while ( len ) { word32 add = min ( len , blockSz - buffLen_ ) ; memcpy ( & local [ buffLen_ ] , data , add ) ; buffLen_ += add ; data += add ; len -= add ; if ( buffLen_ == blockSz ) { ByteReverseIf ( buffer_ , buffer_ , blockSz , getByteOrder ( ) ) ; Transform ( ) ; AddLength ( blockSz ) ; buffLen_ = 0 ; } } }
void HASH64withTransform :: Final ( byte * hash ) { word32 blockSz = getBlockSize ( ) ; word32 digestSz = getDigestSize ( ) ; word32 padSz = getPadSize ( ) ; ByteOrder order = getByteOrder ( ) ; AddLength ( buffLen_ ) ; HashLengthType preLoLen = GetBitCountLo ( ) ; HashLengthType preHiLen = GetBitCountHi ( ) ; byte * local = reinterpret_cast < byte * > ( buffer_ ) ; local [ buffLen_ ++ ] = 0x80 ; if ( buffLen_ > padSz ) { memset ( & local [ buffLen_ ] , 0 , blockSz - buffLen_ ) ; buffLen_ += blockSz - buffLen_ ; ByteReverseIf ( buffer_ , buffer_ , blockSz , order ) ; Transform ( ) ; buffLen_ = 0 ; } memset ( & local [ buffLen_ ] , 0 , padSz - buffLen_ ) ; ByteReverseIf ( buffer_ , buffer_ , padSz , order ) ; buffer_ [ blockSz / sizeof ( word64 ) - 2 ] = order ? preHiLen : preLoLen ; buffer_ [ blockSz / sizeof ( word64 ) - 1 ] = order ? preLoLen : preHiLen ; Transform ( ) ; ByteReverseIf ( digest_ , digest_ , digestSz , order ) ; memcpy ( hash , digest_ , digestSz ) ; Init ( ) ; }
instance_shadowfang_keep :: instance_shadowfang_keep ( Map * pMap ) : ScriptedInstance ( pMap ) { Initialize ( ) ; }
void instance_shadowfang_keep :: Initialize ( ) { memset ( & m_auiEncounter , 0 , sizeof ( m_auiEncounter ) ) ; }
void instance_shadowfang_keep :: OnCreature@@ Create ( Creature * pCreature ) { switch ( pCreature -> GetEntry ( ) ) { case NPC_ASH : case NPC_ADA : case NPC_FENRUS : break ; case NPC_VIN@@ CENT : if ( m_auiEncounter [ 4 ] == DONE ) pCreature -> SetStandState ( UNIT_STAND_STATE_@@ DEAD ) ; break ; default : return ; } m_m@@ NpcEntryGuidStore [ pCreature -> GetEntry ( ) ] = pCreature -> GetObjectGuid ( ) ; }
void instance_shadowfang_keep :: OnObjectCreate ( GameObject * pGo ) { switch ( pGo -> GetEntry ( ) ) { case GO_COURTYARD_DOOR : if ( m_auiEncounter [ 0 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_SORCERER_DOOR : if ( m_auiEncounter [ 2 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUGAL_DOOR : if ( m_auiEncounter [ 3 ] == DONE ) pGo -> SetGoState ( GO_STATE_ACTIVE ) ; break ; case GO_ARUG@@ AL_F@@ OCUS : break ; default : return ; } m_m@@ GoEntryGuidStore [ pGo -> GetEntry ( ) ] = pGo -> GetObjectGuid ( ) ; }
void instance_shadowfang_keep :: DoSpeech ( ) { Creature * pAda = GetSingleCreatureFromStorage ( NPC_ADA ) ; Creature * pAsh = GetSingleCreatureFromStorage ( NPC_ASH ) ; if ( pAda && pAda -> isAlive ( ) && pAsh && pAsh -> isAlive ( ) ) { DoScriptText ( SAY_BOSS_DIE_@@ AD , pAda ) ; DoScriptText ( SAY_BOSS_DIE_@@ AS , pAsh ) ; } }
void instance_shadowfang_keep :: SetData ( uint32 uiType , uint32 uiData ) { switch ( uiType ) { case TYPE_FREE_NPC : if ( uiData == DONE ) DoUseDoorOrButton ( GO_COURTYARD_DOOR ) ; m_auiEncounter [ 0 ] = uiData ; break ; case TYPE_RETHILGORE : if ( uiData == DONE ) DoSpeech ( ) ; m_auiEncounter [ 1 ] = uiData ; break ; case TYPE_FENRUS : if ( uiData == DONE ) { if ( Creature * pFenrus = GetSingleCreatureFromStorage ( NPC_FENRUS ) ) pFenrus -> SummonCreature ( NPC_ARCH@@ MAGE_@@ ARUG@@ AL , - 136.@@ 89f , 2169@@ .17@@ f , 136.@@ 58f , 2.794f , TEMPSUMMON_TIMED_@@ DESPAWN , 30000 ) ; } m_auiEncounter [ 2 ] = uiData ; break ; case TYPE_NANDOS : if ( uiData == DONE ) DoUseDoorOrButton ( GO_ARUGAL_DOOR ) ; m_auiEncounter [ 3 ] = uiData ; break ; case TYPE_INTRO : m_auiEncounter [ 4 ] = uiData ; break ; case TYPE_VO@@ IDWAL@@ KER : if ( uiData == DONE ) { m_auiEncounter [ 5 ] ++ ; if ( m_auiEncounter [ 5 ] > 3 ) DoUseDoorOrButton ( GO_SORCERER_DOOR ) ; } break ; } if ( uiData == DONE ) { OUT_SAVE_INST_@@ DATA ; std :: ostringstream saveStream ; saveStream << m_auiEncounter [ 0 ] << " ▁ " << m_auiEncounter [ 1 ] << " ▁ " << m_auiEncounter [ 2 ] << " ▁ " << m_auiEncounter [ 3 ] << " ▁ " << m_auiEncounter [ 4 ] << " ▁ " << m_auiEncounter [ 5 ] ; m_strInst@@ Data = saveStream . str ( ) ; SaveToDB ( ) ; OUT_SAVE_INST_@@ DATA_COMPLETE ; } }
void instance_shadowfang_keep :: Load ( const char * chrIn ) { if ( ! chrIn ) { OUT_LOAD_INST_@@ DATA_FAIL ; return ; } OUT_LOAD_INST_@@ DATA ( chrIn ) ; std :: istringstream loadStream ( chrIn ) ; loadStream >> m_auiEncounter [ 0 ] >> m_auiEncounter [ 1 ] >> m_auiEncounter [ 2 ] >> m_auiEncounter [ 3 ] >> m_auiEncounter [ 4 ] >> m_auiEncounter [ 5 ] ; for ( uint8 i = 0 ; i < MAX_ENCOUN@@ TER ; ++ i ) { if ( m_auiEncounter [ i ] == IN_PROGRESS ) m_auiEncounter [ i ] = NOT_STARTED ; } OUT_LOAD_INST_@@ DATA_COMPLETE ; }
bool QEventDispatcherX11 :: processEvents ( QEventLoop :: ProcessEvents@@ Flags flags ) { Q_D ( QEventDispatcherX11 ) ; d -> interrupt = false ; QApplication :: sendPostedEvents ( ) ; ulong marker = XNext@@ Request ( X11 -> display ) ; int nevents = 0 ; do { while ( ! d -> interrupt ) { XEvent event ; if ( ! ( flags & QEventLoop :: ExcludeUserInputEvents ) && ! d -> queuedUserInputEvents . isEmpty ( ) ) { event = d -> queuedUserInputEvents . take@@ First ( ) ; } else if ( XEventsQueued ( X11 -> display , Queued@@ Already ) ) { XNext@@ Event ( X11 -> display , & event ) ; if ( flags & QEventLoop :: ExcludeUserInputEvents ) { switch ( event . type ) { case ButtonPress : case ButtonRelease : case MotionNotify : case XKeyPress : case XKeyRelease : case EnterNotify : case Leave@@ Notify : d -> queuedUserInputEvents . append ( event ) ; continue ; case ClientMessage : if ( event . xclient . format == 32 ) { if ( event . xclient . message_type == ATOM ( WM_PROTO@@ COLS ) && ( Atom ) event . xclient . data . l [ 0 ] == ATOM ( WM_TAKE_@@ FOCUS ) ) { break ; } else if ( event . xclient . message_type == ATOM ( _Q@@ T_SC@@ ROLL_@@ DONE ) ) { break ; } } d -> queuedUserInputEvents . append ( event ) ; continue ; default : break ; } } } else { break ; } if ( filterEvent ( & event ) ) continue ; nevents ++ ; if ( qApp -> x11@@ ProcessEvent ( & event ) == 1 ) return true ; if ( event . xany . serial >= marker ) { if ( XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) flags &= ~ QEventLoop :: WaitForMoreEvents ; goto out ; } } } while ( ! d -> interrupt && XEventsQueued ( X11 -> display , QueuedAfterFlush ) ) ; out : if ( ! d -> interrupt ) { const uint exclude_all = QEventLoop :: Exclude@@ Socket@@ Notifiers | QEventLoop :: X11@@ Exclude@@ Timers | QEventLoop :: WaitForMoreEvents ; if ( nevents > 0 && ( ( uint ) flags & exclude_all ) == exclude_all ) { QApplication :: sendPostedEvents ( ) ; return nevents > 0 ; } return QEventDispatcherUNIX :: processEvents ( flags ) || ( nevents > 0 ) ; } return nevents > 0 ; }
bool QEventDispatcherX11 :: hasPending@@ Events ( ) { extern uint qGlobalPostedEventsCount ( ) ; return ( qGlobalPostedEventsCount ( ) || XPending ( X11 -> display ) ) ; }
void QEventDispatcherX11 :: flush ( ) { XFlush ( X11 -> display ) ; }
void QEventDispatcherX11 :: starting@@ Up ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = XConnection@@ Number ( X11 -> display ) ; }
void QEventDispatcherX11 :: closingDown ( ) { Q_D ( QEventDispatcherX11 ) ; d -> xfd = - 1 ; }
int QEventDispatcherX11 :: select ( int nfds , fd_set * readfds , fd_set * writefds , fd_set * exceptfds , timeval * timeout ) { Q_D ( QEventDispatcherX11 ) ; if ( d -> xfd > 0 ) { nfds = qMax ( nfds - 1 , d -> xfd ) + 1 ; FD_SET ( d -> xfd , readfds ) ; } return QEventDispatcherUNIX :: select ( nfds , readfds , writefds , exceptfds , timeout ) ; }
bool GlyphPage :: fill ( unsigned offset , unsigned length , UChar * buffer , unsigned bufferLength , const SimpleFontData * fontData ) { bool haveGlyphs = false ; if ( ! shouldUseCoreText ( buffer , bufferLength , fontData ) ) { Vector < CGGlyph , 512 > glyphs ( bufferLength ) ; wk@@ GetGlyph@@ sFor@@ Characters ( fontData -> platformData ( ) . cgFont ( ) , buffer , glyphs . data ( ) , bufferLength ) ; for ( unsigned i = 0 ; i < length ; ++ i ) { if ( ! glyphs [ i ] ) setGlyphDataForIndex ( offset + i , 0 , 0 ) ; else { setGlyphDataForIndex ( offset + i , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } else { RetainPtr < CFStringRef > string ( AdoptCF , CFStringCreateWith@@ CharactersNo@@ Copy ( kCFAllocatorDefault , buffer , bufferLength , kCFAllocator@@ Null ) ) ; RetainPtr < CFAttributedString@@ Ref > attributedString ( AdoptCF , CFAttributedString@@ Create ( kCFAllocatorDefault , string . get ( ) , fontData -> getCFString@@ Attributes ( 0 , fontData -> hasVerticalGlyphs ( ) ? Vertical : Horizontal ) ) ) ; RetainPtr < CTLine@@ Ref > line ( AdoptCF , CTLine@@ CreateWith@@ AttributedString ( attributedString . get ( ) ) ) ; CFArray@@ Ref runArray = CTLine@@ GetGlyph@@ Runs ( line . get ( ) ) ; CFIndex runCount = CFArray@@ GetCount ( runArray ) ; for ( unsigned index = 0 ; index < length ; ++ index ) setGlyphDataForIndex ( offset + index , 0 , 0 ) ; Vector < CGGlyph , 512 > glyphVector ; Vector < CFIndex , 512 > indexVector ; bool done = false ; RetainPtr < CGFontRef > cgFont ( AdoptCF , CTFontCopyGraphicsFont ( fontData -> platformData ( ) . ctFont ( ) , 0 ) ) ; for ( CFIndex r = 0 ; r < runCount && ! done ; ++ r ) { CTRunRef ctRun = static_cast < CTRunRef > ( CFArray@@ GetValueAtIndex ( runArray , r ) ) ; ASSERT ( CFGetTypeID ( ctRun ) == CTRunGetTypeID ( ) ) ; CFDictionary@@ Ref attributes = CTRunGet@@ Attributes ( ctRun ) ; CTFontRef runFont = static_cast < CTFontRef > ( CFDictionary@@ GetValue ( attributes , kCTFont@@ AttributeName ) ) ; RetainPtr < CGFontRef > runCGFont ( AdoptCF , CTFontCopyGraphicsFont ( runFont , 0 ) ) ; if ( CFE@@ qual ( cgFont . get ( ) , runCGFont . get ( ) ) ) { CFIndex glyphCount = CTRunGetGlyph@@ Count ( ctRun ) ; const CGGlyph * glyphs = CTRunGetGlyph@@ sPtr ( ctRun ) ; if ( ! glyphs ) { glyphVector . resize ( glyphCount ) ; CTRunGet@@ Glyphs ( ctRun , CFRangeMake ( 0 , 0 ) , glyphVector . data ( ) ) ; glyphs = glyphVector . data ( ) ; } const CFIndex * stringIndices = CTRunGetString@@ Indices@@ Ptr ( ctRun ) ; if ( ! stringIndices ) { indexVector . resize ( glyphCount ) ; CTRunGetString@@ Indices ( ctRun , CFRangeMake ( 0 , 0 ) , indexVector . data ( ) ) ; stringIndices = indexVector . data ( ) ; } for ( CFIndex i = 0 ; i < glyphCount ; ++ i ) { if ( stringIndices [ i ] >= static_cast < CFIndex > ( length ) ) { done = true ; break ; } if ( glyphs [ i ] ) { setGlyphDataForIndex ( offset + stringIndices [ i ] , glyphs [ i ] , fontData ) ; haveGlyphs = true ; } } } } } return haveGlyphs ; }
CView :: CView ( ) : m_PenColor ( RGB ( 0 , 0 , 0 ) ) { m_Brush . CreateSol@@ idBrush ( RGB ( 255 , 255 , 230 ) ) ; }
void CView :: ClearPoints ( ) { m_points . clear ( ) ; Invalidate ( ) ; }
void CView :: DrawLine ( int x , int y ) { CClient@@ DC dcClient ( this ) ; dcClient . CreatePen ( PS_SOLID , 1 , m_points . back ( ) . color ) ; dcClient . MoveTo ( m_points . back ( ) . x , m_points . back ( ) . y ) ; dcClient . LineTo ( x , y ) ; }
void CView :: OnDraw ( CDC * pDC ) { if ( m_points . size ( ) > 0 ) { bool bDraw = false ; for ( unsigned int i = 0 ; i < m_points . size ( ) ; i ++ ) { pDC -> CreatePen ( PS_SOLID , 1 , m_points [ i ] . color ) ; if ( bDraw ) pDC -> LineTo ( m_points [ i ] . x , m_points [ i ] . y ) ; else pDC -> MoveTo ( m_points [ i ] . x , m_points [ i ] . y ) ; bDraw = m_points [ i ] . PenDown ; } } }
void CView :: PreCreate ( CREATESTRUCT & cs ) { cs . dwExStyle = WS_EX_CLIENTEDGE ; }
void CView :: PreRegisterClass ( WNDCLASS & wc ) { wc . hbr@@ Background = m_Brush ; wc . lpszClassName = _T ( " Scri@@ bble ▁ Window " ) ; wc . hCursor = :: LoadCursor ( GetApp ( ) -> GetInstance@@ Handle ( ) , MAKE@@ INTR@@ ESOURCE ( IDC_@@ CURS@@ OR1 ) ) ; }
BOOL CView :: FileOpen ( LPCTSTR szFilename ) { m_points . clear ( ) ; DWORD nBytesRead ; BOOL bResult = FALSE ; CFile File ; if ( File . Open ( szFilename , OPEN_EXISTING ) ) { do { PlotPoint pp ; nBytesRead = File . Read ( & pp , sizeof ( PlotPoint ) ) ; if ( nBytesRead == sizeof ( PlotPoint ) ) m_points . push_back ( pp ) ; } while ( nBytesRead == sizeof ( PlotPoint ) ) ; if ( ( 0 != nBytesRead ) || ( m_points . empty ( ) ) ) { m_points . clear ( ) ; :: MessageBox ( 0 , _T ( " Invalid ▁ data ▁ in ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } else bResult = TRUE ; } else { tString tsErrMsg = _T ( " Failed ▁ to ▁ open ▁ file ▁ " ) ; tsErrMsg += szFilename ; :: MessageBox ( 0 , tsErrMsg . c_str ( ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; } Invalidate ( ) ; return bResult ; }
BOOL CView :: FileSave ( LPCTSTR szFilename ) { BOOL bResult = TRUE ; CFile hFile ; if ( ! hFile . Open ( szFilename , CREATE_ALWAY@@ S ) ) { :: MessageBox ( 0 , _T ( " Failed ▁ to ▁ open ▁ file ▁ for ▁ writing " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } if ( bResult ) { for ( size_t i = 0 ; i < m_points . size ( ) ; ++ i ) { if ( ! hFile . Write ( & m_points [ i ] , sizeof ( PlotPoint ) ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; break ; } } if ( hFile . GetLength ( ) != m_points . size ( ) * sizeof ( PlotPoint ) ) { :: MessageBox ( 0 , _T ( " Error ▁ while ▁ writing ▁ to ▁ file " ) , _T ( " Error " ) , MB_ICONEXCLAMATION | MB_OK ) ; bResult = FALSE ; } } return bResult ; }
void CView :: SetPen ( COLOR@@ REF color ) { m_PenColor = color ; }
void CView :: StorePoint ( int x , int y , bool PenDown ) { PlotPoint P1 ; P1 . x = x ; P1 . y = y ; P1 . PenDown = PenDown ; P1 . color = m_PenColor ; m_points . push_back ( P1 ) ; }
void CView :: OnLButtonDown ( LPARAM lParam ) { SetCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; }
void CView :: OnLButtonUp ( LPARAM lParam ) { { ReleaseCapture ( ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , false ) ; } }
void CView :: OnMouseMove ( WPARAM wParam , LPARAM lParam ) { if ( ( wParam & MK_@@ LBUTTON ) && ( GetCapture ( ) == this ) ) { DrawLine ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) ) ; StorePoint ( GET_X_LPARAM ( lParam ) , GET_Y_LPARAM ( lParam ) , true ) ; } }
LRESULT CView :: WndProc ( UINT uMsg , WPARAM wParam , LPARAM lParam ) { switch ( uMsg ) { case WM_LBUTTONDOWN : OnLButtonDown ( lParam ) ; break ; case WM_MOUSE@@ MOVE : OnMouseMove ( wParam , lParam ) ; break ; case WM_LBUTTON@@ UP : OnLButtonUp ( lParam ) ; break ; } return WndProc@@ Default ( uMsg , wParam , lParam ) ; }
XbelWriter :: XbelWriter ( BookmarkModel * model ) : QXmlStream@@ Writer ( ) , treeModel ( model ) { setAuto@@ Formatting ( true ) ; }
void XbelWriter :: writeTo@@ File ( QIODevice * device ) { setDevice ( device ) ; writeStart@@ Document ( ) ; writeDT@@ D ( QLatin1String ( " < ! DOCTYPE ▁ xbel > " ) ) ; writeStartElement ( QLatin1String ( " xbel " ) ) ; writeAttribute ( QLatin1String ( " version " ) , QLatin1String ( "1.0" ) ) ; QStandardItem * root = treeModel -> invis@@ ible@@ RootItem ( ) ; for ( int i = 0 ; i < root -> rowCount ( ) ; ++ i ) writeData ( root -> child ( i ) ) ; writeEnd@@ Document ( ) ; }
void XbelWriter :: writeData ( QStandardItem * child ) { Bookmark entry ; entry . title = child -> data ( Qt :: DisplayRole ) . toString ( ) ; entry . url = child -> data ( Qt :: UserRole + 10 ) . toString ( ) ; if ( entry . url == QLatin1String ( " Folder " ) ) { writeStartElement ( QLatin1String ( " folder " ) ) ; entry . folded = ! child -> data ( Qt :: UserRole + 11 ) . toBool ( ) ; writeAttribute ( QLatin1String ( " folded " ) , entry . folded ? QLatin1String ( " yes " ) : QLatin1String ( " no " ) ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; for ( int i = 0 ; i < child -> rowCount ( ) ; ++ i ) writeData ( child -> child ( i ) ) ; writeEndElement ( ) ; } else { writeStartElement ( QLatin1String ( " bookmark " ) ) ; writeAttribute ( QLatin1String ( " href " ) , entry . url ) ; writeTextElement ( QLatin1String ( " title " ) , entry . title ) ; writeEndElement ( ) ; } }
XbelReader :: XbelReader ( BookmarkModel * tree , BookmarkModel * list ) : QXmlStream@@ Reader ( ) , treeModel ( tree ) , listModel ( list ) { bookmarkIcon = QIcon ( QLatin1String ( " : / help / images / bookmark . png " ) ) ; folderIcon = QApplication :: style ( ) -> standardIcon ( QStyle :: SP_Dir@@ ClosedIcon ) ; }
bool XbelReader :: readFromFile ( QIODevice * device ) { setDevice ( device ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " xbel " ) && attributes ( ) . value ( QLatin1String ( " version " ) ) == QLatin1String ( "1.0" ) ) { readXBEL ( ) ; } else { raise@@ Error ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " The ▁ file ▁ is ▁ not ▁ an ▁ XBEL ▁ version ▁ 1.0 ▁ file . " ) ) ; } } } return ! error ( ) ; }
void XbelReader :: readXBEL ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( 0 ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( 0 ) ; else readUnknownElement ( ) ; } } }
void XbelReader :: readUnknownElement ( ) { while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) readUnknownElement ( ) ; } }
void XbelReader :: readFolder ( QStandardItem * item ) { QStandardItem * folder = createChildItem ( item ) ; folder -> setIcon ( folderIcon ) ; folder -> setData ( QLatin1String ( " Folder " ) , Qt :: UserRole + 10 ) ; bool expanded = ( attributes ( ) . value ( QLatin1String ( " folded " ) ) != QLatin1String ( " no " ) ) ; folder -> setData ( expanded , Qt :: UserRole + 11 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) folder -> setText ( readElementText ( ) ) ; else if ( name ( ) == QLatin1String ( " folder " ) ) readFolder ( folder ) ; else if ( name ( ) == QLatin1String ( " bookmark " ) ) readBookmark ( folder ) ; else readUnknownElement ( ) ; } } }
void XbelReader :: readBookmark ( QStandardItem * item ) { QStandardItem * bookmark = createChildItem ( item ) ; bookmark -> setIcon ( bookmarkIcon ) ; bookmark -> setText ( QCoreApplication :: translate ( " Help : : Internal : : XbelReader " , " Unknown ▁ title " ) ) ; bookmark -> setData ( attributes ( ) . value ( QLatin1String ( " href " ) ) . toString ( ) , Qt :: UserRole + 10 ) ; while ( ! atEnd ( ) ) { readNext ( ) ; if ( isEndElement ( ) ) break ; if ( isStartElement ( ) ) { if ( name ( ) == QLatin1String ( " title " ) ) bookmark -> setText ( readElementText ( ) ) ; else readUnknownElement ( ) ; } } listModel -> appendRow ( bookmark -> clone ( ) ) ; }
QStandardItem * XbelReader :: createChildItem ( QStandardItem * item ) { QStandardItem * childItem = new QStandardItem ( ) ; childItem -> setEditable ( false ) ; if ( item ) item -> appendRow ( childItem ) ; else treeModel -> appendRow ( childItem ) ; return childItem ; }
MachineSSAUpdater :: MachineSSAUpdater ( MachineFunction & MF , SmallVectorImpl < MachineInstr * > * NewPHI ) : AV ( nullptr ) , InsertedPHIs ( NewPHI ) { TII = MF . getSub@@ target ( ) . getIn@@ strInfo ( ) ; MRI = & MF . getReg@@ Info ( ) ; }
MachineSSAUpdater :: ~ MachineSSAUpdater ( ) { delete static_cast < AvailableValsTy * > ( AV ) ; }
void MachineSSAUpdater :: Initialize ( unsigned V ) { if ( ! AV ) AV = new AvailableValsTy ( ) ; else getAvailableVals ( AV ) . clear ( ) ; VR = V ; VRC = MRI -> getReg@@ Class ( VR ) ; }
void MachineSSAUpdater :: AddAvailable@@ Value ( MachineBasicBlock * BB , unsigned V ) { getAvailableVals ( AV ) [ BB ] = V ; }
unsigned MachineSSAUpdater :: GetValueAtEnd@@ OfBlock ( MachineBasicBlock * BB ) { return GetValueAtEndOfBlockInternal ( BB ) ; }
unsigned MachineSSAUpdater :: GetValueInMiddleOfBlock ( MachineBasicBlock * BB ) { if ( ! HasValueForBlock ( BB ) ) return GetValueAtEndOfBlockInternal ( BB ) ; if ( BB -> pred_empty ( ) ) { MachineInstr * NewDef = InsertNewDef ( TargetOpcode :: IMPLICIT_DEF , BB , BB -> getFirstTerminator ( ) , VRC , MRI , TII ) ; return NewDef -> getOperand ( 0 ) . getReg ( ) ; } SmallVector < std :: pair < MachineBasicBlock * , unsigned > , 8 > PredValues ; unsigned SingularValue = 0 ; bool isFirstPred = true ; for ( MachineBasicBlock :: pred_iterator PI = BB -> pred_begin ( ) , E = BB -> pred_end ( ) ; PI != E ; ++ PI ) { MachineBasicBlock * PredBB = * PI ; unsigned PredVal = GetValueAtEndOfBlockInternal ( PredBB ) ; PredValues . push_back ( std :: make_pair ( PredBB , PredVal ) ) ; if ( isFirstPred ) { SingularValue = PredVal ; isFirstPred = false ; } else if ( PredVal != SingularValue ) SingularValue = 0 ; } if ( SingularValue != 0 ) return SingularValue ; unsigned DupPHI = LookForIdenticalPHI ( BB , PredValues ) ; if ( DupPHI ) return DupPHI ; MachineBasicBlock :: iterator Loc = BB -> empty ( ) ? BB -> end ( ) : BB -> begin ( ) ; MachineInstrBuilder InsertedPHI = InsertNewDef ( TargetOpcode :: PHI , BB , Loc , VRC , MRI , TII ) ; for ( unsigned i = 0 , e = PredValues . size ( ) ; i != e ; ++ i ) InsertedPHI . addReg ( PredValues [ i ] . second ) . addMBB ( PredValues [ i ] . first ) ; if ( unsigned ConstVal = InsertedPHI -> isConstant@@ ValuePHI ( ) ) { InsertedPHI -> eraseFromParent ( ) ; return ConstVal ; } if ( InsertedPHIs ) InsertedPHIs -> push_back ( InsertedPHI ) ; DEBUG ( dbgs ( ) << " ▁ ▁ Inserted ▁ PHI : ▁ " << * InsertedPHI << " \n " ) ; return InsertedPHI -> getOperand ( 0 ) . getReg ( ) ; }
void MachineSSAUpdater :: Rewrite@@ Use ( MachineOperand & U ) { MachineInstr * UseMI = U . getParent ( ) ; unsigned NewVR = 0 ; if ( UseMI -> isPHI ( ) ) { MachineBasicBlock * SourceBB = findCorrespondingPred ( UseMI , & U ) ; NewVR = GetValueAtEndOfBlockInternal ( SourceBB ) ; } else { NewVR = GetValueInMiddleOfBlock ( UseMI -> getParent ( ) ) ; } U . setReg ( NewVR ) ; }
unsigned MachineSSAUpdater :: GetValueAtEndOfBlockInternal ( MachineBasicBlock * BB ) { AvailableValsTy & AvailableVals = getAvailableVals ( AV ) ; if ( unsigned V = AvailableVals [ BB ] ) return V ; SSAUpdaterImpl < MachineSSAUpdater > Impl ( this , & AvailableVals , InsertedPHIs ) ; return Impl . GetValue ( BB ) ; }
UserCode :: UserCode ( uint32 const _homeId , uint8 const _nodeId ) : CommandClass ( _homeId , _nodeId ) , m_queryAll ( false ) , m_currentCode ( 0 ) , m_userCodeCount ( 0 ) , m_refreshUserCodes ( false ) { SetStaticRequest ( StaticRequest_Values ) ; memset ( m_userCodesStatus , 0xff , sizeof ( m_userCodesStatus ) ) ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; }
void UserCode :: ReadXML ( TiXmlElement const * _ccElement ) { int32 intVal ; CommandClass :: ReadXML ( _ccElement ) ; if ( TIXML_SUCCESS == _ccElement -> QueryIntAttribute ( " codes " , & intVal ) ) { m_userCodeCount = intVal ; } }
void UserCode :: WriteXML ( TiXmlElement * _ccElement ) { char str [ 32 ] ; CommandClass :: WriteXML ( _ccElement ) ; snprintf ( str , sizeof ( str ) , " % d " , m_userCodeCount ) ; _ccElement -> SetAttribute ( " codes " , str ) ; }
bool UserCode :: RequestState ( uint32 const _requestFlags , uint8 const _instance , Driver :: MsgQueue const _queue ) { bool requests = false ; if ( ( _requestFlags & RequestFlag_@@ Static ) && HasStaticRequest ( StaticRequest_Values ) ) { requests |= RequestValue ( _requestFlags , UserCodeIndex_Count , _instance , _queue ) ; } if ( _requestFlags & RequestFlag_@@ Session ) { if ( m_userCodeCount > 0 ) { m_queryAll = true ; m_currentCode = 1 ; requests |= RequestValue ( _requestFlags , m_currentCode , _instance , _queue ) ; } } return requests ; }
bool UserCode :: RequestValue ( uint32 const _requestFlags , uint8 const _userCodeIdx , uint8 const _instance , Driver :: MsgQueue const _queue ) { if ( _instance != 1 ) { return false ; } if ( ! IsGetSupported ( ) ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " UserNumberCmd _ Get ▁ Not ▁ Supported ▁ on ▁ this ▁ node " ) ; return false ; } if ( _userCodeIdx == UserCodeIndex_Count ) { Msg * msg = new Msg ( " UserNumberCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 2 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserNumberCmd_Get ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; } if ( _userCodeIdx == 0 ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " UserCodeCmd _ Get ▁ with ▁ Index ▁ 0 ▁ not ▁ Supported " ) ; return false ; } Msg * msg = new Msg ( " UserCodeCmd _ Get " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true , true , FUNC_ID_APPLICATION_COMMAND_HANDLER , GetCommandClassId ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 3 ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Get ) ; msg -> Append ( _userCodeIdx ) ; msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , _queue ) ; return true ; }
bool UserCode :: HandleMsg ( uint8 const * _data , uint32 const _length , uint32 const _instance ) { if ( UserNumberCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { m_userCodeCount = _data [ 1 ] ; if ( m_userCodeCount > 254 ) { m_userCodeCount = 254 ; } ClearStaticRequest ( StaticRequest_Values ) ; if ( m_userCodeCount == 0 ) { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Not ▁ supported " , GetNodeId ( ) ) ; } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Number ▁ report ▁ from ▁ node ▁ % d : ▁ Supported ▁ Codes ▁ % d ▁ ( % d ) " , GetNodeId ( ) , m_userCodeCount , _data [ 1 ] ) ; } if ( ValueByte * value = static_cast < ValueByte * > ( GetValue ( _instance , UserCodeIndex_Count ) ) ) { value -> OnValueRefreshed ( m_userCodeCount ) ; value -> Release ( ) ; } if ( Node * node = GetNodeUnsafe ( ) ) { uint8 data [ UserCodeLength ] ; memset ( data , 0 , UserCodeLength ) ; for ( uint8 i = 0 ; i <= m_userCodeCount ; i ++ ) { char str [ 16 ] ; if ( i == 0 ) { snprintf ( str , sizeof ( str ) , " Enroll@@ ment ▁ Code " ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , true , false , data , UserCodeLength , 0 ) ; } else { snprintf ( str , sizeof ( str ) , " Code ▁ % d : " , i ) ; node -> CreateValueRaw ( ValueID :: ValueGenre_User , GetCommandClassId ( ) , _instance , i , str , " " , false , false , data , UserCodeLength , 0 ) ; } } } return true ; } else if ( UserCodeCmd_Report == ( UserCodeCmd ) _data [ 0 ] ) { int i = _data [ 1 ] ; if ( ValueRaw * value = static_cast < ValueRaw * > ( GetValue ( _instance , i ) ) ) { uint8 data [ UserCodeLength ] ; uint8 size = _length - 4 ; if ( size > UserCodeLength ) { Log :: Write ( LogLevel_Warning , GetNodeId ( ) , " User ▁ Code ▁ length ▁ % d ▁ is ▁ larger ▁ then ▁ maximum ▁ % d " , size , UserCodeLength ) ; size = UserCodeLength ; } m_userCodesStatus [ i ] = _data [ 2 ] ; memcpy ( data , & _data [ 3 ] , size ) ; value -> OnValueRefreshed ( data , size ) ; value -> Release ( ) ; } Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Received ▁ User ▁ Code ▁ Report ▁ from ▁ node ▁ % d ▁ for ▁ User ▁ Code ▁ % d ▁ ( % s ) " , GetNodeId ( ) , i , CodeStatus ( _data [ 2 ] ) . c_str ( ) ) ; if ( m_queryAll && i == m_currentCode ) { if ( m_refreshUserCodes || ( _data [ 2 ] != UserCode_@@ Available ) ) { if ( ++ i <= m_userCodeCount ) { m_currentCode = i ; RequestValue ( 0 , m_currentCode , _instance , Driver :: MsgQueue_Query ) ; } else { m_queryAll = false ; Options :: Get ( ) -> GetOptionAsBool ( " RefreshAllUserCodes " , & m_refreshUserCodes ) ; } } else { Log :: Write ( LogLevel_Info , GetNodeId ( ) , " Not ▁ Requesting ▁ addition@@ al ▁ UserCode ▁ Slots ▁ as ▁ RefreshAllUserCodes ▁ is ▁ false , ▁ and ▁ slot ▁ % d ▁ is ▁ available " , i ) ; m_queryAll = false ; } } return true ; } return false ; }
bool UserCode :: SetValue ( Value const & _value ) { if ( ( ValueID :: ValueType_@@ Raw == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) < UserCodeIndex_Refresh ) ) { ValueRaw const * value = static_cast < ValueRaw const * > ( & _value ) ; uint8 * s = value -> GetValue ( ) ; uint8 len = value -> GetLength ( ) ; if ( len > UserCodeLength ) { return false ; } m_userCodesStatus [ value -> GetID ( ) . GetIndex ( ) ] = UserCode_Occupied ; Msg * msg = new Msg ( " UserCodeCmd _ Set " , GetNodeId ( ) , REQUEST , FUNC_ID_ZW_SEND_DATA , true ) ; msg -> SetInstance ( this , _value . GetID ( ) . GetInstance ( ) ) ; msg -> Append ( GetNodeId ( ) ) ; msg -> Append ( 4 + len ) ; msg -> Append ( GetCommandClassId ( ) ) ; msg -> Append ( UserCodeCmd_Set ) ; msg -> Append ( value -> GetID ( ) . GetIndex ( ) ) ; msg -> Append ( UserCode_Occupied ) ; for ( uint8 i = 0 ; i < len ; i ++ ) { msg -> Append ( s [ i ] ) ; } msg -> Append ( GetDriver ( ) -> GetTransmitOptions ( ) ) ; GetDriver ( ) -> SendMsg ( msg , Driver :: MsgQueue_@@ Send ) ; return true ; } if ( ( ValueID :: ValueType_@@ Button == _value . GetID ( ) . GetType ( ) ) && ( _value . GetID ( ) . GetIndex ( ) == UserCodeIndex_Refresh ) ) { m_refreshUserCodes = true ; m_currentCode = 1 ; m_queryAll = true ; RequestValue ( 0 , m_currentCode , _value . GetID ( ) . GetInstance ( ) , Driver :: MsgQueue_Query ) ; return true ; } return false ; }
void UserCode :: CreateVars ( uint8 const _instance ) { if ( Node * node = GetNodeUnsafe ( ) ) { node -> CreateValueByte ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Count , " Code ▁ Count " , " " , true , false , 0 , 0 ) ; node -> CreateValueButton ( ValueID :: ValueGenre_System , GetCommandClassId ( ) , _instance , UserCodeIndex_Refresh , " Refresh ▁ All ▁ UserCodes " , 0 ) ; } }
ComputeTempAsphere :: ComputeTempAsphere ( LAMMP@@ S * lmp , int narg , char * * arg ) : Compute ( lmp , narg , arg ) { if ( narg < 3 ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; scalar_@@ flag = vector@@ _flag = 1 ; size_vector = 6 ; extscalar = 0 ; extvector = 1 ; tempflag = 1 ; tempbias = 0 ; id_bias = NULL ; mode = ALL ; int iarg = 3 ; while ( iarg < narg ) { if ( strcmp ( arg [ iarg ] , " bias " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; tempbias = 1 ; int n = strlen ( arg [ iarg + 1 ] ) + 1 ; id_bias = new char [ n ] ; strcpy ( id_bias , arg [ iarg + 1 ] ) ; iarg += 2 ; } else if ( strcmp ( arg [ iarg ] , " dof " ) == 0 ) { if ( iarg + 2 > narg ) error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; if ( strcmp ( arg [ iarg + 1 ] , " rotate " ) == 0 ) mode = ROTATE ; else if ( strcmp ( arg [ iarg + 1 ] , " all " ) == 0 ) mode = ALL ; else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; iarg += 2 ; } else error -> all ( FLERR , " Illegal ▁ compute ▁ temp / asphere ▁ command " ) ; } vector = new double [ 6 ] ; }
ComputeTempAsphere :: ~ ComputeTempAsphere ( ) { delete [ ] id_bias ; delete [ ] vector ; }
void ComputeTempAsphere :: init ( ) { avec = ( AtomVecEllipsoid * ) atom -> style_@@ match ( " ellipsoid " ) ; if ( ! avec ) error -> all ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ atom ▁ style ▁ ellipsoid " ) ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( ellipsoid [ i ] < 0 ) error -> one ( FLERR , " Compute ▁ temp / asphere ▁ requires ▁ extended ▁ partic@@ les " ) ; if ( tempbias ) { int i = modify -> find_compute ( id_bias ) ; if ( i < 0 ) error -> all ( FLERR , " Could ▁ not ▁ find ▁ compute ▁ ID ▁ for ▁ temperature ▁ bias " ) ; tbias = modify -> compute [ i ] ; if ( tbias -> tempflag == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ temperature " ) ; if ( tbias -> tempbias == 0 ) error -> all ( FLERR , " Bias ▁ compute ▁ does ▁ not ▁ calculate ▁ a ▁ velocity ▁ bias " ) ; if ( tbias -> igroup != igroup ) error -> all ( FLERR , " Bias ▁ compute ▁ group ▁ does ▁ not ▁ match ▁ compute ▁ group " ) ; tbias -> init ( ) ; tbias -> setup ( ) ; if ( strcmp ( tbias -> style , " temp / region " ) == 0 ) tempbias = 2 ; else tempbias = 1 ; } }
void ComputeTempAsphere :: setup ( ) { fix_dof = - 1 ; dof_compute ( ) ; }
void ComputeTempAsphere :: dof_compute ( ) { if ( fix_dof ) adju@@ st_dof_@@ fix ( ) ; double natoms = group -> count ( igroup ) ; int nper ; if ( domain -> dimen@@ sion == 3 ) { if ( mode == ALL ) nper = 6 ; else nper = 3 ; } else { if ( mode == ALL ) nper = 3 ; else nper = 1 ; } dof = nper * natoms ; if ( tempbias == 1 ) { if ( mode == ALL ) dof -= tbias -> dof_remove ( - 1 ) * natoms ; } else if ( tempbias == 2 ) { int * mask = atom -> mask ; int nlocal = atom -> nlocal ; tbias -> dof_re@@ move_pre ( ) ; int count = 0 ; for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) if ( tbias -> dof_remove ( i ) ) count ++ ; int count_all ; MPI_Allreduce ( & count , & count_all , 1 , MPI_INT , MPI_SUM , world ) ; dof -= nper * count_all ; } dof -= extr@@ a_dof + fix_dof ; if ( dof > 0 ) tfactor = force -> mvv2e / ( dof * force -> bolt@@ z ) ; else tfactor = 0.0 ; }
double ComputeTempAsphere :: compute_scalar ( ) { invoked_scalar = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_scalar != update -> ntimestep ) tbias -> compute_scalar ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] ; double rot [ 3 ] [ 3 ] ; double t = 0.0 ; if ( mode == ALL ) { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { t += ( v [ i ] [ 0 ] * v [ i ] [ 0 ] + v [ i ] [ 1 ] * v [ i ] [ 1 ] + v [ i ] [ 2 ] * v [ i ] [ 2 ] ) * rmass [ i ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } else { for ( int i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * rmass [ i ] * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * rmass [ i ] * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] + inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] + inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( & t , & scalar , 1 , MPI_DOUBLE , MPI_SUM , world ) ; if ( dynamic || tempbias == 2 ) dof_compute ( ) ; scalar *= tfactor ; return scalar ; }
void ComputeTempAsphere :: compute_vector ( ) { int i ; invoked_vector = update -> ntimestep ; if ( tempbias ) { if ( tbias -> invoked_vector != update -> ntimestep ) tbias -> compute_vector ( ) ; tbias -> remove_bias_all ( ) ; } AtomVecEllipsoid :: Bonus * bonus = avec -> bonus ; double * * v = atom -> v ; double * * angmom = atom -> angmom ; double * rmass = atom -> rmass ; int * ellipsoid = atom -> ellipsoid ; int * mask = atom -> mask ; int nlocal = atom -> nlocal ; double * shape , * quat ; double wbody [ 3 ] , inertia [ 3 ] , t [ 6 ] ; double rot [ 3 ] [ 3 ] ; double massone ; for ( i = 0 ; i < 6 ; i ++ ) t [ i ] = 0.0 ; if ( mode == ALL ) { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { massone = rmass [ i ] ; t [ 0 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 0 ] ; t [ 1 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 1 ] ; t [ 2 ] += massone * v [ i ] [ 2 ] * v [ i ] [ 2 ] ; t [ 3 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 1 ] ; t [ 4 ] += massone * v [ i ] [ 0 ] * v [ i ] [ 2 ] ; t [ 5 ] += massone * v [ i ] [ 1 ] * v [ i ] [ 2 ] ; shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } else { for ( i = 0 ; i < nlocal ; i ++ ) if ( mask [ i ] & groupbit ) { shape = bonus [ ellipsoid [ i ] ] . shape ; quat = bonus [ ellipsoid [ i ] ] . quat ; massone = rmass [ i ] ; inertia [ 0 ] = INERTIA * massone * ( shape [ 1 ] * shape [ 1 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 1 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 2 ] * shape [ 2 ] ) ; inertia [ 2 ] = INERTIA * massone * ( shape [ 0 ] * shape [ 0 ] + shape [ 1 ] * shape [ 1 ] ) ; MathExtra :: quat_to_mat ( quat , rot ) ; MathExtra :: transpose_matvec ( rot , angmom [ i ] , wbody ) ; wbody [ 0 ] /= inertia [ 0 ] ; wbody [ 1 ] /= inertia [ 1 ] ; wbody [ 2 ] /= inertia [ 2 ] ; t [ 0 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 0 ] ; t [ 1 ] += inertia [ 1 ] * wbody [ 1 ] * wbody [ 1 ] ; t [ 2 ] += inertia [ 2 ] * wbody [ 2 ] * wbody [ 2 ] ; t [ 3 ] += inertia [ 0 ] * wbody [ 0 ] * wbody [ 1 ] ; t [ 4 ] += inertia [ 1 ] * wbody [ 0 ] * wbody [ 2 ] ; t [ 5 ] += inertia [ 2 ] * wbody [ 1 ] * wbody [ 2 ] ; } } if ( tempbias ) tbias -> restore_bias_all ( ) ; MPI_Allreduce ( t , vector , 6 , MPI_DOUBLE , MPI_SUM , world ) ; for ( i = 0 ; i < 6 ; i ++ ) vector [ i ] *= force -> mvv2e ; }
void ComputeTempAsphere :: remove_bias ( int i , double * v ) { if ( tbias ) tbias -> remove_bias ( i , v ) ; }
void ComputeTempAsphere :: restore_bias ( int i , double * v ) { if ( tbias ) tbias -> restore_bias ( i , v ) ; }
void WorldSession :: HandleRepopRequestOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ REPO@@ P _ REQUEST ▁ Message " ) ; recvData . read_skip < uint8 > ( ) ; if ( GetPlayer ( ) -> IsAlive ( ) || GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; if ( GetPlayer ( ) -> HasAura@@ Type ( SPELL_AURA_@@ PR@@ EVENT_RESUR@@ RECTION ) ) return ; if ( GetPlayer ( ) -> getDe@@ athState ( ) == JU@@ ST_DIED ) { TC_LOG_DEBUG ( " network " , " HandleRepopRequestOpcode : ▁ got ▁ request ▁ after ▁ player ▁ % s ( % d ) ▁ was ▁ kil@@ led ▁ and ▁ before ▁ he ▁ was ▁ updated " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; GetPlayer ( ) -> Kill@@ Player ( ) ; } GetPlayer ( ) -> RemoveGho@@ ul ( ) ; GetPlayer ( ) -> RemovePet ( NULL , PET_SAVE_@@ NOT_IN_S@@ LOT , true ) ; GetPlayer ( ) -> BuildPlayerRepop ( ) ; GetPlayer ( ) -> RepopAtGraveyard ( ) ; }
void WorldSession :: HandleGossipSelectOptionOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ GOSSIP _ SELECT _ OPTION " ) ; uint32 gossipListId ; uint32 menuId ; ObjectGuid guid ; std :: string code = " " ; recvData >> guid >> menuId >> gossipListId ; if ( ! _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetItem ( gossipListId ) ) { recvData . rfinish ( ) ; return ; } if ( _player -> PlayerTalkClass -> IsGossip@@ OptionCoded ( gossipListId ) ) recvData >> code ; if ( _player -> PlayerTalkClass -> GetGossipMenu ( ) . GetSender@@ GUID ( ) != guid ) return ; Creature * unit = NULL ; GameObject * go = NULL ; if ( guid . IsCreature@@ OrVehicle ( ) ) { unit = GetPlayer ( ) -> GetNP@@ CIfCanInteractWith ( guid , UNIT_NPC_FLAG_GOSSIP ) ; if ( ! unit ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ him . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else if ( guid . IsGameObject ( ) ) { go = _player -> GetGameObject@@ IfCanInteractWith ( guid ) ; if ( ! go ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ % s ▁ not ▁ found ▁ or ▁ you ▁ can ' t ▁ interact ▁ with ▁ it . " , guid . ToString ( ) . c_str ( ) ) ; return ; } } else { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ unsupported ▁ % s . " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( GetPlayer ( ) -> HasUnitState ( UNIT_STATE_DIED ) ) GetPlayer ( ) -> RemoveAurasByType ( SPELL_AUR@@ A_FEIGN_DEATH ) ; if ( ( unit && unit -> GetScriptId ( ) != unit -> LastUsedScriptID ) || ( go && go -> GetScriptId ( ) != go -> LastUsedScriptID ) ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ HandleGossipSelectOptionOpcode ▁ - ▁ Script ▁ reloaded ▁ while ▁ in ▁ use , ▁ ignoring ▁ and ▁ set ▁ new ▁ sci@@ pt ▁ id " ) ; if ( unit ) unit -> LastUsedScriptID = unit -> GetScriptId ( ) ; if ( go ) go -> LastUsedScriptID = go -> GetScriptId ( ) ; _player -> PlayerTalkClass -> SendCloseGossip ( ) ; return ; } if ( ! code . empty ( ) ) { if ( unit ) { unit -> AI ( ) -> sGossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelectCode ( _player , menuId , gossipListId , code . c_str ( ) ) ; if ( ! sScriptMgr -> OnGossipSelectCode ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) , code . c_str ( ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } else { if ( unit ) { unit -> AI ( ) -> sGossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , unit , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( unit , gossipListId , menuId ) ; } else { go -> AI ( ) -> GossipSelect ( _player , menuId , gossipListId ) ; if ( ! sScriptMgr -> OnGossipSelect ( _player , go , _player -> PlayerTalkClass -> GetGossipOptionSender ( gossipListId ) , _player -> PlayerTalkClass -> GetGossipOptionAction ( gossipListId ) ) ) _player -> OnGossipSelect ( go , gossipListId , menuId ) ; } } }
void WorldSession :: HandleWho@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ WHO ▁ Message " ) ; uint32 matchCount = 0 ; uint32 levelMin , levelMax , racemask , classmask , zonesCount , strCount ; uint32 zoneids [ 10 ] ; std :: string packetPlayerName , packetGuildName ; recvData >> levelMin ; recvData >> levelMax ; recvData >> packetPlayerName ; recvData >> packetGuildName ; recvData >> racemask ; recvData >> classmask ; recvData >> zonesCount ; if ( zonesCount > 10 ) return ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { uint32 temp ; recvData >> temp ; zoneids [ i ] = temp ; TC_LOG_DEBUG ( " network " , " Zone ▁ % u : ▁ % u " , i , zoneids [ i ] ) ; } recvData >> strCount ; if ( strCount > 4 ) return ; TC_LOG_DEBUG ( " network " , " Minlvl ▁ % u , ▁ maxlvl ▁ % u , ▁ name ▁ % s , ▁ guild ▁ % s , ▁ racemask ▁ % u , ▁ classmask ▁ % u , ▁ zones ▁ % u , ▁ strings ▁ % u " , levelMin , levelMax , packetPlayerName . c_str ( ) , packetGuildName . c_str ( ) , racemask , classmask , zonesCount , strCount ) ; std :: wstring str [ 4 ] ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { std :: string temp ; recvData >> temp ; if ( ! Utf8toWStr ( temp , str [ i ] ) ) continue ; wstrToLower ( str [ i ] ) ; TC_LOG_DEBUG ( " network " , " String ▁ % u : ▁ % s " , i , temp . c_str ( ) ) ; } std :: wstring wpacketPlayerName ; std :: wstring wpacketGuildName ; if ( ! ( Utf8toWStr ( packetPlayerName , wpacketPlayerName ) && Utf8toWStr ( packetGuildName , wpacketGuildName ) ) ) return ; wstrToLower ( wpacketPlayerName ) ; wstrToLower ( wpacketGuildName ) ; if ( levelMax >= MAX_LEVEL ) levelMax = STRON@@ G_MAX_LEVEL ; uint32 team = _player -> GetTeam ( ) ; uint32 gmLevelInWhoList = sWorld -> getIntConfig ( CONFIG_GM_@@ LEVEL_IN_WHO_LIST ) ; uint32 displayCount = 0 ; WorldPacket data ( SMSG_WHO , 500 ) ; data << uint32 ( matchCount ) ; data << uint32 ( displayCount ) ; WhoList@@ InfoVector const & whoList = sWhoList@@ Storage@@ Mgr -> GetWhoList ( ) ; for ( WhoList@@ PlayerInfo const & target : whoList ) { if ( target . GetTeam ( ) != team && ! HasPermission ( rbac :: RBAC_PERM_@@ TWO_S@@ IDE_@@ WHO_LIST ) ) continue ; if ( ! HasPermission ( rbac :: RBAC_PERM_@@ WHO@@ _SEE_AL@@ L_SEC_LEV@@ ELS ) && target . GetSecurity ( ) > AccountTypes ( gmLevelInWhoList ) ) continue ; if ( _player -> GetGUID ( ) != target . GetGuid ( ) && ! target . IsVisible ( ) ) if ( AccountMgr :: IsPlayer@@ Account ( _player -> GetSession ( ) -> GetSecurity ( ) ) || target . GetSecurity ( ) > _player -> GetSession ( ) -> GetSecurity ( ) ) continue ; uint8 lvl = target . GetLevel ( ) ; if ( lvl < levelMin || lvl > levelMax ) continue ; uint8 class_ = target . GetClass ( ) ; if ( ! ( classmask & ( 1 << class_ ) ) ) continue ; uint32 race = target . GetRace ( ) ; if ( ! ( racemask & ( 1 << race ) ) ) continue ; uint32 playerZoneId = target . GetZoneId ( ) ; uint8 gender = target . GetGen@@ der ( ) ; bool showZones = true ; for ( uint32 i = 0 ; i < zonesCount ; ++ i ) { if ( zoneids [ i ] == playerZoneId ) { showZones = true ; break ; } showZones = false ; } if ( ! showZones ) continue ; std :: wstring const & wideplayername = target . GetWide@@ PlayerName ( ) ; if ( ! ( wpacketPlayerName . empty ( ) || wideplayername . find ( wpacketPlayerName ) != std :: wstring :: npos ) ) continue ; std :: wstring const & wideguildname = target . GetWide@@ GuildName ( ) ; if ( ! ( wpacketGuildName . empty ( ) || wideguildname . find ( wpacketGuildName ) != std :: wstring :: npos ) ) continue ; std :: string aname ; if ( AreaTableEntry const * areaEntry = sAreaTableStore . LookupEntry ( playerZoneId ) ) aname = areaEntry -> area_name [ GetSessionDbcLocale ( ) ] ; bool s_show = true ; for ( uint32 i = 0 ; i < strCount ; ++ i ) { if ( ! str [ i ] . empty ( ) ) { if ( wideguildname . find ( str [ i ] ) != std :: wstring :: npos || wideplayername . find ( str [ i ] ) != std :: wstring :: npos || Utf8@@ Fit@@ To ( aname , str [ i ] ) ) { s_show = true ; break ; } s_show = false ; } } if ( ! s_show ) continue ; if ( ( matchCount ++ ) >= sWorld -> getIntConfig ( CONFIG_MAX_WHO ) ) continue ; data << target . GetPlayerName ( ) ; data << target . GetGuildName ( ) ; data << uint32 ( lvl ) ; data << uint32 ( class_ ) ; data << uint32 ( race ) ; data << uint8 ( gender ) ; data << uint32 ( playerZoneId ) ; ++ displayCount ; } data . put ( 0 , displayCount ) ; data . put ( 4 , matchCount ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Send ▁ SMSG _ WHO ▁ Message " ) ; }
void WorldSession :: HandleLogout@@ RequestOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ REQUEST ▁ Message , ▁ security ▁ - ▁ % u " , GetSecurity ( ) ) ; if ( ObjectGuid lguid = GetPlayer ( ) -> GetLoot@@ GUID ( ) ) DoLoot@@ Release ( lguid ) ; bool instantLogout = ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) && ! GetPlayer ( ) -> IsInCombat ( ) ) || GetPlayer ( ) -> IsInFlight ( ) || HasPermission ( rbac :: RBAC_PERM_@@ INSTANT_@@ LOGOUT ) ; bool canLogoutInCombat = GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_RESTING ) ; uint32 reason = 0 ; if ( GetPlayer ( ) -> IsInCombat ( ) && ! canLogoutInCombat ) reason = 1 ; else if ( GetPlayer ( ) -> m_movementInfo . HasMovement@@ Flag ( MOVEMENTFLAG_FAL@@ LING | MOVEMENTFLAG_FAL@@ LING_@@ FAR ) ) reason = 3 ; else if ( GetPlayer ( ) -> duel || GetPlayer ( ) -> HasAura ( 9454 ) ) reason = 2 ; WorldPacket data ( SMSG_LOGOUT_@@ RESPONSE , 1 + 4 ) ; data << uint32 ( reason ) ; data << uint8 ( instantLogout ) ; SendPacket ( & data ) ; if ( reason ) { LogoutRequest ( 0 ) ; return ; } if ( instantLogout ) { LogoutPlayer ( true ) ; return ; } if ( GetPlayer ( ) -> CanFreeMove ( ) ) { if ( GetPlayer ( ) -> GetStandState ( ) == UNIT_STAND_STATE_STAND ) GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_@@ SIT ) ; WorldPacket data ( SMSG_FORCE_MOVE_@@ ROOT , ( 8 + 4 ) ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << ( uint32 ) 2 ; SendPacket ( & data ) ; GetPlayer ( ) -> SetFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } LogoutRequest ( time ( NULL ) ) ; }
void WorldSession :: HandlePlayer@@ LogoutOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ PLAYER _ LOGOUT ▁ Message " ) ; }
void WorldSession :: HandleLogout@@ Cancel@@ Opcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ CMSG _ LOGOUT _ CANCEL ▁ Message " ) ; if ( ! GetPlayer ( ) ) return ; LogoutRequest ( 0 ) ; WorldPacket data ( SMSG_LOGOUT_@@ CANCEL_@@ ACK , 0 ) ; SendPacket ( & data ) ; if ( GetPlayer ( ) -> CanFreeMove ( ) ) { data . Initialize ( SMSG_FORCE_MOVE_@@ UNROOT , 8 ) ; data << GetPlayer ( ) -> GetPackGUID ( ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; GetPlayer ( ) -> SetStandState ( UNIT_STAND_STATE_STAND ) ; GetPlayer ( ) -> RemoveFlag ( UNIT_FIELD_FLAGS , UNIT_FLAG_STUNNED ) ; } }
void WorldSession :: HandleToggle@@ PvP ( WorldPacket & recvData ) { if ( recvData . size ( ) == 1 ) { bool newPvPStatus ; recvData >> newPvPStatus ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP , newPvPStatus ) ; GetPlayer ( ) -> ApplyModFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER , ! newPvPStatus ) ; } else { GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ; GetPlayer ( ) -> ToggleFlag ( PLAYER_FLAGS , PLAYER_FLAGS_PVP_TIMER ) ; } if ( GetPlayer ( ) -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_IN_PVP ) ) { if ( ! GetPlayer ( ) -> IsPvP ( ) || GetPlayer ( ) -> pvpInfo . EndTimer ) GetPlayer ( ) -> UpdatePvP ( true , true ) ; } else { if ( ! GetPlayer ( ) -> pvpInfo . IsHost@@ ile && GetPlayer ( ) -> IsPvP ( ) ) GetPlayer ( ) -> pvpInfo . EndTimer = time ( NULL ) ; } }
void WorldSession :: HandleZone@@ UpdateOpcode ( WorldPacket & recvData ) { uint32 newZone ; recvData >> newZone ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Recvd ▁ ZONE _ UPDATE : ▁ % u " , newZone ) ; GetPlayer ( ) -> SetNeeds@@ ZoneUpdate ( true ) ; }
void WorldSession :: HandleSetSelectionOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; _player -> SetSelection ( guid ) ; }
void WorldSession :: HandleStand@@ StateChange@@ Opcode ( WorldPacket & recvData ) { uint32 animstate ; recvData >> animstate ; _player -> SetStandState ( animstate ) ; }
void WorldSession :: HandleBugOpcode ( WorldPacket & recvData ) { uint32 suggestion , contentlen , typelen ; std :: string content , type ; recvData >> suggestion >> contentlen >> content ; recvData >> typelen >> type ; if ( suggestion == 0 ) TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Bug ▁ Report ] " ) ; else TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ BUG ▁ [ Suggest@@ ion ] " ) ; TC_LOG_DEBUG ( " network " , " % s " , type . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " % s " , content . c_str ( ) ) ; PreparedStatement * stmt = CharacterDatabase . GetPreparedStatement ( CHAR_INS_@@ BUG_REPORT ) ; stmt -> setString ( 0 , type ) ; stmt -> setString ( 1 , content ) ; CharacterDatabase . Execute ( stmt ) ; }
void WorldSession :: HandleRe@@ claim@@ Corpse@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RECLA@@ IM _ CORPSE " ) ; ObjectGuid guid ; recvData >> guid ; if ( _player -> IsAlive ( ) ) return ; if ( _player -> InAr@@ ena ( ) ) return ; if ( ! _player -> HasFlag ( PLAYER_FLAGS , PLAYER_FLAGS_GHOST ) ) return ; Corpse * corpse = _player -> GetCorpse ( ) ; if ( ! corpse ) return ; if ( time_t ( corpse -> GetGhost@@ Time ( ) + _player -> GetCorpse@@ Reclaim@@ Delay ( corpse -> GetType ( ) == CORPSE_RESUR@@ RECT@@ ABLE_PVP ) ) > time_t ( time ( NULL ) ) ) return ; if ( ! corpse -> IsWithinDistInMap ( _player , CORPSE_RECLA@@ IM_@@ RADIUS , true ) ) return ; _player -> ResurrectPlayer ( _player -> InBattleground ( ) ? 1.0f : 0.5f ) ; _player -> SpawnCorpseBones ( ) ; }
void WorldSession :: HandleResurrect@@ ResponseOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ RESUR@@ RECT _ RESPONSE " ) ; ObjectGuid guid ; uint8 status ; recvData >> guid ; recvData >> status ; if ( GetPlayer ( ) -> IsAlive ( ) ) return ; if ( status == 0 ) { GetPlayer ( ) -> ClearResurrect@@ RequestData ( ) ; return ; } if ( ! GetPlayer ( ) -> IsResurrect@@ RequestedBy ( guid ) ) return ; GetPlayer ( ) -> ResurrectUsingRequestData ( ) ; }
void WorldSession :: SendAreaTrigger@@ Message ( const char * Text , ... ) { va_list ap ; char szStr [ 1024 ] ; szStr [ 0 ] = ' \0' ; va_start ( ap , Text ) ; vsnprintf ( szStr , 1024 , Text , ap ) ; va_end ( ap ) ; uint32 length = strlen ( szStr ) + 1 ; WorldPacket data ( SMSG_AREA_@@ TRIGGER_@@ MESSAGE , 4 + length ) ; data << length ; data << szStr ; SendPacket ( & data ) ; }
void WorldSession :: HandleAreaTriggerOpcode ( WorldPacket & recvData ) { uint32 triggerId ; recvData >> triggerId ; TC_LOG_DEBUG ( " network " , " CMSG _ AREATRIG@@ GER . ▁ Trigger ▁ ID : ▁ % u " , triggerId ) ; Player * player = GetPlayer ( ) ; if ( player -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } AreaTriggerEntry const * atEntry = sAreaTrigger@@ Store . LookupEntry ( triggerId ) ; if ( ! atEntry ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ send ▁ unknown ▁ ( by ▁ DBC ) ▁ Area ▁ Trigger ▁ ID : % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( ! player -> IsInAreaTriggerRadius ( atEntry ) ) { TC_LOG_DEBUG ( " network " , " HandleAreaTriggerOpcode : ▁ Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ too ▁ far , ▁ ignore ▁ Area ▁ Trigger ▁ ID : ▁ % u " , player -> GetName ( ) . c_str ( ) , player -> GetGUID ( ) . GetCounter ( ) , triggerId ) ; return ; } if ( player -> isDebug@@ AreaTriggers ) ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( LANG_DEBUG_@@ AREATRIG@@ GER_REACHED , triggerId ) ; if ( sScriptMgr -> OnAreaTrigger ( player , atEntry ) ) return ; if ( player -> IsAlive ( ) ) if ( uint32 questId = sObjectMgr -> GetQuest@@ ForAreaTrigger ( triggerId ) ) if ( player -> GetQuestStatus ( questId ) == QUEST_STATUS_INCOMPLETE ) player -> AreaExplored@@ OrEventHappens ( questId ) ; if ( sObjectMgr -> IsTa@@ vernAreaTrigger ( triggerId ) ) { player -> SetRestFlag ( REST_@@ FLAG_IN_TAVERN , atEntry -> id ) ; if ( sWorld -> IsFFAP@@ vP@@ Realm ( ) ) player -> RemoveByteFlag ( UNIT_FIELD_@@ BYTES_@@ 2 , UNIT_BYTES_@@ 2_OFFSET_@@ PVP_FLA@@ G , UNIT_BY@@ TE2_FLAG_@@ FFA_@@ PVP ) ; return ; } if ( Battleground * bg = player -> GetBattleground ( ) ) if ( bg -> GetStatus ( ) == STATUS_IN_PROGRESS ) bg -> HandleAreaTrigger ( player , triggerId ) ; if ( OutdoorPvP * pvp = player -> GetOutdoorPvP ( ) ) if ( pvp -> HandleAreaTrigger ( _player , triggerId ) ) return ; AreaTrigger const * at = sObjectMgr -> GetAreaTrigger ( triggerId ) ; if ( ! at ) return ; bool teleported = false ; if ( player -> GetMapId ( ) != at -> target_mapId ) { if ( Map :: EnterState denyReason = sMap@@ Mgr -> PlayerCannot@@ Enter ( at -> target_mapId , player , false ) ) { bool reviveAtTrigger = false ; switch ( denyReason ) { case Map :: CANNOT_ENTER_NO_ENTRY : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ map ▁ with ▁ id ▁ % d ▁ which ▁ has ▁ no ▁ entry " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_UNINSTANC@@ ED_DUNGEON : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ dunge@@ on ▁ map ▁ % d ▁ but ▁ no ▁ instance ▁ template ▁ was ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; case Map :: CANNOT_ENTER_DIFFICULTY_@@ UNAVAILABLE : TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ attempted ▁ to ▁ enter ▁ instance ▁ map ▁ % d ▁ but ▁ the ▁ requested ▁ difficulty ▁ was ▁ not ▁ found " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) player -> SendTransferAborted ( entry -> MapID , TRANSFER_ABORT_@@ DIFFICULTY , player -> GetDifficulty ( entry -> IsRaid ( ) ) ) ; break ; case Map :: CANNOT_ENTER_NOT_IN_RAID : { WorldPacket data ( SMSG_RAID_@@ GROUP_ONLY , 4 + 4 ) ; data << uint32 ( 0 ) ; data << uint32 ( 2 ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ must ▁ be ▁ in ▁ a ▁ raid ▁ group ▁ to ▁ enter ▁ instance ▁ map ▁ % d " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; } case Map :: CANNOT_ENTER_CORPSE_@@ IN_DIFFERENT_@@ INSTANCE : { WorldPacket data ( SMSG_CORPSE_@@ NOT_IN_INSTANCE ) ; player -> GetSession ( ) -> SendPacket ( & data ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ does ▁ not ▁ have ▁ a ▁ corpse ▁ in ▁ instance ▁ map ▁ % d ▁ and ▁ cannot ▁ enter " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; break ; } case Map :: CANNOT_ENTER_INSTANCE_BIND_MISMATCH : if ( MapEntry const * entry = sMapStore . LookupEntry ( at -> target_mapId ) ) { char const * mapName = entry -> name [ player -> GetSession ( ) -> GetSessionDbcLocale ( ) ] ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ ' % s ' ▁ because ▁ their ▁ perman@@ ent ▁ bind ▁ is ▁ incomp@@ atible ▁ with ▁ their ▁ group ' s " , player -> GetName ( ) . c_str ( ) , mapName ) ; ChatHandler ( player -> GetSession ( ) ) . PSendSysMessage ( player -> GetSession ( ) -> GetTrinityString ( LANG_INSTANCE_BIND_MISMATCH ) , mapName ) ; } reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_TOO_MANY_INSTANCES : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_@@ TOO_MANY_INSTANCES ) ; TC_LOG_DEBUG ( " maps " , " MAP : ▁ Player ▁ ' % s ' ▁ cannot ▁ enter ▁ instance ▁ map ▁ % d ▁ because ▁ he ▁ has ▁ exceeded ▁ the ▁ maximum ▁ number ▁ of ▁ instances ▁ per ▁ hour . " , player -> GetName ( ) . c_str ( ) , at -> target_mapId ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_MAX_PLAYERS : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_@@ MAX_PLAYERS ) ; reviveAtTrigger = true ; break ; case Map :: CANNOT_ENTER_ZONE_IN_COMBAT : player -> SendTransferAborted ( at -> target_mapId , TRANSFER_ABORT_@@ ZONE_IN_COMBAT ) ; reviveAtTrigger = true ; break ; default : break ; } if ( reviveAtTrigger ) if ( ! player -> IsAlive ( ) && player -> HasCor@@ pse ( ) ) if ( player -> GetCorpse@@ Location ( ) . GetMapId ( ) == at -> target_mapId ) { player -> ResurrectPlayer ( 0.5f ) ; player -> SpawnCorpseBones ( ) ; } return ; } if ( Group * group = player -> GetGroup ( ) ) if ( group -> isLF@@ GGroup ( ) && player -> GetMap ( ) -> IsDungeon ( ) ) teleported = player -> Teleport@@ ToBG@@ EntryPoint ( ) ; } if ( ! teleported ) player -> TeleportTo ( at -> target_mapId , at -> target_X , at -> target_Y , at -> target_Z , at -> target_Orientation , TEL@@ E_TO_@@ NOT_LEAVE_@@ TRANSPORT ) ; }
void WorldSession :: HandleUpdate@@ AccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ UPDATE _ ACCOUNT _ DATA " ) ; uint32 type , timestamp , decompressedSize ; recvData >> type >> timestamp >> decompressedSize ; TC_LOG_DEBUG ( " network " , " UAD : ▁ type ▁ % u , ▁ time ▁ % u , ▁ decompressedSize ▁ % u " , type , timestamp , decompressedSize ) ; if ( type > NUM_ACCOUNT_DATA_TYPES ) return ; if ( decompressedSize == 0 ) { SetAccountData ( AccountDataType ( type ) , 0 , " " ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; return ; } if ( decompressedSize > 0xFFFF ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Account ▁ data ▁ packet ▁ too ▁ big , ▁ size ▁ % u " , decompressedSize ) ; return ; } ByteBuffer dest ; dest . resize ( decompressedSize ) ; uLongf realSize = decompressedSize ; if ( uncompress ( dest . contents ( ) , & realSize , recvData . contents ( ) + recvData . rpos ( ) , recvData . size ( ) - recvData . rpos ( ) ) != Z_OK ) { recvData . rfinish ( ) ; TC_LOG_ERROR ( " network " , " UAD : ▁ Failed ▁ to ▁ decompress ▁ account ▁ data " ) ; return ; } recvData . rfinish ( ) ; std :: string adata ; dest >> adata ; SetAccountData ( AccountDataType ( type ) , timestamp , adata ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_DATA_COMPLETE , 4 + 4 ) ; data << uint32 ( type ) ; data << uint32 ( 0 ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleRequest@@ AccountData ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ REQUEST _ ACCOUNT _ DATA " ) ; uint32 type ; recvData >> type ; TC_LOG_DEBUG ( " network " , " RAD : ▁ type ▁ % u " , type ) ; if ( type >= NUM_ACCOUNT_DATA_TYPES ) return ; AccountData * adata = GetAccountData ( AccountDataType ( type ) ) ; uint32 size = adata -> Data . size ( ) ; uLongf destSize = compressBound ( size ) ; ByteBuffer dest ; dest . resize ( destSize ) ; if ( size && compress ( dest . contents ( ) , & destSize , ( uint8 const * ) adata -> Data . c_str ( ) , size ) != Z_OK ) { TC_LOG_DEBUG ( " network " , " RAD : ▁ Failed ▁ to ▁ compress ▁ account ▁ data " ) ; return ; } dest . resize ( destSize ) ; WorldPacket data ( SMSG_UPDATE_ACCOUNT_@@ DATA , 8 + 4 + 4 + 4 + destSize ) ; data << uint64 ( _player ? _player -> GetGUID ( ) : ObjectGuid :: Empty ) ; data << uint32 ( type ) ; data << uint32 ( adata -> Time ) ; data << uint32 ( size ) ; data . append ( dest ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleSetAction@@ ButtonOpcode ( WorldPacket & recvData ) { uint8 button ; uint32 packetData ; recvData >> button >> packetData ; TC_LOG_DEBUG ( " network " , " CMSG _ SET _ ACTION _ BUTTON ▁ Button : ▁ % u ▁ Data : ▁ % u " , button , packetData ) ; if ( ! packetData ) GetPlayer ( ) -> removeActionButton ( button ) ; else GetPlayer ( ) -> addActionButton ( button , ACTION_BUTTON_@@ ACTION ( packetData ) , ACTION_BUTTON_@@ TYPE ( packetData ) ) ; }
void WorldSession :: HandleComplete@@ Cinematic ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> EndCinematic ( ) ; }
void WorldSession :: HandleNext@@ Cinematic@@ Camera ( WorldPacket & ) { GetPlayer ( ) -> GetCinematicMgr ( ) -> BeginCinematic ( ) ; }
void WorldSession :: HandleMove@@ TimeSkipp@@ edOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ MOVE _ TIME _ SKIPPED " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; }
void WorldSession :: HandleFe@@ ather@@ Fall@@ Ack ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ FEATHER _ FALL _ ACK " ) ; recvData . rfinish ( ) ; }
void WorldSession :: HandleMove@@ UnRootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; }
void WorldSession :: HandleMove@@ RootAck ( WorldPacket & recvData ) { recvData . rfinish ( ) ; }
void WorldSession :: HandleSetActionBarToggles ( WorldPacket & recvData ) { uint8 actionBar ; recvData >> actionBar ; if ( ! GetPlayer ( ) ) { if ( actionBar != 0 ) TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetActionBarToggles ▁ in ▁ not ▁ logg@@ ed ▁ state ▁ with ▁ value : ▁ % u , ▁ ignored " , uint32 ( actionBar ) ) ; return ; } GetPlayer ( ) -> SetByte@@ Value ( PLAYER_FIELD_@@ BYTES , PLAYER_FIELD_@@ BYTES_@@ OFFSET_@@ ACTION_BAR_@@ TOGG@@ LES , actionBar ) ; }
void WorldSession :: HandlePlayedTime ( WorldPacket & recvData ) { uint8 unk1 ; recvData >> unk1 ; WorldPacket data ( SMSG_PLAYED_TIME , 4 + 4 + 1 ) ; data << uint32 ( _player -> GetTotal@@ PlayedTime ( ) ) ; data << uint32 ( _player -> GetLevel@@ PlayedTime ( ) ) ; data << uint8 ( unk1 ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleInspect@@ Opcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ INSPECT " ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " CMSG _ INSPECT : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; uint32 talent_points = 0x47 ; uint32 guid_size = player -> GetPackGUID ( ) . size ( ) ; WorldPacket data ( SMSG_INSPECT_@@ TALENT , guid_size + 4 + talent_points ) ; data << player -> GetPackGUID ( ) ; if ( GetPlayer ( ) -> CanBeGameMaster ( ) || sWorld -> getIntConfig ( CONFIG_TAL@@ ENTS_@@ INSPECTING ) + ( GetPlayer ( ) -> GetTeamId ( ) == player -> GetTeamId ( ) ) > 1 ) player -> BuildPlayer@@ TalentsInfoData ( & data ) ; else { data << uint32 ( 0 ) ; data << uint8 ( 0 ) ; data << uint8 ( 0 ) ; } player -> BuildEnchan@@ tment@@ sInfoData ( & data ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleInspect@@ HonorStatsOpcode ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) { TC_LOG_DEBUG ( " network " , " MSG _ INSPECT _ HON@@ OR _ STATS : ▁ No ▁ player ▁ found ▁ from ▁ % s " , guid . ToString ( ) . c_str ( ) ) ; return ; } if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; WorldPacket data ( MSG_INSPECT_@@ HONOR@@ _STATS , 8 + 1 + 4 * 4 ) ; data << uint64 ( player -> GetGUID ( ) ) ; data << uint8 ( player -> GetHonor@@ Points ( ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ KILLS ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ TODAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ YES@@ TERDAY_CONTRIBUTION ) ) ; data << uint32 ( player -> GetUInt32Value ( PLAYER_FIELD_@@ LIFE@@ TIME_@@ HONORABLE_@@ KILLS ) ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleWorld@@ Teleport@@ Opcode ( WorldPacket & recvData ) { uint32 time ; uint32 mapid ; float PositionX ; float PositionY ; float PositionZ ; float Orientation ; recvData >> time ; recvData >> mapid ; recvData >> PositionX ; recvData >> PositionY ; recvData >> PositionZ ; recvData >> Orientation ; TC_LOG_DEBUG ( " network " , " WORLD : ▁ Received ▁ CMSG _ WORLD _ TELEPORT " ) ; if ( GetPlayer ( ) -> IsInFlight ( ) ) { TC_LOG_DEBUG ( " network " , " Player ▁ ' % s ' ▁ ( GUID : ▁ % u ) ▁ in ▁ flight , ▁ ignore ▁ worldport ▁ command . " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , GetPlayer ( ) -> GetGUID ( ) . GetCounter ( ) ) ; return ; } TC_LOG_DEBUG ( " network " , " CMSG _ WORLD _ TELEPORT : ▁ Player ▁ = ▁ % s , ▁ Time ▁ = ▁ % u , ▁ map ▁ = ▁ % u , ▁ x ▁ = ▁ % f , ▁ y ▁ = ▁ % f , ▁ z ▁ = ▁ % f , ▁ o ▁ = ▁ % f " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , time , mapid , PositionX , PositionY , PositionZ , Orientation ) ; if ( HasPermission ( rbac :: RBAC_PERM_OPCODE_@@ WORLD_@@ TELEPORT ) ) GetPlayer ( ) -> TeleportTo ( mapid , PositionX , PositionY , PositionZ , Orientation ) ; else SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; }
void WorldSession :: HandleWho@@ isOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " Received ▁ opcode ▁ CMSG _ WHOIS " ) ; std :: string charname ; recvData >> charname ; if ( ! HasPermission ( rbac :: RBAC_PERM_OPCODE_@@ WHOIS ) ) { SendNotification ( LANG_YOU_NOT_HAVE_PERMISSION ) ; return ; } if ( charname . empty ( ) || ! normalizePlayerName ( charname ) ) { SendNotification ( LANG_NEED_@@ CHARACTER_NAME ) ; return ; } Player * player = ObjectAccessor :: FindConnected@@ PlayerByName ( charname ) ; if ( ! player ) { SendNotification ( LANG_PLAYER_@@ NOT_EXI@@ ST_OR_@@ OFFLINE , charname . c_str ( ) ) ; return ; } uint32 accid = player -> GetSession ( ) -> GetAccountId ( ) ; PreparedStatement * stmt = LoginDatabase . GetPreparedStatement ( LOGIN_SE@@ L_ACCOUNT_@@ WHOIS ) ; stmt -> setUInt32 ( 0 , accid ) ; PreparedQueryResult result = LoginDatabase . Query ( stmt ) ; if ( ! result ) { SendNotification ( LANG_ACCOUNT_@@ FOR_PLAYER_@@ NOT_FOUND , charname . c_str ( ) ) ; return ; } Field * fields = result -> Fetch ( ) ; std :: string acc = fields [ 0 ] . GetString ( ) ; if ( acc . empty ( ) ) acc = " Unknown " ; std :: string email = fields [ 1 ] . GetString ( ) ; if ( email . empty ( ) ) email = " Unknown " ; std :: string lastip = fields [ 2 ] . GetString ( ) ; if ( lastip . empty ( ) ) lastip = " Unknown " ; std :: string msg = charname + " ' s ▁ " + " account ▁ is ▁ " + acc + " , ▁ e - mail : ▁ " + email + " , ▁ last ▁ ip : ▁ " + lastip ; WorldPacket data ( SMSG_WHOIS , msg . size ( ) + 1 ) ; data << msg ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " Received ▁ whois ▁ command ▁ from ▁ player ▁ % s ▁ for ▁ character ▁ % s " , GetPlayer ( ) -> GetName ( ) . c_str ( ) , charname . c_str ( ) ) ; }
void WorldSession :: HandleCompla@@ inOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ COMPLA@@ IN " ) ; uint8 spam_type ; ObjectGuid spammer_guid ; uint32 unk1 = 0 ; uint32 unk2 = 0 ; uint32 unk3 = 0 ; uint32 unk4 = 0 ; std :: string description = " " ; recvData >> spam_type ; recvData >> spammer_guid ; switch ( spam_type ) { case 0 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; break ; case 1 : recvData >> unk1 ; recvData >> unk2 ; recvData >> unk3 ; recvData >> unk4 ; recvData >> description ; break ; } WorldPacket data ( SMSG_COMPLA@@ IN_RESULT , 1 ) ; data << uint8 ( 0 ) ; SendPacket ( & data ) ; TC_LOG_DEBUG ( " network " , " REPORT ▁ SPAM : ▁ type ▁ % u , ▁ % s , ▁ unk1 ▁ % u , ▁ unk2 ▁ % u , ▁ unk3 ▁ % u , ▁ unk4 ▁ % u , ▁ message ▁ % s " , spam_type , spammer_guid . ToString ( ) . c_str ( ) , unk1 , unk2 , unk3 , unk4 , description . c_str ( ) ) ; }
void WorldSession :: HandleReal@@ mSplit@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ REAL@@ M _ SPLIT " ) ; uint32 unk ; std :: string split_date = "01/@@ 01/@@ 01" ; recvData >> unk ; WorldPacket data ( SMSG_REAL@@ M_SP@@ LIT , 4 + 4 + split_date . size ( ) + 1 ) ; data << unk ; data << uint32 ( 0x00000000 ) ; data << split_date ; SendPacket ( & data ) ; }
void WorldSession :: HandleFarS@@ ightOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ FAR _ SIGHT " ) ; bool apply ; recvData >> apply ; if ( apply ) { TC_LOG_DEBUG ( " network " , " Added ▁ FarS@@ ight ▁ % s ▁ to ▁ player ▁ % u " , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; if ( WorldObject * target = _player -> GetView@@ point ( ) ) _player -> SetSeer ( target ) ; else TC_LOG_DEBUG ( " network " , " Player ▁ % s ▁ ( % s ) ▁ requests ▁ non - existing ▁ seer ▁ % s " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , _player -> GetGuidValue ( PLAYER_FARSIGHT ) . ToString ( ) . c_str ( ) ) ; } else { TC_LOG_DEBUG ( " network " , " Player ▁ % u ▁ set ▁ vision ▁ to ▁ self " , _player -> GetGUID ( ) . GetCounter ( ) ) ; _player -> SetSeer ( _player ) ; } GetPlayer ( ) -> UpdateVisibility@@ ForPlayer ( ) ; }
void WorldSession :: HandleSetTitle@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ SET _ TITLE " ) ; int32 title ; recvData >> title ; if ( title > 0 && title < MAX_TIT@@ LE_INDEX ) { if ( ! GetPlayer ( ) -> HasTitle ( title ) ) return ; } else title = 0 ; GetPlayer ( ) -> SetUInt32Value ( PLAYER_@@ CHOS@@ EN_TITLE , title ) ; }
void WorldSession :: HandleTimeSync@@ Resp ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " CMSG _ TIME _ SYNC _ RESP " ) ; uint32 counter , clientTicks ; recvData >> counter >> clientTicks ; if ( counter != _player -> m_timeSync@@ Counter - 1 ) TC_LOG_DEBUG ( " network " , " Wron@@ g ▁ time ▁ sync ▁ counter ▁ from ▁ player ▁ % s ▁ ( cheat@@ er ? ) " , _player -> GetName ( ) . c_str ( ) ) ; TC_LOG_DEBUG ( " network " , " Time ▁ sync ▁ received : ▁ counter ▁ % u , ▁ client ▁ ticks ▁ % u , ▁ time ▁ since ▁ last ▁ sync ▁ % u " , counter , clientTicks , clientTicks - _player -> m_timeSyncClient ) ; uint32 ourTicks = clientTicks + ( GameTime :: GetGame@@ TimeMS ( ) - _player -> m_timeSync@@ Server ) ; TC_LOG_DEBUG ( " network " , " Our ▁ ticks : ▁ % u , ▁ diff ▁ % u , ▁ latency ▁ % u " , ourTicks , ourTicks - clientTicks , GetLatency ( ) ) ; _player -> m_timeSyncClient = clientTicks ; }
void WorldSession :: HandleResetInstan@@ cesOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ RESET _ INSTANCES " ) ; if ( Group * group = _player -> GetGroup ( ) ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) group -> ResetInstances ( INSTANCE_RESET_ALL , false , _player ) ; } else _player -> ResetInstances ( INSTANCE_RESET_ALL , false ) ; }
void WorldSession :: HandleSetDungeonDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ DUNGEON _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_DUNGEON_@@ DIFFICULTY ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } if ( Difficulty ( mode ) == _player -> GetDungeonDifficulty ( ) ) return ; Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ player ▁ is ▁ inside ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsNon@@ RaidDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetDungeonDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ group ▁ member ▁ ( Name : ▁ % s , ▁ GUID : ▁ % u ) ▁ is ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) , groupGuy -> GetName ( ) . c_str ( ) , groupGuy -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false , _player ) ; group -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , false ) ; _player -> SetDungeonDifficulty ( Difficulty ( mode ) ) ; } }
void WorldSession :: HandleSetRaidDifficultyOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " MSG _ SET _ RAID _ DIFFICULTY " ) ; uint32 mode ; recvData >> mode ; if ( mode >= MAX_RAID_@@ DIFFICULTY ) { TC_LOG_ERROR ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ sent ▁ an ▁ invalid ▁ instance ▁ mode ▁ % d ! " , _player -> GetGUID ( ) . GetCounter ( ) , mode ) ; return ; } Map * map = _player -> FindMap ( ) ; if ( map && map -> IsDungeon ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( Difficulty ( mode ) == _player -> GetRaidDifficulty ( ) ) return ; Group * group = _player -> GetGroup ( ) ; if ( group ) { if ( group -> IsLeader ( _player -> GetGUID ( ) ) ) { for ( GroupReference * itr = group -> GetFirstMember ( ) ; itr != NULL ; itr = itr -> next ( ) ) { Player * groupGuy = itr -> GetSource ( ) ; if ( ! groupGuy ) continue ; if ( ! groupGuy -> IsInMap ( groupGuy ) ) return ; if ( groupGuy -> GetMap ( ) -> IsRaid ( ) ) { TC_LOG_DEBUG ( " network " , " WorldSession : : HandleSetRaidDifficultyOpcode : ▁ player ▁ % d ▁ tried ▁ to ▁ reset ▁ the ▁ instance ▁ while ▁ inside ! " , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } } group -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true , _player ) ; group -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } } else { _player -> ResetInstances ( INSTANCE_RESET_CHANGE_DIFFICULTY , true ) ; _player -> SetRaidDifficulty ( Difficulty ( mode ) ) ; } }
void WorldSession :: HandleCancel@@ Mount@@ AuraOpcode ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ CANCEL _ MOUN@@ T _ AURA " ) ; if ( ! _player -> IsMounted ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_CHAR_@@ NON_@@ MOUNTED ) ; return ; } if ( _player -> IsInFlight ( ) ) { ChatHandler ( this ) . SendSysMessage ( LANG_YOU_@@ IN_F@@ LIGHT ) ; return ; } _player -> RemoveAurasByType ( SPELL_AURA_@@ MOUNTED ) ; }
void WorldSession :: HandleMove@@ SetCan@@ Fly@@ AckOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ MOVE _ SET _ CAN _ FLY _ ACK " ) ; ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; recvData . read_skip < uint32 > ( ) ; MovementInfo movementInfo ; movementInfo . guid = guid ; ReadMovementInfo ( recvData , & movementInfo ) ; recvData . read_skip < float > ( ) ; _player -> m_unit@@ MovedBy@@ Me -> m_movementInfo . flags = movementInfo . GetMovement@@ Flags ( ) ; }
void WorldSession :: HandleSetTax@@ iBenchmark@@ Opcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ SET _ TAX@@ I _ BENCHMARK _ MODE " ) ; uint8 mode ; recvData >> mode ; mode ? _player -> SetFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) : _player -> RemoveFlag ( PLAYER_FLAGS , PLAYER_FLAGS_TAXI_BENCHMARK ) ; TC_LOG_DEBUG ( " network " , " Client ▁ used ▁ \ " / timete@@ st ▁ % d \ " ▁ command " , mode ) ; }
void WorldSession :: HandleQuery@@ InspectAchievements ( WorldPacket & recvData ) { ObjectGuid guid ; recvData >> guid . ReadAsPacked ( ) ; TC_LOG_DEBUG ( " network " , " CMSG _ QUERY _ INSPECT _ ACHIEVE@@ MENTS ▁ [ % s ] ▁ Insp@@ ected ▁ Player ▁ [ % s ] " , _player -> GetGUID ( ) . ToString ( ) . c_str ( ) , guid . ToString ( ) . c_str ( ) ) ; Player * player = ObjectAccessor :: GetPlayer ( * _player , guid ) ; if ( ! player ) return ; if ( ! GetPlayer ( ) -> IsWithinDistInMap ( player , INSPECT_DISTANCE , false ) ) return ; if ( GetPlayer ( ) -> IsValidAttackTarget ( player ) ) return ; player -> SendRespon@@ dInspectAchievements ( _player ) ; }
void WorldSession :: HandleWorld@@ StateUI@@ Timer@@ Update ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ WORLD _ STATE _ UI _ TIMER _ UPDATE " ) ; WorldPacket data ( SMSG_WORLD@@ _STATE_UI_@@ TIMER_@@ UPDATE , 4 ) ; data << uint32 ( time ( NULL ) ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleRead@@ yFor@@ AccountDataTimes ( WorldPacket & ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ READY _ FOR _ ACCOUNT _ DATA _ TIME@@ S " ) ; SendAccountDataTimes ( GLOBAL_@@ CACHE_@@ MASK ) ; }
void WorldSession :: SendSetPhaseShift ( uint32 PhaseShift ) { WorldPacket data ( SMSG@@ _SET_PHASE_@@ SHIFT , 4 ) ; data << uint32 ( PhaseShift ) ; SendPacket ( & data ) ; }
void WorldSession :: HandleAreaSpiritHealerQueryOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUERY " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) sBattlegroundMgr -> SendAreaSpiritHealerQueryOpcode ( _player , bg , guid ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> SendAreaSpiritHealerQueryOpcode ( _player , guid ) ; }
void WorldSession :: HandleAreaSpiritHealer@@ QueueOpcode ( WorldPacket & recvData ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ AREA _ SPIRIT _ HEALER _ QUEUE " ) ; Battleground * bg = _player -> GetBattleground ( ) ; ObjectGuid guid ; recvData >> guid ; Creature * unit = GetPlayer ( ) -> GetMap ( ) -> GetCreature ( guid ) ; if ( ! unit ) return ; if ( ! unit -> IsSpiritService ( ) ) return ; if ( bg ) bg -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) bf -> AddPlayerToResurrectQueue ( guid , _player -> GetGUID ( ) ) ; }
void WorldSession :: HandleHearth@@ AndResur@@ rect ( WorldPacket & ) { if ( _player -> IsInFlight ( ) ) return ; if ( Battlefield * bf = sBattlefieldMgr -> GetBattlefieldToZoneId ( _player -> GetZoneId ( ) ) ) { bf -> PlayerAskTo@@ Leave ( _player ) ; return ; } AreaTableEntry const * atEntry = sAreaTableStore . LookupEntry ( _player -> GetArea@@ Id ( ) ) ; if ( ! atEntry || ! ( atEntry -> flags & AREA_FLAG_WINTERGRASP_@@ 2 ) ) return ; _player -> BuildPlayerRepop ( ) ; _player -> ResurrectPlayer ( 1.0f ) ; _player -> TeleportTo ( _player -> m_homebind@@ MapId , _player -> m_homebind@@ X , _player -> m_homebind@@ Y , _player -> m_homebind@@ Z , _player -> GetOrientation ( ) ) ; }
void WorldSession :: HandleInstanceLockResponse ( WorldPacket & recvPacket ) { uint8 accept ; recvPacket >> accept ; if ( ! _player -> HasPendingBind ( ) ) { TC_LOG_INFO ( " network " , " InstanceLockResponse : ▁ Player ▁ % s ▁ ( guid ▁ % u ) ▁ tried ▁ to ▁ bind ▁ himself / teleport ▁ to ▁ graveyard ▁ without ▁ a ▁ pending ▁ bind ! " , _player -> GetName ( ) . c_str ( ) , _player -> GetGUID ( ) . GetCounter ( ) ) ; return ; } if ( accept ) _player -> BindToInstance ( ) ; else _player -> RepopAtGraveyard ( ) ; _player -> SetPendingBind ( 0 , 0 ) ; }
void WorldSession :: HandleUpdate@@ MissileTrajectory ( WorldPacket & recvPacket ) { TC_LOG_DEBUG ( " network " , " WORLD : ▁ CMSG _ UPDATE _ MISSI@@ LE _ TRA@@ JECTORY " ) ; ObjectGuid guid ; uint32 spellId ; float elevation , speed ; float curX , curY , curZ ; float targetX , targetY , targetZ ; uint8 moveStop ; recvPacket >> guid >> spellId >> elevation >> speed ; recvPacket >> curX >> curY >> curZ ; recvPacket >> targetX >> targetY >> targetZ ; recvPacket >> moveStop ; Unit * caster = ObjectAccessor :: GetUnit ( * _player , guid ) ; Spell * spell = caster ? caster -> GetCurrentSpell ( CURRENT_@@ GENERIC_SPELL ) : NULL ; if ( ! spell || spell -> m_spellInfo -> Id != spellId || ! spell -> m_targets . HasDst ( ) || ! spell -> m_targets . HasSrc ( ) ) { recvPacket . rfinish ( ) ; return ; } Position pos = * spell -> m_targets . GetSrc@@ Pos ( ) ; pos . Relocate ( curX , curY , curZ ) ; spell -> m_targets . ModSrc ( pos ) ; pos = * spell -> m_targets . GetDst@@ Pos ( ) ; pos . Relocate ( targetX , targetY , targetZ ) ; spell -> m_targets . ModDst ( pos ) ; spell -> m_targets . SetEle@@ vation ( elevation ) ; spell -> m_targets . SetSpeed ( speed ) ; if ( moveStop ) { uint32 opcode ; recvPacket >> opcode ; recvPacket . SetOpcode ( opcode ) ; HandleMovement@@ Opcodes ( recvPacket ) ; } }
