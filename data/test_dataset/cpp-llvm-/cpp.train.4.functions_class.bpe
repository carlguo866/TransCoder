void QgsProxyProgressTask :: finalize ( bool result ) { mResult = result ; mNotFinishedWaitCondition . wakeAll ( ) ; }
bool QgsProxyProgressTask :: run ( ) { mNotFinishedMutex . lock ( ) ; mNotFinishedWaitCondition . wait ( & mNotFinishedMutex ) ; mNotFinishedMutex . unlock ( ) ; return mResult ; }
void QgsProxyProgressTask :: setProxyProgress ( double progress ) { QMeta@@ Object :: invokeMethod ( this , " setProgress " , Qt :: AutoConnection , Q_ARG ( double , progress ) ) ; }
QgsScopedProxyProgressTask :: QgsScopedProxyProgressTask ( const QString & description ) : mTask ( new QgsProxyProgressTask ( description ) ) { QgsApplication :: task@@ Manager ( ) -> addTask ( mTask ) ; }
QgsScopedProxyProgressTask :: ~ QgsScopedProxyProgressTask ( ) { mTask -> finalize ( true ) ; }
void QgsScopedProxyProgressTask :: setProgress ( double progress ) { mTask -> setProxyProgress ( progress ) ; }
ACE_Log_Msg_IPC :: ~ ACE_Log_Msg_IPC ( void ) { ( void ) this -> close ( ) ; }
int ACE_Log_Msg_IPC :: open ( const ACE_TCHAR * logger_key ) { ACE_LOG_MSG_IPC_@@ CONNECTOR con ; return con . connect ( this -> message_queue_ , ACE_LOG_MSG_IPC_@@ ADDR ( logger_key ) ) ; }
int ACE_Log_Msg_IPC :: reset ( void ) { if ( this -> message_queue_ . get_handle ( ) != ACE_INVALID_@@ HANDLE ) { return this -> close ( ) ; } return 0 ; }
int ACE_Log_Msg_IPC :: close ( void ) { return this -> message_queue_ . close ( ) ; }
ssize_t ACE_Log_Msg_IPC :: log ( ACE_Log_Record & log_record ) { size_t const max_payload_size = 4 + 4 + 12 + 4 + 4 + ( log_record . msg_data_len ( ) * ACE_OutputCDR :: wchar_max@@ bytes ( ) ) + log_record . msg_data_len ( ) + ACE_CDR :: MAX_ALIGNMENT ; ACE_OutputCDR payload ( max_payload_size ) ; if ( ! ( payload << log_record ) ) return - 1 ; ACE_CDR :: ULong const length = ACE_Utils :: truncate_cast < ACE_CDR :: ULong > ( payload . total_length ( ) ) ; ACE_OutputCDR header ( ACE_CDR :: MAX_ALIGNMENT + 8 ) ; if ( ! ( header << ACE_OutputCDR :: from_boolean ( ACE_CD@@ R_BY@@ TE_ORDER ) ) ) return - 1 ; if ( ! ( header << ACE_CDR :: ULong ( length ) ) ) return - 1 ; iovec iov [ 2 ] ; iov [ 0 ] . iov_base = header . begin ( ) -> rd_ptr ( ) ; iov [ 0 ] . iov_len = 8 ; iov [ 1 ] . iov_base = payload . begin ( ) -> rd_ptr ( ) ; iov [ 1 ] . iov_len = length ; ACE_HAS@@ _STREAM_@@ LOG_MSG_@@ IPC == 1 ) ACE_Str_Buf header_msg ( static_cast < void * > ( header . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( 8 ) ) ; ACE_Str_Buf payload_msg ( static_cast < void * > ( payload . begin ( ) -> rd_ptr ( ) ) , static_cast < int > ( length ) ) ; return this -> message_queue_ . send ( & header_msg , & payload_msg , static_cast < int > ( log_record . priority ( ) ) , MSG_BAN@@ D ) ; return this -> message_queue_ . sendv_n ( iov , 2 ) ; }
Delete :: Delete ( const XmlNode & xmlNode ) : m_objectsHasBeenSet ( false ) , m_quiet ( false ) , m_quietHasBeenSet ( false ) { * this = xmlNode ; }
RDListLogs :: RDListLogs ( QString * logname , RDLogFilter :: FilterMode mode , QWidget * parent ) : RDDialog ( parent ) { list_logname = logname ; setMinimum@@ Size ( sizeHint ( ) ) ; setWindowTitle ( tr ( " Select ▁ Log " ) ) ; list_filter_widget = new RDLogFilter ( mode , this ) ; connect ( list_filter_widget , SIGNAL ( filterChanged ( const QString & ) ) , this , SLOT ( filterChangedData ( const QString & ) ) ) ; list_log_list = new Q3ListView ( this ) ; list_log_list -> setAll@@ ColumnsShow@@ Focus ( true ) ; list_log_list -> setItem@@ Margin ( 5 ) ; list_log_list -> setSelection@@ Mode ( Q3ListView :: Single ) ; connect ( list_log_list , SIGNAL ( double@@ Clicked ( Q3ListViewItem * , const QPoint & , int ) ) , this , SLOT ( doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) ) ) ; list_log_list -> addColumn ( tr ( " Name " ) ) ; list_log_list -> setColumnAlignment ( 0 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Description " ) ) ; list_log_list -> setColumnAlignment ( 1 , Qt :: AlignLeft ) ; list_log_list -> addColumn ( tr ( " Service " ) ) ; list_log_list -> setColumnAlignment ( 2 , Qt :: AlignLeft ) ; list_ok_button = new QPushButton ( this ) ; list_ok_button -> setFont ( buttonFont ( ) ) ; list_ok_button -> setText ( tr ( " OK " ) ) ; connect ( list_ok_button , SIGNAL ( clicked ( ) ) , this , SLOT ( okButtonData ( ) ) ) ; list_cancel_button = new QPushButton ( this ) ; list_cancel_button -> setFont ( buttonFont ( ) ) ; list_cancel_button -> setText ( tr ( " Cancel " ) ) ; list_cancel_button -> setDefault ( true ) ; connect ( list_cancel_button , SIGNAL ( clicked ( ) ) , this , SLOT ( cancelButtonData ( ) ) ) ; RefreshList ( ) ; }
void RDListLogs :: close@@ Event ( QClose@@ Event * e ) { done ( 1 ) ; }
void RDListLogs :: filterChangedData ( const QString & where_@@ sql ) { RefreshList ( ) ; }
void RDListLogs :: doubleClickedData ( Q3ListViewItem * , const QPoint & , int ) { okButtonData ( ) ; }
void RDListLogs :: okButtonData ( ) { Q3ListViewItem * item = list_log_list -> selectedItem ( ) ; if ( item == NULL ) { return ; } * list_logname = item -> text ( 0 ) ; done ( 0 ) ; }
void RDListLogs :: cancelButtonData ( ) { done ( 1 ) ; }
void RDListLogs :: resizeEvent ( QResizeEvent * e ) { list_filter_widget -> setGeometry ( 10 , 10 , size ( ) . width ( ) - 10 , list_filter_widget -> sizeHint ( ) . height ( ) ) ; list_log_list -> setGeometry ( 10 , list_filter_widget -> sizeHint ( ) . height ( ) , size ( ) . width ( ) - 20 , size ( ) . height ( ) - list_filter_widget -> sizeHint ( ) . height ( ) - 70 ) ; list_ok_button -> setGeometry ( size ( ) . width ( ) - 190 , size ( ) . height ( ) - 60 , 80 , 50 ) ; list_cancel_button -> setGeometry ( size ( ) . width ( ) - 90 , size ( ) . height ( ) - 60 , 80 , 50 ) ; }
void RDListLogs :: RefreshList ( ) { RDSqlQuery * q ; QString sql ; Q3ListViewItem * l ; Q3ListViewItem * view_item = NULL ; QDate current_date = QDate :: currentDate ( ) ; list_log_list -> clear ( ) ; sql = QString ( " select ▁ NAME , DESCRIPTION , SERVICE ▁ from ▁ LOGS ▁ " ) + " where ▁ ( TYPE = 0 ) & & ( LOG _ EXISTS = \ " Y \ " ) & & " + " ( ( START _ DATE < = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( START _ DATE = \ " 0000 - 00 - 00 \ " ) | | " + " ( START _ DATE ▁ is ▁ null ) ) & & " + " ( ( END _ DATE > = \ " " + current_date . toString ( " yyyy - MM - dd " ) + " \ " ) | | " + " ( END _ DATE = \ " 0000 - 00 - 00 \ " ) | | " + " ( END _ DATE ▁ is ▁ null ) ) " + list_filter_widget -> where@@ Sql ( ) ; q = new RDSqlQuery ( sql ) ; while ( q -> next ( ) ) { l = new Q3ListViewItem ( list_log_list ) ; l -> setText ( 0 , q -> value ( 0 ) . toString ( ) ) ; l -> setText ( 1 , q -> value ( 1 ) . toString ( ) ) ; l -> setText ( 2 , q -> value ( 2 ) . toString ( ) ) ; if ( l -> text ( 0 ) == * list_logname ) { view_item = l ; } } delete q ; if ( view_item != NULL ) { list_log_list -> setCurrentItem ( view_item ) ; list_log_list -> ensureItem@@ Visible ( view_item ) ; } }
void CDV@@ DSubtitleTagMicro@@ DVD :: ConvertLine ( CDVDOverlayText * pOverlay , const char * line , int len ) { CStdString strUTF8 ; strUTF8 . assign ( line , len ) ; m_flag [ FLAG_BOLD ] = 0 ; m_flag [ FLAG_ITALIC ] = 0 ; m_flag [ FLAG_COLOR ] = 0 ; int machine_status = 1 ; size_t pos = 0 ; while ( machine_status > 0 ) { if ( machine_status == 1 ) { if ( strUTF8 [ pos ] == ' { ' ) { size_t pos2 , pos3 ; if ( ( ( pos2 = strUTF8 . find ( ' : ' , pos ) ) != CStdString :: npos ) && ( ( pos3 = strUTF8 . find ( ' } ' , pos2 ) ) != CStdString :: npos ) ) { CStdString tagName = strUTF8 . substr ( pos + 1 , pos2 - pos - 1 ) ; CStdString tagValue = strUTF8 . substr ( pos2 + 1 , pos3 - pos2 - 1 ) ; StringUtils :: ToLower ( tagValue ) ; strUTF8 . erase ( pos , pos3 - pos + 1 ) ; if ( ( tagName == " Y " ) || ( tagName == " y " ) ) { if ( ( tagValue == " b " ) && ( m_flag [ FLAG_BOLD ] == 0 ) ) { m_flag [ FLAG_BOLD ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ B ] " ) ; pos += 3 ; } else if ( ( tagValue == " i " ) && ( m_flag [ FLAG_ITALIC ] == 0 ) ) { m_flag [ FLAG_ITALIC ] = ( tagName == " Y " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , " [ I ] " ) ; pos += 3 ; } } else if ( ( tagName == " C " ) || ( tagName == " c " ) ) { if ( ( tagValue [ 0 ] == ' $ ' ) && ( tagValue . size ( ) == 7 ) ) { bool bHex = true ; for ( int i = 1 ; i < 7 ; i ++ ) { char temp = tagValue [ i ] ; if ( ! ( ( '0' <= temp && temp <= '9' ) || ( ' a ' <= temp && temp <= ' f ' ) || ( ' A ' <= temp && temp <= ' F ' ) ) ) { bHex = false ; break ; } } if ( bHex && ( m_flag [ FLAG_COLOR ] == 0 ) ) { CStdString tempColorTag = " [ COLOR ▁ " ; tempColorTag += " FF " ; tempColorTag += tagValue . substr ( 1 , 6 ) ; tempColorTag += " ] " ; m_flag [ FLAG_COLOR ] = ( tagName == " C " ) ? TAG_ALL_LINE : TAG_ONE_LINE ; strUTF8 . insert ( pos , tempColorTag ) ; pos += tempColorTag . length ( ) ; } } } } else machine_status = 2 ; } else if ( strUTF8 [ pos ] == ' / ' ) { if ( m_flag [ FLAG_ITALIC ] == 0 ) { m_flag [ FLAG_ITALIC ] = TAG_ONE_LINE ; strUTF8 . replace ( pos , 1 , " [ I ] " ) ; pos += 3 ; } else strUTF8 . erase ( pos , 1 ) ; } else machine_status = 2 ; } else if ( machine_status == 2 ) { size_t pos4 ; if ( ( pos4 = strUTF8 . find ( ' | ' , pos ) ) != CStdString :: npos ) { pos = pos4 ; if ( m_flag [ FLAG_BOLD ] == TAG_ONE_LINE ) { m_flag [ FLAG_BOLD ] = 0 ; strUTF8 . insert ( pos , " [ / B ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_ITALIC ] == TAG_ONE_LINE ) { m_flag [ FLAG_ITALIC ] = 0 ; strUTF8 . insert ( pos , " [ / I ] " ) ; pos += 4 ; } if ( m_flag [ FLAG_COLOR ] == TAG_ONE_LINE ) { m_flag [ FLAG_COLOR ] = 0 ; strUTF8 . insert ( pos , " [ / COLOR ] " ) ; pos += 8 ; } strUTF8 . replace ( pos , 1 , " [ CR ] " ) ; pos += 4 ; machine_status = 1 ; } else { if ( m_flag [ FLAG_BOLD ] != 0 ) strUTF8 . append ( " [ / B ] " ) ; if ( m_flag [ FLAG_ITALIC ] != 0 ) strUTF8 . append ( " [ / I ] " ) ; if ( m_flag [ FLAG_COLOR ] != 0 ) strUTF8 . append ( " [ / COLOR ] " ) ; machine_status = 0 ; } } } if ( strUTF8 . empty ( ) ) return ; if ( strUTF8 [ strUTF8 . size ( ) - 1 ] == ' \n ' ) strUTF8 . erase ( strUTF8 . size ( ) - 1 ) ; pOverlay -> AddElement ( new CDVDOverlayText :: CElementText ( strUTF8 . c_str ( ) ) ) ; }
VariableDeltaSerializer :: VariableDeltaSerializer ( ) { didComparisonThisTick = false ; }
VariableDeltaSerializer :: ~ VariableDeltaSerializer ( ) { RemoveRemoteSystemVariableHistory ( ) ; }
VariableDeltaSerializer :: SerializationContext :: SerializationContext ( ) { variableHistoryIdentical = 0 ; variableHistoryUnique = 0 ; }
void VariableDeltaSerializer :: OnMessage@@ Receipt ( RakNetGUID guid , uint32_t receiptId , bool messageArrived ) { if ( messageArrived ) FreeVarsAssociatedWithReceipt ( guid , receiptId ) ; else DirtyAndFreeVarsAssociatedWithReceipt ( guid , receiptId ) ; }
void VariableDeltaSerializer :: BeginUnreli@@ ableAc@@ ked@@ Serialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream , uint32_t _sendReceipt ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> sendReceipt = _sendReceipt ; context -> changedVariables = AllocChangedVariablesList ( ) ; context -> newSystemSend = false ; context -> serializationMode = UNRELIABLE_WITH_ACK_RECEIPT ; }
void VariableDeltaSerializer :: BeginUniqueSerialize ( SerializationContext * context , RakNetGUID _guid , BitStream * _bitStream ) { RakAssert ( _guid != UNASSIGNED_RAKNET_GUID ) ; context -> anyVariablesWritten = false ; context -> guid = _guid ; context -> bitStream = _bitStream ; if ( context -> variableHistoryUnique == 0 ) context -> variableHistoryUnique = StartVariableHistoryWrite ( _guid ) ; context -> variableHistory = context -> variableHistoryUnique ; context -> newSystemSend = false ; context -> serializationMode = RELIABLE ; }
void VariableDeltaSerializer :: BeginIdentical@@ Serialize ( SerializationContext * context , bool _isFirstSendToRemoteSystem , BitStream * _bitStream ) { context -> anyVariablesWritten = false ; context -> guid = UNASSIGNED_RAKNET_GUID ; context -> bitStream = _bitStream ; context -> serializationMode = RELIABLE ; if ( context -> variableHistoryIdentical == 0 ) context -> variableHistoryIdentical = StartVariableHistoryWrite ( UNASSIGNED_RAKNET_GUID ) ; context -> variableHistory = context -> variableHistoryIdentical ; context -> newSystemSend = _isFirstSendToRemoteSystem ; }
void VariableDeltaSerializer :: EndSerialize ( SerializationContext * context ) { if ( context -> serializationMode == UNRELIABLE_WITH_ACK_RECEIPT ) { if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; FreeChangedVariablesList ( context -> changedVariables ) ; return ; } StoreChangedVariablesList ( context -> variableHistory , context -> changedVariables , context -> sendReceipt ) ; } else { if ( context -> variableHistoryIdentical ) { if ( didComparisonThisTick == false ) { didComparisonThisTick = true ; identicalSerializationBs . Reset ( ) ; if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } identicalSerializationBs . Write ( context -> bitStream ) ; context -> bitStream -> ResetReadPointer ( ) ; } else { context -> bitStream -> Write ( & identicalSerializationBs ) ; identicalSerializationBs . ResetReadPointer ( ) ; } } else if ( context -> anyVariablesWritten == false ) { context -> bitStream -> Reset ( ) ; return ; } } }
void VariableDeltaSerializer :: BeginDeserialize ( DeserializationContext * context , BitStream * _bitStream ) { context -> bitStream = _bitStream ; }
void VariableDeltaSerializer :: EndDeserialize ( DeserializationContext * context ) { ( void ) context ; }
void VariableDeltaSerializer :: AddRemoteSystemVariableHistory ( RakNetGUID guid ) { ( void ) guid ; }
void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; remoteSystemVariableHistoryList . RemoveAt@@ IndexFast ( idx ) ; return ; } }
int RakNet :: VariableDeltaSerializer :: UpdatedVariables@@ ListPtr@@ Comp ( const uint32_t & key , ChangedVariablesList * const & data ) { if ( key < data -> sendReceipt ) return - 1 ; if ( key == data -> sendReceipt ) return 0 ; return 1 ; }
void VariableDeltaSerializer :: FreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } }
void VariableDeltaSerializer :: DirtyAndFreeVarsAssociatedWithReceipt ( RakNetGUID guid , uint32_t receiptId ) { unsigned int idx , idx2 ; idx = GetVarsWrittenPerRemoteSystemListIndex ( guid ) ; if ( idx == ( unsigned int ) - 1 ) return ; RemoteSystemVariableHistory * vprs = remoteSystemVariableHistoryList [ idx ] ; bool objectExists ; idx2 = vprs -> updatedVariablesHistory . GetIndexFromKey ( receiptId , & objectExists ) ; if ( objectExists ) { vprs -> variableListDeltaTracker . FlagDirty@@ FromBitArray ( vprs -> updatedVariablesHistory [ idx2 ] -> bitField ) ; FreeChangedVariablesList ( vprs -> updatedVariablesHistory [ idx2 ] ) ; vprs -> updatedVariablesHistory . RemoveAtIndex ( idx2 ) ; } }
unsigned int VariableDeltaSerializer :: GetVarsWrittenPerRemoteSystemListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) return idx ; } return ( unsigned int ) - 1 ; }
void VariableDeltaSerializer :: RemoveRemoteSystemVariableHistory ( void ) { unsigned int idx , idx2 ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { for ( idx2 = 0 ; idx2 < remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory . Size ( ) ; idx2 ++ ) { FreeChangedVariablesList ( remoteSystemVariableHistoryList [ idx ] -> updatedVariablesHistory [ idx2 ] ) ; } delete remoteSystemVariableHistoryList [ idx ] ; } remoteSystemVariableHistoryList . Clear ( false , _FILE_AND_LINE_ ) ; }
VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: GetRemoteSystemVariableHistory ( RakNetGUID guid ) { unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; return remoteSystemVariableHistoryList [ rshli ] ; }
VariableDeltaSerializer :: ChangedVariablesList * VariableDeltaSerializer :: AllocChangedVariablesList ( void ) { VariableDeltaSerializer :: ChangedVariablesList * p = updatedVariablesMemoryPool . Allocate ( _FILE_AND_LINE_ ) ; p -> bitWrite@@ Index = 0 ; p -> bitField [ 0 ] = 0 ; return p ; }
void VariableDeltaSerializer :: FreeChangedVariablesList ( ChangedVariablesList * changedVariables ) { updatedVariablesMemoryPool . Release ( changedVariables , _FILE_AND_LINE_ ) ; }
void VariableDeltaSerializer :: StoreChangedVariablesList ( RemoteSystemVariableHistory * variableHistory , ChangedVariablesList * changedVariables , uint32_t sendReceipt ) { changedVariables -> sendReceipt = sendReceipt ; variableHistory -> updatedVariablesHistory . Insert ( changedVariables -> sendReceipt , changedVariables , true , _FILE_AND_LINE_ ) ; }
VariableDeltaSerializer :: RemoteSystemVariableHistory * VariableDeltaSerializer :: StartVariableHistoryWrite ( RakNetGUID guid ) { RemoteSystemVariableHistory * variableHistory ; unsigned int rshli = GetRemoteSystemHistoryListIndex ( guid ) ; if ( rshli == ( unsigned int ) - 1 ) { variableHistory = new RemoteSystemVariableHistory ; variableHistory -> guid = guid ; remoteSystemVariableHistoryList . Push ( variableHistory , _FILE_AND_LINE_ ) ; } else { variableHistory = remoteSystemVariableHistoryList [ rshli ] ; } variableHistory -> variableListDeltaTracker . StartWrite ( ) ; return variableHistory ; }
unsigned int VariableDeltaSerializer :: GetRemoteSystemHistoryListIndex ( RakNetGUID guid ) { unsigned int idx ; for ( idx = 0 ; idx < remoteSystemVariableHistoryList . Size ( ) ; idx ++ ) { if ( remoteSystemVariableHistoryList [ idx ] -> guid == guid ) { return idx ; } } return ( unsigned int ) - 1 ; }
void VariableDeltaSerializer :: OnPre@@ Serialize@@ Tick ( void ) { didComparisonThisTick = false ; }
PythonScriptController :: PythonScriptController ( ) : ScriptController ( ) , m_filename ( initData ( & m_filename , " filename " , " Python ▁ script ▁ filename " ) ) , m_classname ( initData ( & m_classname , " classname " , " Python ▁ class ▁ implemented ▁ in ▁ the ▁ script ▁ to ▁ instanci@@ ate ▁ for ▁ the ▁ controller " ) ) , m_variables ( initData ( & m_variables , " variables " , " Array ▁ of ▁ string ▁ variables ▁ ( equiv@@ alent ▁ to ▁ a ▁ c - like ▁ argv ) " ) ) , m_timingEnabled ( initData ( & m_timingEnabled , true , " timingEnabled " , " Set ▁ this ▁ attribute ▁ to ▁ true ▁ or ▁ false ▁ to ▁ activate / deactivate ▁ the ▁ gather@@ ing " " ▁ of ▁ timing ▁ statistics ▁ on ▁ the ▁ python ▁ execution ▁ time . ▁ Default ▁ value ▁ is ▁ set " " to ▁ true . " ) ) , m_doAutoReload ( initData ( & m_doAutoReload , false , " aut@@ oreload " , " Automatic@@ ally ▁ reload ▁ the ▁ file ▁ when ▁ the ▁ source ▁ code ▁ is ▁ changed . ▁ " " Default ▁ value ▁ is ▁ set ▁ to ▁ false " ) ) , m_ScriptControllerClass ( nullptr ) , m_ScriptControllerInstance ( nullptr ) { m_filelistener = new MyFileEventListener ( this ) ; }
PythonScriptController :: ~ PythonScriptController ( ) { if ( m_filelistener ) { FileMonitor :: removeListener ( m_filelistener ) ; delete m_filelistener ; } }
void PythonScriptController :: setInstance ( PyObject * instance ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_ScriptControllerInstance ) { Py_DECREF ( m_ScriptControllerInstance ) ; } m_ScriptControllerInstance = instance ; m_ScriptControllerClass = ( PyObject * ) instance -> ob_type ; Py_INCRE@@ F ( instance ) ; refreshBinding ( ) ; }
void PythonScriptController :: refreshBinding ( ) { BIND_OBJECT_METHOD ( onLoaded ) BIND_OBJECT_METHOD ( createGraph ) BIND_OBJECT_METHOD ( initGraph ) BIND_OBJECT_METHOD ( bwdInitGraph ) BIND_OBJECT_METHOD ( onKeyPressed ) BIND_OBJECT_METHOD ( onKeyReleased ) BIND_OBJECT_METHOD ( onMouseMove ) BIND_OBJECT_METHOD ( onMouseButtonLeft ) BIND_OBJECT_METHOD ( onMouseButtonRight ) BIND_OBJECT_METHOD ( onMouseButtonMiddle ) BIND_OBJECT_METHOD ( onMouseWheel ) BIND_OBJECT_METHOD ( onBeginAnimationStep ) BIND_OBJECT_METHOD ( onEndAnimationStep ) BIND_OBJECT_METHOD ( storeResetState ) BIND_OBJECT_METHOD ( reset ) BIND_OBJECT_METHOD ( cleanup ) BIND_OBJECT_METHOD ( onGUIEvent ) BIND_OBJECT_METHOD ( onScriptEvent ) BIND_OBJECT_METHOD ( draw ) BIND_OBJECT_METHOD ( onIdle ) }
bool PythonScriptController :: isDerived@@ From ( const std :: string & name , const std :: string & module ) { PythonEnvironment :: gil lock ( __func__ ) ; PyObject * moduleDict = PyModule_GetDict ( PyImport_AddModule ( module . c_str ( ) ) ) ; PyObject * controllerClass = PyDict_GetItemString ( moduleDict , name . c_str ( ) ) ; return 1 == PyObject_Is@@ Instance ( m_ScriptControllerInstance , controllerClass ) ; }
void PythonScriptController :: loadScript ( ) { PythonEnvironment :: gil lock ( __func__ ) ; if ( m_doAutoReload . getValue ( ) ) { FileMonitor :: addFile ( m_filename . getFullPath ( ) , m_filelistener ) ; } if ( m_filename . isSet ( ) && ! m_filename . getRe@@ lative@@ Path ( ) . empty ( ) && ! PythonEnvironment :: runFile ( m_filename . getFullPath ( ) . c_str ( ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( file ▁ ' " << m_filename . getFullPath ( ) . c_str ( ) << " ' ▁ not ▁ parsable ) " ; return ; } PyObject * pDict = PyModule_GetDict ( PyImport_AddModule ( " _ _ main _ _ " ) ) ; m_ScriptControllerClass = PyDict_GetItemString ( pDict , m_classname . getValueString ( ) . c_str ( ) ) ; if ( ! m_ScriptControllerClass ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ not ▁ found ) . " ; return ; } if ( 1 != PyObject_Is@@ Subclass ( m_ScriptControllerClass , ( PyObject * ) & SP_SOF@@ APYTYPE@@ OBJECT ( PythonScriptController ) ) ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ does ▁ not ▁ inher@@ it ▁ from ▁ ' Sofa . PythonScriptController ' ) . " ; return ; } m_ScriptControllerInstance = BuildPySPtr < Base > ( this , ( PyTypeObject * ) m_ScriptControllerClass ) ; if ( ! m_ScriptControllerInstance ) { msg_error ( ) << " ▁ load ▁ error ▁ ( class ▁ ' " << m_classname . getValueString ( ) << " ' ▁ instanci@@ ation ▁ error ) . " ; return ; } refreshBinding ( ) ; }
void PythonScriptController :: doLoadScript ( ) { loadScript ( ) ; }
void PythonScriptController :: script_onIdleEvent ( const IdleEvent * ) { FileMonitor :: updates ( 0 ) ; { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_onIdle ) ; } std :: cout . flush ( ) ; std :: cerr . flush ( ) ; }
void PythonScriptController :: script_onLoaded ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onLoaded , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
void PythonScriptController :: script_createGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_createGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
void PythonScriptController :: script_initGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_initGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
void PythonScriptController :: script_bwdInitGraph ( Node * node ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_bwdInitGraph , " ( O ) " , sofa :: PythonFactory :: toPython ( node ) ) }
bool PythonScriptController :: script_onKeyPressed ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyPressed " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyPressed , " ( c ) " , c ) ; return b ; }
bool PythonScriptController :: script_onKeyReleased ( const char c ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onKeyReleased " , this ) ; bool b = false ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEBOOLFUNC ( m_Func_onKeyReleased , " ( c ) " , c ) ; return b ; }
void PythonScriptController :: script_onMouseMove ( const int posX , const int posY ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseMove " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseMove , " ( ii ) " , posX , posY ) ; }
void PythonScriptController :: script_onMouseButtonLeft ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonLeft " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonLeft , " ( iiO ) " , posX , posY , pyPressed ) }
void PythonScriptController :: script_onMouseButtonRight ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonRight " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonRight , " ( iiO ) " , posX , posY , pyPressed ) }
void PythonScriptController :: script_onMouseButtonMiddle ( const int posX , const int posY , const bool pressed ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseButtonMiddle " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PyObject * pyPressed = pressed ? Py_True : Py_False ; SP_CALL_MODULEFUNC ( m_Func_onMouseButtonMiddle , " ( iiO ) " , posX , posY , pyPressed ) }
void PythonScriptController :: script_onMouseWheel ( const int posX , const int posY , const int delta ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onMouseWheel " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onMouseWheel , " ( iii ) " , posX , posY , delta ) }
void PythonScriptController :: script_onBeginAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onBeginAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onBeginAnimationStep , " ( d ) " , dt ) }
void PythonScriptController :: script_onEndAnimationStep ( const double dt ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onEndAnimationStep " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onEndAnimationStep , " ( d ) " , dt ) }
void PythonScriptController :: script_storeResetState ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_storeResetState ) }
void PythonScriptController :: script_reset ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_reset ) }
void PythonScriptController :: script_cleanup ( ) { PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_cleanup ) }
void PythonScriptController :: script_onGUIEvent ( const char * controlID , const char * valueName , const char * value ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onGUIEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC ( m_Func_onGUIEvent , " ( sss ) " , controlID , valueName , value ) ; }
void PythonScriptController :: script_onScriptEvent ( core :: objectmodel :: ScriptEvent * event ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ onScriptEvent " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; PythonScriptEvent * pyEvent = static_cast < PythonScriptEvent * > ( event ) ; SP_CALL_MODULEFUNC ( m_Func_onScriptEvent , " ( OsO ) " , sofa :: PythonFactory :: toPython ( pyEvent -> getSender ( ) . get ( ) ) , pyEvent -> getEvent@@ Name ( ) . c_str ( ) , pyEvent -> getUserData ( ) ) ; }
void PythonScriptController :: script_d@@ raw ( const core :: visual :: Visual@@ Params * ) { ActivableScopedAdvancedTimer advancedTimer ( m_timingEnabled . getValue ( ) , " PythonScriptController _ draw " , this ) ; PythonEnvironment :: gil lock ( __func__ ) ; SP_CALL_MODULEFUNC_NOPARAM ( m_Func_draw ) ; }
void PythonScriptController :: handleEvent ( core :: objectmodel :: Event * event ) { if ( PythonScriptEvent :: checkEventType ( event ) ) { script_onScriptEvent ( static_cast < PythonScriptEvent * > ( event ) ) ; } else { ScriptController :: handleEvent ( event ) ; } }
bool AudioResampler :: qualityIsSupported ( src_quality quality ) { switch ( quality ) { case DEFAULT_QUALITY : case LOW_QUALITY : case MED_QUALITY : case HIGH_QUALITY : case VERY_HIGH_QUALITY : return true ; default : return false ; } }
uint32_t AudioResampler :: qualityMHz ( src_quality quality ) { switch ( quality ) { default : case DEFAULT_QUALITY : case LOW_QUALITY : return 3 ; case MED_QUALITY : return 6 ; case HIGH_QUALITY : return 20 ; case VERY_HIGH_QUALITY : return 34 ; } }
AudioResampler * AudioResampler :: create ( audio@@ _format@@ _t format , int inChannelCount , int32_t sampleRate , src_quality quality ) { bool atFinalQuality ; if ( quality == DEFAULT_QUALITY ) { int ok = pthread_once ( & once_control , init_routine ) ; if ( ok != 0 ) { ALOGE ( " % s ▁ pthread _ once ▁ failed : ▁ % d " , __func__ , ok ) ; } quality = defaultQuality ; atFinalQuality = false ; } else { atFinalQuality = true ; } if ( quality == DEFAULT_QUALITY ) { } pthread_mutex_lock ( & mutex ) ; for ( ; ; ) { uint32_t deltaMHz = qualityMHz ( quality ) ; uint32_t newMHz = currentMHz + deltaMHz ; if ( ( qualityIsSupported ( quality ) && newMHz <= maxMHz ) || atFinalQuality ) { ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % u ▁ MHz ▁ due ▁ to ▁ delta ▁ + % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; currentMHz = newMHz ; break ; } switch ( quality ) { default : case LOW_QUALITY : atFinalQuality = true ; break ; case MED_QUALITY : quality = LOW_QUALITY ; break ; case HIGH_QUALITY : quality = MED_QUALITY ; break ; case VERY_HIGH_QUALITY : quality = HIGH_QUALITY ; break ; } } pthread_mutex_unlock ( & mutex ) ; AudioResampler * resampler ; switch ( quality ) { default : case LOW_QUALITY : ALOGV ( " Create ▁ linear ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerOrder1 ( inChannelCount , sampleRate ) ; break ; case MED_QUALITY : ALOGV ( " Create ▁ cubic ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; resampler = new ( std :: nothrow ) AudioResamplerCubic ( inChannelCount , sampleRate ) ; break ; case HIGH_QUALITY : ALOGV ( " Create ▁ HIGH _ QUALITY ▁ sinc ▁ Resampler " ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; case VERY_HIGH_QUALITY : ALOGV ( " Create ▁ VERY _ HIGH _ QUALITY ▁ sinc ▁ Resampler ▁ = ▁ % d " , quality ) ; LOG_ALWAYS_FATAL_IF ( format != AUDIO_FORMAT_PCM_16_BIT , " invalid ▁ pcm ▁ format " ) ; ALOG_ASSERT ( false , " VERY _ HIGH _ QUALITY ▁ isn ' t ▁ supported " ) ; break ; } resampler -> init ( ) ; return resampler ; }
AudioResampler :: AudioResampler ( int inChannelCount , int32_t sampleRate , src_quality quality ) : mChannelCount ( inChannelCount ) , mSampleRate ( sampleRate ) , mInSampleRate ( sampleRate ) , mInputIndex ( 0 ) , mPhaseFraction ( 0 ) , mLocalTimeFreq ( 0 ) , mPTS ( AudioBufferProvider :: kInvalidPTS ) , mQuality ( quality ) { const int maxChannels = 2 ; if ( inChannelCount < 1 || inChannelCount > maxChannels ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ format ▁ % d ▁ quality ▁ % d ▁ channels " , quality , inChannelCount ) ; } if ( sampleRate <= 0 ) { LOG_ALWAYS_FATAL ( " Unsupported ▁ sample ▁ rate ▁ % d ▁ Hz " , sampleRate ) ; } mVolume [ 0 ] = mVolume [ 1 ] = 0 ; mBuffer . frameCount = 0 ; }
AudioResampler :: ~ AudioResampler ( ) { pthread_mutex_lock ( & mutex ) ; src_quality quality = getQuality ( ) ; uint32_t deltaMHz = qualityMHz ( quality ) ; int32_t newMHz = currentMHz - deltaMHz ; ALOGV ( " resampler ▁ load ▁ % u ▁ - > ▁ % d ▁ MHz ▁ due ▁ to ▁ delta ▁ - % u ▁ MHz ▁ from ▁ quality ▁ % d " , currentMHz , newMHz , deltaMHz , quality ) ; LOG_ALWAYS_FATAL_IF ( newMHz < 0 , " negative ▁ resampler ▁ load ▁ % d ▁ MHz " , newMHz ) ; currentMHz = newMHz ; pthread_mutex_unlock ( & mutex ) ; }
void AudioResampler :: setSampleRate ( int32_t inSampleRate ) { mInSampleRate = inSampleRate ; mPhaseIncrement = ( uint32_t ) ( ( kPhaseMultiplier * inSampleRate ) / mSampleRate ) ; }
void AudioResampler :: setVolume ( float left , float right ) { mVolume [ 0 ] = u4_12_from_float ( clampFloatVol ( left ) ) ; mVolume [ 1 ] = u4_12_from_float ( clampFloatVol ( right ) ) ; }
void AudioResampler :: setLocalTimeFreq ( uint64_t freq ) { mLocalTimeFreq = freq ; }
void AudioResampler :: setPTS ( int64_t pts ) { mPTS = pts ; }
int64_t AudioResampler :: calculateOutputPTS ( int outputFrameIndex ) { if ( mPTS == AudioBufferProvider :: kInvalidPTS ) { return AudioBufferProvider :: kInvalidPTS ; } else { return mPTS + ( ( outputFrameIndex * mLocalTimeFreq ) / mSampleRate ) ; } }
void AudioResampler :: reset ( ) { mInputIndex = 0 ; mPhaseFraction = 0 ; mBuffer . frameCount = 0 ; }
size_t AudioResamplerOrder1 :: resample ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { switch ( mChannelCount ) { case 1 : return resampleMono16 ( out , outFrameCount , provider ) ; case 2 : return resampleStereo16 ( out , outFrameCount , provider ) ; default : LOG_ALWAYS_FATAL ( " invalid ▁ channel ▁ count : ▁ % d " , mChannelCount ) ; return 0 ; } }
size_t AudioResamplerOrder1 :: resampleStereo16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { goto resampleStereo16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { out [ outputIndex ++ ] += vl * Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( mX0R , in [ 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = mBuffer . frameCount - 2 ; AsmStereo16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { out [ outputIndex ++ ] += vl * Interp ( in [ inputIndex * 2 - 2 ] , in [ inputIndex * 2 ] , phaseFraction ) ; out [ outputIndex ++ ] += vr * Interp ( in [ inputIndex * 2 - 1 ] , in [ inputIndex * 2 + 1 ] , phaseFraction ) ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount * 2 - 2 ] ; mX0R = mBuffer . i16 [ mBuffer . frameCount * 2 - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleStereo16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex / 2 ; }
size_t AudioResamplerOrder1 :: resampleMono16 ( int32_t * out , size_t outFrameCount , AudioBufferProvider * provider ) { int32_t vl = mVolume [ 0 ] ; int32_t vr = mVolume [ 1 ] ; size_t inputIndex = mInputIndex ; uint32_t phaseFraction = mPhaseFraction ; uint32_t phaseIncrement = mPhaseIncrement ; size_t outputIndex = 0 ; size_t outputSampleCount = outFrameCount * 2 ; size_t inFrameCount = getInFrameCountRequired ( outFrameCount ) ; while ( outputIndex < outputSampleCount ) { while ( mBuffer . frameCount == 0 ) { mBuffer . frameCount = inFrameCount ; provider -> getNextBuffer ( & mBuffer , calculateOutputPTS ( outputIndex / 2 ) ) ; if ( mBuffer . raw == NULL ) { mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; goto resampleMono16_exit ; } if ( mBuffer . frameCount > inputIndex ) break ; inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } int16_t * in = mBuffer . i16 ; while ( inputIndex == 0 ) { int32_t sample = Interp ( mX0L , in [ 0 ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; if ( outputIndex == outputSampleCount ) { break ; } } if ( inputIndex + 2 < mBuffer . frameCount ) { int32_t * maxOutPt ; int32_t maxInIdx ; maxOutPt = out + ( outputSampleCount - 2 ) ; maxInIdx = ( int32_t ) mBuffer . frameCount - 2 ; AsmMono16Loop ( in , maxOutPt , maxInIdx , outputIndex , out , inputIndex , vl , vr , phaseFraction , phaseIncrement ) ; } while ( outputIndex < outputSampleCount && inputIndex < mBuffer . frameCount ) { int32_t sample = Interp ( in [ inputIndex - 1 ] , in [ inputIndex ] , phaseFraction ) ; out [ outputIndex ++ ] += vl * sample ; out [ outputIndex ++ ] += vr * sample ; Advance ( & inputIndex , & phaseFraction , phaseIncrement ) ; } if ( inputIndex >= mBuffer . frameCount ) { inputIndex -= mBuffer . frameCount ; mX0L = mBuffer . i16 [ mBuffer . frameCount - 1 ] ; provider -> releaseBuffer ( & mBuffer ) ; } } resampleMono16_exit : mInputIndex = inputIndex ; mPhaseFraction = phaseFraction ; return outputIndex ; }
GeneralParamReceiver :: ~ GeneralParamReceiver ( ) { m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> DeregisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; }
void GeneralParamReceiver :: init ( ) { m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: SET_GENERAL_PARAMETER ) ; m_guiProtHandler -> RegisterReceiver ( this , isab :: GuiProtEnums :: GET_GENERAL_PARAMETER ) ; }
bool GeneralParamReceiver :: decodedParamNoValue ( uint32 paramId ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const float * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const uint8 * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const char * * data , int32 numEntries ) { return false ; }
bool GeneralParamReceiver :: decodedParamValue ( uint32 paramId , const int32 * data , int32 numEntries ) { switch ( paramId ) { case GuiProtEnums :: paramAutoReroute : { m_settingsData -> m_auto@@ Reroute = data [ 0 ] ; } break ; case GuiProtEnums :: paramBack@@ lightStrategy : { m_settingsData -> m_back@@ lightStrategy = data [ 0 ] ; } break ; case GuiProtEnums :: paramAutoTracking : { m_settingsData -> m_auto@@ Tracking = data [ 0 ] ; } break ; case GuiProtEnums :: paramDistance@@ Mode : { m_settingsData -> m_distance@@ Mode = data [ 0 ] ; } break ; case GuiProtEnums :: paramFavorite@@ Show : { m_settingsData -> m_favorite@@ ShowInMap = data [ 0 ] ; } break ; case GuiProtEnums :: paramHighways : { m_settingsData -> m_route@@ Highways = data [ 0 ] ; } break ; case GuiProtEnums :: paramTollRoads : { m_settingsData -> m_route@@ TollRoads = data [ 0 ] ; } break ; case GuiProtEnums :: paramTime@@ Dist : { m_settingsData -> m_route@@ CostType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrack@@ ingLevel : { m_settingsData -> m_track@@ ingLevel = data [ 0 ] ; } break ; case GuiProtEnums :: paramTrans@@ portationType : { m_settingsData -> m_trans@@ portationType = data [ 0 ] ; } break ; case GuiProtEnums :: paramTurnSoundsLevel : { m_settingsData -> m_turnSoundsLevel = data [ 0 ] ; } break ; case GuiProtEnums :: userTra@@ fficUpdatePeriod : { int32 val = data [ 0 ] ; m_settingsData -> m_traffic@@ UpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_trafficOld@@ UpdatePeriod = 0xbfffffff & val ; m_settingsData -> m_traffic@@ Update = 0x40000000 & val ? 0 : 1 ; m_settingsData -> m_trafficOld@@ Update = 0x40000000 & val ? 0 : 1 ; } break ; case GuiProtEnums :: paramAutomaticRouteOnSMSDest : { m_settingsData -> m_auto@@ RouteOnSMSDest = data [ 0 ] ; } break ; case GuiProtEnums :: paramKeep@@ SMSDestInInbox : { m_settingsData -> m_keep@@ SMSDestInInbox = data [ 0 ] ; } break ; case GuiProtEnums :: paramStore@@ SMSDestIn@@ MyDest : { m_settingsData -> m_store@@ SMSDest@@ InFavor@@ ites = data [ 0 ] ; } break ; case GuiProtEnums :: paramPosition@@ Symbol : { m_settingsData -> m_posit@@ ionSymbol = data [ 0 ] ; } break ; case GuiProtEnums :: paramCheck@@ ForUpdates : { m_settingsData -> m_checkForUpdates = data [ 0 ] ; } break ; default : return false ; break ; } return true ; }
bool GeneralParamReceiver :: GuiProtReceive@@ Message ( class GuiProtMess * mess ) { GuiProtEnums :: MessageType type = mess -> getMessageType ( ) ; if ( type == GuiProtEnums :: GET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; return decodedParamNoValue ( gpm -> getParamId ( ) ) ; } else if ( type == GuiProtEnums :: SET_GENERAL_PARAMETER ) { isab :: GeneralParameterMess * gpm = ( isab :: GeneralParameterMess * ) mess ; switch ( gpm -> getParamType ( ) ) { case isab :: GuiProtEnums :: paramType@@ Int32 : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getInteger@@ Data ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramType@@ Float : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getFloat@@ Data ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramType@@ Bin@@ ary : return decodedParamValue ( gpm -> getParamId ( ) , gpm -> getBinary@@ Data ( ) , gpm -> getNumEntries ( ) ) ; break ; case isab :: GuiProtEnums :: paramType@@ String : return decodedParamValue ( gpm -> getParamId ( ) , ( const char * * ) gpm -> getStringData ( ) , gpm -> getNumEntries ( ) ) ; break ; default : case isab :: GuiProtEnums :: paramType@@ Invalid : return false ; break ; } } return false ; }
void AsmRoutine@@ Manager :: Generate ( MIPS@@ State * mips , MIPSComp :: Jit * jit , MIPSComp :: JitOptions * jo ) { enterCode = AlignCode16 ( ) ; ABI_PushAllCalleeSavedRegsAndAdjustStack ( ) ; MOV ( 64 , R ( MEMBASEREG ) , ImmPtr ( Memory :: base ) ) ; uintptr_t jitbase = ( uintptr_t ) jit -> GetBasePtr ( ) ; if ( jitbase > 0x7FFFFFFFULL ) { MOV ( 64 , R ( JITBASEREG ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; jo -> reserveR15ForAsm = true ; } MOV ( PTR@@ BITS , R ( CTX@@ REG ) , ImmPtr ( & mips -> f [ 0 ] ) ) ; outerLoop = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( reinterpret_cast < void * > ( & CoreTiming :: Advance ) ) ; jit -> ApplyRoundingMode ( true , this ) ; FixupBranch skipToRealDispatch = J ( ) ; dispatcher@@ CheckCoreState = GetCodePtr ( ) ; FixupBranch bailCoreState = J_CC ( CC_S , true ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; FixupBranch badCoreState = J_CC ( CC_NZ , true ) ; FixupBranch skipToRealDispatch2 = J ( ) ; dispatcher = GetCodePtr ( ) ; FixupBranch bail = J_CC ( CC_S , true ) ; SetJumpTarget ( skipToRealDispatch ) ; SetJumpTarget ( skipToRealDispatch2 ) ; dispatcherNoCheck = GetCodePtr ( ) ; MOV ( 32 , R ( EAX ) , M ( & mips -> pc ) ) ; dispatcher@@ InEA@@ XNoCheck = GetCodePtr ( ) ; AND ( 32 , R ( EAX ) , Imm32 ( Memory :: MEMVIEW@@ 32_MASK ) ) ; _assert_msg_ ( CPU , Memory :: base != 0 , " Memory ▁ base ▁ bogus " ) ; MOV ( 32 , R ( EAX ) , MDis@@ p ( EAX , ( u32 ) Memory :: base ) ) ; # elif _M_X64 MOV ( 32 , R ( EAX ) , MComp@@ lex ( MEMBASEREG , RAX , SCAL@@ E_1 , 0 ) ) ; MOV ( 32 , R ( EDX ) , R ( EAX ) ) ; _assert_msg_ ( JIT , MIPS_@@ JITBLOCK_@@ MASK == 0xFF000000 , " Hard@@ coded ▁ assumption ▁ of ▁ emu@@ hack ▁ mask " ) ; SHR ( 32 , R ( EDX ) , Imm8 ( 24 ) ) ; CMP ( 32 , R ( EDX ) , Imm8 ( MIPS_EMUHACK_@@ OPCO@@ DE >> 24 ) ) ; FixupBranch notfound = J_CC ( CC_NE ) ; if ( enableDebug ) { ADD ( 32 , M ( & mips -> debug@@ Count ) , Imm8 ( 1 ) ) ; } AND ( 32 , R ( EAX ) , Imm32 ( MIPS_EMUHACK_@@ VALUE_@@ MASK ) ) ; ADD ( 32 , R ( EAX ) , ImmPtr ( jit -> GetBasePtr ( ) ) ) ; # elif _M_X64 if ( jo -> reserveR15ForAsm ) ADD ( 64 , R ( RAX ) , R ( JITBASEREG ) ) ; else ADD ( 64 , R ( EAX ) , Imm32 ( jitbase ) ) ; JMP@@ ptr ( R ( EAX ) ) ; SetJumpTarget ( notfound ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_CallFunction ( & MIPSComp :: JitAt ) ; jit -> ApplyRoundingMode ( true , this ) ; JMP ( dispatcherNoCheck , true ) ; SetJumpTarget ( bail ) ; SetJumpTarget ( bailCoreState ) ; CMP ( 32 , M ( & coreState ) , Imm32 ( 0 ) ) ; J_CC ( CC_Z , outerLoop , true ) ; SetJumpTarget ( badCoreState ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; breakpoint@@ Bai@@ lout = GetCodePtr ( ) ; jit -> RestoreRoundingMode ( true , this ) ; ABI_PopAllCalleeSavedRegsAndAdjustStack ( ) ; RET ( ) ; }
CCFreeTypeFont :: ~ CCFreeTypeFont ( ) { reset ( ) ; }
void CCFreeTypeFont :: reset ( ) { for ( auto line : m_lines ) { line -> glyphs . clear ( ) ; delete line ; } m_lines . clear ( ) ; if ( m_face ) { FT_Done_@@ Face ( m_face ) ; m_face = nullptr ; } }
unsigned char * CCFreeTypeFont :: initWith@@ String ( const char * text , const FontDefinition & textDefinition , Device :: TextAlign align , int & width , int & height , ssize_t & dataLength ) { FT_Error error = 0 ; ssize_t size = 0 ; unsigned char * pBuffer = nullptr ; unsigned char * data = nullptr ; Size winSize = Director :: getInstance ( ) -> getWin@@ SizeInPixels ( ) ; m_windowWidth = ( int ) winSize . width ; m_inWidth = textDefinition . _dimensions . width ; m_inHeight = textDefinition . _dimensions . height ; m_fontFillColorR = textDefinition . _fontFillColor . r ; m_fontFillColorG = textDefinition . _fontFillColor . g ; m_fontFillColorB = textDefinition . _fontFillColor . b ; auto ittFontNames = s_fontsNames . find ( textDefinition . _fontName ) ; if ( ittFontNames != s_fontsNames . end ( ) ) { pBuffer = ittFontNames -> second . pBuffer ; size = ittFontNames -> second . size ; } if ( ! pBuffer ) { pBuffer = loadFont ( textDefinition . _fontName . c_str ( ) , & size ) ; if ( ! pBuffer ) { pBuffer = loadSystemFont ( textDefinition . _fontName . c_str ( ) , & size ) ; } if ( ! pBuffer ) { pBuffer = loadFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { pBuffer = loadSystemFont ( " Arial " , & size ) ; } if ( ! pBuffer ) { return false ; } FontBufferInfo info ; info . pBuffer = pBuffer ; info . size = size ; s_fontsNames [ textDefinition . _fontName ] = info ; } m_fontName = textDefinition . _fontName ; m_text = text ; if ( ! s_FreeTypeLibrary ) { error = FT_Init_FreeType ( & s_FreeTypeLibrary ) ; } if ( ! error && ! m_face ) { error = FT_New_Mem@@ ory_Face ( s_FreeTypeLibrary , pBuffer , size , 0 , & m_face ) ; } if ( ! error ) { error = FT_Select_Char@@ map ( m_face , FT_ENCO@@ DING_UNICODE ) ; } if ( ! error ) { error = FT_Set_Char@@ _Size ( m_face , textDefinition . _fontSize << 6 , textDefinition . _fontSize << 6 , 72 , 72 ) ; } if ( ! error ) { error = initGlyphs ( text ) ; } if ( ! error ) { data = getBitmap ( align , width , height , dataLength ) ; } delete [ ] pBuffer ; reset ( ) ; return data ; }
unsigned char * CCFreeTypeFont :: getBitmap ( Device :: TextAlign eAlignMask , int & width , int & height , ssize_t & dataLength ) { int lineNumber = 0 ; int totalLines = m_lines . size ( ) ; m_width = m_inWidth ? m_inWidth : m_textWidth ; m_height = m_inHeight ? m_inHeight : m_textHeight ; unsigned int size = m_width * m_height * 4 ; unsigned char * pBuffer = new unsigned char [ size ] ; dataLength = size ; if ( ! pBuffer ) { dataLength = 0 ; return nullptr ; } memset ( pBuffer , 0 , size ) ; for ( auto line = m_lines . begin ( ) ; line != m_lines . end ( ) ; ++ line ) { FT_Vector pen = getPenForAlignment ( * line , eAlignMask , lineNumber , totalLines ) ; drawText ( * line , pBuffer , & pen ) ; lineNumber ++ ; } width = m_width ; height = m_height ; return pBuffer ; }
FT_Vector CCFreeTypeFont :: getPenForAlignment ( FTLineInfo * pInfo , Device :: TextAlign eAlignMask , int lineNumber , int totalLines ) { FT_Error error = 0 ; FT_Vector pen ; int top ; int stringWidth = pInfo -> bbox . xMax - pInfo -> bbox . xMin ; int maxLineNumber = totalLines - 1 ; pen . x = 0 ; pen . y = 0 ; switch ( eAlignMask ) { case Device :: TextAlign :: TOP : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_@@ LEFT : pen . x -= pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: TOP_@@ RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = pInfo -> bbox . yMax + ( lineNumber * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_@@ RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: BOTTOM_@@ LEFT : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = m_height + pInfo -> bbox . yMin - ( ( maxLineNumber - lineNumber ) * m_lineHeight ) ; break ; case Device :: TextAlign :: CEN@@ TER : pen . x = ( ( m_width - stringWidth ) / 2 ) - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: RIGHT : pen . x = m_width - stringWidth - pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; case Device :: TextAlign :: LEFT : default : pen . x -= pInfo -> bbox . xMin ; top = ( m_height - m_textHeight ) / 2 ; pen . y = top + ( lineNumber * m_lineHeight ) + pInfo -> bbox . yMax ; break ; } return pen ; }
void CCFreeTypeFont :: drawText ( FTLineInfo * pInfo , unsigned char * pBuffer , FT_Vector * pen ) { auto glyphs = pInfo -> glyphs ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph image = glyph -> image ; FT_Error error = FT_Glyph_@@ To_Bitmap ( & image , FT_RENDER_@@ MODE_@@ NORMAL , 0 , 1 ) ; if ( ! error ) { FT_BitmapGlyph bit = ( FT_BitmapGlyph ) image ; draw_bitmap ( pBuffer , & bit -> bitmap , pen -> x + glyph -> pos . x + bit -> left , pen -> y - bit -> top ) ; FT_Done_@@ Glyph ( image ) ; } } }
void CCFreeTypeFont :: draw_bitmap ( unsigned char * pBuffer , FT_Bitmap * bitmap , FT_Int x , FT_Int y ) { FT_Int i , j , p , q ; FT_Int x_max = x + bitmap -> width ; FT_Int y_max = y + bitmap -> rows ; for ( i = x , p = 0 ; i < x_max ; i ++ , p ++ ) { for ( j = y , q = 0 ; j < y_max ; j ++ , q ++ ) { if ( i < 0 || j < 0 || i >= m_width || j >= m_height ) continue ; unsigned char value = bitmap -> buffer [ q * bitmap -> width + p ] ; if ( value > 0 ) { FT_Int index = ( j * m_width * 4 ) + ( i * 4 ) ; pBuffer [ index ++ ] = m_fontFillColorR ; pBuffer [ index ++ ] = m_fontFillColorG ; pBuffer [ index ++ ] = m_fontFillColorB ; pBuffer [ index ++ ] = value ; } } } }
void CCFreeTypeFont :: endLine ( ) { if ( m_currentLine ) { m_lines . push_back ( m_currentLine ) ; m_textWidth = std :: max ( ( long ) m_textWidth , m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ) ; m_textHeight += m_lineHeight ; } }
void CCFreeTypeFont :: newLine ( ) { m_currentLine = new FTLineInfo ( ) ; m_currentLine -> width = 0 ; m_currentLine -> pen . x = 0 ; m_currentLine -> pen . y = 0 ; }
FT_Error CCFreeTypeFont :: addWord ( const std :: string & word ) { std :: vector < TGlyph > glyphs ; FT_BBox bbox ; int maxWidth = m_inWidth ? m_inWidth : m_windowWidth ; std :: string newWord ; if ( m_currentLine -> width > 0 ) { newWord = ' ▁ ' + word ; } else { newWord = word ; } FT_Error error = initWordGlyphs ( glyphs , newWord , m_currentLine -> pen ) ; if ( ! error ) { compute_bbox ( glyphs , & bbox ) ; if ( m_currentLine -> width == 0 || bbox . xMax <= maxWidth ) { m_currentLine -> glyphs . insert ( m_currentLine -> glyphs . end ( ) , glyphs . begin ( ) , glyphs . end ( ) ) ; if ( m_currentLine -> width == 0 ) { m_currentLine -> bbox = bbox ; } else { m_currentLine -> bbox . xMax = bbox . xMax ; } m_currentLine -> width = m_currentLine -> bbox . xMax - m_currentLine -> bbox . xMin ; } else { endLine ( ) ; newLine ( ) ; addWord ( word ) ; } } return error ; }
FT_Error CCFreeTypeFont :: initGlyphs ( const char * text ) { FT_Error error = 0 ; std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; m_textWidth = 0 ; m_textHeight = 0 ; m_lineHeight = ( ( m_face -> size -> metrics . ascender ) >> 6 ) - ( ( m_face -> size -> metrics . descender ) >> 6 ) ; m_lines . clear ( ) ; while ( std :: getline ( stringStream , line ) && ! error ) { newLine ( ) ; std :: size_t prev = 0 , pos ; while ( ( pos = line . find_first_of ( " ▁ " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) { addWord ( line . substr ( prev , pos - prev ) ) ; } prev = pos + 1 ; } if ( prev < line . length ( ) ) { addWord ( line . substr ( prev , std :: string :: npos ) ) ; } endLine ( ) ; } return error ; }
void CCFreeTypeFont :: initWords ( const char * text ) { std :: stringstream stringStream ( text ) ; std :: string line ; vector < std :: string > lines ; vector < std :: string > words ; while ( std :: getline ( stringStream , line ) ) { lines . push_back ( line ) ; } for ( auto it = lines . begin ( ) ; it != lines . end ( ) ; ++ it ) { std :: size_t prev = 0 , pos ; while ( ( pos = it -> find_first_of ( " ▁ ' ; " , prev ) ) != std :: string :: npos ) { if ( pos > prev ) words . push_back ( it -> substr ( prev , pos - prev ) ) ; prev = pos + 1 ; } if ( prev < it -> length ( ) ) words . push_back ( it -> substr ( prev , std :: string :: npos ) ) ; } for ( auto it = words . begin ( ) ; it != words . end ( ) ; ++ it ) { std :: string foo ( * it ) ; } }
FT_Error CCFreeTypeFont :: initWordGlyphs ( std :: vector < TGlyph > & glyphs , const std :: string & text , FT_Vector & pen ) { FT_Glyph@@ Slot slot = m_face -> glyph ; FT_UInt glyph_index ; FT_UInt previous = 0 ; FT_Error error = 0 ; PGlyph glyph ; unsigned int numGlyphs = 0 ; wchar_t * pwszBuffer = nullptr ; int num_chars = text . size ( ) ; int nBufLen = num_chars + 1 ; pwszBuffer = new wchar_t [ nBufLen ] ; if ( ! pwszBuffer ) { return - 1 ; } memset ( pwszBuffer , 0 , nBufLen ) ; num_chars = MultiByteToWide@@ Char ( CP_@@ UTF8 , 0 , text . c_str ( ) , num_chars , pwszBuffer , nBufLen ) ; pwszBuffer [ num_chars ] = ' \0' ; glyphs . clear ( ) ; glyphs . resize ( num_chars ) ; FT_Bool useKerning = FT_HAS_@@ KERN@@ ING ( m_face ) ; for ( int n = 0 ; n < num_chars ; n ++ ) { glyph = & glyphs [ numGlyphs ] ; FT_ULong c = pwszBuffer [ n ] ; glyph_index = FT_Get_@@ Char_Index ( m_face , c ) ; if ( useKerning && previous && glyph_index ) { FT_Vector delta ; FT_Get_@@ Kerning ( m_face , previous , glyph_index , FT_KERN@@ ING_DEFAULT , & delta ) ; pen . x += delta . x >> 6 ; } glyph -> pos = pen ; glyph -> index = glyph_index ; error = FT_Load@@ _Glyph ( m_face , glyph_index , FT_LOAD_@@ DEFAULT ) ; if ( error ) continue ; error = FT_Get_@@ Glyph ( m_face -> glyph , & glyph -> image ) ; if ( error ) continue ; FT_Glyph_@@ Transform ( glyph -> image , 0 , & glyph -> pos ) ; pen . x += slot -> advance . x >> 6 ; previous = glyph_index ; numGlyphs ++ ; } CC_SAF@@ E_DELETE_@@ ARRAY ( pwszBuffer ) ; return error ; }
void CCFreeTypeFont :: compute_bbox ( std :: vector < TGlyph > & glyphs , FT_BBox * abbox ) { FT_BBox bbox ; FT_BBox glyph_bbox ; bbox . xMin = 32000 ; bbox . xMax = - 32000 ; bbox . yMin = ( m_face -> size -> metrics . descender ) >> 6 ; bbox . yMax = ( m_face -> size -> metrics . ascender ) >> 6 ; for ( auto glyph = glyphs . begin ( ) ; glyph != glyphs . end ( ) ; ++ glyph ) { FT_Glyph_@@ Get_CBox ( glyph -> image , ft_glyph_bbox_@@ pixels , & glyph_bbox ) ; glyph_bbox . xMin += glyph -> pos . x ; glyph_bbox . xMax += glyph -> pos . x ; glyph_bbox . yMin += glyph -> pos . y ; glyph_bbox . yMax += glyph -> pos . y ; if ( glyph_bbox . xMin < bbox . xMin ) bbox . xMin = glyph_bbox . xMin ; if ( glyph_bbox . yMin < bbox . yMin ) bbox . yMin = glyph_bbox . yMin ; if ( glyph_bbox . xMax > bbox . xMax ) bbox . xMax = glyph_bbox . xMax ; if ( glyph_bbox . yMax > bbox . yMax ) bbox . yMax = glyph_bbox . yMax ; } if ( bbox . xMin > bbox . xMax ) { bbox . xMin = 0 ; bbox . yMin = 0 ; bbox . xMax = 0 ; bbox . yMax = 0 ; } * abbox = bbox ; }
unsigned char * CCFreeTypeFont :: loadFont ( const char * pFontName , ssize_t * size ) { std :: string lowerCase ( pFontName ) ; std :: string path ( pFontName ) ; for ( unsigned int i = 0 ; i < lowerCase . length ( ) ; ++ i ) { lowerCase [ i ] = tolower ( lowerCase [ i ] ) ; } if ( std :: string :: npos == lowerCase . find ( " fonts / " ) ) { path = " fonts / " ; path += pFontName ; } if ( std :: string :: npos == lowerCase . find ( " . ttf " ) ) { path += " . ttf " ; } std :: string fullpath = FileUtils :: getInstance ( ) -> fullPathForFilename ( path . c_str ( ) ) ; return FileUtils :: sharedFileUtils ( ) -> getFile@@ Data ( fullpath . c_str ( ) , " rb " , size ) ; }
unsigned char * CCFreeTypeFont :: loadSystemFont ( const char * pFontName , ssize_t * size ) { CC_TARGET_PLATFORM == CC_PLATFORM_WP8 ) return nullptr ; std :: string aName ( pFontName ) ; unsigned char * pBuffer = nullptr ; HRESULT hr = S_OK ; IDWriteFactory * writeFactory = nullptr ; IDWriteFont@@ Collection * fontCollection = nullptr ; IDWriteFontFamily * fontFamily = nullptr ; IDWriteFont * matchingFont = nullptr ; IDWriteFontFace * fontFace = nullptr ; IDWriteFont@@ File * fontFile = nullptr ; IDWriteFont@@ FileLoader * fontFileLoader = nullptr ; IDWriteFont@@ FileStream * fontFileStream = nullptr ; UINT32 index ; BOOL exists ; std :: wstring fontNameW ; const void * fontFileReferenceKey = nullptr ; UINT32 fontFileReferenceKeySize ; void * fragmentContext = nullptr ; for ( unsigned int i = 0 ; i < aName . length ( ) ; ++ i ) { aName [ i ] = tolower ( aName [ i ] ) ; } fontNameW . assign ( aName . begin ( ) , aName . end ( ) ) ; hr = DWrite@@ CreateFactory ( DWRITE_@@ FACTORY_TYPE_@@ SHARED , __uuidof ( IDWriteFactory ) , reinterpret_cast < IUnknown * * > ( & writeFactory ) ) ; if ( SUCCEEDED ( hr ) ) { hr = writeFactory -> GetSystem@@ FontCollection ( & fontCollection , TRUE ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontCollection -> FindFamil@@ yName ( fontNameW . c_str ( ) , & index , & exists ) ; if ( SUCCEEDED ( hr ) && exists ) { hr = fontCollection -> GetFontFamily ( index , & fontFamily ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFamily -> GetFirst@@ Match@@ ingFont ( DWRITE_FONT_@@ WEIG@@ HT_REGUL@@ AR , DWRITE_@@ FONT_STRE@@ TCH_@@ NORMAL , DWRITE_FONT_@@ STYLE_@@ NORMAL , & matchingFont ) ; } if ( SUCCEEDED ( hr ) ) { hr = matchingFont -> CreateFontFace ( & fontFace ) ; } if ( SUCCEEDED ( hr ) ) { UINT32 numberOfFiles = 1 ; hr = fontFace -> GetFiles ( & numberOfFiles , & fontFile ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetReference@@ Key ( & fontFileReferenceKey , & fontFileReferenceKeySize ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFile -> GetLoader ( & fontFileLoader ) ; } if ( SUCCEEDED ( hr ) ) { hr = fontFileLoader -> CreateStream@@ FromKey ( fontFileReferenceKey , fontFileReferenceKeySize , & fontFileStream ) ; } if ( SUCCEEDED ( hr ) ) { UINT64 fileSize ; const void * fragmentStart = nullptr ; hr = fontFileStream -> GetFile@@ Size ( & fileSize ) ; if ( SUCCEEDED ( hr ) ) { hr = fontFileStream -> ReadFileFragment ( & fragmentStart , 0 , fileSize , & fragmentContext ) ; } if ( SUCCEEDED ( hr ) ) { pBuffer = ( unsigned char * ) malloc ( ( size_t ) fileSize ) ; memcpy ( pBuffer , fragmentStart , ( size_t ) fileSize ) ; * size = ( unsigned long ) fileSize ; } } } } if ( fontFileStream ) { fontFileStream -> ReleaseFileFragment ( fragmentContext ) ; fontFileStream -> Release ( ) ; } if ( fontFileLoader ) { fontFileLoader -> Release ( ) ; } if ( fontFile ) { fontFile -> Release ( ) ; } if ( fontFace ) { fontFace -> Release ( ) ; } if ( matchingFont ) { matchingFont -> Release ( ) ; } if ( fontFamily ) { fontFamily -> Release ( ) ; } if ( fontCollection ) { fontCollection -> Release ( ) ; } if ( writeFactory ) { writeFactory -> Release ( ) ; } return pBuffer ; }
void Interpreter :: Helper_UpdateCR0 ( u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ 0 ] = cr_val ; }
void Interpreter :: Helper_UpdateCRx ( int idx , u32 value ) { s64 sign_extended = ( s64 ) ( s32 ) value ; u64 cr_val = ( u64 ) sign_extended ; cr_val = ( cr_val & ~ ( 1ull << 61 ) ) | ( ( u64 ) GetXER_SO ( ) << 61 ) ; PowerPC :: ppcState . cr_val [ idx ] = cr_val ; }
u32 Interpreter :: Helper_Carry ( u32 _uValue1 , u32 _uValue2 ) { return _uValue2 > ( ~ _uValue1 ) ; }
u32 Interpreter :: Helper_Mask ( int mb , int me ) { u32 begin = 0xFFFFFFFF >> mb ; u32 end = me < 31 ? ( 0xFFFFFFFF >> ( me + 1 ) ) : 0 ; u32 mask = begin ^ end ; if ( me < mb ) return ~ mask ; else return mask ; }
void Interpreter :: addi ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + _inst . SIMM_16 ; else rGPR [ _inst . RD ] = _inst . SIMM_16 ; }
void Interpreter :: addic ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 imm = ( u32 ) ( s32 ) _inst . SIMM_16 ; rGPR [ _inst . RD ] = a + imm ; SetCarry ( Helper_Carry ( a , imm ) ) ; }
void Interpreter :: addic_rc ( UGeckoInstruction _inst ) { addic ( _inst ) ; Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addis ( UGeckoInstruction _inst ) { if ( _inst . RA ) rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + ( _inst . SIMM_16 << 16 ) ; else rGPR [ _inst . RD ] = ( _inst . SIMM_16 << 16 ) ; }
void Interpreter :: andi@@ _rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & _inst . UIMM ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: andi@@ s_rc ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ( ( u32 ) _inst . UIMM << 16 ) ; Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: cmpi ( UGeckoInstruction _inst ) { Helper_UpdateCRx ( _inst . CRFD , rGPR [ _inst . RA ] - _inst . SIMM_16 ) ; }
void Interpreter :: cmpl@@ i ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = _inst . UIMM ; int f ; if ( a < b ) f = 0x8 ; else if ( a > b ) f = 0x4 ; else f = 0x2 ; if ( GetXER_SO ( ) ) f |= 0x1 ; SetCRField ( _inst . CRFD , f ) ; }
void Interpreter :: mulli ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( s32 ) rGPR [ _inst . RA ] * _inst . SIMM_16 ; }
void Interpreter :: ori ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | _inst . UIMM ; }
void Interpreter :: oris ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( _inst . UIMM << 16 ) ; }
void Interpreter :: subfic ( UGeckoInstruction _inst ) { s32 immediate = _inst . SIMM_16 ; rGPR [ _inst . RD ] = immediate - ( int ) rGPR [ _inst . RA ] ; SetCarry ( ( rGPR [ _inst . RA ] == 0 ) || ( Helper_Carry ( 0 - rGPR [ _inst . RA ] , immediate ) ) ) ; }
void Interpreter :: twi ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = _inst . SIMM_16 ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " twi ▁ rA ▁ % x ▁ SIMM ▁ % x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } }
void Interpreter :: xor@@ i ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ _inst . UIMM ; }
void Interpreter :: xor@@ is ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ ( _inst . UIMM << 16 ) ; }
void Interpreter :: rlw@@ imix ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = ( rGPR [ _inst . RA ] & ~ mask ) | ( _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: rl@@ winmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , _inst . SH ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: rl@@ wnmx ( UGeckoInstruction _inst ) { u32 mask = Helper_Mask ( _inst . MB , _inst . ME ) ; rGPR [ _inst . RA ] = _rotl ( rGPR [ _inst . RS ] , rGPR [ _inst . RB ] & 0x1F ) & mask ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: andx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: andcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] & ~ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: cmp ( UGeckoInstruction _inst ) { s32 a = ( s32 ) rGPR [ _inst . RA ] ; s32 b = ( s32 ) rGPR [ _inst . RB ] ; int fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; }
void Interpreter :: cmpl ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 fTemp ; if ( a < b ) fTemp = 0x8 ; else if ( a > b ) fTemp = 0x4 ; else fTemp = 0x2 ; if ( GetXER_SO ( ) ) fTemp |= 0x1 ; SetCRField ( _inst . CRFD , fTemp ) ; }
void Interpreter :: cntlz@@ wx ( UGeckoInstruction _inst ) { u32 val = rGPR [ _inst . RS ] ; u32 mask = 0x80000000 ; int i = 0 ; for ( ; i < 32 ; i ++ , mask >>= 1 ) { if ( val & mask ) break ; } rGPR [ _inst . RA ] = i ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: eq@@ vx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: extsb@@ x ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s8 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: extshx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ( u32 ) ( s32 ) ( s16 ) rGPR [ _inst . RS ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: nandx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] & rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: norx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = ~ ( rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: orx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: orcx ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] | ( ~ rGPR [ _inst . RB ] ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: slwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : rGPR [ _inst . RS ] << ( amount & 0x1f ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: sraw@@ x ( UGeckoInstruction _inst ) { int rb = rGPR [ _inst . RB ] ; if ( rb & 0x20 ) { if ( rGPR [ _inst . RS ] & 0x80000000 ) { rGPR [ _inst . RA ] = 0xFFFFFFFF ; SetCarry ( 1 ) ; } else { rGPR [ _inst . RA ] = 0x00000000 ; SetCarry ( 0 ) ; } } else { int amount = rb & 0x1f ; if ( amount == 0 ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; SetCarry ( 0 ) ; } else { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: sraw@@ ix ( UGeckoInstruction _inst ) { int amount = _inst . SH ; if ( amount != 0 ) { s32 rrs = rGPR [ _inst . RS ] ; rGPR [ _inst . RA ] = rrs >> amount ; if ( ( rrs < 0 ) && ( rrs << ( 32 - amount ) ) ) SetCarry ( 1 ) ; else SetCarry ( 0 ) ; } else { SetCarry ( 0 ) ; rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: srwx ( UGeckoInstruction _inst ) { u32 amount = rGPR [ _inst . RB ] ; rGPR [ _inst . RA ] = ( amount & 0x20 ) ? 0 : ( rGPR [ _inst . RS ] >> ( amount & 0x1f ) ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: tw ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; s32 TO = _inst . TO ; DEBUG_LOG ( POWERPC , " tw ▁ rA ▁ % 0x ▁ rB ▁ % 0x ▁ TO ▁ % 0x " , a , b , TO ) ; if ( ( ( a < b ) && ( TO & 0x10 ) ) || ( ( a > b ) && ( TO & 0x08 ) ) || ( ( a == b ) && ( TO & 0x04 ) ) || ( ( ( u32 ) a < ( u32 ) b ) && ( TO & 0x02 ) ) || ( ( ( u32 ) a > ( u32 ) b ) && ( TO & 0x01 ) ) ) { PowerPC :: ppcState . Exceptions |= EXCEPTION_PROGRAM ; PowerPC :: CheckExceptions ( ) ; m_EndBlock = true ; } }
void Interpreter :: xor@@ x ( UGeckoInstruction _inst ) { rGPR [ _inst . RA ] = rGPR [ _inst . RS ] ^ rGPR [ _inst . RB ] ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RA ] ) ; }
void Interpreter :: addx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RA ] + rGPR [ _inst . RB ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b ; SetCarry ( Helper_Carry ( a , b ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; int b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = a + b + carry ; SetCarry ( Helper_Carry ( a , b ) || ( carry != 0 && Helper_Carry ( a + b , carry ) ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addmex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry - 1 ; SetCarry ( Helper_Carry ( a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: addzex ( UGeckoInstruction _inst ) { int carry = GetCarry ( ) ; int a = rGPR [ _inst . RA ] ; rGPR [ _inst . RD ] = a + carry ; SetCarry ( Helper_Carry ( a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ addzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: divwx ( UGeckoInstruction _inst ) { s32 a = rGPR [ _inst . RA ] ; s32 b = rGPR [ _inst . RB ] ; if ( b == 0 || ( ( u32 ) a == 0x80000000 && b == - 1 ) ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwx " ) ; } if ( ( ( u32 ) a & 0x80000000 ) && b == 0 ) rGPR [ _inst . RD ] = - 1 ; else rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = ( u32 ) ( a / b ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: divwux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; if ( b == 0 ) { if ( _inst . OE ) { PanicAlert ( " OE : ▁ divwux " ) ; } rGPR [ _inst . RD ] = 0 ; } else { rGPR [ _inst . RD ] = a / b ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: mulh@@ wx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( u64 ) ( ( ( s64 ) ( s32 ) a * ( s64 ) ( s32 ) b ) ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: mulh@@ wux ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( ( u64 ) a * ( u64 ) b ) >> 32 ) ; rGPR [ _inst . RD ] = d ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: mullwx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; u32 d = ( u32 ) ( ( s32 ) a * ( s32 ) b ) ; rGPR [ _inst . RD ] = d ; if ( _inst . OE ) PanicAlert ( " OE : ▁ mullwx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: negx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = ( ~ rGPR [ _inst . RA ] ) + 1 ; if ( rGPR [ _inst . RD ] == 0x80000000 ) { if ( _inst . OE ) PanicAlert ( " OE : ▁ negx " ) ; } if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfx ( UGeckoInstruction _inst ) { rGPR [ _inst . RD ] = rGPR [ _inst . RB ] - rGPR [ _inst . RA ] ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfcx ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; rGPR [ _inst . RD ] = b - a ; SetCarry ( a == 0 || Helper_Carry ( b , 0 - a ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfcx " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; u32 b = rGPR [ _inst . RB ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + b + carry ; SetCarry ( Helper_Carry ( ~ a , b ) || Helper_Carry ( ( ~ a ) + b , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfmex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry - 1 ; SetCarry ( Helper_Carry ( ~ a , carry - 1 ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfmex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
void Interpreter :: subfzex ( UGeckoInstruction _inst ) { u32 a = rGPR [ _inst . RA ] ; int carry = GetCarry ( ) ; rGPR [ _inst . RD ] = ( ~ a ) + carry ; SetCarry ( Helper_Carry ( ~ a , carry ) ) ; if ( _inst . OE ) PanicAlert ( " OE : ▁ subfzex " ) ; if ( _inst . Rc ) Helper_UpdateCR0 ( rGPR [ _inst . RD ] ) ; }
MaterialDocManager :: ~ MaterialDocManager ( void ) { UnRegisterAllMaterialViews ( ) ; ClearUndo ( ) ; ClearRedo ( ) ; }
void MaterialDocManager :: RegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; UnRegisterMaterialView ( view ) ; materialViews . Append ( view ) ; view -> SetMaterialDocManager ( this ) ; }
void MaterialDocManager :: UnRegisterMaterialView ( MaterialView * view ) { ASSERT ( view ) ; materialViews . Remove ( view ) ; view -> SetMaterialDocManager ( NULL ) ; }
void MaterialDocManager :: UnRegisterAllMaterialViews ( ) { int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { materialViews [ i ] -> SetMaterialDocManager ( NULL ) ; } materialViews . Clear ( ) ; }
void MaterialDocManager :: SetSelected@@ Material ( idMaterial * material ) { bool change = false ; if ( material ) { if ( currentMaterial ) { if ( strcmp ( material -> GetName ( ) , currentMaterial -> renderMaterial -> GetName ( ) ) ) { change = true ; } } else { change = true ; } } else { if ( currentMaterial ) { change = true ; } } if ( change ) { if ( currentMaterial ) { if ( ! inProgressMaterials . Get ( currentMaterial -> name . c_str ( ) ) ) { delete currentMaterial ; currentMaterial = NULL ; } } MaterialDoc * * tempDoc ; if ( material && inProgressMaterials . Get ( material -> GetName ( ) , & tempDoc ) ) { currentMaterial = * tempDoc ; } else { currentMaterial = CreateMaterialDoc ( material ) ; } NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } }
bool MaterialDocManager :: Does@@ FileNeedApply ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) && ( * pDoc ) -> applyWaiting ) return true ; } return false ; }
bool MaterialDocManager :: Does@@ AnyNeedApply ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ( * pDoc ) -> applyWaiting ) return true ; } return false ; }
bool MaterialDocManager :: IsFile@@ Modified ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) return true ; } return false ; }
bool MaterialDocManager :: IsAny@@ Modified ( ) { return ( inProgressMaterials . Num ( ) > 0 ) ; }
void MaterialDocManager :: AddMaterial ( const char * name , const char * filename , const char * sourceText , bool addUndo ) { if ( addUndo ) { AddMaterialModifier * mod = new AddMaterialModifier ( this , name , filename ) ; AddMaterialUndoModifier ( mod ) ; } MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = ( idMaterial * ) declManager -> CreateNew@@ Decl ( DECL_MATERIAL , name , filename ) ; if ( sourceText ) { rendMat -> SetText ( sourceText ) ; } newDoc -> SetRenderMaterial ( rendMat , true , sourceText ? true : false ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; }
void MaterialDocManager :: Redo@@ AddMaterial ( const char * name , bool clearData ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> modified = true ; idMaterial * rendMat = const_cast < idMaterial * > ( declManager -> FindMaterial ( name , false ) ) ; if ( clearData ) { rendMat -> SetText ( rendMat -> DefaultDefinition ( ) ) ; } newDoc -> SetRenderMaterial ( rendMat , true , true ) ; inProgressMaterials . Set ( newDoc -> name . c_str ( ) , newDoc ) ; NotifyViews ( newDoc , MATERIAL_ADD ) ; newDoc -> applyWaiting = true ; newDoc -> ApplyMaterialChanges ( ) ; }
void MaterialDocManager :: DeleteMaterial ( MaterialDoc * material , bool addUndo ) { assert ( material ) ; material -> Delete ( ) ; if ( addUndo ) { DeleteMaterialModifier * mod = new DeleteMaterialModifier ( this , material -> name ) ; AddMaterialUndoModifier ( mod ) ; } NotifyViews ( material , MATERIAL_DELETE ) ; }
void MaterialDocManager :: ApplyMaterial ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; materialDoc -> ApplyMaterialChanges ( ) ; }
void MaterialDocManager :: ApplyFile ( const char * filename ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> ApplyMaterialChanges ( ) ; } }
void MaterialDocManager :: ApplyAll ( ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> ApplyMaterialChanges ( ) ; } }
void MaterialDocManager :: SaveMaterial ( MaterialDoc * material ) { assert ( material ) ; material -> Save ( ) ; }
void MaterialDocManager :: SaveFile ( const char * filename ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) ( * pDoc ) -> Save ( ) ; } NotifyViews ( NULL , MATERIAL_SAVE_FILE , filename ) ; }
void MaterialDocManager :: SaveAllMaterials ( ) { for ( int i = inProgressMaterials . Num ( ) - 1 ; i >= 0 ; i -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; ( * pDoc ) -> Save ( ) ; } }
void MaterialDocManager :: ReloadFile ( const char * filename ) { declManager -> ReloadFile ( filename , true ) ; for ( int j = inProgressMaterials . Num ( ) - 1 ; j >= 0 ; j -- ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( j ) ; if ( ! strcmp ( ( * pDoc ) -> renderMaterial -> GetFileName ( ) , filename ) ) { ( * pDoc ) -> SetRenderMaterial ( ( * pDoc ) -> renderMaterial ) ; inProgressMaterials . Remove ( ( * pDoc ) -> name ) ; } } if ( currentMaterial ) { currentMaterial -> SetRenderMaterial ( currentMaterial -> renderMaterial ) ; NotifyViews ( currentMaterial , SELECTION_CHANGE ) ; } NotifyViews ( NULL , FILE_RELOAD , filename ) ; }
MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( const char * materialName ) { const idMaterial * material = declManager -> FindMaterial ( materialName ) ; return CreateMaterialDoc ( const_cast < idMaterial * > ( material ) ) ; }
MaterialDoc * MaterialDocManager :: CreateMaterialDoc ( idMaterial * material ) { MaterialDoc * existingDoc = GetInProgressDoc ( material ) ; if ( existingDoc ) { return existingDoc ; } if ( currentMaterial && material && ! currentMaterial -> name . Icmp ( material -> GetName ( ) ) ) { return currentMaterial ; } if ( material ) { MaterialDoc * newDoc = new MaterialDoc ( ) ; newDoc -> manager = this ; newDoc -> SetRenderMaterial ( material ) ; return newDoc ; } return NULL ; }
MaterialDoc * MaterialDocManager :: GetInProgressDoc ( idMaterial * material ) { if ( material ) { for ( int i = 0 ; i < inProgressMaterials . Num ( ) ; i ++ ) { MaterialDoc * * pDoc = inProgressMaterials . GetIndex ( i ) ; if ( ! ( * pDoc ) -> name . Icmp ( material -> GetName ( ) ) ) return * pDoc ; } } return NULL ; }
void MaterialDocManager :: CopyMaterial ( MaterialDoc * materialDoc , bool cut ) { cutMaterial = cut ; if ( materialDoc ) copyMaterial = materialDoc -> name ; else ClearCopy ( ) ; }
void MaterialDocManager :: ClearCopy ( ) { copyMaterial . Empty ( ) ; }
bool MaterialDocManager :: IsCopyMaterial ( ) { return ( copyMaterial . Length ( ) ) ? true : false ; }
idStr MaterialDocManager :: GetCopy@@ MaterialName ( ) { return copyMaterial ; }
void MaterialDocManager :: Paste@@ Material ( const char * name , const char * filename ) { if ( ! IsCopyMaterial ( ) ) { return ; } MaterialDoc * copyMat = CreateMaterialDoc ( copyMaterial ) ; if ( copyMat -> applyWaiting ) { copyMat -> ApplyMaterialChanges ( ) ; } idMaterial * material = copyMat -> renderMaterial ; char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; AddMaterial ( name , filename , declText , ! cutMaterial ) ; if ( cutMaterial ) { MaterialDoc * cutMaterial = CreateMaterialDoc ( material ) ; DeleteMaterial ( cutMaterial , false ) ; MoveMaterialModifier * mod = new MoveMaterialModifier ( this , name , filename , copyMaterial ) ; AddMaterialUndoModifier ( mod ) ; ClearCopy ( ) ; } }
void MaterialDocManager :: CopyStage ( MaterialDoc * materialDoc , int stageNum ) { assert ( materialDoc ) ; copyStageMaterial = materialDoc -> name ; copyStage = materialDoc -> GetStage ( stageNum ) ; idStr stageName = copyStage . stageData . GetString ( " name " ) ; }
void MaterialDocManager :: ClearCopyStage ( ) { copyStageMaterial . Empty ( ) ; copyStage . stageData . Clear ( ) ; }
bool MaterialDocManager :: IsCopyStage ( ) { return ( copyStageMaterial . Length ( ) ) ? true : false ; }
void MaterialDocManager :: Paste@@ Stage ( MaterialDoc * materialDoc ) { assert ( materialDoc ) ; int stageType = copyStage . stageData . GetInt ( " stagetype " ) ; materialDoc -> AddStage ( stageType , copyStage . stageData . GetString ( " name " ) ) ; materialDoc -> SetData ( materialDoc -> GetStage@@ Count ( ) - 1 , & copyStage . stageData ) ; }
void MaterialDocManager :: GetCopy@@ StageInfo ( int & type , idStr & name ) { if ( IsCopyStage ( ) ) { type = copyStage . stageData . GetInt ( " stagetype " ) ; name = copyStage . stageData . GetString ( " name " ) ; } }
void MaterialDocManager :: Undo ( ) { if ( IsUndoAvailable ( ) ) { MaterialModifier * mod = undoModifiers [ undoModifiers . Num ( ) - 1 ] ; undoModifiers . RemoveIndex ( undoModifiers . Num ( ) - 1 ) ; mod -> Undo ( ) ; AddMaterialRedoModifier ( mod ) ; } }
bool MaterialDocManager :: IsUndoAvailable ( ) { return ( undoModifiers . Num ( ) > 0 ) ; }
void MaterialDocManager :: ClearUndo ( ) { int c = undoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete undoModifiers [ i ] ; } undoModifiers . Clear ( ) ; }
void MaterialDocManager :: Redo ( ) { if ( IsRedoAvailable ( ) ) { MaterialModifier * mod = redoModifiers [ redoModifiers . Num ( ) - 1 ] ; redoModifiers . RemoveIndex ( redoModifiers . Num ( ) - 1 ) ; mod -> Redo ( ) ; AddMaterialUndoModifier ( mod , false ) ; } }
bool MaterialDocManager :: IsRedoAvailable ( ) { return ( redoModifiers . Num ( ) > 0 ) ; }
void MaterialDocManager :: ClearRedo ( ) { int c = redoModifiers . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { delete redoModifiers [ i ] ; } redoModifiers . Clear ( ) ; }
void MaterialDocManager :: AddMaterialUndoModifier ( MaterialModifier * mod , bool clearRedo ) { undoModifiers . Append ( mod ) ; while ( undoModifiers . Num ( ) > MAX_UNDOREDO ) { undoModifiers . RemoveIndex ( 0 ) ; } if ( clearRedo ) { ClearRedo ( ) ; } }
void MaterialDocManager :: AddMaterialRedoModifier ( MaterialModifier * mod ) { redoModifiers . Append ( mod ) ; while ( redoModifiers . Num ( ) > MAX_UNDOREDO ) { redoModifiers . RemoveIndex ( 0 ) ; } }
bool MaterialDocManager :: FindMaterial ( const char * name , MaterialSearch@@ Data_t * searchData , bool checkName ) { const idMaterial * material = static_cast < const idMaterial * > ( declManager -> FindDecl@@ Without@@ Parsing ( DECL_MATERIAL , name , false ) ) ; if ( material ) { int findPos ; if ( checkName ) { idStr name = material -> GetName ( ) ; findPos = name . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } char * declText = ( char * ) _alloca ( material -> GetTextLength ( ) + 1 ) ; material -> GetText ( declText ) ; idStr text = declText ; int start = text . Find ( " { " ) ; if ( start != - 1 ) { text = text . Right ( text . Length ( ) - start ) ; } findPos = text . Find ( searchData -> searchText , false ) ; if ( findPos != - 1 ) { return true ; } } return false ; }
idStr MaterialDocManager :: GetUnique@@ MaterialName ( idStr name ) { int num = 0 ; while ( 1 ) { idStr testName ; if ( num == 0 ) testName = name ; else testName = va ( " % s % d " , name . c_str ( ) , num ) ; const idMaterial * mat = declManager -> FindMaterial ( testName . c_str ( ) , false ) ; if ( ! mat ) { return testName ; } else { if ( mat -> GetTextLength ( ) < 1 ) return testName ; } num ++ ; } }
void MaterialDocManager :: NotifyViews ( MaterialDoc * materialDoc , int notifyType , ... ) { va_list argptr ; int c = materialViews . Num ( ) ; for ( int i = 0 ; i < c ; i ++ ) { va_start ( argptr , notifyType ) ; switch ( notifyType ) { case SELECTION_CHANGE : materialViews [ i ] -> MV_OnMaterialSelectionChange ( materialDoc ) ; break ; case MATERIAL_CHANGE : materialViews [ i ] -> MV_OnMaterialChange ( materialDoc ) ; break ; case MATERIAL_APPLY : materialViews [ i ] -> MV_OnMaterialApply ( materialDoc ) ; break ; case MATERIAL_SAVE : materialViews [ i ] -> MV_OnMaterialSaved ( materialDoc ) ; break ; case MATERIAL_SAVE_FILE : materialViews [ i ] -> MV_OnMaterialSaveFile ( va_arg ( argptr , const char * ) ) ; break ; case MATERIAL_ADD : materialViews [ i ] -> MV_OnMaterialAdd ( materialDoc ) ; break ; case MATERIAL_DELETE : materialViews [ i ] -> MV_OnMaterialDelete ( materialDoc ) ; break ; case MATERIAL_ADD_STAGE : materialViews [ i ] -> MV_OnMaterialStage@@ Add ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_DELETE_STAGE : materialViews [ i ] -> MV_OnMaterialStage@@ Delete ( materialDoc , va_arg ( argptr , int ) ) ; break ; case MATERIAL_MOVE_STAGE : { int from = va_arg ( argptr , int ) ; int to = va_arg ( argptr , int ) ; materialViews [ i ] -> MV_OnMaterialStage@@ Move ( materialDoc , from , to ) ; } break ; case MATERIAL_ATTRIBUTE_CHANGE : { int stage = va_arg ( argptr , int ) ; const char * attribName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialAttributeChanged ( materialDoc , stage , attribName ) ; } break ; case MATERIAL_NAME_CHANGE : { const char * oldName = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnMaterialNameChanged ( materialDoc , oldName ) ; } break ; case FILE_RELOAD : { const char * filename = va_arg ( argptr , const char * ) ; materialViews [ i ] -> MV_OnFileReload ( filename ) ; } break ; } va_end ( argptr ) ; } }
void MaterialDocManager :: MaterialChanged ( MaterialDoc * materialDoc ) { if ( ! inProgressMaterials . Get ( materialDoc -> name . c_str ( ) ) ) { inProgressMaterials . Set ( materialDoc -> name . c_str ( ) , materialDoc ) ; } NotifyViews ( materialDoc , MATERIAL_CHANGE ) ; }
void MaterialDocManager :: MaterialApplied ( MaterialDoc * materialDoc ) { NotifyViews ( materialDoc , MATERIAL_APPLY ) ; }
void MaterialDocManager :: MaterialSaved ( MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( materialDoc -> name . c_str ( ) , & tempDoc ) ) { idStr name = materialDoc -> name . c_str ( ) ; inProgressMaterials . Remove ( name . c_str ( ) ) ; NotifyViews ( materialDoc , MATERIAL_SAVE ) ; if ( materialDoc != currentMaterial ) delete materialDoc ; } }
void MaterialDocManager :: MaterialNameChanged ( const char * oldName , MaterialDoc * materialDoc ) { MaterialDoc * * tempDoc ; if ( inProgressMaterials . Get ( oldName , & tempDoc ) ) { inProgressMaterials . Set ( materialDoc -> name , * tempDoc ) ; inProgressMaterials . Remove ( oldName ) ; } NotifyViews ( materialDoc , MATERIAL_NAME_CHANGE , oldName ) ; }
void MaterialDocManager :: StageAdded ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_ADD_STAGE , stageNum ) ; }
void MaterialDocManager :: StageDeleted ( MaterialDoc * materialDoc , int stageNum ) { NotifyViews ( materialDoc , MATERIAL_DELETE_STAGE , stageNum ) ; }
void MaterialDocManager :: StageMoved ( MaterialDoc * materialDoc , int from , int to ) { NotifyViews ( materialDoc , MATERIAL_MOVE_STAGE , from , to ) ; }
void MaterialDocManager :: AttributeChanged ( MaterialDoc * materialDoc , int stage , const char * attribName ) { NotifyViews ( materialDoc , MATERIAL_ATTRIBUTE_CHANGE , stage , attribName ) ; }
Eigen :: Matrix4d dquatConjugate ( ) { Matrix4d dq_conj = Matrix4d :: Identity ( ) ; dq_conj ( 1 , 1 ) = - 1.0 ; dq_conj ( 2 , 2 ) = - 1.0 ; dq_conj ( 3 , 3 ) = - 1.0 ; return dq_conj ; }
Eigen :: Vector4d quatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Vector4d r ; r << w1 * w2 - v1 . dot ( v2 ) , v1 . cross ( v2 ) + w1 * v2 + w2 * v1 ; return r ; }
Eigen :: Matrix < double , 4 , 8 > dquatProduct ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { double w1 = q1 ( 0 ) ; double w2 = q2 ( 0 ) ; const auto & v1 = q1 . tail < 3 > ( ) ; const auto & v2 = q2 . tail < 3 > ( ) ; Matrix < double , 4 , 8 > dr ; dr . row ( 0 ) << w2 , - v2 . transpose ( ) , w1 , - v1 . transpose ( ) ; dr . row ( 1 ) << q2 ( 1 ) , q2 ( 0 ) , q2 ( 3 ) , - q2 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) , - q1 ( 3 ) , q1 ( 2 ) ; dr . row ( 2 ) << q2 ( 2 ) , - q2 ( 3 ) , q2 ( 0 ) , q2 ( 1 ) , q1 ( 2 ) , q1 ( 3 ) , q1 ( 0 ) , - q1 ( 1 ) ; dr . row ( 3 ) << q2 ( 3 ) , q2 ( 2 ) , - q2 ( 1 ) , q2 ( 0 ) , q1 ( 3 ) , - q1 ( 2 ) , q1 ( 1 ) , q1 ( 0 ) ; return dr ; }
Eigen :: Vector3d quatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Vector4d q_conj = quatConjugate ( q ) ; Vector4d v_rot = quatProduct ( q_times_v , q_conj ) ; Vector3d r = v_rot . bottomRows < 3 > ( ) ; return r ; }
Eigen :: Matrix < double , 3 , 7 > dquatRotateVec ( const Eigen :: Vector4d & q , const Eigen :: Vector3d & v ) { Matrix < double , 4 , 7 > dq ; dq << Matrix4d :: Identity ( ) , MatrixXd :: Zero ( 4 , 3 ) ; Matrix < double , 4 , 7 > dv = Matrix < double , 4 , 7 > :: Zero ( ) ; dv . bottomRight@@ Corner < 3 , 3 > ( ) = Matrix3d :: Identity ( ) ; Matrix < double , 8 , 7 > dqdv ; dqdv << dq , dv ; Vector4d v_quat ; v_quat << 0 , v ; Vector4d q_times_v = quatProduct ( q , v_quat ) ; Matrix < double , 4 , 8 > dq_times_v_tmp = dquatProduct ( q , v_quat ) ; Matrix < double , 4 , 7 > dq_times_v = dq_times_v_tmp * dqdv ; Matrix < double , 4 , 7 > dq_conj = dquatConjugate ( ) * dq ; Matrix < double , 8 , 7 > dq_times_v_dq_conj ; dq_times_v_dq_conj << dq_times_v , dq_conj ; Matrix < double , 4 , 8 > dv_rot_tmp = dquatProduct ( q_times_v , quatConjugate ( q ) ) ; Matrix < double , 4 , 7 > dv_rot = dv_rot_tmp * dq_times_v_dq_conj ; Eigen :: Matrix < double , 3 , 7 > dr = dv_rot . bottomRows ( 3 ) ; return dr ; }
Eigen :: Vector4d quatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { return quatProduct ( quatConjugate ( q1 ) , q2 ) ; }
Eigen :: Matrix < double , 4 , 8 > dquatDiff ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 ) { auto dr = dquatProduct ( quatConjugate ( q1 ) , q2 ) ; dr . block < 4 , 3 > ( 0 , 1 ) = - dr . block < 4 , 3 > ( 0 , 1 ) ; return dr ; }
Eigen :: Matrix < double , 1 , 11 > dquatDiffAxisInvar ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , const Eigen :: Vector3d & u ) { Vector4d r = quatDiff ( q1 , q2 ) ; Matrix < double , 4 , 8 > dr = dquatDiff ( q1 , q2 ) ; Matrix < double , 1 , 11 > de ; const auto & rvec = r . tail < 3 > ( ) ; de << 4.0 * r ( 0 ) * dr . row ( 0 ) + 4.0 * u . transpose ( ) * rvec * u . transpose ( ) * dr . block < 3 , 8 > ( 1 , 0 ) , 4.0 * u . transpose ( ) * rvec * rvec . transpose ( ) ; return de ; }
Eigen :: Vector4d slerp ( const Eigen :: Vector4d & q1 , const Eigen :: Vector4d & q2 , double interpolation_parameter ) { double lambda = ( q1 . transpose ( ) * q2 ) . value ( ) ; int q2_sign ; if ( lambda < 0.0 ) { lambda = - lambda ; q2_sign = - 1 ; } else { q2_sign = 1 ; } double r , s ; if ( std :: abs ( 1.0 - lambda ) < std :: numeric_limits < double > :: epsilon ( ) ) { r = 1.0 - interpolation_parameter ; s = interpolation_parameter ; } else { double alpha = std :: acos ( lambda ) ; double gamma = 1.0 / std :: sin ( alpha ) ; r = std :: sin ( ( 1.0 - interpolation_parameter ) * alpha ) * gamma ; s = std :: sin ( interpolation_parameter * alpha ) * gamma ; } Vector4d ret = q1 * r ; ret += q2_sign * q2 * s ; return ret ; }
Eigen :: Matrix3d uniformlyRandomRotmat ( std :: default_random_engine & generator ) { return axis2rotmat ( uniformlyRandomAxisAngle ( generator ) ) ; }
Eigen :: Vector3d uniformlyRandomRPY ( std :: default_random_engine & generator ) { return axis2rpy ( uniformlyRandomAxisAngle ( generator ) ) ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > quat2rpy ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > ret ; ret << std :: atan2 ( 2.0 * ( w * x + y * z ) , w * w + z * z - ( x * x + y * y ) ) , std :: asin ( 2.0 * ( w * y - z * x ) ) , std :: atan2 ( 2.0 * ( w * z + x * y ) , w * w + x * x - ( y * y + z * z ) ) ; return ret ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > quat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto w = q_normalized ( 0 ) ; auto x = q_normalized ( 1 ) ; auto y = q_normalized ( 2 ) ; auto z = q_normalized ( 3 ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > M ; M . row ( 0 ) << w * w + x * x - y * y - z * z , 2.0 * x * y - 2.0 * w * z , 2.0 * x * z + 2.0 * w * y ; M . row ( 1 ) << 2.0 * x * y + 2.0 * w * z , w * w + y * y - x * x - z * z , 2.0 * y * z - 2.0 * w * x ; M . row ( 2 ) << 2.0 * x * z - 2.0 * w * y , 2.0 * y * z + 2.0 * w * x , w * w + z * z - x * x - y * y ; return M ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > quat2axis ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto q_normalized = q . normalized ( ) ; auto s = std :: sqrt ( 1.0 - q_normalized ( 0 ) * q_normalized ( 0 ) ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > a ; a << q_normalized . template tail < 3 > ( ) / s , 2.0 * std :: acos ( q_normalized ( 0 ) ) ; return a ; }
template < typename Derived > Eigen :: Vector4d axis2quat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; auto axis = a . template head < 3 > ( ) ; auto angle = a ( 3 ) ; auto arg = 0.5 * angle ; auto c = std :: cos ( arg ) ; auto s = std :: sin ( arg ) ; Eigen :: Vector4d ret ; ret << c , s * axis ; return ret ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > axis2rotmat ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; const auto & axis = ( a . template head < 3 > ( ) ) / ( a . template head < 3 > ( ) ) . norm ( ) ; const auto & theta = a ( 3 ) ; auto x = axis ( 0 ) ; auto y = axis ( 1 ) ; auto z = axis ( 2 ) ; auto ctheta = std :: cos ( theta ) ; auto stheta = std :: sin ( theta ) ; auto c = 1 - ctheta ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R << ctheta + x * x * c , x * y * c - z * stheta , x * z * c + y * stheta , y * x * c + z * stheta , ctheta + y * y * c , y * z * c - x * stheta , z * x * c - y * stheta , z * y * c + x * stheta , ctheta + z * z * c ; return R ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > axis2rpy ( const Eigen :: MatrixBase < Derived > & a ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 4 ) ; return quat2rpy ( axis2quat ( a ) ) ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2axis ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; typename Derived :: Scalar theta = std :: acos ( ( R . trace ( ) - 1.0 ) / 2.0 ) ; Vector4d a ; if ( theta > std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ) { a << R ( 2 , 1 ) - R ( 1 , 2 ) , R ( 0 , 2 ) - R ( 2 , 0 ) , R ( 1 , 0 ) - R ( 0 , 1 ) , theta ; a . head < 3 > ( ) *= 1.0 / ( 2.0 * std :: sin ( theta ) ) ; } else { a << 1.0 , 0.0 , 0.0 , 0.0 ; } return a ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rotmat2quat ( const Eigen :: MatrixBase < Derived > & M ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Matrix < typename Derived :: Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < typename Derived :: Scalar , 4 , 1 > B = A * M . diagonal ( ) ; typename Matrix < typename Derived :: Scalar , 4 , 1 > :: Index ind , max_col ; typename Derived :: Scalar val = B . maxCoeff ( & ind , & max_col ) ; typename Derived :: Scalar w , x , y , z ; switch ( ind ) { case 0 : { w = sqrt ( 1.0 + val ) / 2.0 ; typename Derived :: Scalar w4 = w * 4.0 ; x = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / w4 ; y = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / w4 ; z = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / w4 ; break ; } case 1 : { double s = 2.0 * sqrt ( 1.0 + val ) ; w = ( M ( 2 , 1 ) - M ( 1 , 2 ) ) / s ; x = 0.25 * s ; y = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; z = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; break ; } case 2 : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 0 , 2 ) - M ( 2 , 0 ) ) / s ; x = ( M ( 0 , 1 ) + M ( 1 , 0 ) ) / s ; y = 0.25 * s ; z = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; break ; } default : { double s = 2.0 * ( sqrt ( 1.0 + val ) ) ; w = ( M ( 1 , 0 ) - M ( 0 , 1 ) ) / s ; x = ( M ( 0 , 2 ) + M ( 2 , 0 ) ) / s ; y = ( M ( 1 , 2 ) + M ( 2 , 1 ) ) / s ; z = 0.25 * s ; break ; } } Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > q ; q << w , x , y , z ; return q ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rotmat2rpy ( const Eigen :: MatrixBase < Derived > & R ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 , 3 ) ; using namespace std ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 1 > rpy ; rpy << atan2 ( R ( 2 , 1 ) , R ( 2 , 2 ) ) , atan2 ( - R ( 2 , 0 ) , sqrt ( pow ( R ( 2 , 1 ) , 2.0 ) + pow ( R ( 2 , 2 ) , 2.0 ) ) ) , atan2 ( R ( 1 , 0 ) , R ( 0 , 0 ) ) ; return rpy ; }
template < typename Derived > DLLEXPORT Eigen :: Matrix < typename Derived :: Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const Eigen :: MatrixBase < Derived > & R , int rotation_type ) { typedef typename Derived :: Scalar Scalar ; Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ret ; switch ( rotation_type ) { case 0 : return Eigen :: Matrix < Scalar , Eigen :: Dynamic , 1 > ( 0 , 1 ) ; case 1 : return rotmat2rpy ( R ) ; case 2 : return rotmat2quat ( R ) ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } }
template < typename Scalar > DLLEXPORT GradientVar < Scalar , Eigen :: Dynamic , 1 > rotmat2Representation ( const GradientVar < Scalar , SPACE_DIMENSION , SPACE_DIMENSION > & R , int rotation_type ) { GradientVar < Scalar , Eigen :: Dynamic , 1 > ret ( rotationRepresentationSize ( rotation_type ) , 1 , R . getNumVariables ( ) , R . maxOrder ( ) ) ; switch ( rotation_type ) { case 0 : break ; case 1 : ret . value ( ) = rotmat2rpy ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2rpy ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; case 2 : ret . value ( ) = rotmat2quat ( R . value ( ) ) ; if ( R . hasGradient ( ) ) { ret . gradient ( ) . value ( ) = drotmat2quat ( R . value ( ) , R . gradient ( ) . value ( ) ) ; } break ; default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; }
template < typename Derived > GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > expmap2quat ( const Eigen :: MatrixBase < Derived > & v , const int gradient_order ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; GradientVar < typename Derived :: Scalar , QUAT_SIZE , 1 > ret ( QUAT_SIZE , 1 , EXPMAP@@ _SIZE , gradient_order ) ; auto theta = v . norm ( ) ; if ( theta < pow ( std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) , 0.25 ) ) { ret . value ( ) = expmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } else { ret . value ( ) = expmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 0 ) { ret . gradient ( ) . value ( ) = dexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) = ddexpmap2quatNonDegenerate ( v , theta ) ; if ( gradient_order > 2 ) { throw std :: runtime_error ( " expmap2quat ▁ does ▁ not ▁ support ▁ gradient ▁ order ▁ larger ▁ than ▁ 2" ) ; } } } } return ret ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2axis ( const Eigen :: MatrixBase < Derived > & rpy ) { return quat2axis ( rpy2quat ( rpy ) ) ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 4 , 1 > rpy2quat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_2 = ( rpy / 2.0 ) . array ( ) ; auto s = rpy_2 . sin ( ) ; auto c = rpy_2 . cos ( ) ; Vector4d q ; q << c ( 0 ) * c ( 1 ) * c ( 2 ) + s ( 0 ) * s ( 1 ) * s ( 2 ) , s ( 0 ) * c ( 1 ) * c ( 2 ) - c ( 0 ) * s ( 1 ) * s ( 2 ) , c ( 0 ) * s ( 1 ) * c ( 2 ) + s ( 0 ) * c ( 1 ) * s ( 2 ) , c ( 0 ) * c ( 1 ) * s ( 2 ) - s ( 0 ) * s ( 1 ) * c ( 2 ) ; q /= q . norm ( ) + std :: numeric_limits < typename Derived :: Scalar > :: epsilon ( ) ; return q ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > rpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > R ; R . row ( 0 ) << c ( 2 ) * c ( 1 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; R . row ( 1 ) << s ( 2 ) * c ( 1 ) , s ( 2 ) * s ( 1 ) * s ( 0 ) + c ( 2 ) * c ( 0 ) , s ( 2 ) * s ( 1 ) * c ( 0 ) - c ( 2 ) * s ( 0 ) ; R . row ( 2 ) << - s ( 1 ) , c ( 1 ) * s ( 0 ) , c ( 1 ) * c ( 0 ) ; return R ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > drpy2rotmat ( const Eigen :: MatrixBase < Derived > & rpy ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , 3 ) ; auto rpy_array = rpy . array ( ) ; auto s = rpy_array . sin ( ) ; auto c = rpy_array . cos ( ) ; Eigen :: Matrix < typename Derived :: Scalar , 9 , 3 > dR ; dR . row ( 0 ) << 0 , c ( 2 ) * - s ( 1 ) , c ( 1 ) * - s ( 2 ) ; dR . row ( 1 ) << 0 , - s ( 1 ) * s ( 2 ) , c ( 2 ) * c ( 1 ) ; dR . row ( 2 ) << 0 , - c ( 1 ) , 0 ; dR . row ( 3 ) << c ( 2 ) * s ( 1 ) * c ( 0 ) - s ( 2 ) * - s ( 0 ) , c ( 2 ) * c ( 1 ) * s ( 0 ) , - s ( 2 ) * s ( 1 ) * s ( 0 ) - c ( 2 ) * c ( 0 ) ; dR . row ( 4 ) << s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * - s ( 0 ) , s ( 2 ) * c ( 1 ) * s ( 0 ) , c ( 2 ) * s ( 1 ) * s ( 0 ) - s ( 2 ) * c ( 0 ) ; dR . row ( 5 ) << c ( 1 ) * c ( 0 ) , - s ( 1 ) * s ( 0 ) , 0 ; dR . row ( 6 ) << c ( 2 ) * s ( 1 ) * - s ( 0 ) + s ( 2 ) * c ( 0 ) , c ( 2 ) * c ( 1 ) * c ( 0 ) , - s ( 2 ) * s ( 1 ) * c ( 0 ) + c ( 2 ) * s ( 0 ) ; dR . row ( 7 ) << s ( 2 ) * s ( 1 ) * - s ( 0 ) - c ( 2 ) * c ( 0 ) , s ( 2 ) * c ( 1 ) * c ( 0 ) , c ( 2 ) * s ( 1 ) * c ( 0 ) + s ( 2 ) * s ( 0 ) ; dR . row ( 8 ) << c ( 1 ) * - s ( 0 ) , - s ( 1 ) * c ( 0 ) , 0 ; return dR ; }
template < typename Derived > typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type dquat2rotmat ( const Eigen :: MatrixBase < Derived > & q ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , QUAT_SIZE ) ; typename Gradient < Matrix < typename Derived :: Scalar , 3 , 3 > , QUAT_SIZE > :: type ret ; typename Eigen :: MatrixBase < Derived > :: PlainObject qtilde ; typename Gradient < Derived , QUAT_SIZE > :: type dqtilde ; normalizeVec ( q , qtilde , & dqtilde ) ; typedef typename Derived :: Scalar Scalar ; Scalar w = qtilde ( 0 ) ; Scalar x = qtilde ( 1 ) ; Scalar y = qtilde ( 2 ) ; Scalar z = qtilde ( 3 ) ; ret << w , x , - y , - z , z , y , x , w , - y , z , - w , x , - z , y , x , - w , w , - x , y , - z , x , w , z , y , y , z , w , x , - x , - w , z , y , w , - x , - y , z ; ret *= 2.0 ; ret *= dqtilde ; return ret ; }
template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2rpy ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typename DerivedDR :: Index nq = dR . cols ( ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , RPY_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; ReturnType drpy ( RPY_SIZE , nq ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Scalar sqterm = R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ; using namespace std ; drpy . row ( 0 ) = ( R ( 2 , 2 ) * dR32_dq - R ( 2 , 1 ) * dR33_dq ) / sqterm ; Scalar sqrt_sqterm = sqrt ( sqterm ) ; drpy . row ( 1 ) = ( - sqrt_sqterm * dR31_dq + R ( 2 , 0 ) / sqrt_sqterm * ( R ( 2 , 1 ) * dR32_dq + R ( 2 , 2 ) * dR33_dq ) ) / ( R ( 2 , 0 ) * R ( 2 , 0 ) + R ( 2 , 1 ) * R ( 2 , 1 ) + R ( 2 , 2 ) * R ( 2 , 2 ) ) ; sqterm = R ( 0 , 0 ) * R ( 0 , 0 ) + R ( 1 , 0 ) * R ( 1 , 0 ) ; drpy . row ( 2 ) = ( R ( 0 , 0 ) * dR21_dq - R ( 1 , 0 ) * dR11_dq ) / sqterm ; return drpy ; }
template < typename DerivedR , typename DerivedDR > typename Gradient < Eigen :: Matrix < typename DerivedR :: Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type drotmat2quat ( const Eigen :: MatrixBase < DerivedR > & R , const Eigen :: MatrixBase < DerivedDR > & dR ) { EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE ( Eigen :: MatrixBase < DerivedR > , SPACE_DIMENSION , SPACE_DIMENSION ) ; EIGEN_STATIC_ASSERT ( Eigen :: MatrixBase < DerivedDR > :: RowsAtCompileTime == RotmatSize , THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE ) ; typedef typename DerivedR :: Scalar Scalar ; typedef typename Gradient < Eigen :: Matrix < Scalar , QUAT_SIZE , 1 > , DerivedDR :: ColsAtCompileTime > :: type ReturnType ; typename DerivedDR :: Index nq = dR . cols ( ) ; auto dR11_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 0 , R . rows ( ) ) ; auto dR12_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 1 , R . rows ( ) ) ; auto dR13_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 0 , 2 , R . rows ( ) ) ; auto dR21_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 0 , R . rows ( ) ) ; auto dR22_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 1 , R . rows ( ) ) ; auto dR23_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 1 , 2 , R . rows ( ) ) ; auto dR31_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 0 , R . rows ( ) ) ; auto dR32_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 1 , R . rows ( ) ) ; auto dR33_dq = getSubMatrixGradient < DerivedDR :: ColsAtCompileTime > ( dR , 2 , 2 , R . rows ( ) ) ; Matrix < Scalar , 4 , 3 > A ; A . row ( 0 ) << 1.0 , 1.0 , 1.0 ; A . row ( 1 ) << 1.0 , - 1.0 , - 1.0 ; A . row ( 2 ) << - 1.0 , 1.0 , - 1.0 ; A . row ( 3 ) << - 1.0 , - 1.0 , 1.0 ; Matrix < Scalar , 4 , 1 > B = A * R . diagonal ( ) ; typename Matrix < Scalar , 4 , 1 > :: Index ind , max_col ; Scalar val = B . maxCoeff ( & ind , & max_col ) ; ReturnType dq ( QUAT_SIZE , nq ) ; using namespace std ; switch ( ind ) { case 0 : { auto dvaldq = dR11_dq + dR22_dq + dR33_dq ; auto dwdq = dvaldq / ( 4.0 * sqrt ( 1.0 + val ) ) ; auto w = sqrt ( 1.0 + val ) / 2.0 ; auto wsquare4 = 4.0 * w * w ; dq . row ( 0 ) = dwdq ; dq . row ( 1 ) = ( ( dR32_dq - dR23_dq ) * w - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dwdq ) / wsquare4 ; dq . row ( 2 ) = ( ( dR13_dq - dR31_dq ) * w - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dwdq ) / wsquare4 ; dq . row ( 3 ) = ( ( dR21_dq - dR12_dq ) * w - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dwdq ) / wsquare4 ; break ; } case 1 : { auto dvaldq = dR11_dq - dR22_dq - dR33_dq ; auto s = 2.0 * sqrt ( 1.0 + val ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR32_dq - dR23_dq ) * s - ( R ( 2 , 1 ) - R ( 1 , 2 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = .25 * dsdq ; dq . row ( 2 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; break ; } case 2 : { auto dvaldq = - dR11_dq + dR22_dq - dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR13_dq - dR31_dq ) * s - ( R ( 0 , 2 ) - R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR12_dq + dR21_dq ) * s - ( R ( 0 , 1 ) + R ( 1 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = .25 * dsdq ; dq . row ( 3 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; break ; } default : { auto dvaldq = - dR11_dq - dR22_dq + dR33_dq ; auto s = 2.0 * ( sqrt ( 1.0 + val ) ) ; auto ssquare = s * s ; auto dsdq = dvaldq / sqrt ( 1.0 + val ) ; dq . row ( 0 ) = ( ( dR21_dq - dR12_dq ) * s - ( R ( 1 , 0 ) - R ( 0 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 1 ) = ( ( dR13_dq + dR31_dq ) * s - ( R ( 0 , 2 ) + R ( 2 , 0 ) ) * dsdq ) / ssquare ; dq . row ( 2 ) = ( ( dR23_dq + dR32_dq ) * s - ( R ( 1 , 2 ) + R ( 2 , 1 ) ) * dsdq ) / ssquare ; dq . row ( 3 ) = .25 * dsdq ; break ; } } return dq ; }
template < typename Derived > Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > vectorToSkewSymmetric ( const Eigen :: MatrixBase < Derived > & p ) { EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE ( Eigen :: MatrixBase < Derived > , SPACE_DIMENSION ) ; Eigen :: Matrix < typename Derived :: Scalar , 3 , 3 > ret ; ret << 0.0 , - p ( 2 ) , p ( 1 ) , p ( 2 ) , 0.0 , - p ( 0 ) , - p ( 1 ) , p ( 0 ) , 0.0 ; return ret ; }
template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > dcrossProduct ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , 3 , Eigen :: Dynamic > ret ( 3 , da . cols ( ) ) ; ret . noalias ( ) = da . colwise ( ) . cross ( b ) ; ret . noalias ( ) -= db . colwise ( ) . cross ( a ) ; return ret ; }
template < typename Derived > DLLEXPORT GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > angularvel2RepresentationDotMatrix ( int rotation_type , const Eigen :: MatrixBase < Derived > & qrot , int gradient_order ) { GradientVar < typename Derived :: Scalar , Eigen :: Dynamic , SPACE_DIMENSION > ret ( qrot . rows ( ) , SPACE_DIMENSION , qrot . rows ( ) , gradient_order ) ; switch ( rotation_type ) { case 0 : break ; case 1 : { if ( gradient_order > 1 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , & ret . gradient ( ) . gradient ( ) . value ( ) ) ; } else if ( gradient_order > 0 ) { angularvel2rpydotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) , ( MatrixXd * ) nullptr ) ; } else { angularvel2rpydotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr , ( MatrixXd * ) nullptr ) ; } break ; } case 2 : { if ( gradient_order > 1 ) { ret . gradient ( ) . gradient ( ) . value ( ) . setZero ( ) ; } if ( gradient_order > 0 ) { angularvel2quatdotMatrix ( qrot , ret . value ( ) , & ret . gradient ( ) . value ( ) ) ; } else { angularvel2quatdotMatrix ( qrot , ret . value ( ) , ( MatrixXd * ) nullptr ) ; } break ; } default : throw std :: runtime_error ( " rotation ▁ representation ▁ type ▁ not ▁ recognized " ) ; } return ret ; }
template < typename DerivedM > typename TransformSpatial < DerivedM > :: type transformSpatialMotion ( const Eigen :: Transform < typename DerivedM :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedM > & M ) { Eigen :: Matrix < typename DerivedM :: Scalar , TWIST_SIZE , DerivedM :: ColsAtCompileTime > ret ( TWIST_SIZE , M . cols ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) = T . linear ( ) * M . template topRows < 3 > ( ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = - ret . template topRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) += T . linear ( ) * M . template bottomRows < 3 > ( ) ; return ret ; }
template < typename DerivedF > typename TransformSpatial < DerivedF > :: type transformSpatialForce ( const Eigen :: Transform < typename DerivedF :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedF > & F ) { Eigen :: Matrix < typename DerivedF :: Scalar , TWIST_SIZE , DerivedF :: ColsAtCompileTime > ret ( TWIST_SIZE , F . cols ( ) ) ; ret . template bottomRows < 3 > ( ) . noalias ( ) = T . linear ( ) * F . template bottomRows < 3 > ( ) . eval ( ) ; ret . template topRows < 3 > ( ) = - ret . template bottomRows < 3 > ( ) . colwise ( ) . cross ( T . translation ( ) ) ; ret . template topRows < 3 > ( ) . noalias ( ) += T . linear ( ) * F . template topRows < 3 > ( ) ; return ret ; }
template < typename DerivedI > GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > transformSpatialInertia ( const Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > & T_current_to_new , const typename Gradient < typename Eigen :: Transform < typename DerivedI :: Scalar , SPACE_DIMENSION , Eigen :: Isometry > :: MatrixType , Eigen :: Dynamic > :: type * dT_current_to_new , const Eigen :: MatrixBase < DerivedI > & I ) { int gradient_order ; typename DerivedI :: Index nq ; if ( dT_current_to_new ) { gradient_order = 1 ; nq = dT_current_to_new -> cols ( ) ; } else { nq = 0 ; gradient_order = 0 ; } GradientVar < typename DerivedI :: Scalar , TWIST_SIZE , TWIST_SIZE > ret ( TWIST_SIZE , TWIST_SIZE , nq , gradient_order ) ; auto I_half_transformed = transformSpatialForce ( T_current_to_new , I ) ; ret . value ( ) = transformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) ) ; if ( gradient_order > 0 ) { auto dI = Eigen :: Matrix < typename DerivedI :: Scalar , DerivedI :: SizeAtCompileTime , Eigen :: Dynamic > :: Zero ( I . size ( ) , nq ) . eval ( ) ; auto dI_half_transformed = dTransformSpatialForce ( T_current_to_new , I , * dT_current_to_new , dI ) ; auto dI_half_transformed_transpose = transposeGrad ( dI_half_transformed , I_half_transformed . rows ( ) ) ; ret . gradient ( ) . value ( ) = dTransformSpatialForce ( T_current_to_new , I_half_transformed . transpose ( ) , * dT_current_to_new , dI_half_transformed_transpose ) ; } return ret ; }
template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; }
template < typename DerivedA , typename DerivedB > typename TransformSpatial < DerivedB > :: type crossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b ) { typename TransformSpatial < DerivedB > :: type ret ( TWIST_SIZE , b . cols ( ) ) ; ret . template topRows < 3 > ( ) = - b . template topRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; ret . template topRows < 3 > ( ) -= b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template bottomRows < 3 > ( ) ) ; ret . template bottomRows < 3 > ( ) = - b . template bottomRows < 3 > ( ) . colwise ( ) . cross ( a . template topRows < 3 > ( ) ) ; return ret ; }
template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialMotion ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = - da . row ( 2 ) * b [ 1 ] + da . row ( 1 ) * b [ 2 ] - a [ 2 ] * db . row ( 1 ) + a [ 1 ] * db . row ( 2 ) ; ret . row ( 1 ) = da . row ( 2 ) * b [ 0 ] - da . row ( 0 ) * b [ 2 ] + a [ 2 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 2 ) ; ret . row ( 2 ) = - da . row ( 1 ) * b [ 0 ] + da . row ( 0 ) * b [ 1 ] - a [ 1 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 1 ) ; ret . row ( 3 ) = - da . row ( 5 ) * b [ 1 ] + da . row ( 4 ) * b [ 2 ] - da . row ( 2 ) * b [ 4 ] + da . row ( 1 ) * b [ 5 ] - a [ 5 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 2 ) - a [ 2 ] * db . row ( 4 ) + a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = da . row ( 5 ) * b [ 0 ] - da . row ( 3 ) * b [ 2 ] + da . row ( 2 ) * b [ 3 ] - da . row ( 0 ) * b [ 5 ] + a [ 5 ] * db . row ( 0 ) - a [ 3 ] * db . row ( 2 ) + a [ 2 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = - da . row ( 4 ) * b [ 0 ] + da . row ( 3 ) * b [ 1 ] - da . row ( 1 ) * b [ 3 ] + da . row ( 0 ) * b [ 4 ] - a [ 4 ] * db . row ( 0 ) + a [ 3 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 4 ) ; return ret ; }
template < typename DerivedA , typename DerivedB > Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > dCrossSpatialForce ( const Eigen :: MatrixBase < DerivedA > & a , const Eigen :: MatrixBase < DerivedB > & b , const typename Gradient < DerivedA , Eigen :: Dynamic > :: type & da , const typename Gradient < DerivedB , Eigen :: Dynamic > :: type & db ) { Eigen :: Matrix < typename DerivedA :: Scalar , TWIST_SIZE , Eigen :: Dynamic > ret ( TWIST_SIZE , da . cols ( ) ) ; ret . row ( 0 ) = da . row ( 2 ) * b [ 1 ] - da . row ( 1 ) * b [ 2 ] + da . row ( 5 ) * b [ 4 ] - da . row ( 4 ) * b [ 5 ] + a [ 2 ] * db . row ( 1 ) - a [ 1 ] * db . row ( 2 ) + a [ 5 ] * db . row ( 4 ) - a [ 4 ] * db . row ( 5 ) ; ret . row ( 1 ) = - da . row ( 2 ) * b [ 0 ] + da . row ( 0 ) * b [ 2 ] - da . row ( 5 ) * b [ 3 ] + da . row ( 3 ) * b [ 5 ] - a [ 2 ] * db . row ( 0 ) + a [ 0 ] * db . row ( 2 ) - a [ 5 ] * db . row ( 3 ) + a [ 3 ] * db . row ( 5 ) ; ret . row ( 2 ) = da . row ( 1 ) * b [ 0 ] - da . row ( 0 ) * b [ 1 ] + da . row ( 4 ) * b [ 3 ] - da . row ( 3 ) * b [ 4 ] + a [ 1 ] * db . row ( 0 ) - a [ 0 ] * db . row ( 1 ) + a [ 4 ] * db . row ( 3 ) - a [ 3 ] * db . row ( 4 ) ; ret . row ( 3 ) = da . row ( 2 ) * b [ 4 ] - da . row ( 1 ) * b [ 5 ] + a [ 2 ] * db . row ( 4 ) - a [ 1 ] * db . row ( 5 ) ; ret . row ( 4 ) = - da . row ( 2 ) * b [ 3 ] + da . row ( 0 ) * b [ 5 ] - a [ 2 ] * db . row ( 3 ) + a [ 0 ] * db . row ( 5 ) ; ret . row ( 5 ) = da . row ( 1 ) * b [ 3 ] - da . row ( 0 ) * b [ 4 ] + a [ 1 ] * db . row ( 3 ) - a [ 0 ] * db . row ( 4 ) ; ret = - ret ; return ret ; }
template < typename DerivedS , typename DerivedQdotToV > typename DHomogTrans < DerivedQdotToV > :: type dHomogTrans ( const Eigen :: Transform < typename DerivedQdotToV :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedS > & S , const Eigen :: MatrixBase < DerivedQdotToV > & qdot_to_v ) { const int nq_at_compile_time = DerivedQdotToV :: ColsAtCompileTime ; typename DerivedQdotToV :: Index nq = qdot_to_v . cols ( ) ; auto qdot_to_twist = ( S * qdot_to_v ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedQdotToV :: Scalar , numel , nq_at_compile_time > ret ( numel , nq ) ; const auto & Rx = T . linear ( ) . col ( 0 ) ; const auto & Ry = T . linear ( ) . col ( 1 ) ; const auto & Rz = T . linear ( ) . col ( 2 ) ; const auto & qdot_to_omega_x = qdot_to_twist . row ( 0 ) ; const auto & qdot_to_omega_y = qdot_to_twist . row ( 1 ) ; const auto & qdot_to_omega_z = qdot_to_twist . row ( 2 ) ; ret . template middleRows < 3 > ( 0 ) = - Rz * qdot_to_omega_y + Ry * qdot_to_omega_z ; ret . row ( 3 ) . setZero ( ) ; ret . template middleRows < 3 > ( 4 ) = Rz * qdot_to_omega_x - Rx * qdot_to_omega_z ; ret . row ( 7 ) . setZero ( ) ; ret . template middleRows < 3 > ( 8 ) = - Ry * qdot_to_omega_x + Rx * qdot_to_omega_y ; ret . row ( 11 ) . setZero ( ) ; ret . template middleRows < 3 > ( 12 ) = T . linear ( ) * qdot_to_twist . bottomRows ( 3 ) ; ret . row ( 15 ) . setZero ( ) ; return ret ; }
template < typename DerivedDT > typename DHomogTrans < DerivedDT > :: type dHomogTransInv ( const Eigen :: Transform < typename DerivedDT :: Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedDT > & dT ) { typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; auto dinvT_R = transposeGrad ( dR , R . rows ( ) ) ; auto dinvT_p = ( - R . transpose ( ) * dp - matGradMult ( dinvT_R , p ) ) . eval ( ) ; const int numel = HOMOGENEOUS_TRANSFORM_SIZE ; Eigen :: Matrix < typename DerivedDT :: Scalar , numel , DerivedDT :: ColsAtCompileTime > ret ( numel , nq ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_R , rows , R_cols , T . Rows ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dinvT_p , rows , p_cols , T . Rows ) ; const int last_row = 3 ; for ( int col = 0 ; col < T . HDim ; col ++ ) { ret . row ( last_row + col * T . Rows ) . setZero ( ) ; } return ret ; }
template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type dTransformSpatialMotion ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime , 1 > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXomega_col = ( R * Xomega_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col + matGradMult ( dR , Xomega_col ) ) . eval ( ) ; auto dv_part_col = ( R * dXv_col + matGradMult ( dR , Xv_col ) ) . eval ( ) ; dv_part_col += dp . colwise ( ) . cross ( RXomega_col ) ; dv_part_col -= domega_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; }
template < typename Scalar , typename DerivedX , typename DerivedDT , typename DerivedDX > typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type dTransformSpatialForce ( const Eigen :: Transform < Scalar , 3 , Eigen :: Isometry > & T , const Eigen :: MatrixBase < DerivedX > & X , const Eigen :: MatrixBase < DerivedDT > & dT , const Eigen :: MatrixBase < DerivedDX > & dX ) { assert ( dT . cols ( ) == dX . cols ( ) ) ; typename DerivedDT :: Index nq = dT . cols ( ) ; const auto & R = T . linear ( ) ; const auto & p = T . translation ( ) ; std :: array < int , 3 > rows = { 0 , 1 , 2 } ; std :: array < int , 3 > R_cols = { 0 , 1 , 2 } ; std :: array < int , 1 > p_cols = { 3 } ; auto dR = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , R_cols , T . Rows ) ; auto dp = getSubMatrixGradient < Eigen :: Dynamic > ( dT , rows , p_cols , T . Rows ) ; typename Gradient < DerivedX , DerivedDX :: ColsAtCompileTime > :: type ret ( X . size ( ) , nq ) ; std :: array < int , 3 > Xomega_rows = { 0 , 1 , 2 } ; std :: array < int , 3 > Xv_rows = { 3 , 4 , 5 } ; for ( int col = 0 ; col < X . cols ( ) ; col ++ ) { auto Xomega_col = X . template block < 3 , 1 > ( 0 , col ) ; auto Xv_col = X . template block < 3 , 1 > ( 3 , col ) ; auto RXv_col = ( R * Xv_col ) . eval ( ) ; std :: array < int , 1 > col_array = { col } ; auto dXomega_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xomega_rows , col_array , X . rows ( ) ) ; auto dXv_col = getSubMatrixGradient < Eigen :: Dynamic > ( dX , Xv_rows , col_array , X . rows ( ) ) ; auto domega_part_col = ( R * dXomega_col ) . eval ( ) ; domega_part_col += matGradMult ( dR , Xomega_col ) ; auto dv_part_col = ( R * dXv_col ) . eval ( ) ; dv_part_col += matGradMult ( dR , Xv_col ) ; domega_part_col += dp . colwise ( ) . cross ( RXv_col ) ; domega_part_col -= dv_part_col . colwise ( ) . cross ( p ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , domega_part_col , Xomega_rows , col_array , X . rows ( ) ) ; setSubMatrixGradient < Eigen :: Dynamic > ( ret , dv_part_col , Xv_rows , col_array , X . rows ( ) ) ; } return ret ; }
