void heapsort ( Comparable * A [ ] , int n ) { std :: cout << " Getting ▁ started ▁ with ▁ array : " << std :: endl ; for ( int j = 0 ; j < n ; j ++ ) std :: cout << * A [ j ] << " ▁ " ; std :: cout << std :: endl ; MaxHeap H ( A , n , n ) ; std :: cout << " Now , ▁ ready ▁ to ▁ unpack ▁ the ▁ heap " << std :: endl ; for ( int i = 0 ; i < n ; i ++ ) H . removemax ( ) ; }
bool sorttest ( int array [ ] , int n , int thresh@@ old ) { Comparable * A [ n ] ; int i ; cout << " We ▁ came ▁ in ▁ with ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << array [ i ] << " ▁ " ; std :: cout << std :: endl ; for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new Int ( array [ i ] ) ; } cout << " We ▁ are ▁ going ▁ to ▁ call ▁ Heapsort ▁ with ▁ this ▁ array : " << endl ; for ( i = 0 ; i < n ; i ++ ) std :: cout << A [ i ] << " ▁ " ; std :: cout << std :: endl ; heapsort ( A , n ) ; if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } for ( i = 0 ; i < n ; ++ i ) { A [ i ] = new KVPair ( array [ i ] , & array [ i ] ) ; } if ( ! checkorder ( A , n ) ) return false ; for ( i = 0 ; i < n ; ++ i ) { delete A [ i ] ; } delete [ ] array ; return true ; }
void gbump ( int n ) { base :: gbump ( n ) ; }
virtual int_type pbackfail ( int_type c = traits_type :: eof ( ) ) { return base :: pbackfail ( c ) ; }
int main ( ) { { std :: ifstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; } { std :: fstream bs ( " underflow . dat " ) ; test_buf f ( bs . rdbuf ( ) ) ; assert ( f . sbumpc ( ) == L ' 1' ) ; assert ( f . sgetc ( ) == L ' 2' ) ; assert ( f . pbackfail ( L ' a ' ) == test_buf :: traits_type :: eof ( ) ) ; assert ( f . sbumpc ( ) == L ' 2' ) ; assert ( f . sgetc ( ) == L ' 3' ) ; } }
int main ( ) { ofstream fout ( " ride . out " ) ; ifstream fin ( " ride . in " ) ; string a , b ; fin >> a >> b ; int anum = 1 , bnum = 1 ; for ( char c : a ) anum *= c - ' A ' + 1 ; for ( char c : b ) bnum *= c - ' A ' + 1 ; if ( anum % 47 == bnum % 47 ) fout << " GO " << endl ; else fout << " STAY " << endl ; return 0 ; }
JSValue toJS ( ExecState * exec , JSDOMGlobalObject * globalObject , Document * document ) { if ( ! document ) return jsNull ( ) ; JSDOMWrapper * wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; if ( DOMWindow * domWindow = document -> domWindow ( ) ) { globalObject = toJSDOM@@ Window ( toJS ( exec , domWindow ) ) ; wrapper = getCachedWrapper ( currentWorld ( exec ) , document ) ; if ( wrapper ) return wrapper ; } if ( document -> isHTMLDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , HTMLDocument , document ) ; ( SVG ) else if ( document -> isSVGDocument ( ) ) wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , SVGDocument , document ) ; else wrapper = CREATE_DOM_WRAPPER ( exec , globalObject , Document , document ) ; if ( ! document -> frame ( ) ) { size_t nodeCount = 0 ; for ( Node * n = document ; n ; n = n -> traverse@@ NextNode ( ) ) nodeCount ++ ; exec -> heap ( ) -> report@@ Extra@@ MemoryCost ( nodeCount * sizeof ( Node ) ) ; } return wrapper ; }
public : hal ( ) { I :: init ( ) ; }
virtual void write ( const unsigned char data ) { RW :: write ( data ) ; }
virtual unsigned char read ( ) { return RW :: read ( ) ; }
static void init ( const long baudRate ) { long ubrr = F_CPU / 16 / baudRate - 1 ; UBR@@ R0@@ H = ubrr >> 8 ; UBR@@ R0L = ubrr ; UCSR0@@ B = ( 1 << RXEN@@ 0 ) | ( 1 << TXEN0 ) ; UCSR0@@ C = ( 3 << UCS@@ Z00 ) ; }
public : static void write ( const unsigned char data ) { while ( ! ( UCSR0A & ( 1 << UD@@ RE0 ) ) ) ; UDR0 = data ; }
static unsigned char read ( ) { while ( ! ( UCSR0A & ( 1 << RXC@@ 0 ) ) ) ; return UDR0 ; }
static void write ( unsigned char data ) { SPDR = data ; while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; }
static unsigned char read ( ) { while ( ! ( SPSR & ( 1 << SPIF ) ) ) ; return SPDR ; }
static void init ( ) { DDRB |= ( 1 << PB3 ) | ( 1 << PB5 ) | ( 1 << PB2 ) ; SPCR = ( 1 << SPE ) | ( 1 << MSTR ) | ( 1 << SPR0 ) ; }
static void init ( ) { DDRB |= ( 1 << PB4 ) ; SPCR = ( 1 << SPE ) ; }
public : USART ( const long Rate ) { T :: init ( Rate ) ; }
static bool copyData ( QIODevice & inFile , QIODevice & outFile ) { while ( ! inFile . atEnd ( ) ) { char buf [ 4096 ] ; qint64 readLen = inFile . read ( buf , 4096 ) ; if ( readLen <= 0 ) return false ; if ( outFile . write ( buf , readLen ) != readLen ) return false ; } return true ; }
void CG_InitMarkPolys ( void ) { int i ; memset ( cg_markPolys , 0 , sizeof ( cg_markPolys ) ) ; cg_activeMarkPolys . nextMark = & cg_activeMarkPolys ; cg_activeMarkPolys . prevMark = & cg_activeMarkPolys ; cg_freeMarkPolys = cg_markPolys ; for ( i = 0 ; i < MAX_MARK_POLYS - 1 ; i ++ ) { cg_markPolys [ i ] . nextMark = & cg_markPolys [ i + 1 ] ; } }
void CG_FreeMarkPoly ( markPoly_t * le ) { if ( ! le -> prevMark ) { CG_Error ( " CG _ FreeLocalEntity : ▁ not ▁ active " ) ; } le -> prevMark -> nextMark = le -> nextMark ; le -> nextMark -> prevMark = le -> prevMark ; le -> nextMark = cg_freeMarkPolys ; cg_freeMarkPolys = le ; }
markPoly_t * CG_AllocMark ( void ) { markPoly_t * le ; int time ; if ( ! cg_freeMarkPolys ) { time = cg_activeMarkPolys . prevMark -> time ; while ( cg_activeMarkPolys . prevMark && time == cg_activeMarkPolys . prevMark -> time ) { CG_FreeMarkPoly ( cg_activeMarkPolys . prevMark ) ; } } le = cg_freeMarkPolys ; cg_freeMarkPolys = cg_freeMarkPolys -> nextMark ; memset ( le , 0 , sizeof ( * le ) ) ; le -> nextMark = cg_activeMarkPolys . nextMark ; le -> prevMark = & cg_activeMarkPolys ; cg_activeMarkPolys . nextMark -> prevMark = le ; cg_activeMarkPolys . nextMark = le ; return le ; }
void CG_ImpactMark ( qhandle@@ _t markShader , const vec3_t origin , const vec3_t dir , float orientation , float red , float green , float blue , float alpha , qboolean alphaFade , float radius , qboolean temporary ) { vec3_t axis [ 3 ] ; float texCoordScale ; vec3_t originalPoints [ 4 ] ; byte colors [ 4 ] ; int i , j ; int numFragments ; markFrag@@ ment_t markFragments [ MAX_MARK_FRAGMENTS ] , * mf ; vec3_t markPoints [ MAX_MARK_POINTS ] ; vec3_t projection ; if ( ! cg_addMarks . integer ) { return ; } if ( radius <= 0 ) { CG_Error ( " CG _ ImpactMark ▁ called ▁ with ▁ < = ▁ 0 ▁ radius " ) ; } VectorNormal@@ ize2 ( dir , axis [ 0 ] ) ; Perpend@@ icular@@ Vector ( axis [ 1 ] , axis [ 0 ] ) ; Rotate@@ PointAround@@ Vector ( axis [ 2 ] , axis [ 0 ] , axis [ 1 ] , orientation ) ; Cross@@ Product ( axis [ 0 ] , axis [ 2 ] , axis [ 1 ] ) ; texCoordScale = 0.5 * 1.0 / radius ; for ( i = 0 ; i < 3 ; i ++ ) { originalPoints [ 0 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 1 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] - radius * axis [ 2 ] [ i ] ; originalPoints [ 2 ] [ i ] = origin [ i ] + radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; originalPoints [ 3 ] [ i ] = origin [ i ] - radius * axis [ 1 ] [ i ] + radius * axis [ 2 ] [ i ] ; } VectorScale ( dir , - 20 , projection ) ; numFragments = cgi_@@ CM_MarkFragments ( 4 , ( const float ( * ) [ 3 ] ) originalPoints , projection , MAX_MARK_POINTS , markPoints [ 0 ] , MAX_MARK_FRAGMENTS , markFragments ) ; colors [ 0 ] = red * 255 ; colors [ 1 ] = green * 255 ; colors [ 2 ] = blue * 255 ; colors [ 3 ] = alpha * 255 ; for ( i = 0 , mf = markFragments ; i < numFragments ; i ++ , mf ++ ) { polyVert_t * v ; polyVert_t verts [ MAX_VERTS_ON_POLY ] ; markPoly_t * mark ; if ( mf -> numPoints > MAX_VERTS_ON_POLY ) { mf -> numPoints = MAX_VERTS_ON_POLY ; } for ( j = 0 , v = verts ; j < mf -> numPoints ; j ++ , v ++ ) { vec3_t delta ; VectorCopy ( markPoints [ mf -> firstPoint + j ] , v -> xyz ) ; VectorSubtract ( v -> xyz , origin , delta ) ; v -> st [ 0 ] = 0.5f + DotProduct ( delta , axis [ 1 ] ) * texCoordScale ; v -> st [ 1 ] = 0.5f + DotProduct ( delta , axis [ 2 ] ) * texCoordScale ; for ( int k = 0 ; k < 4 ; k ++ ) { v -> modulate [ k ] = colors [ k ] ; } } if ( temporary ) { cgi_R_AddPolyToScene ( markShader , mf -> numPoints , verts ) ; continue ; } mark = CG_AllocMark ( ) ; mark -> time = cg . time ; mark -> alphaFade = alphaFade ; mark -> markShader = markShader ; mark -> poly . numVerts = mf -> numPoints ; mark -> color [ 0 ] = colors [ 0 ] ; mark -> color [ 1 ] = colors [ 1 ] ; mark -> color [ 2 ] = colors [ 2 ] ; mark -> color [ 3 ] = colors [ 3 ] ; memcpy ( mark -> verts , verts , mf -> numPoints * sizeof ( verts [ 0 ] ) ) ; } }
void CG_AddMarks ( void ) { int j ; markPoly_t * mp , * next ; int t ; int fade ; if ( ! cg_addMarks . integer ) { return ; } mp = cg_activeMarkPolys . nextMark ; for ( ; mp != & cg_activeMarkPolys ; mp = next ) { next = mp -> nextMark ; if ( cg . time > mp -> time + MARK_TOTAL_TIME ) { CG_FreeMarkPoly ( mp ) ; continue ; } t = mp -> time + MARK_TOTAL_TIME - cg . time ; if ( t < MARK_FADE_TIME ) { fade = 255 * t / MARK_FADE_TIME ; if ( mp -> alphaFade ) { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 3 ] = fade ; } } else { float f = ( float ) t / MARK_FADE_TIME ; for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] * f ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] * f ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] * f ; } } } else { for ( j = 0 ; j < mp -> poly . numVerts ; j ++ ) { mp -> verts [ j ] . modulate [ 0 ] = mp -> color [ 0 ] ; mp -> verts [ j ] . modulate [ 1 ] = mp -> color [ 1 ] ; mp -> verts [ j ] . modulate [ 2 ] = mp -> color [ 2 ] ; } } cgi_R_AddPolyToScene ( mp -> markShader , mp -> poly . numVerts , mp -> verts ) ; } }
TEST ( ModelInstantiatorTest , Brp@@ Prob ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " P = ? ▁ [ F ▁ s = 5 ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; EXPECT_FALSE ( dtmc -> hasRewardModel ( ) ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.8 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.2989@@ 2789@@ 41 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_EQ ( 0.0 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] ) ; } { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: one < storm :: RationalFunctionCoefficient > ( ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.015880558@@ 32 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } }
TEST ( ModelInstantiatorTest , Brp_Rew ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pdtmc / brp16_2 . pm " ; std :: string formulaAsString = " R = ? ▁ [ F ▁ ( ( s = 5 ) ▁ | ▁ ( s = 0 & srep = 3 ) ) ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> dtmc = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Dtmc < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Dtmc < storm :: RationalFunction > , storm :: models :: sparse :: Dtmc < double >> modelInstantiator ( * dtmc ) ; { std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & pL = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pL " ) ; ASSERT_NE ( pL , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & pK = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " pK " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOMsg = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOMsg " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & TOAck = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " TOAck " ) ; ASSERT_NE ( pK , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( pL , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.9 ) ) ) ; valuation . insert ( std :: make_pair ( pK , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOMsg , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.3 ) ) ) ; valuation . insert ( std :: make_pair ( TOAck , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.5 ) ) ) ; storm :: models :: sparse :: Dtmc < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < dtmc -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < dtmc -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : dtmc -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } ASSERT_TRUE ( instantiated . hasUniqueRewardModel ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasState@@ Rewards ( ) ) ; EXPECT_FALSE ( instantiated . getUniqueRewardModel ( ) . hasTransition@@ Rewards ( ) ) ; EXPECT_TRUE ( instantiated . getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; ASSERT_TRUE ( dtmc -> getUniqueRewardModel ( ) . hasStateActionRewards ( ) ) ; std :: size_t stateActionEntries = dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ; ASSERT_EQ ( stateActionEntries , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) . size ( ) ) ; for ( std :: size_t i = 0 ; i < stateActionEntries ; ++ i ) { double evaluatedValue = carl :: toDouble ( dtmc -> getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiated . getUniqueRewardModel ( ) . getStateActionRewardVector ( ) [ i ] ) ; } EXPECT_EQ ( dtmc -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( dtmc -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseDtmcPrctlModelChecker < storm :: models :: sparse :: Dtmc < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 1.308@@ 32449@@ 5 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; } }
TEST ( ModelInstantiatorTest , Consens@@ us ) { carl :: VariablePool :: getInstance ( ) . clear ( ) ; std :: string programFile = STORM_TEST_RESOURCES_DIR " / pmdp / coin2_2 . nm " ; std :: string formulaAsString = " Pmin = ? ▁ [ F ▁ \ " finished \ " & \ " all _ coins _ equal _ 1 \ " ▁ ] " ; storm :: prism :: Program program = storm :: api :: parseProgram ( programFile ) ; program . checkValidity ( ) ; std :: vector < std :: shared_ptr < storm :: logic :: Formula const >> formulas = storm :: api :: extractFormulasFromProperties ( storm :: api :: parsePropertiesForPrismProgram ( formulaAsString , program ) ) ; ASSERT_TRUE ( formulas . size ( ) == 1 ) ; storm :: generator :: NextStateGeneratorOptions options ( * formulas . front ( ) ) ; std :: shared_ptr < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> mdp = storm :: builder :: ExplicitModelBuilder < storm :: RationalFunction > ( program , options ) . build ( ) -> as < storm :: models :: sparse :: Mdp < storm :: RationalFunction >> ( ) ; storm :: utility :: ModelInstantiator < storm :: models :: sparse :: Mdp < storm :: RationalFunction > , storm :: models :: sparse :: Mdp < double >> modelInstantiator ( * mdp ) ; std :: map < storm :: RationalFunctionVariable , storm :: RationalFunctionCoefficient > valuation ; storm :: RationalFunctionVariable const & p1 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p1" ) ; ASSERT_NE ( p1 , carl :: Variable :: NO_VARIABLE ) ; storm :: RationalFunctionVariable const & p2 = carl :: VariablePool :: getInstance ( ) . findVariableWithName ( " p2" ) ; ASSERT_NE ( p2 , carl :: Variable :: NO_VARIABLE ) ; valuation . insert ( std :: make_pair ( p1 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.51 ) ) ) ; valuation . insert ( std :: make_pair ( p2 , storm :: utility :: convertNumber < storm :: RationalFunctionCoefficient > ( 0.49 ) ) ) ; storm :: models :: sparse :: Mdp < double > const & instantiated ( modelInstantiator . instantiate ( valuation ) ) ; ASSERT_EQ ( mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) , instantiated . getTransitionMatrix ( ) . getRowGroupIndices ( ) ) ; for ( std :: size_t rowGroup = 0 ; rowGroup < mdp -> getTransitionMatrix ( ) . getRowGroupCount ( ) ; ++ rowGroup ) { for ( std :: size_t row = mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup ] ; row < mdp -> getTransitionMatrix ( ) . getRowGroupIndices ( ) [ rowGroup + 1 ] ; ++ row ) { auto instantiatedEntry = instantiated . getTransitionMatrix ( ) . getRow ( row ) . begin ( ) ; for ( auto const & paramEntry : mdp -> getTransitionMatrix ( ) . getRow ( row ) ) { EXPECT_EQ ( paramEntry . getColumn ( ) , instantiatedEntry -> getColumn ( ) ) ; double evaluatedValue = carl :: toDouble ( paramEntry . getValue ( ) . evaluate ( valuation ) ) ; EXPECT_EQ ( evaluatedValue , instantiatedEntry -> getValue ( ) ) ; ++ instantiatedEntry ; } EXPECT_EQ ( instantiated . getTransitionMatrix ( ) . getRow ( row ) . end ( ) , instantiatedEntry ) ; } } EXPECT_EQ ( mdp -> getStateLabeling ( ) , instantiated . getStateLabeling ( ) ) ; EXPECT_EQ ( mdp -> getOptionalChoiceLabeling ( ) , instantiated . getOptionalChoiceLabeling ( ) ) ; storm :: modelchecker :: SparseMdp@@ PrctlModelChecker < storm :: models :: sparse :: Mdp < double >> modelchecker ( instantiated ) ; std :: unique_ptr < storm :: modelchecker :: CheckResult > chkResult = modelchecker . check ( * formulas [ 0 ] ) ; storm :: modelchecker :: ExplicitQuantitativeCheckResult < double > & quantitativeChkResult = chkResult -> asExplicitQuantitativeCheckResult < double > ( ) ; EXPECT_NEAR ( 0.3526@@ 577219 , quantitativeChkResult [ * instantiated . getInitialStates ( ) . begin ( ) ] , storm :: settings :: getModule < storm :: settings :: modules :: GeneralSettings > ( ) . getPrecision ( ) ) ; }
static void d3d9_free ( ) { capture_free ( ) ; if ( data . using_shtex ) { if ( data . d3d11_tex ) data . d3d11_tex -> Release ( ) ; if ( data . d3d11_context ) data . d3d11_context -> Release ( ) ; if ( data . d3d11_device ) data . d3d11_device -> Release ( ) ; if ( data . d3d9_copytex ) data . d3d9_copytex -> Release ( ) ; } else { for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( data . copy_surfaces [ i ] ) { if ( data . texture_mapped [ i ] ) data . copy_surfaces [ i ] -> UnlockRect ( ) ; data . copy_surfaces [ i ] -> Release ( ) ; } if ( data . render_targets [ i ] ) data . render_targets [ i ] -> Release ( ) ; if ( data . queries [ i ] ) data . queries [ i ] -> Release ( ) ; } } memset ( & data , 0 , sizeof ( data ) ) ; hlog ( " - - - - - - - - - - - - - - - - - ▁ d3d9 ▁ capture ▁ freed ▁ - - - - - - - - - - - - - - - - - " ) ; }
static DXGI_FORMAT d3d9_to_dxgi_format ( D3DFORMAT format ) { switch ( ( unsigned long ) format ) { case D3DFMT_@@ A2B10@@ G10@@ R10 : return DXGI_FORMAT_@@ R10@@ G10@@ B10@@ A2_UNORM ; case D3DFMT_A8R8G8B8 : return DXGI_FORMAT_B8G8R8@@ A8_UNORM ; case D3DFMT_@@ X8R8G8B8 : return DXGI_FORMAT_B8G8R8@@ X8_UNORM ; } return DXGI_FORMAT_@@ UNKNOWN ; }
static inline bool shex_init_d3d11 ( ) { PFN_D3D11_CREATE_DEVICE create_device ; createfactory1_t create_factory ; D3D_FEATURE_LEVEL level_used ; IDXGIFact@@ ory * factory ; IDXGI@@ Adapter * adapter ; HMODULE d3d11 ; HMODULE dxgi ; HRESULT hr ; d3d11 = load_system_library ( " d3d11 . dll " ) ; if ( ! d3d11 ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ D3D11" ) ; return false ; } dxgi = load_system_library ( " dxgi . dll " ) ; if ( ! dxgi ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ load ▁ DXG@@ I " ) ; return false ; } create_factory = ( createfactory1_t ) GetProcAddress ( dxgi , " CreateDXGIFactory@@ 1" ) ; if ( ! create_factory ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ CreateDXGIFactory@@ 1 ▁ address " ) ; return false ; } create_device = ( PFN_D3D11_CREATE_DEVICE ) GetProcAddress ( d3d11 , " D3D11CreateDevice " ) ; if ( ! create_device ) { hlog ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ D3D11CreateDevice ▁ address " ) ; return false ; } hr = create_factory ( __uuidof ( IDXGIFactory@@ 1 ) , ( void * * ) & factory ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ factory ▁ object " , hr ) ; return false ; } hr = factory -> EnumAdapt@@ ers ( 0 , & adapter ) ; factory -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ get ▁ adapter " , hr ) ; return false ; } hr = create_device ( adapter , D3D_DRI@@ VER_@@ TYPE_UNKNOWN , nullptr , 0 , feature_levels , sizeof ( feature_levels ) / sizeof ( D3D_FEATURE_LEVEL ) , D3D11@@ _SDK_VERSION , & data . d3d11_device , & level_used , & data . d3d11_context ) ; adapter -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ device " , hr ) ; return false ; } return true ; }
static inline bool d3d9_shtex_init_shtex ( ) { IDXGIResource * res ; HRESULT hr ; D3D11_TEXTURE@@ 2D_@@ DESC desc = { } ; desc . Width = data . cx ; desc . Height = data . cy ; desc . Format = data . dxgi_format ; desc . Mip@@ Levels = 1 ; desc . ArraySize = 1 ; desc . SampleDesc . Count = 1 ; desc . Usa@@ ge = D3D11_USAGE_@@ DEFAULT ; desc . Misc@@ Flags = D3D11_RESOURCE_MI@@ SC_SHAR@@ ED ; desc . BindFlags = D3D11_BIND_RENDER_@@ TARGET | D3D11_BIND_SH@@ ADER_@@ RESOURCE ; hr = data . d3d11_device -> CreateTexture2D ( & desc , nullptr , ( ID3D11@@ Texture2D * * ) & data . d3d11_tex ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ create ▁ D3D11 ▁ texture " , hr ) ; return false ; } hr = data . d3d11_tex -> QueryInterface ( __uuidof ( IDXGIResource ) , ( void * * ) & res ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ query ▁ IDXGIResource " , hr ) ; return false ; } hr = res -> GetShared@@ Handle ( & data . handle ) ; res -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ shtex : ▁ Failed ▁ to ▁ get ▁ shared ▁ handle " , hr ) ; return false ; } return true ; }
static inline bool d3d9_shtex_init_copytex ( ) { uint8_t * patch_addr = get_d3d9_p@@ atch_addr ( data . d3d9 , data . patch ) ; uint8_t saved_data [ MAX_PAT@@ CH_SIZE ] ; size_t patch_size = 0 ; IDirect3DTexture@@ 9 * tex ; DWORD protect_val ; HRESULT hr ; if ( patch_addr ) { patch_size = patch [ data . patch ] . size ; VirtualProtect ( patch_addr , patch_size , PAGE_EXEC@@ UTE_RE@@ ADWRITE , & protect_val ) ; memcpy ( saved_data , patch_addr , patch_size ) ; memcpy ( patch_addr , patch [ data . patch ] . data , patch_size ) ; } hr = data . device -> CreateTexture ( data . cx , data . cy , 1 , D3DUSAGE_@@ REN@@ DERTARGET , data . d3d9_format , D3DPOO@@ L_DEFAULT , & tex , & data . handle ) ; if ( patch_addr && patch_size ) { memcpy ( patch_addr , saved_data , patch_size ) ; VirtualProtect ( patch_addr , patch_size , protect_val , & protect_val ) ; } if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ create ▁ shared ▁ texture " , hr ) ; return false ; } hr = tex -> GetSurface@@ Level ( 0 , & data . d3d9_copytex ) ; tex -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shtex _ init _ copytex : ▁ Failed ▁ to ▁ get ▁ surface ▁ level " , hr ) ; return false ; } return true ; }
static bool d3d9_shtex_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = true ; if ( ! shex_init_d3d11 ( ) ) { return false ; } if ( ! d3d9_shtex_init_shtex ( ) ) { return false ; } if ( ! d3d9_shtex_init_copytex ( ) ) { return false ; } if ( ! capture_init_@@ shtex ( & data . shtex_info , window , cx , cy , data . cx , data . cy , data . dxgi_format , false , ( uintptr_t ) data . handle ) ) { return false ; } hlog ( " d3d9 ▁ shared ▁ texture ▁ capture ▁ successful " ) ; return true ; }
static bool d3d9_shmem_init_buffers ( size_t buffer ) { HRESULT hr ; hr = data . device -> CreateOff@@ screen@@ Plain@@ Surface ( data . cx , data . cy , data . d3d9_format , D3DPOO@@ L_SYSTEM@@ MEM , & data . copy_surfaces [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ surface " , hr ) ; return false ; } if ( buffer == 0 ) { D3DLOCKED_RECT rect ; hr = data . copy_surfaces [ buffer ] -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ lock ▁ " " buffer " , hr ) ; return false ; } data . pitch = rect . Pit@@ ch ; data . copy_surfaces [ buffer ] -> UnlockRect ( ) ; } hr = data . device -> CreateRender@@ Target ( data . cx , data . cy , data . d3d9_format , D3DMULTI@@ SAMP@@ LE_NONE , 0 , false , & data . render_targets [ buffer ] , nullptr ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ render ▁ " " target " , hr ) ; return false ; } hr = data . device -> CreateQuery ( D3DQUER@@ YTYPE_EVENT , & data . queries [ buffer ] ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ init _ buffers : ▁ Failed ▁ to ▁ create ▁ query " , hr ) ; return false ; } return true ; }
static bool d3d9_shmem_init ( uint32_t cx , uint32_t cy , HWND window ) { data . using_shtex = false ; for ( size_t i = 0 ; i < NUM_BUFFERS ; i ++ ) { if ( ! d3d9_shmem_init_buffers ( i ) ) { return false ; } } if ( ! capture_init_@@ shmem ( & data . shmem_info , window , cx , cy , data . cx , data . cy , data . pitch , data . dxgi_format , false ) ) { return false ; } hlog ( " d3d9 ▁ memory ▁ capture ▁ successful " ) ; return true ; }
static bool d3d9_get_swap_desc ( D3DPRESENT_PARAMETERS & pp ) { IDirect3DSwapChain9 * swap = nullptr ; HRESULT hr ; hr = data . device -> GetSwapChain ( 0 , & swap ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ swap ▁ chain " , hr ) ; return false ; } hr = swap -> GetPresent@@ Parameters ( & pp ) ; swap -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ get _ swap _ desc : ▁ Failed ▁ to ▁ get ▁ " " presentation ▁ parameters " , hr ) ; return false ; } return true ; }
static bool d3d9_init_format_backbuffer ( uint32_t & cx , uint32_t & cy , HWND & window ) { IDirect3DSurface9 * back_buffer = nullptr ; D3DPRESENT_PARAMETERS pp ; D3DSUR@@ FACE_@@ DESC desc ; HRESULT hr ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } hr = data . device -> GetRenderTarget ( 0 , & back_buffer ) ; if ( FAILED ( hr ) ) { return false ; } hr = back_buffer -> GetDesc ( & desc ) ; back_buffer -> Release ( ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ init _ format _ backbuffer : ▁ Failed ▁ to ▁ get ▁ " " backbuffer ▁ descriptor " , hr ) ; return false ; } data . d3d9_format = desc . Format ; data . dxgi_format = d3d9_to_dxgi_format ( desc . Format ) ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = desc . Width ; cy = desc . Height ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = desc . Width ; data . cy = desc . Height ; } return true ; }
static bool d3d9_init_format_swapchain ( uint32_t & cx , uint32_t & cy , HWND & window ) { D3DPRESENT_PARAMETERS pp ; if ( ! d3d9_get_swap_desc ( pp ) ) { return false ; } data . dxgi_format = d3d9_to_dxgi_format ( pp . BackBufferFormat ) ; data . d3d9_format = pp . BackBufferFormat ; data . using_scale = global_hook_info -> use_scale ; window = pp . hDeviceWindow ; cx = pp . BackBufferWidth ; cy = pp . BackBufferHeight ; if ( data . using_scale ) { data . cx = global_hook_info -> cx ; data . cy = global_hook_info -> cy ; } else { data . cx = pp . BackBufferWidth ; data . cy = pp . BackBufferHeight ; } return true ; }
static void d3d9_init ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; bool success ; uint32_t cx = 0 ; uint32_t cy = 0 ; HWND window = nullptr ; HRESULT hr ; data . d3d9 = get_system_module ( " d3d9 . dll " ) ; data . device = device ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { d3d9ex -> Release ( ) ; data . patch = - 1 ; } else { data . patch = get_d3d9_p@@ atch ( data . d3d9 ) ; } if ( ! d3d9_init_format_backbuffer ( cx , cy , window ) ) { if ( ! d3d9_init_format_swapchain ( cx , cy , window ) ) { return ; } } if ( global_hook_info -> force_shmem || ( ! d3d9ex && data . patch == - 1 ) ) { success = d3d9_shmem_init ( cx , cy , window ) ; } else { success = d3d9_shtex_init ( cx , cy , window ) ; } if ( ! success ) d3d9_free ( ) ; }
static inline HRESULT get_backbuffer ( IDirect3DDevice9 * device , IDirect3DSurface9 * * surface ) { static bool use_backbuffer = false ; static bool checked_exceptions = false ; if ( ! checked_exceptions ) { if ( _str@@ cmpi ( get_process_@@ name ( ) , " hotd _ ng . exe " ) == 0 ) use_backbuffer = true ; checked_exceptions = true ; } if ( use_backbuffer ) { return device -> GetBack@@ Buffer ( 0 , 0 , D3DBACK@@ BUFFER_TYPE_MON@@ O , surface ) ; } else { return device -> GetRenderTarget ( 0 , surface ) ; } }
static inline void d3d9_shtex_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; HRESULT hr ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; hr = data . device -> StretchRect ( backbuffer , nullptr , data . d3d9_copytex , nullptr , filter ) ; if ( FAILED ( hr ) ) hlog_hr ( " d3d9 _ shtex _ capture : ▁ StretchRect ▁ failed " , hr ) ; }
static inline void d3d9_shmem_capture_queue_copy ( ) { for ( int i = 0 ; i < NUM_BUFFERS ; i ++ ) { IDirect3DSurface9 * target = data . copy_surfaces [ i ] ; D3DLOCKED_RECT rect ; HRESULT hr ; if ( ! data . issued_queries [ i ] ) { continue ; } if ( data . queries [ i ] -> GetData ( 0 , 0 , 0 ) != S_OK ) { continue ; } data . issued_queries [ i ] = false ; hr = target -> LockRect ( & rect , nullptr , D3DLOCK_READONLY ) ; if ( SUCCEEDED ( hr ) ) { data . texture_mapped [ i ] = true ; shmem_copy_data ( i , rect . pBits ) ; } break ; } }
static inline void d3d9_shmem_capture ( IDirect3DSurface9 * backbuffer ) { D3DTEXTUREFILTERTYPE filter ; IDirect3DSurface9 * copy ; int next_tex ; HRESULT hr ; d3d9_shmem_capture_queue_copy ( ) ; next_tex = ( data . cur_tex == NUM_BUFFERS - 1 ) ? 0 : data . cur_tex + 1 ; filter = data . using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE ; copy = data . render_targets [ data . cur_tex ] ; hr = data . device -> StretchRect ( backbuffer , nullptr , copy , nullptr , filter ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ StretchRect ▁ failed " , hr ) ; return ; } if ( data . copy_wait < NUM_BUFFERS - 1 ) { data . copy_wait ++ ; } else { IDirect3DSurface9 * src = data . render_targets [ next_tex ] ; IDirect3DSurface9 * dst = data . copy_surfaces [ next_tex ] ; if ( shmem_texture_data_@@ lock ( next_tex ) ) { dst -> UnlockRect ( ) ; data . texture_mapped [ next_tex ] = false ; shmem_texture_data_@@ unlock ( next_tex ) ; } hr = data . device -> GetRenderTargetData ( src , dst ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ GetRenderTargetData ▁ " " failed " , hr ) ; } data . queries [ next_tex ] -> Issue ( D3DIS@@ SUE_END ) ; data . issued_queries [ next_tex ] = true ; } data . cur_tex = next_tex ; }
static void d3d9_capture ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { if ( capture_should_@@ stop ( ) ) { d3d9_free ( ) ; } if ( capture_should_init ( ) ) { d3d9_init ( device ) ; } if ( capture_ready ( ) ) { if ( data . using_shtex ) d3d9_shtex_capture ( backbuffer ) ; else d3d9_shmem_capture ( backbuffer ) ; } }
static inline void present_begin ( IDirect3DDevice9 * device , IDirect3DSurface9 * & backbuffer ) { HRESULT hr ; if ( ! present_recurse ) { hr = get_backbuffer ( device , & backbuffer ) ; if ( FAILED ( hr ) ) { hlog_hr ( " d3d9 _ shmem _ capture : ▁ Failed ▁ to ▁ get ▁ " " backbuffer " , hr ) ; } if ( ! global_hook_info -> capture_overlay ) { d3d9_capture ( device , backbuffer ) ; } } present_recurse ++ ; }
static inline void present_end ( IDirect3DDevice9 * device , IDirect3DSurface9 * backbuffer ) { present_recurse -- ; if ( ! present_recurse ) { if ( global_hook_info -> capture_overlay ) { if ( ! present_recurse ) d3d9_capture ( device , backbuffer ) ; } if ( backbuffer ) backbuffer -> Release ( ) ; } }
static HRESULT STDMETHODCALLTYPE hook_present ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present ) ; present_t call = ( present_t ) present . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region ) ; rehook ( & present ) ; present_end ( device , backbuffer ) ; return hr ; }
static HRESULT STDMETHODCALLTYPE hook_present_ex ( IDirect3DDevice9 * device , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; HRESULT hr ; if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; unhook ( & present_ex ) ; present_ex_t call = ( present_ex_t ) present_ex . call_addr ; hr = call ( device , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_ex ) ; present_end ( device , backbuffer ) ; return hr ; }
static HRESULT STDMETHODCALLTYPE hook_present_swap ( IDirect3DSwapChain9 * swap , CONST RECT * src_rect , CONST RECT * dst_rect , HWND override_window , CONST RGNDATA * dirty_region , DWORD flags ) { IDirect3DSurface9 * backbuffer = nullptr ; IDirect3DDevice9 * device = nullptr ; HRESULT hr ; if ( ! present_recurse ) { hr = swap -> GetDevice ( & device ) ; if ( SUCCEEDED ( hr ) ) { device -> Release ( ) ; } } if ( device ) { if ( ! hooked_reset ) setup_reset_hooks ( device ) ; present_begin ( device , backbuffer ) ; } unhook ( & present_swap ) ; present_swap_t call = ( present_swap_t ) present_swap . call_addr ; hr = call ( swap , src_rect , dst_rect , override_window , dirty_region , flags ) ; rehook ( & present_swap ) ; if ( device ) present_end ( device , backbuffer ) ; return hr ; }
static HRESULT STDMETHODCALLTYPE hook_reset ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset ) ; reset_t call = ( reset_t ) reset . call_addr ; hr = call ( device , params ) ; rehook ( & reset ) ; return hr ; }
static HRESULT STDMETHODCALLTYPE hook_reset_ex ( IDirect3DDevice9 * device , D3DPRESENT_PARAMETERS * params , D3DDISPLAYMODEEX * dmex ) { HRESULT hr ; if ( capture_active ( ) ) d3d9_free ( ) ; unhook ( & reset_ex ) ; reset_ex_t call = ( reset_ex_t ) reset_ex . call_addr ; hr = call ( device , params , dmex ) ; rehook ( & reset_ex ) ; return hr ; }
static void setup_reset_hooks ( IDirect3DDevice9 * device ) { IDirect3DDevice9Ex * d3d9ex = nullptr ; uintptr_t * vtable = * ( uintptr_t * * ) device ; HRESULT hr ; hook_init ( & reset , ( void * ) vtable [ 16 ] , ( void * ) hook_reset , " IDirect3DDevice9 : : Reset " ) ; rehook ( & reset ) ; hr = device -> QueryInterface ( __uuidof ( IDirect3DDevice9Ex ) , ( void * * ) & d3d9ex ) ; if ( SUCCEEDED ( hr ) ) { hook_init ( & reset_ex , ( void * ) vtable [ 132 ] , ( void * ) hook_reset_ex , " IDirect3DDevice9Ex : : ResetEx " ) ; rehook ( & reset_ex ) ; d3d9ex -> Release ( ) ; } hooked_reset = true ; }
static bool manually_get_d3d9_addrs ( HMODULE d3d9_module , void * * present_addr , void * * present_ex_addr , void * * present_swap_addr ) { d3d9create_ex_t create_ex ; D3DPRESENT_PARAMETERS pp ; HRESULT hr ; IDirect3DDevice9Ex * device ; IDirect3D9Ex * d3d9ex ; hlog ( " D3D9 ▁ values ▁ invalid , ▁ manu@@ ally ▁ obtain@@ ing " ) ; create_ex = ( d3d9create_ex_t ) GetProcAddress ( d3d9_module , " Direct3DCreate9Ex " ) ; if ( ! create_ex ) { hlog ( " Failed ▁ to ▁ load ▁ Direct3DCreate9Ex " ) ; return false ; } if ( FAILED ( create_ex ( D3D_SDK_VERSION , & d3d9ex ) ) ) { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ context " ) ; return false ; } memset ( & pp , 0 , sizeof ( pp ) ) ; pp . Windowed = 1 ; pp . SwapEffect = D3DSW@@ APEFFECT_@@ FLIP ; pp . BackBufferFormat = D3DFMT_A8R8G8B8 ; pp . BackBufferCount = 1 ; pp . hDeviceWindow = ( HWND ) dummy_window ; pp . Presentation@@ Interval = D3DPRESENT_INTERVAL_@@ IMMEDIATE ; hr = d3d9ex -> CreateDevice@@ Ex ( D3DADAP@@ TER_DEFAULT , D3DDEV@@ TYPE_HAL , dummy_window , D3DCREATE_@@ HARDWARE_@@ VERTEX@@ PROC@@ ESS@@ ING | D3DCREATE_@@ NOWINDOW@@ CHANGES , & pp , NULL , & device ) ; d3d9ex -> Release ( ) ; if ( SUCCEEDED ( hr ) ) { uintptr_t * vtable = * ( uintptr_t * * ) device ; IDirect3DSwapChain9 * swap ; * present_addr = ( void * ) vtable [ 17 ] ; * present_ex_addr = ( void * ) vtable [ 121 ] ; hr = device -> GetSwapChain ( 0 , & swap ) ; if ( SUCCEEDED ( hr ) ) { vtable = * ( uintptr_t * * ) swap ; * present_swap_addr = ( void * ) vtable [ 3 ] ; swap -> Release ( ) ; } device -> Release ( ) ; } else { hlog ( " Failed ▁ to ▁ create ▁ D3D9 ▁ device " ) ; return false ; } return true ; }
bool hook_d3d9 ( void ) { HMODULE d3d9_module = get_system_module ( " d3d9 . dll " ) ; uint32_t d3d9_size ; void * present_addr = nullptr ; void * present_ex_addr = nullptr ; void * present_swap_addr = nullptr ; if ( ! d3d9_module ) { return false ; } d3d9_size = module_size ( d3d9_module ) ; if ( global_hook_info -> offsets . d3d9 . present < d3d9_size && global_hook_info -> offsets . d3d9 . present_ex < d3d9_size && global_hook_info -> offsets . d3d9 . present_swap < d3d9_size ) { present_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present ) ; present_ex_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_ex ) ; present_swap_addr = get_offset_addr ( d3d9_module , global_hook_info -> offsets . d3d9 . present_swap ) ; } else { if ( ! dummy_window ) { return false ; } if ( ! manually_get_d3d9_addrs ( d3d9_module , & present_addr , & present_ex_addr , & present_swap_addr ) ) { hlog ( " Failed ▁ to ▁ get ▁ D3D9 ▁ values " ) ; return true ; } } if ( ! present_addr && ! present_ex_addr && ! present_swap_addr ) { hlog ( " Invalid ▁ D3D9 ▁ values " ) ; return true ; } if ( present_swap_addr ) { hook_init ( & present_swap , present_swap_addr , ( void * ) hook_present_swap , " IDirect3DSwapChain9 : : Present " ) ; rehook ( & present_swap ) ; } if ( present_ex_addr ) { hook_init ( & present_ex , present_ex_addr , ( void * ) hook_present_ex , " IDirect3DDevice9Ex : : Present@@ Ex " ) ; rehook ( & present_ex ) ; } if ( present_addr ) { hook_init ( & present , present_addr , ( void * ) hook_present , " IDirect3DDevice9 : : Present " ) ; rehook ( & present ) ; } hlog ( " Hooked ▁ D3D9" ) ; return true ; }
static UBool compareRules ( UVector * rules1 , UVector * rules2 ) { if ( rules1 == NULL && rules2 == NULL ) { return TRUE ; } else if ( rules1 == NULL || rules2 == NULL ) { return FALSE ; } int32_t size = rules1 -> size ( ) ; if ( size != rules2 -> size ( ) ) { return FALSE ; } for ( int32_t i = 0 ; i < size ; i ++ ) { TimeZoneRule * r1 = ( TimeZoneRule * ) rules1 -> elementAt ( i ) ; TimeZoneRule * r2 = ( TimeZoneRule * ) rules2 -> elementAt ( i ) ; if ( * r1 != * r2 ) { return FALSE ; } } return TRUE ; }
inline int hashPos2 ( int x , int y , int n ) { return ( ( x * 73856093 ) ^ ( y * 19349@@ 663 ) ) & ( n - 1 ) ; }
npc_jaina_or_sylvanas_intro_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; }
void DeleteGameObject ( ) { if ( GameObject * go = ObjectAccessor :: GetGameObject ( * _owner , _gameObjectGUID ) ) go -> Delete ( ) ; }
void DestroyIceWall ( ) { if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) me -> RemoveAurasDueToSpell ( SPELL_JAINA_DESTROY_ICE_WALL ) ; else me -> RemoveAurasDueToSpell ( SPELL_SYLVANAS_DESTROY_ICE_WALL ) ; _instance -> HandleGameObject ( _instance -> GetGuidData ( DATA_ICEWALL ) , true ) ; me -> m_Events . AddEvent ( new HoRGameObjectDeleteDelayEvent ( me , _instance -> GetGuidData ( DATA_ICEWALL ) ) , me -> m_Events . CalculateTime ( 5000 ) ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) wallTarget -> DespawnOrUnsummon ( ) ; }
void SummonIceWall ( ) { if ( _icewall < 4 ) { if ( Creature * lichking = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_THE_LICH_KING_ESCAPE ) ) ) { lichking -> StopMoving ( ) ; if ( Creature * wallTarget = me -> SummonCreature ( NPC_ICE_WAL@@ L_TARGET , IceWallTargetPosition [ _icewall ] , TEMPSUMMON_MANUAL_DESPAWN , 720000 ) ) lichking -> CastSpell ( wallTarget , SPELL_SUMMON_ICE_WALL ) ; lichking -> AI ( ) -> SetData ( DATA_ICEWALL , _icewall ) ; } } }
void AttackIceWall ( ) { if ( _icewall < 4 ) Talk ( SAY_JAINA_SYLVANAS_ESCAPE_2 + _icewall ) ; if ( Creature * wallTarget = ObjectAccessor :: GetCreature ( * me , _instance -> GetGuidData ( DATA_ICEWALL_TARGET ) ) ) me -> SetFacingToObject ( wallTarget ) ; if ( _instance -> GetData ( DATA_TEAM_IN_INSTANCE ) == ALLIANCE ) DoCast ( me , SPELL_JAINA_DESTROY_ICE_WALL , true ) ; else DoCast ( me , SPELL_SYLVANAS_DESTROY_ICE_WALL , true ) ; }
void DeleteAllFromThreatList ( Unit * target , ObjectGuid except ) { for ( Threat@@ Reference * ref : target -> GetThreat@@ Manager ( ) . GetModifi@@ ableThreatList ( ) ) if ( ref -> GetVictim ( ) -> GetGUID ( ) != except ) ref -> ClearThreat ( ) ; }
npc_the_lich_king_escape_horAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; _instance -> SetBossState ( DATA_THE_LICH_KING_ESCAPE , NOT_STARTED ) ; _summonsCount = 0 ; _icewall = 0 ; _despawn = false ; }
private : bool SelectVictim ( ) { if ( ! me -> IsInCombat ( ) ) return false ; if ( ! me -> HasReactState ( REACT_PASSIVE ) ) { if ( Unit * victim = me -> SelectVictim ( ) ) if ( ! me -> HasSpell@@ Focus ( ) && victim != me -> GetVictim ( ) ) AttackStart ( victim ) ; return me -> GetVictim ( ) != nullptr ; } else if ( me -> GetCombat@@ Manager ( ) . GetPv@@ ECombat@@ Refs ( ) . size ( ) < 2 && me -> HasAura ( SPELL_REMORSELESS_WINTER ) ) { EnterEvadeMode ( EVAD@@ E_REASON_@@ OTH@@ ER ) ; return false ; } return true ; }
npc_frostsworn_generalAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = creature -> GetInstanceScript ( ) ; }
void SummonClones ( ) { std :: list < Unit * > playerList ; SelectTarget@@ List ( playerList , 5 , SELECT_TARGET_MAXTHREAT , 0 , 0.0f , true ) ; for ( Unit * target : playerList ) { if ( Creature * reflection = me -> SummonCreature ( NPC_REFLECTION , * target , TEMPSUMMON_TIMED_@@ DESPAWN_OUT_@@ OF_COMBAT , 3000 ) ) { reflection -> SetImmuneToPC ( false ) ; target -> CastSpell ( reflection , SPELL_CLONE , true ) ; target -> CastSpell ( reflection , SPELL_GHOST_VISUAL , true ) ; reflection -> AI ( ) -> AttackStart ( target ) ; } } }
npc_uther_quel_delarAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; }
npc_quel_delar_swordAI ( Creature * creature ) : ScriptedAI ( creature ) { _instance = me -> GetInstanceScript ( ) ; me -> SetDisplay@@ Id ( me -> GetCreature@@ Template ( ) -> Modelid2 ) ; _intro = true ; }
void StartQuests ( SpellEffIndex ) { if ( Player * target = GetHitPlayer ( ) ) { if ( target -> GetTeam ( ) == ALLIANCE ) target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_@@ A , true ) ; else target -> CastSpell ( target , SPELL_START_HALLS_OF_REFLECTION_QUEST_@@ H , true ) ; } }
void SetDest ( SpellDestination & dest ) { WorldObject * target = GetExplTarget@@ WorldObject ( ) ; Position pos ( * target ) ; Position home = GetCaster ( ) -> ToCreature ( ) -> GetHo@@ mePosition ( ) ; if ( pos . IsInDist@@ 2d ( & home , 15.0f ) ) return ; float angle = pos . GetAb@@ soluteAngle ( & home ) ; float dist = GetSpellInfo ( ) -> Effects [ EFFECT_0 ] . Calc@@ Radius ( GetCaster ( ) ) ; target -> MovePosition ( pos , dist , angle ) ; dest . Relocate ( pos ) ; }
void HandlePeriodic ( AuraEffect const * ) { if ( ! urand ( 0 , 2 ) ) { if ( GetTarget ( ) -> GetEntry ( ) == NPC_GUNSHIP_CAN@@ NON_@@ HORDE ) GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_@@ HORDE , true ) ; else GetTarget ( ) -> CastSpell ( nullptr , SPELL_GUNSHIP_CANNON_FIRE_MISSILE_@@ ALLIANCE , true ) ; } }
void HandleReagent ( SpellEffIndex effIndex ) { PreventHitDefaultEffect ( effIndex ) ; GetHitUnit ( ) -> CastSpell ( GetCaster ( ) , GetSpellInfo ( ) -> Effects [ effIndex ] . TriggerSpell , Trigger@@ CastFlags ( TRIGGERED_@@ FULL_@@ MASK & ~ TRIGGERED_@@ IGNORE_@@ POWER_@@ AND_REAGENT_@@ COST ) ) ; }
void AddSC_@@ halls_of_reflection ( ) { new at_hor_intro_start ( ) ; new at_hor_waves_restarter ( ) ; new at_hor_impenetrable_door ( ) ; new at_hor_shadow_throne ( ) ; new at_hor_uther_quel_delar_start ( ) ; new npc_jaina_or_sylvanas_intro_hor ( ) ; new npc_jaina_or_sylvanas_escape_hor ( ) ; new npc_the_lich_king_escape_hor ( ) ; new npc_ghostly_priest ( ) ; new npc_phantom_mage ( ) ; new npc_phantom_hallucination ( ) ; new npc_shadowy_mercenary ( ) ; new npc_spectral_footman ( ) ; new npc_tortured_rifleman ( ) ; new npc_frostsworn_general ( ) ; new npc_spiritual_reflection ( ) ; new npc_raging_ghoul ( ) ; new npc_risen_witch_doctor ( ) ; new npc_lumbering_abomination ( ) ; new npc_uther_quel_delar ( ) ; new npc_quel_delar_sword ( ) ; new spell_hor_start_halls_of_reflection_quest_ae ( ) ; new spell_hor_evasion ( ) ; new spell_hor_gunship_cannon_fire ( ) ; RegisterSpellScript ( spell_hor_quel_delars_will ) ; }
AS_API const char * asGetLibrary@@ Version ( ) { return ANGELSCRIPT_VERSION_STRING " ▁ DEBUG " ; return ANGELSCRIPT_VERSION_STRING ; }
AS_API const char * asGetLibrary@@ Options ( ) { const char * string = " ▁ " " AS _ MAX _ PORTABILITY ▁ " " AS _ DEBUG ▁ " " AS _ NO _ CLASS _ METHODS ▁ " " AS _ USE _ DOUBLE _ AS _ FLOAT ▁ " " AS _ 64BIT _ PTR ▁ " " AS _ NO _ THREADS ▁ " " AS _ NO _ ATOMIC ▁ " " AS _ WIN ▁ " " AS _ LINUX ▁ " " AS _ MAC ▁ " " AS _ BSD ▁ " " AS _ XBOX ▁ " " AS _ XBOX360 ▁ " " AS _ PSP ▁ " " AS _ PS2 ▁ " " AS _ PS3 ▁ " " AS _ DC ▁ " " AS _ GC ▁ " " AS _ WII ▁ " " AS _ IPHONE ▁ " " AS _ ANDROID ▁ " " AS _ PPC ▁ " " AS _ PPC _ 64 ▁ " " AS _ X86 ▁ " " AS _ MIPS ▁ " " AS _ SH4 ▁ " " AS _ XEN@@ ON ▁ " " AS _ ARM ▁ " ; return string ; }
AS_API asIScriptEngine * asCreate@@ ScriptEngine ( asDWORD version ) { if ( ( version / 10000 ) != ( ANGELSCRIPT_VERSION / 10000 ) ) return 0 ; if ( ( version / 100 ) % 100 != ( ANGELSCRIPT_VERSION / 100 ) % 100 ) return 0 ; if ( ( version % 100 ) > ( ANGELSCRIPT_VERSION % 100 ) ) return 0 ; asASSERT ( sizeof ( asBYTE ) == 1 ) ; asASSERT ( sizeof ( asWORD ) == 2 ) ; asASSERT ( sizeof ( asDWORD ) == 4 ) ; asASSERT ( sizeof ( asQWORD ) == 8 ) ; asASSERT ( sizeof ( asPWORD ) == sizeof ( void * ) ) ; asASSERT ( sizeof ( bool ) == AS_SIZEOF_@@ BOOL ) ; asASSERT ( true == VALUE_@@ OF_BOOLEAN_@@ TRUE ) ; asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x000@@ 10203 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x000@@ 1020@@ 304050@@ 607 ) ) ; asASSERT ( * ( asDWORD * ) " \x00\x01\x02\x03" == 0x03020100 ) ; asASSERT ( * ( asQWORD * ) " \x00\x01\x02\x03\x04\x05\x06\x07" == I64 ( 0x07060@@ 504030@@ 20100 ) ) ; return asNEW ( asCScriptEngine ) ( ) ; }
