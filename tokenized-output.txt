%struct.TYPE_4__ = type STRUCT 1 * i8 
 %struct.fuse_args = type STRUCT 2 i32 i32 
 @options = common dso_local global STRUCT 1 * i8 zeroinitializer 
 @pifs_opts = common dso_local global i32 0 
 @stderr = common dso_local global i32 0 
 @.str = private unnamed_addr constant ARR 3 66 x i8 c "%s: ▁ Metadata ▁ directory ▁ must ▁ be ▁ specified ▁ with ▁ -o ▁ mdd=<directory>\0A\00" 
 @R_OK = common dso_local global i32 0 
 @W_OK = common dso_local global i32 0 
 @X_OK = common dso_local global i32 0 
 @.str.1 = private unnamed_addr constant ARR 3 47 x i8 c "%s: ▁ Cannot ▁ access ▁ metadata ▁ directory ▁ '%s': ▁ %s\0A\00" 
 @errno = common dso_local global i32 0 
 @pifs_ops = common dso_local global i32 0 
 define dso_local i32 @main ( i32 %0 , * * i8 %1 ) #0 { 
 %3 = alloca i32 
 %4 = alloca i32 
 %5 = alloca * * i8 
 %6 = alloca i32 
 %7 = alloca STRUCT 2 i32 i32 
 store i32 0 %3 
 store i32 %0 %4 
 store * * i8 %1 %5 
 %8 = load i32 %4 
 %9 = load * * i8 %5 
 %10 = call i64 @FUSE_ARGS_INIT ( i32 %8 , * * i8 %9 ) 
 %11 = bitcast * STRUCT 2 i32 i32 %7 to * i64 
 store i64 %10 %11 
 %12 = call i32 @memset ( * STRUCT 1 * i8 @options , i32 0 , i32 4 ) 
 %13 = load i32 @pifs_opts 
 %14 = call i32 @fuse_opt_parse ( * STRUCT 2 i32 i32 %7 , * STRUCT 1 * i8 @options , i32 %13 , * i32 null ) 
 %15 = icmp eq i32 %14 , -1 
 br i1 %15 , label %16 , label %17 
 16: 
 store i32 -1 %3 
 br label %52 
 17: 
 %18 = load * i8 getelementptr inbounds ( STRUCT 1 * i8 @options , i32 0 , i32 0 ) 
 %19 = icmp ne * i8 %18 , null 
 br i1 %19 , label %26 , label %20 
 20: 
 %21 = load i32 @stderr 
 %22 = load * * i8 %5 
 %23 = getelementptr inbounds * i8 %22 , i64 0 
 %24 = load * i8 %23 
 %25 = call i32 ( i32 , * i8 , * i8 , ... ) @fprintf ( i32 %21 , * i8 getelementptr inbounds ( ARR 3 66 x i8 @.str , i64 0 , i64 0 ) , * i8 %24 ) 
 store i32 -1 %3 
 br label %52 
 26: 
 %27 = load * i8 getelementptr inbounds ( STRUCT 1 * i8 @options , i32 0 , i32 0 ) 
 %28 = load i32 @R_OK 
 %29 = load i32 @W_OK 
 %30 = or i32 %28 , %29 
 %31 = load i32 @X_OK 
 %32 = or i32 %30 , %31 
 %33 = call i32 @access ( * i8 %27 , i32 %32 ) 
 %34 = icmp eq i32 %33 , -1 
 br i1 %34 , label %35 , label %44 
 35: 
 %36 = load i32 @stderr 
 %37 = load * * i8 %5 
 %38 = getelementptr inbounds * i8 %37 , i64 0 
 %39 = load * i8 %38 
 %40 = load * i8 getelementptr inbounds ( STRUCT 1 * i8 @options , i32 0 , i32 0 ) 
 %41 = load i32 @errno 
 %42 = call * i8 @strerror ( i32 %41 ) 
 %43 = call i32 ( i32 , * i8 , * i8 , ... ) @fprintf ( i32 %36 , * i8 getelementptr inbounds ( ARR 3 47 x i8 @.str.1 , i64 0 , i64 0 ) , * i8 %39 , * i8 %40 , * i8 %42 ) 
 store i32 -1 %3 
 br label %52 
 44: 
 %45 = getelementptr inbounds STRUCT 2 i32 i32 %7 , i32 0 , i32 1 
 %46 = load i32 %45 
 %47 = getelementptr inbounds STRUCT 2 i32 i32 %7 , i32 0 , i32 0 
 %48 = load i32 %47 
 %49 = call i32 @fuse_main ( i32 %46 , i32 %48 , * i32 @pifs_ops , * i32 null ) 
 store i32 %49 %6 
 %50 = call i32 @fuse_opt_free_args ( * STRUCT 2 i32 i32 %7 ) 
 %51 = load i32 %6 
 store i32 %51 %3 
 br label %52 
 52: 
 %53 = load i32 %3 
 ret i32 %53 
 } 
 declare dso_local i64 @FUSE_ARGS_INIT ( i32 , * * i8 ) #1 
 declare dso_local i32 @memset ( * STRUCT 1 * i8 , i32 , i32 ) #1 
 declare dso_local i32 @fuse_opt_parse ( * STRUCT 2 i32 i32 , * STRUCT 1 * i8 , i32 , * i32 ) #1 
 declare dso_local i32 @fprintf ( i32 , * i8 , * i8 , ... ) #1 
 declare dso_local i32 @access ( * i8 , i32 ) #1 
 declare dso_local * i8 @strerror ( i32 ) #1 
 declare dso_local i32 @fuse_main ( i32 , i32 , * i32 , * i32 ) #1 
 declare dso_local i32 @fuse_opt_free_args ( * STRUCT 2 i32 i32 ) #1 
